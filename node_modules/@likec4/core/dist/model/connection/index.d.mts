import { C as Connection } from '../../shared/core.DKhRkHRN.mjs';
export { D as DeploymentConnectionModel, f as deployment } from '../../shared/core.tpvDGvdC.mjs';
export { C as ConnectionModel, f as model } from '../../shared/core.DE9qzhn8.mjs';
import { I as IterableContainer, R as ReorderedArray } from '../../shared/core.DB0Ue5Wx.mjs';
import '../../shared/core.BfCKSW-g.mjs';
import 'type-fest';
import '../../shared/core.CAgYpDtM.mjs';
import '../../shared/core.DC5IAaDT.mjs';
import '../../shared/core.D00YbOhQ.mjs';
import '../../shared/core.C_3y3eqV.mjs';
import '../../types/fqnRef.mjs';
import '../../shared/core.Dojz4bvg.mjs';
import '../../types/expression-model.mjs';
import '../../shared/core.BPGOjone.mjs';
import '../../shared/core.CywrQs86.mjs';
import '../../shared/core.osFs8tU7.mjs';

/**
 * Check if connection is nested inside another connection
 * (i.e. between descendants)
 */
declare function isNestedConnection<T extends {
    id: string;
}>(parent: WithSourceTarget<NoInfer<T>>): (nested: WithSourceTarget<T>) => boolean;
declare function isNestedConnection<T extends {
    id: string;
}>(nested: WithSourceTarget<T>, parent: WithSourceTarget<T>): boolean;
type ConnectionElemId = Connection<{
    readonly id: string;
}, any>;
declare function findDeepestNestedConnection<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): C | null;
declare function sortDeepestFirst<C extends ConnectionElemId>(connections: ReadonlyArray<C>): C[];
type WithBoundary = {
    id: string;
    boundary: null | {
        id: string;
    };
};
declare function sortConnectionsByBoundaryHierarchy(sort?: 'asc' | 'desc'): <T extends WithBoundary, A extends IterableContainer<T>>(array: A) => ReorderedArray<A>;
declare function sortConnectionsByBoundaryHierarchy<T extends WithBoundary, A extends IterableContainer<T>>(array: A, sort?: 'asc' | 'desc'): ReorderedArray<A>;
/**
 * Find connections that includes given connection (i.e between it's ancestors)
 */
declare function findAscendingConnections<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): Array<C>;
/**
 * Find connections that given connection includes (i.e between it's descendants)
 */
declare function findDescendantConnections<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): Array<C>;
declare function mergeConnections<C extends IterableContainer<Connection<any, any>>>(connections: C): Array<C[number]>;
/**
 * Excludes the values existing in `other` array.
 * The output maintains the same order as the input.
 */
declare function differenceConnections<C extends Connection<any, any>>(source: Iterable<C>, exclude: Iterable<C>): C[];
type WithSourceTarget<T = unknown> = {
    source: T;
    target: T;
};
declare function hasSameSourceTarget<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameSourceTarget<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
declare function hasSameSource<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameSource<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
declare function hasSameTarget<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameTarget<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
type WithId<T> = {
    id: T;
};
declare function isOutgoing<T extends string>(source: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isOutgoing<T extends string>(a: WithSourceTarget<WithId<T>>, source: WithId<T>): boolean;
declare function isIncoming<T extends string>(target: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isIncoming<T extends string>(a: WithSourceTarget<WithId<T>>, target: WithId<T>): boolean;
declare function isAnyInOut<T extends string>(source: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isAnyInOut<T extends string>(a: WithSourceTarget<WithId<T>>, source: WithId<T>): boolean;

export { Connection, differenceConnections, findAscendingConnections, findDeepestNestedConnection, findDescendantConnections, hasSameSource, hasSameSourceTarget, hasSameTarget, isAnyInOut, isIncoming, isNestedConnection, isOutgoing, mergeConnections, sortConnectionsByBoundaryHierarchy, sortDeepestFirst };
