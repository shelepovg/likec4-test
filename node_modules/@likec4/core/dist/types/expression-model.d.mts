import { W as WhereOperator, C as Color, f as RelationshipLineType, g as RelationshipArrowType, P as PredicateSelector, h as ElementShape, B as BorderStyle, e as ShapeSize } from '../shared/core.DC5IAaDT.mjs';
import { A as Any, S as StrictViewId, E as ElementKind, T as Tag } from '../shared/core.D00YbOhQ.mjs';
import { E as ExclusiveUnion } from '../shared/core.DB0Ue5Wx.mjs';
import { FqnRef } from './fqnRef.mjs';
import { M as MarkdownOrString, I as Icon } from '../shared/core.C_3y3eqV.mjs';
import 'type-fest';

type AnyAux = Any;
declare namespace ModelFqnExpr {
    type Wildcard = {
        wildcard: true;
    };
    function isWildcard<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelFqnExpr.Wildcard;
    interface Ref<M extends AnyAux> {
        ref: FqnRef.ModelRef<M>;
        selector?: PredicateSelector;
    }
    function isModelRef<A extends AnyAux>(ref: ModelExpression<A>): ref is ModelFqnExpr.Ref<A>;
    interface ElementKindExpr<A extends AnyAux = AnyAux> {
        elementKind: ElementKind<A>;
        isEqual: boolean;
    }
    function isElementKindExpr<A extends AnyAux>(expr: ModelExpression<A>): expr is ElementKindExpr<A>;
    interface ElementTagExpr<A extends AnyAux> {
        elementTag: Tag<A>;
        isEqual: boolean;
    }
    function isElementTagExpr<A extends AnyAux>(expr: ModelExpression<A>): expr is ElementTagExpr<A>;
    type NonWildcard<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Ref: Ref<A>;
        ElementKind: ElementKindExpr<A>;
        ElementTag: ElementTagExpr<A>;
    }>;
    interface Where<A extends AnyAux = AnyAux> {
        where: {
            expr: ExclusiveUnion<{
                Wildcard: Wildcard;
                Ref: Ref<A>;
                ElementKind: ElementKindExpr<A>;
                ElementTag: ElementTagExpr<A>;
            }>;
            condition: WhereOperator<A>;
        };
    }
    function isWhere<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelFqnExpr.Where<A>;
    interface Custom<A extends AnyAux = AnyAux> {
        custom: {
            expr: OrWhere<A>;
            title?: string;
            description?: MarkdownOrString;
            technology?: string;
            notation?: string;
            shape?: ElementShape;
            color?: Color;
            icon?: Icon;
            border?: BorderStyle;
            opacity?: number;
            navigateTo?: StrictViewId<A>;
            multiple?: boolean;
            size?: ShapeSize;
            padding?: ShapeSize;
            textSize?: ShapeSize;
        };
    }
    function isCustom<A extends AnyAux>(expr: ModelExpression<A>): expr is Custom<A>;
    function is<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelFqnExpr<A>;
    type OrWhere<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Wildcard: ModelFqnExpr.Wildcard;
        Ref: ModelFqnExpr.Ref<A>;
        ElementKind: ElementKindExpr<A>;
        ElementTag: ElementTagExpr<A>;
        Where: ModelFqnExpr.Where<A>;
    }>;
    type Any<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Wildcard: Wildcard;
        Ref: Ref<A>;
        ElementKind: ElementKindExpr<A>;
        ElementTag: ElementTagExpr<A>;
        Where: Where<A>;
        Custom: Custom<A>;
    }>;
    function unwrap<A extends AnyAux>(expr: ModelFqnExpr.Any<A>): Wildcard | Ref<A> | ElementKindExpr<A> | ElementTagExpr<A>;
}
type ModelFqnExpr<A extends AnyAux = AnyAux> = ExclusiveUnion<{
    Wildcard: ModelFqnExpr.Wildcard;
    Ref: ModelFqnExpr.Ref<A>;
    ElementKind: ModelFqnExpr.ElementKindExpr<A>;
    ElementTag: ModelFqnExpr.ElementTagExpr<A>;
}>;
declare namespace ModelRelationExpr {
    type Endpoint<A extends AnyAux = AnyAux> = ModelFqnExpr.Where<A>['where']['expr'];
    interface Direct<A extends AnyAux = AnyAux> {
        source: Endpoint<A>;
        target: Endpoint<A>;
        isBidirectional?: boolean;
    }
    function isDirect<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.Direct<A>;
    interface Incoming<A extends AnyAux = AnyAux> {
        incoming: Endpoint<A>;
    }
    function isIncoming<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.Incoming<A>;
    interface Outgoing<A extends AnyAux = AnyAux> {
        outgoing: Endpoint<A>;
    }
    function isOutgoing<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.Outgoing<A>;
    interface InOut<A extends AnyAux = AnyAux> {
        inout: Endpoint<A>;
    }
    function isInOut<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.InOut<A>;
    interface Where<A extends AnyAux = AnyAux> {
        where: {
            expr: ExclusiveUnion<{
                Direct: ModelRelationExpr.Direct<A>;
                Incoming: ModelRelationExpr.Incoming<A>;
                Outgoing: ModelRelationExpr.Outgoing<A>;
                InOut: ModelRelationExpr.InOut<A>;
            }>;
            condition: WhereOperator<A>;
        };
    }
    function isWhere<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.Where<A>;
    interface Custom<A extends AnyAux = AnyAux> {
        customRelation: {
            expr: OrWhere<A>;
            title?: string;
            description?: string;
            technology?: string;
            notation?: string;
            navigateTo?: StrictViewId<A>;
            notes?: string;
            color?: Color;
            line?: RelationshipLineType;
            head?: RelationshipArrowType;
            tail?: RelationshipArrowType;
        };
    }
    function isCustom<A extends AnyAux>(expr: ModelExpression<A>): expr is Custom<A>;
    function is<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr<A>;
    type OrWhere<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Direct: Direct<A>;
        Incoming: Incoming<A>;
        Outgoing: Outgoing<A>;
        InOut: InOut<A>;
        Where: Where<A>;
    }>;
    type Any<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Direct: Direct<A>;
        Incoming: Incoming<A>;
        Outgoing: Outgoing<A>;
        InOut: InOut<A>;
        Where: Where<A>;
        Custom: Custom<A>;
    }>;
    function unwrap<A extends AnyAux>(expr: ModelRelationExpr.Any<A>): Direct<A> | Incoming<A> | Outgoing<A> | InOut<A>;
}
type ModelRelationExpr<A extends AnyAux = AnyAux> = ExclusiveUnion<{
    Direct: ModelRelationExpr.Direct<A>;
    Incoming: ModelRelationExpr.Incoming<A>;
    Outgoing: ModelRelationExpr.Outgoing<A>;
    InOut: ModelRelationExpr.InOut<A>;
}>;
/**
 * Represents a version 2 expression which can be one of several types.
 *
 * @template D - The type for the deployment FQN, defaults to `Fqn`.
 * @template M - The type for the model FQN, defaults to `Fqn`.
 */
type ModelExpression<A extends AnyAux = AnyAux> = ExclusiveUnion<{
    Wildcard: ModelFqnExpr.Wildcard;
    Ref: ModelFqnExpr.Ref<A>;
    ElementKind: ModelFqnExpr.ElementKindExpr<A>;
    ElementTag: ModelFqnExpr.ElementTagExpr<A>;
    Custom: ModelFqnExpr.Custom<A>;
    Direct: ModelRelationExpr.Direct<A>;
    Incoming: ModelRelationExpr.Incoming<A>;
    Outgoing: ModelRelationExpr.Outgoing<A>;
    InOut: ModelRelationExpr.InOut<A>;
    Where: ModelExpression.Where<A>;
    CustomRelation: ModelRelationExpr.Custom<A>;
}>;
declare namespace ModelExpression {
    type Where<A extends AnyAux = AnyAux> = ModelFqnExpr.Where<A> | ModelRelationExpr.Where<A>;
    function isWhere<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelExpression.Where<A>;
    function isRelationWhere<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.Where<A>;
    function isFqnExprWhere<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelFqnExpr.Where<A>;
    function isFqnExpr<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelFqnExpr.Any<A>;
    function isRelationExpr<A extends AnyAux>(expr: ModelExpression<A>): expr is ModelRelationExpr.Any<A>;
}

export { ModelExpression, ModelFqnExpr, ModelRelationExpr };
