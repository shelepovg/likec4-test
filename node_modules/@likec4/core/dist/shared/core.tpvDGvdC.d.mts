import { C as Connection, c as customInspectSymbol } from './core.DKhRkHRN.mjs';
import { e as DeploymentElementModel, h as RelationshipsAccum, D as DeploymentNodeModel, R as RelationshipModel, b as DeploymentRelationModel } from './core.BfCKSW-g.mjs';
import { A as Any, z as EdgeId } from './core.D00YbOhQ.mjs';
import { c as IteratorLike } from './core.DB0Ue5Wx.mjs';

/**
 * Connection is ephemeral entity, result of a resolving relationships between source and target.
 * Includes direct relationships and/or between their nested elements.
 */
declare class DeploymentConnectionModel<A extends Any = Any> implements Connection<DeploymentElementModel<A>, EdgeId> {
    readonly source: DeploymentElementModel<A>;
    readonly target: DeploymentElementModel<A>;
    readonly relations: RelationshipsAccum<A>;
    readonly id: EdgeId;
    constructor(source: DeploymentElementModel<A>, target: DeploymentElementModel<A>, relations: RelationshipsAccum<A>);
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    get expression(): string;
    private _boundary;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    get boundary(): DeploymentNodeModel<A> | null;
    nonEmpty(): boolean;
    [customInspectSymbol](_depth: any, _inspectOptions: any, _inspect: any): string;
    toString(): string;
    /**
     * Check if connection contains deployment relation,
     * that is directly connected to source or target.
     */
    hasDirectDeploymentRelation(): boolean;
    values(): IteratorLike<RelationshipModel<A> | DeploymentRelationModel<A>>;
    /**
     * Merge with another connections, if it has the same source and target.
     * Returns new connection with union of relationships.
     */
    mergeWith(others: DeploymentConnectionModel<A>[]): DeploymentConnectionModel<A>;
    /**
     * Merge with another connection, if it has the same source and target.
     * Returns new connection with union of relationships.
     */
    mergeWith(other: DeploymentConnectionModel<A>): DeploymentConnectionModel<A>;
    difference(other: DeploymentConnectionModel<A>): DeploymentConnectionModel<A>;
    intersect(other: DeploymentConnectionModel<A>): DeploymentConnectionModel<A>;
    equals(other: Connection): boolean;
    /**
     * Creates a clone of the current `DeploymentConnectionModel` instance with optional overrides.
     * if `null` is provided in overrides, the corresponding relation set will be empty.
     */
    update(overrides?: {
        model?: ReadonlySet<RelationshipModel<A>> | null;
        deployment?: ReadonlySet<DeploymentRelationModel<A>> | null;
    }): DeploymentConnectionModel<A>;
}

/**
 * Resolve connection from source to target
 * If direction is `both`, also look for reverse connection
 *
 * @default direction directed
 */
declare function findConnection<M extends Any>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction: 'directed'): readonly [DeploymentConnectionModel<M>] | readonly [];
declare function findConnection<M extends Any>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction: 'both'): readonly [DeploymentConnectionModel<M>, DeploymentConnectionModel<M>] | readonly [DeploymentConnectionModel<M>] | readonly [];
declare function findConnection<M extends Any>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction?: 'directed' | 'both'): readonly [DeploymentConnectionModel<M>, DeploymentConnectionModel<M>] | readonly [DeploymentConnectionModel<M>] | readonly [];
/**
 * Resolve all connections between element and others
 * By default, look for both directions.
 *
 * @default direction both
 */
declare function findConnectionsBetween<M extends Any>(element: DeploymentElementModel<M>, others: Iterable<DeploymentElementModel<NoInfer<M>>>, direction?: 'directed' | 'both'): readonly DeploymentConnectionModel<M>[];
/**
 * Resolve all connections within a given set of elements
 */
declare function findConnectionsWithin<M extends Any>(elements: Iterable<DeploymentElementModel<M>>): readonly DeploymentConnectionModel<M>[];

declare const find_findConnection: typeof findConnection;
declare const find_findConnectionsBetween: typeof findConnectionsBetween;
declare const find_findConnectionsWithin: typeof findConnectionsWithin;
declare namespace find {
  export { find_findConnection as findConnection, find_findConnectionsBetween as findConnectionsBetween, find_findConnectionsWithin as findConnectionsWithin };
}

export { DeploymentConnectionModel as D, findConnection as a, findConnectionsBetween as b, findConnectionsWithin as c, find as f };
