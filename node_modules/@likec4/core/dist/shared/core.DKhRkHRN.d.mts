import { E as ElementModel, e as DeploymentElementModel } from './core.BfCKSW-g.mjs';
import { A as Any } from './core.D00YbOhQ.mjs';
import { F as Fqn } from './core.C_3y3eqV.mjs';

interface Connection<Elem = ElementModel<Any> | DeploymentElementModel<Any>, Id = string> {
    readonly id: Id;
    readonly source: Elem;
    readonly target: Elem;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    readonly boundary: Elem | null;
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    readonly expression: string;
    mergeWith(this: Connection<Elem, Id>, other: typeof this): typeof this;
    nonEmpty(): boolean;
    difference(this: Connection<Elem, Id>, other: typeof this): typeof this;
    intersect(this: Connection<Elem, Id>, other: typeof this): typeof this;
    equals(other: Connection): boolean;
}
declare namespace Connection {
    type ConnectionPredicate = <C extends Connection<{
        id: string;
    }, any>>(connection: C) => boolean;
    type ElementId = Fqn | string;
    export const isInside: (fqn: ElementId) => ConnectionPredicate;
    export const isDirectedBetween: (source: ElementId, target: ElementId) => ConnectionPredicate;
    export const isAnyBetween: (source: ElementId, target: ElementId) => ConnectionPredicate;
    export const isIncoming: (target: ElementId) => ConnectionPredicate;
    export const isOutgoing: (source: ElementId) => ConnectionPredicate;
    export const isAnyInOut: (source: ElementId) => ConnectionPredicate;
    export {  };
}

declare const customInspectSymbol: unique symbol;

export { Connection as C, customInspectSymbol as c };
