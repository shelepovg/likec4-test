import { Simplify, IsAny } from 'type-fest';
import { A as Any, U as Unknown, W as WithDescriptionAndTech, s as WithOptionalTags, u as WithOptionalLinks, v as WithMetadata, w as WithNotation, x as DeploymentFqn, y as DeploymentKind, F as Fqn, n as _type, m as _stage, o as _layout, S as StrictViewId, N as NodeId, z as EdgeId, k as ExtractOnStage, M as ModelStage, P as ProjectId, a as ElementId, D as DeploymentId, d as AnyParsed, i as UnknownParsed, V as ViewId$1, b as AnyComputed, g as UnknownComputed, c as AnyLayouted, h as UnknownLayouted, f as SpecAux, e as Aux, B as Never } from './core.D00YbOhQ.mjs';
import { a as NonEmptyReadonlyArray, N as NonEmptyArray, E as ExclusiveUnion, K as KeysOf } from './core.DB0Ue5Wx.mjs';
import { E as ElementStyle, A as AbstractRelationship, F as ViewType, B as ViewAutoLayout, J as ViewWithNotation, H as BaseViewProperties, K as ViewWithHash, O as ComputedNode, P as ComputedEdge, a6 as DynamicViewDisplayVariant, I as BaseParsedViewProperties, o as AnyIncludePredicate, p as AnyExcludePredicate, q as AnyViewRuleStyle, y as ViewRuleAutoLayout, ah as ParsedElementView, a7 as ParsedDynamicView, U as ComputedElementView, W as ComputedDeploymentView, X as ComputedDynamicView, n as LikeC4Project, S as Specification, f as Element, R as Relationship, M as ModelGlobals } from './core.Dojz4bvg.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { F as Fqn$1, V as ViewId, M as MarkdownOrString, d as RelationId } from './core.C_3y3eqV.mjs';
import { B as BBox, P as Point, X as XYPoint } from './core.BPGOjone.mjs';
import { j as Expression, F as FqnExpr } from './core.DC5IAaDT.mjs';

interface DeploymentNode<A extends Any = Unknown> extends WithDescriptionAndTech, WithOptionalTags<A>, WithOptionalLinks, WithMetadata<A>, WithNotation {
    element?: never;
    readonly id: DeploymentFqn<A>;
    readonly kind: DeploymentKind<A>;
    readonly title: string;
    readonly style: ElementStyle;
}
interface DeployedInstance<A extends Any = Unknown> extends WithDescriptionAndTech, WithOptionalTags<A>, WithOptionalLinks, WithMetadata<A>, WithNotation {
    kind?: never;
    /**
     * Format: `<DeploymentNode Fqn>.<Instance Id>`
     * i.e parent fqn is deployment target
     */
    readonly id: DeploymentFqn<A>;
    readonly element: Fqn<A>;
    readonly title?: string;
    readonly style: ElementStyle;
}
type DeploymentElement<A extends Any = Unknown> = DeploymentNode<A> | DeployedInstance<A>;
type DeploymentElementRef<A extends Any = Unknown> = {
    readonly id: DeploymentFqn<A>;
    readonly element?: Fqn<A>;
};
declare function isDeploymentNode<A extends Any>(el: DeploymentElement<A>): el is DeploymentNode<A>;
declare function isDeployedInstance<A extends Any>(el: DeploymentElement<A>): el is DeployedInstance<A>;
/**
 * Relationship in deployment model
 */
interface DeploymentRelationship<A extends Any = Unknown> extends AbstractRelationship<A> {
    readonly source: FqnRef.DeploymentRef<A>;
    readonly target: FqnRef.DeploymentRef<A>;
}
/**
 * Backward compatibility alias
 * @deprecated Use {@link DeploymentRelationship} instead
 */
type DeploymentRelation<A extends Any = Unknown> = DeploymentRelationship<A>;

type LayoutedViewDriftReason = 'not-exists' | 'type-changed' | 'nodes-added' | 'nodes-removed' | 'nodes-drift' | 'edges-added' | 'edges-removed' | 'edges-drift';
type DiagramNodeDriftReason = 'removed' | 'added' | 'label-changed' | 'modelRef-changed' | 'parent-changed' | 'children-changed' | 'became-compound' | 'became-leaf' | 'shape-changed';
type DiagramEdgeDriftReason = 'removed' | 'added' | 'label-added' | 'label-removed' | 'label-changed' | 'notes-changed' | 'direction-changed' | 'source-changed' | 'target-changed';
type ViewManualLayoutSnapshotPerType = {
    readonly [_type]: 'element';
    readonly viewOf?: Fqn$1;
    readonly extends?: ViewId;
} | {
    readonly [_type]: 'deployment';
} | {
    readonly [_type]: 'dynamic';
    readonly sequenceLayout: LayoutedDynamicView.Sequence.Layout;
};
type ViewManualLayoutSnapshot<Type extends ViewType = ViewType> = Simplify<ViewManualLayoutSnapshotPerType & {
    readonly id: ViewId;
    readonly title: string | null;
    readonly description: MarkdownOrString | null;
    readonly [_type]: Type;
    readonly [_stage]: 'layouted';
    readonly hash: string;
    readonly nodes: ReadonlyArray<DiagramNode>;
    readonly edges: ReadonlyArray<DiagramEdge>;
    readonly bounds: BBox;
    readonly autoLayout: ViewAutoLayout;
} & ViewWithNotation>;

interface DiagramNode<A extends Any = Any> extends ComputedNode<A>, BBox {
    /**
     * Absolute X coordinate
     */
    x: number;
    /**
     * Absolute Y coordinate
     */
    y: number;
    width: number;
    height: number;
    /**
     * Bounding box of label
     * (Absolute coordinates)
     */
    labelBBox: BBox;
    /**
     * List of reasons causing node drift
     */
    drifts?: NonEmptyReadonlyArray<DiagramNodeDriftReason> | null;
}
interface DiagramEdge<A extends Any = Any> extends ComputedEdge<A> {
    /**
     * Bezier points
     * (Absolute coordinates)
     */
    points: NonEmptyArray<Point>;
    /**
     * Control points to adjust the edge
     * (Absolute coordinates)
     */
    controlPoints?: NonEmptyArray<XYPoint> | null;
    /**
     * Bounding box of label
     * (Absolute coordinates)
     */
    labelBBox?: BBox | null;
    /**
     * List of reasons causing edge drift
     */
    drifts?: NonEmptyReadonlyArray<DiagramEdgeDriftReason> | null;
}
/**
 * Type of the layout
 * - `auto`: auto-layouted from the current sources
 * - `manual`: read from the manually layouted snapshot
 */
type LayoutType = 'auto' | 'manual';
interface BaseLayoutedViewProperties<A extends Any> extends BaseViewProperties<A>, ViewWithHash, ViewWithNotation {
    readonly [_stage]: 'layouted';
    /**
     * If undefined, view does not have any manual layouts, and is auto-layouted
     */
    readonly [_layout]?: LayoutType;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ReadonlyArray<DiagramNode<A>>;
    readonly edges: ReadonlyArray<DiagramEdge<A>>;
    readonly bounds: BBox;
    /**
     * If diagram has manual layout
     * But was changed and layout should be recalculated
     * @deprecated manual layout v2 uses {@link drifts}
     */
    readonly hasLayoutDrift?: boolean;
    /**
     * List of reasons causing layout drift
     * If undefined or null, there is no layout drift or view is auto-layouted
     */
    readonly drifts?: NonEmptyReadonlyArray<LayoutedViewDriftReason> | null;
}
interface LayoutedElementView<A extends Any = Any> extends BaseLayoutedViewProperties<A> {
    readonly [_type]: 'element';
    readonly viewOf?: Fqn<A>;
    readonly extends?: StrictViewId<A>;
}
interface LayoutedDeploymentView<A extends Any = Any> extends BaseLayoutedViewProperties<A> {
    readonly [_type]: 'deployment';
}
interface LayoutedDynamicView<A extends Any = Any> extends BaseLayoutedViewProperties<A> {
    readonly [_type]: 'dynamic';
    /**
     * Default variant of this dynamic view
     * - `diagram`: display as a regular likec4 view (default if not specified)
     * - `sequence`: display as a sequence diagram
     */
    readonly variant: DynamicViewDisplayVariant;
    /**
     * Sequence layout of this dynamic view
     */
    readonly sequenceLayout: LayoutedDynamicView.Sequence.Layout;
}
declare namespace LayoutedDynamicView {
    namespace Sequence {
        interface ActorPort {
            readonly id: string;
            readonly cx: number;
            readonly cy: number;
            readonly height: number;
            readonly type: 'target' | 'source';
            readonly position: 'left' | 'right' | 'top' | 'bottom';
        }
        interface Actor {
            readonly id: NodeId;
            readonly x: number;
            readonly y: number;
            readonly width: number;
            readonly height: number;
            readonly ports: ReadonlyArray<ActorPort>;
        }
        interface Compound {
            readonly id: NodeId;
            /**
             * Original node id, since multiple compound nodes can be built from one node
             */
            readonly origin: NodeId;
            readonly x: number;
            readonly y: number;
            readonly width: number;
            readonly height: number;
            readonly depth: number;
        }
        interface ParallelArea {
            readonly parallelPrefix: string;
            readonly x: number;
            readonly y: number;
            readonly width: number;
            readonly height: number;
        }
        interface Step {
            readonly id: EdgeId;
            readonly labelBBox?: {
                width: number;
                height: number;
            } | undefined;
            readonly sourceHandle: string;
            readonly targetHandle: string;
        }
        interface Layout {
            readonly actors: ReadonlyArray<Actor>;
            /**
             * Steps in the sequence diagram (filtered edges with compound nodes)
             */
            readonly steps: ReadonlyArray<Step>;
            readonly compounds: ReadonlyArray<Compound>;
            readonly parallelAreas: ReadonlyArray<ParallelArea>;
            readonly bounds: BBox;
        }
    }
}

/**
 * Predicates scoped to deployment model
 */
interface DeploymentViewIncludePredicate<A extends Any = Unknown> extends AnyIncludePredicate<Expression<A>> {
}
interface DeploymentViewExcludePredicate<A extends Any = Unknown> extends AnyExcludePredicate<Expression<A>> {
}
type DeploymentViewPredicate<A extends Any = Unknown> = DeploymentViewIncludePredicate<A> | DeploymentViewExcludePredicate<A>;
interface DeploymentViewRuleStyle<A extends Any = Unknown> extends AnyViewRuleStyle<FqnExpr<A>> {
}
type DeploymentViewRule<A extends Any = Unknown> = ExclusiveUnion<{
    Include: DeploymentViewIncludePredicate<A>;
    Exclude: DeploymentViewExcludePredicate<A>;
    Style: DeploymentViewRuleStyle<A>;
    AutoLayout: ViewRuleAutoLayout;
}>;
interface ParsedDeploymentView<A extends Any = Unknown> extends BaseParsedViewProperties<A> {
    [_type]: 'deployment';
    readonly rules: DeploymentViewRule<A>[];
}

type ParsedView<A extends Any = Any> = ParsedElementView<A> | ParsedDeploymentView<A> | ParsedDynamicView<A>;

type ComputedView<A extends Any = Any> = ComputedElementView<A> | ComputedDeploymentView<A> | ComputedDynamicView<A>;
type LayoutedView<A extends Any = Any> = LayoutedElementView<A> | LayoutedDeploymentView<A> | LayoutedDynamicView<A>;
type ProcessedView<A extends Any = Any> = ComputedView<A> | LayoutedView<A>;

type AnyView<A extends Any = Any> = ParsedElementView<A> | ParsedDeploymentView<A> | ParsedDynamicView<A> | ComputedElementView<A> | ComputedDeploymentView<A> | ComputedDynamicView<A> | LayoutedElementView<A> | LayoutedDeploymentView<A> | LayoutedDynamicView<A>;
type ViewOnStage<V extends AnyView<Any>, T extends ModelStage> = Extract<V, {
    [_stage]: T;
}>;
type ViewWithType<V extends AnyView<Any>, T extends ViewType> = Extract<V, {
    [_type]: T;
}>;
type ViewRule<A extends Any = Any> = ParsedView<A>['rules'][number];
type ViewRulePredicate<A extends Any = Any> = Extract<ViewRule<A>, {
    include: any[];
} | {
    exclude: any[];
}>;
declare function isViewRulePredicate<V extends ViewRule<any>>(rule: V): rule is Extract<V, {
    include: any[];
} | {
    exclude: any[];
}>;
declare function isViewRuleStyle<V extends ViewRule<any>>(rule: V): rule is Extract<V, {
    targets: any[];
    style: {};
}>;
declare function isComputedView<V extends AnyView<any>>(view: V): view is ExtractOnStage<V, 'computed'>;
declare function isDiagramView<V extends AnyView<any>>(view: V): view is ExtractOnStage<V, 'layouted'>;

declare function isElementView<V extends AnyView<any>>(view: V): view is ViewWithType<V, 'element'>;
declare function isScopedElementView<V extends AnyView<any>>(view: V): view is ViewWithType<V, 'element'> & {
    viewOf: Fqn<Any>;
};
declare function isExtendsElementView<V extends AnyView<any>>(view: V): view is ViewWithType<V, 'element'> & {
    extends: StrictViewId<Any>;
};
declare function isDeploymentView<V extends AnyView<any>>(view: V): view is ViewWithType<V, 'deployment'>;
declare function isDynamicView<V extends AnyView<any>>(view: V): view is ViewWithType<V, 'dynamic'>;

/**
 * Represents a LikeC4 model data, in different stages of processing
 * - {@link ParsedLikeC4ModelData} - parsed from DSL or result from Builder
 * - {@link ComputedLikeC4ModelData} - computed from parsed model
 * - {@link LayoutedLikeC4ModelData} - layouted from computed model
 *
 * !IMPORTANT: This is a low-level type, use `LikeC4Model` instead.
 */
interface BaseLikeC4ModelData<A extends Any> {
    [_stage]: A['Stage'];
    projectId: ProjectId<A>;
    project: LikeC4Project;
    specification: Specification<A>;
    elements: Record<ElementId<A>, Element<A>>;
    deployments: {
        elements: Record<DeploymentId<A>, DeploymentElement<A>>;
        relations: Record<RelationId, DeploymentRelationship<A>>;
    };
    relations: Record<RelationId, Relationship<A>>;
    globals: ModelGlobals;
    imports: Record<string, NonEmptyArray<Element<A>>>;
}
type AuxFromLikeC4ModelData<D> = D extends BaseLikeC4ModelData<infer A extends Any> ? IsAny<A> extends true ? never : A : never;
interface ParsedLikeC4ModelData<A extends AnyParsed = UnknownParsed> extends BaseLikeC4ModelData<A> {
    [_stage]: 'parsed';
    views: Record<ViewId$1<A>, ParsedView<A>>;
}
interface ComputedLikeC4ModelData<A extends AnyComputed = UnknownComputed> extends BaseLikeC4ModelData<A> {
    [_stage]: 'computed';
    views: Record<ViewId$1<A>, ComputedView<A>>;
    /**
     * If project contains saved manual layouts
     */
    manualLayouts?: Record<ViewId, ViewManualLayoutSnapshot>;
}
interface LayoutedLikeC4ModelData<A extends AnyLayouted = UnknownLayouted> extends BaseLikeC4ModelData<A> {
    [_stage]: 'layouted';
    views: Record<ViewId$1<A>, LayoutedView<A>>;
    /**
     * If this model contains saved manual layouts
     */
    manualLayouts?: Record<ViewId, ViewManualLayoutSnapshot>;
}
type LikeC4ModelData<A extends Any> = ParsedLikeC4ModelData<A> | ComputedLikeC4ModelData<A> | LayoutedLikeC4ModelData<A>;

/**
 * JSON representation of {@link Specification}
 */
interface SpecificationDump {
    elements: {
        [kind: string]: object;
    };
    tags?: {
        [tag: string]: object;
    };
    deployments?: {
        [kind: string]: object;
    };
    relationships?: {
        [kind: string]: object;
    };
    metadataKeys?: string[];
    customColors?: {
        [kind: string]: object;
    };
}
type SpecTypesFromDump<J> = J extends SpecificationDump ? SpecAux<KeysOf<J['elements']>, KeysOf<J['deployments']>, KeysOf<J['relationships']>, KeysOf<J['tags']>, J['metadataKeys'] extends readonly [string, ...string[]] ? J['metadataKeys'][number] : never> : SpecAux<never, never, never, never, never>;
/**
 * Dump differs from {@link ParsedLikeC4ModelData} by the fact that it is computed or layouted
 */
type LikeC4ModelDump = {
    [_stage]?: 'computed' | 'layouted';
    projectId?: string;
    project?: ProjectDump;
    specification: SpecificationDump;
    elements?: {
        [kind: string]: object;
    };
    deployments: {
        elements?: {
            [kind: string]: object;
        };
        relations?: {};
    };
    views?: {
        [kind: string]: object;
    };
    relations?: {};
    globals?: {
        predicates?: {};
        dynamicPredicates?: {};
        styles?: {};
    };
    imports?: {};
};
type ProjectDump = {
    id: string;
    name?: string;
    title?: string | undefined;
};
type AuxFromDump<D> = D extends LikeC4ModelDump ? Aux<D[_stage] extends infer S extends 'computed' | 'layouted' ? S : 'computed' | 'layouted' | 'parsed', KeysOf<D['elements']>, KeysOf<D['deployments']['elements']>, KeysOf<D['views']>, D['projectId'] extends infer PID extends string ? PID : never, SpecTypesFromDump<D['specification']>> : Never;

interface RichTextEmpty {
    readonly isEmpty: true;
    readonly isMarkdown: false;
    readonly nonEmpty: false;
    readonly $source: null;
    readonly text: null;
    readonly md: null;
    readonly html: null;
    equals(other: unknown): boolean;
}
interface RichTextNonEmpty {
    readonly isEmpty: false;
    readonly nonEmpty: true;
    readonly isMarkdown: boolean;
    readonly $source: MarkdownOrString;
    readonly text: string;
    readonly md: string;
    readonly html: string;
    equals(other: unknown): boolean;
}
type RichTextOrEmpty = RichTextNonEmpty | RichTextEmpty;
/**
 * RichText is a class that represents a potentially markdown string.
 * It can be either a plain text or a markdown.
 * It is used to represent the content of a node or a link.
 */
declare class RichText {
    private static getOrCreateFromText;
    private static getOrCreateFromMarkdown;
    /**
     * Creates and memoizes a RichText instance.
     * @see ElementModel.description
     * @example
     *
     *  get description(): RichTextOrEmpty {
     *    return RichText.memoize(this, 'description', this.$element.description)
     *  }
     */
    static memoize(obj: object, tag: symbol | string, source: MarkdownOrString | null | undefined): RichTextOrEmpty;
    /**
     * Creates a RichText instance from a source.
     */
    static from(source: RichTextOrEmpty | MarkdownOrString | string | null | undefined): RichTextOrEmpty;
    /**
     * This is a workaround for the fact that we need instance of RichText for `instanceof` checks
     * It is invalid inheritance (returning `null` from getters), and we cast to @see RichTextEmpty
     */
    static EMPTY: RichTextEmpty;
    readonly $source: Readonly<MarkdownOrString> | null;
    readonly isEmpty: boolean;
    readonly nonEmpty: boolean;
    readonly isMarkdown: boolean;
    /**
     * Private constructor to prevent direct instantiation.
     * Use {@link RichText.from} or {@link RichText.memoize} instead.
     */
    private constructor();
    /**
     * Returns the text content of the rich text.
     * If the source is a string, it returns the string.
     * If the source is a markdown, it returns the markdown.
     */
    get text(): string;
    /**
     * Returns the markdown content of the rich text.
     * If the source is a string, it returns the string.
     * If the source is a markdown, it returns the markdown.
     */
    get md(): string;
    /**
     * Returns the html content of the rich text.
     * If the source is a string, it returns the string.
     * If the source is a markdown, it returns the HTML.
     */
    get html(): string;
    equals(other: unknown): boolean;
}

export { type DeploymentViewRule as $, type AuxFromLikeC4ModelData as A, isComputedView as B, type ComputedLikeC4ModelData as C, type DeploymentNode as D, isElementView as E, isScopedElementView as F, isExtendsElementView as G, isDeploymentView as H, isDynamicView as I, type DiagramNode as J, type DiagramEdge as K, type LayoutedView as L, type LayoutType as M, type LayoutedElementView as N, type LayoutedDeploymentView as O, type ParsedLikeC4ModelData as P, LayoutedDynamicView as Q, RichText as R, type SpecificationDump as S, type LayoutedViewDriftReason as T, type DiagramNodeDriftReason as U, type ViewManualLayoutSnapshot as V, type DiagramEdgeDriftReason as W, type DeploymentViewIncludePredicate as X, type DeploymentViewExcludePredicate as Y, type DeploymentViewPredicate as Z, type DeploymentViewRuleStyle as _, type RichTextEmpty as a, type ParsedDeploymentView as a0, type RichTextOrEmpty as b, type LayoutedLikeC4ModelData as c, type LikeC4ModelData as d, type DeployedInstance as e, type DeploymentElement as f, type DeploymentElementRef as g, isDeployedInstance as h, isDeploymentNode as i, type DeploymentRelationship as j, type DeploymentRelation as k, type SpecTypesFromDump as l, type LikeC4ModelDump as m, type ProjectDump as n, type AuxFromDump as o, type ParsedView as p, isDiagramView as q, type ComputedView as r, type ProcessedView as s, type AnyView as t, type ViewOnStage as u, type ViewWithType as v, type ViewRule as w, type ViewRulePredicate as x, isViewRulePredicate as y, isViewRuleStyle as z };
