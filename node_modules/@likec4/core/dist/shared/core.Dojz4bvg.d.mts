import { Tagged, NonEmptyTuple, IsNever, PartialDeep, WritableDeep, Except } from 'type-fest';
import { h as ElementShape, C as Color, B as BorderStyle, e as ShapeSize, S as SpacingSize, d as TextSize, f as RelationshipLineType, g as RelationshipArrowType, T as ThemeColor, G as ColorLiteral, Q as CustomColorDefinitions, a as LikeC4Theme, b as LikeC4StyleDefaults } from './core.DC5IAaDT.mjs';
import { A as Any, s as WithOptionalTags, u as WithOptionalLinks, S as StrictViewId, m as _stage, n as _type, F as Fqn, R as RelationKind, W as WithDescriptionAndTech, v as WithMetadata, w as WithNotation, E as ElementKind, T as Tag, y as DeploymentKind, C as MetadataKey, G as WithTags, x as DeploymentFqn } from './core.D00YbOhQ.mjs';
import { N as NonEmptyArray, E as ExclusiveUnion, a as NonEmptyReadonlyArray, L as Link } from './core.DB0Ue5Wx.mjs';
import { M as MarkdownOrString, I as Icon, d as RelationId, T as Tag$1, P as ProjectId, j as NodeId, k as EdgeId, n as StepEdgeKind } from './core.C_3y3eqV.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { ModelExpression, ModelFqnExpr } from '../types/expression-model.mjs';
import { P as Point, X as XYPoint, B as BBox } from './core.BPGOjone.mjs';

interface AnyIncludePredicate<Expr> {
    include: Expr[];
    exclude?: never;
}
interface AnyExcludePredicate<Expr> {
    include?: never;
    exclude: Expr[];
}
interface AnyViewRuleStyle<Expr> {
    targets: Expr[];
    notation?: string;
    style: {
        border?: BorderStyle;
        opacity?: number;
        multiple?: boolean;
        size?: ShapeSize;
        padding?: SpacingSize;
        textSize?: TextSize;
        color?: Color;
        shape?: ElementShape;
        icon?: Icon;
    };
}
interface ViewRuleGlobalStyle {
    styleId: GlobalStyleID;
}
declare function isViewRuleGlobalStyle(rule: object): rule is ViewRuleGlobalStyle;
interface ViewRuleGlobalPredicateRef {
    predicateId: GlobalPredicateId;
}
declare function isViewRuleGlobalPredicateRef(rule: object): rule is ViewRuleGlobalPredicateRef;
type RankValue = 'max' | 'min' | 'same' | 'sink' | 'source';
interface ViewRuleRank<Expr> {
    targets: Expr[];
    rank: RankValue;
}
type AutoLayoutDirection = 'TB' | 'BT' | 'LR' | 'RL';
declare function isAutoLayoutDirection(autoLayout: unknown): autoLayout is AutoLayoutDirection;
interface ViewRuleAutoLayout {
    direction: AutoLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare function isViewRuleAutoLayout(rule: object): rule is ViewRuleAutoLayout;
interface ViewAutoLayout {
    direction: ViewRuleAutoLayout['direction'];
    rankSep?: number;
    nodeSep?: number;
}
/**
 * v1 Manual layout of a view, stored in the block comment to the view definition.
 * Keeping this type for backward compatibility and migration purposes.
 *
 * @deprecated Use {@link ViewManualLayoutSnapshot} instead
 */
type ViewManualLayout = {
    readonly hash: string;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: Record<string, {
        isCompound: boolean;
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    readonly edges: Record<string, {
        points: NonEmptyArray<Point>;
        controlPoints?: NonEmptyArray<XYPoint>;
        labelBBox?: BBox;
    }>;
};
type ViewType = 'element' | 'dynamic' | 'deployment';
interface BaseViewProperties<A extends Any> extends WithOptionalTags<A>, WithOptionalLinks {
    readonly id: StrictViewId<A>;
    readonly title: string | null;
    readonly description: MarkdownOrString | null;
    /**
     * Source file containing this view, relative to the project root.
     * Undefined if the view is auto-generated.
     */
    readonly sourcePath?: string | undefined;
}
interface BaseParsedViewProperties<A extends Any> extends BaseViewProperties<A> {
    /**
     * Internal field to identify the stage of the view.
     * This is used to create the correct type of the view.
     */
    readonly [_stage]: 'parsed';
    /**
     * URI to the source file of this view.
     * Undefined if the view is auto-generated.
     */
    readonly docUri?: string | undefined;
}
type NodeNotation = {
    kinds: string[];
    shape: ElementShape;
    color: Color;
    title: string;
};
interface ViewWithNotation {
    notation?: {
        nodes: NodeNotation[];
    };
}
interface ViewWithHash {
    /**
     * Hash of the view object.
     * This is used to detect changes in layout
     */
    hash: string;
}

/**
 * Predicates scoped to logical model
 */
interface ElementViewIncludePredicate<A extends Any = Any> extends AnyIncludePredicate<ModelExpression<A>> {
}
interface ElementViewExcludePredicate<A extends Any = Any> extends AnyExcludePredicate<ModelExpression<A>> {
}
type ElementViewPredicate<A extends Any = Any> = ElementViewIncludePredicate<A> | ElementViewExcludePredicate<A>;
interface ElementViewRuleGroup<A extends Any = Any> {
    groupRules: Array<ElementViewPredicate<A> | ElementViewRuleGroup<A>>;
    title: string | null;
    color?: Color;
    border?: BorderStyle;
    opacity?: number;
    multiple?: boolean;
    size?: ShapeSize;
    padding?: SpacingSize;
    textSize?: TextSize;
}
declare function isViewRuleGroup<A extends Any>(rule: ElementViewRule<A>): rule is ElementViewRuleGroup<A>;
interface ElementViewRuleStyle<A extends Any = Any> extends AnyViewRuleStyle<ModelFqnExpr<A>> {
}
interface ElementViewRuleRank<A extends Any = Any> extends ViewRuleRank<ModelFqnExpr<A>> {
}
declare function isViewRuleRank<A extends Any>(rule: ElementViewRule<A>): rule is ElementViewRuleRank<A>;
type ElementViewRule<A extends Any = Any> = ExclusiveUnion<{
    IncludePredicate: ElementViewIncludePredicate<A>;
    ExcludePredicate: ElementViewExcludePredicate<A>;
    Group: ElementViewRuleGroup<A>;
    Style: ElementViewRuleStyle<A>;
    GlobalStyle: ViewRuleGlobalStyle;
    GlobalPredicateRef: ViewRuleGlobalPredicateRef;
    AutoLayout: ViewRuleAutoLayout;
    Rank: ElementViewRuleRank<A>;
}>;
interface ParsedElementView<A extends Any = Any> extends BaseParsedViewProperties<A> {
    [_type]: 'element';
    readonly rules: ElementViewRule<A>[];
    readonly viewOf?: Fqn<A>;
    readonly extends?: StrictViewId<A>;
}

interface DynamicStep<A extends Any = Any> {
    readonly source: Fqn<A>;
    readonly target: Fqn<A>;
    readonly title?: string | null;
    readonly kind?: RelationKind<A>;
    readonly description?: MarkdownOrString;
    readonly technology?: string;
    readonly notation?: string;
    readonly notes?: MarkdownOrString;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly isBackward?: boolean;
    readonly navigateTo?: StrictViewId<A>;
    /**
     * Path to the AST node relative to the view body ast
     * Used to locate the step in the source code
     */
    readonly astPath: string;
}
interface DynamicStepsSeries<A extends Any = Any> {
    readonly seriesId: string;
    readonly __series: NonEmptyReadonlyArray<DynamicStep<A>>;
}
interface DynamicStepsParallel<A extends Any = Any> {
    readonly parallelId: string;
    readonly __parallel: NonEmptyReadonlyArray<DynamicStep<A> | DynamicStepsSeries<A>>;
}
declare function getParallelStepsPrefix(id: string): string | null;
type DynamicViewStep<A extends Any = Any> = ExclusiveUnion<{
    Step: DynamicStep<A>;
    Series: DynamicStepsSeries<A>;
    Parallel: DynamicStepsParallel<A>;
}>;
declare function isDynamicStep<A extends Any>(step: DynamicViewStep<A> | undefined): step is DynamicStep<A>;
declare function isDynamicStepsParallel<A extends Any>(step: DynamicViewStep<A> | undefined): step is DynamicStepsParallel<A>;
declare function isDynamicStepsSeries<A extends Any>(step: DynamicViewStep<A> | undefined): step is DynamicStepsSeries<A>;
interface DynamicViewIncludeRule<A extends Any = Any> {
    include: ModelFqnExpr.Any<A>[];
}
type DynamicViewRule<A extends Any = Any> = ExclusiveUnion<{
    Include: DynamicViewIncludeRule<A>;
    GlobalPredicateRef: ViewRuleGlobalPredicateRef;
    ElementViewRuleStyle: ElementViewRuleStyle<A>;
    GlobalStyle: ViewRuleGlobalStyle;
    AutoLayout: ViewRuleAutoLayout;
}>;
type DynamicViewDisplayVariant = 'diagram' | 'sequence';
interface ParsedDynamicView<A extends Any = Any> extends BaseParsedViewProperties<A> {
    [_type]: 'dynamic';
    /**
     * How to display the dynamic view
     * - `diagram`: display as a regular likec4 view
     * - `sequence`: display as a sequence diagram
     *
     * @default 'diagram'
     */
    readonly variant?: DynamicViewDisplayVariant;
    readonly steps: DynamicViewStep<A>[];
    readonly rules: DynamicViewRule<A>[];
}

type GlobalPredicateId = Tagged<string, 'GlobalPredicateId'>;
type GlobalPredicates<A extends Any = Any> = NonEmptyArray<ElementViewPredicate<A>>;
type GlobalDynamicPredicates<A extends Any = Any> = NonEmptyArray<DynamicViewIncludeRule<A>>;
type GlobalStyleID = Tagged<string, 'GlobalStyleID'>;
type GlobalStyles<A extends Any = Any> = NonEmptyTuple<ElementViewRuleStyle<A>>;
interface ModelGlobals<A extends Any = Any> {
    readonly predicates: Record<GlobalPredicateId, GlobalPredicates<A>>;
    readonly dynamicPredicates: Record<GlobalPredicateId, GlobalDynamicPredicates<A>>;
    readonly styles: Record<GlobalStyleID, GlobalStyles<A>>;
}

interface ElementStyle {
    readonly icon?: Icon;
    readonly shape?: ElementShape;
    readonly color?: Color;
    readonly border?: BorderStyle;
    /**
     * In percentage 0-100, 0 is fully transparent
     *
     * @default 100
     */
    readonly opacity?: number;
    /**
     * If true, the element is rendered as multiple shapes
     * @default false
     */
    readonly multiple?: boolean;
    /**
     * Shape size
     *
     * @default 'md'
     */
    readonly size?: ShapeSize;
    readonly padding?: SpacingSize;
    readonly textSize?: TextSize;
}
type WithSizes = Pick<ElementStyle, 'size' | 'padding' | 'textSize'>;
/**
 * Ensures that the sizes are set to default values if they are not set
 */
declare function ensureSizes<S extends WithSizes>({ size, padding, textSize, ...rest }: S, defaultSize?: "xs" | "sm" | "md" | "lg" | "xl"): Omit<S, 'size' | 'padding' | 'textSize'> & Required<WithSizes>;
interface Element<A extends Any = Any> extends WithDescriptionAndTech, WithOptionalTags<A>, WithOptionalLinks, WithMetadata<A>, WithNotation {
    readonly id: Fqn<A>;
    readonly kind: ElementKind<A>;
    readonly title: string;
    readonly style: ElementStyle;
}
interface AbstractRelationship<A extends Any> extends WithDescriptionAndTech, WithOptionalTags<A>, WithOptionalLinks, WithMetadata<A> {
    readonly id: RelationId;
    readonly title?: string | null;
    readonly kind?: RelationKind<A>;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly navigateTo?: StrictViewId<A>;
}
/**
 * Relationship between two model elements
 */
interface Relationship<A extends Any = Any> extends AbstractRelationship<A> {
    readonly source: FqnRef.ModelRef<A>;
    readonly target: FqnRef.ModelRef<A>;
}
/**
 * Backward compatibility alias
 * @deprecated Use {@link Relationship} instead
 */
type ModelRelation<A extends Any = Any> = Relationship<A>;

/**
 * Element and deployment kind specification
 */
interface ElementSpecification {
    tags?: Tag$1[];
    title?: string;
    summary?: MarkdownOrString;
    description?: MarkdownOrString;
    technology?: string;
    notation?: string;
    links?: NonEmptyArray<Link>;
    style: {
        shape?: ElementShape;
        icon?: Icon;
        color?: Color;
        border?: BorderStyle;
        opacity?: number;
        size?: ShapeSize;
        padding?: SpacingSize;
        textSize?: TextSize;
        multiple?: boolean;
    };
}
interface TagSpecification {
    color: ThemeColor | ColorLiteral;
}
/**
 * Checks if tag color is defined in the specification
 * Expects HEX, `rgb(...)` or `rgba(...)` color
 */
declare function isTagColorSpecified(spec: string | TagSpecification): spec is {
    color: ColorLiteral;
};
interface RelationshipSpecification {
    technology?: string;
    notation?: string;
    color?: Color;
    line?: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
}
type Specification<A> = A extends Any ? {
    tags: {
        [key in Tag<A>]: TagSpecification;
    };
    elements: {
        [key in ElementKind<A>]: Partial<ElementSpecification>;
    };
    deployments: {
        [key in DeploymentKind<A>]: Partial<ElementSpecification>;
    };
    relationships: {
        [key in RelationKind<A>]: Partial<RelationshipSpecification>;
    };
    metadataKeys?: IsNever<MetadataKey<A>> extends true ? never : MetadataKey<A>[];
    customColors?: CustomColorDefinitions;
} : never;

type LikeC4ProjectTheme = PartialDeep<WritableDeep<LikeC4Theme>, {
    recurseIntoArrays: false;
    allowUndefinedInNonTupleArrays: false;
}>;
type LikeC4ProjectStyleDefaults = PartialDeep<WritableDeep<LikeC4StyleDefaults>, {
    recurseIntoArrays: false;
    allowUndefinedInNonTupleArrays: false;
}>;
interface LikeC4ProjectStylesConfig {
    theme?: LikeC4ProjectTheme;
    defaults?: LikeC4ProjectStyleDefaults;
}
interface LikeC4ProjectManualLayoutsConfig {
    outDir: string;
}
/**
 * Configuration of the project, as read from the config file.
 * LikeC4 projects encapsulate models, and can import from each other
 */
interface LikeC4Project {
    /**
     * ID of the project, casted to {@link scalar.ProjectId}
     */
    readonly id: ProjectId;
    title?: string;
    /**
     * Custom styles
     */
    styles?: LikeC4ProjectStylesConfig | undefined;
    /**
     * Configuration for manual layouts snapshots
     */
    manualLayouts?: LikeC4ProjectManualLayoutsConfig | undefined;
}

type ComputedNodeStyle = Except<ElementStyle, 'icon' | 'shape' | 'color', {
    requireExactProps: true;
}>;
interface ComputedNode<A extends Any = Any> extends WithTags<A>, WithOptionalLinks {
    id: NodeId;
    kind: ElementKind<A> | DeploymentKind<A> | '@group';
    parent: NodeId | null;
    /**
     * Reference to model element
     */
    modelRef?: Fqn<A>;
    /**
     * Reference to deployment element
     */
    deploymentRef?: DeploymentFqn<A>;
    title: string;
    /**
     * Description of the node
     * either summary or description
     */
    description?: MarkdownOrString | null;
    technology?: string | null;
    children: NodeId[];
    inEdges: EdgeId[];
    outEdges: EdgeId[];
    shape: ElementShape;
    color: Color;
    icon?: Icon | null;
    style: ComputedNodeStyle;
    navigateTo?: StrictViewId<A> | null;
    level: number;
    depth?: number | null;
    /**
     * If this node was customized in the view
     */
    isCustomized?: boolean;
    notation?: string | null;
}
interface ComputedEdge<A extends Any = Any> extends WithOptionalTags<A> {
    id: EdgeId;
    parent: NodeId | null;
    source: NodeId;
    target: NodeId;
    label: string | null;
    description?: MarkdownOrString | null;
    technology?: string | null;
    relations: RelationId[];
    kind?: RelationKind<A> | typeof StepEdgeKind;
    notation?: string;
    notes?: MarkdownOrString;
    color: Color;
    line: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    navigateTo?: StrictViewId<A> | null;
    /**
     * If this edge is derived from custom relationship predicate
     */
    isCustomized?: boolean;
    /**
     * Path to the AST node relative to the view body ast
     * Available only in dynamic views
     * @internal
     */
    astPath?: string;
    /**
     * For layouting purposes
     * @default 'forward'
     */
    dir?: 'forward' | 'back' | 'both';
}
interface ComputedRankConstraint {
    type: RankValue;
    nodes: NodeId[];
}
interface BaseComputedViewProperties<A extends Any> extends BaseViewProperties<A>, ViewWithHash, ViewWithNotation {
    readonly [_stage]: 'computed';
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ReadonlyArray<ComputedNode<A>>;
    readonly edges: ReadonlyArray<ComputedEdge<A>>;
    /**
     * If the view has manual layout (v2)
     */
    readonly hasManualLayout?: boolean;
    /**
     * Manual layout data (v1), for compatibility during migration
     * @deprecated
     */
    readonly manualLayout?: ViewManualLayout | undefined;
}
interface ComputedElementView<A extends Any = Any> extends BaseComputedViewProperties<A> {
    readonly [_type]: 'element';
    readonly viewOf?: Fqn<A>;
    readonly extends?: StrictViewId<A>;
    readonly ranks?: ComputedRankConstraint[];
}
interface ComputedDeploymentView<A extends Any = Any> extends BaseComputedViewProperties<A> {
    readonly [_type]: 'deployment';
}
interface ComputedDynamicView<A extends Any = Any> extends BaseComputedViewProperties<A> {
    readonly [_type]: 'dynamic';
    /**
     * How to display the dynamic view
     * - `diagram`: display as a regular likec4 view
     * - `sequence`: display as a sequence diagram
     */
    readonly variant: DynamicViewDisplayVariant;
}

export { getParallelStepsPrefix as $, type AbstractRelationship as A, type ViewAutoLayout as B, type ComputedNodeStyle as C, type ViewManualLayout as D, type ElementStyle as E, type ViewType as F, type GlobalPredicateId as G, type BaseViewProperties as H, type BaseParsedViewProperties as I, type ViewWithNotation as J, type ViewWithHash as K, type LikeC4ProjectStylesConfig as L, type ModelGlobals as M, type NodeNotation as N, type ComputedNode as O, type ComputedEdge as P, type ComputedRankConstraint as Q, type Relationship as R, type Specification as S, type TagSpecification as T, type ComputedElementView as U, type ViewRuleGlobalStyle as V, type ComputedDeploymentView as W, type ComputedDynamicView as X, type DynamicStep as Y, type DynamicStepsSeries as Z, type DynamicStepsParallel as _, type GlobalPredicates as a, type DynamicViewStep as a0, isDynamicStep as a1, isDynamicStepsParallel as a2, isDynamicStepsSeries as a3, type DynamicViewIncludeRule as a4, type DynamicViewRule as a5, type DynamicViewDisplayVariant as a6, type ParsedDynamicView as a7, type ElementViewIncludePredicate as a8, type ElementViewExcludePredicate as a9, type ElementViewPredicate as aa, type ElementViewRuleGroup as ab, isViewRuleGroup as ac, type ElementViewRuleStyle as ad, type ElementViewRuleRank as ae, isViewRuleRank as af, type ElementViewRule as ag, type ParsedElementView as ah, type GlobalDynamicPredicates as b, type GlobalStyleID as c, type GlobalStyles as d, ensureSizes as e, type Element as f, type ModelRelation as g, type ElementSpecification as h, isTagColorSpecified as i, type RelationshipSpecification as j, type LikeC4ProjectTheme as k, type LikeC4ProjectStyleDefaults as l, type LikeC4ProjectManualLayoutsConfig as m, type LikeC4Project as n, type AnyIncludePredicate as o, type AnyExcludePredicate as p, type AnyViewRuleStyle as q, isViewRuleGlobalStyle as r, type ViewRuleGlobalPredicateRef as s, isViewRuleGlobalPredicateRef as t, type RankValue as u, type ViewRuleRank as v, type AutoLayoutDirection as w, isAutoLayoutDirection as x, type ViewRuleAutoLayout as y, isViewRuleAutoLayout as z };
