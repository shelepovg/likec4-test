import { g as getDefaultExportFromCjs } from './core.B85MJLTf.mjs';
import { e as e$1 } from './core.CqAJJpK_.mjs';

const e={done:true,hasNext:false},t$1={done:false,hasNext:false},n$1=()=>e;

function t(e,...t){let a=e,o=t.map(e=>`lazy`in e?r(e):void 0),s=0;for(;s<t.length;){if(o[s]===void 0||!i(a)){let e=t[s];a=e(a),s+=1;continue}let e=[];for(let n=s;n<t.length;n++){let t=o[n];if(t===void 0||(e.push(t),t.isSingle))break}let r=[];for(let t of a)if(n(t,r,e))break;let{isSingle:c}=e.at(-1);a=c?r[0]:r,s+=e.length;}return a}function n(t,r,i){if(i.length===0)return r.push(t),false;let a=t,o=t$1,s=false;for(let[e,t]of i.entries()){let{index:c,items:l}=t;if(l.push(a),o=t(a,c,l),t.index+=1,o.hasNext){if(o.hasMany??false){for(let t of o.next)if(n(t,r,i.slice(e+1)))return  true;return s}a=o.next;}if(!o.hasNext)break;o.done&&(s=true);}return o.hasNext&&r.push(a),s}function r(e){let{lazy:t,lazyArgs:n}=e,r=t(...n);return Object.assign(r,{isSingle:t.single??false,index:0,items:[]})}function i(e){return typeof e==`string`||typeof e==`object`&&!!e&&Symbol.iterator in e}

var naturalCompareLite = {exports: {}};

var hasRequiredNaturalCompareLite;

function requireNaturalCompareLite () {
	if (hasRequiredNaturalCompareLite) return naturalCompareLite.exports;
	hasRequiredNaturalCompareLite = 1;
	/*
	 * @version    1.4.0
	 * @date       2015-10-26
	 * @stability  3 - Stable
	 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
	 * @license    MIT License
	 */


	var naturalCompare = function(a, b) {
		var i, codeA
		, codeB = 1
		, posA = 0
		, posB = 0
		, alphabet = String.alphabet;

		function getCode(str, pos, code) {
			if (code) {
				for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
				return +str.slice(pos - 1, i)
			}
			code = alphabet && alphabet.indexOf(str.charAt(pos));
			return code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code
				: code < 46 ? 65               // -
				: code < 48 ? code - 1
				: code < 58 ? code + 18        // 0-9
				: code < 65 ? code - 11
				: code < 91 ? code + 11        // A-Z
				: code < 97 ? code - 37
				: code < 123 ? code + 5        // a-z
				: code - 63
		}


		if ((a+="") != (b+="")) for (;codeB;) {
			codeA = getCode(a, posA++);
			codeB = getCode(b, posB++);

			if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
				codeA = getCode(a, posA, posA);
				codeB = getCode(b, posB, posA = i);
				posB = i;
			}

			if (codeA != codeB) return (codeA < codeB) ? -1 : 1
		}
		return 0
	};

	try {
		naturalCompareLite.exports = naturalCompare;
	} catch (e) {
		String.naturalCompare = naturalCompare;
	}
	return naturalCompareLite.exports;
}

var naturalCompareLiteExports = requireNaturalCompareLite();
const compare = /*@__PURE__*/getDefaultExportFromCjs(naturalCompareLiteExports);

function compareNatural(a, b) {
  if (a === b) return 0;
  if (e$1(a)) {
    if (e$1(b)) {
      return compare(a, b);
    }
    return 1;
  }
  return e$1(b) ? -1 : 0;
}
function compareNaturalHierarchically(separator = ".", deepestFirst = false) {
  return (a, b) => {
    if (a === b) return 0;
    if (!a) return -1;
    if (!b) return 1;
    const aParts = a.split(separator);
    const bParts = b.split(separator);
    const minLength = Math.min(aParts.length, bParts.length);
    for (let i = 0; i < minLength; i++) {
      const aPart = aParts[i];
      const bPart = bParts[i];
      const comparison = compare(aPart, bPart);
      if (comparison !== 0) {
        return comparison;
      }
    }
    const diff = aParts.length - bParts.length;
    return deepestFirst ? -1 * diff : diff;
  };
}

export { t$1 as a, compareNaturalHierarchically as b, compareNatural as c, n$1 as n, t };
