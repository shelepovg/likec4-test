import { t as t$1 } from './core.BsSXS-_R.mjs';
import { g as getDefaultExportFromCjs } from './core.B85MJLTf.mjs';
import { r as requireForeach, b as requireIterator, a as markdownToText, m as markdownToHtml } from './core.Bdy3hhTc.mjs';
import { m as memoizeProp } from './core.CLSZtnFh.mjs';
import { n as nonexhaustive } from './core.D4npX2q8.mjs';

function t(...t){return t$1(n,t)}function n(e,t){let n={...e};for(let[r,i]of Object.entries(n))t(i,r,e)&&delete n[r];return n}

var typedArrays = {};

/**
 * Mnemonist Typed Array Helpers
 * ==============================
 *
 * Miscellaneous helpers related to typed arrays.
 */

var hasRequiredTypedArrays;

function requireTypedArrays () {
	if (hasRequiredTypedArrays) return typedArrays;
	hasRequiredTypedArrays = 1;
	(function (exports$1) {
		/**
		 * When using an unsigned integer array to store pointers, one might want to
		 * choose the optimal word size in regards to the actual numbers of pointers
		 * to store.
		 *
		 * This helpers does just that.
		 *
		 * @param  {number} size - Expected size of the array to map.
		 * @return {TypedArray}
		 */
		var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,
		    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,
		    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;

		var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,
		    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,
		    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;

		exports$1.getPointerArray = function(size) {
		  var maxIndex = size - 1;

		  if (maxIndex <= MAX_8BIT_INTEGER)
		    return Uint8Array;

		  if (maxIndex <= MAX_16BIT_INTEGER)
		    return Uint16Array;

		  if (maxIndex <= MAX_32BIT_INTEGER)
		    return Uint32Array;

		  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');
		};

		exports$1.getSignedPointerArray = function(size) {
		  var maxIndex = size - 1;

		  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
		    return Int8Array;

		  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
		    return Int16Array;

		  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
		    return Int32Array;

		  return Float64Array;
		};

		/**
		 * Function returning the minimal type able to represent the given number.
		 *
		 * @param  {number} value - Value to test.
		 * @return {TypedArrayClass}
		 */
		exports$1.getNumberType = function(value) {

		  // <= 32 bits itnteger?
		  if (value === (value | 0)) {

		    // Negative
		    if (Math.sign(value) === -1) {
		      if (value <= 127 && value >= -128)
		        return Int8Array;

		      if (value <= 32767 && value >= -32768)
		        return Int16Array;

		      return Int32Array;
		    }
		    else {

		      if (value <= 255)
		        return Uint8Array;

		      if (value <= 65535)
		        return Uint16Array;

		      return Uint32Array;
		    }
		  }

		  // 53 bits integer & floats
		  // NOTE: it's kinda hard to tell whether we could use 32bits or not...
		  return Float64Array;
		};

		/**
		 * Function returning the minimal type able to represent the given array
		 * of JavaScript numbers.
		 *
		 * @param  {array}    array  - Array to represent.
		 * @param  {function} getter - Optional getter.
		 * @return {TypedArrayClass}
		 */
		var TYPE_PRIORITY = {
		  Uint8Array: 1,
		  Int8Array: 2,
		  Uint16Array: 3,
		  Int16Array: 4,
		  Uint32Array: 5,
		  Int32Array: 6,
		  Float32Array: 7,
		  Float64Array: 8
		};

		// TODO: make this a one-shot for one value
		exports$1.getMinimalRepresentation = function(array, getter) {
		  var maxType = null,
		      maxPriority = 0,
		      p,
		      t,
		      v,
		      i,
		      l;

		  for (i = 0, l = array.length; i < l; i++) {
		    v = getter ? getter(array[i]) : array[i];
		    t = exports$1.getNumberType(v);
		    p = TYPE_PRIORITY[t.name];

		    if (p > maxPriority) {
		      maxPriority = p;
		      maxType = t;
		    }
		  }

		  return maxType;
		};

		/**
		 * Function returning whether the given value is a typed array.
		 *
		 * @param  {any} value - Value to test.
		 * @return {boolean}
		 */
		exports$1.isTypedArray = function(value) {
		  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);
		};

		/**
		 * Function used to concat byte arrays.
		 *
		 * @param  {...ByteArray}
		 * @return {ByteArray}
		 */
		exports$1.concat = function() {
		  var length = 0,
		      i,
		      o,
		      l;

		  for (i = 0, l = arguments.length; i < l; i++)
		    length += arguments[i].length;

		  var array = new (arguments[0].constructor)(length);

		  for (i = 0, o = 0; i < l; i++) {
		    array.set(arguments[i], o);
		    o += arguments[i].length;
		  }

		  return array;
		};

		/**
		 * Function used to initialize a byte array of indices.
		 *
		 * @param  {number}    length - Length of target.
		 * @return {ByteArray}
		 */
		exports$1.indices = function(length) {
		  var PointerArray = exports$1.getPointerArray(length);

		  var array = new PointerArray(length);

		  for (var i = 0; i < length; i++)
		    array[i] = i;

		  return array;
		}; 
	} (typedArrays));
	return typedArrays;
}

var iterables = {};

/**
 * Mnemonist Iterable Function
 * ============================
 *
 * Harmonized iteration helpers over mixed iterable targets.
 */

var hasRequiredIterables;

function requireIterables () {
	if (hasRequiredIterables) return iterables;
	hasRequiredIterables = 1;
	var forEach = requireForeach();

	var typed = /*@__PURE__*/ requireTypedArrays();

	/**
	 * Function used to determine whether the given object supports array-like
	 * random access.
	 *
	 * @param  {any} target - Target object.
	 * @return {boolean}
	 */
	function isArrayLike(target) {
	  return Array.isArray(target) || typed.isTypedArray(target);
	}

	/**
	 * Function used to guess the length of the structure over which we are going
	 * to iterate.
	 *
	 * @param  {any} target - Target object.
	 * @return {number|undefined}
	 */
	function guessLength(target) {
	  if (typeof target.length === 'number')
	    return target.length;

	  if (typeof target.size === 'number')
	    return target.size;

	  return;
	}

	/**
	 * Function used to convert an iterable to an array.
	 *
	 * @param  {any}   target - Iteration target.
	 * @return {array}
	 */
	function toArray(target) {
	  var l = guessLength(target);

	  var array = typeof l === 'number' ? new Array(l) : [];

	  var i = 0;

	  // TODO: we could optimize when given target is array like
	  forEach(target, function(value) {
	    array[i++] = value;
	  });

	  return array;
	}

	/**
	 * Same as above but returns a supplementary indices array.
	 *
	 * @param  {any}   target - Iteration target.
	 * @return {array}
	 */
	function toArrayWithIndices(target) {
	  var l = guessLength(target);

	  var IndexArray = typeof l === 'number' ?
	    typed.getPointerArray(l) :
	    Array;

	  var array = typeof l === 'number' ? new Array(l) : [];
	  var indices = typeof l === 'number' ? new IndexArray(l) : [];

	  var i = 0;

	  // TODO: we could optimize when given target is array like
	  forEach(target, function(value) {
	    array[i] = value;
	    indices[i] = i++;
	  });

	  return [array, indices];
	}

	/**
	 * Exporting.
	 */
	iterables.isArrayLike = isArrayLike;
	iterables.guessLength = guessLength;
	iterables.toArray = toArray;
	iterables.toArrayWithIndices = toArrayWithIndices;
	return iterables;
}

/**
 * Mnemonist LRUCache
 * ===================
 *
 * JavaScript implementation of the LRU Cache data structure. To save up
 * memory and allocations this implementation represents its underlying
 * doubly-linked list as static arrays and pointers. Thus, memory is allocated
 * only once at instantiation and JS objects are never created to serve as
 * pointers. This also means this implementation does not trigger too many
 * garbage collections.
 *
 * Note that to save up memory, a LRU Cache can be implemented using a singly
 * linked list by storing predecessors' pointers as hashmap values.
 * However, this means more hashmap lookups and would probably slow the whole
 * thing down. What's more, pointers are not the things taking most space in
 * memory.
 */

var lruCache;
var hasRequiredLruCache;

function requireLruCache () {
	if (hasRequiredLruCache) return lruCache;
	hasRequiredLruCache = 1;
	var Iterator = requireIterator(),
	    forEach = requireForeach(),
	    typed = /*@__PURE__*/ requireTypedArrays(),
	    iterables = /*@__PURE__*/ requireIterables();

	/**
	 * LRUCache.
	 *
	 * @constructor
	 * @param {function} Keys     - Array class for storing keys.
	 * @param {function} Values   - Array class for storing values.
	 * @param {number}   capacity - Desired capacity.
	 */
	function LRUCache(Keys, Values, capacity) {
	  if (arguments.length < 2) {
	    capacity = Keys;
	    Keys = null;
	    Values = null;
	  }

	  this.capacity = capacity;

	  if (typeof this.capacity !== 'number' || this.capacity <= 0)
	    throw new Error('mnemonist/lru-cache: capacity should be positive number.');
	  else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)
	    throw new Error('mnemonist/lru-cache: capacity should be a finite positive integer.');

	  var PointerArray = typed.getPointerArray(capacity);

	  this.forward = new PointerArray(capacity);
	  this.backward = new PointerArray(capacity);
	  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);
	  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);

	  // Properties
	  this.size = 0;
	  this.head = 0;
	  this.tail = 0;
	  this.items = {};
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	LRUCache.prototype.clear = function() {
	  this.size = 0;
	  this.head = 0;
	  this.tail = 0;
	  this.items = {};
	};

	/**
	 * Method used to splay a value on top.
	 *
	 * @param  {number}   pointer - Pointer of the value to splay on top.
	 * @return {LRUCache}
	 */
	LRUCache.prototype.splayOnTop = function(pointer) {
	  var oldHead = this.head;

	  if (this.head === pointer)
	    return this;

	  var previous = this.backward[pointer],
	      next = this.forward[pointer];

	  if (this.tail === pointer) {
	    this.tail = previous;
	  }
	  else {
	    this.backward[next] = previous;
	  }

	  this.forward[previous] = next;

	  this.backward[oldHead] = pointer;
	  this.head = pointer;
	  this.forward[pointer] = oldHead;

	  return this;
	};

	/**
	 * Method used to set the value for the given key in the cache.
	 *
	 * @param  {any} key   - Key.
	 * @param  {any} value - Value.
	 * @return {undefined}
	 */
	LRUCache.prototype.set = function(key, value) {

	  var pointer = this.items[key];

	  // The key already exists, we just need to update the value and splay on top
	  if (typeof pointer !== 'undefined') {
	    this.splayOnTop(pointer);
	    this.V[pointer] = value;

	    return;
	  }

	  // The cache is not yet full
	  if (this.size < this.capacity) {
	    pointer = this.size++;
	  }

	  // Cache is full, we need to drop the last value
	  else {
	    pointer = this.tail;
	    this.tail = this.backward[pointer];
	    delete this.items[this.K[pointer]];
	  }

	  // Storing key & value
	  this.items[key] = pointer;
	  this.K[pointer] = key;
	  this.V[pointer] = value;

	  // Moving the item at the front of the list
	  this.forward[pointer] = this.head;
	  this.backward[this.head] = pointer;
	  this.head = pointer;
	};

	/**
	 * Method used to set the value for the given key in the cache
	 *
	 * @param  {any} key   - Key.
	 * @param  {any} value - Value.
	 * @return {{evicted: boolean, key: any, value: any}} An object containing the
	 * key and value of an item that was overwritten or evicted in the set
	 * operation, as well as a boolean indicating whether it was evicted due to
	 * limited capacity. Return value is null if nothing was evicted or overwritten
	 * during the set operation.
	 */
	LRUCache.prototype.setpop = function(key, value) {
	  var oldValue = null;
	  var oldKey = null;

	  var pointer = this.items[key];

	  // The key already exists, we just need to update the value and splay on top
	  if (typeof pointer !== 'undefined') {
	    this.splayOnTop(pointer);
	    oldValue = this.V[pointer];
	    this.V[pointer] = value;
	    return {evicted: false, key: key, value: oldValue};
	  }

	  // The cache is not yet full
	  if (this.size < this.capacity) {
	    pointer = this.size++;
	  }

	  // Cache is full, we need to drop the last value
	  else {
	    pointer = this.tail;
	    this.tail = this.backward[pointer];
	    oldValue = this.V[pointer];
	    oldKey = this.K[pointer];
	    delete this.items[oldKey];
	  }

	  // Storing key & value
	  this.items[key] = pointer;
	  this.K[pointer] = key;
	  this.V[pointer] = value;

	  // Moving the item at the front of the list
	  this.forward[pointer] = this.head;
	  this.backward[this.head] = pointer;
	  this.head = pointer;

	  // Return object if eviction took place, otherwise return null
	  if (oldKey) {
	    return {evicted: true, key: oldKey, value: oldValue};
	  }
	  else {
	    return null;
	  }
	};

	/**
	 * Method used to check whether the key exists in the cache.
	 *
	 * @param  {any} key   - Key.
	 * @return {boolean}
	 */
	LRUCache.prototype.has = function(key) {
	  return key in this.items;
	};

	/**
	 * Method used to get the value attached to the given key. Will move the
	 * related key to the front of the underlying linked list.
	 *
	 * @param  {any} key   - Key.
	 * @return {any}
	 */
	LRUCache.prototype.get = function(key) {
	  var pointer = this.items[key];

	  if (typeof pointer === 'undefined')
	    return;

	  this.splayOnTop(pointer);

	  return this.V[pointer];
	};

	/**
	 * Method used to get the value attached to the given key. Does not modify
	 * the ordering of the underlying linked list.
	 *
	 * @param  {any} key   - Key.
	 * @return {any}
	 */
	LRUCache.prototype.peek = function(key) {
	  var pointer = this.items[key];

	  if (typeof pointer === 'undefined')
	    return;

	  return this.V[pointer];
	};

	/**
	 * Method used to iterate over the cache's entries using a callback.
	 *
	 * @param  {function}  callback - Function to call for each item.
	 * @param  {object}    scope    - Optional scope.
	 * @return {undefined}
	 */
	LRUCache.prototype.forEach = function(callback, scope) {
	  scope = arguments.length > 1 ? scope : this;

	  var i = 0,
	      l = this.size;

	  var pointer = this.head,
	      keys = this.K,
	      values = this.V,
	      forward = this.forward;

	  while (i < l) {

	    callback.call(scope, values[pointer], keys[pointer], this);
	    pointer = forward[pointer];

	    i++;
	  }
	};

	/**
	 * Method used to create an iterator over the cache's keys from most
	 * recently used to least recently used.
	 *
	 * @return {Iterator}
	 */
	LRUCache.prototype.keys = function() {
	  var i = 0,
	      l = this.size;

	  var pointer = this.head,
	      keys = this.K,
	      forward = this.forward;

	  return new Iterator(function() {
	    if (i >= l)
	      return {done: true};

	    var key = keys[pointer];

	    i++;

	    if (i < l)
	      pointer = forward[pointer];

	    return {
	      done: false,
	      value: key
	    };
	  });
	};

	/**
	 * Method used to create an iterator over the cache's values from most
	 * recently used to least recently used.
	 *
	 * @return {Iterator}
	 */
	LRUCache.prototype.values = function() {
	  var i = 0,
	      l = this.size;

	  var pointer = this.head,
	      values = this.V,
	      forward = this.forward;

	  return new Iterator(function() {
	    if (i >= l)
	      return {done: true};

	    var value = values[pointer];

	    i++;

	    if (i < l)
	      pointer = forward[pointer];

	    return {
	      done: false,
	      value: value
	    };
	  });
	};

	/**
	 * Method used to create an iterator over the cache's entries from most
	 * recently used to least recently used.
	 *
	 * @return {Iterator}
	 */
	LRUCache.prototype.entries = function() {
	  var i = 0,
	      l = this.size;

	  var pointer = this.head,
	      keys = this.K,
	      values = this.V,
	      forward = this.forward;

	  return new Iterator(function() {
	    if (i >= l)
	      return {done: true};

	    var key = keys[pointer],
	        value = values[pointer];

	    i++;

	    if (i < l)
	      pointer = forward[pointer];

	    return {
	      done: false,
	      value: [key, value]
	    };
	  });
	};

	/**
	 * Attaching the #.entries method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;

	/**
	 * Convenience known methods.
	 */
	LRUCache.prototype.inspect = function() {
	  var proxy = new Map();

	  var iterator = this.entries(),
	      step;

	  while ((step = iterator.next(), !step.done))
	    proxy.set(step.value[0], step.value[1]);

	  // Trick so that node displays the name of the constructor
	  Object.defineProperty(proxy, 'constructor', {
	    value: LRUCache,
	    enumerable: false
	  });

	  return proxy;
	};

	if (typeof Symbol !== 'undefined')
	  LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a structure.
	 *
	 * @param  {Iterable} iterable - Target iterable.
	 * @param  {function} Keys     - Array class for storing keys.
	 * @param  {function} Values   - Array class for storing values.
	 * @param  {number}   capacity - Cache's capacity.
	 * @return {LRUCache}
	 */
	LRUCache.from = function(iterable, Keys, Values, capacity) {
	  if (arguments.length < 2) {
	    capacity = iterables.guessLength(iterable);

	    if (typeof capacity !== 'number')
	      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');
	  }
	  else if (arguments.length === 2) {
	    capacity = Keys;
	    Keys = null;
	    Values = null;
	  }

	  var cache = new LRUCache(Keys, Values, capacity);

	  forEach(iterable, function(value, key) {
	    cache.set(key, value);
	  });

	  return cache;
	};

	/**
	 * Exporting.
	 */
	lruCache = LRUCache;
	return lruCache;
}

/**
 * Mnemonist LRUMap
 * =================
 *
 * Variant of the LRUCache class that leverages an ES6 Map instead of an object.
 * It might be faster for some use case but it is still hard to understand
 * when a Map can outperform an object in v8.
 */

var lruMap;
var hasRequiredLruMap;

function requireLruMap () {
	if (hasRequiredLruMap) return lruMap;
	hasRequiredLruMap = 1;
	var LRUCache = /*@__PURE__*/ requireLruCache(),
	    forEach = requireForeach(),
	    typed = /*@__PURE__*/ requireTypedArrays(),
	    iterables = /*@__PURE__*/ requireIterables();

	/**
	 * LRUMap.
	 *
	 * @constructor
	 * @param {function} Keys     - Array class for storing keys.
	 * @param {function} Values   - Array class for storing values.
	 * @param {number}   capacity - Desired capacity.
	 */
	function LRUMap(Keys, Values, capacity) {
	  if (arguments.length < 2) {
	    capacity = Keys;
	    Keys = null;
	    Values = null;
	  }

	  this.capacity = capacity;

	  if (typeof this.capacity !== 'number' || this.capacity <= 0)
	    throw new Error('mnemonist/lru-map: capacity should be positive number.');
	  else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)
	    throw new Error('mnemonist/lru-map: capacity should be a finite positive integer.');

	  var PointerArray = typed.getPointerArray(capacity);

	  this.forward = new PointerArray(capacity);
	  this.backward = new PointerArray(capacity);
	  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);
	  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);

	  // Properties
	  this.size = 0;
	  this.head = 0;
	  this.tail = 0;
	  this.items = new Map();
	}

	/**
	 * Method used to clear the structure.
	 *
	 * @return {undefined}
	 */
	LRUMap.prototype.clear = function() {
	  this.size = 0;
	  this.head = 0;
	  this.tail = 0;
	  this.items.clear();
	};

	/**
	 * Method used to set the value for the given key in the cache.
	 *
	 * @param  {any} key   - Key.
	 * @param  {any} value - Value.
	 * @return {undefined}
	 */
	LRUMap.prototype.set = function(key, value) {

	  var pointer = this.items.get(key);

	  // The key already exists, we just need to update the value and splay on top
	  if (typeof pointer !== 'undefined') {
	    this.splayOnTop(pointer);
	    this.V[pointer] = value;

	    return;
	  }

	  // The cache is not yet full
	  if (this.size < this.capacity) {
	    pointer = this.size++;
	  }

	  // Cache is full, we need to drop the last value
	  else {
	    pointer = this.tail;
	    this.tail = this.backward[pointer];
	    this.items.delete(this.K[pointer]);
	  }

	  // Storing key & value
	  this.items.set(key, pointer);
	  this.K[pointer] = key;
	  this.V[pointer] = value;

	  // Moving the item at the front of the list
	  this.forward[pointer] = this.head;
	  this.backward[this.head] = pointer;
	  this.head = pointer;
	};

	/**
	 * Method used to set the value for the given key in the cache.
	 *
	 * @param  {any} key   - Key.
	 * @param  {any} value - Value.
	 * @return {{evicted: boolean, key: any, value: any}} An object containing the
	 * key and value of an item that was overwritten or evicted in the set
	 * operation, as well as a boolean indicating whether it was evicted due to
	 * limited capacity. Return value is null if nothing was evicted or overwritten
	 * during the set operation.
	 */
	LRUMap.prototype.setpop = function(key, value) {
	  var oldValue = null;
	  var oldKey = null;

	  var pointer = this.items.get(key);

	  // The key already exists, we just need to update the value and splay on top
	  if (typeof pointer !== 'undefined') {
	    this.splayOnTop(pointer);
	    oldValue = this.V[pointer];
	    this.V[pointer] = value;
	    return {evicted: false, key: key, value: oldValue};
	  }

	  // The cache is not yet full
	  if (this.size < this.capacity) {
	    pointer = this.size++;
	  }

	  // Cache is full, we need to drop the last value
	  else {
	    pointer = this.tail;
	    this.tail = this.backward[pointer];
	    oldValue = this.V[pointer];
	    oldKey = this.K[pointer];
	    this.items.delete(oldKey);
	  }

	  // Storing key & value
	  this.items.set(key, pointer);
	  this.K[pointer] = key;
	  this.V[pointer] = value;

	  // Moving the item at the front of the list
	  this.forward[pointer] = this.head;
	  this.backward[this.head] = pointer;
	  this.head = pointer;

	  // Return object if eviction took place, otherwise return null
	  if (oldKey) {
	    return {evicted: true, key: oldKey, value: oldValue};
	  }
	  else {
	    return null;
	  }
	};

	/**
	 * Method used to check whether the key exists in the cache.
	 *
	 * @param  {any} key   - Key.
	 * @return {boolean}
	 */
	LRUMap.prototype.has = function(key) {
	  return this.items.has(key);
	};

	/**
	 * Method used to get the value attached to the given key. Will move the
	 * related key to the front of the underlying linked list.
	 *
	 * @param  {any} key   - Key.
	 * @return {any}
	 */
	LRUMap.prototype.get = function(key) {
	  var pointer = this.items.get(key);

	  if (typeof pointer === 'undefined')
	    return;

	  this.splayOnTop(pointer);

	  return this.V[pointer];
	};

	/**
	 * Method used to get the value attached to the given key. Does not modify
	 * the ordering of the underlying linked list.
	 *
	 * @param  {any} key   - Key.
	 * @return {any}
	 */
	LRUMap.prototype.peek = function(key) {
	  var pointer = this.items.get(key);

	  if (typeof pointer === 'undefined')
	    return;

	  return this.V[pointer];
	};

	/**
	 * Methods that can be reused as-is from LRUCache.
	 */
	LRUMap.prototype.splayOnTop = LRUCache.prototype.splayOnTop;
	LRUMap.prototype.forEach = LRUCache.prototype.forEach;
	LRUMap.prototype.keys = LRUCache.prototype.keys;
	LRUMap.prototype.values = LRUCache.prototype.values;
	LRUMap.prototype.entries = LRUCache.prototype.entries;

	/**
	 * Attaching the #.entries method to Symbol.iterator if possible.
	 */
	if (typeof Symbol !== 'undefined')
	  LRUMap.prototype[Symbol.iterator] = LRUMap.prototype.entries;

	/**
	 * Convenience known methods.
	 */
	LRUMap.prototype.inspect = LRUCache.prototype.inspect;

	/**
	 * Static @.from function taking an arbitrary iterable & converting it into
	 * a structure.
	 *
	 * @param  {Iterable} iterable - Target iterable.
	 * @param  {function} Keys     - Array class for storing keys.
	 * @param  {function} Values   - Array class for storing values.
	 * @param  {number}   capacity - Cache's capacity.
	 * @return {LRUMap}
	 */
	LRUMap.from = function(iterable, Keys, Values, capacity) {
	  if (arguments.length < 2) {
	    capacity = iterables.guessLength(iterable);

	    if (typeof capacity !== 'number')
	      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');
	  }
	  else if (arguments.length === 2) {
	    capacity = Keys;
	    Keys = null;
	    Values = null;
	  }

	  var cache = new LRUMap(Keys, Values, capacity);

	  forEach(iterable, function(value, key) {
	    cache.set(key, value);
	  });

	  return cache;
	};

	/**
	 * Exporting.
	 */
	lruMap = LRUMap;
	return lruMap;
}

var lruMapExports = /*@__PURE__*/ requireLruMap();
const LRUMap = /*@__PURE__*/getDefaultExportFromCjs(lruMapExports);

function exact(a) {
  return t(a, (v) => v === void 0);
}

const symb_text = /* @__PURE__ */ Symbol.for("text");
const symb_html = /* @__PURE__ */ Symbol.for("html");
const emptyTxt = "";
const mdcache = new LRUMap(500);
const txtcache = new LRUMap(500);
class RichText {
  static getOrCreateFromText(txt) {
    if (txt.trim() === emptyTxt) {
      return RichText.EMPTY;
    }
    let cached = txtcache.get(txt);
    if (cached) {
      return cached;
    }
    cached = new RichText({ txt });
    txtcache.set(txt, cached);
    return cached;
  }
  static getOrCreateFromMarkdown(md) {
    if (md.trim() === emptyTxt) {
      return RichText.EMPTY;
    }
    let cached = mdcache.get(md);
    if (cached) {
      return cached;
    }
    cached = new RichText({ md });
    mdcache.set(md, cached);
    return cached;
  }
  /**
   * Creates and memoizes a RichText instance.
   * @see ElementModel.description
   * @example
   *
   *  get description(): RichTextOrEmpty {
   *    return RichText.memoize(this, 'description', this.$element.description)
   *  }
   */
  static memoize(obj, tag, source) {
    return memoizeProp(obj, tag, () => RichText.from(source));
  }
  /**
   * Creates a RichText instance from a source.
   */
  static from(source) {
    if (source === null || source === void 0 || source === RichText.EMPTY) {
      return RichText.EMPTY;
    }
    if (source instanceof RichText) {
      return source;
    }
    if (typeof source === "string") {
      return this.getOrCreateFromText(source);
    }
    if ("isEmpty" in source && source.isEmpty) {
      return RichText.EMPTY;
    }
    if ("md" in source) {
      return this.getOrCreateFromMarkdown(source.md);
    }
    return this.getOrCreateFromText(source.txt);
  }
  /**
   * This is a workaround for the fact that we need instance of RichText for `instanceof` checks
   * It is invalid inheritance (returning `null` from getters), and we cast to @see RichTextEmpty
   */
  static EMPTY = new class extends RichText {
    isEmpty = true;
    nonEmpty = false;
    isMarkdown = false;
    $source = null;
    constructor() {
      super({ txt: emptyTxt });
    }
    get text() {
      return null;
    }
    get md() {
      return null;
    }
    get html() {
      return null;
    }
  }();
  $source;
  isEmpty;
  nonEmpty;
  isMarkdown;
  /**
   * Private constructor to prevent direct instantiation.
   * Use {@link RichText.from} or {@link RichText.memoize} instead.
   */
  constructor(source) {
    this.isMarkdown = false;
    if (typeof source === "string") {
      this.$source = { txt: source };
      this.isEmpty = source.trim() === emptyTxt;
    } else {
      this.$source = source;
      this.isEmpty = true;
      if ("md" in source) {
        this.isEmpty = source.md === emptyTxt;
        this.isMarkdown = true;
      } else {
        this.isEmpty = source.txt === emptyTxt;
      }
    }
    this.nonEmpty = !this.isEmpty;
  }
  /**
   * Returns the text content of the rich text.
   * If the source is a string, it returns the string.
   * If the source is a markdown, it returns the markdown.
   */
  get text() {
    if (this.isEmpty || this.$source === null) {
      return emptyTxt;
    }
    const source = this.$source;
    if ("txt" in source) {
      return source.txt;
    }
    return memoizeProp(this, symb_text, () => markdownToText(source.md));
  }
  /**
   * Returns the markdown content of the rich text.
   * If the source is a string, it returns the string.
   * If the source is a markdown, it returns the markdown.
   */
  get md() {
    if (this.isEmpty || this.$source === null) {
      return emptyTxt;
    }
    const source = this.$source;
    if ("md" in source) {
      return source.md;
    }
    if ("txt" in source) {
      return source.txt;
    }
    nonexhaustive(source);
  }
  /**
   * Returns the html content of the rich text.
   * If the source is a string, it returns the string.
   * If the source is a markdown, it returns the HTML.
   */
  get html() {
    if (this.isEmpty || this.$source === null) {
      return emptyTxt;
    }
    const source = this.$source;
    if ("txt" in source) {
      return source.txt;
    }
    return memoizeProp(this, symb_html, () => markdownToHtml(source.md));
  }
  equals(other) {
    if (this === other) return true;
    if (!(other instanceof RichText)) return false;
    if (this.isEmpty && other.isEmpty) return true;
    if (this.isEmpty !== other.isEmpty || this.isMarkdown !== other.isMarkdown) return false;
    if (this.isMarkdown) {
      return this.$source?.md === other.$source?.md;
    }
    return this.$source?.txt === other.$source?.txt;
  }
}

export { RichText as R, exact as e, requireIterables as r, t };
