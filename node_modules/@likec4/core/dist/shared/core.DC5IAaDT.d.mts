import { TupleToUnion, Tagged } from 'type-fest';
import { A as Any, T as Tag, q as AllKinds, r as Tags, S as StrictViewId, E as ElementKind } from './core.D00YbOhQ.mjs';
import { N as NonEmptyArray, E as ExclusiveUnion } from './core.DB0Ue5Wx.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { M as MarkdownOrString, I as Icon } from './core.C_3y3eqV.mjs';

/**
 * For padding, margin, etc.
 */
declare const Sizes: readonly ["xs", "sm", "md", "lg", "xl"];
type Size = TupleToUnion<typeof Sizes>;
type TextSize = Size;
type ShapeSize = Size;
type SpacingSize = Size;
declare const BorderStyles: readonly ["solid", "dashed", "dotted", "none"];
type BorderStyle = TupleToUnion<typeof BorderStyles>;
declare const ElementShapes: readonly ["rectangle", "person", "browser", "mobile", "cylinder", "storage", "queue", "bucket", "document"];
type ElementShape = TupleToUnion<typeof ElementShapes>;
type HexColor = `#${string}`;
type ColorLiteral = HexColor | `rgb(${number},${number},${number})` | `rgba(${number},${number},${number},${number})`;
type RelationshipLineType = 'dashed' | 'solid' | 'dotted';
declare const RelationshipArrowTypes: readonly ["none", "normal", "onormal", "dot", "odot", "diamond", "odiamond", "crow", "open", "vee"];
type RelationshipArrowType = TupleToUnion<typeof RelationshipArrowTypes>;
declare const ThemeColors: readonly ["amber", "blue", "gray", "slate", "green", "indigo", "muted", "primary", "red", "secondary", "sky"];
type ThemeColor = typeof ThemeColors[number];
declare function isThemeColor(color: string): color is ThemeColor;
type CustomColorDefinitions = {
    [key: string]: ThemeColorValues;
};
type CustomColor = Tagged<string, 'CustomColor'>;
declare function isCustomColor(color: string): color is CustomColor;
type Color = ThemeColor | CustomColor;
interface ElementColorValues {
    readonly fill: ColorLiteral;
    readonly stroke: ColorLiteral;
    readonly hiContrast: ColorLiteral;
    readonly loContrast: ColorLiteral;
}
interface RelationshipColorValues {
    readonly line: ColorLiteral;
    readonly labelBg: ColorLiteral;
    readonly label: ColorLiteral;
}
interface ThemeColorValues {
    readonly elements: ElementColorValues;
    readonly relationships: RelationshipColorValues;
}
/**
 * Default style values for elements, groups and relationships
 */
interface LikeC4StyleDefaults {
    readonly color: ThemeColor;
    readonly size: ShapeSize;
    readonly shape: ElementShape;
    readonly opacity?: number;
    readonly border?: BorderStyle;
    readonly padding?: SpacingSize;
    readonly text?: TextSize;
    /**
     * Default style values for groups
     * If not specified, the default values for elements are used
     */
    readonly group?: {
        readonly color?: ThemeColor;
        readonly opacity?: number;
        readonly border?: BorderStyle;
    };
    readonly relationship: {
        readonly color: ThemeColor;
        readonly line: RelationshipLineType;
        readonly arrow: RelationshipArrowType;
    };
}
interface LikeC4Theme {
    readonly colors: Readonly<Record<ThemeColor, ThemeColorValues>>;
    readonly sizes: Readonly<Record<ShapeSize, {
        readonly width: number;
        readonly height: number;
    }>>;
    readonly spacing: Readonly<Record<SpacingSize, number>>;
    readonly textSizes: Readonly<Record<TextSize, number>>;
}
interface LikeC4StylesConfig {
    readonly theme: LikeC4Theme;
    readonly defaults: LikeC4StyleDefaults;
}

type EqualOperator<V> = {
    eq: V;
    neq?: never;
} | {
    eq?: never;
    neq: V;
};
type AllNever = {
    not?: never;
    and?: never;
    or?: never;
    tag?: never;
    kind?: never;
    participant?: never;
    operator?: never;
};
type TagEqual<A extends Any> = Omit<AllNever, 'tag'> & {
    tag: EqualOperator<Tag<A>> | Tag<A>;
};
declare function isTagEqual<A extends Any>(operator: WhereOperator<A>): operator is TagEqual<A>;
type KindEqual<A extends Any> = Omit<AllNever, 'kind'> & {
    kind: EqualOperator<AllKinds<A>> | AllKinds<A>;
};
declare function isKindEqual<A extends Any>(operator: WhereOperator<A>): operator is KindEqual<A>;
type Participant = 'source' | 'target';
type ParticipantOperator<A extends Any> = Omit<AllNever, 'participant' | 'operator'> & {
    participant: Participant;
    operator: KindEqual<A> | TagEqual<A>;
};
declare function isParticipantOperator<A extends Any>(operator: WhereOperator<A>): operator is ParticipantOperator<A>;
type NotOperator<A extends Any> = Omit<AllNever, 'not'> & {
    not: WhereOperator<A>;
};
declare function isNotOperator<A extends Any>(operator: WhereOperator<A>): operator is NotOperator<A>;
type AndOperator<A extends Any> = Omit<AllNever, 'and'> & {
    and: NonEmptyArray<WhereOperator<A>>;
};
declare function isAndOperator<A extends Any>(operator: WhereOperator<A>): operator is AndOperator<A>;
type OrOperator<A extends Any> = Omit<AllNever, 'or'> & {
    or: NonEmptyArray<WhereOperator<A>>;
};
declare function isOrOperator<A extends Any>(operator: WhereOperator<A>): operator is OrOperator<A>;
type WhereOperator<A extends Any = Any> = TagEqual<A> | KindEqual<A> | ParticipantOperator<A> | NotOperator<A> | AndOperator<A> | OrOperator<A>;
type Filterable<A extends Any> = {
    tags?: Tags<A> | null | undefined;
    kind?: AllKinds<A> | null | undefined;
    source?: Filterable<A>;
    target?: Filterable<A>;
};
type OperatorPredicate<A extends Any> = (value: Filterable<A>) => boolean;
declare function whereOperatorAsPredicate<A extends Any>(operator: WhereOperator<A>): OperatorPredicate<A>;

type AnyAux = Any;
type PredicateSelector = 'children' | 'expanded' | 'descendants';
declare namespace FqnExpr {
    type Wildcard = {
        wildcard: true;
    };
    function isWildcard<A extends AnyAux>(expr: Expression<A>): expr is FqnExpr.Wildcard;
    interface ModelRef<M extends AnyAux = AnyAux> {
        ref: FqnRef.ModelRef<M>;
        selector?: PredicateSelector;
    }
    function isModelRef<A extends AnyAux>(ref: Expression<A>): ref is FqnExpr.ModelRef<A>;
    interface DeploymentRef<A extends AnyAux = AnyAux> {
        ref: FqnRef.DeploymentRef<A>;
        selector?: PredicateSelector;
    }
    function isDeploymentRef<A extends AnyAux>(expr: Expression<A>): expr is FqnExpr.DeploymentRef<A>;
    interface ElementKindExpr<A extends AnyAux = AnyAux> {
        elementKind: ElementKind<A>;
        isEqual: boolean;
    }
    function isElementKindExpr<A extends AnyAux>(expr: Expression<A>): expr is ElementKindExpr<A>;
    interface ElementTagExpr<A extends AnyAux = AnyAux> {
        elementTag: Tag<A>;
        isEqual: boolean;
    }
    function isElementTagExpr<A extends AnyAux>(expr: Expression<A>): expr is ElementTagExpr<A>;
    type NonWildcard<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        ModelRef: ModelRef<A>;
        DeploymentRef: DeploymentRef<A>;
        ElementKind: ElementKindExpr<A>;
        ElementTag: ElementTagExpr<A>;
    }>;
    interface Where<A extends AnyAux = AnyAux> {
        where: {
            expr: ExclusiveUnion<{
                Wildcard: Wildcard;
                ModelRef: ModelRef<A>;
                DeploymentRef: DeploymentRef<A>;
                ElementKind: ElementKindExpr<A>;
                ElementTag: ElementTagExpr<A>;
            }>;
            condition: WhereOperator<A>;
        };
    }
    function isWhere<A extends AnyAux>(expr: Expression<A>): expr is FqnExpr.Where<A>;
    interface Custom<A extends AnyAux = AnyAux> {
        custom: {
            expr: OrWhere<A>;
            title?: string;
            description?: MarkdownOrString;
            technology?: string;
            notation?: string;
            shape?: ElementShape;
            color?: Color;
            icon?: Icon;
            border?: BorderStyle;
            opacity?: number;
            navigateTo?: StrictViewId<A>;
            multiple?: boolean;
            size?: ShapeSize;
            padding?: ShapeSize;
            textSize?: ShapeSize;
        };
    }
    function isCustom<A extends AnyAux>(expr: Expression<A>): expr is Custom<A>;
    function is<A extends AnyAux>(expr: Expression<A>): expr is FqnExpr<A>;
    type OrWhere<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Wildcard: FqnExpr.Wildcard;
        ModelRef: FqnExpr.ModelRef<A>;
        DeploymentRef: FqnExpr.DeploymentRef<A>;
        ElementKind: ElementKindExpr<A>;
        ElementTag: ElementTagExpr<A>;
        Where: FqnExpr.Where<A>;
    }>;
    type Any<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Wildcard: Wildcard;
        ModelRef: ModelRef<A>;
        DeploymentRef: DeploymentRef<A>;
        ElementKind: ElementKindExpr<A>;
        ElementTag: ElementTagExpr<A>;
        Where: Where<A>;
        Custom: Custom<A>;
    }>;
    function unwrap<A extends AnyAux>(expr: FqnExpr.Any<A>): Wildcard | ModelRef<A> | DeploymentRef<A> | ElementKindExpr<A> | ElementTagExpr<A>;
}
type FqnExpr<A extends AnyAux = AnyAux> = ExclusiveUnion<{
    Wildcard: FqnExpr.Wildcard;
    ModelRef: FqnExpr.ModelRef<A>;
    DeploymentRef: FqnExpr.DeploymentRef<A>;
    ElementKind: FqnExpr.ElementKindExpr<A>;
    ElementTag: FqnExpr.ElementTagExpr<A>;
}>;
declare namespace RelationExpr {
    type Endpoint<A extends AnyAux = AnyAux> = FqnExpr.Where<A>['where']['expr'];
    interface Direct<A extends AnyAux = AnyAux> {
        source: Endpoint<A>;
        target: Endpoint<A>;
        isBidirectional?: boolean;
    }
    function isDirect<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.Direct<A>;
    interface Incoming<A extends AnyAux = AnyAux> {
        incoming: Endpoint<A>;
    }
    function isIncoming<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.Incoming<A>;
    interface Outgoing<A extends AnyAux = AnyAux> {
        outgoing: Endpoint<A>;
    }
    function isOutgoing<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.Outgoing<A>;
    interface InOut<A extends AnyAux = AnyAux> {
        inout: Endpoint<A>;
    }
    function isInOut<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.InOut<A>;
    interface Where<A extends AnyAux = AnyAux> {
        where: {
            expr: ExclusiveUnion<{
                Direct: RelationExpr.Direct<A>;
                Incoming: RelationExpr.Incoming<A>;
                Outgoing: RelationExpr.Outgoing<A>;
                InOut: RelationExpr.InOut<A>;
            }>;
            condition: WhereOperator<A>;
        };
    }
    function isWhere<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.Where<A>;
    interface Custom<A extends AnyAux = AnyAux> {
        customRelation: {
            expr: OrWhere<A>;
            title?: string;
            description?: string;
            technology?: string;
            notation?: string;
            navigateTo?: StrictViewId<A>;
            notes?: string;
            color?: Color;
            line?: RelationshipLineType;
            head?: RelationshipArrowType;
            tail?: RelationshipArrowType;
        };
    }
    function isCustom<A extends AnyAux>(expr: Expression<A>): expr is Custom<A>;
    function is<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr<A>;
    type OrWhere<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Direct: Direct<A>;
        Incoming: Incoming<A>;
        Outgoing: Outgoing<A>;
        InOut: InOut<A>;
        Where: Where<A>;
    }>;
    type Any<A extends AnyAux = AnyAux> = ExclusiveUnion<{
        Direct: Direct<A>;
        Incoming: Incoming<A>;
        Outgoing: Outgoing<A>;
        InOut: InOut<A>;
        Where: Where<A>;
        Custom: Custom<A>;
    }>;
    function unwrap<A extends AnyAux>(expr: RelationExpr.Any<A>): Direct<A> | Incoming<A> | Outgoing<A> | InOut<A>;
}
type RelationExpr<A extends AnyAux = AnyAux> = ExclusiveUnion<{
    Direct: RelationExpr.Direct<A>;
    Incoming: RelationExpr.Incoming<A>;
    Outgoing: RelationExpr.Outgoing<A>;
    InOut: RelationExpr.InOut<A>;
}>;
/**
 * Represents a version 2 expression which can be one of several types.
 *
 * @template D - The type for the deployment FQN, defaults to `Fqn`.
 * @template M - The type for the model FQN, defaults to `Fqn`.
 */
type Expression<A extends AnyAux = AnyAux> = ExclusiveUnion<{
    Wildcard: FqnExpr.Wildcard;
    ModelRef: FqnExpr.ModelRef<A>;
    DeploymentRef: FqnExpr.DeploymentRef<A>;
    ElementKind: FqnExpr.ElementKindExpr<A>;
    ElementTag: FqnExpr.ElementTagExpr<A>;
    Custom: FqnExpr.Custom<A>;
    Direct: RelationExpr.Direct<A>;
    Incoming: RelationExpr.Incoming<A>;
    Outgoing: RelationExpr.Outgoing<A>;
    InOut: RelationExpr.InOut<A>;
    Where: Expression.Where<A>;
    CustomRelation: RelationExpr.Custom<A>;
}>;
declare namespace Expression {
    type Where<A extends AnyAux = AnyAux> = FqnExpr.Where<A> | RelationExpr.Where<A>;
    function isWhere<A extends AnyAux>(expr: Expression<A>): expr is Expression.Where<A>;
    function isRelationWhere<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.Where<A>;
    function isFqnExprWhere<A extends AnyAux>(expr: Expression<A>): expr is FqnExpr.Where<A>;
    function isFqnExpr<A extends AnyAux>(expr: Expression<A>): expr is FqnExpr.Any<A>;
    function isRelation<A extends AnyAux>(expr: Expression<A>): expr is RelationExpr.Any<A>;
}

export { type AndOperator as A, type BorderStyle as B, type Color as C, ElementShapes as D, type ElementColorValues as E, FqnExpr as F, type ColorLiteral as G, type HexColor as H, RelationshipArrowTypes as I, ThemeColors as J, type KindEqual as K, type LikeC4StylesConfig as L, isThemeColor as M, type NotOperator as N, type OrOperator as O, type PredicateSelector as P, type CustomColorDefinitions as Q, type RelationshipColorValues as R, type SpacingSize as S, type ThemeColor as T, type CustomColor as U, isCustomColor as V, type WhereOperator as W, type LikeC4Theme as a, type LikeC4StyleDefaults as b, type ThemeColorValues as c, type TextSize as d, type ShapeSize as e, type RelationshipLineType as f, type RelationshipArrowType as g, type ElementShape as h, RelationExpr as i, Expression as j, type EqualOperator as k, type TagEqual as l, isTagEqual as m, isKindEqual as n, type Participant as o, type ParticipantOperator as p, isParticipantOperator as q, isNotOperator as r, isAndOperator as s, isOrOperator as t, type Filterable as u, type OperatorPredicate as v, whereOperatorAsPredicate as w, Sizes as x, type Size as y, BorderStyles as z };
