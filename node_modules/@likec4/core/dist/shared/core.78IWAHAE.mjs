import { c as customInspectSymbol } from './core.BFd1lU9R.mjs';
import { e } from './core.BoYfZOBm.mjs';
import { i as intersection, u as union, d as difference, e as equals } from './core.DbfO90vF.mjs';
import { s as stringHash } from './core.oSV6SRfk.mjs';
import { t } from './core.3ZhnKAlZ.mjs';
import { t as t$1 } from './core.CbT8JVYL.mjs';
import { b as isDescendantOf, i as isAncestor, e as isString, s as sortNaturalByFqn, d as isSameHierarchy } from './core.CdNCAwq7.mjs';
import { i as isome } from './core.FZ305VYd.mjs';
import { i as ifilter } from './core.DRJma0Ol.mjs';
import { i as invariant } from './core.D4npX2q8.mjs';

function isNestedConnection(nested, parent) {
  if (!parent) {
    const p = nested;
    return (n) => isNestedConnection(n, p);
  }
  const isSameSource = nested.source === parent.source;
  const isSameTarget = nested.target === parent.target;
  if (isSameSource && isSameTarget) {
    return false;
  }
  const isSourceNested = isAncestor(parent.source.id, nested.source.id);
  const isTargetNested = isAncestor(parent.target.id, nested.target.id);
  return isSourceNested && isTargetNested || isSameSource && isTargetNested || isSameTarget && isSourceNested;
}
function findDeepestNestedConnection(connections, connection) {
  let deepest = connection;
  for (const c of connections) {
    if (isNestedConnection(c, deepest)) {
      deepest = c;
    }
  }
  return deepest !== connection ? deepest : null;
}
function sortDeepestFirst(connections) {
  const sorted = [];
  const unsorted = connections.slice();
  let next;
  while (next = unsorted.shift()) {
    let deepest;
    while (deepest = findDeepestNestedConnection(unsorted, next)) {
      const index = unsorted.indexOf(deepest);
      sorted.push(unsorted.splice(index, 1)[0]);
    }
    sorted.push(next);
  }
  return sorted;
}
function boundaryHierarchy(conn) {
  return conn.boundary?.id ? `.${conn.boundary.id}` : "";
}
function sortConnectionsByBoundaryHierarchy(connections, sort) {
  if (!connections || isString(connections)) {
    const dir = connections ?? "asc";
    return (arr) => _sortByBoundary(arr, dir);
  }
  return _sortByBoundary(connections, sort ?? "asc");
}
function _sortByBoundary(connections, order) {
  return t(
    connections,
    t$1((conn) => ({
      id: boundaryHierarchy(conn),
      conn
    })),
    sortNaturalByFqn(order),
    t$1((p) => p.conn)
  );
}
function findAscendingConnections(connections, connection) {
  return connections.filter((c) => isNestedConnection(connection, c));
}
function findDescendantConnections(connections, connection) {
  return connections.filter(isNestedConnection(connection));
}
function mergeConnections(connections) {
  const map2 = /* @__PURE__ */ new Map();
  for (const conn of connections) {
    const existing = map2.get(conn.id);
    if (existing) {
      map2.set(conn.id, conn.mergeWith(existing));
    } else {
      map2.set(conn.id, conn);
    }
  }
  return [...map2.values()];
}
function differenceConnections(source, exclude) {
  const minus = new Map([...exclude].map((c) => [c.id, c]));
  return [...source].reduce((acc, c) => {
    const other = minus.get(c.id);
    if (!other) {
      acc.push(c);
      return acc;
    }
    const updated = c.difference(other);
    if (updated.nonEmpty()) {
      acc.push(updated);
    }
    return acc;
  }, []);
}
function hasSameSourceTarget(a, b) {
  if (b) {
    return a.source === b.source && a.target === b.target;
  }
  return (b2) => a.source === b2.source && a.target === b2.target;
}
function hasSameSource(a, b) {
  if (b) {
    return a.source === b.source;
  }
  return (b2) => a.source === b2.source;
}
function hasSameTarget(a, b) {
  if (b) {
    return a.target === b.target;
  }
  return (b2) => a.target === b2.target;
}
function isOutgoing(a, source) {
  if (!source) {
    const _source = a;
    return (b) => isOutgoing(b, _source);
  }
  const at = a;
  return isDescendantOf(at.source, source) && !isDescendantOf(at.target, source);
}
function isIncoming(a, target) {
  if (!target) {
    const _target = a;
    return (b) => isIncoming(b, _target);
  }
  const at = a;
  return isDescendantOf(at.target, target) && !isDescendantOf(at.source, target);
}
function isAnyInOut(a, source) {
  if (!source) {
    const _source = a;
    return (b) => isAnyInOut(b, _source);
  }
  const at = a;
  return isDescendantOf(at.source, source) !== isDescendantOf(at.target, source);
}

function findConnection(source, target, direction = "directed") {
  if (source === target) {
    return [];
  }
  if (isSameHierarchy(source, target)) {
    return [];
  }
  const directedIntersection = intersection(source.allOutgoing, target.allIncoming);
  const directed = directedIntersection.size > 0 ? new ConnectionModel(
    source,
    target,
    directedIntersection
  ) : null;
  if (direction === "directed") {
    return directed ? [directed] : [];
  }
  const reverseIntersection = intersection(source.allIncoming, target.allOutgoing);
  const reverse = reverseIntersection.size > 0 ? new ConnectionModel(
    target,
    source,
    reverseIntersection
  ) : null;
  if (directed && reverse) {
    return [directed, reverse];
  }
  if (directed) {
    return [directed];
  }
  if (reverse) {
    return [reverse];
  }
  return [];
}
function findConnectionsBetween(element, others, direction = "both") {
  if (element.allIncoming.size === 0 && element.allOutgoing.size === 0) {
    return [];
  }
  const outgoing = [];
  const incoming = [];
  for (const _other of others) {
    if (element === _other) {
      continue;
    }
    for (const found of findConnection(element, _other, direction)) {
      if (found.source === element) {
        outgoing.push(found);
      } else {
        incoming.push(found);
      }
    }
  }
  return [
    ...outgoing,
    ...incoming
  ];
}
function findConnectionsWithin(elements) {
  return [...elements].reduce((acc, el, index, array) => {
    if (index === array.length - 1) {
      return acc;
    }
    acc.push(
      ...findConnectionsBetween(el, array.slice(index + 1), "both")
    );
    return acc;
  }, []);
}

const modelConnection = {
  __proto__: null,
  findConnection: findConnection,
  findConnectionsBetween: findConnectionsBetween,
  findConnectionsWithin: findConnectionsWithin
};

class ConnectionModel {
  constructor(source, target, relations = /* @__PURE__ */ new Set()) {
    this.source = source;
    this.target = target;
    this.relations = relations;
    this.id = stringHash(`model:${source.id}:${target.id}`);
  }
  id;
  _boundary;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the connection.
   */
  get boundary() {
    return this._boundary ??= this.source.commonAncestor(this.target);
  }
  /**
   * Human readable expression of the connection
   * Mostly used for testing and debugging
   */
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  /**
   * Returns true if only includes relations between the source and target elements.
   */
  get isDirect() {
    return this.nonEmpty() && !this.isImplicit;
  }
  /**
   * Returns true if includes relations between nested elements of the source and target elements.
   */
  get isImplicit() {
    return this.nonEmpty() && isome(this.relations, e(hasSameSourceTarget(this)));
  }
  get directRelations() {
    return new Set(ifilter(this.relations, hasSameSourceTarget(this)));
  }
  nonEmpty() {
    return this.relations.size > 0;
  }
  mergeWith(other) {
    invariant(this.source.id === other.source.id, "Cannot merge connections with different sources");
    invariant(this.target.id === other.target.id, "Cannot merge connections with different targets");
    return new ConnectionModel(
      this.source,
      this.target,
      union(this.relations, other.relations)
    );
  }
  difference(other) {
    return new ConnectionModel(
      this.source,
      this.target,
      difference(this.relations, other.relations)
    );
  }
  intersect(other) {
    invariant(other instanceof ConnectionModel, "Cannot intersect connection with different type");
    return new ConnectionModel(
      this.source,
      this.target,
      intersection(this.relations, other.relations)
    );
  }
  equals(other) {
    invariant(other instanceof ConnectionModel, "Cannot merge connection with different type");
    const _other = other;
    return this.id === _other.id && this.source.id === _other.source.id && this.target.id === _other.target.id && equals(this.relations, _other.relations);
  }
  /**
   * Returns a new instance with the updated relations.
   *
   * @param relations - A readonly set of `RelationshipModel` instances representing the new relations.
   * @returns A new `ConnectionModel` instance with the updated relations.
   */
  update(relations) {
    return new ConnectionModel(
      this.source,
      this.target,
      relations
    );
  }
  [customInspectSymbol](_depth, _inspectOptions, _inspect) {
    const asString = this.toString();
    Object.defineProperty(asString, "constructor", {
      value: ConnectionModel,
      enumerable: false
    });
    return asString;
  }
  toString() {
    return [
      this.expression,
      this.relations.size ? "  relations:" : "  relations: [ ]",
      ...[...this.relations].map((c) => "    " + c.expression)
    ].join("\n");
  }
  /**
   * Creates a new connection with reversed direction (target becomes source and vice versa)
   * @param search - When true, attempts to find an existing connection between the reversed nodes
   */
  reversed(search = false) {
    if (!search) {
      return new ConnectionModel(this.target, this.source);
    }
    const [found] = findConnection(this.target, this.source, "directed");
    return found ?? new ConnectionModel(this.target, this.source, /* @__PURE__ */ new Set());
  }
}

export { ConnectionModel as C, findDeepestNestedConnection as a, findDescendantConnections as b, hasSameSourceTarget as c, differenceConnections as d, hasSameTarget as e, findAscendingConnections as f, isIncoming as g, hasSameSource as h, isAnyInOut as i, isNestedConnection as j, isOutgoing as k, sortDeepestFirst as l, mergeConnections as m, modelConnection as n, findConnectionsBetween as o, findConnection as p, findConnectionsWithin as q, sortConnectionsByBoundaryHierarchy as s };
