import { Tagged } from 'type-fest';

type ProjectId<T = string> = Tagged<T, 'ProjectID'>;
declare function ProjectId(name: string): ProjectId;
type MarkdownOrString = {
    txt: string;
    md?: never;
} | {
    md: string;
    txt?: never;
};
/**
 * Converts a MarkdownOrString object or a plain string into a simple string representation.
 * This utility function handles different types of text content and normalizes them to a string format.
 *
 * @param value - The content to be flattened.
 *   Can be one of:
 *   - A plain string
 *   - A MarkdownOrString object with either txt or md property
 *   - undefined or null
 *
 * @returns The string content contained within the input value.
 *   - Returns the input directly if it's already a string
 *   - Returns the txt property if available in a MarkdownOrString object
 *   - Falls back to the md property if txt is not available
 *   - Returns null if:
 *     - The input is null or undefined
 *     - The resulting string value is empty, whitespace, or null
 *
 * @example
 * // String input
 * flattenMarkdownOrString("Hello world") // Returns: "Hello world"
 * flattenMarkdownOrString("   ") // Returns: null
 *
 * // MarkdownOrString with txt property
 * flattenMarkdownOrString({ txt: "Plain text" }) // Returns: "Plain text"
 * flattenMarkdownOrString({ txt: "   " }) // Returns: null
 *
 * // MarkdownOrString with md property
 * flattenMarkdownOrString({ md: "**Bold markdown**" }) // Returns: "**Bold markdown**"
 *
 * // Null input
 * flattenMarkdownOrString(null) // Returns: null
 */
declare function flattenMarkdownOrString(value: MarkdownOrString | string): string;
declare function flattenMarkdownOrString(value: MarkdownOrString | string | undefined | null): string | null;
type BuiltInIcon = 'none' | `${'aws' | 'azure' | 'gcp' | 'tech' | 'bootstrap'}:${string}`;
type Icon = Tagged<string, 'Icon'> | BuiltInIcon;
declare const NoneIcon: Icon;
type IconUrl = Icon;
/**
 * Full-qualified-name for model elements
 *
 * @param This - Fqn of the element (specific element)
 * @param All - The type of all known FQNs
 *
 * @example
 * ```ts
 * type ElementAFqn = Fqn<'a', 'a' | ' | 'b'>
 *
 * ```
 */
type Fqn<Id = string> = Tagged<Id, 'Fqn'>;
declare function Fqn(name: string, parent?: Fqn | null): Fqn;
type ElementKind<Kinds = string> = Tagged<Kinds, 'ElementKind'>;
declare const GroupElementKind: ElementKind<"@group">;
type GroupElementKind = typeof GroupElementKind;
declare function isGroupElementKind<V extends {
    kind?: any;
}>(v: V): v is V & {
    kind: GroupElementKind;
};
/**
 * Full-qualified-name for deployment elements
 */
type DeploymentFqn<T = string> = Tagged<T, 'DeploymentFqn'>;
declare function DeploymentFqn(name: string, parent?: DeploymentFqn | null): DeploymentFqn;
type DeploymentKind<Kinds = string> = Tagged<Kinds, 'DeploymentKind'>;
type ViewId<Id = string> = Tagged<Id, 'ViewId'>;
declare function ViewId(id: string): ViewId;
type AnyFqn<T = string> = DeploymentFqn<T> | Fqn<T>;
/**
 * @deprecated Use {@link RelationshipKind} instead
 */
type RelationKind<Kinds = string> = RelationshipKind<Kinds>;
type RelationshipKind<Kinds = string> = Tagged<Kinds, 'RelationshipKind'>;
type RelationId<Id = string> = Tagged<Id, 'RelationId'>;
declare function RelationId(id: string): RelationId;
type Tag<T = string> = Tagged<T, 'Tag'>;
type GlobalFqn<Id = string> = Tagged<Fqn<Id>, 'GlobalFqn'>;
declare function GlobalFqn<A>(projectId: A | ProjectId<A>, name: string): GlobalFqn<A>;
declare function isGlobalFqn<A extends string>(fqn: A): fqn is GlobalFqn<A>;
declare function splitGlobalFqn<I extends string>(fqn: Fqn<I> | GlobalFqn<I>): [ProjectId | null, Fqn<I>];
type NodeId = Tagged<string, 'NodeId' | 'Fqn' | 'DeploymentFqn'>;
declare function NodeId(id: string): NodeId;
type EdgeId = Tagged<string, 'EdgeId'>;
declare function EdgeId(id: string): EdgeId;
type StepEdgeIdLiteral = `step-${number}` | `step-${number}.${number}`;
type StepEdgeId = Tagged<StepEdgeIdLiteral, 'EdgeId'>;
declare function stepEdgeId(step: number, parallelStep?: number): StepEdgeId;
declare const StepEdgeKind = "@step";
declare function isStepEdgeId(id: string): id is StepEdgeId;
declare function extractStep(id: EdgeId): number;

type scalar_AnyFqn<T = string> = AnyFqn<T>;
type scalar_BuiltInIcon = BuiltInIcon;
declare const scalar_DeploymentFqn: typeof DeploymentFqn;
type scalar_DeploymentKind<Kinds = string> = DeploymentKind<Kinds>;
declare const scalar_EdgeId: typeof EdgeId;
type scalar_ElementKind<Kinds = string> = ElementKind<Kinds>;
declare const scalar_Fqn: typeof Fqn;
declare const scalar_GlobalFqn: typeof GlobalFqn;
type scalar_GroupElementKind = GroupElementKind;
type scalar_Icon = Icon;
type scalar_IconUrl = IconUrl;
type scalar_MarkdownOrString = MarkdownOrString;
declare const scalar_NodeId: typeof NodeId;
declare const scalar_NoneIcon: typeof NoneIcon;
declare const scalar_ProjectId: typeof ProjectId;
declare const scalar_RelationId: typeof RelationId;
type scalar_RelationKind<Kinds = string> = RelationKind<Kinds>;
type scalar_RelationshipKind<Kinds = string> = RelationshipKind<Kinds>;
type scalar_StepEdgeId = StepEdgeId;
type scalar_StepEdgeIdLiteral = StepEdgeIdLiteral;
declare const scalar_StepEdgeKind: typeof StepEdgeKind;
type scalar_Tag<T = string> = Tag<T>;
declare const scalar_ViewId: typeof ViewId;
declare const scalar_extractStep: typeof extractStep;
declare const scalar_flattenMarkdownOrString: typeof flattenMarkdownOrString;
declare const scalar_isGlobalFqn: typeof isGlobalFqn;
declare const scalar_isGroupElementKind: typeof isGroupElementKind;
declare const scalar_isStepEdgeId: typeof isStepEdgeId;
declare const scalar_splitGlobalFqn: typeof splitGlobalFqn;
declare const scalar_stepEdgeId: typeof stepEdgeId;
declare namespace scalar {
  export { type scalar_AnyFqn as AnyFqn, type scalar_BuiltInIcon as BuiltInIcon, scalar_DeploymentFqn as DeploymentFqn, type scalar_DeploymentKind as DeploymentKind, scalar_EdgeId as EdgeId, type scalar_ElementKind as ElementKind, scalar_Fqn as Fqn, scalar_GlobalFqn as GlobalFqn, type scalar_GroupElementKind as GroupElementKind, type scalar_Icon as Icon, type scalar_IconUrl as IconUrl, type scalar_MarkdownOrString as MarkdownOrString, scalar_NodeId as NodeId, scalar_NoneIcon as NoneIcon, scalar_ProjectId as ProjectId, scalar_RelationId as RelationId, type scalar_RelationKind as RelationKind, type scalar_RelationshipKind as RelationshipKind, type scalar_StepEdgeId as StepEdgeId, type scalar_StepEdgeIdLiteral as StepEdgeIdLiteral, scalar_StepEdgeKind as StepEdgeKind, type scalar_Tag as Tag, scalar_ViewId as ViewId, scalar_extractStep as extractStep, scalar_flattenMarkdownOrString as flattenMarkdownOrString, scalar_isGlobalFqn as isGlobalFqn, scalar_isGroupElementKind as isGroupElementKind, scalar_isStepEdgeId as isStepEdgeId, scalar_splitGlobalFqn as splitGlobalFqn, scalar_stepEdgeId as stepEdgeId };
}

export { type AnyFqn as A, type BuiltInIcon as B, DeploymentFqn as D, type ElementKind as E, Fqn as F, GroupElementKind as G, type Icon as I, type MarkdownOrString as M, NoneIcon as N, ProjectId as P, type RelationKind as R, type StepEdgeIdLiteral as S, type Tag as T, ViewId as V, type IconUrl as a, type DeploymentKind as b, type RelationshipKind as c, RelationId as d, GlobalFqn as e, flattenMarkdownOrString as f, isGlobalFqn as g, splitGlobalFqn as h, isGroupElementKind as i, NodeId as j, EdgeId as k, type StepEdgeId as l, stepEdgeId as m, StepEdgeKind as n, isStepEdgeId as o, extractStep as p, scalar as s };
