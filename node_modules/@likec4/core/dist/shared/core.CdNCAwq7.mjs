import { c as compareNatural } from './core.3ZhnKAlZ.mjs';

function isString(value) {
  return value != null && typeof value === "string";
}
function isNonEmptyArray(arr) {
  return !!arr && Array.isArray(arr) && arr.length > 0;
}
function hasProp(value, path) {
  return value[path] != null;
}
function isAnyOf(...predicates) {
  return (value) => {
    return predicates.some((predicate) => predicate(value));
  };
}

function parentFqn(fqn) {
  const lastDot = fqn.lastIndexOf(".");
  if (lastDot > 0) {
    return fqn.slice(0, lastDot);
  }
  return null;
}
function nameFromFqn(fqn) {
  const lastDot = fqn.lastIndexOf(".");
  if (lastDot > 0) {
    return fqn.slice(lastDot + 1);
  } else {
    return fqn;
  }
}
const asString = (e) => isString(e) ? e : e.id;
function isAncestor(arg1, arg2) {
  const arg1Id = asString(arg1);
  if (arg2) {
    const arg2Id = asString(arg2);
    return arg2Id.startsWith(arg1Id + ".");
  }
  return (ancestor) => {
    const ancestorId = asString(ancestor);
    return arg1Id.startsWith(ancestorId + ".");
  };
}
function isSameHierarchy(one, another) {
  if (!another) {
    return (b) => isSameHierarchy(one, b);
  }
  const first = asString(one);
  const second = asString(another);
  return first === second || second.startsWith(first + ".") || first.startsWith(second + ".");
}
function isDescendantOf(descedant, ancestor) {
  if (!ancestor) {
    return (d) => isAncestor(descedant, d);
  }
  return isAncestor(ancestor, descedant);
}
function hierarchyLevel(elementOfFqn) {
  const first = isString(elementOfFqn) ? elementOfFqn : elementOfFqn.id;
  return first.split(".").length;
}
function hierarchyDistance(one, another) {
  const first = isString(one) ? one : one.id;
  const second = isString(another) ? another : another.id;
  if (first === second) {
    return 0;
  }
  const firstDepth = hierarchyLevel(first);
  const secondDepth = hierarchyLevel(second);
  if (isSameHierarchy(first, second)) {
    return Math.abs(firstDepth - secondDepth);
  }
  const ancestor = commonAncestor(first, second);
  const ancestorDepth = ancestor ? hierarchyLevel(ancestor) : 0;
  return firstDepth + secondDepth - (2 * ancestorDepth + 1);
}
function commonAncestor(first, second) {
  const a = first.split(".");
  if (a.length < 2) {
    return null;
  }
  const b = second.split(".");
  if (b.length < 2) {
    return null;
  }
  let ancestor = [];
  for (let i = 0; i < Math.min(a.length, b.length) - 1 && a[i] === b[i]; i++) {
    ancestor.push(a[i]);
  }
  if (ancestor.length === 0) {
    return null;
  }
  return ancestor.join(".");
}
function ancestorsFqn(fqn) {
  const path = fqn.split(".");
  path.pop();
  if (path.length === 0) {
    return [];
  }
  return path.reduce((acc, part, idx) => {
    if (idx === 0) {
      acc.push(part);
      return acc;
    }
    acc.unshift(`${acc[0]}.${part}`);
    return acc;
  }, []);
}
function compareFqnHierarchically(a, b) {
  const depthA = a.split(".").length;
  const depthB = b.split(".").length;
  switch (true) {
    case depthA > depthB: {
      return 1;
    }
    case depthA < depthB: {
      return -1;
    }
    default: {
      return 0;
    }
  }
}
function compareByFqnHierarchically(a, b) {
  return compareFqnHierarchically(a.id, b.id);
}
function sortByFqnHierarchically(array) {
  return array.map((item) => ({ item, fqn: item.id.split(".") })).sort((a, b) => {
    return a.fqn.length - b.fqn.length;
  }).map(({ item }) => item);
}
function findTopAncestor(items, item) {
  let parent = item;
  for (const e of items) {
    if (isAncestor(e, parent)) {
      parent = e;
    }
  }
  return parent !== item ? parent : null;
}
function sortParentsFirst(array) {
  const result = [];
  const items = [...array];
  let item;
  while (item = items.shift()) {
    let parent;
    while (parent = findTopAncestor(items, item)) {
      result.push(items.splice(items.indexOf(parent), 1)[0]);
    }
    result.push(item);
  }
  return result;
}
function sortNaturalByFqn(array, sort) {
  if (!array || isString(array)) {
    const dir2 = array ?? "asc";
    return (arr) => sortNaturalByFqn(arr, dir2);
  }
  const dir = sort === "desc" ? -1 : 1;
  return array.map((item) => ({ item, fqn: item.id.split(".") })).sort((a, b) => {
    if (a.fqn.length !== b.fqn.length) {
      return (a.fqn.length - b.fqn.length) * dir;
    }
    for (let i = 0; i < a.fqn.length; i++) {
      const compare = compareNatural(a.fqn[i], b.fqn[i]);
      if (compare !== 0) {
        return compare;
      }
    }
    return 0;
  }).map(({ item }) => item);
}

export { ancestorsFqn as a, isDescendantOf as b, isNonEmptyArray as c, isSameHierarchy as d, isString as e, sortParentsFirst as f, commonAncestor as g, hasProp as h, isAncestor as i, compareByFqnHierarchically as j, compareFqnHierarchically as k, hierarchyDistance as l, hierarchyLevel as m, nameFromFqn as n, sortByFqnHierarchically as o, parentFqn as p, isAnyOf as q, sortNaturalByFqn as s };
