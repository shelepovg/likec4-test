import { I as IterableContainer, R as ReorderedArray, N as NonEmptyArray } from './core.DB0Ue5Wx.mjs';
import { F as Fqn } from './core.C_3y3eqV.mjs';
import { SetRequired, SetNonNullable } from 'type-fest';

/**
 * Mnemonist DefaultWeakMap Typings
 * ================================
 */
declare class DefaultWeakMap<K extends object, V> {

  // Constructor
  constructor(factory: (key: K) => V);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  peek(key: K): V | undefined;
  inspect(): any;
}

/**
 * Mnemonist LinkedList Typings
 * =============================
 */
declare class LinkedList<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  first(): T | undefined;
  last(): T | undefined;
  peek(): T | undefined;
  push(value: T): number;
  shift(): T | undefined;
  unshift(value: T): number;
  forEach(callback: (value: T, index: number, list: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): LinkedList<I>;
}

/**
 * Mnemonist Queue Typings
 * ========================
 */
declare class Queue<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  enqueue(item: T): number;
  dequeue(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, queue: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): Queue<I>;
  static of<I>(...items: Array<I>): Queue<I>;
}

interface MultiMapConstructor {
  new <K, V>(container: SetConstructor): MultiMap<K, V, Set<V>>;
  new <K, V>(container?: ArrayConstructor): MultiMap<K, V, V[]>;

  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container: SetConstructor
  ): MultiMap<K, V, Set<V>>;
  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container?: ArrayConstructor
  ): MultiMap<K, V, V[]>;
}
/**
 * Mnemonist MultiMap Typings
 * ===========================
 */

interface MultiMap<K, V, C extends V[] | Set<V> = V[]> extends Iterable<[K, V]> {

  // Members
  dimension: number;
  size: number;

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  remove(key: K, value: V): boolean;
  has(key: K): boolean;
  get(key: K): C | undefined;
  multiplicity(key: K): number;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  forEachAssociation(callback: (value: C, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  containers(): IterableIterator<C>;
  associations(): IterableIterator<[K, C]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
  toJSON(): any;
}

declare const MultiMap: MultiMapConstructor;

/**
 * Mnemonist BiMap Typings
 * ========================
 */
declare class InverseMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;
  inverse: BiMap<V, K>;

  // Constructor
  constructor(original: BiMap<K, V>);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
}

declare class BiMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;
  inverse: InverseMap<V, K>;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static from<I, J>(iterable: Iterable<[I, J]> | {[key: string]: J}): BiMap<I, J>;
}

declare function nonNullable<T>(value: T, message?: string | (() => string)): NonNullable<T>;
declare function invariant(condition: any, message?: string): asserts condition;
declare function nonexhaustive(value: never): never;

declare function parentFqn<E extends string>(fqn: E): E | null;
declare function nameFromFqn<E extends string>(fqn: E): string;
/**
 * Check if one element is an ancestor of another
 * Composable version
 * @signature
 *  isAncestor(another)(ancestor)
 */
declare function isAncestor<A extends string | {
    id: string;
}>(another: NoInfer<A>): (ancestor: A) => boolean;
/**
 * Check if one element is an ancestor of another
 * @signature
 *   isAncestor(ancestor, another)
 */
declare function isAncestor<A extends string | {
    id: string;
}>(ancestor: A, another: A): boolean;
declare function isSameHierarchy<T extends string>(one: NoInfer<T> | WithId<NoInfer<T>>): (another: T | WithId<T>) => boolean;
declare function isSameHierarchy<T extends string>(one: T | WithId<T>, another: T | WithId<T>): boolean;
type WithId<T = string> = {
    id: T;
};
declare function isDescendantOf<T extends string>(ancestor: WithId<T>): (descedant: WithId<T>) => boolean;
declare function isDescendantOf<T extends string>(descedant: WithId<T>, ancestor: WithId<T>): boolean;
/**
 * How deep in the hierarchy the element is.
 * Root element has depth 1
 */
declare function hierarchyLevel<E extends string | {
    id: Fqn;
}>(elementOfFqn: E): number;
/**
 * Calculate the distance as number of steps from one element to another, i.e.
 * going up to the common ancestor, then going down to the other element.
 * Sibling distance is always 1
 *
 * Can be used for hierarchical clustering
 */
declare function hierarchyDistance<E extends string | {
    id: Fqn;
}>(one: E, another: E): number;
declare function commonAncestor<E extends string>(first: E, second: E): E | null;
/**
 * Get all ancestor elements (i.e. parent, parentâ€™s parent, etc.)
 * going up from parent to the root
 */
declare function ancestorsFqn<Id extends string>(fqn: Id): Id[];
/**
 * Compares two fully qualified names (fqns) hierarchically based on their depth.
 * From parent nodes to leaves
 *
 * @param {string} a - The first fqn to compare.
 * @param {string} b - The second fqn to compare.
 * @returns {number} - 0 if the fqns have the same depth.
 *                    - Positive number if a is deeper than b.
 *                    - Negative number if b is deeper than a.
 */
declare function compareFqnHierarchically<T extends string = string>(a: T, b: T): -1 | 0 | 1;
declare function compareByFqnHierarchically<T extends {
    id: string;
}>(a: T, b: T): -1 | 0 | 1;
/**
 * Sorts an array of objects hierarchically based on their fully qualified names (FQN).
 * Objects are sorted by the number of segments in their FQN (defined by dot-separated ID).
 *
 * @typeParam T - Object type that contains an 'id' string property
 * @typeParam A - Type extending IterableContainer of T
 *
 * @param array - Array of objects to be sorted
 * @returns A new array with items sorted by their FQN hierarchy depth (number of segments)
 *
 * @example
 * ```ts
 * const items = [
 *   { id: "a.b.c" },
 *   { id: "a" },
 *   { id: "a.b" }
 * ];
 * sortByFqnHierarchically(items);
 * // Result: [
 * //   { id: "a" },
 * //   { id: "a.b" },
 * //   { id: "a.b.c" }
 * // ]
 * ```
 */
declare function sortByFqnHierarchically<T extends {
    id: string;
}, A extends IterableContainer<T>>(array: A): ReorderedArray<A>;
/**
 * Keeps initial order of the elements, but ensures that parents are before children
 */
declare function sortParentsFirst<T extends {
    id: string;
}, A extends IterableContainer<T>>(array: A): ReorderedArray<A>;
/**
 * Sorts an array of objects naturally by their fully qualified name (FQN) identifier.
 *
 * @template T - Type of objects containing an 'id' string property
 * @template A - Type extending IterableContainer of T
 *
 * @param first - Optional. Either the array to sort or the sort direction ('asc'|'desc')
 * @param sort - Optional. The sort direction ('asc'|'desc'). Defaults to 'asc' if not specified
 *
 * @example
 * // As a function that returns a sorting function
 * const sorted = sortNaturalByFqn('desc')(myArray);
 *
 * // Direct array sorting
 * const sorted = sortNaturalByFqn(myArray, 'desc');
 */
declare function sortNaturalByFqn(sort?: 'asc' | 'desc'): <I extends WithId<string>, A extends IterableContainer<I>>(array: A) => ReorderedArray<A>;
declare function sortNaturalByFqn<A extends IterableContainer<WithId>>(array: A, sort?: 'asc' | 'desc'): ReorderedArray<A>;

declare function isString(value: unknown): value is string;
declare function isNonEmptyArray<A>(arr: ArrayLike<A> | undefined): arr is NonEmptyArray<A>;
declare function hasProp<T extends object, P extends keyof T & string>(value: T, path: P): value is SetRequired<SetNonNullable<T, P>, P>;
type Guard<N = unknown> = (n: unknown) => n is N;
type Guarded<G> = G extends Guard<infer N> ? N : never;
/**
 * Creates a type guard that checks if a value matches any of the provided predicates.
 *
 * @template Predicates - A non-empty array of guard functions
 * @param predicates - The guard functions to test against
 * @returns A type guard function that returns true if the value matches any of the predicates
 *
 * @example
 * ```typescript
 * const isStringOrNumber = isAnyOf(isString, isNumber);
 *
 * if (isStringOrNumber(value)) {
 *   // value is now typed as string | number
 *   console.log(value);
 * }
 * ```
 */
declare function isAnyOf<const Predicates extends NonEmptyArray<Guard>>(...predicates: Predicates): (value: unknown) => value is Guarded<Predicates[number]>;

/**
 * Saves the value returned by fn() in a hidden property tag of obj object, so next time memoizeProp() is called,
 * that value will be returned, and fn won't be called.
 *
 * @example
 * ```ts
 * class Model {
 *   // using same Symbol
 *   get computed1() {
 *     return memoizeProp(this, Symbol.for('computed1'), () => doOnce())
 *   }
 *   // using string
 *   get computed2() {
 *     return memoizeProp(this, 'computed2', () => doOnce())
 *   }
 *
 * }
 * ```
 */
declare function memoizeProp<Tag extends symbol | string, Res>(obj: object, tag: Tag, fn: () => Res): Res;

export { BiMap as B, DefaultWeakMap as D, LinkedList as L, MultiMap as M, Queue as Q, ancestorsFqn as a, isAncestor as b, isDescendantOf as c, isNonEmptyArray as d, isSameHierarchy as e, isString as f, nonexhaustive as g, hasProp as h, invariant as i, nonNullable as j, sortParentsFirst as k, commonAncestor as l, memoizeProp as m, nameFromFqn as n, compareByFqnHierarchically as o, parentFqn as p, compareFqnHierarchically as q, hierarchyDistance as r, sortNaturalByFqn as s, hierarchyLevel as t, sortByFqnHierarchically as u, isAnyOf as v };
