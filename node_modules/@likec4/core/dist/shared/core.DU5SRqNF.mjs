import { t as t$3, e as e$3, a as DeploymentNodeModel, b as DeployedInstanceModel, c as DeploymentRelationModel, N as NestedElementOfDeployedInstanceModel } from './core.BP_QHEXs.mjs';
import { e as e$2 } from './core.BKlholso.mjs';
import { n as n$1 } from './core.BhNcrwzK.mjs';
import { c as splitGlobalFqn, h as extractStep, g as isStepEdgeId, i as isGroupElementKind, b as isGlobalFqn, a as GlobalFqn } from './core.D0WZutNd.mjs';
import { m as hierarchyLevel, n as nameFromFqn, i as isAncestor, g as commonAncestor, s as sortNaturalByFqn, f as sortParentsFirst, p as parentFqn, a as ancestorsFqn } from './core.CdNCAwq7.mjs';
import { m as memoizeProp } from './core.CLSZtnFh.mjs';
import { R as RichText, e as exact } from './core.CHf8VEa3.mjs';
import { preferSummary, preferDescription } from '../types/_aux.mjs';
import { i as ihead } from './core.uFk_o9X6.mjs';
import { t as t$6, b as compareNaturalHierarchically, c as compareNatural } from './core.3ZhnKAlZ.mjs';
import { t as t$2, a as t$4 } from './core.BsSXS-_R.mjs';
import { t as t$5, e as e$4 } from './core.Coi_LOUZ.mjs';
import { t as t$8 } from './core.CbT8JVYL.mjs';
import { t as t$7 } from './core.BkVA6gjl.mjs';
import { c as calcDriftsFromSnapshot, a as applyManualLayout, h as t$9 } from './core.DjcWextK.mjs';
import { L as LikeC4Styles } from './core.DGcIbsj4.mjs';
import { g as getOrCreate } from './core.DcS-0zys.mjs';
import { D as DefaultMap } from './core.BbE4y-yl.mjs';
import { i as invariant, a as nonNullable } from './core.D4npX2q8.mjs';
import { FqnRef } from '../types/fqnRef.mjs';
import { c as isDeploymentNode, a as _type, _ as _stage, i as isOnStage, w as whereOperatorAsPredicate } from './core.DH7TXqXf.mjs';
import { i as ifind } from './core.CmPXpJ8l.mjs';
import { i as ifilter } from './core.DRJma0Ol.mjs';
import './core.BFd1lU9R.mjs';
import './core.78IWAHAE.mjs';

function e$1(e){if(e==null||e===``)return  true;if(typeof e!=`object`)return  false;if(`length`in e&&typeof e.length==`number`)return e.length===0;if(`size`in e&&typeof e.size==`number`)return e.size===0;for(let t in e)return  false;return Object.getOwnPropertySymbols(e).length===0}

function t$1(...t){return t$2(n,t)}const n=e=>e.at(-1);

function e(e,t,n){return typeof t==`number`||t===void 0?n=>n.split(e,t):e.split(t,n)}

function t(...t){return t$2(Object.values,t)}

class ElementModel {
  constructor($model, $element) {
    this.$model = $model;
    this.$element = $element;
    this.id = this.$element.id;
    this._literalId = this.$element.id;
    const [projectId, fqn] = splitGlobalFqn(this.id);
    if (projectId) {
      this.imported = {
        from: projectId,
        fqn
      };
      this.hierarchyLevel = hierarchyLevel(fqn);
    } else {
      this.imported = null;
      this.hierarchyLevel = hierarchyLevel(this.id);
    }
  }
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  id;
  _literalId;
  hierarchyLevel;
  imported;
  get name() {
    return nameFromFqn(this.id);
  }
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$element.kind;
  }
  get shape() {
    return this.style.shape;
  }
  get color() {
    return this.style.color;
  }
  get icon() {
    return this.style.icon ?? null;
  }
  /**
   * Returns all tags of the element.
   * It includes tags from the element and its kind.
   */
  get tags() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("tags"), () => {
      return n$1([
        ...this.$element.tags ?? [],
        ...this.$model.specification.elements[this.$element.kind]?.tags ?? []
      ]);
    });
  }
  get title() {
    return this.$element.title;
  }
  /**
   * Returns true if the element has a summary and a description
   * (if one is missing - it falls back to another)
   */
  get hasSummary() {
    return !!this.$element.summary && !!this.$element.description && !t$3(this.$element.summary, this.$element.description);
  }
  /**
   * Short description of the element.
   * Falls back to description if summary is not provided.
   */
  get summary() {
    return RichText.memoize(this, "summary", preferSummary(this.$element));
  }
  /**
   * Long description of the element.
   * Falls back to summary if description is not provided.
   */
  get description() {
    return RichText.memoize(this, "description", preferDescription(this.$element));
  }
  get technology() {
    return this.$element.technology ?? null;
  }
  get links() {
    return this.$element.links ?? [];
  }
  get defaultView() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("defaultView"), () => ihead(this.scopedViews()) ?? null);
  }
  get isRoot() {
    return this.parent === null;
  }
  get style() {
    return memoizeProp(this, "style", () => exact({
      shape: this.$model.$styles.defaults.shape,
      color: this.$model.$styles.defaults.color,
      border: this.$model.$styles.defaults.border,
      opacity: this.$model.$styles.defaults.opacity,
      size: this.$model.$styles.defaults.size,
      padding: this.$model.$styles.defaults.padding,
      textSize: this.$model.$styles.defaults.text,
      ...this.$element.style
    }));
  }
  get projectId() {
    return this.imported?.from ?? this.$model.projectId;
  }
  isAncestorOf(another) {
    return isAncestor(this, another);
  }
  isDescendantOf(another) {
    return isAncestor(another, this);
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.element(common) : null;
  }
  children() {
    return this.$model.children(this);
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  descendants(sort) {
    if (sort) {
      const sorted = sortNaturalByFqn([...this.$model.descendants(this)], sort);
      return sorted[Symbol.iterator]();
    }
    return this.$model.descendants(this);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Resolve siblings of the element and its ancestors
   * (from closest parent to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  *incomers(filter = "all") {
    const unique2 = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique2.has(r.source.id)) {
        continue;
      }
      unique2.add(r.source.id);
      yield r.source;
    }
    return;
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *outgoers(filter = "all") {
    const unique2 = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique2.has(r.target.id)) {
        continue;
      }
      unique2.add(r.target.id);
      yield r.target;
    }
    return;
  }
  get allOutgoing() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("allOutgoing"), () => new Set(this.outgoing()));
  }
  get allIncoming() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("allIncoming"), () => new Set(this.incoming()));
  }
  /**
   * Iterate over all views that include this element.
   */
  views() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("views"), () => {
      const views = /* @__PURE__ */ new Set();
      for (const view of this.$model.views()) {
        if (view.includesElement(this.id)) {
          views.add(view);
        }
      }
      return views;
    });
  }
  /**
   * Iterate over all views that scope this element.
   * It is possible that element is not included in the view.
   */
  scopedViews() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("scopedViews"), () => {
      const views = /* @__PURE__ */ new Set();
      for (const vm of this.$model.views()) {
        if (vm.isScopedElementView() && vm.viewOf.id === this.id) {
          views.add(vm);
        }
      }
      return views;
    });
  }
  /**
   * @returns true if the element is deployed
   */
  isDeployed() {
    return e$2(ihead(this.deployments()));
  }
  deployments() {
    return this.$model.deployment.instancesOf(this);
  }
  hasMetadata() {
    return !!this.$element.metadata && !e$3(this.$element.metadata);
  }
  getMetadata(field) {
    if (field) {
      return this.$element.metadata?.[field];
    }
    return this.$element.metadata ?? {};
  }
  /**
   * Checks if the element has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

const getId = (element) => {
  return typeof element === "string" ? element : element.id;
};

const VIEW_FOLDERS_SEPARATOR = "/";
const splitViewTitle = (title) => {
  invariant(!title.includes("\n"), "View title cannot contain newlines");
  if (title.includes(VIEW_FOLDERS_SEPARATOR)) {
    const segments = title.split(VIEW_FOLDERS_SEPARATOR).map((s) => s.trim()).filter((s) => s.length > 0);
    if (t$4(segments, 1)) {
      return segments;
    }
    return [""];
  }
  return [title.trim()];
};
const normalizeViewPath = (title) => {
  return splitViewTitle(title).join(VIEW_FOLDERS_SEPARATOR);
};
const getViewFolderPath = (title) => {
  const segments = splitViewTitle(title);
  if (!t$4(segments, 2)) {
    return null;
  }
  return segments.slice(0, -1).join(VIEW_FOLDERS_SEPARATOR);
};
const extractViewTitleFromPath = (title) => {
  if (!title.includes(VIEW_FOLDERS_SEPARATOR)) {
    return title.trim();
  }
  return splitViewTitle(title).pop() ?? title;
};

class LikeC4DeploymentModel {
  constructor($model) {
    this.$model = $model;
    const $deployments = this.$deployments = $model.$data.deployments;
    const elements = t($deployments.elements);
    for (const element of sortParentsFirst(elements)) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
      if (el.isInstance()) {
        this.#instancesOf.get(el.element.id).add(el);
      }
    }
    for (const relation of t($deployments.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
  }
  #elements = /* @__PURE__ */ new Map();
  // Parent element for given FQN
  #parents = /* @__PURE__ */ new Map();
  // Children elements for given FQN
  #children = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Keep track of instances of the logical element
  #instancesOf = new DefaultMap(() => /* @__PURE__ */ new Set());
  #rootElements = /* @__PURE__ */ new Set();
  #relations = /* @__PURE__ */ new Map();
  // Incoming to an element or its descendants
  #incoming = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Outgoing from an element or its descendants
  #outgoing = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Relationships inside the element, among descendants
  #internal = new DefaultMap(() => /* @__PURE__ */ new Set());
  // readonly #views = new Map<ViewID, LikeC4ViewModel<A>>()
  #allTags = new DefaultMap(
    () => /* @__PURE__ */ new Set()
  );
  #nestedElementsOfDeployment = /* @__PURE__ */ new Map();
  $deployments;
  get $styles() {
    return this.$model.$styles;
  }
  get projectId() {
    return this.$model.projectId;
  }
  element(el) {
    if (el instanceof DeploymentNodeModel || el instanceof DeployedInstanceModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this.#elements.get(id), `Element ${id} not found`);
  }
  findElement(el) {
    return this.#elements.get(el) ?? null;
  }
  node(el) {
    const element = this.element(el);
    invariant(element.isDeploymentNode(), `Element ${element.id} is not a deployment node`);
    return element;
  }
  findNode(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isDeploymentNode(), `Element ${element?.id} is not a deployment node`);
    return element;
  }
  instance(el) {
    const element = this.element(el);
    invariant(element.isInstance(), `Element ${element.id} is not a deployed instance`);
    return element;
  }
  findInstance(el) {
    const element = this.findElement(el);
    if (!element) {
      return null;
    }
    invariant(element.isInstance(), `Element ${element?.id} is not a deployed instance`);
    return element;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return this.#rootElements.values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return this.#elements.values();
  }
  /**
   * Returns all elements in the model.
   */
  *nodes() {
    for (const element of this.#elements.values()) {
      if (element.isDeploymentNode()) {
        yield element;
      }
    }
    return;
  }
  *nodesOfKind(kind) {
    for (const node of this.#elements.values()) {
      if (node.isDeploymentNode() && node.kind === kind) {
        yield node;
      }
    }
    return;
  }
  *instances() {
    for (const element of this.#elements.values()) {
      if (element.isInstance()) {
        yield element;
      }
    }
    return;
  }
  /**
   * Iterate over all instances of the given logical element.
   */
  *instancesOf(element) {
    const id = getId(element);
    const instances = this.#instancesOf.get(id);
    if (instances) {
      yield* instances;
    }
    return;
  }
  deploymentRef(ref) {
    if (FqnRef.isInsideInstanceRef(ref)) {
      const { deployment, element } = ref;
      return getOrCreate(this.#nestedElementsOfDeployment, `${deployment}@${element}`, () => {
        return new NestedElementOfDeployedInstanceModel(this.instance(deployment), this.$model.element(element));
      });
    }
    return this.element(ref.deployment);
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return this.#relations.values();
  }
  /**
   * Returns a specific relationship by its ID.
   */
  relationship(id) {
    const relationId = getId(id);
    return nonNullable(this.#relations.get(relationId), `DeploymentRelationModel ${relationId} not found`);
  }
  findRelationship(id) {
    return this.#relations.get(id) ?? null;
  }
  /**
   * Returns all deployment views in the model.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view.isDeploymentView()) {
        yield view;
      }
    }
    return;
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return this.#parents.get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return this.#children.get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const siblings = this.parent(element)?.children() ?? this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = getId(element);
    let parent;
    while (parent = this.#parents.get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element, sort = "desc") {
    for (const child of this.children(element)) {
      if (sort === "asc") {
        yield child;
        yield* this.descendants(child.id);
      } else {
        yield* this.descendants(child.id);
        yield child;
      }
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#incoming.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of this.#outgoing.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  addElement(element) {
    if (this.#elements.has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = isDeploymentNode(element) ? new DeploymentNodeModel(this, Object.freeze(element)) : new DeployedInstanceModel(this, Object.freeze(element), this.$model.element(element.element));
    this.#elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(this.#elements.has(parentId), `Parent ${parentId} of ${el.id} not found`);
      this.#parents.set(el.id, this.node(parentId));
      this.#children.get(parentId).add(el);
    } else {
      invariant(el.isDeploymentNode(), `Root element ${el.id} is not a deployment node`);
      this.#rootElements.add(el);
    }
    return el;
  }
  addRelation(relation) {
    if (this.#relations.has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new DeploymentRelationModel(
      this,
      Object.freeze(relation)
    );
    this.#relations.set(rel.id, rel);
    this.#incoming.get(rel.target.id).add(rel);
    this.#outgoing.get(rel.source.id).add(rel);
    const relParent = rel.boundary?.id ?? null;
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        this.#internal.get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(rel.source.id)) {
      if (sourceAncestor === relParent) {
        break;
      }
      this.#outgoing.get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(rel.target.id)) {
      if (targetAncestor === relParent) {
        break;
      }
      this.#incoming.get(targetAncestor).add(rel);
    }
    return rel;
  }
}

class RelationshipModel {
  constructor(model, $relationship) {
    this.model = model;
    this.$relationship = $relationship;
    this.source = model.element(FqnRef.flatten($relationship.source));
    this.target = model.element(FqnRef.flatten($relationship.target));
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.model.element(parent) : null;
  }
  source;
  target;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the Relation.
   */
  boundary;
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (!e$2(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    if (!e$2(this.$relationship.technology)) {
      return null;
    }
    return this.$relationship.technology;
  }
  /**
   * Returns true if the relationship has a summary and a description
   * (if one is missing - it falls back to another)
   */
  get hasSummary() {
    return !!this.$relationship.summary && !!this.$relationship.description && !t$3(this.$relationship.summary, this.$relationship.description);
  }
  /**
   * Short description of the relationship.
   * Falls back to description if summary is not provided.
   */
  get summary() {
    return RichText.memoize(this, "summary", preferSummary(this.$relationship));
  }
  /**
   * Long description of the relationship.
   * Falls back to summary if description is not provided.
   */
  get description() {
    return RichText.memoize(this, "description", preferDescription(this.$relationship));
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.model.view(this.$relationship.navigateTo) : null;
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? this.model.$styles.defaults.relationship.color;
  }
  get line() {
    return this.$relationship.line ?? this.model.$styles.defaults.relationship.line;
  }
  get head() {
    return this.$relationship.head ?? this.model.$styles.defaults.relationship.arrow;
  }
  get tail() {
    return this.$relationship.tail;
  }
  /**
   * Iterate over all views that include this relationship.
   */
  *views() {
    for (const view of this.model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return false;
  }
  isModelRelation() {
    return true;
  }
  hasMetadata() {
    return !!this.$relationship.metadata && !e$3(this.$relationship.metadata);
  }
  getMetadata(field) {
    if (field) {
      return this.$relationship.metadata?.[field];
    }
    return this.$relationship.metadata ?? {};
  }
  /**
   * Checks if the relationship has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

class EdgeModel {
  constructor($viewModel, $edge, source, target) {
    this.source = source;
    this.target = target;
    this.$viewModel = $viewModel;
    this.$view = $viewModel.$view;
    this.$edge = $edge;
  }
  Aux;
  $viewModel;
  $view;
  $edge;
  get id() {
    return this.$edge.id;
  }
  get parent() {
    return this.$edge.parent ? this.$viewModel.node(this.$edge.parent) : null;
  }
  get label() {
    return this.$edge.label ?? null;
  }
  get description() {
    return RichText.memoize(this, "description", this.$edge.description);
  }
  get technology() {
    return this.$edge.technology ?? null;
  }
  hasParent() {
    return this.$edge.parent !== null;
  }
  get tags() {
    return this.$edge.tags ?? [];
  }
  get stepNumber() {
    return this.isStep() ? extractStep(this.id) : null;
  }
  get navigateTo() {
    return this.$edge.navigateTo ? this.$viewModel.$model.view(this.$edge.navigateTo) : null;
  }
  get color() {
    return this.$edge.color;
  }
  get line() {
    return this.$edge.line ?? this.$viewModel.$styles.defaults.relationship.line;
  }
  get head() {
    return this.$edge.head ?? this.$viewModel.$styles.defaults.relationship.arrow;
  }
  get tail() {
    return this.$edge.tail;
  }
  isStep() {
    return isStepEdgeId(this.id);
  }
  *relationships(type) {
    for (const id of this.$edge.relations) {
      if (type) {
        const rel = this.$viewModel.$model.findRelationship(id, type);
        if (rel) {
          yield rel;
        }
      } else {
        yield this.$viewModel.$model.relationship(id);
      }
    }
    return;
  }
  includesRelation(rel) {
    const id = typeof rel === "string" ? rel : rel.id;
    return this.$edge.relations.includes(id);
  }
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

class NodeModel {
  Aux;
  $viewModel;
  $view;
  $node;
  constructor($viewModel, $node) {
    this.$viewModel = $viewModel;
    this.$view = $viewModel.$view;
    this.$node = $node;
  }
  get id() {
    return this.$node.id;
  }
  get title() {
    return this.$node.title;
  }
  get kind() {
    return this.$node.kind;
  }
  get description() {
    return RichText.memoize(this, "description", this.$node.description);
  }
  get technology() {
    return this.$node.technology ?? null;
  }
  get parent() {
    return this.$node.parent ? this.$viewModel.node(this.$node.parent) : null;
  }
  get element() {
    const modelRef = this.$node.modelRef;
    return modelRef ? this.$viewModel.$model.element(modelRef) : null;
  }
  get deployment() {
    const modelRef = this.$node.deploymentRef;
    return modelRef ? this.$viewModel.$model.deployment.element(modelRef) : null;
  }
  get shape() {
    return this.$node.shape;
  }
  get color() {
    return this.$node.color;
  }
  get icon() {
    return this.$node.icon ?? null;
  }
  get tags() {
    return this.$node.tags;
  }
  get links() {
    return this.$node.links ?? [];
  }
  get navigateTo() {
    return this.$node.navigateTo ? this.$viewModel.$model.view(this.$node.navigateTo) : null;
  }
  get style() {
    return this.$node.style;
  }
  get x() {
    return "x" in this.$node ? this.$node.x : void 0;
  }
  get y() {
    return "y" in this.$node ? this.$node.y : void 0;
  }
  get width() {
    return "width" in this.$node ? this.$node.width : void 0;
  }
  get height() {
    return "height" in this.$node ? this.$node.height : void 0;
  }
  children() {
    return memoizeProp(this, "children", () => new Set(this.$node.children.map((child) => this.$viewModel.node(child))));
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors() {
    let parent = this.parent;
    while (parent) {
      yield parent;
      parent = parent.parent;
    }
    return;
  }
  *siblings() {
    const siblings = this.parent?.children() ?? this.$viewModel.roots();
    for (const sibling of siblings) {
      if (sibling.id !== this.id) {
        yield sibling;
      }
    }
    return;
  }
  *incoming(filter = "all") {
    for (const edgeId of this.$node.inEdges) {
      const edge = this.$viewModel.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.target.id === this.id):
        case (filter === "to-descendants" && edge.target.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *incomers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique.has(r.source.id)) {
        continue;
      }
      unique.add(r.source.id);
      yield r.source;
    }
    return;
  }
  *outgoing(filter = "all") {
    for (const edgeId of this.$node.outEdges) {
      const edge = this.$viewModel.edge(edgeId);
      switch (true) {
        case filter === "all":
        case (filter === "direct" && edge.source.id === this.id):
        case (filter === "from-descendants" && edge.source.id !== this.id):
          yield edge;
          break;
      }
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique.has(r.target.id)) {
        continue;
      }
      unique.add(r.target.id);
      yield r.target;
    }
    return;
  }
  isLayouted() {
    return "width" in this.$node && "height" in this.$node;
  }
  hasChildren() {
    return this.$node.children.length > 0;
  }
  hasParent() {
    return this.$node.parent !== null;
  }
  /**
   * Check if this node references to logical model element.
   */
  hasElement() {
    return e$2(this.$node.modelRef);
  }
  /**
   * Check if this node references to deployment element (Node or Instance).
   */
  hasDeployment() {
    return e$2(this.$node.deploymentRef);
  }
  /**
   * Check if this node references to deployed instance
   * Deployed instance always references to element and deployment element.
   */
  hasDeployedInstance() {
    return this.hasElement() && this.hasDeployment();
  }
  isGroup() {
    return isGroupElementKind(this.$node);
  }
  /**
   * Checks if the node has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}

class LikeC4ViewModel {
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  #view;
  #rootnodes = /* @__PURE__ */ new Set();
  #nodes = /* @__PURE__ */ new Map();
  #edges = /* @__PURE__ */ new Map();
  #includeElements = /* @__PURE__ */ new Set();
  #includeDeployments = /* @__PURE__ */ new Set();
  #includeRelations = /* @__PURE__ */ new Set();
  #allTags = new DefaultMap((_key) => /* @__PURE__ */ new Set());
  #manualLayoutSnapshot;
  id;
  /**
   * The model this view belongs to
   */
  $model;
  /**
   * The title of the view
   */
  title;
  /**
   * View folder this view belongs to.
   * If view is top-level, this is the root folder.
   */
  folder;
  /**
   * Path to this view, processed by {@link normalizeViewPath}
   *
   * @example
   * "Group 1/Group 2/View"
   */
  viewPath;
  constructor(model, folder, view, manualLayoutSnapshot) {
    this.$model = model;
    this.#view = view;
    this.id = view.id;
    this.folder = folder;
    this.#manualLayoutSnapshot = manualLayoutSnapshot;
    for (const node of this.#view.nodes) {
      const el = new NodeModel(this, Object.freeze(node));
      this.#nodes.set(node.id, el);
      if (!node.parent) {
        this.#rootnodes.add(el);
      }
      if (node.deploymentRef) {
        this.#includeDeployments.add(node.deploymentRef);
      }
      if (node.modelRef) {
        this.#includeElements.add(node.modelRef);
      }
      for (const tag of el.tags) {
        this.#allTags.get(tag).add(el);
      }
    }
    for (const edge of this.#view.edges) {
      const edgeModel = new EdgeModel(
        this,
        Object.freeze(edge),
        this.node(edge.source),
        this.node(edge.target)
      );
      for (const tag of edgeModel.tags) {
        this.#allTags.get(tag).add(edgeModel);
      }
      for (const rel of edge.relations) {
        this.#includeRelations.add(rel);
      }
      this.#edges.set(edge.id, edgeModel);
    }
    this.title = view.title ? extractViewTitleFromPath(view.title) : null;
    this.viewPath = view.title ? normalizeViewPath(view.title) : view.id;
  }
  /**
   * Returns the styles configuration for the project.
   */
  get $styles() {
    return this.$model.$styles;
  }
  get _type() {
    return this.#view[_type];
  }
  get stage() {
    return this.#view[_stage];
  }
  get bounds() {
    if ("bounds" in this.#view) {
      return this.#view.bounds;
    }
    if (this.#manualLayoutSnapshot) {
      return this.#manualLayoutSnapshot.bounds;
    }
    throw new Error("View is not layouted");
  }
  /**
   * Returns title if defined, otherwise returns title of the element it is based on, otherwise returns its {@link id}
   */
  get titleOrId() {
    return this.title ?? this.viewOf?.title ?? this.id;
  }
  /**
   * Returns title if defined, otherwise returns `Untitled`.
   */
  get titleOrUntitled() {
    return this.title ?? "Untitled";
  }
  /**
   * Returns path to this view as an array of groups and this view as the last element
   * If view is top-level, returns only this view.
   *
   * @example
   * viewPath = "Group 1/Group 2/View"
   *
   * breadcrumbs = [
   *   "Group 1",             // folder
   *   "Group 1/Group 2",     // folder
   *   "Group 1/Group 2/View" // view
   * ]
   */
  get breadcrumbs() {
    return memoizeProp(this, "breadcrumbs", () => {
      if (!this.folder.isRoot) {
        return [...this.folder.breadcrumbs, this];
      }
      return [this];
    });
  }
  get description() {
    return RichText.memoize(this, "description", this.#view.description);
  }
  get tags() {
    return this.#view.tags ?? [];
  }
  get links() {
    return this.#view.links ?? [];
  }
  get viewOf() {
    if (this.isElementView()) {
      const viewOf = this.#view.viewOf;
      return viewOf ? this.$model.element(viewOf) : null;
    }
    return null;
  }
  /**
   * Available for dynamic views only
   * throws error if view is not dynamic
   */
  get mode() {
    if (this.isDynamicView()) {
      return this.#view.variant ?? "diagram";
    }
    return null;
  }
  /**
   * All tags from nodes and edges.
   */
  get includedTags() {
    return [...this.#allTags.keys()];
  }
  /**
   * The original view from the model.
   * In case of layouted model, this is the latest auto-layouted view without manual changes applied
   * @see {@link $layouted} should be used for rendering in the UI
   */
  get $view() {
    if (!this.isLayouted() || "drifts" in this.#view) {
      return this.#view;
    }
    const snapshot = this.#manualLayoutSnapshot;
    if (snapshot) {
      return memoizeProp(this, "withDriftReasons", () => {
        return calcDriftsFromSnapshot(this.#view, snapshot);
      });
    }
    return this.#view;
  }
  /**
   * Returns the view with manual layout applied if it exists, otherwise returns the original view
   * This should be used for rendering in the UI
   */
  get $layouted() {
    if (!this.isLayouted()) {
      throw new Error("View is not layouted");
    }
    return this.$manual ?? this.#view;
  }
  get hasManualLayout() {
    return this.#manualLayoutSnapshot !== void 0;
  }
  get hasLayoutDrifts() {
    if (!this.isLayouted()) {
      return false;
    }
    const manualLayout = this.$manual;
    return !!manualLayout?.drifts && manualLayout.drifts.length > 0;
  }
  /**
   * If view has manual layout, returns it with manual layout applied
   */
  get $manual() {
    if (!this.isLayouted()) {
      return null;
    }
    const snapshot = this.#manualLayoutSnapshot;
    if (snapshot) {
      return memoizeProp(this, "snapshotWithManualLayout", () => {
        return applyManualLayout(this.#view, snapshot);
      });
    }
    return null;
  }
  get projectId() {
    return this.$model.projectId;
  }
  roots() {
    return this.#rootnodes.values();
  }
  /**
   * Iterate over all nodes that have children.
   */
  *compounds() {
    for (const node of this.#nodes.values()) {
      if (node.hasChildren()) {
        yield node;
      }
    }
    return;
  }
  /**
   * Get node by id.
   * @throws Error if node is not found.
   */
  node(node) {
    const nodeId = getId(node);
    return nonNullable(this.#nodes.get(nodeId), `Node ${nodeId} not found in view ${this.#view.id}`);
  }
  /**
   * Find node by id.
   */
  findNode(node) {
    return this.#nodes.get(getId(node)) ?? null;
  }
  findNodeWithElement(element) {
    const id = getId(element);
    if (!this.#includeElements.has(id)) {
      return null;
    }
    return ifind(
      this.#nodes.values(),
      (node) => node.hasElement() && node.element.id === id
    ) ?? null;
  }
  /**
   * Iterate over all nodes.
   */
  nodes() {
    return this.#nodes.values();
  }
  /**
   * Get edge by id, throws error if edge is not found.
   * Use {@link findEdge} if you are not sure if the edge exists.
   *
   * @param edge Edge or id
   * @returns {@link EdgeModel}
   */
  edge(edge) {
    const edgeId = getId(edge);
    return nonNullable(this.#edges.get(edgeId), `Edge ${edgeId} not found in view ${this.#view.id}`);
  }
  /**
   * Find edge by id.
   * @param edge Edge or id
   * @returns {@link EdgeModel} or null if edge is not found
   */
  findEdge(edge) {
    return this.#edges.get(getId(edge)) ?? null;
  }
  /**
   * Iterate over all edges.
   */
  edges() {
    return this.#edges.values();
  }
  /**
   * Iterate over all edges.
   */
  *edgesWithRelation(relation) {
    for (const edge of this.#edges.values()) {
      if (edge.includesRelation(relation)) {
        yield edge;
      }
    }
    return;
  }
  /**
   * Nodes that have references to elements from logical model.
   */
  *elements() {
    for (const node of this.#nodes.values()) {
      if (node.hasElement()) {
        yield node;
      }
    }
    return;
  }
  /**
   * Checks if the view has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
  includesElement(element) {
    return this.#includeElements.has(getId(element));
  }
  includesDeployment(deployment) {
    return this.#includeDeployments.has(getId(deployment));
  }
  includesRelation(relation) {
    return this.#includeRelations.has(getId(relation));
  }
  /**
   * Below are type guards.
   */
  isComputed() {
    return this.#view[_stage] === "computed";
  }
  isLayouted() {
    return this.#view[_stage] === "layouted";
  }
  /**
   * @deprecated Use {@link isLayouted} instead
   */
  isDiagram() {
    return this.#view[_stage] === "layouted";
  }
  isElementView() {
    return this.#view[_type] === "element";
  }
  isScopedElementView() {
    return this.#view[_type] === "element" && e$2(this.#view.viewOf);
  }
  isDeploymentView() {
    return this.#view[_type] === "deployment";
  }
  isDynamicView() {
    return this.#view[_type] === "dynamic";
  }
}

class LikeC4ViewsFolder {
  $model;
  /**
   * Path to this view folder, processed by {@link normalizeViewPath}
   *
   * @example
   * "Folder 1/Folder 2/Folder 3"
   */
  path;
  /**
   * Title of this view folder.
   *
   * @example
   * // title is the last segment of the path
   * path = "Folder 1/Folder 2/Folder 3"
   * title = "Folder 3"
   */
  title;
  /**
   * Whether this is the root view folder.
   *
   * !NOTE
   * Root folder is special folder with an empty path and used only for internal purposes. \
   * It is not visible to the user and should not be used in the code.
   */
  isRoot;
  parentPath;
  defaultViewId;
  constructor($model, path, defaultViewId) {
    this.$model = $model;
    this.path = path.join("/");
    this.isRoot = this.path === "";
    this.title = t$1(path);
    if (this.isRoot) {
      this.parentPath = void 0;
    } else {
      this.parentPath = path.slice(0, -1).join("/");
    }
    this.defaultViewId = defaultViewId;
  }
  /**
   * Default view of this view folder.\
   * It is for the case when there is a view at the same path as this folder.\
   * (if there are multiple views at the same path, the first one is chosen)
   *
   * @example
   * ```
   * // Assume the following views exist:
   * const views = [
   *   "Folder 1/ Folder 2 / View",
   *   "Folder 1/ Folder 2 / View / Subview",
   * ]
   * ```
   * Group with path `Folder 1/ Folder 2 / View`\
   * will have default view `Folder 1/ Folder 2 / View`
   */
  get defaultView() {
    if (!this.defaultViewId) {
      return null;
    }
    return this.$model.view(this.defaultViewId);
  }
  /**
   * Returns path to this view folder as an array of ancestors (excluding root) and this view folder as the last element
   *
   * @throws Error if this is the root folder.
   */
  get breadcrumbs() {
    invariant(!this.isRoot, "Root view folder has no breadcrumbs");
    return memoizeProp(this, "breadcrumbs", () => {
      const parent = this.parent;
      if (parent) {
        if (parent.isRoot) {
          return [parent, this];
        }
        return [...parent.breadcrumbs, this];
      }
      return [this];
    });
  }
  /**
   * Returns parent folder
   *
   * @throws Error if this is the root folder.
   */
  get parent() {
    invariant(!this.isRoot, "Root view folder has no parent");
    if (e$1(this.parentPath)) {
      return null;
    }
    return this.$model.viewFolder(this.parentPath);
  }
  /**
   * Returns sorted set of children
   * - First folders
   * - Then views
   */
  get children() {
    return this.$model.viewFolderItems(this.path);
  }
  /**
   * Returns sorted array of children folders
   */
  get folders() {
    return memoizeProp(this, "folders", () => {
      const folders = [];
      for (const child of this.children) {
        if (child instanceof LikeC4ViewsFolder) {
          folders.push(child);
        }
      }
      return folders;
    });
  }
  /**
   * Returns all views in this view folder.
   */
  get views() {
    return memoizeProp(this, "views", () => {
      const views = [];
      for (const child of this.children) {
        if (child instanceof LikeC4ViewModel) {
          views.push(child);
        }
      }
      return views;
    });
  }
}

class LikeC4Model {
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  _elements = /* @__PURE__ */ new Map();
  // Parent element for given FQN
  _parents = /* @__PURE__ */ new Map();
  // Children elements for given FQN
  _children = new DefaultMap(() => /* @__PURE__ */ new Set());
  _rootElements = /* @__PURE__ */ new Set();
  _relations = /* @__PURE__ */ new Map();
  // Incoming to an element or its descendants
  _incoming = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Outgoing from an element or its descendants
  _outgoing = new DefaultMap(() => /* @__PURE__ */ new Set());
  // Relationships inside the element, among descendants
  _internal = new DefaultMap(() => /* @__PURE__ */ new Set());
  _views = /* @__PURE__ */ new Map();
  _rootViewFolder;
  _viewFolders = /* @__PURE__ */ new Map();
  _viewFolderItems = new DefaultMap(() => /* @__PURE__ */ new Set());
  _allTags = new DefaultMap(() => /* @__PURE__ */ new Set());
  static fromParsed(model) {
    return new LikeC4Model(model);
  }
  static create(model) {
    return new LikeC4Model(model);
  }
  /**
   * Creates a new LikeC4Model instance and infers types from a model dump.\
   * Model dump expected to be computed or layouted.
   *
   * @typeParam D - A constant type parameter extending LikeC4ModelDump
   * @param dump - The model dump to create the instance from
   * @returns A  new LikeC4Model instance with types inferred from the dump
   */
  static fromDump(dump) {
    const {
      _stage: stage = "layouted",
      projectId = "unknown",
      project,
      globals,
      imports,
      deployments,
      views,
      relations,
      elements,
      specification
    } = dump;
    return new LikeC4Model({
      [_stage]: stage,
      projectId,
      project,
      globals: {
        predicates: globals?.predicates ?? {},
        dynamicPredicates: globals?.dynamicPredicates ?? {},
        styles: globals?.styles ?? {}
      },
      imports: imports ?? {},
      deployments: {
        elements: deployments?.elements ?? {},
        relations: deployments?.relations ?? {}
      },
      views: views ?? {},
      relations: relations ?? {},
      elements: elements ?? {},
      specification
    });
  }
  deployment;
  $data;
  constructor($data) {
    this.$data = $data;
    for (const [, element] of t$5($data.elements)) {
      const el = this.addElement(element);
      for (const tag of el.tags) {
        this._allTags.get(tag).add(el);
      }
    }
    for (const [projectId, elements] of t$5($data.imports ?? {})) {
      for (const element of sortParentsFirst(elements)) {
        const el = this.addImportedElement(projectId, element);
        for (const tag of el.tags) {
          this._allTags.get(tag).add(el);
        }
      }
    }
    for (const relation of t($data.relations)) {
      const el = this.addRelation(relation);
      for (const tag of el.tags) {
        this._allTags.get(tag).add(el);
      }
    }
    this.deployment = new LikeC4DeploymentModel(this);
    if (isOnStage($data, "computed") || isOnStage($data, "layouted")) {
      const compare = compareNaturalHierarchically(VIEW_FOLDERS_SEPARATOR);
      const views = t$6(
        t($data.views),
        t$8((view) => ({
          view,
          path: normalizeViewPath(view.title ?? view.id),
          folderPath: view.title && getViewFolderPath(view.title) || ""
        })),
        // Sort hierarchically by groups, but keep same order within groups
        t$7((a, b) => compare(a.folderPath, b.folderPath))
      );
      const getOrCreateFolder = (path) => {
        let folder = this._viewFolders.get(path);
        if (!folder) {
          const segments = e(path, VIEW_FOLDERS_SEPARATOR);
          invariant(t$4(segments, 1), `View group path "${path}" must have at least one element`);
          let defaultView;
          if (path === "") {
            defaultView = views.find((view) => view.view.id === "index");
          } else {
            defaultView = views.find((view) => view.path === path);
          }
          folder = new LikeC4ViewsFolder(this, segments, defaultView?.view.id);
          this._viewFolders.set(path, folder);
        }
        return folder;
      };
      this._rootViewFolder = getOrCreateFolder("");
      for (const { folderPath } of views) {
        if (this._viewFolders.has(folderPath)) {
          continue;
        }
        e(folderPath, VIEW_FOLDERS_SEPARATOR).reduce((segments, segment) => {
          const parent = segments.join(VIEW_FOLDERS_SEPARATOR);
          const path = e$3(parent) ? segment : parent + VIEW_FOLDERS_SEPARATOR + segment;
          const folder = getOrCreateFolder(path);
          this._viewFolderItems.get(parent).add(folder);
          segments.push(segment);
          return segments;
        }, []);
      }
      for (const { view, folderPath } of views) {
        const vm = new LikeC4ViewModel(
          this,
          getOrCreateFolder(folderPath),
          view,
          $data.manualLayouts?.[view.id]
        );
        this._viewFolderItems.get(folderPath).add(vm);
        this._views.set(view.id, vm);
        for (const tag of vm.tags) {
          this._allTags.get(tag).add(vm);
        }
      }
    } else {
      this._rootViewFolder = new LikeC4ViewsFolder(this, [""], void 0);
      this._viewFolders.set(this._rootViewFolder.path, this._rootViewFolder);
    }
  }
  /**
   * Type narrows the model to the parsed stage.
   * This is useful for tests
   */
  get asParsed() {
    return this;
  }
  /**
   * Type narrows the model to the layouted stage.
   * This is useful for tests
   */
  get asComputed() {
    return this;
  }
  /**
   * Type narrows the model to the layouted stage.
   * This is useful for tests
   */
  get asLayouted() {
    return this;
  }
  /**
   * Returns the styles configuration for the project.
   */
  get $styles() {
    return memoizeProp(
      this,
      "styles",
      () => LikeC4Styles.from(
        this.$data.project.styles,
        this.$data.specification.customColors ? {
          theme: {
            colors: this.$data.specification.customColors
          }
        } : void 0
      )
    );
  }
  /**
   * Type guard the model to the parsed stage.
   */
  isParsed() {
    return this.stage === "parsed";
  }
  /**
   * Type guard the model to the layouted stage.
   */
  isLayouted() {
    return this.stage === "layouted";
  }
  /**
   * Type guard the model to the computed stage.
   */
  isComputed() {
    return this.stage === "computed";
  }
  /**
   * Keeping here for backward compatibility
   * @deprecated use {@link $data}
   */
  get $model() {
    return this.$data;
  }
  get stage() {
    return this.$data[_stage];
  }
  /**
   * Returns the Project ID associated with the model.
   * If the project ID is not defined in the model, it returns "default".
   */
  get projectId() {
    return this.$data.projectId ?? "default";
  }
  /**
   * Returns the project associated with the model.
   * If the project is not defined in the model, it returns a default project with the ID "default".
   */
  get project() {
    return this.$data.project ?? memoizeProp(this, /* @__PURE__ */ Symbol.for("project"), () => ({
      id: this.projectId
    }));
  }
  get specification() {
    return this.$data.specification;
  }
  get globals() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("globals"), () => ({
      predicates: {
        ...this.$data.globals?.predicates
      },
      dynamicPredicates: {
        ...this.$data.globals?.dynamicPredicates
      },
      styles: {
        ...this.$data.globals?.styles
      }
    }));
  }
  /**
     * Returns the element with the given FQN.
     *
     * @throws Error if element is not found\
     * Use {@link findElement} if you don't want to throw an error
     *
     * @note Method is type-safe for typed model
  
     * @example
     * model.element('cloud.frontend')
     * // or object with id property of scalar.Fqn
     * model.element({
     *   id: 'dashboard',
     * })
     */
  element(el) {
    if (el instanceof ElementModel) {
      return el;
    }
    const id = getId(el);
    return nonNullable(this._elements.get(id), `Element ${id} not found`);
  }
  /**
   * Returns the element with the given FQN.
   *
   * @returns Element if found, null otherwise
   * @note Method is not type-safe as {@link element}
   *
   * @example
   * model.findElement('cloud.frontend')
   */
  findElement(el) {
    return this._elements.get(getId(el)) ?? null;
  }
  /**
   * Returns the root elements of the model.
   */
  roots() {
    return this._rootElements.values();
  }
  /**
   * Returns all elements in the model.
   */
  elements() {
    return this._elements.values();
  }
  /**
   * Returns all relationships in the model.
   */
  relationships() {
    return this._relations.values();
  }
  relationship(rel, type) {
    if (type === "deployment") {
      return this.deployment.relationship(rel);
    }
    const id = getId(rel);
    let model = this._relations.get(id) ?? null;
    if (model || type === "model") {
      return nonNullable(model, `Model relation ${id} not found`);
    }
    return nonNullable(this.deployment.findRelationship(id), `No model/deployment relation ${id} not found`);
  }
  findRelationship(id, type) {
    if (type === "deployment") {
      return this.deployment.findRelationship(id);
    }
    let model = this._relations.get(getId(id)) ?? null;
    if (model || type === "model") {
      return model;
    }
    return this.deployment.findRelationship(id);
  }
  /**
   * Returns all views in the model.
   */
  views() {
    return this._views.values();
  }
  /**
   * Returns a specific view by its ID.
   * @note Method is type-safe for typed model
   * @throws Error if view is not found\
   * Use {@link findView} if you don't want to throw an error
   *
   * @example
   * model.view('index')
   * // or object with id property of scalar.ViewId
   * model.view({
   *   id: 'index',
   * })
   */
  view(viewId) {
    const id = getId(viewId);
    return nonNullable(this._views.get(id), `View ${id} not found`);
  }
  /**
   * Returns a specific view by its ID.
   * @note Method is not type-safe as {@link view}
   *
   * @example
   * model.findView('index')
   */
  findView(viewId) {
    return this._views.get(viewId) ?? null;
  }
  /**
   * Returns manual layout snapshot for given view ID, if any.
   */
  findManualLayout(viewId) {
    if ("manualLayouts" in this.$data) {
      const view = this.$data.manualLayouts?.[viewId];
      return view ?? null;
    }
    return null;
  }
  /**
   * Returns a view folder by its path.
   * Path is extracted from the view title, e.g. "Group 1/Group 2/View" -> "Group 1/Group 2"
   * @throws Error if view folder is not found.
   */
  viewFolder(path) {
    return nonNullable(this._viewFolders.get(path), `View folder ${path} not found`);
  }
  /**
   * Root folder is a special one with an empty path and used only for internal purposes.
   * It is not visible to the user and should be used only to get top-level folders and views.
   */
  get rootViewFolder() {
    return this._rootViewFolder;
  }
  /**
   * Whether the model has any view folders.
   */
  get hasViewFolders() {
    return this._viewFolders.size > 1;
  }
  /**
   * Returns all children of a view folder.
   * Path is extracted from the view title, e.g. "Group 1/Group 2/View" -> "Group 1/Group 2"
   *
   * @throws Error if view folder is not found.
   */
  viewFolderItems(path) {
    invariant(this._viewFolders.has(path), `View folder ${path} not found`);
    return this._viewFolderItems.get(path);
  }
  /**
   * Returns the parent element of given element.
   * @see ancestors
   */
  parent(element) {
    const id = getId(element);
    return this._parents.get(id) || null;
  }
  /**
   * Get all children of the element (only direct children),
   * @see descendants
   */
  children(element) {
    const id = getId(element);
    return this._children.get(id);
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  *siblings(element) {
    const id = getId(element);
    const parent = this._parents.get(id);
    const siblings = parent ? this._children.get(parent.id).values() : this.roots();
    for (const sibling of siblings) {
      if (sibling.id !== id) {
        yield sibling;
      }
    }
    return;
  }
  /**
   * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
   * (from closest to root)
   */
  *ancestors(element) {
    let id = getId(element);
    let parent;
    while (parent = this._parents.get(id)) {
      yield parent;
      id = parent.id;
    }
    return;
  }
  /**
   * Get all descendant elements (i.e. children, children’s children, etc.)
   */
  *descendants(element) {
    for (const child of this.children(element)) {
      yield child;
      yield* this.descendants(child.id);
    }
    return;
  }
  /**
   * Incoming relationships to the element and its descendants
   * @see incomers
   */
  *incoming(element, filter = "all") {
    const id = getId(element);
    for (const rel of this._incoming.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.target.id === id):
        case (filter === "to-descendants" && rel.target.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Outgoing relationships from the element and its descendants
   * @see outgoers
   */
  *outgoing(element, filter = "all") {
    const id = getId(element);
    for (const rel of this._outgoing.get(id)) {
      switch (true) {
        case filter === "all":
        case (filter === "direct" && rel.source.id === id):
        case (filter === "from-descendants" && rel.source.id !== id):
          yield rel;
          break;
      }
    }
    return;
  }
  /**
   * Returns array of all tags used in the model, sorted naturally.\
   * Use {@link specification.tags} to get all defined tags
   */
  get tags() {
    return memoizeProp(this, "tags", () => t$7([...this._allTags.keys()], compareNatural));
  }
  /**
   * Returns all tags used in the model, sorted by usage count (descending).
   */
  get tagsSortedByUsage() {
    return memoizeProp(this, "tagsSortedByUsage", () => t$6(
      [...this._allTags.entries()],
      t$8(([tag, tagged]) => ({
        tag,
        count: tagged.size,
        tagged
      })),
      t$7((a, b) => compareNatural(a.tag, b.tag)),
      t$9(
        [e$4("count"), "desc"]
      )
    ));
  }
  findByTag(tag, type) {
    return ifilter(this._allTags.get(tag), (el) => {
      if (type === "elements") {
        return el instanceof ElementModel;
      }
      if (type === "views") {
        return el instanceof LikeC4ViewModel;
      }
      if (type === "relationships") {
        return el instanceof RelationshipModel;
      }
      return true;
    });
  }
  /**
   * Returns all elements of the given kind.
   */
  *elementsOfKind(kind) {
    for (const el of this._elements.values()) {
      if (el.kind === kind) {
        yield el;
      }
    }
    return;
  }
  /**
   * Returns all elements that match the given where operator.
   *
   * @example
   * ```ts
   * model.where({
   *   and: [
   *     { kind: 'component' },
   *     {
   *       or: [
   *         { tag: 'old' },
   *         { tag: { neq: 'new' } },
   *       ],
   *     },
   *   ],
   * })
   * ```
   */
  *elementsWhere(where) {
    const predicate = whereOperatorAsPredicate(where);
    for (const el of this._elements.values()) {
      if (predicate(el)) {
        yield el;
      }
    }
    return;
  }
  /**
   * Returns all **model** relationships that match the given where operator.
   *
   * @example
   * ```ts
   * model.relationshipsWhere({
   *   and: [
   *     { kind: 'uses' },
   *     {
   *       or: [
   *         { tag: 'old' },
   *         { tag: { neq: 'new' } },
   *       ],
   *     },
   *   ],
   * })
   * ```
   */
  *relationshipsWhere(where) {
    const predicate = whereOperatorAsPredicate(where);
    for (const rel of this._relations.values()) {
      if (predicate(rel)) {
        yield rel;
      }
    }
    return;
  }
  addElement(element) {
    if (this._elements.has(element.id)) {
      throw new Error(`Element ${element.id} already exists`);
    }
    const el = new ElementModel(this, Object.freeze(element));
    this._elements.set(el.id, el);
    const parentId = parentFqn(el.id);
    if (parentId) {
      invariant(this._elements.has(parentId), `Parent ${parentId} of ${el.id} not found`);
      this._parents.set(el.id, this.element(parentId));
      this._children.get(parentId).add(el);
    } else {
      this._rootElements.add(el);
    }
    return el;
  }
  addImportedElement(projectId, element) {
    invariant(!isGlobalFqn(element.id), `Imported element already has global FQN`);
    const id = GlobalFqn(projectId, element.id);
    if (this._elements.has(id)) {
      throw new Error(`Element ${id} already exists`);
    }
    const el = new ElementModel(
      this,
      Object.freeze({
        ...element,
        id
      })
    );
    this._elements.set(el.id, el);
    let parentId = parentFqn(el.id);
    while (parentId) {
      if (parentId.includes(".") && this._elements.has(parentId)) {
        this._parents.set(el.id, this.element(parentId));
        this._children.get(parentId).add(el);
        return el;
      }
      parentId = parentFqn(parentId);
    }
    this._rootElements.add(el);
    return el;
  }
  addRelation(relation) {
    if (this._relations.has(relation.id)) {
      throw new Error(`Relation ${relation.id} already exists`);
    }
    const rel = new RelationshipModel(
      this,
      Object.freeze(relation)
    );
    const { source, target } = rel;
    this._relations.set(rel.id, rel);
    this._incoming.get(target.id).add(rel);
    this._outgoing.get(source.id).add(rel);
    const relParent = commonAncestor(source.id, target.id);
    if (relParent) {
      for (const ancestor of [relParent, ...ancestorsFqn(relParent)]) {
        this._internal.get(ancestor).add(rel);
      }
    }
    for (const sourceAncestor of ancestorsFqn(source.id)) {
      if (sourceAncestor === relParent) {
        break;
      }
      this._outgoing.get(sourceAncestor).add(rel);
    }
    for (const targetAncestor of ancestorsFqn(target.id)) {
      if (targetAncestor === relParent) {
        break;
      }
      this._incoming.get(targetAncestor).add(rel);
    }
    return rel;
  }
}
((LikeC4Model2) => {
  LikeC4Model2.EMPTY = LikeC4Model2.create({
    _stage: "computed",
    projectId: "default",
    project: { id: "default" },
    specification: {
      elements: {},
      relationships: {},
      deployments: {},
      tags: {}
    },
    globals: {
      predicates: {},
      dynamicPredicates: {},
      styles: {}
    },
    deployments: {
      elements: {},
      relations: {}
    },
    elements: {},
    relations: {},
    views: {},
    imports: {}
  });
})(LikeC4Model || (LikeC4Model = {}));

function isDeploymentNodeModel(model) {
  return model instanceof DeploymentNodeModel;
}
function isDeployedInstanceModel(model) {
  return model instanceof DeployedInstanceModel;
}
function isDeploymentElementModel(model) {
  return isDeploymentNodeModel(model) || isDeployedInstanceModel(model);
}
function isNestedElementOfDeployedInstanceModel(model) {
  return model instanceof NestedElementOfDeployedInstanceModel;
}
function isDeploymentRelationModel(x) {
  return x instanceof DeploymentRelationModel;
}
function isRelationModel(x) {
  return x instanceof RelationshipModel;
}
function isElementModel(element) {
  return element instanceof ElementModel;
}
function isLikeC4ViewModel(view) {
  return view instanceof LikeC4ViewModel;
}
function isNodeModel(node) {
  return node instanceof NodeModel;
}
function isEdgeModel(edge) {
  return edge instanceof EdgeModel;
}

export { ElementModel as E, LikeC4Model as L, NodeModel as N, RelationshipModel as R, VIEW_FOLDERS_SEPARATOR as V, t$1 as a, isNestedElementOfDeployedInstanceModel as b, isDeployedInstanceModel as c, isDeploymentNodeModel as d, isDeploymentElementModel as e, LikeC4DeploymentModel as f, EdgeModel as g, LikeC4ViewModel as h, isElementModel as i, LikeC4ViewsFolder as j, extractViewTitleFromPath as k, getViewFolderPath as l, isDeploymentRelationModel as m, normalizeViewPath as n, isRelationModel as o, isLikeC4ViewModel as p, isNodeModel as q, isEdgeModel as r, t };
