import { c as customInspectSymbol } from './core.BFd1lU9R.mjs';
import { i as intersection, d as difference, u as union, e as equals } from './core.DbfO90vF.mjs';
import { t as t$1 } from './core.BsSXS-_R.mjs';
import { e as e$1 } from './core.BKlholso.mjs';
import { n as n$1 } from './core.BhNcrwzK.mjs';
import { m as hierarchyLevel, g as commonAncestor, n as nameFromFqn, d as isSameHierarchy } from './core.CdNCAwq7.mjs';
import { a as nonNullable, i as invariant } from './core.D4npX2q8.mjs';
import { m as memoizeProp } from './core.CLSZtnFh.mjs';
import { e as exact, R as RichText } from './core.CHf8VEa3.mjs';
import { preferSummary, preferDescription } from '../types/_aux.mjs';
import { i as ihead } from './core.uFk_o9X6.mjs';
import { s as stringHash } from './core.oSV6SRfk.mjs';

function e(e){return e===``||e===void 0?true:Array.isArray(e)?e.length===0:Object.keys(e).length===0}

function t(...t){return t$1(n,t)}function n(e,t){if(e===t||Object.is(e,t))return  true;if(typeof e!=`object`||!e||typeof t!=`object`||!t)return  false;if(e instanceof Map&&t instanceof Map)return r(e,t);if(e instanceof Set&&t instanceof Set)return i(e,t);let n=Object.keys(e);if(n.length!==Object.keys(t).length)return  false;for(let r of n){if(!Object.hasOwn(t,r))return  false;let{[r]:n}=e,{[r]:i}=t;if(n!==i||!Object.is(n,i))return  false}return  true}function r(e,t){if(e.size!==t.size)return  false;for(let[n,r]of e){let e=t.get(n);if(r!==e||!Object.is(r,e))return  false}return  true}function i(e,t){if(e.size!==t.size)return  false;for(let n of e)if(!t.has(n))return  false;return  true}

class AbstractDeploymentElementModel {
  /**
   * Don't use in runtime, only for type inference
   */
  Aux;
  get style() {
    return memoizeProp(this, "style", () => exact({
      shape: this.$model.$styles.defaults.shape,
      color: this.$model.$styles.defaults.color,
      border: this.$model.$styles.defaults.border,
      opacity: this.$model.$styles.defaults.opacity,
      size: this.$model.$styles.defaults.size,
      padding: this.$model.$styles.defaults.padding,
      textSize: this.$model.$styles.defaults.text,
      ...this.$node.style
    }));
  }
  get name() {
    return nameFromFqn(this.id);
  }
  get shape() {
    return this.style.shape;
  }
  get color() {
    return this.style.color;
  }
  get icon() {
    return this.style.icon ?? null;
  }
  /**
   * Short description of the element.
   * Falls back to description if summary is not provided.
   */
  get summary() {
    return RichText.memoize(this, "summary", preferSummary(this.$node));
  }
  /**
   * Long description of the element.
   * Falls back to summary if description is not provided.
   */
  get description() {
    return RichText.memoize(this, "description", preferDescription(this.$node));
  }
  get technology() {
    return this.$node.technology ?? null;
  }
  get links() {
    return this.$node.links ?? [];
  }
  /**
   * Get all ancestor elements (i.e. parent, parentâ€™s parent, etc.)
   * (from closest to root)
   */
  ancestors() {
    return this.$model.ancestors(this);
  }
  /**
   * Returns the common ancestor of this element and another element.
   */
  commonAncestor(another) {
    const common = commonAncestor(this.id, another.id);
    return common ? this.$model.node(common) : null;
  }
  /**
   * Get all sibling (i.e. same parent)
   */
  siblings() {
    return this.$model.siblings(this);
  }
  /**
   * Check if the element is a sibling of another element
   */
  isSibling(other) {
    return this.parent === other.parent;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from closest to root)
   */
  *ascendingSiblings() {
    yield* this.siblings();
    for (const ancestor of this.ancestors()) {
      yield* ancestor.siblings();
    }
    return;
  }
  /**
   * Resolve siblings of the element and its ancestors
   *  (from root to closest)
   */
  *descendingSiblings() {
    for (const ancestor of [...this.ancestors()].reverse()) {
      yield* ancestor.siblings();
    }
    yield* this.siblings();
    return;
  }
  incoming(filter = "all") {
    return this.$model.incoming(this, filter);
  }
  outgoing(filter = "all") {
    return this.$model.outgoing(this, filter);
  }
  *incomers(filter = "all") {
    const unique2 = /* @__PURE__ */ new Set();
    for (const r of this.incoming(filter)) {
      if (unique2.has(r.source.id)) {
        continue;
      }
      unique2.add(r.source.id);
      yield r.source;
    }
    return;
  }
  *outgoers(filter = "all") {
    const unique2 = /* @__PURE__ */ new Set();
    for (const r of this.outgoing(filter)) {
      if (unique2.has(r.target.id)) {
        continue;
      }
      unique2.add(r.target.id);
      yield r.target;
    }
    return;
  }
  /**
   * Iterate over all views that include this deployment element.
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view._type !== "deployment") {
        continue;
      }
      if (view.includesDeployment(this.id)) {
        yield view;
      }
    }
  }
  // type guard
  isDeploymentNode() {
    return false;
  }
  // type guard
  isInstance() {
    return false;
  }
  get allOutgoing() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("allOutgoing"), () => RelationshipsAccum.from(
      new Set(this.outgoingModelRelationships()),
      new Set(this.outgoing())
    ));
  }
  get allIncoming() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("allIncoming"), () => RelationshipsAccum.from(
      new Set(this.incomingModelRelationships()),
      new Set(this.incoming())
    ));
  }
  hasMetadata() {
    return !!this.$node.metadata && !e(this.$node.metadata);
  }
  getMetadata(field) {
    if (field) {
      return this.$node.metadata?.[field];
    }
    return this.$node.metadata ?? {};
  }
  /**
   * Checks if the deployment element has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}
class DeploymentNodeModel extends AbstractDeploymentElementModel {
  constructor($model, $node) {
    super();
    this.$model = $model;
    this.$node = $node;
    this.id = $node.id;
    this._literalId = $node.id;
    this.title = $node.title;
    this.hierarchyLevel = hierarchyLevel($node.id);
  }
  id;
  _literalId;
  title;
  hierarchyLevel;
  get parent() {
    return this.$model.parent(this);
  }
  get kind() {
    return this.$node.kind;
  }
  get tags() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("tags"), () => {
      return n$1([
        ...this.$node.tags ?? [],
        ...this.$model.$model.specification.deployments[this.kind]?.tags ?? []
      ]);
    });
  }
  children() {
    return this.$model.children(this);
  }
  descendants(sort = "desc") {
    return this.$model.descendants(this, sort);
  }
  isDeploymentNode() {
    return true;
  }
  /**
   * Iterate over all instances nested in this deployment node.
   */
  *instances() {
    for (const nested of this.descendants("desc")) {
      if (nested.isInstance()) {
        yield nested;
      }
    }
    return;
  }
  /**
   * Returns deployed instance inside this deployment node
   * if only there are no more instances
   */
  onlyOneInstance() {
    const children = this.children();
    if (children.size !== 1) {
      return null;
    }
    const child = ihead(children);
    if (!child) {
      return null;
    }
    return child.isInstance() ? child : child.onlyOneInstance();
  }
  /**
   * Cached result of relationships from instances
   */
  _relationshipsFromInstances = null;
  relationshipsFromInstances() {
    if (this._relationshipsFromInstances) {
      return this._relationshipsFromInstances;
    }
    const {
      outgoing,
      incoming
    } = this._relationshipsFromInstances = {
      outgoing: /* @__PURE__ */ new Set(),
      incoming: /* @__PURE__ */ new Set()
    };
    for (const instance of this.instances()) {
      for (const r of instance.element.outgoing()) {
        outgoing.add(r);
      }
      for (const r of instance.element.incoming()) {
        incoming.add(r);
      }
    }
    return this._relationshipsFromInstances;
  }
  /**
   * We return only relationships that are not already present in nested instances
   */
  outgoingModelRelationships() {
    return this.relationshipsFromInstances().outgoing.values();
  }
  /**
   * We return only relationships that are not already present in nested instances
   */
  incomingModelRelationships() {
    return this.relationshipsFromInstances().incoming.values();
  }
  /**
   * Returns an iterator of relationships between nested instances
   */
  internalModelRelationships() {
    const {
      outgoing,
      incoming
    } = this.relationshipsFromInstances();
    return intersection(incoming, outgoing);
  }
}
class DeployedInstanceModel extends AbstractDeploymentElementModel {
  constructor($model, $instance, element) {
    super();
    this.$model = $model;
    this.$instance = $instance;
    this.element = element;
    this.id = $instance.id;
    this._literalId = $instance.id;
    this.title = $instance.title ?? element.title;
    this.hierarchyLevel = hierarchyLevel($instance.id);
  }
  id;
  _literalId;
  title;
  hierarchyLevel;
  get $node() {
    return this.$instance;
  }
  get parent() {
    return nonNullable(this.$model.parent(this), `Parent of ${this.id} not found`);
  }
  get style() {
    return memoizeProp(this, "style", () => exact({
      shape: this.$model.$styles.defaults.shape,
      color: this.$model.$styles.defaults.color,
      border: this.$model.$styles.defaults.border,
      opacity: this.$model.$styles.defaults.opacity,
      size: this.$model.$styles.defaults.size,
      padding: this.$model.$styles.defaults.padding,
      textSize: this.$model.$styles.defaults.text,
      ...this.element.$element.style,
      ...this.$instance.style
    }));
  }
  get tags() {
    return memoizeProp(this, /* @__PURE__ */ Symbol.for("tags"), () => {
      return n$1([
        ...this.$instance.tags ?? [],
        ...this.element.tags
      ]);
    });
  }
  get kind() {
    return this.element.kind;
  }
  get summary() {
    return RichText.memoize(
      this,
      "summary",
      preferSummary(this.$instance) ?? preferSummary(this.element.$element)
    );
  }
  get description() {
    return RichText.memoize(
      this,
      "description",
      preferDescription(this.$instance) ?? preferDescription(this.element.$element)
    );
  }
  get technology() {
    return this.$instance.technology ?? this.element.technology ?? null;
  }
  get links() {
    return this.$instance.links ?? this.element.links;
  }
  isInstance() {
    return true;
  }
  outgoingModelRelationships() {
    return this.element.outgoing();
  }
  incomingModelRelationships() {
    return this.element.incoming();
  }
  /**
   * Iterate over all views that include this instance.
   * (Some views may include the parent deployment node instead of the instance.)
   */
  *views() {
    for (const view of this.$model.views()) {
      if (view._type !== "deployment") {
        continue;
      }
      if (view.includesDeployment(this.id)) {
        yield view;
        continue;
      }
      if (view.includesDeployment(this.parent.id) && this.parent.onlyOneInstance()) {
        yield view;
      }
    }
  }
}
class NestedElementOfDeployedInstanceModel {
  constructor(instance, element) {
    this.instance = instance;
    this.element = element;
  }
  get id() {
    return this.instance.id;
  }
  get _literalId() {
    return this.instance.id;
  }
  get style() {
    return memoizeProp(this, "style ", () => ({
      shape: this.element.shape,
      color: this.element.color,
      ...this.element.$element.style
    }));
  }
  get shape() {
    return this.element.shape;
  }
  get color() {
    return this.element.color;
  }
  get title() {
    return this.element.title;
  }
  get summary() {
    return this.element.summary;
  }
  get description() {
    return this.element.description;
  }
  get technology() {
    return this.element.technology;
  }
  isDeploymentNode() {
    return false;
  }
  isInstance() {
    return false;
  }
}
class DeploymentRelationModel {
  constructor($model, $relationship) {
    this.$model = $model;
    this.$relationship = $relationship;
    this.source = $model.deploymentRef($relationship.source);
    this.target = $model.deploymentRef($relationship.target);
    const parent = commonAncestor(this.source.id, this.target.id);
    this.boundary = parent ? this.$model.node(parent) : null;
  }
  boundary;
  source;
  target;
  get id() {
    return this.$relationship.id;
  }
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  get title() {
    if (!e$1(this.$relationship.title)) {
      return null;
    }
    return this.$relationship.title;
  }
  get technology() {
    return this.$relationship.technology ?? null;
  }
  /**
   * Returns true if the relationship has a summary and a description
   * (if one is missing - it falls back to another)
   */
  get hasSummary() {
    return !!this.$relationship.summary && !!this.$relationship.description && !t(this.$relationship.summary, this.$relationship.description);
  }
  /**
   * Short description of the relationship.
   * Falls back to description if summary is not provided.
   */
  get summary() {
    return RichText.memoize(this, "summary", preferSummary(this.$relationship));
  }
  /**
   * Long description of the relationship.
   * Falls back to summary if description is not provided.
   */
  get description() {
    return RichText.memoize(this, "description", preferDescription(this.$relationship));
  }
  get tags() {
    return this.$relationship.tags ?? [];
  }
  get kind() {
    return this.$relationship.kind ?? null;
  }
  get navigateTo() {
    return this.$relationship.navigateTo ? this.$model.$model.view(this.$relationship.navigateTo) : null;
  }
  get links() {
    return this.$relationship.links ?? [];
  }
  get color() {
    return this.$relationship.color ?? this.$model.$styles.defaults.relationship.color;
  }
  get line() {
    return this.$relationship.line ?? this.$model.$styles.defaults.relationship.line;
  }
  get head() {
    return this.$relationship.head ?? this.$model.$styles.defaults.relationship.arrow;
  }
  get tail() {
    return this.$relationship.tail;
  }
  *views() {
    for (const view of this.$model.views()) {
      if (view.includesRelation(this.id)) {
        yield view;
      }
    }
    return;
  }
  isDeploymentRelation() {
    return true;
  }
  isModelRelation() {
    return false;
  }
  hasMetadata() {
    return !!this.$relationship.metadata && !e(this.$relationship.metadata);
  }
  getMetadata(field) {
    if (field) {
      return this.$relationship.metadata?.[field];
    }
    return this.$relationship.metadata ?? {};
  }
  /**
   * Checks if the relationship has the given tag.
   */
  isTagged(tag) {
    return this.tags.includes(tag);
  }
}
class RelationshipsAccum {
  /**
   * @param model relationships from logical model
   * @param deployment relationships from deployment model
   */
  constructor(model = /* @__PURE__ */ new Set(), deployment = /* @__PURE__ */ new Set()) {
    this.model = model;
    this.deployment = deployment;
  }
  static empty() {
    return new RelationshipsAccum();
  }
  static from(model, deployment) {
    return new RelationshipsAccum(
      new Set(model),
      new Set(deployment)
    );
  }
  get isEmpty() {
    return this.model.size === 0 && this.deployment.size === 0;
  }
  get nonEmpty() {
    return this.model.size > 0 || this.deployment.size > 0;
  }
  get size() {
    return this.model.size + this.deployment.size;
  }
  /**
   * Returns new Accum containing all the elements which are both in this and otherAccum
   */
  intersect(otherAccum) {
    return RelationshipsAccum.from(
      intersection(this.model, otherAccum.model),
      intersection(this.deployment, otherAccum.deployment)
    );
  }
  /**
   * Returns new Accum containing all the elements which are both in this and otherAccum
   */
  difference(otherAccum) {
    return RelationshipsAccum.from(
      difference(this.model, otherAccum.model),
      difference(this.deployment, otherAccum.deployment)
    );
  }
  /**
   * Returns new Accum containing all the elements from both
   */
  union(otherAccum) {
    return RelationshipsAccum.from(
      union(this.model, otherAccum.model),
      union(this.deployment, otherAccum.deployment)
    );
  }
}

class DeploymentConnectionModel {
  constructor(source, target, relations) {
    this.source = source;
    this.target = target;
    this.relations = relations;
    this.id = stringHash(`deployment:${source.id}:${target.id}`);
  }
  id;
  /**
   * Human readable expression of the connection
   * Mostly used for testing and debugging
   */
  get expression() {
    return `${this.source.id} -> ${this.target.id}`;
  }
  _boundary;
  /**
   * Common ancestor of the source and target elements.
   * Represents the boundary of the connection.
   */
  get boundary() {
    this._boundary ??= this.source.commonAncestor(this.target);
    return this._boundary;
  }
  nonEmpty() {
    return this.relations.nonEmpty;
  }
  [customInspectSymbol](_depth, _inspectOptions, _inspect) {
    const asString = this.toString();
    Object.defineProperty(asString, "constructor", {
      value: DeploymentConnectionModel,
      enumerable: false
    });
    return asString;
  }
  toString() {
    const model = [...this.relations.model].map((c) => "    " + c.expression);
    if (model.length) {
      model.unshift("  model:");
    } else {
      model.unshift("  model: []");
    }
    const deployment = [...this.relations.deployment].map((c) => "    " + c.expression);
    if (deployment.length) {
      deployment.unshift("  deployment:");
    } else {
      deployment.unshift("  deployment: []");
    }
    return [
      this.expression,
      ...model,
      ...deployment
    ].join("\n");
  }
  /**
   * Check if connection contains deployment relation,
   * that is directly connected to source or target.
   */
  hasDirectDeploymentRelation() {
    for (const relation of this.relations.deployment) {
      if (relation.source.id === this.source.id || relation.target.id === this.target.id) {
        return true;
      }
    }
    return false;
  }
  *values() {
    yield* this.relations.model;
    yield* this.relations.deployment;
  }
  mergeWith(other) {
    if (Array.isArray(other)) {
      return other.reduce((acc, o) => acc.mergeWith(o), this);
    }
    invariant(this.source.id === other.source.id, "Cannot merge connections with different sources");
    invariant(this.target.id === other.target.id, "Cannot merge connections with different targets");
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.union(other.relations)
    );
  }
  difference(other) {
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.difference(other.relations)
    );
  }
  intersect(other) {
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      this.relations.intersect(other.relations)
    );
  }
  equals(other) {
    invariant(other instanceof DeploymentConnectionModel, "Other should ne DeploymentConnectionModel");
    return this.id === other.id && this.source.id === other.source.id && this.target.id === other.target.id && equals(this.relations.model, other.relations.model) && equals(this.relations.deployment, other.relations.deployment);
  }
  /**
   * Creates a clone of the current `DeploymentConnectionModel` instance with optional overrides.
   * if `null` is provided in overrides, the corresponding relation set will be empty.
   */
  update(overrides) {
    if (overrides) {
      overrides = {
        model: this.relations.model,
        deployment: this.relations.deployment,
        ...overrides
      };
    }
    return new DeploymentConnectionModel(
      this.source,
      this.target,
      overrides ? new RelationshipsAccum(
        overrides.model ?? /* @__PURE__ */ new Set(),
        overrides.deployment ?? /* @__PURE__ */ new Set()
      ) : this.relations
    );
  }
}

function findConnection(source, target, direction = "directed") {
  if (source === target) {
    return [];
  }
  if (isSameHierarchy(source, target)) {
    return [];
  }
  const directedIntersection = source.allOutgoing.intersect(target.allIncoming);
  const directed = directedIntersection.nonEmpty ? [
    new DeploymentConnectionModel(
      source,
      target,
      directedIntersection
    )
  ] : [];
  if (direction === "directed") {
    return directed;
  }
  return [
    ...directed,
    ...findConnection(target, source, "directed")
  ];
}
function findConnectionsBetween(element, others, direction = "both") {
  if (element.allIncoming.isEmpty && element.allOutgoing.isEmpty) {
    return [];
  }
  const outgoing = [];
  const incoming = [];
  for (const _other of others) {
    if (element === _other) {
      continue;
    }
    for (const found of findConnection(element, _other, direction)) {
      if (found.source === element) {
        outgoing.push(found);
      } else {
        incoming.push(found);
      }
    }
  }
  return [
    ...outgoing,
    ...incoming
  ];
}
function findConnectionsWithin(elements) {
  return [...elements].reduce((acc, el, index, array) => {
    if (index === array.length - 1) {
      return acc;
    }
    acc.push(
      ...findConnectionsBetween(el, array.slice(index + 1), "both")
    );
    return acc;
  }, []);
}

const deploymentConnection = {
  __proto__: null,
  findConnection: findConnection,
  findConnectionsBetween: findConnectionsBetween,
  findConnectionsWithin: findConnectionsWithin
};

export { DeploymentConnectionModel as D, NestedElementOfDeployedInstanceModel as N, RelationshipsAccum as R, DeploymentNodeModel as a, DeployedInstanceModel as b, DeploymentRelationModel as c, deploymentConnection as d, e, findConnection as f, findConnectionsBetween as g, findConnectionsWithin as h, t };
