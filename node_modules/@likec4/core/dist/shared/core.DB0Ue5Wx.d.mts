import { IsAny, UnionToIntersection, Simplify, KeysOfUnion } from 'type-fest';

type NonEmptyArray<T> = [T, ...T[]];
type NonEmptyReadonlyArray<T> = readonly [T, ...T[]];
type IterableContainer<T = unknown> = ReadonlyArray<T> | readonly [];
type ReorderedArray<T extends IterableContainer> = {
    -readonly [P in keyof T]: T[number];
};
type KeysOf<T> = keyof T extends infer K extends string ? K : never;
type AllNever<Expressions> = UnionToIntersection<{
    [Name in keyof Expressions]: {
        -readonly [Key in keyof Expressions[Name]]?: never;
    };
}[keyof Expressions]>;
/**
 * @example
 * ```ts
 *   type Variant1 = {
 *     a: string
 *   }
 *   type Variant2 = {
 *     b: number
 *   }
 *
 *   type Variants = ExclusiveUnion<{
 *     Variant1: Variant1,
 *     Variant2: Variant2
 *   }>
 *
 *   // Fail here
 *   const variant1: Variants = {
 *      a: 'one',
 *      b: 1
 *   }
 * ```
 */
type ExclusiveUnion<Expressions, All = AllNever<Expressions>> = Expressions extends object ? {
    [Name in keyof Expressions]: Simplify<Omit<All, keyof Expressions[Name]> & Expressions[Name]>;
}[keyof Expressions] : never;
/**
 * Copy from https://github.com/remeda/remeda/blob/main/packages/remeda/src/internal/types/NTuple.ts
 * An array with *exactly* N elements in it.
 *
 * Only literal N values are supported. For very large N the type might result
 * in a recurse depth error. For negative N the type would result in an infinite
 * recursion. None of these have protections because this is an internal type!
 */
type NTuple<T, N extends number, Result extends Array<unknown> = []> = Result['length'] extends N ? Result : NTuple<T, N, [...Result, T]>;
type IteratorLike<T> = IteratorObject<T, BuiltinIteratorReturn, unknown>;
type Predicate<T> = (x: T) => boolean;
interface Link {
    title?: string;
    url: string;
    relative?: string;
}
/**
 * Coalesce `V` to a string if it is `any`
 */
type Coalesce<V extends string, OrIfAny = string> = IsAny<V> extends true ? OrIfAny : V;
type ExactObject<T, InputType = unknown> = {
    [KeyType in keyof T]: undefined extends T[KeyType] ? T[KeyType] | undefined : T[KeyType];
} & Record<Exclude<keyof InputType, KeysOfUnion<T>>, never>;
/**
 * Allows only exact properties of `U` to be present in `T` and omits undefined values
 *
 * See {@link Exact} for more details (this version is non-deep)
 */
declare function exact<Expected, T extends ExactObject<Expected, T>>(a: T): Expected;

export { type Coalesce as C, type ExclusiveUnion as E, type IterableContainer as I, type KeysOf as K, type Link as L, type NonEmptyArray as N, type Predicate as P, type ReorderedArray as R, type NonEmptyReadonlyArray as a, type NTuple as b, type IteratorLike as c, exact as e };
