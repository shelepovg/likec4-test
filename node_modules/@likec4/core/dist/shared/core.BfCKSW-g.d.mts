import { SetRequired, IsAny } from 'type-fest';
import { L as LikeC4Styles } from './core.CAgYpDtM.mjs';
import { A as Any, R as RelationKind, r as Tags, H as Metadata, C as MetadataKey, I as LooseTag, F as Fqn, a as ElementId, E as ElementKind, P as ProjectId$1, y as DeploymentKind, c as AnyLayouted, J as RelationId$1, S as StrictViewId, n as _type, m as _stage, K as LooseElementId, O as LooseDeploymentId, x as DeploymentFqn, t as toComputed, b as AnyComputed, Q as Stage, D as DeploymentId, V as ViewId, T as Tag, d as AnyParsed, X as LooseViewId, U as Unknown, e as Aux, i as UnknownParsed, g as UnknownComputed, h as UnknownLayouted } from './core.D00YbOhQ.mjs';
import { d as RelationId, P as ProjectId, a as IconUrl, j as NodeId, G as GroupElementKind, k as EdgeId, l as StepEdgeId, V as ViewId$1 } from './core.C_3y3eqV.mjs';
import { D as DefaultMap } from './core.CywrQs86.mjs';
import { b as RichTextOrEmpty, L as LayoutedView, V as ViewManualLayoutSnapshot, r as ComputedView, v as ViewWithType, P as ParsedLikeC4ModelData, C as ComputedLikeC4ModelData, c as LayoutedLikeC4ModelData, e as DeployedInstance, j as DeploymentRelationship, f as DeploymentElement, D as DeploymentNode, m as LikeC4ModelDump, o as AuxFromDump } from './core.osFs8tU7.mjs';
import { c as IteratorLike, L as Link, N as NonEmptyArray } from './core.DB0Ue5Wx.mjs';
import { C as Color, f as RelationshipLineType, g as RelationshipArrowType, h as ElementShape, W as WhereOperator } from './core.DC5IAaDT.mjs';
import { R as Relationship, f as Element, E as ElementStyle, C as ComputedNodeStyle, a6 as DynamicViewDisplayVariant, n as LikeC4Project, S as Specification, M as ModelGlobals } from './core.Dojz4bvg.mjs';
import { B as BBox } from './core.BPGOjone.mjs';
import { FqnRef } from '../types/fqnRef.mjs';

type RelationshipsIterator<A extends Any> = IteratorLike<RelationshipModel<A>>;
/**
 * A relationship between two elements (in logical or deployment model)
 * use {@link isDeploymentRelationModel} guard to check if the relationship is a deployment relationship
 */
interface AnyRelationshipModel<A extends Any = Any> extends WithTags<A>, WithMetadata<A> {
    readonly id: RelationId;
    readonly expression: string;
    readonly title: string | null;
    readonly technology: string | null;
    readonly hasSummary: boolean;
    readonly summary: RichTextOrEmpty;
    readonly description: RichTextOrEmpty;
    readonly navigateTo: LikeC4ViewModel<A> | null;
    readonly kind: RelationKind<A> | null;
    readonly links: ReadonlyArray<Link>;
    readonly color: Color;
    readonly line: RelationshipLineType;
    readonly head: RelationshipArrowType;
    readonly tail: RelationshipArrowType | undefined;
    isDeploymentRelation(): this is DeploymentRelationModel<A>;
    isModelRelation(): this is RelationshipModel<A>;
    views(): ViewsIterator<A>;
}
declare class RelationshipModel<A extends Any = Any> implements AnyRelationshipModel<A> {
    readonly model: LikeC4Model<A>;
    readonly $relationship: Relationship<A>;
    readonly source: ElementModel<A>;
    readonly target: ElementModel<A>;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the Relation.
     */
    readonly boundary: ElementModel<A> | null;
    constructor(model: LikeC4Model<A>, $relationship: Relationship<A>);
    get id(): RelationId;
    get expression(): string;
    get title(): string | null;
    get technology(): string | null;
    /**
     * Returns true if the relationship has a summary and a description
     * (if one is missing - it falls back to another)
     */
    get hasSummary(): boolean;
    /**
     * Short description of the relationship.
     * Falls back to description if summary is not provided.
     */
    get summary(): RichTextOrEmpty;
    /**
     * Long description of the relationship.
     * Falls back to summary if description is not provided.
     */
    get description(): RichTextOrEmpty;
    get navigateTo(): LikeC4ViewModel<A> | null;
    get tags(): Tags<A>;
    get kind(): RelationKind<A> | null;
    get links(): ReadonlyArray<Link>;
    get color(): Color;
    get line(): RelationshipLineType;
    get head(): RelationshipArrowType;
    get tail(): RelationshipArrowType | undefined;
    /**
     * Iterate over all views that include this relationship.
     */
    views(): ViewsIterator<A>;
    isDeploymentRelation(): this is DeploymentRelationModel<A>;
    isModelRelation(): this is RelationshipModel<A>;
    hasMetadata(): boolean;
    getMetadata(): Metadata<A>;
    getMetadata(field: MetadataKey<A>): string | string[] | undefined;
    /**
     * Checks if the relationship has the given tag.
     */
    isTagged(tag: LooseTag<A>): boolean;
}

type ElementsIterator<M extends Any> = IteratorLike<ElementModel<M>>;
declare class ElementModel<A extends Any = Any> implements WithTags<A>, WithMetadata<A> {
    readonly $model: LikeC4Model<A>;
    readonly $element: Element<A>;
    /**
     * Don't use in runtime, only for type inference
     */
    readonly Aux: A;
    readonly id: Fqn<A>;
    readonly _literalId: ElementId<A>;
    readonly hierarchyLevel: number;
    readonly imported: null | {
        readonly from: ProjectId;
        readonly fqn: Fqn<Any>;
    };
    constructor($model: LikeC4Model<A>, $element: Element<A>);
    get name(): string;
    get parent(): ElementModel<A> | null;
    get kind(): ElementKind<A>;
    get shape(): ElementShape;
    get color(): Color;
    get icon(): IconUrl | null;
    /**
     * Returns all tags of the element.
     * It includes tags from the element and its kind.
     */
    get tags(): Tags<A>;
    get title(): string;
    /**
     * Returns true if the element has a summary and a description
     * (if one is missing - it falls back to another)
     */
    get hasSummary(): boolean;
    /**
     * Short description of the element.
     * Falls back to description if summary is not provided.
     */
    get summary(): RichTextOrEmpty;
    /**
     * Long description of the element.
     * Falls back to summary if description is not provided.
     */
    get description(): RichTextOrEmpty;
    get technology(): string | null;
    get links(): ReadonlyArray<Link>;
    get defaultView(): LikeC4ViewModel.ScopedElementView<A> | null;
    get isRoot(): boolean;
    get style(): SetRequired<ElementStyle, 'shape' | 'color' | 'size'>;
    get projectId(): ProjectId$1<A>;
    isAncestorOf(another: ElementModel<A>): boolean;
    isDescendantOf(another: ElementModel<A>): boolean;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(): ElementsIterator<A>;
    /**
     * Returns the common ancestor of this element and another element.
     */
    commonAncestor(another: ElementModel<A>): ElementModel<A> | null;
    children(): ReadonlySet<ElementModel<A>>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(sort?: 'asc' | 'desc'): ElementsIterator<A>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(): ElementsIterator<A>;
    /**
     * Resolve siblings of the element and its ancestors
     * (from closest parent to root)
     */
    ascendingSiblings(): ElementsIterator<A>;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from root to closest)
     */
    descendingSiblings(): ElementsIterator<A>;
    incoming(filter?: IncomingFilter): RelationshipsIterator<A>;
    incomers(filter?: IncomingFilter): ElementsIterator<A>;
    outgoing(filter?: OutgoingFilter): RelationshipsIterator<A>;
    outgoers(filter?: OutgoingFilter): ElementsIterator<A>;
    get allOutgoing(): ReadonlySet<RelationshipModel<A>>;
    get allIncoming(): ReadonlySet<RelationshipModel<A>>;
    /**
     * Iterate over all views that include this element.
     */
    views(): ReadonlySet<LikeC4ViewModel<A>>;
    /**
     * Iterate over all views that scope this element.
     * It is possible that element is not included in the view.
     */
    scopedViews(): ReadonlySet<LikeC4ViewModel.ScopedElementView<A>>;
    /**
     * @returns true if the element is deployed
     */
    isDeployed(): boolean;
    deployments(): DeployedInstancesIterator<A>;
    hasMetadata(): boolean;
    getMetadata(): Metadata<A>;
    getMetadata(field: MetadataKey<A>): string | string[] | undefined;
    /**
     * Checks if the element has the given tag.
     */
    isTagged(tag: LooseTag<A>): boolean;
}

type NodesIterator<M extends Any, V extends $View<M>> = IteratorLike<NodeModel<M, V>>;
declare class NodeModel<A extends Any = Any, V extends $View<A> = $View<A>> implements WithTags<A> {
    readonly Aux: A;
    readonly $viewModel: LikeC4ViewModel<A, V>;
    readonly $view: V;
    readonly $node: V['nodes'][number];
    constructor($viewModel: LikeC4ViewModel<A, V>, $node: V['nodes'][number]);
    get id(): NodeId;
    get title(): string;
    get kind(): ElementKind<A> | DeploymentKind<A> | typeof GroupElementKind | 'instance';
    get description(): RichTextOrEmpty;
    get technology(): string | null;
    get parent(): NodeModel<A, V> | null;
    get element(): ElementModel<A> | null;
    get deployment(): DeploymentElementModel<A> | null;
    get shape(): ElementShape;
    get color(): Color;
    get icon(): IconUrl | null;
    get tags(): Tags<A>;
    get links(): ReadonlyArray<Link>;
    get navigateTo(): LikeC4ViewModel<A> | null;
    get style(): ComputedNodeStyle;
    get x(): number | undefined;
    get y(): number | undefined;
    get width(): number | undefined;
    get height(): number | undefined;
    children(): ReadonlySet<NodeModel<A, V>>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(): NodesIterator<A, V>;
    siblings(): NodesIterator<A, V>;
    incoming(filter?: IncomingFilter): EdgesIterator<A, V>;
    incomers(filter?: IncomingFilter): NodesIterator<A, V>;
    outgoing(filter?: OutgoingFilter): EdgesIterator<A, V>;
    outgoers(filter?: OutgoingFilter): NodesIterator<A, V>;
    isLayouted(): this is NodeModel.Layouted<A>;
    hasChildren(): boolean;
    hasParent(): this is NodeModel.WithParent<A, V>;
    /**
     * Check if this node references to logical model element.
     */
    hasElement(): this is NodeModel.WithElement<A, V>;
    /**
     * Check if this node references to deployment element (Node or Instance).
     */
    hasDeployment(): this is NodeModel.WithDeploymentElement<A, V>;
    /**
     * Check if this node references to deployed instance
     * Deployed instance always references to element and deployment element.
     */
    hasDeployedInstance(): this is NodeModel.WithDeployedInstance<A, V>;
    isGroup(): this is NodeModel.IsGroup<A, V>;
    /**
     * Checks if the node has the given tag.
     */
    isTagged(tag: LooseTag<A>): boolean;
}
declare namespace NodeModel {
    type Layouted<A> = A extends AnyLayouted ? NodeModel<A, LayoutedView<A>> & {
        x: number;
        y: number;
        width: number;
        height: number;
    } : never;
    interface WithParent<A extends Any, V extends $View<A> = $View<A>> extends NodeModel<A, V> {
        readonly parent: NodeModel<A, V>;
    }
    interface WithElement<A extends Any, V extends $View<A> = $View<A>> extends NodeModel<A, V> {
        readonly kind: ElementKind<A>;
        readonly element: ElementModel<A>;
    }
    interface WithDeploymentElement<A extends Any, V extends $View<A> = $View<A>> extends NodeModel<A, V> {
        readonly kind: DeploymentKind<A>;
        readonly deployment: DeploymentElementModel<A>;
    }
    interface WithDeployedInstance<A extends Any, V extends $View<A> = $View<A>> extends NodeModel<A, V> {
        readonly kind: 'instance';
        readonly element: ElementModel<A>;
        readonly deployment: DeployedInstanceModel<A>;
    }
    interface IsGroup<A extends Any, V extends $View<A> = $View<A>> extends NodeModel<A, V> {
        readonly kind: typeof GroupElementKind;
        readonly element: null;
        readonly deployment: null;
    }
}

type EdgesIterator<A extends Any, V extends $View<A>> = IteratorLike<EdgeModel<A, V>>;
declare class EdgeModel<A extends Any = Any, V extends $View<A> = $View<A>> implements WithTags<A> {
    readonly source: NodeModel<A, V>;
    readonly target: NodeModel<A, V>;
    readonly Aux: A;
    readonly $viewModel: LikeC4ViewModel<A, V>;
    readonly $view: V;
    readonly $edge: V['edges'][number];
    constructor($viewModel: LikeC4ViewModel<A, V>, $edge: V['edges'][number], source: NodeModel<A, V>, target: NodeModel<A, V>);
    get id(): EdgeId;
    get parent(): NodeModel<A, V> | null;
    get label(): string | null;
    get description(): RichTextOrEmpty;
    get technology(): string | null;
    hasParent(): this is EdgeModel.WithParent<A, V>;
    get tags(): Tags<A>;
    get stepNumber(): number | null;
    get navigateTo(): LikeC4ViewModel<A> | null;
    get color(): Color;
    get line(): RelationshipLineType;
    get head(): RelationshipArrowType;
    get tail(): RelationshipArrowType | undefined;
    isStep(): this is EdgeModel.StepEdge<A, V>;
    relationships(type: 'model'): IteratorLike<RelationshipModel<A>>;
    relationships(type: 'deployment'): IteratorLike<DeploymentRelationModel<A>>;
    relationships(type?: 'model' | 'deployment'): IteratorLike<RelationshipModel<A> | DeploymentRelationModel<A>>;
    includesRelation(rel: RelationId$1 | {
        id: RelationId$1;
    }): boolean;
    isTagged(tag: LooseTag<A>): boolean;
}
declare namespace EdgeModel {
    interface StepEdge<A extends Any, V extends $View<A>> extends EdgeModel<A, V> {
        readonly id: StepEdgeId;
        readonly stepNumber: number;
    }
    interface WithParent<A extends Any, V extends $View<A>> extends EdgeModel<A, V> {
        readonly parent: NodeModel<A, V>;
    }
}

declare class LikeC4ViewsFolder<A extends Any = Any> {
    readonly $model: LikeC4Model<A>;
    /**
     * Path to this view folder, processed by {@link normalizeViewPath}
     *
     * @example
     * "Folder 1/Folder 2/Folder 3"
     */
    readonly path: string;
    /**
     * Title of this view folder.
     *
     * @example
     * // title is the last segment of the path
     * path = "Folder 1/Folder 2/Folder 3"
     * title = "Folder 3"
     */
    readonly title: string;
    /**
     * Whether this is the root view folder.
     *
     * !NOTE
     * Root folder is special folder with an empty path and used only for internal purposes. \
     * It is not visible to the user and should not be used in the code.
     */
    readonly isRoot: boolean;
    protected readonly parentPath: string | undefined;
    protected readonly defaultViewId: StrictViewId<A> | undefined;
    constructor($model: LikeC4Model<A>, path: NonEmptyArray<string>, defaultViewId: StrictViewId<A> | undefined);
    /**
     * Default view of this view folder.\
     * It is for the case when there is a view at the same path as this folder.\
     * (if there are multiple views at the same path, the first one is chosen)
     *
     * @example
     * ```
     * // Assume the following views exist:
     * const views = [
     *   "Folder 1/ Folder 2 / View",
     *   "Folder 1/ Folder 2 / View / Subview",
     * ]
     * ```
     * Group with path `Folder 1/ Folder 2 / View`\
     * will have default view `Folder 1/ Folder 2 / View`
     */
    get defaultView(): LikeC4ViewModel<A> | null;
    /**
     * Returns path to this view folder as an array of ancestors (excluding root) and this view folder as the last element
     *
     * @throws Error if this is the root folder.
     */
    get breadcrumbs(): [...LikeC4ViewsFolder<A>[], this];
    /**
     * Returns parent folder
     *
     * @throws Error if this is the root folder.
     */
    get parent(): LikeC4ViewsFolder<A> | null;
    /**
     * Returns sorted set of children
     * - First folders
     * - Then views
     */
    get children(): ReadonlySet<LikeC4ViewsFolder<A> | LikeC4ViewModel<A>>;
    /**
     * Returns sorted array of children folders
     */
    get folders(): ReadonlyArray<LikeC4ViewsFolder<A>>;
    /**
     * Returns all views in this view folder.
     */
    get views(): ReadonlyArray<LikeC4ViewModel<A>>;
}

type ViewsIterator<A extends Any, V extends $View<A> = $View<A>> = IteratorLike<LikeC4ViewModel<A, V>>;
declare class LikeC4ViewModel<A extends Any = Any, V extends $View<A> = $View<A>> implements WithTags<A> {
    #private;
    /**
     * Don't use in runtime, only for type inference
     */
    readonly Aux: A;
    readonly id: StrictViewId<A>;
    /**
     * The model this view belongs to
     */
    readonly $model: LikeC4Model<A>;
    /**
     * The title of the view
     */
    readonly title: string | null;
    /**
     * View folder this view belongs to.
     * If view is top-level, this is the root folder.
     */
    readonly folder: LikeC4ViewsFolder<A>;
    /**
     * Path to this view, processed by {@link normalizeViewPath}
     *
     * @example
     * "Group 1/Group 2/View"
     */
    readonly viewPath: string;
    constructor(model: LikeC4Model<A>, folder: LikeC4ViewsFolder<A>, view: V, manualLayoutSnapshot?: ViewManualLayoutSnapshot | undefined);
    /**
     * Returns the styles configuration for the project.
     */
    get $styles(): LikeC4Styles;
    get _type(): V[_type];
    get stage(): V[_stage];
    get bounds(): Readonly<BBox>;
    /**
     * Returns title if defined, otherwise returns title of the element it is based on, otherwise returns its {@link id}
     */
    get titleOrId(): string;
    /**
     * Returns title if defined, otherwise returns `Untitled`.
     */
    get titleOrUntitled(): string;
    /**
     * Returns path to this view as an array of groups and this view as the last element
     * If view is top-level, returns only this view.
     *
     * @example
     * viewPath = "Group 1/Group 2/View"
     *
     * breadcrumbs = [
     *   "Group 1",             // folder
     *   "Group 1/Group 2",     // folder
     *   "Group 1/Group 2/View" // view
     * ]
     */
    get breadcrumbs(): [...LikeC4ViewsFolder<A>[], this];
    get description(): RichTextOrEmpty;
    get tags(): Tags<A>;
    get links(): ReadonlyArray<Link>;
    get viewOf(): ElementModel<A> | null;
    /**
     * Available for dynamic views only
     * throws error if view is not dynamic
     */
    get mode(): DynamicViewDisplayVariant | null;
    /**
     * All tags from nodes and edges.
     */
    get includedTags(): Tags<A>;
    /**
     * The original view from the model.
     * In case of layouted model, this is the latest auto-layouted view without manual changes applied
     * @see {@link $layouted} should be used for rendering in the UI
     */
    get $view(): V;
    /**
     * Returns the view with manual layout applied if it exists, otherwise returns the original view
     * This should be used for rendering in the UI
     */
    get $layouted(): V;
    get hasManualLayout(): boolean;
    get hasLayoutDrifts(): boolean;
    /**
     * If view has manual layout, returns it with manual layout applied
     */
    get $manual(): V | null;
    get projectId(): ProjectId$1<A>;
    roots(): NodesIterator<A, V>;
    /**
     * Iterate over all nodes that have children.
     */
    compounds(): NodesIterator<A, V>;
    /**
     * Get node by id.
     * @throws Error if node is not found.
     */
    node(node: NodeOrId): NodeModel<A, V>;
    /**
     * Find node by id.
     */
    findNode(node: NodeOrId): NodeModel<A, V> | null;
    findNodeWithElement(element: LooseElementId<A> | {
        id: Fqn<A>;
    }): NodeModel.WithElement<A, V> | null;
    /**
     * Iterate over all nodes.
     */
    nodes(): NodesIterator<A, V>;
    /**
     * Get edge by id, throws error if edge is not found.
     * Use {@link findEdge} if you are not sure if the edge exists.
     *
     * @param edge Edge or id
     * @returns {@link EdgeModel}
     */
    edge(edge: EdgeOrId): EdgeModel<A, V>;
    /**
     * Find edge by id.
     * @param edge Edge or id
     * @returns {@link EdgeModel} or null if edge is not found
     */
    findEdge(edge: EdgeOrId): EdgeModel<A, V> | null;
    /**
     * Iterate over all edges.
     */
    edges(): EdgesIterator<A, V>;
    /**
     * Iterate over all edges.
     */
    edgesWithRelation(relation: RelationId$1): EdgesIterator<A, V>;
    /**
     * Nodes that have references to elements from logical model.
     */
    elements(): IteratorLike<NodeModel.WithElement<A, V>>;
    /**
     * Checks if the view has the given tag.
     */
    isTagged(tag: LooseTag<A>): boolean;
    includesElement(element: LooseElementId<A> | {
        id: Fqn<A>;
    }): boolean;
    includesDeployment(deployment: LooseDeploymentId<A> | {
        id: DeploymentFqn<A>;
    }): boolean;
    includesRelation(relation: RelationId | {
        id: RelationId;
    }): boolean;
    /**
     * Below are type guards.
     */
    isComputed(this: LikeC4ViewModel<any, any>): this is LikeC4ViewModel.Computed<toComputed<A>>;
    isLayouted(): this is LikeC4ViewModel.Layouted<A>;
    /**
     * @deprecated Use {@link isLayouted} instead
     */
    isDiagram(): this is LikeC4ViewModel.Layouted<A>;
    isElementView(this: LikeC4ViewModel<any, any>): this is LikeC4ViewModel.ElementView<A, V>;
    isScopedElementView(this: LikeC4ViewModel<any, any>): this is LikeC4ViewModel.ScopedElementView<A>;
    isDeploymentView(this: LikeC4ViewModel<any, any>): this is LikeC4ViewModel.DeploymentView<A, V>;
    isDynamicView(this: LikeC4ViewModel<any, any>): this is LikeC4ViewModel.DynamicView<A, V>;
}
declare namespace LikeC4ViewModel {
    type Computed<A> = A extends AnyComputed ? LikeC4ViewModel<A, ComputedView<A>> : never;
    type Layouted<A> = A extends AnyLayouted ? LikeC4ViewModel<A, LayoutedView<A>> : never;
    interface ElementView<A extends Any, V extends $View<A> = $View<A>> extends LikeC4ViewModel<A, ViewWithType<V, 'element'>> {
        readonly mode: never;
    }
    interface ScopedElementView<A extends Any> extends LikeC4ViewModel<A, ViewWithType<$View<A>, 'element'> & {
        viewOf: Fqn<A>;
    }> {
        readonly mode: never;
        readonly viewOf: ElementModel<A>;
    }
    interface DeploymentView<A extends Any, V extends $View<A> = $View<A>> extends LikeC4ViewModel<A, ViewWithType<V, 'deployment'>> {
        readonly mode: never;
    }
    interface DynamicView<A extends Any, V extends $View<A>> extends LikeC4ViewModel<A, ViewWithType<V, 'dynamic'>> {
        readonly mode: DynamicViewDisplayVariant;
        readonly viewOf: never;
    }
}

type IncomingFilter = 'all' | 'direct' | 'to-descendants';
type OutgoingFilter = 'all' | 'direct' | 'from-descendants';
type ElementOrFqn<A> = ElementId<A> | {
    id: Fqn<A>;
};
type DeploymentOrFqn<A> = DeploymentId<A> | {
    id: DeploymentFqn<A>;
};
type NodeOrId = string | {
    id: NodeId;
};
type EdgeOrId = string | {
    id: EdgeId;
};
type RelationOrId = string | {
    id: RelationId;
};
type $View<A extends Any> = {
    parsed: never;
    computed: ComputedView<A>;
    layouted: LayoutedView<A>;
}[Stage<A>];
type $ViewModel<A extends Any> = {
    parsed: never;
    computed: LikeC4ViewModel<A, $View<A>>;
    layouted: LikeC4ViewModel<A, $View<A>>;
}[Stage<A>];
type $ModelData<A extends Any> = {
    parsed: ParsedLikeC4ModelData<A>;
    computed: ComputedLikeC4ModelData<A>;
    layouted: LayoutedLikeC4ModelData<A>;
}[Stage<A>];
interface WithTags<A extends Any> {
    get tags(): Tags<A>;
    isTagged(tag: LooseTag<A>): boolean;
}
interface WithMetadata<A extends Any> {
    hasMetadata(): boolean;
    getMetadata(): Metadata<A>;
    getMetadata(field: MetadataKey<A>): string | string[] | undefined;
}

declare class LikeC4DeploymentModel<A extends Any = Any> {
    #private;
    readonly $model: LikeC4Model<A>;
    readonly $deployments: $ModelData<A>['deployments'];
    constructor($model: LikeC4Model<A>);
    get $styles(): LikeC4Styles;
    get projectId(): ProjectId$1<A>;
    element(el: DeploymentOrFqn<A>): DeploymentElementModel<A>;
    findElement(el: LooseDeploymentId<A>): DeploymentElementModel<A> | null;
    node(el: DeploymentOrFqn<A>): DeploymentNodeModel<A>;
    findNode(el: LooseDeploymentId<A>): DeploymentNodeModel<A> | null;
    instance(el: DeploymentOrFqn<A>): DeployedInstanceModel<A>;
    findInstance(el: LooseDeploymentId<A>): DeployedInstanceModel<A> | null;
    /**
     * Returns the root elements of the model.
     */
    roots(): DeploymentNodesIterator<A>;
    /**
     * Returns all elements in the model.
     */
    elements(): DeploymentElementsIterator<A>;
    /**
     * Returns all elements in the model.
     */
    nodes(): DeploymentNodesIterator<A>;
    nodesOfKind(kind: DeploymentKind<A>): DeploymentNodesIterator<A>;
    instances(): DeployedInstancesIterator<A>;
    /**
     * Iterate over all instances of the given logical element.
     */
    instancesOf(element: ElementOrFqn<A>): DeployedInstancesIterator<A>;
    deploymentRef(ref: FqnRef.DeploymentRef<A>): DeploymentElementModel<A> | NestedElementOfDeployedInstanceModel<A>;
    /**
     * Returns all relationships in the model.
     */
    relationships(): IteratorLike<DeploymentRelationModel<A>>;
    /**
     * Returns a specific relationship by its ID.
     */
    relationship(id: RelationOrId): DeploymentRelationModel<A>;
    findRelationship(id: string): DeploymentRelationModel<A> | null;
    /**
     * Returns all deployment views in the model.
     */
    views(): IteratorLike<LikeC4ViewModel.DeploymentView<A>>;
    /**
     * Returns the parent element of given element.
     * @see ancestors
     */
    parent(element: DeploymentOrFqn<A>): DeploymentNodeModel<A> | null;
    /**
     * Get all children of the element (only direct children),
     * @see descendants
     */
    children(element: DeploymentOrFqn<A>): ReadonlySet<DeploymentElementModel<A>>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(element: DeploymentOrFqn<A>): DeploymentElementsIterator<A>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: DeploymentOrFqn<A>): DeploymentNodesIterator<A>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(element: DeploymentOrFqn<A>, sort?: 'asc' | 'desc'): DeploymentElementsIterator<A>;
    /**
     * Incoming relationships to the element and its descendants
     * @see incomers
     */
    incoming(element: DeploymentOrFqn<A>, filter?: IncomingFilter): IteratorLike<DeploymentRelationModel<A>>;
    /**
     * Outgoing relationships from the element and its descendants
     * @see outgoers
     */
    outgoing(element: DeploymentOrFqn<A>, filter?: OutgoingFilter): IteratorLike<DeploymentRelationModel<A>>;
    private addElement;
    private addRelation;
}

type DeploymentElementsIterator<A extends Any> = IteratorLike<DeploymentElementModel<A>>;
type DeployedInstancesIterator<A extends Any> = IteratorLike<DeployedInstanceModel<A>>;
type DeploymentNodesIterator<A extends Any> = IteratorLike<DeploymentNodeModel<A>>;
type DeploymentElementModel<A extends Any = Any> = DeploymentNodeModel<A> | DeployedInstanceModel<A>;
declare abstract class AbstractDeploymentElementModel<A extends Any> implements WithTags<A>, WithMetadata<A> {
    /**
     * Don't use in runtime, only for type inference
     */
    readonly Aux: A;
    abstract readonly id: DeploymentFqn<A>;
    abstract readonly _literalId: DeploymentId<A>;
    abstract readonly parent: DeploymentNodeModel<A> | null;
    abstract readonly title: string;
    abstract readonly hierarchyLevel: number;
    abstract readonly $model: LikeC4DeploymentModel<A>;
    abstract readonly $node: DeploymentElement<A>;
    abstract readonly tags: Tags<A>;
    get style(): SetRequired<ElementStyle, 'shape' | 'color' | 'size'>;
    get name(): string;
    get shape(): ElementShape;
    get color(): Color;
    get icon(): IconUrl | null;
    /**
     * Short description of the element.
     * Falls back to description if summary is not provided.
     */
    get summary(): RichTextOrEmpty;
    /**
     * Long description of the element.
     * Falls back to summary if description is not provided.
     */
    get description(): RichTextOrEmpty;
    get technology(): string | null;
    get links(): ReadonlyArray<Link>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(): DeploymentNodesIterator<A>;
    /**
     * Returns the common ancestor of this element and another element.
     */
    commonAncestor(another: DeploymentElementModel<A>): DeploymentNodeModel<A> | null;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(): DeploymentElementsIterator<A>;
    /**
     * Check if the element is a sibling of another element
     */
    isSibling(other: DeploymentElementModel<A>): boolean;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from closest to root)
     */
    ascendingSiblings(): DeploymentElementsIterator<A>;
    /**
     * Resolve siblings of the element and its ancestors
     *  (from root to closest)
     */
    descendingSiblings(): DeploymentElementsIterator<A>;
    incoming(filter?: IncomingFilter): IteratorLike<DeploymentRelationModel<A>>;
    outgoing(filter?: OutgoingFilter): IteratorLike<DeploymentRelationModel<A>>;
    incomers(filter?: IncomingFilter): IteratorLike<DeploymentRelationEndpoint<A>>;
    outgoers(filter?: OutgoingFilter): IteratorLike<DeploymentRelationEndpoint<A>>;
    /**
     * Iterate over all views that include this deployment element.
     */
    views(): IteratorLike<LikeC4ViewModel.DeploymentView<A>>;
    isDeploymentNode(): this is DeploymentNodeModel<A>;
    isInstance(): this is DeployedInstanceModel<A>;
    abstract outgoingModelRelationships(): RelationshipsIterator<A>;
    abstract incomingModelRelationships(): RelationshipsIterator<A>;
    get allOutgoing(): RelationshipsAccum<A>;
    get allIncoming(): RelationshipsAccum<A>;
    hasMetadata(): boolean;
    getMetadata(): Metadata<A>;
    getMetadata(field: MetadataKey<A>): string | string[] | undefined;
    /**
     * Checks if the deployment element has the given tag.
     */
    isTagged(tag: LooseTag<A>): boolean;
}
declare class DeploymentNodeModel<A extends Any = Any> extends AbstractDeploymentElementModel<A> {
    readonly $model: LikeC4DeploymentModel<A>;
    readonly $node: DeploymentNode<A>;
    id: DeploymentFqn<A>;
    _literalId: DeploymentId<A>;
    title: string;
    hierarchyLevel: number;
    constructor($model: LikeC4DeploymentModel<A>, $node: DeploymentNode<A>);
    get parent(): DeploymentNodeModel<A> | null;
    get kind(): DeploymentKind<A>;
    get tags(): Tags<A>;
    children(): ReadonlySet<DeploymentElementModel<A>>;
    descendants(sort?: 'asc' | 'desc'): DeploymentElementsIterator<A>;
    isDeploymentNode(): this is DeploymentNodeModel<A>;
    /**
     * Iterate over all instances nested in this deployment node.
     */
    instances(): DeployedInstancesIterator<A>;
    /**
     * Returns deployed instance inside this deployment node
     * if only there are no more instances
     */
    onlyOneInstance(): DeployedInstanceModel<A> | null;
    /**
     * Cached result of relationships from instances
     */
    private _relationshipsFromInstances;
    private relationshipsFromInstances;
    /**
     * We return only relationships that are not already present in nested instances
     */
    outgoingModelRelationships(): RelationshipsIterator<A>;
    /**
     * We return only relationships that are not already present in nested instances
     */
    incomingModelRelationships(): RelationshipsIterator<A>;
    /**
     * Returns an iterator of relationships between nested instances
     */
    internalModelRelationships(): ReadonlySet<RelationshipModel<A>>;
}
declare class DeployedInstanceModel<A extends Any = Any> extends AbstractDeploymentElementModel<A> {
    readonly $model: LikeC4DeploymentModel<A>;
    readonly $instance: DeployedInstance<A>;
    readonly element: ElementModel<A>;
    readonly id: DeploymentFqn<A>;
    readonly _literalId: DeploymentId<A>;
    readonly title: string;
    readonly hierarchyLevel: number;
    constructor($model: LikeC4DeploymentModel<A>, $instance: DeployedInstance<A>, element: ElementModel<A>);
    get $node(): DeployedInstance<A>;
    get parent(): DeploymentNodeModel<A>;
    get style(): SetRequired<ElementStyle, 'shape' | 'color' | 'size'>;
    get tags(): Tags<A>;
    get kind(): ElementKind<A>;
    get summary(): RichTextOrEmpty;
    get description(): RichTextOrEmpty;
    get technology(): string | null;
    get links(): ReadonlyArray<Link>;
    isInstance(): this is DeployedInstanceModel<A>;
    outgoingModelRelationships(): RelationshipsIterator<A>;
    incomingModelRelationships(): RelationshipsIterator<A>;
    /**
     * Iterate over all views that include this instance.
     * (Some views may include the parent deployment node instead of the instance.)
     */
    views(): IteratorLike<LikeC4ViewModel.DeploymentView<A>>;
}
declare class NestedElementOfDeployedInstanceModel<A extends Any = Any> {
    readonly instance: DeployedInstanceModel<A>;
    readonly element: ElementModel<A>;
    constructor(instance: DeployedInstanceModel<A>, element: ElementModel<A>);
    get id(): DeploymentFqn<A>;
    get _literalId(): DeploymentId<A>;
    get style(): SetRequired<ElementStyle, 'shape' | 'color'>;
    get shape(): ElementShape;
    get color(): Color;
    get title(): string;
    get summary(): RichTextOrEmpty;
    get description(): RichTextOrEmpty;
    get technology(): string | null;
    isDeploymentNode(): this is DeploymentNodeModel<A>;
    isInstance(): this is DeployedInstanceModel<A>;
}
type DeploymentRelationEndpoint<A extends Any = Any> = DeploymentElementModel<A> | NestedElementOfDeployedInstanceModel<A>;
declare class DeploymentRelationModel<A extends Any = Any> implements AnyRelationshipModel<A> {
    readonly $model: LikeC4DeploymentModel<A>;
    readonly $relationship: DeploymentRelationship<A>;
    boundary: DeploymentNodeModel<A> | null;
    source: DeploymentRelationEndpoint<A>;
    target: DeploymentRelationEndpoint<A>;
    constructor($model: LikeC4DeploymentModel<A>, $relationship: DeploymentRelationship<A>);
    get id(): RelationId;
    get expression(): string;
    get title(): string | null;
    get technology(): string | null;
    /**
     * Returns true if the relationship has a summary and a description
     * (if one is missing - it falls back to another)
     */
    get hasSummary(): boolean;
    /**
     * Short description of the relationship.
     * Falls back to description if summary is not provided.
     */
    get summary(): RichTextOrEmpty;
    /**
     * Long description of the relationship.
     * Falls back to summary if description is not provided.
     */
    get description(): RichTextOrEmpty;
    get tags(): Tags<A>;
    get kind(): RelationKind<A> | null;
    get navigateTo(): LikeC4ViewModel<A> | null;
    get links(): ReadonlyArray<Link>;
    get color(): Color;
    get line(): RelationshipLineType;
    get head(): RelationshipArrowType;
    get tail(): RelationshipArrowType | undefined;
    views(): IteratorLike<LikeC4ViewModel.DeploymentView<A>>;
    isDeploymentRelation(): this is DeploymentRelationModel<A>;
    isModelRelation(): this is RelationshipModel<A>;
    hasMetadata(): boolean;
    getMetadata(): Metadata<A>;
    getMetadata(field: MetadataKey<A>): string | string[] | undefined;
    /**
     * Checks if the relationship has the given tag.
     */
    isTagged(tag: LooseTag<A>): boolean;
}
declare class RelationshipsAccum<A extends Any = Any> {
    readonly model: ReadonlySet<RelationshipModel<A>>;
    readonly deployment: ReadonlySet<DeploymentRelationModel<A>>;
    static empty<A extends Any>(): RelationshipsAccum<A>;
    static from<A extends Any>(model: Iterable<RelationshipModel<A>> | undefined, deployment?: Iterable<DeploymentRelationModel<A>>): RelationshipsAccum<A>;
    /**
     * @param model relationships from logical model
     * @param deployment relationships from deployment model
     */
    constructor(model?: ReadonlySet<RelationshipModel<A>>, deployment?: ReadonlySet<DeploymentRelationModel<A>>);
    get isEmpty(): boolean;
    get nonEmpty(): boolean;
    get size(): number;
    /**
     * Returns new Accum containing all the elements which are both in this and otherAccum
     */
    intersect(otherAccum: RelationshipsAccum<A>): RelationshipsAccum<A>;
    /**
     * Returns new Accum containing all the elements which are both in this and otherAccum
     */
    difference(otherAccum: RelationshipsAccum<A>): RelationshipsAccum<A>;
    /**
     * Returns new Accum containing all the elements from both
     */
    union(otherAccum: RelationshipsAccum<A>): RelationshipsAccum<A>;
}

/**
 *  When you do not need types in the model
 */
type AnyLikeC4Model = LikeC4Model<any>;
declare class LikeC4Model<A extends Any = Any> {
    /**
     * Don't use in runtime, only for type inference
     */
    readonly Aux: A;
    protected readonly _elements: Map<Fqn<A>, ElementModel<A>>;
    protected readonly _parents: Map<Fqn<A>, ElementModel<A>>;
    protected readonly _children: DefaultMap<Fqn<A>, Set<ElementModel<A>>>;
    protected readonly _rootElements: Set<ElementModel<A>>;
    protected readonly _relations: Map<RelationId<string>, RelationshipModel<A>>;
    protected readonly _incoming: DefaultMap<Fqn<A>, Set<RelationshipModel<A>>>;
    protected readonly _outgoing: DefaultMap<Fqn<A>, Set<RelationshipModel<A>>>;
    protected readonly _internal: DefaultMap<Fqn<A>, Set<RelationshipModel<A>>>;
    protected readonly _views: Map<ViewId<A>, LikeC4ViewModel<A, $View<A>>>;
    protected readonly _rootViewFolder: LikeC4ViewsFolder<A>;
    protected readonly _viewFolders: Map<string, LikeC4ViewsFolder<A>>;
    protected readonly _viewFolderItems: DefaultMap<string, Set<LikeC4ViewsFolder<A> | LikeC4ViewModel<A, $View<A>>>>;
    protected readonly _allTags: DefaultMap<Tag<A>, Set<ElementModel<A> | RelationshipModel<A> | LikeC4ViewModel<A, $View<A>>>>;
    static fromParsed<T extends AnyParsed>(model: ParsedLikeC4ModelData<T>): LikeC4Model<T>;
    /**
     * Creates a new LikeC4Model instance from the provided model data.
     * Model with parsed data will not have views, as they must be computed
     * (this model is used for computing views)
     *
     * @typeParam M - Type parameter constrained to AnyLikeC4Model
     * @param model - The model data to create a LikeC4Model from
     * @returns A new LikeC4Model instance with the type derived from the input model
     */
    static create<T extends AnyParsed>(model: ParsedLikeC4ModelData<T>): LikeC4Model<T>;
    static create<T extends AnyComputed>(model: ComputedLikeC4ModelData<T>): LikeC4Model<T>;
    static create<T extends AnyLayouted>(model: LayoutedLikeC4ModelData<T>): LikeC4Model<T>;
    static create<T extends Any>(model: $ModelData<T>): LikeC4Model<T>;
    /**
     * Creates a new LikeC4Model instance and infers types from a model dump.\
     * Model dump expected to be computed or layouted.
     *
     * @typeParam D - A constant type parameter extending LikeC4ModelDump
     * @param dump - The model dump to create the instance from
     * @returns A  new LikeC4Model instance with types inferred from the dump
     */
    static fromDump<const D extends LikeC4ModelDump>(dump: D): LikeC4Model<AuxFromDump<D>>;
    readonly deployment: LikeC4DeploymentModel<A>;
    readonly $data: $ModelData<A>;
    constructor($data: $ModelData<A>);
    /**
     * Type narrows the model to the parsed stage.
     * This is useful for tests
     */
    get asParsed(): LikeC4Model.Parsed<A>;
    /**
     * Type narrows the model to the layouted stage.
     * This is useful for tests
     */
    get asComputed(): LikeC4Model.Computed<A>;
    /**
     * Type narrows the model to the layouted stage.
     * This is useful for tests
     */
    get asLayouted(): LikeC4Model.Layouted<A>;
    /**
     * Returns the styles configuration for the project.
     */
    get $styles(): LikeC4Styles;
    /**
     * Type guard the model to the parsed stage.
     */
    isParsed(this: LikeC4Model<any>): this is LikeC4Model.Parsed<A>;
    /**
     * Type guard the model to the layouted stage.
     */
    isLayouted(this: LikeC4Model<any>): this is LikeC4Model.Layouted<A>;
    /**
     * Type guard the model to the computed stage.
     */
    isComputed(this: LikeC4Model<any>): this is LikeC4Model.Computed<A>;
    /**
     * Keeping here for backward compatibility
     * @deprecated use {@link $data}
     */
    get $model(): $ModelData<A>;
    get stage(): Stage<A>;
    /**
     * Returns the Project ID associated with the model.
     * If the project ID is not defined in the model, it returns "default".
     */
    get projectId(): ProjectId$1<A>;
    /**
     * Returns the project associated with the model.
     * If the project is not defined in the model, it returns a default project with the ID "default".
     */
    get project(): LikeC4Project;
    get specification(): Specification<A>;
    get globals(): ModelGlobals<A>;
    /**
     * Returns the element with the given FQN.
     *
     * @throws Error if element is not found\
     * Use {@link findElement} if you don't want to throw an error
     *
     * @note Method is type-safe for typed model
  
     * @example
     * model.element('cloud.frontend')
     * // or object with id property of scalar.Fqn
     * model.element({
     *   id: 'dashboard',
     * })
     */
    element(el: ElementId<A> | {
        id: Fqn<A>;
    }): ElementModel<A>;
    /**
     * Returns the element with the given FQN.
     *
     * @returns Element if found, null otherwise
     * @note Method is not type-safe as {@link element}
     *
     * @example
     * model.findElement('cloud.frontend')
     */
    findElement(el: LooseElementId<A>): ElementModel<A> | null;
    /**
     * Returns the root elements of the model.
     */
    roots(): ElementsIterator<A>;
    /**
     * Returns all elements in the model.
     */
    elements(): ElementsIterator<A>;
    /**
     * Returns all relationships in the model.
     */
    relationships(): RelationshipsIterator<A>;
    /**
     * Returns a specific relationship by its ID.
     * If the relationship is not found in the model, it will be searched in the deployment model.
     * Search can be limited to the model or deployment model only.
     */
    relationship(rel: RelationOrId, type: 'model'): RelationshipModel<A>;
    relationship(rel: RelationOrId, type: 'deployment'): DeploymentRelationModel<A>;
    relationship(rel: RelationId, type?: 'model' | 'deployment'): RelationshipModel<A> | DeploymentRelationModel<A>;
    findRelationship(id: string, type: 'model'): RelationshipModel<A> | null;
    findRelationship(id: string, type: 'deployment'): DeploymentRelationModel<A> | null;
    findRelationship(id: string, type?: 'model' | 'deployment'): RelationshipModel<A> | DeploymentRelationModel<A> | null;
    /**
     * Returns all views in the model.
     */
    views(): IteratorLike<LikeC4ViewModel<A, $View<A>>>;
    /**
     * Returns a specific view by its ID.
     * @note Method is type-safe for typed model
     * @throws Error if view is not found\
     * Use {@link findView} if you don't want to throw an error
     *
     * @example
     * model.view('index')
     * // or object with id property of scalar.ViewId
     * model.view({
     *   id: 'index',
     * })
     */
    view(viewId: ViewId<A> | {
        id: ViewId$1<ViewId<A>>;
    }): $ViewModel<A>;
    /**
     * Returns a specific view by its ID.
     * @note Method is not type-safe as {@link view}
     *
     * @example
     * model.findView('index')
     */
    findView(viewId: LooseViewId<A>): $ViewModel<A> | null;
    /**
     * Returns manual layout snapshot for given view ID, if any.
     */
    findManualLayout(viewId: LooseViewId<A>): ViewManualLayoutSnapshot | null;
    /**
     * Returns a view folder by its path.
     * Path is extracted from the view title, e.g. "Group 1/Group 2/View" -> "Group 1/Group 2"
     * @throws Error if view folder is not found.
     */
    viewFolder(path: string): LikeC4ViewsFolder<A>;
    /**
     * Root folder is a special one with an empty path and used only for internal purposes.
     * It is not visible to the user and should be used only to get top-level folders and views.
     */
    get rootViewFolder(): LikeC4ViewsFolder<A>;
    /**
     * Whether the model has any view folders.
     */
    get hasViewFolders(): boolean;
    /**
     * Returns all children of a view folder.
     * Path is extracted from the view title, e.g. "Group 1/Group 2/View" -> "Group 1/Group 2"
     *
     * @throws Error if view folder is not found.
     */
    viewFolderItems(path: string): ReadonlySet<LikeC4ViewsFolder<A> | LikeC4ViewModel<A>>;
    /**
     * Returns the parent element of given element.
     * @see ancestors
     */
    parent(element: ElementOrFqn<A>): ElementModel<A> | null;
    /**
     * Get all children of the element (only direct children),
     * @see descendants
     */
    children(element: ElementOrFqn<A>): ReadonlySet<ElementModel<A>>;
    /**
     * Get all sibling (i.e. same parent)
     */
    siblings(element: ElementOrFqn<A>): ElementsIterator<A>;
    /**
     * Get all ancestor elements (i.e. parent, parent’s parent, etc.)
     * (from closest to root)
     */
    ancestors(element: ElementOrFqn<A>): ElementsIterator<A>;
    /**
     * Get all descendant elements (i.e. children, children’s children, etc.)
     */
    descendants(element: ElementOrFqn<A>): ElementsIterator<A>;
    /**
     * Incoming relationships to the element and its descendants
     * @see incomers
     */
    incoming(element: ElementOrFqn<A>, filter?: IncomingFilter): RelationshipsIterator<A>;
    /**
     * Outgoing relationships from the element and its descendants
     * @see outgoers
     */
    outgoing(element: ElementOrFqn<A>, filter?: OutgoingFilter): RelationshipsIterator<A>;
    /**
     * Returns array of all tags used in the model, sorted naturally.\
     * Use {@link specification.tags} to get all defined tags
     */
    get tags(): Tags<A>;
    /**
     * Returns all tags used in the model, sorted by usage count (descending).
     */
    get tagsSortedByUsage(): ReadonlyArray<{
        tag: Tag<A>;
        count: number;
        tagged: ReadonlySet<ElementModel<A> | RelationshipModel<A> | LikeC4ViewModel<A>>;
    }>;
    /**
     * Returns all elements, relationships and views marked with the given tag.
     */
    findByTag(tag: Tag<A>): IteratorLike<ElementModel<A> | RelationshipModel<A> | LikeC4ViewModel<A>>;
    findByTag(tag: Tag<A>, type: 'elements'): IteratorLike<ElementModel<A>>;
    findByTag(tag: Tag<A>, type: 'views'): IteratorLike<LikeC4ViewModel<A>>;
    findByTag(tag: Tag<A>, type: 'relationships'): IteratorLike<RelationshipModel<A>>;
    /**
     * Returns all elements of the given kind.
     */
    elementsOfKind(kind: ElementKind<A>): IteratorLike<ElementModel<A>>;
    /**
     * Returns all elements that match the given where operator.
     *
     * @example
     * ```ts
     * model.where({
     *   and: [
     *     { kind: 'component' },
     *     {
     *       or: [
     *         { tag: 'old' },
     *         { tag: { neq: 'new' } },
     *       ],
     *     },
     *   ],
     * })
     * ```
     */
    elementsWhere(where: WhereOperator<A>): IteratorLike<ElementModel<A>>;
    /**
     * Returns all **model** relationships that match the given where operator.
     *
     * @example
     * ```ts
     * model.relationshipsWhere({
     *   and: [
     *     { kind: 'uses' },
     *     {
     *       or: [
     *         { tag: 'old' },
     *         { tag: { neq: 'new' } },
     *       ],
     *     },
     *   ],
     * })
     * ```
     */
    relationshipsWhere(where: WhereOperator<A>): IteratorLike<RelationshipModel<A>>;
    private addElement;
    private addImportedElement;
    private addRelation;
}
declare namespace LikeC4Model {
    const EMPTY: LikeC4Model<Unknown>;
    type Parsed<A = unknown> = IsAny<A> extends true ? LikeC4Model<AnyParsed> : A extends Aux<any, infer E, infer D, infer V, infer PID, infer Spec> ? LikeC4Model<Aux<'parsed', E, D, V, PID, Spec>> : LikeC4Model<UnknownParsed>;
    type Computed<A = unknown> = IsAny<A> extends true ? LikeC4Model<AnyComputed> : A extends Aux<any, infer E, infer D, infer V, infer PID, infer Spec> ? LikeC4Model<Aux<'computed', E, D, V, PID, Spec>> : LikeC4Model<UnknownComputed>;
    type Layouted<A = unknown> = IsAny<A> extends true ? LikeC4Model<AnyLayouted> : A extends Aux<any, infer E, infer D, infer V, infer PID, infer Spec> ? LikeC4Model<Aux<'layouted', E, D, V, PID, Spec>> : LikeC4Model<UnknownLayouted>;
    type Node<A = Any> = A extends Any ? NodeModel<A> : never;
    type Element<A = Any> = A extends Any ? ElementModel<A> : never;
    type Relationship<A = Any> = A extends Any ? RelationshipModel<A> : never;
    type View<A = Any> = A extends Any ? $ViewModel<A> : never;
    type DeploymentNode<A = Any> = A extends Any ? DeploymentNodeModel<A> : never;
    type DeploymentRelation<A = Any> = A extends Any ? DeploymentRelationModel<A> : never;
    type DeployedInstance<A = Any> = A extends Any ? DeployedInstanceModel<A> : never;
    type AnyRelation<M = Any> = M extends Any ? RelationshipModel<M> | DeploymentRelationModel<M> : never;
}

export { type AnyRelationshipModel as A, DeploymentNodeModel as D, ElementModel as E, type IncomingFilter as I, LikeC4ViewModel as L, NestedElementOfDeployedInstanceModel as N, type OutgoingFilter as O, RelationshipModel as R, type WithMetadata as W, DeployedInstanceModel as a, DeploymentRelationModel as b, NodeModel as c, EdgeModel as d, type DeploymentElementModel as e, LikeC4Model as f, type AnyLikeC4Model as g, RelationshipsAccum as h, type DeploymentRelationEndpoint as i, LikeC4DeploymentModel as j, LikeC4ViewsFolder as k, type DeploymentOrFqn as l, type EdgeOrId as m, type ElementOrFqn as n, type NodeOrId as o, type WithTags as p };
