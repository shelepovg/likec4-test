import { C as Connection, c as customInspectSymbol } from './core.DKhRkHRN.mjs';
import { E as ElementModel, R as RelationshipModel } from './core.BfCKSW-g.mjs';
import { A as Any, U as Unknown, z as EdgeId } from './core.D00YbOhQ.mjs';

/**
 * Connection refers to any relationships between two elements,
 * both direct and implicit ones (between their nested elements).
 *
 * Merges relationships together to an single edge on the diagram.
 */
declare class ConnectionModel<A extends Any = Unknown> implements Connection<ElementModel<A>, EdgeId> {
    readonly source: ElementModel<A>;
    readonly target: ElementModel<A>;
    readonly relations: ReadonlySet<RelationshipModel<A>>;
    readonly id: EdgeId;
    constructor(source: ElementModel<A>, target: ElementModel<A>, relations?: ReadonlySet<RelationshipModel<A>>);
    private _boundary;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    get boundary(): ElementModel<A> | null;
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    get expression(): string;
    /**
     * Returns true if only includes relations between the source and target elements.
     */
    get isDirect(): boolean;
    /**
     * Returns true if includes relations between nested elements of the source and target elements.
     */
    get isImplicit(): boolean;
    get directRelations(): ReadonlySet<RelationshipModel<A>>;
    nonEmpty(): boolean;
    mergeWith(other: ConnectionModel<A>): ConnectionModel<A>;
    difference(other: ConnectionModel<A>): ConnectionModel<A>;
    intersect(other: ConnectionModel<A>): ConnectionModel<A>;
    equals(other: Connection): boolean;
    /**
     * Returns a new instance with the updated relations.
     *
     * @param relations - A readonly set of `RelationshipModel` instances representing the new relations.
     * @returns A new `ConnectionModel` instance with the updated relations.
     */
    update(relations: ReadonlySet<RelationshipModel<A>>): ConnectionModel<A>;
    [customInspectSymbol](_depth: any, _inspectOptions: any, _inspect: any): string;
    toString(): string;
    /**
     * Creates a new connection with reversed direction (target becomes source and vice versa)
     * @param search - When true, attempts to find an existing connection between the reversed nodes
     */
    reversed(search?: boolean): ConnectionModel<A>;
}

/**
 * Resolve connection from source to target
 *
 * @param direction - if 'both', also returns connection from target to source
 * @default `directed`
 */
declare function findConnection<A extends Any>(source: ElementModel<A>, target: ElementModel<A>, direction?: 'directed' | 'both'): [ConnectionModel<A>, ConnectionModel<A>] | [ConnectionModel<A>] | [];
/**
 * Resolve all connections between element and others
 * @param direction - if 'directed', only look for outgoing connections from the element to others
 * @default `both`
 */
declare function findConnectionsBetween<M extends Any>(element: ElementModel<M>, others: Iterable<ElementModel<M>>, direction?: 'directed' | 'both'): readonly ConnectionModel<M>[];
/**
 * Resolve all connections within a given set of elements
 */
declare function findConnectionsWithin<M extends Any>(elements: Iterable<ElementModel<M>>): readonly ConnectionModel<M>[];

declare const find_findConnection: typeof findConnection;
declare const find_findConnectionsBetween: typeof findConnectionsBetween;
declare const find_findConnectionsWithin: typeof findConnectionsWithin;
declare namespace find {
  export { find_findConnection as findConnection, find_findConnectionsBetween as findConnectionsBetween, find_findConnectionsWithin as findConnectionsWithin };
}

export { ConnectionModel as C, findConnection as a, findConnectionsBetween as b, findConnectionsWithin as c, find as f };
