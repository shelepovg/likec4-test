import { IfNever, IsNever, IsLiteral } from 'type-fest';
import { C as Coalesce, L as Link } from './core.DB0Ue5Wx.mjs';
import { V as ViewId$1, F as Fqn$1, D as DeploymentFqn$1, j as NodeId$1, k as EdgeId$1, d as RelationId$1, P as ProjectId$1, T as Tag$1, E as ElementKind$1, b as DeploymentKind$1, c as RelationshipKind, M as MarkdownOrString } from './core.C_3y3eqV.mjs';

/**
 * Determines the stage of the model:
 * 1. `parsed` - parsed from DSL or returned from Builder
 * 2. `computed` - views are computed
 * 3. `layouted` - views are layouted
 *
 * @internal
 */
type ModelStage = 'parsed' | 'computed' | 'layouted';
type ExtractOnStage<T, S extends ModelStage> = Extract<T, {
    [_stage]: S;
}>;
declare function isOnStage<T extends {
    [_stage]: ModelStage;
}, S extends ModelStage>(value: T, stage: S): value is ExtractOnStage<T, S>;
/**
 * Property name to store the stage of the model
 *
 * @internal
 */
declare const _stage = "_stage";
type _stage = typeof _stage;
/**
 * Property name to store type information, used to identify the type of the view
 *
 * @internal
 */
declare const _type = "_type";
type _type = typeof _type;
/**
 * Property name to store layout type information, used to identify the type of the layout*
 * @internal
 */
declare const _layout = "_layout";
type _layout = typeof _layout;

/**
 * Specification types (kinds, tags, metadata keys)
 *
 * @param ElementKind - Literal union of element kinds
 * @param DeploymentKind - Literal union of deployment kinds
 * @param RelationKind - Literal union of relationship kinds
 * @param Tag - Literal union of tags
 * @param MetadataKey - Literal union of metadata keys
 */
interface SpecAux<ElementKind extends string, DeploymentKind extends string, RelationKind extends string, Tag extends string, MetadataKey extends string> {
    ElementKind: ElementKind;
    DeploymentKind: DeploymentKind;
    RelationKind: RelationKind;
    Tag: Tag;
    MetadataKey: MetadataKey;
}
type AnySpec = SpecAux<any, any, any, any, any>;
/**
 * Auxilary interface to keep inferred types
 *
 * @typeParam Stage - View stage
 * @typeParam Element - Literal union of FQNs of model elements
 * @typeParam Deployment - Literal union of FQNs of deployment elements
 * @typeParam View - Literal union of view identifiers
 * @typeParam Project - Project identifier type
 * @typeParam Spec - Specification types (kinds, tags, metadata keys)
 */
interface Aux<Stage extends ModelStage, Element extends string, Deployment extends string, View extends string, Project extends string, Spec extends AnySpec> {
    Stage: Stage;
    ProjectId: Project;
    ElementId: Element;
    DeploymentId: Deployment;
    ViewId: View;
    ElementKind: Spec['ElementKind'];
    DeploymentKind: Spec['DeploymentKind'];
    RelationKind: Spec['RelationKind'];
    Tag: Spec['Tag'];
    MetadataKey: Spec['MetadataKey'];
}
type AnyOnStage<Stage extends ModelStage> = Aux<Stage, any, any, any, any, any>;
type AnyParsed = AnyOnStage<'parsed'>;
type AnyComputed = AnyOnStage<'computed'>;
type AnyLayouted = AnyOnStage<'layouted'>;
type Any = Aux<any, any, any, any, any, any>;

type Never = Aux<never, never, never, never, never, SpecAux<never, never, never, never, never>>;
/**
 * Fallback when {@link Aux} can't be inferred.
 * By default assumes non parsed model
 */
type Unknown = UnknownComputed | UnknownLayouted;
type UnknownParsed = Aux<'parsed', string, string, string, string, SpecAux<string, string, string, string, string>>;
type UnknownComputed = Aux<'computed', string, string, string, string, SpecAux<string, string, string, string, string>>;
type UnknownLayouted = Aux<'layouted', string, string, string, string, SpecAux<string, string, string, string, string>>;
/**
 * Reads stage from Aux
 */
type Stage<A> = A extends Aux<infer S, any, any, any, any, any> ? IfNever<S, never, Coalesce<S, ModelStage>> : never;
/**
 * Picks type based on stage from Aux
 */
type PickByStage<A extends Any, OnParsed, OnComputed, OnLayouted = OnComputed> = {
    parsed: OnParsed;
    computed: OnComputed;
    layouted: OnLayouted;
}[A['Stage']];
type setStage<A, S extends ModelStage> = A extends Aux<any, infer E, infer D, infer V, infer P, infer Spec> ? Aux<S, E, D, V, P, Spec> : never;
type toParsed<A> = A extends Aux<any, infer E, infer D, infer V, infer P, infer Spec> ? Aux<'parsed', E, D, V, P, Spec> : never;
type toComputed<A> = A extends Aux<any, infer E, infer D, infer V, infer P, infer Spec> ? Aux<'computed', E, D, V, P, Spec> : never;
type toLayouted<A> = A extends Aux<any, infer E, infer D, infer V, infer P, infer Spec> ? Aux<'layouted', E, D, V, P, Spec> : never;
/**
 * Project identifier from Aux
 */
type ProjectId<A> = A extends Aux<any, any, any, any, infer P, any> ? Coalesce<P> : never;
type setProject<A, P extends string> = A extends Aux<infer S, infer E, infer D, infer V, any, infer Spec> ? Aux<S, E, D, V, P, Spec> : never;
/**
 * Element FQN from Aux as branded type
 */
type Fqn<A> = A extends Any ? Fqn$1<ElementId<A>> : never;
/**
 * Element FQN from Aux as a literal union
 */
type ElementId<A> = A extends Any ? Coalesce<A['ElementId']> : never;
/**
 * Deployment FQN from Aux as branded type
 */
type DeploymentFqn<A> = A extends Any ? DeploymentFqn$1<DeploymentId<A>> : never;
/**
 * Deployment FQN from Aux as a literal union
 * @alias {@link DeploymentFqn}
 */
type DeploymentId<A> = A extends Any ? Coalesce<A['DeploymentId']> : never;
/**
 * View identifier from Aux as a literal union
 */
type ViewId<A> = A extends Any ? Coalesce<A['ViewId']> : never;
type RelationId = RelationId$1;
type NodeId = NodeId$1;
type EdgeId = EdgeId$1;
/**
 * ElementKind from Aux as a literal union
 */
type ElementKind<A> = A extends Any ? Coalesce<A['ElementKind']> : never;
/**
 * DeploymentKind from Aux as a literal union
 */
type DeploymentKind<A> = A extends Any ? Coalesce<A['DeploymentKind']> : never;
/**
 * RelationKind from Aux as a literal union
 */
type RelationKind<A> = A extends Any ? Coalesce<A['RelationKind']> : never;
/**
 * Tags from Aux as a literal union
 */
type Tag<A> = A extends Any ? Coalesce<A['Tag']> : never;
/**
 * Array of tags from Aux
 */
type Tags<A extends Any> = readonly Tag<A>[];
/**
 * Metadata key from Aux
 */
type MetadataKey<A> = A extends Any ? Coalesce<A['MetadataKey']> : never;
/**
 * Metadata object from Aux
 */
type Metadata<A extends Any> = IsNever<A['MetadataKey']> extends true ? never : IsLiteral<A['MetadataKey']> extends true ? {
    [key in A['MetadataKey']]?: string | string[];
} : Record<string, string | string[]>;
/**
 * All known kinds from Aux as a literal union.
 */
type AllKinds<A> = ElementKind<A> | DeploymentKind<A> | RelationKind<A>;
/**
 * Specification from Aux
 */
type Spec<A> = A extends Aux<any, any, any, any, any, SpecAux<infer E, infer D, infer R, infer T, infer M>> ? SpecAux<E, D, R, T, M> : never;
type StrictProjectId<A> = A extends infer T extends Any ? ProjectId$1<ProjectId<T>> : never;

type StrictViewId<A> = A extends infer T extends Any ? ViewId$1<ViewId<T>> : never;
type StrictTag<A> = A extends infer T extends Any ? Tag$1<Tag<T>> : never;
type StrictElementKind<A> = A extends infer T extends Any ? ElementKind$1<ElementKind<T>> : never;
type StrictDeploymentKind<A> = A extends infer T extends Any ? DeploymentKind$1<DeploymentKind<T>> : never;
type StrictRelationKind<A> = A extends infer T extends Any ? RelationshipKind<RelationKind<T>> : never;
type WithDescriptionAndTech = {
    readonly summary?: MarkdownOrString | null;
    readonly description?: MarkdownOrString | null;
    readonly technology?: string | null;
};
/**
 * Returns summary if it is not null, otherwise returns description
 */
declare function preferSummary(a: WithDescriptionAndTech): MarkdownOrString | null | undefined;
/**
 * Returns description if it is not null, otherwise returns summary
 */
declare function preferDescription(a: WithDescriptionAndTech): MarkdownOrString | null | undefined;
type WithTags<A extends Any> = {
    readonly tags: Tags<A>;
};
type WithOptionalTags<A extends Any> = {
    readonly tags?: Tags<A> | null;
};
type WithLinks = {
    readonly links: readonly Link[];
};
type WithOptionalLinks = {
    readonly links?: readonly Link[] | null;
};
type WithMetadata<A extends Any> = {
    readonly metadata?: Metadata<A>;
};
type WithNotation = {
    readonly notation?: string | null;
};
/**
 * @see {@link LiteralUnion} from type-fest (https://github.com/sindresorhus/type-fest/blob/main/source/literal-union.d.ts)
 */
type OrString = string & Record<never, never>;
/**
 * Allows any string value, but still auto-completes to the possible values in IDE
 */
type LooseLiteral<V extends string> = Coalesce<V> | OrString;
type LooseElementId<A> = A extends Any ? LooseLiteral<A['ElementId']> : string;
type LooseDeploymentId<A> = A extends Any ? LooseLiteral<A['DeploymentId']> : string;
type LooseViewId<A> = A extends Any ? LooseLiteral<A['ViewId']> : string;
type LooseTag<A> = A extends Any ? LooseLiteral<A['Tag']> : string;
type LooseTags<A> = A extends Any ? readonly (LooseLiteral<A['Tag']>)[] : string[];
type LooseElementKind<A> = A extends Any ? LooseLiteral<A['ElementKind']> : string;
type LooseDeploymentKind<A> = A extends Any ? LooseLiteral<A['DeploymentKind']> : string;
type LooseRelationKind<A> = A extends Any ? LooseLiteral<A['RelationKind']> : string;

type _aux_AllKinds<A> = AllKinds<A>;
type _aux_Any = Any;
type _aux_AnyComputed = AnyComputed;
type _aux_AnyLayouted = AnyLayouted;
type _aux_AnyOnStage<Stage extends ModelStage> = AnyOnStage<Stage>;
type _aux_AnyParsed = AnyParsed;
type _aux_AnySpec = AnySpec;
type _aux_Aux<Stage extends ModelStage, Element extends string, Deployment extends string, View extends string, Project extends string, Spec extends AnySpec> = Aux<Stage, Element, Deployment, View, Project, Spec>;
type _aux_DeploymentFqn<A> = DeploymentFqn<A>;
type _aux_DeploymentId<A> = DeploymentId<A>;
type _aux_DeploymentKind<A> = DeploymentKind<A>;
type _aux_EdgeId = EdgeId;
type _aux_ElementId<A> = ElementId<A>;
type _aux_ElementKind<A> = ElementKind<A>;
type _aux_Fqn<A> = Fqn<A>;
type _aux_LooseDeploymentId<A> = LooseDeploymentId<A>;
type _aux_LooseDeploymentKind<A> = LooseDeploymentKind<A>;
type _aux_LooseElementId<A> = LooseElementId<A>;
type _aux_LooseElementKind<A> = LooseElementKind<A>;
type _aux_LooseLiteral<V extends string> = LooseLiteral<V>;
type _aux_LooseRelationKind<A> = LooseRelationKind<A>;
type _aux_LooseTag<A> = LooseTag<A>;
type _aux_LooseTags<A> = LooseTags<A>;
type _aux_LooseViewId<A> = LooseViewId<A>;
type _aux_Metadata<A extends Any> = Metadata<A>;
type _aux_MetadataKey<A> = MetadataKey<A>;
type _aux_Never = Never;
type _aux_NodeId = NodeId;
type _aux_OrString = OrString;
type _aux_PickByStage<A extends Any, OnParsed, OnComputed, OnLayouted = OnComputed> = PickByStage<A, OnParsed, OnComputed, OnLayouted>;
type _aux_ProjectId<A> = ProjectId<A>;
type _aux_RelationId = RelationId;
type _aux_RelationKind<A> = RelationKind<A>;
type _aux_Spec<A> = Spec<A>;
type _aux_SpecAux<ElementKind extends string, DeploymentKind extends string, RelationKind extends string, Tag extends string, MetadataKey extends string> = SpecAux<ElementKind, DeploymentKind, RelationKind, Tag, MetadataKey>;
type _aux_Stage<A> = Stage<A>;
type _aux_StrictDeploymentKind<A> = StrictDeploymentKind<A>;
type _aux_StrictElementKind<A> = StrictElementKind<A>;
type _aux_StrictProjectId<A> = StrictProjectId<A>;
type _aux_StrictRelationKind<A> = StrictRelationKind<A>;
type _aux_StrictTag<A> = StrictTag<A>;
type _aux_StrictViewId<A> = StrictViewId<A>;
type _aux_Tag<A> = Tag<A>;
type _aux_Tags<A extends Any> = Tags<A>;
type _aux_Unknown = Unknown;
type _aux_UnknownComputed = UnknownComputed;
type _aux_UnknownLayouted = UnknownLayouted;
type _aux_UnknownParsed = UnknownParsed;
type _aux_ViewId<A> = ViewId<A>;
type _aux_WithDescriptionAndTech = WithDescriptionAndTech;
type _aux_WithLinks = WithLinks;
type _aux_WithMetadata<A extends Any> = WithMetadata<A>;
type _aux_WithNotation = WithNotation;
type _aux_WithOptionalLinks = WithOptionalLinks;
type _aux_WithOptionalTags<A extends Any> = WithOptionalTags<A>;
type _aux_WithTags<A extends Any> = WithTags<A>;
declare const _aux_preferDescription: typeof preferDescription;
declare const _aux_preferSummary: typeof preferSummary;
type _aux_setProject<A, P extends string> = setProject<A, P>;
type _aux_setStage<A, S extends ModelStage> = setStage<A, S>;
type _aux_toComputed<A> = toComputed<A>;
type _aux_toLayouted<A> = toLayouted<A>;
type _aux_toParsed<A> = toParsed<A>;
declare namespace _aux {
  export { type _aux_AllKinds as AllKinds, type _aux_Any as Any, type Any as AnyAux, type _aux_AnyComputed as AnyComputed, type _aux_AnyLayouted as AnyLayouted, type _aux_AnyOnStage as AnyOnStage, type _aux_AnyParsed as AnyParsed, type _aux_AnySpec as AnySpec, type _aux_Aux as Aux, type _aux_DeploymentFqn as DeploymentFqn, type _aux_DeploymentId as DeploymentId, type _aux_DeploymentKind as DeploymentKind, type _aux_EdgeId as EdgeId, type _aux_ElementId as ElementId, type _aux_ElementKind as ElementKind, type _aux_Fqn as Fqn, type _aux_LooseDeploymentId as LooseDeploymentId, type _aux_LooseDeploymentKind as LooseDeploymentKind, type _aux_LooseElementId as LooseElementId, type _aux_LooseElementKind as LooseElementKind, type _aux_LooseLiteral as LooseLiteral, type _aux_LooseRelationKind as LooseRelationKind, type _aux_LooseTag as LooseTag, type _aux_LooseTags as LooseTags, type _aux_LooseViewId as LooseViewId, type _aux_Metadata as Metadata, type _aux_MetadataKey as MetadataKey, type _aux_Never as Never, type _aux_NodeId as NodeId, type _aux_OrString as OrString, type _aux_PickByStage as PickByStage, type _aux_ProjectId as ProjectId, type _aux_RelationId as RelationId, type _aux_RelationKind as RelationKind, type _aux_Spec as Spec, type _aux_SpecAux as SpecAux, type _aux_Stage as Stage, type DeploymentFqn as StrictDeploymentFqn, type _aux_StrictDeploymentKind as StrictDeploymentKind, type _aux_StrictElementKind as StrictElementKind, type Fqn as StrictFqn, type _aux_StrictProjectId as StrictProjectId, type _aux_StrictRelationKind as StrictRelationKind, type _aux_StrictTag as StrictTag, type _aux_StrictViewId as StrictViewId, type _aux_Tag as Tag, type _aux_Tags as Tags, type _aux_Unknown as Unknown, type _aux_UnknownComputed as UnknownComputed, type _aux_UnknownLayouted as UnknownLayouted, type _aux_UnknownParsed as UnknownParsed, type _aux_ViewId as ViewId, type _aux_WithDescriptionAndTech as WithDescriptionAndTech, type _aux_WithLinks as WithLinks, type _aux_WithMetadata as WithMetadata, type _aux_WithNotation as WithNotation, type _aux_WithOptionalLinks as WithOptionalLinks, type _aux_WithOptionalTags as WithOptionalTags, type _aux_WithTags as WithTags, _aux_preferDescription as preferDescription, _aux_preferSummary as preferSummary, type _aux_setProject as setProject, type _aux_setStage as setStage, type _aux_toComputed as toComputed, type _aux_toLayouted as toLayouted, type _aux_toParsed as toParsed };
}

export { type AnyOnStage as $, type Any as A, type Never as B, type MetadataKey as C, type DeploymentId as D, type ElementKind as E, type Fqn as F, type WithTags as G, type Metadata as H, type LooseTag as I, type RelationId as J, type LooseElementId as K, type LooseLiteral as L, type ModelStage as M, type NodeId as N, type LooseDeploymentId as O, type ProjectId as P, type Stage as Q, type RelationKind as R, type StrictViewId as S, type Tag as T, type Unknown as U, type ViewId as V, type WithDescriptionAndTech as W, type LooseViewId as X, type setProject as Y, type AnySpec as Z, _aux as _, type ElementId as a, type PickByStage as a0, type setStage as a1, type toParsed as a2, type toLayouted as a3, type Spec as a4, type StrictProjectId as a5, type StrictTag as a6, type StrictElementKind as a7, type StrictDeploymentKind as a8, type StrictRelationKind as a9, type WithLinks as aa, type OrString as ab, type LooseTags as ac, type LooseElementKind as ad, type LooseDeploymentKind as ae, type LooseRelationKind as af, type AnyComputed as b, type AnyLayouted as c, type AnyParsed as d, type Aux as e, type SpecAux as f, type UnknownComputed as g, type UnknownLayouted as h, type UnknownParsed as i, preferSummary as j, type ExtractOnStage as k, isOnStage as l, _stage as m, _type as n, _layout as o, preferDescription as p, type AllKinds as q, type Tags as r, type WithOptionalTags as s, type toComputed as t, type WithOptionalLinks as u, type WithMetadata as v, type WithNotation as w, type DeploymentFqn as x, type DeploymentKind as y, type EdgeId as z };
