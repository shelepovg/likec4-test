import { a as t } from '../shared/core.BsSXS-_R.mjs';
import { i as invariant } from '../shared/core.D4npX2q8.mjs';

var BBox;
((BBox2) => {
  function center({ x, y, width, height }) {
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  }
  BBox2.center = center;
  function toPoints({ x, y, width, height }) {
    return [
      { x, y },
      // Top left
      { x: x + width, y },
      // Top right
      { x: x + width, y: y + height },
      // Bottom right
      { x, y: y + height }
      // Bottom left
    ];
  }
  BBox2.toPoints = toPoints;
  function fromPoints(points) {
    const { x1, y1, x2, y2 } = RectBox.fromPoints(points);
    return {
      x: x1,
      y: y1,
      width: x2 - x1,
      height: y2 - y1
    };
  }
  BBox2.fromPoints = fromPoints;
  function merge(...boxes) {
    invariant(t(boxes, 1), "No boxes provided");
    if (boxes.length === 1) {
      return boxes[0];
    }
    let minX = boxes[0].x;
    let minY = boxes[0].y;
    let maxX = boxes[0].x + boxes[0].width;
    let maxY = boxes[0].y + boxes[0].height;
    for (let i = 1; i < boxes.length; i++) {
      const box = boxes[i];
      minX = Math.min(minX, box.x);
      minY = Math.min(minY, box.y);
      maxX = Math.max(maxX, box.x + box.width);
      maxY = Math.max(maxY, box.y + box.height);
    }
    return {
      x: Math.floor(minX),
      y: Math.floor(minY),
      width: Math.round(maxX - minX),
      height: Math.round(maxY - minY)
    };
  }
  BBox2.merge = merge;
  function fromRectBox(rect) {
    return {
      x: Math.min(rect.x1, rect.x2),
      y: Math.min(rect.y1, rect.y2),
      width: Math.abs(rect.x2 - rect.x1),
      height: Math.abs(rect.y2 - rect.y1)
    };
  }
  BBox2.fromRectBox = fromRectBox;
  function toRectBox(box) {
    return {
      x1: box.x,
      y1: box.y,
      x2: box.x + box.width,
      y2: box.y + box.height
    };
  }
  BBox2.toRectBox = toRectBox;
  function expand(box, plus) {
    if (plus === 0) {
      return box;
    }
    return {
      x: box.x - plus,
      y: box.y - plus,
      width: box.width + plus * 2,
      height: box.height + plus * 2
    };
  }
  BBox2.expand = expand;
  function shrink(box, minus) {
    if (minus === 0) {
      return box;
    }
    return {
      x: box.x + minus,
      y: box.y + minus,
      width: box.width - minus * 2,
      height: box.height - minus * 2
    };
  }
  BBox2.shrink = shrink;
  function includes(a, b) {
    if (a === b) {
      return true;
    }
    return a.x <= b.x && a.y <= b.y && a.x + a.width >= b.x + b.width && a.y + a.height >= b.y + b.height;
  }
  BBox2.includes = includes;
})(BBox || (BBox = {}));
var RectBox;
((RectBox2) => {
  function center({ x1, y1, x2, y2 }) {
    return {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    };
  }
  RectBox2.center = center;
  function fromPoints(points) {
    invariant(points.length > 0, "At least one point is required");
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const [x, y] of points) {
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }
    return {
      x1: minX,
      y1: minY,
      x2: maxX,
      y2: maxY
    };
  }
  RectBox2.fromPoints = fromPoints;
  function merge(...boxes) {
    invariant(boxes.length > 0, "No boxes provided");
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const box of boxes) {
      minX = Math.min(minX, box.x1);
      minY = Math.min(minY, box.y1);
      maxX = Math.max(maxX, box.x2);
      maxY = Math.max(maxY, box.y2);
    }
    return {
      x1: minX,
      y1: minY,
      x2: maxX,
      y2: maxY
    };
  }
  RectBox2.merge = merge;
  function toBBox(box) {
    return {
      x: box.x1,
      y: box.y1,
      width: box.x2 - box.x1,
      height: box.y2 - box.y1
    };
  }
  RectBox2.toBBox = toBBox;
  function includes(a, b) {
    if (a === b) {
      return true;
    }
    return a.x1 <= b.x1 && a.y1 <= b.y1 && a.x2 >= b.x2 && a.y2 >= b.y2;
  }
  RectBox2.includes = includes;
})(RectBox || (RectBox = {}));

class Vector {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  static create(...args) {
    if (args.length === 2) {
      return new Vector(args[0], args[1]);
    }
    return new Vector(args[0].x, args[0].y);
  }
  /**
   * Adds two vectors.
   * @param a The first vector.
   * @param b The second vector.
   * @returns The sum of the two vectors.
   */
  static add(a, b) {
    return { x: a.x + b.x, y: a.y + b.y };
  }
  /**
   * Subtracts two vectors.
   * @param a The first vector.
   * @param b The second vector.
   * @returns The difference of the two vectors.
   */
  static subtract(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
  }
  /**
   * Multiplies a vector by a scalar.
   * @param a The vector.
   * @param b The scalar.
   * @returns The scaled vector.
   */
  static multiply(a, b) {
    return { x: a.x * b, y: a.y * b };
  }
  /**
   * Divides a vector by a scalar.
   * @param a The vector.
   * @param b The scalar.
   * @returns The scaled vector.
   */
  static divide(a, b) {
    return { x: a.x / b, y: a.y / b };
  }
  /**
   * Calculates the dot product of the vectors.
   * @param a The first vector.
   * @param b The second vector.
   * @returns The dot product.
   */
  static dot(a, b) {
    return a.x * b.x + a.y * b.y;
  }
  /**
   * Adds the given vector to this vector.
   * @param b The vector to add.
   * @returns A new vector that is the sum of this vector and the given vector.
   */
  add(b) {
    return new Vector(this.x + b.x, this.y + b.y);
  }
  /**
   * Subtracts the given vector from this vector.
   * @param b The vector to subtract.
   * @returns A new vector that is the difference of this vector and the given vector.
   */
  subtract(b) {
    return new Vector(this.x - b.x, this.y - b.y);
  }
  /**
   * Multiplies this vector by a scalar.
   * @param b The scalar to multiply by.
   * @returns A new vector that is the product of this vector and the given scalar.
   */
  multiply(b) {
    return new Vector(this.x * b, this.y * b);
  }
  /**
   * Divides this vector by a scalar.
   * @param b The scalar to divide by.
   * @returns A new vector that is the quotient of this vector and the given scalar.
   */
  divide(b) {
    return new Vector(this.x / b, this.y / b);
  }
  /**
   * Calculates the dot product of this vector and another vector.
   * @param b The other vector.
   * @returns The dot product.
   */
  dot(b) {
    return this.x * b.x + this.y * b.y;
  }
  /**
   * Calculates the cross product of this vector and another vector.
   * The cross product of two 2D vectors is a scalar value: a.x * b.y - a.y * b.x
   * @param b The other vector.
   * @returns The cross product as a scalar.
   */
  cross(b) {
    return this.x * b.y - this.y * b.x;
  }
  /**
   * Calculates the length (magnitude) of this vector.
   * @returns The length of the vector.
   */
  length() {
    if (this.x === 0 && this.y === 0) {
      return 0;
    }
    return Math.sqrt(this.x ** 2 + this.y ** 2);
  }
  /**
   * Normalizes the vector (makes it unit length, i.e., has a length of 1).
   * @returns A new vector that is the normalized version of this vector.
   */
  normalize() {
    const len = this.length();
    if (len === 0) {
      return new Vector(0, 0);
    }
    return new Vector(this.x / len, this.y / len);
  }
  /**
   * Rounds the components of the vector to the nearest integers.
   * @returns A new vector with rounded components.
   */
  round() {
    return new Vector(Math.round(this.x), Math.round(this.y));
  }
  /**
   * Converts the vector to a plain object.
   * @returns An object with x and y properties.
   */
  toObject() {
    return { x: this.x, y: this.y };
  }
}
function vector(...args) {
  if (args.length === 1 && args[0] instanceof Vector) {
    return args[0];
  }
  if (args.length === 2) {
    return new Vector(args[0], args[1]);
  }
  return new Vector(args[0].x, args[0].y);
}

export { BBox, RectBox, Vector, vector };
