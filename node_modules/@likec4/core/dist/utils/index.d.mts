export { D as DefaultMap } from '../shared/core.CywrQs86.mjs';
export { B as BiMap, D as DefaultWeakMap, L as LinkedList, M as MultiMap, Q as Queue, a as ancestorsFqn, l as commonAncestor, o as compareByFqnHierarchically, q as compareFqnHierarchically, h as hasProp, r as hierarchyDistance, t as hierarchyLevel, i as invariant, b as isAncestor, v as isAnyOf, c as isDescendantOf, d as isNonEmptyArray, e as isSameHierarchy, f as isString, m as memoizeProp, n as nameFromFqn, j as nonNullable, g as nonexhaustive, p as parentFqn, u as sortByFqnHierarchically, s as sortNaturalByFqn, k as sortParentsFirst } from '../shared/core.OtRNdMxy.mjs';
import { N as NonEmptyArray } from '../shared/core.DB0Ue5Wx.mjs';
export { ifilter, ifind, ifirst, iflat, iflatMap, ihead, imap, ireduce, isome, iunique, toArray, toSet } from './iterable/index.mjs';
export { i as isIterable } from '../shared/core.DXhDWKFZ.mjs';
import '../shared/core.C_3y3eqV.mjs';
import 'type-fest';

/**
 * Mnemonist Stack Typings
 * ========================
 */
declare class Stack<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor();

  // Methods
  clear(): void;
  push(item: T): number;
  pop(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, stack: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): Stack<I>;
  static of<I>(...items: Array<I>): Stack<I>;
}

/**
 * Common head of two arrays
 *
 * @param equals - Equality function, defaults to `Object.is`
 */
declare function commonHead<T>(sources: ReadonlyArray<T>, targets: ReadonlyArray<T>, equals?: (a: T, b: T) => boolean): T[];

declare function compareNatural(a: string | undefined, b: string | undefined): -1 | 0 | 1;
/**
 * Compares two strings lexicographically first, then hierarchically based on their depth.\
 * From parent nodes to leaves
 *
 * @example
 * const lines = [
 *   'b.c',
 *   'b',
 *   'a.b.c',
 * ]
 * lines.sort(compareNaturalHierarchically('.'))
 * // [
 * //   'a.b.c',
 * //   'b',
 * //   'b.c',
 * // ]
 */
declare function compareNaturalHierarchically(separator?: string, deepestFirst?: boolean): (a: string | undefined, b: string | undefined) => number;

declare function getOrCreate<K, V>(map: Map<K, V>, key: K, create: (key: K) => V): V;
declare function getOrCreate<K extends WeakKey, V>(map: WeakMap<K, V>, key: K, create: (key: K) => V): V;

declare function delay(): Promise<string>;
declare function delay(ms: number): Promise<string>;
declare function delay(randomFrom: number, randomTo: number): Promise<string>;
declare function promiseNextTick(): Promise<void>;
declare function onNextTick(fn: () => Promise<void> | void): void;

type RelationshipLike = {
    source: {
        id: string;
    };
    target: {
        id: string;
    };
};
/**
 * Compares two relations hierarchically.
 * From the most general (implicit) to the most specific (deepest in the tree)
 */
declare const compareRelations: <T extends RelationshipLike>(a: T, b: T) => number;

/**
 * Returns new set as a union of given sets
 * Keeps order of elements
 */
declare function union<T>(...sets: ReadonlySet<T>[]): Set<T>;
/**
 * Returns new set as an intersection of all sets
 * Keeps order from the first set
 */
declare function intersection<T>(first: ReadonlySet<T>, ...sets: NonEmptyArray<ReadonlySet<NoInfer<T>>>): Set<T>;
/**
 * Returns new set as a difference of two sets (A-B)
 * Keeps order from the first set
 */
declare function difference<T>(a: ReadonlySet<T>, b: ReadonlySet<NoInfer<T>>): Set<T>;
declare function equals<T>(a: ReadonlySet<T>, b: ReadonlySet<T>): boolean;
declare function symmetricDifference<T>(a: ReadonlySet<T>, b: ReadonlySet<T>): Set<T>;

declare function objectHash(value: any): string;

/**
 * @see https://gist.github.com/victor-homyakov/bcb7d7911e4a388b1c810f8c3ce17bcf
 */
declare function stringHash(str: string): string;

declare function markdownToHtml(markdown: string): string;

/**
 * Converts markdown to plain text, removing any markdown formatting.
 * @param markdown - The markdown to convert.
 * @returns The plain text.
 */
declare function markdownToText(markdown: string): string;

export { Stack, commonHead, compareNatural, compareNaturalHierarchically, compareRelations, delay, difference, equals as equalsSet, getOrCreate, intersection, markdownToHtml, markdownToText, objectHash, onNextTick, promiseNextTick, stringHash, symmetricDifference, union };
