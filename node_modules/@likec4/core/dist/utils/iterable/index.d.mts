export { i as isIterable } from '../../shared/core.DXhDWKFZ.mjs';
import { c as IteratorLike } from '../../shared/core.DB0Ue5Wx.mjs';
import 'type-fest';

/**
 * Filters an iterable based on a predicate.
 * Composabel first version of `ifilter`.
 * @signature
 *    ifilter(predicate)(data)
 */
declare function ifilter<T, S extends T>(predicate: (v: T) => v is S): (iterable: Iterable<T>) => IteratorLike<S>;
declare function ifilter<T>(predicate: (v: T) => boolean): (iterable: Iterable<T>) => IteratorLike<T>;
/**
 * Filters an iterable based on a predicate.
 * Data first version of `ifilter`.
 * @signature
 *    ifilter(data, predicate)
 * @example
 *    ifilter(new Set([1, 2, 3]), x => x % 2 === 1) // => Iterable<[1, 3]>
 */
declare function ifilter<T, S extends T>(iterable: Iterable<T>, predicate: (v: T) => v is S): IteratorLike<S>;
declare function ifilter<T>(iterable: Iterable<T>, predicate: (v: T) => boolean): IteratorLike<T>;

/**
 * Finds the first element in the iterable that satisfies the predicate.
 * Composable first version of `find`.
 * @signature
 *   ifind(predicate)(data)
 */
declare function ifind<T, S extends T>(predicate: (item: T) => item is S): (iterable: Iterable<T>) => S | undefined;
declare function ifind<T>(predicate: (item: T) => boolean): (iterable: Iterable<T>) => T | undefined;
/**
 * Finds the first element in the iterable that satisfies the predicate.
 * Data first version of `find`.
 * @signature
 *  ifind(data, predicate)
 */
declare function ifind<T, S extends T>(iterable: Iterable<T>, predicate: (item: T) => item is S): S | undefined;
declare function ifind<T>(iterable: Iterable<T>, predicate: (item: T) => boolean): T | undefined;

/**
 * Takes the first N elements from an iterable.
 * Composable first version of `ifirst`.
 * @signature
 *   ifirst(count)(data)
 */
declare function ifirst<T>(count: number): (iterable: Iterable<T>) => IteratorLike<T>;
/**
 * Takes the first N elements from an iterable.
 * Data first version of `ifirst`.
 * @signature
 *   ifirst(data, count)
 * @example
 *   ifirst([1, 2, 3, 4, 5], 3) // => Iterable<[1, 2, 3]>
 */
declare function ifirst<T>(iterable: Iterable<T>, count: number): IteratorLike<T>;

declare function iflat(): <T>(iterable: Iterable<IteratorLike<T>>) => IteratorLike<T>;
declare function iflat<T>(iterable: Iterable<IteratorLike<T>>): IteratorLike<T>;

type FlatMapFunction<T, S> = (item: T) => Iterable<S>;
/**
 * Maps an iterable using a mapper function and flattens the result by one level.
 * Composable first version of `iflatMap`.
 * @signature
 *   iflatMap(mapper)(data)
 */
declare function iflatMap<T, S>(mapper: FlatMapFunction<T, S>): (iterable: Iterable<T>) => IteratorLike<S>;
/**
 * Maps an iterable using a mapper function and flattens the result by one level.
 * Data first version of `iflatMap`.
 * @signature
 *   iflatMap(data, mapper)
 */
declare function iflatMap<T, S>(iterable: Iterable<T>, mapper: FlatMapFunction<T, S>): IteratorLike<S>;

declare function ihead<T>(): (iterable: Iterable<T>) => T | undefined;
/**
 * Finds the first element in the iterable that satisfies the predicate.
 * Data first version of `find`.
 * @signature
 *  ifind(data, predicate)
 */
declare function ihead<T>(iterable: Iterable<T>): T | undefined;

type MapFunction<T, S> = (item: T) => S;
/**
 * Maps an iterable using a mapper function.
 * Composable first version of `imap`.
 * @signature
 *   imap(mapper)(data)
 */
declare function imap<T, S>(mapper: MapFunction<T, S>): (iterable: Iterable<T>) => IteratorLike<S>;
/**
 * Maps an iterable using a mapper function.
 * Data first version of `imap`.
 * @signature
 *   imap(data, mapper)
 */
declare function imap<T, S>(iterable: Iterable<T>, mapper: MapFunction<T, S>): IteratorLike<S>;

declare function ireduce<T, R>(reducer: (acc: R, item: T) => R, initialValue: R): (iterable: Iterable<T>) => R;
declare function ireduce<T, R>(iterable: Iterable<T>, reducer: (acc: R, item: T) => R, initialValue: R): R;

/**
 * Checks if at least one element in the iterable satisfies the predicate.
 * Composable first version of `some`.
 * @signature
 *   isome(predicate)(data)
 */
declare function isome<T>(predicate: (item: T) => boolean): (iterable: Iterable<T>) => boolean;
/**
 * Checks if at least one element in the iterable satisfies the predicate.
 * Data first version of `some`.
 * @signature
 *  isome(data, predicate)
 */
declare function isome<T>(iterable: Iterable<T>, predicate: (item: T) => boolean): boolean;

declare function toArray(): <T>(iterable: Iterable<T> | ArrayLike<T>) => T[];
declare function toArray<T>(iterable: Iterable<T> | ArrayLike<T>): T[];
declare function toSet(): <T>(iterable: Iterable<T>) => Set<T>;
declare function toSet<T>(iterable: Iterable<T>): Set<T>;

/**
 * Returns an iterable that yields only unique values.
 * It uses a Set to keep track of the values.
 */
declare function iunique(): <T>(iterable: Iterable<T>) => IteratorLike<T>;
declare function iunique<T>(iterable: Iterable<T>): IteratorLike<T>;

export { ifilter, ifind, ifirst, iflat, iflatMap, ihead, imap, ireduce, isome, iunique, toArray, toSet };
