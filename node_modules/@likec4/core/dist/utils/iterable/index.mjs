export { i as isIterable } from '../../shared/core.RfnaEmgA.mjs';
import { e } from '../../shared/core.DRJma0Ol.mjs';
export { i as ifilter } from '../../shared/core.DRJma0Ol.mjs';
export { i as ifind } from '../../shared/core.CmPXpJ8l.mjs';
import { i as invariant } from '../../shared/core.D4npX2q8.mjs';
import { e as e$1 } from '../../shared/core.C4x8aaWa.mjs';
export { i as iflat, a as iunique } from '../../shared/core.C4x8aaWa.mjs';
export { i as ihead } from '../../shared/core.uFk_o9X6.mjs';
export { i as imap, a as toArray, t as toSet } from '../../shared/core.C3JowhaZ.mjs';
export { i as isome } from '../../shared/core.FZ305VYd.mjs';

function ifirst(arg1, arg2) {
  const count = arg2 ?? arg1;
  invariant(typeof count === "number" && count >= 0, "Count must be a non-negative number");
  function* _first(iter) {
    let taken = 0;
    for (const value of iter) {
      if (taken >= count) {
        break;
      }
      yield value;
      taken++;
    }
    return;
  }
  if (arg2 === void 0) {
    return (iterable) => _first(iterable);
  }
  return _first(arg1);
}

function iflatMap(arg1, arg2) {
  const mapper = arg2 ?? arg1;
  invariant(e(mapper));
  function* _flatMap(iter) {
    for (const value of iter) {
      const mapped = mapper(value);
      yield* mapped;
    }
    return;
  }
  if (!arg2) {
    return _flatMap;
  }
  return _flatMap(arg1);
}

function ireduce(arg1, arg2, arg3) {
  const reducer = e$1(arg3) ? arg2 : arg1;
  const initialValue = arg3 ?? arg2;
  invariant(e(reducer));
  function _reduce(iter) {
    let acc = initialValue;
    for (const value of iter) {
      acc = reducer(acc, value);
    }
    return acc;
  }
  return e$1(arg3) ? _reduce(arg1) : _reduce;
}

export { ifirst, iflatMap, ireduce };
