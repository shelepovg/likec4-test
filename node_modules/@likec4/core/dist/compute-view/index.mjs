import { w as willCreateCycle, t as topologicalSortExports, a as t$4, n as n$1, b as t$9, l as linkNodesWithEdges, c as topologicalSort } from '../shared/core.Dh119QSP.mjs';
export { d as computeLikeC4Model, e as computeParsedModelData, f as computeView, u as unsafeComputeView } from '../shared/core.Dh119QSP.mjs';
import { n } from '../shared/core.BhNcrwzK.mjs';
import { t as t$2 } from '../shared/core.DU5SRqNF.mjs';
import { r as isExtendsElementView, p as isElementView, _ as _stage } from '../shared/core.DH7TXqXf.mjs';
import { G as Graph } from '../shared/core.CmGY9blO.mjs';
import { c as isNonEmptyArray } from '../shared/core.CdNCAwq7.mjs';
import { t as t$5 } from '../shared/core.CbT8JVYL.mjs';
import { t as t$3, b as t$8 } from '../shared/core.DjcWextK.mjs';
import { t as t$1, a as t$7 } from '../shared/core.BsSXS-_R.mjs';
import { t as t$6, e as e$1 } from '../shared/core.Coi_LOUZ.mjs';
import { e } from '../shared/core.BP_QHEXs.mjs';
import { D as DefaultMap } from '../shared/core.BbE4y-yl.mjs';
import { a as nonNullable, i as invariant } from '../shared/core.D4npX2q8.mjs';
import { s as stringHash } from '../shared/core.oSV6SRfk.mjs';
import { preferSummary } from '../types/_aux.mjs';
import { a as GlobalFqn, P as ProjectId } from '../shared/core.D0WZutNd.mjs';

function t(...t){return t$1(Object.keys,t)}

function resolveRulesExtendedViews(unresolvedViews) {
  const g = new Graph({
    type: "directed"
  });
  const extendedViews = [];
  for (const view of t$2(unresolvedViews)) {
    g.addNode(view.id, { view });
    if (isExtendsElementView(view)) {
      extendedViews.push(view);
    }
  }
  if (extendedViews.length === 0) {
    return unresolvedViews;
  }
  for (const view of extendedViews) {
    if (!g.hasNode(view.extends)) {
      console.warn(`View "${view.id}" extends from "${view.extends}" which does not exist`);
      continue;
    }
    if (willCreateCycle(g, view.id, view.extends)) {
      console.warn(`View "${view.id}" extends from "${view.extends}" which creates a cycle`);
      continue;
    }
    g.addDirectedEdge(view.id, view.extends);
  }
  const sorted = topologicalSortExports.topologicalSort(g).reverse();
  return sorted.reduce((acc, id) => {
    const view = g.getNodeAttribute(id, "view");
    if (!isExtendsElementView(view)) {
      acc[view.id] = view;
      return acc;
    }
    const extendsFrom = acc[view.extends];
    if (!extendsFrom || !isElementView(extendsFrom)) {
      return acc;
    }
    const tags = n([
      ...extendsFrom.tags ?? [],
      ...view.tags ?? []
    ]);
    const links = [
      ...extendsFrom.links ?? [],
      ...view.links ?? []
    ];
    acc[view.id] = {
      ...extendsFrom,
      ...view,
      title: view.title ?? extendsFrom.title ?? null,
      description: view.description ?? extendsFrom.description ?? null,
      tags,
      links: isNonEmptyArray(links) ? links : null,
      rules: [...extendsFrom.rules, ...view.rules]
    };
    return acc;
  }, {});
}

function withReadableEdges({ edges, nodes, ...view }, separator = ":") {
  const edgeids = t$4(edges, (e) => [e.id, `${e.source}${separator}${e.target}`]);
  return {
    ...view,
    edges: edges.map((e) => ({
      ...e,
      id: edgeids[e.id]
    })),
    nodes: nodes.map((n) => ({
      ...n,
      inEdges: t$5(n.inEdges, (e) => edgeids[e]),
      outEdges: t$5(n.outEdges, (e) => edgeids[e])
    })),
    nodeIds: nodes.map((n) => n.id),
    edgeIds: edges.map((e) => edgeids[e.id])
  };
}
function viewsWithReadableEdges({ views, ...model }) {
  return {
    ...model,
    views: t$3(views, (v) => n$1(withReadableEdges(v), ["nodeIds", "edgeIds"]))
  };
}

const keysCount = (object) => t(object).length;
const nodeId = (projectId) => stringHash(projectId);
function computeProjectsView(likec4models) {
  const nodesMap = buildNodesForEachModel(likec4models);
  const key = (from, to) => `${from}->${to}`;
  const relationships = new DefaultMap((key2) => {
    const [from, to] = key2.split("->");
    return {
      from,
      to,
      relationships: /* @__PURE__ */ new Set()
    };
  });
  const relationshipsFromTo = (from, to) => relationships.get(key(from, to)).relationships;
  const processImportedElement = (model, importedElement) => {
    const projectId = importedElement.projectId;
    invariant(projectId !== model.projectId, "Imported element must have a different project id");
    const incoming = relationshipsFromTo(model.projectId, projectId);
    for (const rel of importedElement.incoming("direct")) {
      if (rel.source.projectId === model.projectId) {
        incoming.add(rel);
      }
    }
    const outgoing = relationshipsFromTo(projectId, model.projectId);
    for (const rel of importedElement.outgoing("direct")) {
      if (rel.target.projectId === model.projectId) {
        outgoing.add(rel);
      }
    }
  };
  for (const model of likec4models) {
    if (e(model.$data.imports)) {
      continue;
    }
    for (const [projectId, imported] of t$6(model.$data.imports)) {
      for (const importedElement of imported) {
        const fqn = GlobalFqn(projectId, importedElement.id);
        processImportedElement(
          model,
          nonNullable(
            model.findElement(fqn),
            `Element ${importedElement.id} from project ${projectId} not found in model ${model.projectId}`
          )
        );
      }
    }
  }
  const edges = Array.from(relationships.entries()).filter(([_, { relationships: relationships2 }]) => relationships2.size > 0).map(([key2, { from, to, relationships: relationshipsSet }]) => {
    const relationships2 = [...relationshipsSet];
    invariant(t$7(relationships2, 1), "Relationships set must have at least one relationship");
    const edge = {
      id: stringHash(key2),
      source: nodeId(from),
      target: nodeId(to),
      projectId: from,
      relations: t$5(relationships2, e$1("id")),
      label: null,
      color: "gray",
      parent: null,
      line: "solid",
      tags: n(t$8(relationships2, e$1("tags")))
    };
    const onlyOne = t$9(relationships2);
    if (onlyOne) {
      edge.label = onlyOne.title;
      edge.description = preferSummary(onlyOne.$relationship) ?? null;
      edge.technology = onlyOne.technology;
      edge.color = onlyOne.color;
      edge.line = onlyOne.line;
      if (onlyOne.kind) {
        edge.kind = onlyOne.kind;
      }
      if (onlyOne.$relationship.navigateTo) {
        edge.navigateTo = onlyOne.$relationship.navigateTo;
      }
    }
    return edge;
  });
  linkNodesWithEdges(nodesMap, edges);
  const sorted = topologicalSort({
    nodes: nodesMap,
    edges
  });
  return {
    id: "projects-view",
    [_stage]: "computed",
    title: "Projects",
    description: {
      txt: "Overview of all projects and their relationships"
    },
    autoLayout: {
      direction: "TB"
    },
    ...sorted
  };
}
function buildNodesForEachModel(likec4models) {
  const nodesMap = /* @__PURE__ */ new Map();
  for (const model of likec4models) {
    const projectId = ProjectId(model.projectId);
    const node = {
      id: nodeId(projectId),
      kind: "@project",
      parent: null,
      projectId,
      title: model.project.title ?? model.project.id,
      description: {
        txt: [
          `Elements: ${keysCount(model.$data.elements)}`,
          `Relationships: ${keysCount(model.$data.relations)}`,
          `Views: ${keysCount(model.$data.views)}`
        ].join("\n")
      },
      shape: "rectangle",
      children: [],
      inEdges: [],
      outEdges: [],
      color: "primary",
      level: 0,
      style: {},
      tags: []
    };
    nodesMap.set(node.id, node);
  }
  return nodesMap;
}

export { computeProjectsView, resolveRulesExtendedViews, viewsWithReadableEdges, withReadableEdges };
