import { t } from '../../shared/core.3ZhnKAlZ.mjs';
import { f as sortParentsFirst, b as isDescendantOf, i as isAncestor } from '../../shared/core.CdNCAwq7.mjs';
import { D as DefaultMap } from '../../shared/core.BbE4y-yl.mjs';
import { a as nonNullable, i as invariant } from '../../shared/core.D4npX2q8.mjs';
import { t as toSet, a as toArray, i as imap } from '../../shared/core.C3JowhaZ.mjs';
import { i as ifilter } from '../../shared/core.DRJma0Ol.mjs';

function treeFromElements(elements) {
  const sorted = sortParentsFirst([...elements]);
  const root = new Set(sorted);
  const map = new Map(sorted.map((e) => [e._literalId, e]));
  const parents = new DefaultMap(() => null);
  const children = sorted.reduce((acc, parent, index, all) => {
    acc.set(
      parent,
      all.slice(index + 1).filter(isDescendantOf(parent)).map((e) => {
        root.delete(e);
        return e;
      }).reduce((acc2, el) => {
        if (!acc2.some(isAncestor(el))) {
          acc2.push(el);
          parents.set(el, parent);
        }
        return acc2;
      }, [])
    );
    return acc;
  }, new DefaultMap(() => []));
  return {
    sorted,
    byId: (id) => nonNullable(map.get(id), `Element not found by id: ${id}`),
    root,
    parent: (el) => parents.get(el),
    children: (el) => children.get(el),
    /**
     * Flattens the tree structure by removing redundant hierarchy levels.
     * @example
     *   A
     *   └── B
     *       ├── C
     *       │   └── D
     *       │       └── E
     *       └── F
     *           └── G
     * becomes
     *   A
     *   ├── C
     *   │   └── E
     *   └── F
     *       └── G
     */
    flatten: () => {
      return /* @__PURE__ */ new Set([
        ...root,
        ...sorted.reduce((acc, el) => {
          const _children = children.get(el);
          if (_children.length === 0) {
            acc.push(el);
            return acc;
          }
          if (_children.length > 1) {
            acc.push(..._children);
          }
          return acc;
        }, [])
      ]);
    }
  };
}

const finalize = (elements, explicits) => {
  if (elements.size > 2 && explicits.size !== elements.size) {
    return new Set(sortParentsFirst([
      ...treeFromElements(elements).flatten(),
      ...explicits
    ]));
  }
  if (elements.size > 1) {
    return new Set(sortParentsFirst([...elements]));
  }
  return elements;
};
function computeRelationships(subject, others, relationships) {
  const isOther = (e) => others.has(e);
  let subjects = /* @__PURE__ */ new Set([subject]);
  const explicits = {
    incomers: /* @__PURE__ */ new Set(),
    subjects: /* @__PURE__ */ new Set([subject]),
    outgoers: /* @__PURE__ */ new Set()
  };
  let incomers = new Set(relationships.incoming.flatMap((r) => {
    explicits.subjects.add(r.target);
    explicits.incomers.add(r.source);
    subjects.add(r.target);
    if (r.target !== subject) {
      let target = r.target.parent;
      while (target && target !== subject) {
        subjects.add(target);
        target = target.parent;
      }
    }
    let source = r.source;
    const incomerBranch = [];
    while (true) {
      incomerBranch.push(source);
      if (isOther(source) || !source.parent) {
        break;
      }
      source = source.parent;
    }
    return incomerBranch;
  }));
  let outgoers = new Set(relationships.outgoing.flatMap((r) => {
    explicits.subjects.add(r.source);
    explicits.outgoers.add(r.target);
    subjects.add(r.source);
    if (r.source !== subject) {
      let source = r.source.parent;
      while (source && source !== subject) {
        subjects.add(source);
        source = source.parent;
      }
    }
    let target = r.target;
    const outgoerBranch = [];
    while (true) {
      outgoerBranch.push(target);
      if (isOther(target) || !target.parent) {
        break;
      }
      target = target.parent;
    }
    return outgoerBranch;
  }));
  return {
    incomers: finalize(incomers, explicits.incomers),
    incoming: new Set(relationships.incoming),
    subjects: finalize(subjects, explicits.subjects),
    outgoing: new Set(relationships.outgoing),
    outgoers: finalize(outgoers, explicits.outgoers)
  };
}
function computeRelationshipsView(subjectId, likec4model, scopeViewId, scope = "global") {
  const view = scopeViewId ? likec4model.findView(scopeViewId) : null;
  if (scope === "view") {
    invariant(
      view,
      'Scope view id is required when scope is "view"'
    );
    return computeScopedRelationshipsView(subjectId, view, likec4model);
  }
  const subject = likec4model.element(subjectId);
  const subjectSiblings = toSet(subject.ascendingSiblings());
  return computeRelationships(
    subject,
    subjectSiblings,
    {
      incoming: [...subject.incoming()],
      outgoing: [...subject.outgoing()]
    }
  );
}
function computeScopedRelationshipsView(subjectId, view, likec4model) {
  const subject = likec4model.element(subjectId);
  let relationships = {
    incoming: toArray(ifilter(subject.incoming(), (r) => view.includesRelation(r.id))),
    outgoing: toArray(ifilter(subject.outgoing(), (r) => view.includesRelation(r.id)))
  };
  const isDescendant = isDescendantOf(subject);
  const others = /* @__PURE__ */ new Set([
    ...subject.ascendingSiblings(),
    ...t(
      view.elements(),
      imap((e) => e.element),
      ifilter((e) => e !== subject && isDescendant(e))
    )
  ]);
  return computeRelationships(
    subject,
    others,
    relationships
  );
}

export { computeRelationshipsView, treeFromElements };
