import { Align } from '@xyflow/react';
import { Any } from '@likec4/core/types';
import { aux } from '@likec4/core/types';
import { BBox } from '@likec4/core/types';
import { BBox as BBox_2 } from '@likec4/core';
import { CamelCasedProperties } from 'type-fest';
import { Color } from '@likec4/core/types';
import { ComputedNodeStyle } from '@likec4/core/types';
import { ComputedNodeStyle as ComputedNodeStyle_2 } from '@likec4/core';
import { Context as Context_4 } from 'react';
import { ControlButton } from '@xyflow/react';
import { Controls } from '@xyflow/react';
import { CSSProperties } from 'react';
import { DependencyList } from 'react';
import { DeploymentFqn } from '@likec4/core/types';
import { DetailedHTMLProps } from 'react';
import { DiagramEdge } from '@likec4/core/types';
import { DiagramNode } from '@likec4/core/types';
import { DiagramNodeDriftReason } from '@likec4/core/types';
import { DiagramView } from '@likec4/core/types';
import { DynamicViewDisplayVariant } from '@likec4/core/types';
import { Edge } from '@xyflow/react';
import { EdgeChange } from '@xyflow/system';
import { EdgeChange as EdgeChange_2 } from '@xyflow/react';
import { EdgeId } from '@likec4/core/types';
import { EdgeId as EdgeId_2 } from '@likec4/core';
import { EdgeProps } from '@xyflow/react';
import { EffectCallback } from 'react';
import { ElementKind } from '@likec4/core/types';
import { ElementShape as ElementShape_2 } from '@likec4/core/types';
import { ElementStyle } from '@likec4/core/types';
import { Except } from 'type-fest';
import { ExclusiveUnion } from '@likec4/core/types';
import { ExclusiveUnion as ExclusiveUnion_2 } from '@likec4/core';
import { FC } from 'react';
import { ForwardRefExoticComponent } from 'react';
import { Fqn } from '@likec4/core/types';
import { Fqn as Fqn_3 } from '@likec4/core';
import { FunctionComponent } from 'react';
import { HTMLAttributes } from 'react';
import { IconUrl } from '@likec4/core/types';
import { JSX } from 'react/jsx-runtime';
import { JsxStyleProps } from '../../styled-system/types';
import { LayoutedProjectsView } from '@likec4/core/compute-view';
import { LayoutedView } from '@likec4/core/types';
import { LayoutType } from '@likec4/core/types';
import { LikeC4Model } from '@likec4/core/model';
import { LikeC4Project } from '@likec4/core/types';
import { LikeC4Styles } from '@likec4/core/styles';
import { LikeC4ViewModel } from '@likec4/core/model';
import { MantineThemeOverride } from '@mantine/core';
import { MarkdownOrString } from '@likec4/core/types';
import { MarkdownOrString as MarkdownOrString_2 } from '@likec4/core';
import { MemoExoticComponent } from 'react';
import { MiniMap as MiniMap_2 } from '@xyflow/react';
import { MiniMapNode } from '@xyflow/react';
import { MiniMapNodeProps } from '@xyflow/react';
import { MiniMapNodes as MiniMapNodes_2 } from '@xyflow/react';
import { MotionNodeLayoutOptions } from 'motion/react';
import { MouseEvent as MouseEvent_2 } from 'react';
import { NamedExoticComponent } from 'react';
import { Node as Node_2 } from '@xyflow/react';
import { NodeChange } from '@xyflow/system';
import { NodeChange as NodeChange_2 } from '@xyflow/react';
import { NodeId } from '@likec4/core/types';
import { NodeId as NodeId_3 } from '@likec4/core';
import { NodeModel } from '@likec4/core/model';
import { NodeNotation } from '@likec4/core/types';
import { NodeProps } from '@xyflow/react';
import { NodeToolbar } from '@xyflow/react';
import { NodeToolbarProps } from '@xyflow/react';
import { NonEmptyArray } from '@likec4/core/types';
import { NonEmptyObject } from 'type-fest';
import { NonEmptyReadonlyArray } from '@likec4/core/types';
import { OptionalKeysOf } from 'type-fest';
import { Panel } from '@xyflow/react';
import { PartialDeep } from 'type-fest';
import { Position } from '@xyflow/react';
import { ProjectId } from '@likec4/core/types';
import { ProjectId as ProjectId_2 } from '@likec4/core';
import { PropsWithChildren } from 'react';
import { ReactFlowInstance } from '@xyflow/react';
import { ReactFlowProps } from '@xyflow/react';
import { ReactFlowState } from '@xyflow/react';
import { ReactNode } from 'react';
import { Rect } from '@xyflow/system';
import { RefAttributes } from 'react';
import { RefObject } from 'react';
import { RelationId as RelationId_2 } from '@likec4/core/types';
import { RelationshipArrowType } from '@likec4/core/types';
import { RelationshipLineType } from '@likec4/core/types';
import { RichTextOrEmpty } from '@likec4/core/types';
import { SetRequired } from 'type-fest';
import { Simplify } from 'type-fest';
import { SimplifyDeep } from 'type-fest';
import { StepEdgeId } from '@likec4/core/types';
import type * as t from '@likec4/core/types';
import { UnknownLayouted } from '@likec4/core';
import { UnknownLayouted as UnknownLayouted_3 } from '@likec4/core/types';
import { ViewChange } from '@likec4/core/types';
import { ViewId } from '@likec4/core/types';
import { ViewId as ViewId_3 } from '@likec4/core';
import { Viewport } from '@xyflow/system';
import { ViewportPortal } from '@xyflow/react';
import { WhereOperator } from '@likec4/core/types';
import { Without } from 'type-fest/source/merge-exclusive';
import { XYPosition } from '@xyflow/system';

declare type Action<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject> = NoRequiredParams<TAction> | WithDynamicParams<TContext, TExpressionEvent, TAction> | ActionFunction<TContext, TExpressionEvent, TEvent, TParams, TActor, TAction, TGuard, TDelay, TEmitted>;

declare interface ActionArgs<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject> extends UnifiedArg<TContext, TExpressionEvent, TEvent> {
}

declare type ActionExecutor = (actionToExecute: ExecutableActionObject) => void;

declare type ActionFunction<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject> = {
    (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;
    _out_TEvent?: TEvent;
    _out_TActor?: TActor;
    _out_TAction?: TAction;
    _out_TGuard?: TGuard;
    _out_TDelay?: TDelay;
    _out_TEmitted?: TEmitted;
};

declare type ActionFunctionMap<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject = ParameterizedObject, TGuard extends ParameterizedObject = ParameterizedObject, TDelay extends string = string, TEmitted extends EventObject = EventObject> = {
    [K in TAction['type']]?: ActionFunction<TContext, TEvent, TEvent, GetParameterizedParams<TAction extends {
        type: K;
    } ? TAction : never>, TActor, TAction, TGuard, TDelay, TEmitted>;
};

declare type Actions<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject> = SingleOrArray<Action<TContext, TExpressionEvent, TEvent, TParams, TActor, TAction, TGuard, TDelay, TEmitted>>;

declare interface ActiveMachineSnapshot<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TStateValue extends StateValue, TTag extends string, TOutput, TMeta extends MetaObject, TConfig extends StateSchema> extends MachineSnapshotBase<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> {
    status: 'active';
    output: undefined;
    error: undefined;
}

/**
 * An Actor is a running process that can receive events, send events and change
 * its behavior based on the events it receives, which can cause effects outside
 * of the actor. When you run a state machine, it becomes an actor.
 */
declare class Actor<TLogic extends AnyActorLogic> implements ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>> {
    logic: TLogic;
    /** The current internal state of the actor. */
    private _snapshot;
    /**
     * The clock that is responsible for setting and clearing timeouts, such as
     * delayed events and transitions.
     */
    clock: Clock;
    options: Readonly<ActorOptions<TLogic>>;
    /** The unique identifier for this actor relative to its parent. */
    id: string;
    private mailbox;
    private observers;
    private eventListeners;
    private logger;
    _parent?: AnyActorRef;
    ref: ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>;
    private _actorScope;
    systemId: string | undefined;
    /** The globally unique process ID for this invocation. */
    sessionId: string;
    /** The system to which this actor belongs. */
    system: AnyActorSystem;
    private _doneEvent?;
    src: string | AnyActorLogic;
    /**
     * Creates a new actor instance for the given logic with the provided options,
     * if any.
     *
     * @param logic The logic to create an actor from
     * @param options Actor options
     */
    constructor(logic: TLogic, options?: ActorOptions<TLogic>);
    private _initState;
    private _deferred;
    private update;
    /**
     * Subscribe an observer to an actor’s snapshot values.
     *
     * @remarks
     * The observer will receive the actor’s snapshot value when it is emitted.
     * The observer can be:
     *
     * - A plain function that receives the latest snapshot, or
     * - An observer object whose `.next(snapshot)` method receives the latest
     *   snapshot
     *
     * @example
     *
     * ```ts
     * // Observer as a plain function
     * const subscription = actor.subscribe((snapshot) => {
     *   console.log(snapshot);
     * });
     * ```
     *
     * @example
     *
     * ```ts
     * // Observer as an object
     * const subscription = actor.subscribe({
     *   next(snapshot) {
     *     console.log(snapshot);
     *   },
     *   error(err) {
     *     // ...
     *   },
     *   complete() {
     *     // ...
     *   }
     * });
     * ```
     *
     * The return value of `actor.subscribe(observer)` is a subscription object
     * that has an `.unsubscribe()` method. You can call
     * `subscription.unsubscribe()` to unsubscribe the observer:
     *
     * @example
     *
     * ```ts
     * const subscription = actor.subscribe((snapshot) => {
     *   // ...
     * });
     *
     * // Unsubscribe the observer
     * subscription.unsubscribe();
     * ```
     *
     * When the actor is stopped, all of its observers will automatically be
     * unsubscribed.
     *
     * @param observer - Either a plain function that receives the latest
     *   snapshot, or an observer object whose `.next(snapshot)` method receives
     *   the latest snapshot
     */
    subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;
    subscribe(nextListener?: (snapshot: SnapshotFrom<TLogic>) => void, errorListener?: (error: any) => void, completeListener?: () => void): Subscription;
    on<TType extends EmittedFrom<TLogic>['type'] | '*'>(type: TType, handler: (emitted: EmittedFrom<TLogic> & (TType extends '*' ? unknown : {
        type: TType;
    })) => void): Subscription;
    /** Starts the Actor from the initial state */
    start(): this;
    private _process;
    private _stop;
    /** Stops the Actor and unsubscribe all listeners. */
    stop(): this;
    private _complete;
    private _reportError;
    private _error;
    private _stopProcedure;
    /**
     * Sends an event to the running Actor to trigger a transition.
     *
     * @param event The event to send
     */
    send(event: EventFromLogic<TLogic>): void;
    private attachDevTools;
    toJSON(): {
        xstate$$type: number;
        id: string;
    };
    /**
     * Obtain the internal state of the actor, which can be persisted.
     *
     * @remarks
     * The internal state can be persisted from any actor, not only machines.
     *
     * Note that the persisted state is not the same as the snapshot from
     * {@link Actor.getSnapshot}. Persisted state represents the internal state of
     * the actor, while snapshots represent the actor's last emitted value.
     *
     * Can be restored with {@link ActorOptions.state}
     * @see https://stately.ai/docs/persistence
     */
    getPersistedSnapshot(): Snapshot<unknown>;
    [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>>;
    /**
     * Read an actor’s snapshot synchronously.
     *
     * @remarks
     * The snapshot represent an actor's last emitted value.
     *
     * When an actor receives an event, its internal state may change. An actor
     * may emit a snapshot when a state transition occurs.
     *
     * Note that some actors, such as callback actors generated with
     * `fromCallback`, will not emit snapshots.
     * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.
     * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
     */
    getSnapshot(): SnapshotFrom<TLogic>;
}

/**
 * Represents logic which can be used by an actor.
 *
 * @template TSnapshot - The type of the snapshot.
 * @template TEvent - The type of the event object.
 * @template TInput - The type of the input.
 * @template TSystem - The type of the actor system.
 */
declare interface ActorLogic<in out TSnapshot extends Snapshot<unknown>, // it's invariant because it's also part of `ActorScope["self"]["getSnapshot"]`
in out TEvent extends EventObject, // it's invariant because it's also part of `ActorScope["self"]["send"]`
in TInput = NonReducibleUnknown, TSystem extends AnyActorSystem = AnyActorSystem, in out TEmitted extends EventObject = EventObject> {
    /** The initial setup/configuration used to create the actor logic. */
    config?: unknown;
    /**
     * Transition function that processes the current state and an incoming event
     * to produce a new state.
     *
     * @param snapshot - The current state.
     * @param event - The incoming event.
     * @param actorScope - The actor scope.
     * @returns The new state.
     */
    transition: (snapshot: TSnapshot, event: TEvent, actorScope: ActorScope<TSnapshot, TEvent, TSystem, TEmitted>) => TSnapshot;
    /**
     * Called to provide the initial state of the actor.
     *
     * @param actorScope - The actor scope.
     * @param input - The input for the initial state.
     * @returns The initial state.
     */
    getInitialSnapshot: (actorScope: ActorScope<TSnapshot, TEvent, TSystem, TEmitted>, input: TInput) => TSnapshot;
    /**
     * Called when Actor is created to restore the internal state of the actor
     * given a persisted state. The persisted state can be created by
     * `getPersistedSnapshot`.
     *
     * @param persistedState - The persisted state to restore from.
     * @param actorScope - The actor scope.
     * @returns The restored state.
     */
    restoreSnapshot?: (persistedState: Snapshot<unknown>, actorScope: ActorScope<TSnapshot, TEvent, AnyActorSystem, TEmitted>) => TSnapshot;
    /**
     * Called when the actor is started.
     *
     * @param snapshot - The starting state.
     * @param actorScope - The actor scope.
     */
    start?: (snapshot: TSnapshot, actorScope: ActorScope<TSnapshot, TEvent, AnyActorSystem, TEmitted>) => void;
    /**
     * Obtains the internal state of the actor in a representation which can be be
     * persisted. The persisted state can be restored by `restoreSnapshot`.
     *
     * @param snapshot - The current state.
     * @returns The a representation of the internal state to be persisted.
     */
    getPersistedSnapshot: (snapshot: TSnapshot, options?: unknown) => Snapshot<unknown>;
}

declare interface ActorOptions<TLogic extends AnyActorLogic> {
    /**
     * The clock that is responsible for setting and clearing timeouts, such as
     * delayed events and transitions.
     *
     * @remarks
     * You can create your own “clock”. The clock interface is an object with two
     * functions/methods:
     *
     * - `setTimeout` - same arguments as `window.setTimeout(fn, timeout)`
     * - `clearTimeout` - same arguments as `window.clearTimeout(id)`
     *
     * By default, the native `setTimeout` and `clearTimeout` functions are used.
     *
     * For testing, XState provides `SimulatedClock`.
     * @see {@link Clock}
     * @see {@link SimulatedClock}
     */
    clock?: Clock;
    /**
     * Specifies the logger to be used for `log(...)` actions. Defaults to the
     * native `console.log(...)` method.
     */
    logger?: (...args: any[]) => void;
    parent?: AnyActorRef;
    /** The custom `id` for referencing this service. */
    id?: string;
    /** @deprecated Use `inspect` instead. */
    devTools?: never;
    /** The system ID to register this actor under. */
    systemId?: string;
    /** The input data to pass to the actor. */
    input?: InputFrom<TLogic>;
    /**
     * Initializes actor logic from a specific persisted internal state.
     *
     * @remarks
     * If the state is compatible with the actor logic, when the actor is started
     * it will be at that persisted state. Actions from machine actors will not be
     * re-executed, because they are assumed to have been already executed.
     * However, invocations will be restarted, and spawned actors will be restored
     * recursively.
     *
     * Can be generated with {@link Actor.getPersistedSnapshot}.
     * @see https://stately.ai/docs/persistence
     */
    snapshot?: Snapshot<unknown>;
    /** @deprecated Use `snapshot` instead. */
    state?: Snapshot<unknown>;
    /** The source actor logic. */
    src?: string | AnyActorLogic;
    /**
     * A callback function or observer object which can be used to inspect actor
     * system updates.
     *
     * @remarks
     * If a callback function is provided, it can accept an inspection event
     * argument. The types of inspection events that can be observed include:
     *
     * - `@xstate.actor` - An actor ref has been created in the system
     * - `@xstate.event` - An event was sent from a source actor ref to a target
     *   actor ref in the system
     * - `@xstate.snapshot` - An actor ref emitted a snapshot due to a received
     *   event
     *
     * @example
     *
     * ```ts
     * import { createMachine } from 'xstate';
     *
     * const machine = createMachine({
     *   // ...
     * });
     *
     * const actor = createActor(machine, {
     *   inspect: (inspectionEvent) => {
     *     if (inspectionEvent.actorRef === actor) {
     *       // This event is for the root actor
     *     }
     *
     *     if (inspectionEvent.type === '@xstate.actor') {
     *       console.log(inspectionEvent.actorRef);
     *     }
     *
     *     if (inspectionEvent.type === '@xstate.event') {
     *       console.log(inspectionEvent.sourceRef);
     *       console.log(inspectionEvent.actorRef);
     *       console.log(inspectionEvent.event);
     *     }
     *
     *     if (inspectionEvent.type === '@xstate.snapshot') {
     *       console.log(inspectionEvent.actorRef);
     *       console.log(inspectionEvent.event);
     *       console.log(inspectionEvent.snapshot);
     *     }
     *   }
     * });
     * ```
     *
     * Alternately, an observer object (`{ next?, error?, complete? }`) can be
     * provided:
     *
     * @example
     *
     * ```ts
     * const actor = createActor(machine, {
     *   inspect: {
     *     next: (inspectionEvent) => {
     *       if (inspectionEvent.actorRef === actor) {
     *         // This event is for the root actor
     *       }
     *
     *       if (inspectionEvent.type === '@xstate.actor') {
     *         console.log(inspectionEvent.actorRef);
     *       }
     *
     *       if (inspectionEvent.type === '@xstate.event') {
     *         console.log(inspectionEvent.sourceRef);
     *         console.log(inspectionEvent.actorRef);
     *         console.log(inspectionEvent.event);
     *       }
     *
     *       if (inspectionEvent.type === '@xstate.snapshot') {
     *         console.log(inspectionEvent.actorRef);
     *         console.log(inspectionEvent.event);
     *         console.log(inspectionEvent.snapshot);
     *       }
     *     }
     *   }
     * });
     * ```
     */
    inspect?: Observer<InspectionEvent> | ((inspectionEvent: InspectionEvent) => void);
}

declare interface ActorRef<TSnapshot extends Snapshot<unknown>, TEvent extends EventObject, TEmitted extends EventObject = EventObject> extends Subscribable<TSnapshot>, InteropObservable<TSnapshot> {
    /** The unique identifier for this actor relative to its parent. */
    id: string;
    sessionId: string;
    send: (event: TEvent) => void;
    start: () => void;
    getSnapshot: () => TSnapshot;
    getPersistedSnapshot: () => Snapshot<unknown>;
    stop: () => void;
    toJSON?: () => any;
    _parent?: AnyActorRef;
    system: AnyActorSystem;
    src: string | AnyActorLogic;
    on: <TType extends TEmitted['type'] | '*'>(type: TType, handler: (emitted: TEmitted & (TType extends '*' ? unknown : {
        type: TType;
    })) => void) => Subscription;
}

declare type ActorRefFromLogic<T extends AnyActorLogic> = ActorRef<SnapshotFrom<T>, EventFromLogic<T>, EmittedFrom<T>>;

declare type ActorRefLike = Pick<AnyActorRef, 'sessionId' | 'send' | 'getSnapshot'>;

declare interface ActorScope<TSnapshot extends Snapshot<unknown>, TEvent extends EventObject, TSystem extends AnyActorSystem = AnyActorSystem, TEmitted extends EventObject = EventObject> {
    self: ActorRef<TSnapshot, TEvent, TEmitted>;
    id: string;
    sessionId: string;
    logger: (...args: any[]) => void;
    defer: (fn: () => void) => void;
    emit: (event: TEmitted) => void;
    system: TSystem;
    stopChild: (child: AnyActorRef) => void;
    actionExecutor: ActionExecutor;
}

declare interface ActorSystem<T extends ActorSystemInfo> {
    get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;
    getAll: () => Partial<T['actors']>;
    inspect: (observer: Observer<InspectionEvent> | ((inspectionEvent: InspectionEvent) => void)) => Subscription;
    scheduler: Scheduler;
    getSnapshot: () => {
        _scheduledEvents: Record<string, ScheduledEvent>;
    };
    start: () => void;
    _clock: Clock;
    _logger: (...args: any[]) => void;
}

declare interface ActorSystemInfo {
    actors: Record<string, AnyActorRef>;
}

declare type AlignmentMode = LinearAlignmentMode | GridAlignmentMode;

declare type Any_2 = t.aux.Any;

declare type Any_3 = t.aux.Any;

declare type Any_4 = t.aux.Any;

declare type Any_5 = aux.Any;

declare type AnyActorLogic = ActorLogic<any, // snapshot
any, // event
any, // input
any, // system
any>;

declare type AnyActorRef = ActorRef<any, any, // TODO: shouldn't this be AnyEventObject?
any>;

declare type AnyActorScope = ActorScope<any, // TSnapshot
any, // TEvent
AnyActorSystem, any>;

declare type AnyActorSystem = ActorSystem<any>;

declare interface AnyEventObject extends EventObject {
    [key: string]: any;
}

declare type AnyFunction = (...args: any[]) => any;

declare type AnyStateMachine = StateMachine<any, // context
any, // event
any, // children
any, // actor
any, // action
any, // guard
any, // delay
any, // state value
any, // tag
any, // input
any, // output
any, // emitted
any, // TMeta
any>;

declare type AnyTransitionDefinition = TransitionDefinition<any, any>;

export declare const Base: {
    setDimmed: typeof setDimmed;
    setHovered: typeof setHovered;
    setData: typeof setData;
};

export declare namespace Base {
    export type Dimmed = 'immediate' | boolean;
}

export declare interface BaseEdge<Data extends Record<string, unknown> = Record<string, unknown>, EdgeType extends string = string> extends SetRequired<Edge<Data & BaseEdgeData, EdgeType>, 'type' | 'data'> {
}

export declare type BaseEdgeData = {
    /**
     * Whether the cursor is hovering over the edge
     */
    hovered?: boolean;
    /**
     * Whether the edge is active (animated and highlighted)
     */
    active?: boolean;
    /**
     * Whether the edge is dimmed
     * 'immediate' means that the edge is dimmed without delay
     */
    dimmed?: Base.Dimmed;
};

/**
 * ReactFlow Base Edge properties with BaseEdgeData at least
 */
export declare interface BaseEdgeProps<E extends BaseEdge = BaseEdge> extends EdgeProps<E> {
}

export declare type BaseEdgePropsWithData<Data extends Record<string, unknown>> = BaseEdgeProps<BaseEdge<Data>>;

declare interface BaseInspectionEventProperties {
    rootId: string;
    /**
     * The relevant actorRef for the inspection event.
     *
     * - For snapshot events, this is the `actorRef` of the snapshot.
     * - For event events, this is the target `actorRef` (recipient of event).
     * - For actor events, this is the `actorRef` of the registered actor.
     */
    actorRef: ActorRefLike;
}

export declare type BaseNode<Data extends Record<string, unknown> = Record<string, unknown>, NodeType extends string = string> = SetRequired<Node_2<Data & BaseNodeData, NodeType>, 'type' | 'initialWidth' | 'initialHeight'>;

export declare type BaseNodeData = {
    /**
     * Whether the cursor is hovering over the node
     */
    hovered?: boolean;
    /**
     * Whether the node is dimmed
     * 'immediate' means that the node is dimmed without delay
     */
    dimmed?: Base.Dimmed;
};

/**
 * ReactFlow Base Node properties with BaseNodeData at least
 */
export declare interface BaseNodeProps<N extends BaseNode = BaseNode> extends NodeProps<N> {
}

export declare type BaseNodePropsWithData<Data extends Record<string, unknown>> = BaseNodeProps<BaseNode<Data>>;

declare type CallbackActorLogic<TEvent extends EventObject, TInput = NonReducibleUnknown, TEmitted extends EventObject = EventObject> = ActorLogic<CallbackSnapshot<TInput>, TEvent, TInput, AnyActorSystem, TEmitted>;

declare type CallbackSnapshot<TInput> = Snapshot<undefined> & {
    input: TInput;
};

declare interface CancelAction<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TEvent extends EventObject> {
    (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;
}

export declare type ChangeEvent = {
    change: ViewChange;
};

declare interface Clock {
    setTimeout(fn: (...args: any[]) => void, timeout: number): any;
    clearTimeout(id: any): void;
}

export declare function CompoundActionButton({ data: { hovered: isHovered, }, icon, onClick, }: CompoundActionButtonProps): JSX.Element;

declare type CompoundActionButtonProps = Simplify<BaseNodeProps & {
    icon?: ReactNode;
    onClick: (e: MouseEvent_2) => void;
}>;

export declare const CompoundActions: (props: CompoundActionsProps) => JSX.Element | null;

declare type CompoundActionsProps = Types.NodeProps<'compound-deployment' | 'compound-element'>;

export declare function CompoundDeploymentNode(props: Types.NodeProps<'compound-deployment'>): JSX.Element;

/**
 * Node that will be used to render the compound from the deployment model.
 * It is a container node, i.e. it has children.
 *
 * Custom node renderer receives these props:
 * - `nodeProps`: props from XYFlow
 * - `nodeModel`: LikeC4 {@link NodeModel.WithDeploymentElement}
 *
 * @see [Default implementation](https://github.com/likec4/likec4/blob/main/packages/diagram/src/likec4diagram/custom/nodes/nodes.tsx)
 *
 * @example
 * ```tsx
 * import {
 *   compoundDeploymentNode,
 *   CompoundNodeContainer,
 *   CompoundTitle,
 *   CompoundActions,
 *   CompoundDeploymentToolbar,
 *   DefaultHandles,
 * } from '@likec4/diagram/custom'
 *
 * const CustomCompoundDeploymentNode = compoundDeploymentNode(({ nodeProps, nodeModel }) => (
 *   <CompoundNodeContainer nodeProps={nodeProps}>
 *     <CompoundTitle {...nodeProps} />
 *     <CompoundActions {...nodeProps} />
 *     <IfNotReadOnly>
 *       <CompoundDeploymentToolbar {...nodeProps} />
 *     </IfNotReadOnly>
 *     <DefaultHandles />
 *   </CompoundNodeContainer>
 * ```
 */
export declare function compoundDeploymentNode<A extends Any_5 = Unknown_3>(component: FC<CompoundDeploymentNodeProps<A>>): Types.NodeRenderer<'compound-deployment'>;

export declare type CompoundDeploymentNodeProps<A extends Any_5 = Unknown_3> = {
    nodeProps: Types.NodeProps<'compound-deployment'>;
    nodeModel: NodeModel.WithDeploymentElement<A>;
};

export declare function CompoundDeploymentToolbar(props: Types.NodeProps<'compound-deployment'>): JSX.Element;

export declare function CompoundDetailsButton({ data: { hovered: isHovered, }, icon, onClick, }: CompoundDetailsButtonProps): JSX.Element;

declare type CompoundDetailsButtonProps = Simplify<BaseNodeProps & {
    icon?: ReactNode;
    onClick: (e: MouseEvent_2) => void;
}>;

export declare function CompoundDetailsButtonWithHandler(props: Types.NodeProps<'compound-deployment' | 'compound-element'>): JSX.Element | null;

export declare function CompoundElementNode(props: Types.NodeProps<'compound-element'>): JSX.Element;

/**
 * Node that will be used to render the compound element from the model.
 * It is a container node, i.e. it has children.
 *
 * Custom node renderer receives these props:
 * - `nodeProps`: props from XYFlow
 * - `nodeModel`: LikeC4 {@link NodeModel.WithElement}
 *
 * @see [Default implementation](https://github.com/likec4/likec4/blob/main/packages/diagram/src/likec4diagram/custom/nodes/nodes.tsx)
 *
 * @example
 * ```tsx
 * import {
 *   compoundElementNode,
 *   CompoundNodeContainer,
 *   CompoundTitle,
 *   CompoundActions,
 *   CompoundDetailsButtonWithHandler,
 *   IfEnabled,
 *   CompoundElementToolbar,
 *   DefaultHandles,
 * } from '@likec4/diagram/custom'
 *
 * const CustomCompoundElementNode = compoundElementNode(({ nodeProps, nodeModel }) => (
 *   <CompoundNodeContainer nodeProps={props}>
 *     <CompoundTitle {...props} />
 *     <CompoundActions {...props} />
 *     <IfEnabled feature="ElementDetails">
 *       <CompoundDetailsButtonWithHandler {...props} />
 *     </IfEnabled>
 *     <IfNotReadOnly>
 *       <CompoundElementToolbar {...props} />
 *     </IfNotReadOnly>
 *     <DefaultHandles />
 *   </CompoundNodeContainer>
 * ))
 * ```
 */
export declare function compoundElementNode<A extends Any_5 = Unknown_3>(component: FC<CompoundElementNodeProps<A>>): Types.NodeRenderer<'compound-element'>;

export declare type CompoundElementNodeProps<A extends Any_5 = Unknown_3> = {
    nodeProps: Types.NodeProps<'compound-element'>;
    nodeModel: NodeModel.WithElement<A>;
};

export declare function CompoundElementToolbar(props: Types.NodeProps<'compound-element'>): JSX.Element;

export declare function CompoundNodeContainer({ nodeProps: { data: { hovered: isHovered, dimmed: isDimmed, ...data }, }, className, children, style, ...rest }: CompoundNodeContainerProps): JSX.Element;

declare type CompoundNodeContainerProps = PropsWithChildren<HTMLAttributes<HTMLDivElement> & {
    layout?: boolean | 'position' | 'size' | 'preserve-aspect';
    layoutId?: string | undefined;
    nodeProps: BaseNodeProps<BaseNode<RequiredData>>;
}>;

export declare function CompoundTitle({ data }: CompoundTitleProps): JSX.Element;

declare type CompoundTitleProps = {
    data: RequiredData_2;
};

declare type Compute<A> = {
    [K in keyof A]: A[K];
} & unknown;

declare type ConditionalRequired<T, Condition extends boolean> = Condition extends true ? Required<T> : T;

declare type Context = {
    subject: Fqn;
    currentView: DiagramView;
    initiatedFrom: {
        node: NodeId | null;
        clientRect: Rect | null;
    };
};

declare interface Context_2 {
    subject: Fqn_3;
    viewId: ViewId_3 | null;
    scope: 'global' | 'view';
    closeable: boolean;
    enableSelectSubject: boolean;
    enableChangeScope: boolean;
    xyflow: XYFLowInstance | null;
    xystore: XYStoreApi_2 | null;
    layouted: LayoutRelationshipsViewResult | null;
    navigateFromNode: string | null;
    xynodes: RelationshipsBrowserTypes.Node[];
    xyedges: RelationshipsBrowserTypes.Edge[];
}

declare type Context_3 = Readonly<{
    subject: Subject;
    viewId: ViewId_3;
    xyflow: XYFLowInstance_2 | null;
    xystore: XYStoreApi_3 | null;
    initialized: {
        xydata: boolean;
        xyflow: boolean;
    };
    xynodes: RelationshipDetailsTypes.Node[];
    xyedges: RelationshipDetailsTypes.Edge[];
    bounds: BBox_2;
}>;

declare type ContextFactory<TContext extends MachineContext, TActor extends ProvidedActor, TInput, TEvent extends EventObject = EventObject> = ({ spawn, input, self }: {
    spawn: Spawner<TActor>;
    input: TInput;
    self: ActorRef<MachineSnapshot<TContext, TEvent, Record<string, AnyActorRef | undefined>, // TODO: this should be replaced with `TChildren`
    StateValue, string, unknown, TODO, // TMeta
    TODO>, TEvent, AnyEventObject>;
}) => TContext;

declare type CurrentViewModel = LikeC4ViewModel<UnknownLayouted_2, DiagramView<UnknownLayouted_2>>;

declare type Data = {
    shape: ElementShape_2;
    width: number;
    height: number;
    style?: ComputedNodeStyle;
};

declare type Data_2 = {
    tags: readonly string[] | null | undefined;
    width: number;
};

/**
 * XYFlow requires handles to be defined on nodes.
 */
export declare const DefaultHandles: MemoExoticComponent<() => JSX.Element>;

declare type Delay<TDelay extends string> = TDelay | number;

declare type DelayConfig<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TEvent extends EventObject> = number | DelayExpr<TContext, TExpressionEvent, TParams, TEvent>;

declare interface DelayedTransitionDefinition<TContext extends MachineContext, TEvent extends EventObject> extends TransitionDefinition<TContext, TEvent> {
    delay: number | string | DelayExpr<TContext, TEvent, undefined, TEvent>;
}

declare type DelayedTransitions<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string> = {
    [K in Delay<TDelay>]?: string | SingleOrArray<TransitionConfig<TContext, TEvent, TEvent, TActor, TAction, TGuard, TDelay, TODO, // TEmitted
    TODO>>;
};

declare type DelayExpr<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TEvent extends EventObject> = (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams) => number;

declare type DelayFunctionMap<TContext extends MachineContext, TEvent extends EventObject, TAction extends ParameterizedObject> = Record<string, DelayConfig<TContext, TEvent, TAction['params'], TEvent>>;

declare type DependenciesComparator<Deps extends DependencyList = DependencyList> = (a: Deps, b: Deps) => boolean;

/**
 * Center-Bottom action bar, includes zoom-in and browse relationships actions, if the features are enabled.
 * Intended to be used with deployment elements.
 *
 * Use generic {@link ElementActionButtons} for custom action buttons.
 *
 * @param extraButtons - Add extra action buttons
 *
 * @example
 * ```tsx
 * <DeploymentElementActions
 *   extraButtons={[
 *     {
 *       key: 'extra',
 *       icon: <IconZoomScan />,
 *       onClick: (e) => {
 *         e.stopPropagation()
 *         console.log('extra action clicked')
 *       },
 *       },
 *     },
 *   ]}
 * />
 * ```
 */
export declare const DeploymentElementActions: ({ extraButtons, ...props }: DeploymentElementActionsProps) => JSX.Element;

declare type DeploymentElementActionsProps = SimplifyDeep<{
    selected?: boolean;
    data: Pick<Types.DeploymentElementNodeData, 'id' | 'modelFqn' | 'navigateTo'> & BaseNodeData;
}> & WithExtraButtons;

export declare function DeploymentElementToolbar(props: Types.NodeProps<'deployment'>): JSX.Element;

declare type DeploymentFqn_2<A> = t.aux.DeploymentFqn<A>;

export declare function DeploymentNode(props: Types.NodeProps<'deployment'>): JSX.Element;

/**
 * Node that will be used to render the element from deployment model.
 * It is a leaf node, i.e. it does not have children.
 * Can be {@link DeploymentNodeModel} or {@link DeployedInstanceModel}.
 *
 * Custom node renderer receives these props:
 * - `nodeProps`: props from XYFlow
 * - `nodeModel`: {@link NodeModel.WithDeploymentElement}
 *
 * @see [Default implementation](https://github.com/likec4/likec4/blob/main/packages/diagram/src/likec4diagram/custom/nodes/nodes.tsx)
 *
 * @example
 * ```tsx
 * import {
 *   deploymentNode,
 *   ElementNodeContainer,
 *   ElementShape,
 *   ElementData,
 *   DeploymentElementActions,
 *   ElementDetailsButtonWithHandler,
 *   IfNotReadOnly,
 *   DeploymentElementToolbar,
 *   DefaultHandles,
 * } from '@likec4/diagram/custom'
 *
 * const CustomDeploymentNode = deploymentNode(({ nodeProps, nodeModel }) => (
 *   <ElementNodeContainer nodeProps={nodeProps}>
 *     <ElementShape {...nodeProps} />
 *     <ElementData {...nodeProps} />
 *     <DeploymentElementActions
 *       {...nodeProps}
 *       extraButtons={[
 *         {
 *           key: 'plus',
 *           icon: <IconPlus />,
 *           onClick: () => console.log('extra'),
 *         },
 *       ]}
 *     />
 *     <ElementDetailsButtonWithHandler {...nodeProps} />
 *     <IfNotReadOnly>
 *       <DeploymentElementToolbar {...nodeProps} />
 *     </IfNotReadOnly>
 *     <DefaultHandles />
 *   </ElementNodeContainer>
 * ))
 * ```
 */
export declare function deploymentNode<A extends Any_5 = Unknown_3>(component: FC<DeploymentNodeProps<A>>): Types.NodeRenderer<'deployment'>;

export declare type DeploymentNodeProps<A extends Any_5 = Unknown_3> = {
    nodeProps: Types.NodeProps<'deployment'>;
    nodeModel: NodeModel.WithDeploymentElement<A>;
};

export declare interface DiagramActorRef extends DiagramMachineRef {
    system: System;
}

export declare type DiagramActorSnapshot = MachineSnapshot<DiagramContext, DiagramEvents, {
    overlays: OverlaysActorRef | undefined;
    search: SearchActorRef | undefined;
    editor: EditorActorRef | undefined;
}, any, any, any, {}, {}>;

export declare interface DiagramApi<A extends Any_3 = Unknown_2> {
    /**
     * React ref to the diagram actor
     */
    readonly ref: RefObject<DiagramActorRef>;
    /**
     * @warning Do not use in render phase
     */
    readonly actor: DiagramActorRef;
    /**
     * @warning Do not use in render phase
     */
    readonly currentView: t.DiagramView<A>;
    overlays(): OverlaysActorRef;
    /**
     * Send event to diagram actor
     */
    send(event: DiagramEvents): void;
    /**
     * Navigate to view
     * @param viewId - Target view ID
     * @param fromNode - Node from which navigation was triggered
     * @param focusOnElement - Element FQN to focus after navigation (from search)
     */
    navigateTo(viewId: ViewId_4<A>, fromNode?: NodeId_2, focusOnElement?: Fqn_4<A>): void;
    /**
     * Navigate back or forward in history
     */
    navigate(direction: 'back' | 'forward'): void;
    /**
     * Fit diagram to view
     */
    fitDiagram(duration?: number): void;
    /**
     * Open relationships browser
     */
    openRelationshipsBrowser(fqn: Fqn_4<A>): void;
    /**
     * If running in editor, trigger opening source file
     */
    openSource(params: OpenSourceParams<A>): void;
    /**
     * Open element details card
     */
    openElementDetails(fqn: Fqn_4<A>, fromNode?: NodeId_2): void;
    openRelationshipDetails(...params: [edgeId: EdgeId_3] | [source: Fqn_4<A>, target: Fqn_4<A>]): void;
    updateNodeData(nodeId: NodeId_2, data: PartialDeep<Types.NodeData>): void;
    updateEdgeData(edgeId: EdgeId_3, data: PartialDeep<Types.EdgeData>): void;
    /**
     * Start editing, either node or edge
     */
    startEditing(subject: 'node' | 'edge'): void;
    /**
     * Stop editing
     * @param wasChanged - whether there were changes made during editing
     * @default false
     */
    stopEditing(wasChanged?: boolean): void;
    /**
     * Undo last editing operation
     * @returns true if there was something to undo
     */
    undoEditing(): boolean;
    /**
     * Align nodes
     */
    align(mode: AlignmentMode): void;
    /**
     * Reset edge control points
     */
    resetEdgeControlPoints(): void;
    /**
     * Focus node
     */
    focusNode(nodeId: NodeId_2): void;
    /**
     * Focus on element by FQN (finds the node and focuses on it).
     * Used by search to highlight an element on the current view.
     */
    focusOnElement(elementFqn: Fqn_4<A>): void;
    /**
     * @warning Do not use in render phase
     */
    getContext(): DiagramContext;
    /**
     * @warning Do not use in render phase
     */
    findDiagramNode(xynodeId: string): t.DiagramNode<A> | null;
    /**
     * @warning Do not use in render phase
     */
    findEdge(xyedgeId: string): Types.Edge | null;
    /**
     * @warning Do not use in render phase
     */
    findDiagramEdge(xyedgeId: string): t.DiagramEdge<A> | null;
    startWalkthrough(): void;
    walkthroughStep(direction?: 'next' | 'previous'): void;
    stopWalkthrough(): void;
    toggleFeature(feature: FeatureName, forceValue?: boolean): void;
    highlightNotation(notation: NodeNotation, kind?: string): void;
    unhighlightNotation(): void;
    openSearch(searchValue?: string): void;
    triggerChange(viewChange: ViewChange): void;
    /**
     * Switch dynamic view display variant
     */
    switchDynamicViewVariant(variant: DynamicViewDisplayVariant): void;
}

export declare interface DiagramContext extends Input {
    xynodes: Types.Node[];
    xyedges: Types.Edge[];
    features: EnabledFeatures;
    toggledFeatures: ToggledFeatures;
    initialized: {
        xydata: boolean;
        xyflow: boolean;
    };
    viewport: Viewport;
    viewportChangedManually: boolean;
    /**
     * Viewport before entering focus mode, walkthrough or printing
     */
    viewportBefore: null | {
        wasChangedManually: boolean;
        value: Viewport;
    };
    viewportOnManualLayout: null | Viewport;
    viewportOnAutoLayout: null | Viewport;
    lastOnNavigate: null | {
        fromView: ViewId;
        toView: ViewId;
        fromNode: NodeId | null;
        focusOnElement?: Fqn | null;
    };
    navigationHistory: NavigationHistory;
    lastClickedNode: null | {
        id: NodeId;
        clicks: number;
        timestamp: number;
    };
    focusedNode: NodeId | null;
    autoUnfocusTimer: boolean;
    activeElementDetails: null | {
        fqn: Fqn;
        fromNode: NodeId | null;
        nodeRect?: Rect | null;
        nodeRectScreen?: Rect | null;
    };
    xyflow: XYFlowInstance | null;
    dynamicViewVariant: DynamicViewDisplayVariant;
    activeWalkthrough: null | {
        stepId: StepEdgeId;
        parallelPrefix: string | null;
    };
}

export declare type DiagramEmittedEvents = {
    type: 'initialized';
    instance: XYFlowInstance;
} | {
    type: 'navigateTo';
    viewId: ViewId;
} | {
    type: 'openSource';
    params: OpenSourceParams;
} | {
    type: 'paneClick';
} | {
    type: 'nodeClick';
    node: DiagramNode;
    xynode: Types.Node;
} | {
    type: 'edgeClick';
    edge: DiagramEdge;
    xyedge: Types.Edge;
} | {
    type: 'edgeMouseEnter';
    edge: Types.Edge;
    event: MouseEvent_2;
} | {
    type: 'edgeMouseLeave';
    edge: Types.Edge;
    event: MouseEvent_2;
} | {
    type: 'walkthroughStarted';
    edge: Types.Edge;
} | {
    type: 'walkthroughStep';
    edge: Types.Edge;
} | {
    type: 'walkthroughStopped';
} | {
    type: 'onLayoutTypeChange';
    layoutType: LayoutType;
};

declare type DiagramEventHandlersContext = RequiredOrNull<LikeC4DiagramEventHandlers> & {
    handlersRef: RefObject<Required<LikeC4DiagramEventHandlers>>;
};

export declare type DiagramEvents = HotKeyEvent | MediaPrintEvent | {
    type: 'xyflow.init';
    instance: XYFlowInstance;
} | {
    type: 'xyflow.applyNodeChanges';
    changes: NodeChange<Types.Node>[];
} | {
    type: 'xyflow.applyEdgeChanges';
    changes: EdgeChange<Types.Edge>[];
} | {
    type: 'xyflow.viewportMoved';
    viewport: Viewport;
    manually: boolean;
} | {
    type: 'xyflow.nodeClick';
    node: Types.Node;
} | {
    type: 'xyflow.edgeClick';
    edge: Types.Edge;
} | {
    type: 'xyflow.edgeDoubleClick';
    edge: Types.Edge;
} | {
    type: 'xyflow.paneClick';
} | {
    type: 'xyflow.paneDblClick';
} | {
    type: 'xyflow.resized';
} | {
    type: 'xyflow.nodeMouseEnter';
    node: Types.Node;
} | {
    type: 'xyflow.nodeMouseLeave';
    node: Types.Node;
} | {
    type: 'xyflow.edgeMouseEnter';
    edge: Types.Edge;
    event: MouseEvent_2;
} | {
    type: 'xyflow.edgeMouseLeave';
    edge: Types.Edge;
    event: MouseEvent_2;
} | {
    type: 'xyflow.fitDiagram';
    duration?: number;
    bounds?: BBox_2;
} | {
    type: 'xyflow.setViewport';
    duration?: number;
    viewport: Viewport;
} | {
    type: 'update.nodeData';
    nodeId: NodeId;
    data: PartialDeep<Types.NodeData>;
} | {
    type: 'update.edgeData';
    edgeId: EdgeId;
    data: PartialDeep<Types.EdgeData>;
} | {
    type: 'update.view';
    view: DiagramView;
    source?: 'editor' | 'external';
} | {
    type: 'update.view';
    view: DiagramView;
    source?: 'editor' | 'external';
    xynodes: Types.Node[];
    xyedges: Types.Edge[];
} | {
    type: 'update.view-bounds';
    bounds: BBox_2;
} | {
    type: 'update.inputs';
    inputs: Partial<Omit<Input, 'view' | 'xystore' | 'dynamicViewVariant'>>;
} | {
    type: 'update.features';
    features: EnabledFeatures;
} | ({
    type: 'open.source';
} & OpenSourceParams) | {
    type: 'open.elementDetails';
    fqn: Fqn;
    fromNode?: NodeId | undefined;
} | {
    type: 'open.relationshipDetails';
    params: {
        edgeId: EdgeId;
    } | {
        source: Fqn;
        target: Fqn;
    };
} | {
    type: 'open.relationshipsBrowser';
    fqn: Fqn;
} | {
    type: 'open.search';
    search?: string;
} | {
    type: 'navigate.to';
    viewId: ViewId;
    fromNode?: NodeId | undefined;
    focusOnElement?: Fqn | undefined;
} | {
    type: 'navigate.back';
} | {
    type: 'navigate.forward';
} | {
    type: 'layout.align';
    mode: AlignmentMode;
} | {
    type: 'layout.resetEdgeControlPoints';
} | {
    type: 'layout.resetManualLayout';
} | {
    type: 'focus.node';
    nodeId: NodeId;
    autoUnfocus?: boolean;
} | {
    type: 'focus.autoUnfocus';
} | {
    type: 'switch.dynamicViewVariant';
    variant: DynamicViewDisplayVariant;
} | {
    type: 'walkthrough.start';
    stepId?: StepEdgeId;
} | {
    type: 'walkthrough.step';
    direction: 'next' | 'previous';
} | {
    type: 'walkthrough.end';
} | {
    type: 'notations.highlight';
    notation: NodeNotation;
    kind?: string;
} | {
    type: 'notations.unhighlight';
} | {
    type: 'tag.highlight';
    tag: string;
} | {
    type: 'tag.unhighlight';
} | {
    type: 'toggle.feature';
    feature: TogglableFeature;
    forceValue?: boolean;
} | {
    type: 'trigger.change';
    change: ViewChange;
} | {
    type: 'emit.onLayoutTypeChange';
    layoutType: LayoutType;
} | {
    type: 'destroy';
};

declare interface DiagramMachineRef extends ActorRef<DiagramActorSnapshot, DiagramEvents, DiagramEmittedEvents> {
}

export declare type DiagramNodeWithNavigate<A extends Any_2 = Unknown> = SetRequired<DiagramNode<A>, 'navigateTo'>;

declare type DistributeActors<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject, TMeta extends MetaObject, TSpecificActor extends ProvidedActor> = TSpecificActor extends {
    src: infer TSrc;
} ? Compute<{
    systemId?: string;
    /** The source of the machine to be invoked, or the machine itself. */
    src: TSrc;
    /**
     * The unique identifier for the invoked machine. If not specified,
     * this will be the machine's own `id`, or the URL (from `src`).
     */
    id?: TSpecificActor['id'];
    input?: Mapper<TContext, TEvent, InputFrom<TSpecificActor['logic']>, TEvent> | InputFrom<TSpecificActor['logic']>;
    /**
     * The transition to take upon the invoked child machine reaching
     * its final top-level state.
     */
    onDone?: string | SingleOrArray<TransitionConfigOrTarget<TContext, DoneActorEvent<OutputFrom<TSpecificActor['logic']>>, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    /**
     * The transition to take upon the invoked child machine sending an
     * error event.
     */
    onError?: string | SingleOrArray<TransitionConfigOrTarget<TContext, ErrorActorEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    onSnapshot?: string | SingleOrArray<TransitionConfigOrTarget<TContext, SnapshotEvent<SnapshotFrom<TSpecificActor['logic']>>, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
} & {
    [K in RequiredActorOptions<TSpecificActor>]: unknown;
}> | {
    id?: never;
    systemId?: string;
    src: AnyActorLogic;
    input?: Mapper<TContext, TEvent, NonReducibleUnknown, TEvent> | NonReducibleUnknown;
    onDone?: string | SingleOrArray<TransitionConfigOrTarget<TContext, DoneActorEvent<unknown>, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    onError?: string | SingleOrArray<TransitionConfigOrTarget<TContext, ErrorActorEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    onSnapshot?: string | SingleOrArray<TransitionConfigOrTarget<TContext, SnapshotEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
} : never;

declare interface DoneActorEvent<TOutput = unknown, TId extends string = string> extends EventObject {
    type: `xstate.done.actor.${TId}`;
    output: TOutput;
    actorId: TId;
}

declare interface DoneMachineSnapshot<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TStateValue extends StateValue, TTag extends string, TOutput, TMeta extends MetaObject, TConfig extends StateSchema> extends MachineSnapshotBase<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> {
    status: 'done';
    output: TOutput;
    error: undefined;
}

declare interface DoneStateEvent<TOutput = unknown> extends EventObject {
    type: `xstate.done.state.${string}`;
    output: TOutput;
}

declare type DoNotInfer<T> = [T][T extends any ? 0 : any];

declare type EdgeId_3 = t.aux.EdgeId;

declare interface EditorActorContext {
    viewId: t.ViewId;
    pendingChanges: t.ViewChange[];
    history: ReadonlyArray<HistorySnapshot>;
    /**
     * The state before editing started
     */
    beforeEditing: HistorySnapshot | null;
    /**
     * The subject of the edit
     */
    editing: 'node' | 'edge' | null;
}

declare type EditorActorEmitedEvent = {
    type: 'idle';
};

declare type EditorActorEvent = {
    type: 'sync';
} | {
    type: 'change';
    change: t.ViewChange;
} | {
    type: 'edit.start';
    subject: 'node' | 'edge';
} | {
    type: 'edit.finish';
    wasChanged?: boolean;
} | {
    type: 'applyLatestToManual';
} | {
    type: 'synced';
} | {
    type: 'cancel';
} | {
    type: 'reset';
} | HotKeyEvent_2;

declare interface EditorActorInput {
    viewId: t.ViewId;
}

declare interface EditorActorLogic extends InferredMachine {
}

declare const _editorActorLogic: StateMachine<EditorActorContext, EditorActorEvent, {
    [x: string]: ActorRefFromLogic<HotkeyActorLogic> | ActorRefFromLogic<PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>> | ActorRefFromLogic<PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>> | undefined;
    hotkey?: ActorRefFromLogic<HotkeyActorLogic>;
}, Values<{
    hotkey: {
        src: "hotkey";
        logic: HotkeyActorLogic;
        id: "hotkey";
    };
    applyLatest: {
        src: "applyLatest";
        logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
        id: string | undefined;
    };
    executeChange: {
        src: "executeChange";
        logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
        id: string | undefined;
    };
}>, never, Values<{
    "has pending": {
        type: "has pending";
        params: unknown;
    };
    "can undo": {
        type: "can undo";
        params: unknown;
    };
}>, "350ms" | "waitBeforeSync", "pending" | "idle" | "editing" | "afterEdit" | "executeChanges" | {
    applyLatestToManual: "call" | "wait";
}, "pending", EditorActorInput, NonReducibleUnknown, EditorActorEmitedEvent, MetaObject, {
    readonly id: "editor";
    readonly context: ({ input }: {
        spawn: {
            <TSrc extends "hotkey" | "applyLatest" | "executeChange">(logic: TSrc, ...[options]: ({
                src: "hotkey";
                logic: HotkeyActorLogic;
                id: "hotkey";
            } extends infer T ? T extends {
                src: "hotkey";
                logic: HotkeyActorLogic;
                id: "hotkey";
            } ? T extends {
                src: TSrc;
            } ? ConditionalRequired<[options?: {
                id?: T["id"];
                systemId?: string;
                input?: InputFrom<T["logic"]>;
                syncSnapshot?: boolean;
            } & { [K in RequiredActorOptions<T>]: unknown; }], IsNotNever<RequiredActorOptions<T>>> : never : never : never) | ({
                src: "applyLatest";
                logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                id: string | undefined;
            } extends infer T_1 ? T_1 extends {
                src: "applyLatest";
                logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                id: string | undefined;
            } ? T_1 extends {
                src: TSrc;
            } ? ConditionalRequired<[options?: {
                id?: T_1["id"];
                systemId?: string;
                input?: InputFrom<T_1["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_1 in RequiredActorOptions<T_1>]: unknown; }], IsNotNever<RequiredActorOptions<T_1>>> : never : never : never) | ({
                src: "executeChange";
                logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                id: string | undefined;
            } extends infer T_2 ? T_2 extends {
                src: "executeChange";
                logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                id: string | undefined;
            } ? T_2 extends {
                src: TSrc;
            } ? ConditionalRequired<[options?: {
                id?: T_2["id"];
                systemId?: string;
                input?: InputFrom<T_2["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_2 in RequiredActorOptions<T_2>]: unknown; }], IsNotNever<RequiredActorOptions<T_2>>> : never : never : never)): ActorRefFromLogic< GetConcreteByKey<Values<{
                hotkey: {
                    src: "hotkey";
                    logic: HotkeyActorLogic;
                    id: "hotkey";
                };
                applyLatest: {
                    src: "applyLatest";
                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                    id: string | undefined;
                };
                executeChange: {
                    src: "executeChange";
                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                    id: string | undefined;
                };
            }>, "src", TSrc>["logic"]>;
            <TLogic extends AnyActorLogic>(src: TLogic, ...[options]: ConditionalRequired<[options?: {
                id?: never;
                systemId?: string;
                input?: InputFrom<TLogic>;
                syncSnapshot?: boolean;
            } & { [K in RequiredLogicInput<TLogic>]: unknown; }], IsNotNever<RequiredLogicInput<TLogic>>>): ActorRefFromLogic<TLogic>;
        };
        input: EditorActorInput;
        self: ActorRef< MachineSnapshot<EditorActorContext, EditorActorEvent, Record<string, AnyActorRef | undefined>, StateValue, string, unknown, any, any>, EditorActorEvent, AnyEventObject>;
    }) => {
        viewId: t.ViewId;
        beforeEditing: null;
        editing: null;
        pendingChanges: never[];
        history: never[];
    };
    readonly initial: "idle";
    readonly states: {
        readonly idle: {
            id: string;
            on: {
                sync: {
                    target: "#pending";
                };
                'edit.start': {
                    target: "#editing";
                };
            };
        };
        readonly editing: {
            id: string;
            tags: "pending";
            entry: CancelAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>[];
            on: {
                change: {
                    target: "#executeChanges";
                    actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, Values<{
                        "has pending": {
                            type: "has pending";
                            params: unknown;
                        };
                        "can undo": {
                            type: "can undo";
                            params: unknown;
                        };
                    }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>;
                };
                'edit.finish': {
                    target: "#afterEdit";
                    actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, Values<{
                        "has pending": {
                            type: "has pending";
                            params: unknown;
                        };
                        "can undo": {
                            type: "can undo";
                            params: unknown;
                        };
                    }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>;
                };
                undo: {
                    target: "#idle";
                    actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, Values<{
                        "has pending": {
                            type: "has pending";
                            params: unknown;
                        };
                        "can undo": {
                            type: "can undo";
                            params: unknown;
                        };
                    }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>;
                };
            };
        };
        readonly pending: {
            id: string;
            tags: "pending"[];
            entry: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                hotkey: {
                    src: "hotkey";
                    logic: HotkeyActorLogic;
                    id: "hotkey";
                };
                applyLatest: {
                    src: "applyLatest";
                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                    id: string | undefined;
                };
                executeChange: {
                    src: "executeChange";
                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                    id: string | undefined;
                };
            }>, never, Values<{
                "has pending": {
                    type: "has pending";
                    params: unknown;
                };
                "can undo": {
                    type: "can undo";
                    params: unknown;
                };
            }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>;
            on: {
                sync: {
                    target: "#pending";
                    reenter: true;
                };
                'edit.start': {
                    target: "#editing";
                    actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, never, never, never>[];
                };
            };
            after: {
                waitBeforeSync: {
                    target: "#executeChanges";
                    actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, never, never, never>[];
                };
            };
        };
        readonly afterEdit: {
            id: string;
            always: ({
                target: "#pending";
                guard: "has pending";
            } | {
                target: "#idle";
            })[];
        };
        readonly applyLatestToManual: {
            id: string;
            entry: CancelAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>[];
            initial: string;
            on: {
                '*': {
                    actions: LogAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>[];
                };
            };
            states: {
                call: {
                    invoke: {
                        src: "applyLatest";
                        input: ({ context }: {
                            context: EditorActorContext;
                            event: EditorActorEvent;
                            self: ActorRef< MachineSnapshot<EditorActorContext, EditorActorEvent, Record<string, AnyActorRef>, StateValue, string, unknown, any, any>, EditorActorEvent, AnyEventObject>;
                        }) => {
                            current: t.DiagramView | undefined;
                            viewId: t.ViewId;
                        };
                        onDone: {
                            actions: ActionFunction<EditorActorContext, DoneActorEvent<EditorCalls.ApplyLatestToManual.Output, string>, EditorActorEvent, undefined, never, never, never, "350ms" | "waitBeforeSync", never>;
                            target: string;
                        };
                        onError: {
                            target: "#idle";
                            actions: ( ActionFunction<EditorActorContext, ErrorActorEvent<unknown, string>, EditorActorEvent, undefined, Values<{
                                hotkey: {
                                    src: "hotkey";
                                    logic: HotkeyActorLogic;
                                    id: "hotkey";
                                };
                                applyLatest: {
                                    src: "applyLatest";
                                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                                    id: string | undefined;
                                };
                                executeChange: {
                                    src: "executeChange";
                                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                                    id: string | undefined;
                                };
                            }>, never, never, never, never> | (({ event }: ActionArgs<EditorActorContext, ErrorActorEvent<unknown, string>, EditorActorEvent>) => void))[];
                        };
                    };
                };
                wait: {
                    entry: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, never, never, never>;
                    after: {
                        '350ms': {
                            target: "#executeChanges";
                            actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                                hotkey: {
                                    src: "hotkey";
                                    logic: HotkeyActorLogic;
                                    id: "hotkey";
                                };
                                applyLatest: {
                                    src: "applyLatest";
                                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                                    id: string | undefined;
                                };
                                executeChange: {
                                    src: "executeChange";
                                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                                    id: string | undefined;
                                };
                            }>, never, Values<{
                                "has pending": {
                                    type: "has pending";
                                    params: unknown;
                                };
                                "can undo": {
                                    type: "can undo";
                                    params: unknown;
                                };
                            }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>[];
                        };
                    };
                };
            };
        };
        readonly executeChanges: {
            id: string;
            entry: CancelAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>[];
            invoke: {
                src: "executeChange";
                input: ({ context }: {
                    context: EditorActorContext;
                    event: EditorActorEvent;
                    self: ActorRef< MachineSnapshot<EditorActorContext, EditorActorEvent, Record<string, AnyActorRef>, StateValue, string, unknown, any, any>, EditorActorEvent, AnyEventObject>;
                }) => {
                    changes: t.ViewChange[];
                    viewId: t.ViewId;
                };
                onDone: {
                    target: "#idle";
                    actions: ActionFunction<EditorActorContext, DoneActorEvent<NonReducibleUnknown, string>, EditorActorEvent, undefined, Values<{
                        hotkey: {
                            src: "hotkey";
                            logic: HotkeyActorLogic;
                            id: "hotkey";
                        };
                        applyLatest: {
                            src: "applyLatest";
                            logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                            id: string | undefined;
                        };
                        executeChange: {
                            src: "executeChange";
                            logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                            id: string | undefined;
                        };
                    }>, never, Values<{
                        "has pending": {
                            type: "has pending";
                            params: unknown;
                        };
                        "can undo": {
                            type: "can undo";
                            params: unknown;
                        };
                    }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>;
                };
                onError: {
                    target: "#afterEdit";
                    actions: ({ event }: ActionArgs<EditorActorContext, ErrorActorEvent<unknown, string>, EditorActorEvent>) => void;
                };
            };
            on: {
                '*': {
                    actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, never, never, never, "350ms" | "waitBeforeSync", never>;
                };
            };
        };
    };
    readonly on: {
        readonly cancel: {
            readonly target: "#idle";
            readonly actions: readonly [ CancelAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>, ActionFunction<EditorActorContext, {
                type: "cancel";
            }, EditorActorEvent, undefined, Values<{
                hotkey: {
                    src: "hotkey";
                    logic: HotkeyActorLogic;
                    id: "hotkey";
                };
                applyLatest: {
                    src: "applyLatest";
                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                    id: string | undefined;
                };
                executeChange: {
                    src: "executeChange";
                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                    id: string | undefined;
                };
            }>, never, never, never, never>];
        };
        readonly synced: {
            readonly actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                hotkey: {
                    src: "hotkey";
                    logic: HotkeyActorLogic;
                    id: "hotkey";
                };
                applyLatest: {
                    src: "applyLatest";
                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                    id: string | undefined;
                };
                executeChange: {
                    src: "executeChange";
                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                    id: string | undefined;
                };
            }>, never, never, never, never>;
        };
        readonly undo: {
            readonly target: "#idle";
            readonly guard: "can undo";
            readonly actions: ActionFunction<EditorActorContext, EditorActorEvent, EditorActorEvent, undefined, Values<{
                hotkey: {
                    src: "hotkey";
                    logic: HotkeyActorLogic;
                    id: "hotkey";
                };
                applyLatest: {
                    src: "applyLatest";
                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                    id: string | undefined;
                };
                executeChange: {
                    src: "executeChange";
                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                    id: string | undefined;
                };
            }>, never, Values<{
                "has pending": {
                    type: "has pending";
                    params: unknown;
                };
                "can undo": {
                    type: "can undo";
                    params: unknown;
                };
            }>, "350ms" | "waitBeforeSync", EditorActorEmitedEvent>;
        };
        readonly change: {
            readonly target: "#executeChanges";
        };
        readonly applyLatestToManual: {
            readonly target: "#applyLatestToManual";
        };
        readonly reset: {
            readonly target: "#idle";
            readonly actions: readonly [ CancelAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>, ActionFunction<EditorActorContext, {
                type: "reset";
            }, EditorActorEvent, undefined, Values<{
                hotkey: {
                    src: "hotkey";
                    logic: HotkeyActorLogic;
                    id: "hotkey";
                };
                applyLatest: {
                    src: "applyLatest";
                    logic: PromiseActorLogic<EditorCalls.ApplyLatestToManual.Output, EditorCalls.ApplyLatestToManual.Input, EventObject>;
                    id: string | undefined;
                };
                executeChange: {
                    src: "executeChange";
                    logic: PromiseActorLogic<NonReducibleUnknown, EditorCalls.ExecuteChange.Input, EventObject>;
                    id: string | undefined;
                };
            }>, never, never, never, never>, StopAction<EditorActorContext, EditorActorEvent, undefined, EditorActorEvent>];
        };
    };
}>;

declare interface EditorActorRef extends ActorRef<EditorActorSnapshot, EditorActorEvent, EditorActorEmitedEvent> {
}

declare type EditorActorSnapshot = SnapshotFrom<EditorActorLogic>;

declare namespace EditorCalls {
    type ApplyLatestToManual = (params: {
        input: ApplyLatestToManual.Input;
    }) => Promise<ApplyLatestToManual.Output>;
    namespace ApplyLatestToManual {
        type Input = {
            viewId: t.ViewId;
            current: t.LayoutedView | undefined;
        };
        type Output = {
            updated: t.LayoutedView;
        };
    }
    type ExecuteChange = (params: {
        input: ExecuteChange.Input;
    }) => Promise<ExecuteChange.Output>;
    namespace ExecuteChange {
        type Input = {
            viewId: t.ViewId;
            changes: t.ViewChange[];
        };
        type Output = NonReducibleUnknown;
    }
}

declare type EffectCallback_2 = (...args: any[]) => any;

declare type EffectHook<Callback extends EffectCallback_2 = EffectCallback_2, Deps extends DependencyList | undefined = DependencyList | undefined, RestArgs extends any[] = any[]> = ((...args: [Callback, Deps, ...RestArgs]) => void) | ((...args: [Callback, Deps]) => void);

/**
 * Center-Bottom bar with action buttons. Intended to be used inside "leaf" nodes.
 *
 * @param selected - Whether the node is selected
 * @param data - Node data
 * @param buttons - Action buttons
 *
 * @example
 * ```tsx
 * <ElementActionButtons
 *   {...nodeProps}
 *   Buttons={[
 *     {
 *       key: 'action1',
 *       icon: <IconZoomScan />,
 *       onClick: (e) => {
 *         e.stopPropagation()
 *         console.log('action1 clicked')
 *       },
 *     },
 *     //...
 *   ]}
 * />
 * ```
 */
export declare function ElementActionButtons({ selected, data: { hovered: isHovered, }, buttons, }: ElementActionButtonsProps): JSX.Element | null;

export declare namespace ElementActionButtons {
    export type Item = {
        key?: string;
        icon?: ReactNode;
        onClick: (e: MouseEvent_2) => void;
    };
}

declare type ElementActionButtonsProps = {
    selected?: boolean;
    data: {
        hovered?: boolean;
    };
    buttons: ElementActionButtons.Item[];
};

/**
 * Center-Bottom action bar, includes zoom-in and browse relationships actions, if the features are enabled.
 * Intended to be used with model elements.
 *
 * Use generic {@link ElementActionButtons} for custom action buttons.
 *
 * @param extraButtons - Add extra action buttons
 *
 * @example
 * ```tsx
 * <ElementActions
 *   extraButtons={[
 *     {
 *       key: 'extra',
 *       icon: <IconZoomScan />,
 *       onClick: (e) => {
 *         e.stopPropagation()
 *         console.log('extra action clicked')
 *       },
 *       },
 *     },
 *   ]}
 * />
 * ```
 */
export declare const ElementActions: NamedExoticComponent<ElementActionsProps>;

declare type ElementActionsProps = SimplifyDeep<{
    selected?: boolean;
    data: Pick<Types.ElementNodeData, 'id' | 'modelFqn' | 'navigateTo'> & BaseNodeData;
}> & WithExtraButtons;

/**
 * Renders an element title, technology, description, and icon.
 *
 * @example
 * ```tsx
 * <ElementData {...nodeProps} />
 * ```
 * or
 * ```tsx
 * <ElementData.Root>
 *   <ElementData.Icon {...nodeProps} />
 *   <ElementData.Root>
 *     <ElementData.Title {...nodeProps} />
 *     <ElementData.Technology {...nodeProps} />
 *     <ElementData.Description {...nodeProps} />
 *   </ElementData.Root>
 * </ElementData.Root>
 * ```
 */
export declare function ElementData({ iconSize, data }: ElementDataProps): JSX.Element;

export declare namespace ElementData {
    var Root: ForwardRefExoticComponent<Omit<DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & RefAttributes<HTMLDivElement>>;
    var Icon: ({ data, ...props }: IconProps) => JSX.Element;
    var Content: ForwardRefExoticComponent<Omit<DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & RefAttributes<HTMLDivElement>>;
    var Title: ForwardRefExoticComponent<SlotProps & RefAttributes<HTMLDivElement>>;
    var Technology: ForwardRefExoticComponent<((Without<SlotProps, {
    children?: ReactNode | undefined;
    }> & {
    children?: ReactNode | undefined;
    }) | (Without<    {
    children?: ReactNode | undefined;
    }, SlotProps> & SlotProps)) & RefAttributes<HTMLDivElement>>;
    var Description: ForwardRefExoticComponent<SlotProps & RefAttributes<HTMLDivElement>>;
}

declare type ElementDataProps = {
    data: RequiredData_3;
    iconSize?: number;
};

declare interface ElementDetailsActorRef extends ActorRef<ElementDetailsSnapshot, Events> {
}

export declare function ElementDetailsButton({ selected, data: { hovered: isHovered, }, icon, onClick, }: ElementDetailsButtonProps): JSX.Element;

declare type ElementDetailsButtonProps = {
    selected?: boolean;
    data: BaseNodeData;
    icon?: ReactNode;
    onClick: (e: MouseEvent_2) => void;
};

export declare function ElementDetailsButtonWithHandler(props: {
    id: string;
    selected?: boolean;
    data: BaseNodeData & {
        modelFqn?: Fqn_3 | null | undefined;
    };
}): JSX.Element | null;

declare interface ElementDetailsLogic extends StateMachine<Context, Events, {
    [key: `${string}-relationships`]: RelationshipsBrowserActorRef | undefined;
}, any, any, any, any, any, never, Input_2, any, any, any, any> {
}

declare type ElementDetailsSnapshot = SnapshotFrom<ElementDetailsLogic>;

export declare type ElementIconRenderer = (props: ElementIconRendererProps) => ReactNode;

export declare type ElementIconRendererProps = {
    node: {
        id: string;
        title: string;
        icon?: string | null | undefined;
    };
    className?: string;
};

/**
 * Renders an element node.
 */
export declare function ElementNode(props: Types.NodeProps<'element'>): JSX.Element;

/**
 * Node that will be used to render the element from the model.
 * It is a leaf node, i.e. it does not have children.
 *
 * Custom node renderer receives these props:
 * - `nodeProps`: props from XYFlow
 * - `nodeModel`: LikeC4 {@link NodeModel.WithElement}
 *
 * @see [Default implementation](https://github.com/likec4/likec4/blob/main/packages/diagram/src/likec4diagram/custom/nodes/nodes.tsx)
 *
 * @example
 * ```tsx
 * import {
 *   elementNode,
 *   ElementNodeContainer,
 *   ElementShape,
 *   ElementData,
 *   ElementActions,
 *   ElementDetailsButtonWithHandler,
 *   IfEnabled,
 *   IfNotReadOnly,
 *   ElementToolbar,
 *   DefaultHandles,
 *   ElementTags
 * } from '@likec4/diagram/custom'
 *
 * const CustomElementNode = elementNode(({ nodeProps, nodeModel }) => (
 *   <ElementNodeContainer nodeProps={nodeProps}>
 *     <ElementShape {...nodeProps} />
 *     <ElementData {...nodeProps} />
 *     <IfEnabled feature="ElementTags">
 *       <ElementTags {...nodeProps} />
 *     </IfEnabled>
 *     <ElementActions
 *       {...nodeProps}
 *       extraButtons={[
 *         {
 *           key: 'plus',
 *           icon: <IconPlus />,
 *           onClick: () => console.log('extra'),
 *         },
 *       ]}
 *     />
 *     <ElementDetailsButtonWithHandler {...nodeProps} />
 *     {nodeModel.element.getMetadata('your-attr') === 'value' && <YourComponent />}
 *     <IfNotReadOnly>
 *       <ElementToolbar {...nodeProps} />
 *     </IfNotReadOnly>
 *     <DefaultHandles />
 *   </ElementNodeContainer>
 * ))
 * ```
 */
export declare function elementNode<A extends Any_5 = Unknown_3>(component: FC<ElementNodeProps<A>>): Types.NodeRenderer<'element'>;

/**
 * Top-level primitive to compose leaf nodes renderers.
 * This container provides the state via data-* attributes
 */
export declare const ElementNodeContainer: ForwardRefExoticComponent<{
    [key: `data-${string}`]: string | undefined;
    nodeProps: BaseNodePropsWithData<RequiredData_4>;
    className?: string | undefined;
    style?: CSSProperties | undefined;
} & MotionNodeLayoutOptions & {
    children?: ReactNode | undefined;
} & RefAttributes<HTMLDivElement>>;

export declare type ElementNodeProps<A extends Any_5 = Unknown_3> = {
    nodeProps: Types.NodeProps<'element'>;
    nodeModel: NodeModel.WithElement<A>;
};

export declare function ElementShape({ data, width, height, showSeletionOutline }: ElementShapeProps): JSX.Element;

declare type ElementShapeProps = {
    data: Data;
    width?: number | undefined;
    height?: number | undefined;
    /**
     * @default true
     */
    showSeletionOutline?: boolean | undefined;
};

export declare const ElementTag: ForwardRefExoticComponent<{
    tag: string;
    cursor?: "pointer" | "default";
} & Omit<Omit< DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref">, "children" | "color"> & RefAttributes<HTMLDivElement>>;

export declare const ElementTags: MemoExoticComponent<({ id, data: { tags, width, hovered } }: ElementTagsProps) => JSX.Element | null>;

declare type ElementTagsProps = BaseNodePropsWithData<Data_2>;

export declare function ElementToolbar(props: Types.NodeProps<'element'>): JSX.Element;

declare type EmittedFrom<TLogic extends AnyActorLogic> = TLogic extends ActorLogic<infer _TSnapshot, infer _TEvent, infer _TInput, infer _TSystem, infer TEmitted> ? TEmitted : never;

export declare type EnabledFeatures = {
    [P in `enable${FeatureName}`]: boolean;
};

declare type Equals<A1, A2> = (<A>() => A extends A2 ? true : false) extends <A>() => A extends A1 ? true : false ? true : false;

declare interface ErrorActorEvent<TErrorData = unknown, TId extends string = string> extends EventObject {
    type: `xstate.error.actor.${TId}`;
    error: TErrorData;
    actorId: TId;
}

declare interface ErrorMachineSnapshot<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TStateValue extends StateValue, TTag extends string, TOutput, TMeta extends MetaObject, TConfig extends StateSchema> extends MachineSnapshotBase<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> {
    status: 'error';
    output: undefined;
    error: unknown;
}

declare type EventDescriptor<TEvent extends EventObject> = TEvent['type'] | PartialEventDescriptor<TEvent['type']> | '*';

declare type EventDescriptorMatches<TEventType extends string, TNormalizedDescriptor> = TEventType extends TNormalizedDescriptor ? true : false;

declare type EventFromLogic<TLogic extends AnyActorLogic> = TLogic extends ActorLogic<infer _TSnapshot, infer TEvent, infer _TInput, infer _TEmitted, infer _TSystem> ? TEvent : never;

/** The full definition of an event, with a string `type`. */
declare type EventObject = {
    /** The type of event that is sent. */
    type: string;
};

declare type Events = {
    type: 'change.subject';
    subject: Fqn;
} | {
    type: 'close';
};

declare type Events_2 = {
    type: 'xyflow.init';
    instance: XYFLowInstance;
    store: XYStoreApi_2;
} | {
    type: 'xyflow.nodeClick';
    node: RelationshipsBrowserTypes.Node;
} | {
    type: 'xyflow.edgeClick';
    edge: RelationshipsBrowserTypes.Edge;
} | {
    type: 'xyflow.applyNodeChanges';
    changes: NodeChange_2<RelationshipsBrowserTypes.Node>[];
} | {
    type: 'xyflow.applyEdgeChanges';
    changes: EdgeChange_2<RelationshipsBrowserTypes.Edge>[];
} | {
    type: 'xyflow.paneClick';
} | {
    type: 'xyflow.paneDblClick';
} | {
    type: 'xyflow.resized';
} | {
    type: 'xyflow.edgeMouseEnter';
    edge: RelationshipsBrowserTypes.Edge;
} | {
    type: 'xyflow.edgeMouseLeave';
    edge: RelationshipsBrowserTypes.Edge;
} | {
    type: 'xyflow.selectionChange';
    nodes: RelationshipsBrowserTypes.Node[];
    edges: RelationshipsBrowserTypes.Edge[];
} | {
    type: 'dim.nonhovered.edges';
} | {
    type: 'undim.edges';
} | {
    type: 'xyflow.updateNodeInternals';
} | {
    type: 'xyflow.unmount';
} | {
    type: 'fitDiagram';
    duration?: number;
    bounds?: BBox_2;
} | {
    type: 'navigate.to';
    subject: Fqn_3;
    fromNode?: string | undefined;
    viewId?: ViewId_3 | undefined;
} | {
    type: 'update.xydata';
    xynodes: RelationshipsBrowserTypes.Node[];
    xyedges: RelationshipsBrowserTypes.Edge[];
} | {
    type: 'change.scope';
    scope: 'global' | 'view';
} | {
    type: 'update.view';
    layouted: LayoutRelationshipsViewResult;
} | {
    type: 'close';
};

declare type Events_3 = {
    type: 'xyflow.init';
    instance: XYFLowInstance_2;
    store: XYStoreApi_3;
} | {
    type: 'xyflow.nodeClick';
    node: RelationshipDetailsTypes.Node;
} | {
    type: 'xyflow.edgeClick';
    edge: RelationshipDetailsTypes.Edge;
} | {
    type: 'xyflow.edgeMouseEnter';
    edge: RelationshipDetailsTypes.Edge;
} | {
    type: 'xyflow.edgeMouseLeave';
    edge: RelationshipDetailsTypes.Edge;
} | {
    type: 'dim.nonhovered.edges';
} | {
    type: 'undim.edges';
} | {
    type: 'xyflow.selectionChange';
    nodes: RelationshipDetailsTypes.Node[];
    edges: RelationshipDetailsTypes.Edge[];
} | {
    type: 'xyflow.applyNodeChanges';
    changes: NodeChange_2<RelationshipDetailsTypes.Node>[];
} | {
    type: 'xyflow.applyEdgeChanges';
    changes: EdgeChange_2<RelationshipDetailsTypes.Edge>[];
} | {
    type: 'xyflow.paneClick';
} | {
    type: 'xyflow.paneDblClick';
} | {
    type: 'xyflow.resized';
} | {
    type: 'xyflow.updateNodeInternals';
} | {
    type: 'update.layoutData';
    data: LayoutResult;
} | {
    type: 'fitDiagram';
    duration?: number;
    bounds?: BBox_2;
} | {
    type: 'navigate.to';
    params: {
        edgeId: EdgeId_2;
        viewId?: ViewId_3;
    } | {
        source: Fqn_3;
        target: Fqn_3;
        viewId?: ViewId_3;
    };
} | {
    type: 'close';
};

declare interface ExecutableActionObject {
    type: string;
    info: ActionArgs<MachineContext, EventObject, EventObject>;
    params: NonReducibleUnknown;
    exec: ((info: ActionArgs<any, any, any>, params: unknown) => void) | undefined;
}

declare type ExtractEvent<TEvent extends EventObject, TDescriptor extends EventDescriptor<TEvent>> = string extends TEvent['type'] ? TEvent : NormalizeDescriptor<TDescriptor> extends infer TNormalizedDescriptor ? TEvent extends any ? true extends EventDescriptorMatches<TEvent['type'], TNormalizedDescriptor> ? TEvent : never : never : never;

export declare type FeatureName = typeof FeatureNames[number];

declare const FeatureNames: readonly ["Controls", "Editor", "ReadOnly", "FocusMode", "NavigateTo", "ElementDetails", "RelationshipDetails", "RelationshipBrowser", "Search", "NavigationButtons", "Notations", "DynamicViewWalkthrough", "FitView", "CompareWithLatest", "Vscode", "ElementTags"];

declare type Fqn_2<A> = t.aux.Fqn<A>;

declare type Fqn_4<A> = t.aux.Fqn<A>;

export declare const FramerMotionConfig: ({ reducedMotion, children, }: PropsWithChildren<{
    /**
     * If true, will respect the device prefersReducedMotion setting by switching
     * transform animations off.
     *
     * @public
     */
    reducedMotion?: "always" | "never" | "user";
}>) => JSX.Element;

declare type GetConcreteByKey<T, TKey extends keyof T, TValue extends T[TKey]> = T & Record<TKey, TValue>;

declare type GetParameterizedParams<T extends ParameterizedObject | undefined> = T extends any ? ('params' extends keyof T ? T['params'] : undefined) : never;

declare type GridAlignmentMode = 'Column' | 'Row';

declare type Guard<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TGuard extends ParameterizedObject> = NoRequiredParams<TGuard> | WithDynamicParams<TContext, TExpressionEvent, TGuard> | GuardPredicate<TContext, TExpressionEvent, TParams, TGuard>;

declare interface GuardArgs<TContext extends MachineContext, TExpressionEvent extends EventObject> {
    context: TContext;
    event: TExpressionEvent;
}

declare type GuardMap<TContext extends MachineContext, TEvent extends EventObject, TGuard extends ParameterizedObject> = {
    [K in TGuard['type']]?: GuardPredicate<TContext, TEvent, GetParameterizedParams<TGuard extends {
        type: K;
    } ? TGuard : never>, TGuard>;
};

declare type GuardPredicate<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TGuard extends ParameterizedObject> = {
    (args: GuardArgs<TContext, TExpressionEvent>, params: TParams): boolean;
    _out_TGuard?: TGuard;
};

declare type HistorySnapshot = {
    view: t.LayoutedView;
    change: t.ViewChange.SaveViewSnapshot;
    xynodes: Types.Node[];
    xyedges: Types.Edge[];
    synched: boolean;
};

declare type HistoryValue<TContext extends MachineContext, TEvent extends EventObject> = Record<string, Array<StateNode<TContext, TEvent>>>;

declare interface HotkeyActorLogic extends CallbackActorLogic<AnyEventObject, NonReducibleUnknown, HotKeyEvent_2> {
}

declare type HotKeyEvent = {
    type: 'key.esc' | `key.arrow.${'left' | 'right' | 'up' | 'down'}`;
};

declare type HotKeyEvent_2 = {
    type: 'undo';
};

declare type IconProps = {
    data: {
        id: string;
        title: string;
        icon?: string | null | undefined;
    };
    className?: string;
    style?: CSSProperties;
};

export declare function IconRendererProvider({ value, children, }: PropsWithChildren<{
    value: ElementIconRenderer | null;
}>): JSX.Element;

/**
 * Renders children only if the specified feature is enabled
 * @param feature Feature name
 * @param and Additional AND condition
 * @example
 * <IfEnabled feature="ReadOnly" and={isSomething}>
 *   ...
 * </IfEnabled>
 */
export declare function IfEnabled({ feature, children, and, }: PropsWithChildren<{
    feature: FeatureName;
    and?: boolean;
}>): JSX.Element | null;

export declare function IfNotEnabled({ feature, children }: PropsWithChildren<{
    feature: FeatureName;
}>): JSX.Element | null;

export declare function IfNotReadOnly({ children }: PropsWithChildren): JSX.Element | null;

export declare function IfReadOnly({ children }: PropsWithChildren): JSX.Element | null;

declare type InferredMachine = typeof _editorActorLogic;

declare type InitialContext<TContext extends MachineContext, TActor extends ProvidedActor, TInput, TEvent extends EventObject> = TContext | ContextFactory<TContext, TActor, TInput, TEvent>;

declare interface InitialTransitionConfig<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string> extends TransitionConfig<TContext, TEvent, TEvent, TActor, TAction, TGuard, TDelay, TODO, // TEmitted
TODO> {
    target: string;
}

declare interface InitialTransitionDefinition<TContext extends MachineContext, TEvent extends EventObject> extends TransitionDefinition<TContext, TEvent> {
    target: ReadonlyArray<StateNode<TContext, TEvent>>;
    guard?: never;
}

declare interface Input {
    view: DiagramView;
    xystore: XYStoreApi;
    zoomable: boolean;
    pannable: boolean;
    nodesDraggable: boolean;
    nodesSelectable: boolean;
    fitViewPadding: ViewPaddings;
    where: WhereOperator | null;
    dynamicViewVariant?: DynamicViewDisplayVariant | undefined;
}

declare type Input_2 = {
    subject: Fqn;
    currentView: DiagramView;
    initiatedFrom?: {
        node?: NodeId;
        clientRect?: Rect;
    };
};

declare type Input_3 = {
    subject: Fqn_3;
    viewId: ViewId_3 | null;
    scope: 'global' | 'view';
    closeable?: boolean;
    enableSelectSubject?: boolean;
    enableChangeScope?: boolean;
};

declare type Input_4 = ExclusiveUnion_2<{
    Edge: {
        edgeId: EdgeId_2;
        viewId: ViewId_3;
    };
    Between: {
        source: Fqn_3;
        target: Fqn_3;
        viewId: ViewId_3;
    };
}>;

declare type InputFrom<T> = T extends StateMachine<infer _TContext, infer _TEvent, infer _TChildren, infer _TActor, infer _TAction, infer _TGuard, infer _TDelay, infer _TStateValue, infer _TTag, infer TInput, infer _TOutput, infer _TEmitted, infer _TMeta, infer _TStateSchema> ? TInput : T extends ActorLogic<infer _TSnapshot, infer _TEvent, infer TInput, infer _TSystem, infer _TEmitted> ? TInput : never;

declare interface InspectedActionEvent extends BaseInspectionEventProperties {
    type: '@xstate.action';
    action: {
        type: string;
        params: unknown;
    };
}

declare interface InspectedActorEvent extends BaseInspectionEventProperties {
    type: '@xstate.actor';
}

declare interface InspectedEventEvent extends BaseInspectionEventProperties {
    type: '@xstate.event';
    sourceRef: ActorRefLike | undefined;
    event: AnyEventObject;
}

declare interface InspectedMicrostepEvent extends BaseInspectionEventProperties {
    type: '@xstate.microstep';
    event: AnyEventObject;
    snapshot: Snapshot<unknown>;
    _transitions: AnyTransitionDefinition[];
}

declare interface InspectedSnapshotEvent extends BaseInspectionEventProperties {
    type: '@xstate.snapshot';
    event: AnyEventObject;
    snapshot: Snapshot<unknown>;
}

declare type InspectionEvent = InspectedSnapshotEvent | InspectedEventEvent | InspectedActorEvent | InspectedMicrostepEvent | InspectedActionEvent;

declare type InternalMachineImplementations<TTypes extends StateMachineTypes> = {
    actions?: MachineImplementationsActions<TTypes>;
    actors?: MachineImplementationsActors<TTypes>;
    delays?: MachineImplementationsDelays<TTypes>;
    guards?: MachineImplementationsGuards<TTypes>;
};

declare interface InteropObservable<T> {
    [Symbol.observable]: () => InteropSubscribable<T>;
}

declare interface InteropSubscribable<T> {
    subscribe(observer: Observer<T>): Subscription;
}

declare type InvokeConfig<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject, TMeta extends MetaObject> = IsLiteralString<TActor['src']> extends true ? DistributeActors<TContext, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta, TActor> : {
    /**
     * The unique identifier for the invoked machine. If not specified, this
     * will be the machine's own `id`, or the URL (from `src`).
     */
    id?: string;
    systemId?: string;
    /** The source of the machine to be invoked, or the machine itself. */
    src: AnyActorLogic | string;
    input?: Mapper<TContext, TEvent, NonReducibleUnknown, TEvent> | NonReducibleUnknown;
    /**
     * The transition to take upon the invoked child machine reaching its
     * final top-level state.
     */
    onDone?: string | SingleOrArray<TransitionConfigOrTarget<TContext, DoneActorEvent<any>, // TODO: consider replacing with `unknown`
    TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    /**
     * The transition to take upon the invoked child machine sending an
     * error event.
     */
    onError?: string | SingleOrArray<TransitionConfigOrTarget<TContext, ErrorActorEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    onSnapshot?: string | SingleOrArray<TransitionConfigOrTarget<TContext, SnapshotEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
};

declare interface InvokeDefinition<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject, TMeta extends MetaObject> {
    id: string;
    systemId: string | undefined;
    /** The source of the actor logic to be invoked */
    src: AnyActorLogic | string;
    input?: Mapper<TContext, TEvent, NonReducibleUnknown, TEvent> | NonReducibleUnknown;
    /**
     * The transition to take upon the invoked child machine reaching its final
     * top-level state.
     */
    onDone?: string | SingleOrArray<TransitionConfig<TContext, DoneActorEvent<unknown>, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    /**
     * The transition to take upon the invoked child machine sending an error
     * event.
     */
    onError?: string | SingleOrArray<TransitionConfig<TContext, ErrorActorEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    onSnapshot?: string | SingleOrArray<TransitionConfig<TContext, SnapshotEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    toJSON: () => Omit<InvokeDefinition<TContext, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>, 'onDone' | 'onError' | 'toJSON'>;
}

declare type IsLiteralString<T extends string> = string extends T ? false : true;

declare type IsNever<T> = [T] extends [never] ? true : false;

declare type IsNotNever<T> = [T] extends [never] ? false : true;

declare type LayoutRelationshipsViewResult = {
    subject: Fqn;
    subjectExistsInScope: boolean;
    nodes: LayoutRelationshipsViewResult.Node[];
    edges: LayoutRelationshipsViewResult.Edge[];
    bounds: DiagramView['bounds'];
};

declare namespace LayoutRelationshipsViewResult {
    const Empty: ElementKind;
    type Node = Omit<DiagramNode, 'deploymentRef' | 'description' | 'inEdges' | 'outEdges'> & {
        description: MarkdownOrString | null;
        column: RelationshipsBrowserTypes.Column;
        ports: RelationshipsBrowserTypes.Ports;
        existsInCurrentView: boolean;
    };
    type Edge = Omit<DiagramEdge, 'description'> & {
        sourceFqn: Fqn;
        targetFqn: Fqn;
        sourceHandle: string;
        targetHandle: string;
        existsInCurrentView: boolean;
    };
}

declare type LayoutResult = {
    nodes: LayoutResult.Node[];
    edges: LayoutResult.Edge[];
    bounds: DiagramView['bounds'];
};

declare namespace LayoutResult {
    type Node = Except<DiagramNode, 'modelRef' | 'description' | 'deploymentRef' | 'inEdges' | 'outEdges'> & {
        description: MarkdownOrString | null;
        modelRef: Fqn;
        column: RelationshipDetailsTypes.Column;
        ports: RelationshipDetailsTypes.Ports;
    };
    type Edge = Except<DiagramEdge, 'relations' | 'description'> & {
        relationId: RelationId_2;
        sourceHandle: string;
        targetHandle: string;
        description: MarkdownOrString | null;
    };
}

export declare interface LikeC4BrowserProps {
    /**
     * Background pattern for the browser view.
     * @default 'dots'
     */
    background?: 'dots' | 'lines' | 'cross' | 'transparent' | 'solid' | undefined;
    /**
     * Padding around the diagram
     * @default '16px'
     */
    fitViewPadding?: PaddingWithUnit | undefined;
    /**
     * Show/hide panel with top left controls,
     *
     * @default true
     */
    controls?: boolean | undefined;
    /**
     * Show back/forward navigation buttons
     * @default true
     */
    showNavigationButtons?: undefined | boolean;
    /**
     * Enable search popup for elements and views
     * @default true
     */
    enableSearch?: boolean | undefined;
    /**
     * If double click on a node should enable focus mode
     *
     * @default true
     */
    enableFocusMode?: boolean | undefined;
    /**
     * If Walkthrough for dynamic views should be enabled
     * @default true
     */
    enableDynamicViewWalkthrough?: boolean | undefined;
    /**
     * Default dynamic view display variant
     * @default 'diagram'
     */
    dynamicViewVariant?: t.DynamicViewDisplayVariant | undefined;
    /**
     * Enable popup with element details
     * @default true
     */
    enableElementDetails?: boolean | undefined;
    /**
     * Experimental feature to browse relationships
     *
     * @default true
     */
    enableRelationshipBrowser?: boolean | undefined;
    /**
     * Display dropdown with details on relationship's label click
     * @default enableRelationshipBrowser
     */
    enableRelationshipDetails?: boolean | undefined;
    /**
     * Display element tags in the bottom left corner
     * @default true
     */
    enableElementTags?: boolean | undefined;
    /**
     * Display notations of the view
     * @default true
     */
    enableNotations?: boolean | undefined;
    /**
     * Enable "Compare with auto layout" action when view was manually modified and out of sync with latest model
     * @default true
     */
    enableCompareWithLatest?: boolean | undefined;
    /**
     * Improve performance by hiding certain elements and reducing visual effects (disable mix-blend, shadows, animations)
     *
     * @default 'auto' - will be set to true if view is pannable and has more than 3000 * 2000 pixels
     */
    reduceGraphics?: 'auto' | boolean | undefined;
    className?: string | undefined;
    style?: CSSProperties | undefined;
    /**
     * Override some react flow props
     */
    reactFlowProps?: OverrideReactFlowProps | undefined;
    /**
     * Children to render inside the browser overlay
     */
    children?: ReactNode | undefined;
}

export declare type LikeC4ColorScheme = 'light' | 'dark';

/**
 * Low-level component to display LikeC4 view
 * Expects CSS to be injected
 *
 * Use {@link ReactLikeC4} or {@link LikeC4View} for ready-to-use component
 */
export declare function LikeC4Diagram<A extends Any = Any>({ onCanvasClick, onCanvasContextMenu, onCanvasDblClick, onEdgeClick, onEdgeContextMenu, onNavigateTo, onNodeClick, onNodeContextMenu, onOpenSource, onLogoClick, onLayoutTypeChange, onInitialized, view, className, controls, fitView, fitViewPadding: _fitViewPadding, pannable, zoomable, background, enableElementTags, enableFocusMode, enableElementDetails, enableRelationshipDetails, enableRelationshipBrowser, enableCompareWithLatest, nodesSelectable, enableNotations, showNavigationButtons, enableDynamicViewWalkthrough, dynamicViewVariant, enableSearch, initialWidth, initialHeight, reduceGraphics, renderIcon, where, reactFlowProps, renderNodes, children, }: LikeC4DiagramProps<A>): JSX.Element;

export declare interface LikeC4DiagramEventHandlers<A extends Any_2 = Unknown> {
    onNavigateTo?: OnNavigateTo<A> | null | undefined;
    onNodeClick?: OnNodeClick<A> | null | undefined;
    onNodeContextMenu?: OnNodeClick<A> | null | undefined;
    onCanvasContextMenu?: OnCanvasContextMenu | null | undefined;
    onEdgeClick?: OnEdgeClick<A> | null | undefined;
    onEdgeContextMenu?: OnEdgeClick<A> | null | undefined;
    onCanvasClick?: OnCanvasClick | null | undefined;
    onCanvasDblClick?: OnCanvasClick | null | undefined;
    onLogoClick?: null | undefined | (() => void);
    onOpenSource?: OnOpenSource<A> | null | undefined;
    onInitialized?: OnInitialized | null | undefined;
    /**
     * Triggered when user changes layout type (e.g. from 'manual' to 'auto')
     * Expected another `view` to be passed to the diagram
     *
     * @param layoutType new layout type
     */
    onLayoutTypeChange?: OnLayoutTypeChange | null | undefined;
}

export declare interface LikeC4DiagramProperties<A extends Any_2 = Unknown> {
    view: LayoutedView<A>;
    className?: string | undefined;
    /**
     * Enable/disable panning
     * @default true
     */
    pannable?: boolean | undefined;
    /**
     * Enable/disable zooming
     * @default true
     */
    zoomable?: boolean | undefined;
    /**
     * Show/hide panel with top left controls
     *
     * @default true
     */
    controls?: boolean | undefined;
    /**
     * If set, initial viewport will show all nodes & edges
     * @default true
     */
    fitView?: boolean | undefined;
    /**
     * Padding around the diagram (number - pixels)
     * @default 16 - 16px
     *
     * @see {@link ViewPadding}
     *
     * @example
     * ```tsx
     * <LikeC4Diagram
     *   fitViewPadding={{
     *     x: '16px',
     *     y: 16,
     *   }}
     * />
     *
     * <LikeC4Diagram
     *   fitViewPadding={{
     *     top: 8,
     *     right: '8px',
     *     bottom: '1px',
     *     left: '8px',
     *   }}
     * />
     * ```
     */
    fitViewPadding?: ViewPadding | undefined;
    /**
     * If not readonly, or `enableFocusMode`, `onNavigateTo` or  `onNodeClick` are set - nodes will be selectable
     *
     * @default false
     */
    nodesSelectable?: boolean | undefined;
    /**
     * Initial width of the diagram
     * (supposed to be used during SSR)
     */
    initialWidth?: number | undefined;
    /**
     * Initial height of the diagram
     * (supposed to be used during SSR)
     */
    initialHeight?: number | undefined;
    /**
     * Background pattern
     * @default 'dots'
     */
    background?: 'transparent' | 'solid' | 'dots' | 'lines' | 'cross' | undefined;
    /**
     * Show back/forward history navigation buttons
     * @default true if `onNavigateTo` is set
     */
    showNavigationButtons?: undefined | boolean;
    /**
     * Display notations in the bottom right corner
     * (Active if only notations are present)
     *
     * @default false
     */
    enableNotations?: boolean | undefined;
    /**
     * Display dropdown with details on relationship's label click
     * @default false
     */
    enableRelationshipDetails?: boolean | undefined;
    /**
     * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
     * @default false
     */
    enableFocusMode?: boolean | undefined;
    /**
     * Enable search popup for elements and views
     * @default true
     */
    enableSearch?: boolean | undefined;
    /**
     * Enable modal with element details
     * @default false
     */
    enableElementDetails?: boolean | undefined;
    /**
     * Experimental feature to browse relationships
     *
     * @default false
     */
    enableRelationshipBrowser?: boolean | undefined;
    /**
     * If Walkthrough for dynamic views should be enabled
     * @default false
     */
    enableDynamicViewWalkthrough?: boolean | undefined;
    /**
     * Enable "Compare with auto layout" action when view was manually modified and out of sync with latest model
     * @default true if `onLayoutTypeChange` is set, false otherwise
     */
    enableCompareWithLatest?: boolean | undefined;
    /**
     * Default dynamic view display variant
     * @default 'diagram'
     */
    dynamicViewVariant?: DynamicViewDisplayVariant | undefined;
    /**
     * Display element tags in the bottom left corner
     * @default false
     */
    enableElementTags?: boolean | undefined;
    /**
     * Improve performance by hiding certain elements and reducing visual effects (disable mix-blend, shadows, animations)
     * Enable it if you have a large or static view
     * - `auto` - will be `true` if view has more then 3000 * 2000 pixels
     *
     * @default 'auto'
     */
    reduceGraphics?: 'auto' | boolean | undefined;
    /**
     * Render icon for an element, bundled or remote
     * By default, if icon is http:// or https://, it will be rendered as an image
     */
    renderIcon?: ElementIconRenderer | undefined;
    /**
     * Override node renderers
     */
    renderNodes?: NodeRenderers | undefined;
    /**
     * Dynamic filter, applies both to nodes and edges
     */
    where?: WhereOperator<A> | undefined;
    /**
     * Override ReactFlow props
     */
    reactFlowProps?: OverrideReactFlowProps | undefined;
}

export declare type LikeC4DiagramProps<A extends Any = Any> = PropsWithChildren<LikeC4DiagramProperties<A> & LikeC4DiagramEventHandlers<A>>;

export declare type LikeC4EditorPort = {
    /**
     * Fetch a view by its ID and layout type.
     *
     * @param viewId - The ID of the view to fetch.
     * @param layout - The layout type to use when fetching the view.
     */
    fetchView(viewId: t.ViewId, layout?: t.LayoutType): t.LayoutedView | Promise<t.LayoutedView>;
    /**
     * Callback invoked when the view changes.
     */
    handleChange(viewId: t.ViewId, change: t.ViewChange): void | Promise<void>;
};

export declare function LikeC4EditorProvider({ children, editor }: LikeC4EditorProviderProps): JSX.Element;

export declare type LikeC4EditorProviderProps = PropsWithChildren<{
    editor: LikeC4EditorPort;
}>;

/**
 * Ensures LikeC4Model context
 */
export declare function LikeC4ModelProvider<A extends aux.Any = aux.Unknown>({ children, likec4model, }: PropsWithChildren<LikeC4ModelProviderProps<A>>): JSX.Element;

export declare interface LikeC4ModelProviderProps<A extends aux.Any = aux.Unknown> {
    likec4model: LikeC4Model<A>;
}

declare type LikeC4ProjectsContext = {
    projects: ReadonlyArray<LikeC4Project>;
    onProjectChange: (id: ProjectId) => void;
};

declare const LikeC4ProjectsContext: Context_4<LikeC4ProjectsContext | null>;

export declare function LikeC4ProjectsOverview({ view, className, onNavigateToProject, ...props }: LikeC4ProjectsOverviewProps): JSX.Element;

export declare type LikeC4ProjectsOverviewProps = Simplify<Omit<ProjectsOverviewProps, 'id'> & {
    className?: string;
    onSelectProject?: ProjectsOverviewProps['onNavigateToProject'];
}>;

/**
 * Ensures LikeC4Projects context
 */
export declare function LikeC4ProjectsProvider({ children, projects, onProjectChange: _onProjectChange, }: PropsWithChildren<LikeC4ProjectsProviderProps>): JSX.Element;

export declare interface LikeC4ProjectsProviderProps {
    /**
     * Projects to be used in the navigation panel.
     * Current project is taken from the LikeC4Model
     */
    projects: ReadonlyArray<LikeC4Project>;
    /**
     * Optional callback when another project is selected.
     */
    onProjectChange?: (id: ProjectId) => void;
}

/**
 * Ready-to-use component to display embedded LikeC4 view,
 * OnClick allows to browse the model.
 *
 * {@link ReactLikeC4} gives you more control.
 *
 * Component is wrapped in ShadowRoot to isolate styles.
 */
export declare function LikeC4View<A extends t.aux.Any = t.aux.UnknownLayouted>({ viewId, className, pannable, zoomable, keepAspectRatio, colorScheme, injectFontCss, controls, background, browser, showNavigationButtons, enableNotations, enableFocusMode, enableDynamicViewWalkthrough, enableElementDetails, enableRelationshipDetails, enableRelationshipBrowser, reduceGraphics, mantineTheme, styleNonce, style, reactFlowProps, renderNodes, children, ...props }: LikeC4ViewProps<A>): JSX.Element;

export declare interface LikeC4ViewProps<A extends t.aux.Any = t.aux.UnknownLayouted> {
    /**
     * View to display.
     */
    viewId: t.aux.ViewId<A>;
    /**
     * Enable/disable panning
     * @default false
     */
    pannable?: boolean | undefined;
    /**
     * Enable/disable zooming
     * @default false
     */
    zoomable?: boolean | undefined;
    /**
     * @default true
     */
    keepAspectRatio?: boolean | undefined;
    /**
     * Background pattern
     * @default 'transparent'
     */
    background?: 'dots' | 'lines' | 'cross' | 'transparent' | 'solid' | undefined;
    /**
     * Click on the view opens a modal with browser.
     * You can customize or disable the browser.
     *
     * @default true
     */
    browser?: boolean | LikeC4BrowserProps | undefined;
    /**
     * @default - determined by the user's system preferences.
     */
    colorScheme?: 'light' | 'dark' | undefined;
    /**
     * LikeC4 views are using 'IBM Plex Sans' font.
     * By default, component injects the CSS to document head.
     * Set to false if you want to handle the font yourself.
     *
     * @default true
     */
    injectFontCss?: boolean | undefined;
    /**
     * Show/hide panel with top left controls,
     * @default false
     */
    controls?: boolean | undefined;
    /**
     * If set, initial viewport will show all nodes & edges
     * @default true
     */
    fitView?: boolean | undefined;
    /**
     * Padding around the diagram
     * @default '16px'
     *
     * @see {@link ViewPadding}
     *
     * @example
     * ```tsx
     * <LikeC4View
     *   fitViewPadding={{
     *     x: '16px',
     *     y: 16,
     *   }}
     * />
     *
     * <LikeC4View
     *   fitViewPadding={{
     *     top: 8,
     *     right: '8px',
     *     bottom: '1px',
     *     left: '8px',
     *   }}
     * />
     * ```
     */
    fitViewPadding?: ViewPadding | undefined;
    /**
     * Show back/forward navigation buttons in controls panel
     * @default false
     */
    showNavigationButtons?: undefined | boolean;
    /**
     * Display notations of the view
     * @default false
     */
    enableNotations?: boolean | undefined;
    /**
     * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
     * Conflicts with `browser` prop
     *
     * @default false
     */
    enableFocusMode?: boolean | undefined;
    /**
     * If Walkthrough for dynamic views should be enabled
     * @default false
     */
    enableDynamicViewWalkthrough?: boolean | undefined;
    /**
     * Default dynamic view display variant
     * @default 'diagram'
     */
    dynamicViewVariant?: t.DynamicViewDisplayVariant | undefined;
    /**
     * Enable popup with element details
     * @default false
     */
    enableElementDetails?: boolean | undefined;
    /**
     * Display element tags in the bottom left corner
     * @default false
     */
    enableElementTags?: boolean | undefined;
    /**
     * Display dropdown with details on relationship's label click
     * @default false
     */
    enableRelationshipDetails?: boolean | undefined;
    /**
     * Allow popup to browse relationships
     *
     * @default enableRelationshipDetails
     */
    enableRelationshipBrowser?: boolean | undefined;
    /**
     * Improve performance by hiding certain elements and reducing visual effects (disable mix-blend, shadows, animations)
     *
     * @default 'auto' - will be set to true if view is pannable and has more than 3000 * 2000 pixels
     */
    reduceGraphics?: 'auto' | boolean | undefined;
    where?: t.WhereOperator<A> | undefined;
    /**
     * Override some react flow props
     */
    reactFlowProps?: OverrideReactFlowProps | undefined;
    className?: string | undefined;
    style?: CSSProperties | undefined;
    /**
     * Override Mantine theme
     */
    mantineTheme?: any;
    /** Function to generate nonce attribute added to all generated `<style />` tags */
    styleNonce?: string | (() => string) | undefined;
    /**
     * Override node renderers
     */
    renderNodes?: NodeRenderers | undefined;
    /**
     * Render custom icon for a node
     * By default, if icon is http:// or https://, it will be rendered as an image
     */
    renderIcon?: ElementIconRenderer | undefined;
    /**
     * Children to render inside the diagram (not inside the browser overlay)
     */
    children?: ReactNode | undefined;
}

declare type LinearAlignmentMode = 'Left' | 'Center' | 'Right' | 'Top' | 'Middle' | 'Bottom';

declare interface LogAction<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TEvent extends EventObject> {
    (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;
}

declare type LowInfer<T> = T & NonNullable<unknown>;

declare type MachineConfig<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor = ProvidedActor, TAction extends ParameterizedObject = ParameterizedObject, TGuard extends ParameterizedObject = ParameterizedObject, TDelay extends string = string, TTag extends string = string, TInput = any, TOutput = unknown, TEmitted extends EventObject = EventObject, TMeta extends MetaObject = MetaObject> = (Omit<StateNodeConfig<DoNotInfer<TContext>, DoNotInfer<TEvent>, DoNotInfer<TActor>, DoNotInfer<TAction>, DoNotInfer<TGuard>, DoNotInfer<TDelay>, DoNotInfer<TTag>, DoNotInfer<TOutput>, DoNotInfer<TEmitted>, DoNotInfer<TMeta>>, 'output'> & {
    /** The initial context (extended state) */
    /** The machine's own version. */
    version?: string;
    output?: Mapper<TContext, DoneStateEvent, TOutput, TEvent> | TOutput;
}) & (MachineContext extends TContext ? {
    context?: InitialContext<LowInfer<TContext>, TActor, TInput, TEvent>;
} : {
    context: InitialContext<LowInfer<TContext>, TActor, TInput, TEvent>;
});

declare type MachineContext = Record<string, any>;

declare type MachineImplementationsActions<TTypes extends StateMachineTypes> = {
    [K in TTypes['actions']['type']]?: ActionFunction<TTypes['context'], TTypes['events'], TTypes['events'], GetConcreteByKey<TTypes['actions'], 'type', K>['params'], TTypes['actors'], TTypes['actions'], TTypes['guards'], TTypes['delays'], TTypes['emitted']>;
};

declare type MachineImplementationsActors<TTypes extends StateMachineTypes> = {
    [K in TTypes['actors']['src']]?: GetConcreteByKey<TTypes['actors'], 'src', K>['logic'];
};

declare type MachineImplementationsDelays<TTypes extends StateMachineTypes> = {
    [K in TTypes['delays']]?: DelayConfig<TTypes['context'], TTypes['events'], undefined, TTypes['events']>;
};

declare type MachineImplementationsGuards<TTypes extends StateMachineTypes> = {
    [K in TTypes['guards']['type']]?: Guard<TTypes['context'], TTypes['events'], GetConcreteByKey<TTypes['guards'], 'type', K>['params'], TTypes['guards']>;
};

/** @ignore */
declare interface MachineImplementationsSimplified<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor = ProvidedActor, TAction extends ParameterizedObject = ParameterizedObject, TGuard extends ParameterizedObject = ParameterizedObject> {
    guards: GuardMap<TContext, TEvent, TGuard>;
    actions: ActionFunctionMap<TContext, TEvent, TActor, TAction>;
    actors: Record<string, AnyActorLogic | {
        src: AnyActorLogic;
        input: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;
    }>;
    delays: DelayFunctionMap<TContext, TEvent, TAction>;
}

declare type MachineSnapshot<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TStateValue extends StateValue, TTag extends string, TOutput, TMeta extends MetaObject, TConfig extends StateSchema> = ActiveMachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> | DoneMachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> | ErrorMachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> | StoppedMachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>;

declare interface MachineSnapshotBase<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TStateValue extends StateValue, TTag extends string, TOutput, TMeta, TStateSchema extends StateSchema = StateSchema> {
    /** The state machine that produced this state snapshot. */
    machine: StateMachine<TContext, TEvent, TChildren, ProvidedActor, ParameterizedObject, ParameterizedObject, string, TStateValue, TTag, unknown, TOutput, EventObject, // TEmitted
    any, // TMeta
    TStateSchema>;
    /** The tags of the active state nodes that represent the current state value. */
    tags: Set<string>;
    /**
     * The current state value.
     *
     * This represents the active state nodes in the state machine.
     *
     * - For atomic state nodes, it is a string.
     * - For compound parent state nodes, it is an object where:
     *
     *   - The key is the parent state node's key
     *   - The value is the current state value of the active child state node(s)
     *
     * @example
     *
     * ```ts
     * // single-level state node
     * snapshot.value; // => 'yellow'
     *
     * // nested state nodes
     * snapshot.value; // => { red: 'wait' }
     * ```
     */
    value: TStateValue;
    /** The current status of this snapshot. */
    status: SnapshotStatus;
    error: unknown;
    context: TContext;
    historyValue: Readonly<HistoryValue<TContext, TEvent>>;
    /** The enabled state nodes representative of the state value. */
    _nodes: Array<StateNode<TContext, TEvent>>;
    /** An object mapping actor names to spawned/invoked actors. */
    children: TChildren;
    /**
     * Whether the current state value is a subset of the given partial state
     * value.
     *
     * @param partialStateValue
     */
    matches: (partialStateValue: ToTestStateValue<TStateValue>) => boolean;
    /**
     * Whether the current state nodes has a state node with the specified `tag`.
     *
     * @param tag
     */
    hasTag: (tag: TTag) => boolean;
    /**
     * Determines whether sending the `event` will cause a non-forbidden
     * transition to be selected, even if the transitions have no actions nor
     * change the state value.
     *
     * @param event The event to test
     * @returns Whether the event will cause a transition
     */
    can: (event: TEvent) => boolean;
    getMeta: () => Record<StateId<TStateSchema> & string, TMeta | undefined>;
    toJSON: () => unknown;
}

declare type Mapper<TContext extends MachineContext, TExpressionEvent extends EventObject, TResult, TEvent extends EventObject> = (args: {
    context: TContext;
    event: TExpressionEvent;
    self: ActorRef<MachineSnapshot<TContext, TEvent, Record<string, AnyActorRef>, // TODO: this should be replaced with `TChildren`
    StateValue, string, unknown, TODO, // TMeta
    TODO>, TEvent, AnyEventObject>;
}) => TResult;

export declare const Markdown: ForwardRefExoticComponent<Omit<Omit< DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref">, "children" | "color" | "dangerouslySetInnerHTML"> & {
    value: RichTextOrEmpty;
    /**
     * When markdown block is used inside a diagram node, this variant should be used to apply the likec4 palette.
     * @default false
     */
    uselikec4palette?: boolean;
    /**
     * Scale factor for the block
     * @default 1
     */
    textScale?: number;
    /**
     * Font size for the block
     * @default 'md'
     */
    fontSize?: (JsxStyleProps["fontSize"] & string) | undefined;
    /**
     * If true, the component will not render anything if the value is empty.
     * @default false
     */
    hideIfEmpty?: boolean | undefined;
    /**
     * Text to show if the value is empty.
     * @default "no content"
     */
    emptyText?: string;
} & RefAttributes<HTMLDivElement>>;

declare type MediaPrintEvent = {
    type: 'media.print.on';
} | {
    type: 'media.print.off';
};

export declare function memoEdge<P extends BaseEdgeProps>(Edge: FunctionComponent<P>): FunctionComponent<P>;

export declare function memoNode<P extends BaseNodeProps>(Node: FunctionComponent<P>, displayName?: string): FunctionComponent<P>;

declare type MetaObject = Record<string, any>;

declare const MiniMap: TXYMiniMap = XYMiniMap;

declare type MiniMapNodes = MiniMapNodes_2<Types.AnyNode>

declare interface NavigationHistory {
    history: ReadonlyArray<NavigationHistoryEntry_2>;
    currentIndex: number;
}

/**
 * Navigation history entry represents a current view state,
 * including viewport, focused node, dynamic view variant, etc.
 */
declare interface NavigationHistoryEntry_2 {
    viewId: ViewId;
    viewport: Viewport;
    viewportChangedManually: boolean;
    viewportBefore?: null | {
        wasChangedManually: boolean;
        value: Viewport;
    };
    focusedNode?: NodeId | null;
    dynamicViewVariant?: DynamicViewDisplayVariant | null;
    activeWalkthrough?: null | StepEdgeId;
}

declare type NodeId_2 = t.aux.NodeId;

export declare type NodeRenderers = Partial<CamelCasedProperties<Types.NodeRenderers>>;

/**
 * To cooperate with `exactOptionalPropertyTypes` in `tsconfig.json`
 *
 * @example
 * interface User {
 * 	name: string;
 * 	surname?: string;
 * 	luckyNumber?: number;
 * }
 *
 * type NonOptionalUser = NonOptional<User>
 * // NonOptionalUser = {
 * //   name: string
 * //   surname: string | undefined
 * //   luckyNumber: number | undefined
 * // }
 */
declare type NonOptional<T extends object, Keys extends OptionalKeysOf<T> = OptionalKeysOf<T>> = Simplify<{
    [P in Exclude<keyof T, Keys>]: T[P];
} & {
    [P in Keys]-?: T[P] | undefined;
}>;

/**
 * @remarks
 * `T | unknown` reduces to `unknown` and that can be problematic when it comes
 * to contextual typing. It especially is a problem when the union has a
 * function member, like here:
 *
 * ```ts
 * declare function test(
 *   cbOrVal: ((arg: number) => unknown) | unknown
 * ): void;
 * test((arg) => {}); // oops, implicit any
 * ```
 *
 * This type can be used to avoid this problem. This union represents the same
 * value space as `unknown`.
 */
declare type NonReducibleUnknown = {} | null | undefined;

declare type NoRequiredParams<T extends ParameterizedObject> = T extends any ? undefined extends T['params'] ? T['type'] : never : never;

declare type NormalizeDescriptor<TDescriptor extends string> = TDescriptor extends '*' ? string : TDescriptor extends `${infer TLeading}.*` ? `${TLeading}.${string}` : TDescriptor;

declare type Observer<T> = {
    next?: (value: T) => void;
    error?: (err: unknown) => void;
    complete?: () => void;
};

/**
 * On pane/canvas click (not on any node or edge)
 */
export declare type OnCanvasClick = (event: MouseEvent_2) => void;

declare type OnCanvasContextMenu = (event: MouseEvent_2 | MouseEvent) => void;

export declare type OnChange = (event: ChangeEvent) => void;

export declare type OnEdgeClick<A extends Any_2 = Unknown> = (edge: DiagramEdge<A>, event: MouseEvent_2) => void;

export declare type OnInitialized = (params: {
    diagram: DiagramApi;
    xyflow: XYFlowInstance;
}) => void;

declare type OnLayoutTypeChange = (layoutType: LayoutType) => void;

export declare type OnNavigateTo<A extends Any_2 = Unknown> = (to: ViewId_2<A>, event?: MouseEvent_2, element?: DiagramNodeWithNavigate<A>) => void;

export declare type OnNodeClick<A extends Any_2 = Unknown> = (node: DiagramNode<A>, event: MouseEvent_2) => void;

/**
 * "Go to source" action
 */
export declare type OnOpenSource<A extends Any_2 = Unknown> = (params: OpenSourceParams<A>) => void;

export declare type OpenSourceParams<A extends Any_2 = Unknown> = {
    element: Fqn_2<A>;
    property?: string;
} | {
    relation: RelationId;
} | {
    deployment: DeploymentFqn_2<A>;
    property?: string;
} | {
    view: StrictViewId<A>;
} | {
    view: StrictViewId<A>;
    astPath: string;
};

declare type OutputFrom<T> = T extends ActorLogic<infer TSnapshot, infer _TEvent, infer _TInput, infer _TSystem, infer _TEmitted> ? (TSnapshot & {
    status: 'done';
})['output'] : T extends ActorRef<infer TSnapshot, infer _TEvent, infer _TEmitted> ? (TSnapshot & {
    status: 'done';
})['output'] : never;

export declare const Overlay: ForwardRefExoticComponent<{
    fullscreen?: boolean | undefined;
    withBackdrop?: boolean | undefined;
    overlayLevel?: number;
    className?: string;
    classes?: {
        dialog?: string;
        body?: string;
    };
    backdrop?: {
        opacity?: number;
    };
    openDelay?: number;
    onClose: () => void;
    onClick?: never;
} & {
    children?: ReactNode | undefined;
} & RefAttributes<HTMLDialogElement>>;

declare type OverlayActorEmitedEvent = {
    type: 'opened';
    overlay: 'elementDetails' | 'relationshipsBrowser' | 'relationshipDetails';
} | {
    type: 'closed';
    overlay: 'elementDetails' | 'relationshipsBrowser' | 'relationshipDetails';
} | {
    type: 'idle';
};

declare type OverlayActorEvent = {
    type: 'open.elementDetails';
} & Overlays.ElementDetails.Input | {
    type: 'open.relationshipDetails';
} & Overlays.RelationshipDetails.Input | {
    type: 'open.relationshipsBrowser';
} & Overlays.RelationshipsBrowser.Input | {
    type: 'close';
    actorId?: string | undefined;
} | {
    type: 'close.all';
};

export declare type OverlayProps = PropsWithChildren<{
    fullscreen?: boolean | undefined;
    withBackdrop?: boolean | undefined;
    overlayLevel?: number;
    className?: string;
    classes?: {
        dialog?: string;
        body?: string;
    };
    backdrop?: {
        opacity?: number;
    };
    openDelay?: number;
    onClose: () => void;
    onClick?: never;
}>;

declare namespace Overlays {
    namespace ElementDetails {
        interface Input extends Input_2 {
        }
        interface Logic extends ElementDetailsLogic {
        }
        interface ActorRef extends ElementDetailsActorRef {
        }
    }
    namespace RelationshipDetails {
        type Input = Input_4;
        interface Logic extends RelationshipDetailsLogic {
        }
        interface ActorRef extends RelationshipDetailsActorRef {
        }
    }
    namespace RelationshipsBrowser {
        interface Input extends Input_3 {
        }
        interface Logic extends RelationshipsBrowserLogic {
        }
        interface ActorRef extends RelationshipsBrowserActorRef {
        }
    }
}

declare interface OverlaysActorLogic extends StateMachine<OverlaysContext, OverlayActorEvent, {
    [key: `elementDetails-${number}`]: Overlays.ElementDetails.ActorRef | undefined;
    [key: `relationshipDetails-${number}`]: Overlays.RelationshipDetails.ActorRef | undefined;
    [key: `relationshipsBrowser-${number}`]: Overlays.RelationshipsBrowser.ActorRef | undefined;
}, any, any, any, any, any, never, never, any, OverlayActorEmitedEvent, any, any> {
}

declare interface OverlaysActorRef extends ActorRef<OverlaysActorSnapshot, OverlayActorEvent, OverlayActorEmitedEvent> {
}

declare type OverlaysActorSnapshot = SnapshotFrom<OverlaysActorLogic>;

declare interface OverlaysContext {
    seq: number;
    overlays: Array<{
        type: 'elementDetails';
        id: `elementDetails-${number}`;
        subject: Fqn;
    } | {
        type: 'relationshipDetails';
        id: `relationshipDetails-${number}`;
    } | {
        type: 'relationshipsBrowser';
        id: `relationshipsBrowser-${number}`;
        subject: Fqn;
    }>;
}

declare type OverrideReactFlowProps = Pick<ReactFlowProps<Types.AnyNode, Types.AnyEdge>, 'paneClickDistance' | 'nodeClickDistance' | 'selectionKeyCode' | 'panActivationKeyCode' | 'multiSelectionKeyCode' | 'zoomActivationKeyCode' | 'snapToGrid' | 'snapGrid' | 'onlyRenderVisibleElements' | 'nodesDraggable' | 'nodesFocusable' | 'elementsSelectable' | 'selectNodesOnDrag' | 'panOnDrag' | 'preventScrolling' | 'zoomOnScroll' | 'zoomOnPinch' | 'panOnScroll' | 'panOnScrollSpeed' | 'panOnScrollMode' | 'zoomOnDoubleClick' | 'nodeDragThreshold'>;

export declare type PaddingUnit = 'px' | '%';

export declare type PaddingWithUnit = `${number}${PaddingUnit}` | number;

declare interface ParameterizedObject {
    type: string;
    params?: NonReducibleUnknown;
}

declare type PartialEventDescriptor<TEventType extends string> = TEventType extends `${infer TLeading}.${infer TTail}` ? `${TLeading}.*` | `${TLeading}.${PartialEventDescriptor<TTail>}` : never;

declare type PickEmittedEvent<T> = T extends DiagramEmittedEvents['type'] ? DiagramEmittedEvents & {
    type: T;
} : unknown;

/**
 * Picks appropriate bounds from the view,
 * depending on its type and dynamic variant
 */
export declare function pickViewBounds(view: LayoutedView, dynamicVariant?: DynamicViewDisplayVariant): BBox;

/**
 * PortalToContainer is used to render elements outside the LikeC4DiagramXYFlow, but inside the container.
 * It is used internally by the library.
 */
export declare function PortalToContainer({ children }: PropsWithChildren): JSX.Element;

declare type ProjectsOverviewProps = {
    view: LayoutedProjectsView;
    /**
     * Callback when project is selected (e.g. clicked)
     */
    onNavigateToProject?: undefined | ((projectId: ProjectId_2) => void);
    fitViewPadding?: ViewPadding | undefined;
} & ProjectsOverviewXYProps;

declare type ProjectsOverviewXYProps = {
    /**
     * Background pattern
     * @default 'dots'
     */
    background?: 'dots' | 'lines' | 'cross' | 'transparent' | 'solid' | undefined;
    /**
     * @default - determined by the user's system preferences.
     */
    colorScheme?: 'light' | 'dark' | undefined;
};

declare type PromiseActorLogic<TOutput, TInput = unknown, TEmitted extends EventObject = EventObject> = ActorLogic<PromiseSnapshot<TOutput, TInput>, {
    type: string;
    [k: string]: unknown;
}, TInput, // input
AnyActorSystem, TEmitted>;

declare type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {
    input: TInput | undefined;
};

declare interface ProvidedActor {
    src: string;
    logic: UnknownActorLogic;
    id?: string | undefined;
}

/**
 * Ready-to-use component to display embedded LikeC4 view, same as {@link LikeC4View}
 * But provides more control over the diagram
 *
 * Component is wrapped in ShadowRoot to isolate styles.
 */
export declare function ReactLikeC4<A extends t.aux.Any = t.aux.UnknownLayouted>({ viewId, className, colorScheme, injectFontCss, enableNotations, keepAspectRatio, style, mantineTheme, styleNonce, ...props }: ReactLikeC4Props<A>): JSX.Element;

export declare type ReactLikeC4Props<A extends t.aux.Any = t.aux.UnknownLayouted> = {
    viewId: t.aux.ViewId<A>;
    /**
     * Keep aspect ratio of the diagram
     *
     * @default false
     */
    keepAspectRatio?: boolean | undefined;
    /**
     * By default determined by the user's system preferences.
     */
    colorScheme?: 'light' | 'dark' | undefined;
    /**
     * LikeC4 views are using 'IBM Plex Sans' font.
     * By default, component injects the CSS to document head.
     * Set to false if you want to handle the font yourself.
     *
     * @default true
     */
    injectFontCss?: boolean | undefined;
    style?: CSSProperties | undefined;
    mantineTheme?: any;
    /** Function to generate nonce attribute added to all generated `<style />` tags */
    styleNonce?: string | (() => string) | undefined;
    children?: ReactNode | undefined;
} & Omit<LikeC4DiagramProperties<A>, 'view'> & LikeC4DiagramEventHandlers<A>;

declare type RelationId = t.aux.RelationId;

declare interface RelationshipDetailsActorRef extends ActorRef<RelationshipDetailsSnapshot, Events_3> {
}

declare interface RelationshipDetailsLogic extends StateMachine<Context_3, Events_3, {}, any, any, any, any, any, Tags_2, Input_4, any, any, any, any> {
}

declare type RelationshipDetailsSnapshot = SnapshotFrom<RelationshipDetailsLogic>;

declare namespace RelationshipDetailsTypes {
    type Column = 'sources' | 'targets';
    /**
     * The node's incoming and outgoing ports
     */
    type Ports = {
        in: string[];
        out: string[];
    };
    type ElementNodeData = Simplify<BaseNodeData & NonOptional<Pick<DiagramNode, 'id' | 'title' | 'technology' | 'description' | 'color' | 'shape' | 'width' | 'height' | 'navigateTo' | 'style' | 'tags'>> & {
        column: Column;
        fqn: Fqn;
        icon: IconUrl;
        ports: Ports;
    }>;
    type CompoundNodeData = Simplify<BaseNodeData & NonOptional<Pick<DiagramNode, 'id' | 'title' | 'color' | 'style'>> & {
        column: Column;
        fqn: Fqn;
        depth: number;
        icon?: IconUrl;
        ports: Ports;
    }>;
    type ElementNode = BaseNode<ElementNodeData, 'element'>;
    type CompoundNode = BaseNode<CompoundNodeData, 'compound'>;
    type AnyNode = ElementNode | CompoundNode;
    type NodeType = AnyNode['type'];
    type Node<T extends NodeType = NodeType> = Extract<AnyNode, {
        type: T;
    }>;
    type NodeProps<T extends NodeType = NodeType> = BaseNodeProps<Node<T>>;
    type NodeData = ExclusiveUnion<{
        ElementNodeData: ElementNodeData;
        CompoundNodeData: CompoundNodeData;
    }>;
    type NodeRenderer<T extends NodeType = NodeType> = FunctionComponent<NodeProps<T>>;
    type NodeRenderers = {
        element: NodeRenderer<'element'>;
        compound: NodeRenderer<'compound'>;
    };
    type EdgeData = Simplify<BaseEdgeData & {
        relationId: RelationId_2;
        color: Color;
        label: string | null;
        technology?: string | undefined;
        navigateTo: ViewId | null;
        line: RelationshipLineType;
        head?: RelationshipArrowType;
        tail?: RelationshipArrowType;
        description: MarkdownOrString | null;
    }>;
    type Edge = BaseEdge<EdgeData, 'relationship'>;
    type EdgeProps = BaseEdgeProps<Edge>;
}

declare interface RelationshipsBrowserActorRef extends ActorRef<RelationshipsBrowserSnapshot, Events_2> {
}

declare interface RelationshipsBrowserLogic extends StateMachine<Context_2, Events_2, {}, any, any, any, any, any, Tags, Input_3, any, any, any, any> {
}

declare type RelationshipsBrowserSnapshot = SnapshotFrom<RelationshipsBrowserLogic>;

declare namespace RelationshipsBrowserTypes {
    type Column = 'incomers' | 'subjects' | 'outgoers';
    /**
     * The node's incoming and outgoing ports
     */
    type Ports = {
        in: string[];
        out: string[];
    };
    type ElementNodeData = Simplify<BaseNodeData & NonOptional<Pick<DiagramNode, 'id' | 'title' | 'technology' | 'description' | 'color' | 'shape' | 'style' | 'width' | 'height' | 'tags' | 'navigateTo'>> & {
        column: Column;
        fqn: Fqn;
        icon: string | null;
        ports: Ports;
        existsInCurrentView: boolean;
    }>;
    type CompoundNodeData = Simplify<BaseNodeData & NonOptional<Pick<DiagramNode, 'id' | 'title' | 'color' | 'shape' | 'style'>> & {
        column: Column;
        fqn: Fqn;
        depth: number;
        icon: IconUrl;
        ports: Ports;
        existsInCurrentView: boolean;
    }>;
    type EmptyNodeData = BaseNodeData & {
        column: Column;
    };
    type ElementNode = BaseNode<ElementNodeData, 'element'>;
    type CompoundNode = BaseNode<CompoundNodeData, 'compound'>;
    type EmptyNode = BaseNode<EmptyNodeData, 'empty'>;
    type AnyNode = ElementNode | CompoundNode | EmptyNode;
    type NodeType = AnyNode['type'];
    type Node<T extends NodeType = NodeType> = Extract<AnyNode, {
        type: T;
    }>;
    type NodeProps<T extends NodeType = NodeType> = BaseNodeProps<Node<T>>;
    type NodeData = ExclusiveUnion<{
        ElementNodeData: ElementNodeData;
        CompoundNodeData: CompoundNodeData;
        EmptyNodeData: EmptyNodeData;
    }>;
    type NodeRenderer<T extends NodeType = NodeType> = FunctionComponent<NodeProps<T>>;
    type NodeRenderers = {
        [T in NodeType]: NodeRenderer<T>;
    };
    type EdgeData = Simplify<BaseEdgeData & {
        sourceFqn: Fqn;
        targetFqn: Fqn;
        relations: NonEmptyArray<RelationId_2>;
        color: Color;
        label: string | null;
        navigateTo: ViewId | null;
        line: RelationshipLineType;
        head?: RelationshipArrowType;
        tail?: RelationshipArrowType;
        existsInCurrentView: boolean;
    }>;
    type Edge = BaseEdge<EdgeData, 'relationship'>;
    type EdgeProps = BaseEdgeProps<Edge>;
}

declare type RequiredActorOptions<TActor extends ProvidedActor> = (undefined extends TActor['id'] ? never : 'id') | (undefined extends InputFrom<TActor['logic']> ? never : 'input');

declare type RequiredData = {
    color: Color;
    depth: number;
    style: ElementStyle;
};

declare type RequiredData_2 = {
    id: NodeId;
    title: string;
    color: Color;
    style: ComputedNodeStyle;
    icon?: string | null;
};

declare type RequiredData_3 = {
    id: NodeId_3;
    title: string;
    technology?: string | null | undefined;
    color: Color;
    style: ComputedNodeStyle_2;
    description?: MarkdownOrString_2 | null | undefined;
    icon?: string | null;
};

declare type RequiredData_4 = {
    color: Color;
    shape: ElementShape_2;
    style?: ElementStyle;
};

declare type RequiredLogicInput<TLogic extends AnyActorLogic> = undefined extends InputFrom<TLogic> ? never : 'input';

declare type RequiredOrNull<T> = {
    [P in keyof T]-?: NonNullable<T[P]> | null;
};

/** @deprecated */
declare interface ResolvedStateMachineTypes<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TTag extends string, TEmitted extends EventObject = EventObject> {
    context: TContext;
    events: TEvent;
    actors: TActor;
    actions: TAction;
    guards: TGuard;
    delays: TDelay;
    tags: TTag;
    emitted: TEmitted;
}

declare type ReturnTypeOrValue<T> = T extends AnyFunction ? ReturnType<T> : T;

declare interface ScheduledEvent {
    id: string;
    event: EventObject;
    startedAt: number;
    delay: number;
    source: AnyActorRef;
    target: AnyActorRef;
}

declare interface Scheduler {
    schedule(source: AnyActorRef, target: AnyActorRef, event: EventObject, delay: number, id: string | undefined): void;
    cancel(source: AnyActorRef, id: string): void;
    cancelAll(actorRef: AnyActorRef): void;
}

declare type SearchActorEvent = {
    type: 'open';
    search?: string | undefined;
} | {
    type: 'close';
} | {
    type: 'change.search';
    search: string;
} | {
    type: 'pickview.open';
    elementFqn: Fqn;
} | {
    type: 'pickview.close';
};

declare interface SearchActorLogic extends StateMachine<SearchContext, SearchActorEvent, {}, any, any, any, any, any, never, never, any, any, any, any> {
}

declare interface SearchActorRef extends ActorRef<SearchActorSnapshot, SearchActorEvent> {
}

declare type SearchActorSnapshot = SnapshotFrom<SearchActorLogic>;

declare interface SearchContext {
    openedWithSearch: string | null;
    searchValue: string;
    pickViewFor: Fqn | null;
}

export declare function SequenceActorNode(props: Types.NodeProps<'seq-actor'>): JSX.Element;

export declare function sequenceActorNode<A extends Any_5 = Unknown_3>(component: FC<SequenceActorNodeProps<A>>): Types.NodeRenderer<'seq-actor'>;

export declare type SequenceActorNodeProps<A extends Any_5 = Unknown_3> = {
    nodeProps: Types.NodeProps<'seq-actor'>;
    nodeModel: NodeModel.WithElement<A>;
};

export declare function SequenceParallelArea(props: Types.NodeProps<'seq-parallel'>): JSX.Element;

declare function setData<E extends WithData<any>>(value: E, state: Partial<E['data']>): E;

declare function setData<E extends WithData<any>>(state: Partial<NoInfer<E['data']>>): (value: E) => E;

declare function setDimmed<T extends WithDimmed>(value: T, dimmed: 'immediate' | boolean): T;

declare function setDimmed(dimmed: 'immediate' | boolean): <T extends WithDimmed>(value: T) => T;

declare function setHovered<T extends WithHovered>(value: T, hovered: boolean): T;

declare function setHovered(hovered: boolean): <T extends WithHovered>(value: T) => T;

declare const ShadowRoot_2: ForwardRefExoticComponent<HTMLAttributes<HTMLDivElement> & {
    injectFontCss?: boolean | undefined;
    styleNonce?: string | (() => string) | undefined;
    mode?: "open" | "closed";
    delegatesFocus?: boolean;
    colorScheme?: "light" | "dark" | undefined;
    keepAspectRatio?: false | undefined | {
        width: number;
        height: number;
    };
    theme?: MantineThemeOverride | undefined;
} & RefAttributes<HTMLDivElement>>;
export { ShadowRoot_2 as ShadowRoot }

declare type SingleOrArray<T> = readonly T[] | T;

declare type SlotProps = {
    data: RequiredData_3;
    className?: string;
    style?: CSSProperties;
};

declare type Snapshot<TOutput> = {
    status: 'active';
    output: undefined;
    error: undefined;
} | {
    status: 'done';
    output: TOutput;
    error: undefined;
} | {
    status: 'error';
    output: undefined;
    error: unknown;
} | {
    status: 'stopped';
    output: undefined;
    error: undefined;
};

declare interface SnapshotEvent<TSnapshot extends Snapshot<unknown> = Snapshot<unknown>> extends EventObject {
    type: `xstate.snapshot.${string}`;
    snapshot: TSnapshot;
}

declare type SnapshotFrom<T> = ReturnTypeOrValue<T> extends infer R ? R extends ActorRef<infer TSnapshot, infer _, infer __> ? TSnapshot : R extends Actor<infer TLogic> ? SnapshotFrom<TLogic> : R extends ActorLogic<infer _TSnapshot, infer _TEvent, infer _TInput, infer _TEmitted, infer _TSystem> ? ReturnType<R['transition']> : R extends ActorScope<infer TSnapshot, infer _TEvent, infer _TEmitted, infer _TSystem> ? TSnapshot : never : never;

declare type SnapshotStatus = 'active' | 'done' | 'error' | 'stopped';

declare type Spawner<TActor extends ProvidedActor> = IsLiteralString<TActor['src']> extends true ? {
    <TSrc extends TActor['src']>(logic: TSrc, ...[options]: SpawnOptions<TActor, TSrc>): ActorRefFromLogic<GetConcreteByKey<TActor, 'src', TSrc>['logic']>;
    <TLogic extends AnyActorLogic>(src: TLogic, ...[options]: ConditionalRequired<[
    options?: {
        id?: never;
        systemId?: string;
        input?: InputFrom<TLogic>;
        syncSnapshot?: boolean;
    } & {
        [K in RequiredLogicInput<TLogic>]: unknown;
    }
    ], IsNotNever<RequiredLogicInput<TLogic>>>): ActorRefFromLogic<TLogic>;
} : <TLogic extends AnyActorLogic | string>(src: TLogic, ...[options]: ConditionalRequired<[
options?: {
    id?: string;
    systemId?: string;
    input?: TLogic extends string ? unknown : InputFrom<TLogic>;
    syncSnapshot?: boolean;
} & (TLogic extends AnyActorLogic ? {
    [K in RequiredLogicInput<TLogic>]: unknown;
} : {})
], IsNotNever<TLogic extends AnyActorLogic ? RequiredLogicInput<TLogic> : never>>) => TLogic extends AnyActorLogic ? ActorRefFromLogic<TLogic> : AnyActorRef;

declare type SpawnOptions<TActor extends ProvidedActor, TSrc extends TActor['src']> = TActor extends {
    src: TSrc;
} ? ConditionalRequired<[
options?: {
    id?: TActor['id'];
    systemId?: string;
    input?: InputFrom<TActor['logic']>;
    syncSnapshot?: boolean;
} & {
    [K in RequiredActorOptions<TActor>]: unknown;
}
], IsNotNever<RequiredActorOptions<TActor>>> : never;

declare type StateId<TSchema extends StateSchema, TKey extends string = '(machine)', TParentKey extends string | null = null> = (TSchema extends {
    id: string;
} ? TSchema['id'] : TParentKey extends null ? TKey : `${TParentKey}.${TKey}`) | (TSchema['states'] extends Record<string, any> ? Values<{
    [K in keyof TSchema['states'] & string]: StateId<TSchema['states'][K], K, TParentKey extends string ? `${TParentKey}.${TKey}` : TSchema['id'] extends string ? TSchema['id'] : TKey>;
}> : never);

declare class StateMachine<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TStateValue extends StateValue, TTag extends string, TInput, TOutput, TEmitted extends EventObject, TMeta extends MetaObject, TConfig extends StateSchema> implements ActorLogic<MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, TEvent, TInput, AnyActorSystem, TEmitted> {
    /** The raw config used to create the machine. */
    config: MachineConfig<TContext, TEvent, any, any, any, any, any, any, TOutput, any, // TEmitted
    any> & {
        schemas?: unknown;
    };
    /** The machine's own version. */
    version?: string;
    schemas: unknown;
    implementations: MachineImplementationsSimplified<TContext, TEvent>;
    root: StateNode<TContext, TEvent>;
    id: string;
    states: StateNode<TContext, TEvent>['states'];
    events: Array<EventDescriptor<TEvent>>;
    constructor(
    /** The raw config used to create the machine. */
    config: MachineConfig<TContext, TEvent, any, any, any, any, any, any, TOutput, any, // TEmitted
    any> & {
        schemas?: unknown;
    }, implementations?: MachineImplementationsSimplified<TContext, TEvent>);
    /**
     * Clones this state machine with the provided implementations.
     *
     * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to
     *   recursively merge with the existing options.
     * @returns A new `StateMachine` instance with the provided implementations.
     */
    provide(implementations: InternalMachineImplementations<ResolvedStateMachineTypes<TContext, DoNotInfer<TEvent>, TActor, TAction, TGuard, TDelay, TTag, TEmitted>>): StateMachine<TContext, TEvent, TChildren, TActor, TAction, TGuard, TDelay, TStateValue, TTag, TInput, TOutput, TEmitted, TMeta, TConfig>;
    resolveState(config: {
        value: StateValue;
        context?: TContext;
        historyValue?: HistoryValue<TContext, TEvent>;
        status?: SnapshotStatus;
        output?: TOutput;
        error?: unknown;
    } & (Equals<TContext, MachineContext> extends false ? {
        context: unknown;
    } : {})): MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>;
    /**
     * Determines the next snapshot given the current `snapshot` and received
     * `event`. Calculates a full macrostep from all microsteps.
     *
     * @param snapshot The current snapshot
     * @param event The received event
     */
    transition(snapshot: MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, event: TEvent, actorScope: ActorScope<typeof snapshot, TEvent, AnyActorSystem, TEmitted>): MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>;
    /**
     * Determines the next state given the current `state` and `event`. Calculates
     * a microstep.
     *
     * @param state The current state
     * @param event The received event
     */
    microstep(snapshot: MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, event: TEvent, actorScope: AnyActorScope): Array<MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>>;
    getTransitionData(snapshot: MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, event: TEvent): Array<TransitionDefinition<TContext, TEvent>>;
    /**
     * The initial state _before_ evaluating any microsteps. This "pre-initial"
     * state is provided to initial actions executed in the initial state.
     */
    private getPreInitialState;
    /**
     * Returns the initial `State` instance, with reference to `self` as an
     * `ActorRef`.
     */
    getInitialSnapshot(actorScope: ActorScope<MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, TEvent, AnyActorSystem, TEmitted>, input?: TInput): MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>;
    start(snapshot: MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>): void;
    getStateNodeById(stateId: string): StateNode<TContext, TEvent>;
    get definition(): StateMachineDefinition<TContext, TEvent>;
    toJSON(): StateMachineDefinition<TContext, TEvent>;
    getPersistedSnapshot(snapshot: MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, options?: unknown): Snapshot<unknown>;
    restoreSnapshot(snapshot: Snapshot<unknown>, _actorScope: ActorScope<MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>, TEvent, AnyActorSystem, TEmitted>): MachineSnapshot<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig>;
}

declare interface StateMachineDefinition<TContext extends MachineContext, TEvent extends EventObject> extends StateNodeDefinition<TContext, TEvent> {
}

declare interface StateMachineTypes {
    context: MachineContext;
    events: EventObject;
    actors: ProvidedActor;
    actions: ParameterizedObject;
    guards: ParameterizedObject;
    delays: string;
    tags: string;
    emitted: EventObject;
}

declare class StateNode<TContext extends MachineContext = MachineContext, TEvent extends EventObject = EventObject> {
    /** The raw config used to create the machine. */
    config: StateNodeConfig<TContext, TEvent, TODO, // actors
    TODO, // actions
    TODO, // guards
    TODO, // delays
    TODO, // tags
    TODO, // output
    TODO, // emitted
    TODO>;
    /**
     * The relative key of the state node, which represents its location in the
     * overall state value.
     */
    key: string;
    /** The unique ID of the state node. */
    id: string;
    /**
     * The type of this state node:
     *
     * - `'atomic'` - no child state nodes
     * - `'compound'` - nested child state nodes (XOR)
     * - `'parallel'` - orthogonal nested child state nodes (AND)
     * - `'history'` - history state node
     * - `'final'` - final state node
     */
    type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';
    /** The string path from the root machine node to this node. */
    path: string[];
    /** The child state nodes. */
    states: StateNodesConfig<TContext, TEvent>;
    /**
     * The type of history on this state node. Can be:
     *
     * - `'shallow'` - recalls only top-level historical state value
     * - `'deep'` - recalls historical state value at all levels
     */
    history: false | 'shallow' | 'deep';
    /** The action(s) to be executed upon entering the state node. */
    entry: UnknownAction[];
    /** The action(s) to be executed upon exiting the state node. */
    exit: UnknownAction[];
    /** The parent state node. */
    parent?: StateNode<TContext, TEvent>;
    /** The root machine node. */
    machine: StateMachine<TContext, TEvent, any, // children
    any, // actor
    any, // action
    any, // guard
    any, // delay
    any, // state value
    any, // tag
    any, // input
    any, // output
    any, // emitted
    any, // meta
    any>;
    /**
     * The meta data associated with this state node, which will be returned in
     * State instances.
     */
    meta?: any;
    /**
     * The output data sent with the "xstate.done.state._id_" event if this is a
     * final state node.
     */
    output?: Mapper<MachineContext, EventObject, unknown, EventObject> | NonReducibleUnknown;
    /**
     * The order this state node appears. Corresponds to the implicit document
     * order.
     */
    order: number;
    description?: string;
    tags: string[];
    transitions: Map<string, TransitionDefinition<TContext, TEvent>[]>;
    always?: Array<TransitionDefinition<TContext, TEvent>>;
    constructor(
    /** The raw config used to create the machine. */
    config: StateNodeConfig<TContext, TEvent, TODO, // actors
    TODO, // actions
    TODO, // guards
    TODO, // delays
    TODO, // tags
    TODO, // output
    TODO, // emitted
    TODO>, options: StateNodeOptions<TContext, TEvent>);
    /** The well-structured state node definition. */
    get definition(): StateNodeDefinition<TContext, TEvent>;
    /** The logic invoked as actors by this state node. */
    get invoke(): Array<InvokeDefinition<TContext, TEvent, ProvidedActor, ParameterizedObject, ParameterizedObject, string, TODO, // TEmitted
    TODO>>;
    /** The mapping of events to transitions. */
    get on(): TransitionDefinitionMap<TContext, TEvent>;
    get after(): Array<DelayedTransitionDefinition<TContext, TEvent>>;
    get initial(): InitialTransitionDefinition<TContext, TEvent>;
    /** All the event types accepted by this state node and its descendants. */
    get events(): Array<EventDescriptor<TEvent>>;
    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get ownEvents(): Array<EventDescriptor<TEvent>>;
}

declare interface StateNodeConfig<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TTag extends string, _TOutput, TEmitted extends EventObject, TMeta extends MetaObject> {
    /** The initial state transition. */
    initial?: InitialTransitionConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay> | string | undefined;
    /**
     * The type of this state node:
     *
     * - `'atomic'` - no child state nodes
     * - `'compound'` - nested child state nodes (XOR)
     * - `'parallel'` - orthogonal nested child state nodes (AND)
     * - `'history'` - history state node
     * - `'final'` - final state node
     */
    type?: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';
    /**
     * Indicates whether the state node is a history state node, and what type of
     * history: shallow, deep, true (shallow), false (none), undefined (none)
     */
    history?: 'shallow' | 'deep' | boolean | undefined;
    /**
     * The mapping of state node keys to their state node configurations
     * (recursive).
     */
    states?: StatesConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay, TTag, NonReducibleUnknown, TEmitted, TMeta> | undefined;
    /**
     * The services to invoke upon entering this state node. These services will
     * be stopped upon exiting this state node.
     */
    invoke?: SingleOrArray<InvokeConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;
    /** The mapping of event types to their potential transition(s). */
    on?: TransitionsConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>;
    /** The action(s) to be executed upon entering the state node. */
    entry?: Actions<TContext, TEvent, TEvent, undefined, TActor, TAction, TGuard, TDelay, TEmitted>;
    /** The action(s) to be executed upon exiting the state node. */
    exit?: Actions<TContext, TEvent, TEvent, undefined, TActor, TAction, TGuard, TDelay, TEmitted>;
    /**
     * The potential transition(s) to be taken upon reaching a final child state
     * node.
     *
     * This is equivalent to defining a `[done(id)]` transition on this state
     * node's `on` property.
     */
    onDone?: string | SingleOrArray<TransitionConfig<TContext, DoneStateEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>> | undefined;
    /**
     * The mapping (or array) of delays (in milliseconds) to their potential
     * transition(s). The delayed transitions are taken after the specified delay
     * in an interpreter.
     */
    after?: DelayedTransitions<TContext, TEvent, TActor, TAction, TGuard, TDelay>;
    /**
     * An eventless transition that is always taken when this state node is
     * active.
     */
    always?: TransitionConfigOrTarget<TContext, TEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>;
    parent?: StateNode<TContext, TEvent>;
    /**
     * The meta data associated with this state node, which will be returned in
     * State instances.
     */
    meta?: TMeta;
    /**
     * The output data sent with the "xstate.done.state._id_" event if this is a
     * final state node.
     *
     * The output data will be evaluated with the current `context` and placed on
     * the `.data` property of the event.
     */
    output?: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;
    /**
     * The unique ID of the state node, which can be referenced as a transition
     * target via the `#id` syntax.
     */
    id?: string | undefined;
    /**
     * The order this state node appears. Corresponds to the implicit document
     * order.
     */
    order?: number;
    /**
     * The tags for this state node, which are accumulated into the `state.tags`
     * property.
     */
    tags?: SingleOrArray<TTag>;
    /** A text description of the state node */
    description?: string;
    /** A default target for a history state */
    target?: string | undefined;
}

declare interface StateNodeDefinition<TContext extends MachineContext, TEvent extends EventObject> {
    id: string;
    version?: string | undefined;
    key: string;
    type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';
    initial: InitialTransitionDefinition<TContext, TEvent> | undefined;
    history: boolean | 'shallow' | 'deep' | undefined;
    states: StatesDefinition<TContext, TEvent>;
    on: TransitionDefinitionMap<TContext, TEvent>;
    transitions: Array<TransitionDefinition<TContext, TEvent>>;
    entry: UnknownAction[];
    exit: UnknownAction[];
    meta: any;
    order: number;
    output?: StateNodeConfig<TContext, TEvent, ProvidedActor, ParameterizedObject, ParameterizedObject, string, string, unknown, EventObject, // TEmitted
    any>['output'];
    invoke: Array<InvokeDefinition<TContext, TEvent, TODO, TODO, TODO, TODO, TODO, // TEmitted
    TODO>>;
    description?: string;
    tags: string[];
}

declare interface StateNodeOptions<TContext extends MachineContext, TEvent extends EventObject> {
    _key: string;
    _parent?: StateNode<TContext, TEvent>;
    _machine: AnyStateMachine;
}

declare type StateNodesConfig<TContext extends MachineContext, TEvent extends EventObject> = {
    [K in string]: StateNode<TContext, TEvent>;
};

declare type StateSchema = {
    id?: string;
    states?: Record<string, StateSchema>;
    type?: unknown;
    invoke?: unknown;
    on?: unknown;
    entry?: unknown;
    exit?: unknown;
    onDone?: unknown;
    after?: unknown;
    always?: unknown;
    meta?: unknown;
    output?: unknown;
    tags?: unknown;
    description?: unknown;
};

declare type StatesConfig<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TTag extends string, TOutput, TEmitted extends EventObject, TMeta extends MetaObject> = {
    [K in string]: StateNodeConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay, TTag, TOutput, TEmitted, TMeta>;
};

declare type StatesDefinition<TContext extends MachineContext, TEvent extends EventObject> = {
    [K in string]: StateNodeDefinition<TContext, TEvent>;
};

/**
 * The string or object representing the state value relative to the parent
 * state node.
 *
 * @remarks
 * - For a child atomic state node, this is a string, e.g., `"pending"`.
 * - For complex state nodes, this is an object, e.g., `{ success:
 *   "someChildState" }`.
 */
declare type StateValue = string | StateValueMap;

declare interface StateValueMap {
    [key: string]: StateValue | undefined;
}

/* Excluded from this release type: StaticLikeC4Diagram */

declare type StaticLikeC4DiagramProps<A extends Any> = Pick<LikeC4DiagramProperties<A>, 'view' | 'className' | 'fitView' | 'fitViewPadding' | 'background' | 'enableElementDetails' | 'enableRelationshipDetails' | 'enableRelationshipBrowser' | 'enableElementTags' | 'reduceGraphics' | 'initialWidth' | 'initialHeight' | 'renderIcon' | 'renderNodes' | 'dynamicViewVariant' | 'where'>;

declare interface StopAction<TContext extends MachineContext, TExpressionEvent extends EventObject, TParams extends ParameterizedObject['params'] | undefined, TEvent extends EventObject> {
    (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;
}

declare interface StoppedMachineSnapshot<TContext extends MachineContext, TEvent extends EventObject, TChildren extends Record<string, AnyActorRef | undefined>, TStateValue extends StateValue, TTag extends string, TOutput, TMeta extends MetaObject, TConfig extends StateSchema> extends MachineSnapshotBase<TContext, TEvent, TChildren, TStateValue, TTag, TOutput, TMeta, TConfig> {
    status: 'stopped';
    output: undefined;
    error: undefined;
}

declare type StrictViewId<A> = t.aux.StrictViewId<A>;

declare type Subject = {
    edgeId: EdgeId_2;
    source?: never;
    target?: never;
} | {
    source: Fqn_3;
    target: Fqn_3;
    edgeId?: never;
};

declare interface Subscribable<T> extends InteropSubscribable<T> {
    subscribe(observer: Observer<T>): Subscription;
    subscribe(next: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
}

declare interface Subscription {
    unsubscribe(): void;
}

declare const symbolObservable: typeof Symbol.observable;

declare type System = ActorSystem<{
    actors: {
        diagram: DiagramMachineRef;
        overlays: OverlaysActorRef;
        search: SearchActorRef;
        editor: EditorActorRef;
    };
}>;

declare type Tags = 'active';

declare type Tags_2 = never;

declare type TODO = any;

declare type TogglableFeature = ('ReadOnly' | 'CompareWithLatest') & FeatureName;

declare type ToggledFeatures = {
    [P in `enable${TogglableFeature}`]?: boolean;
};

export declare function Toolbar({ title, children, nodeProps, ...props }: ToolbarProps): JSX.Element | null;

declare type ToolbarProps = Omit<NodeToolbarProps, 'title'> & {
    nodeProps: BaseNodeProps;
    title: ReactNode;
};

declare type ToTestStateValue<TStateValue extends StateValue> = TStateValue extends string ? TStateValue : IsNever<keyof TStateValue> extends true ? never : keyof TStateValue | {
    [K in keyof TStateValue]?: ToTestStateValue<NonNullable<TStateValue[K]>>;
};

declare interface TransitionConfig<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject = EventObject, TMeta extends MetaObject = MetaObject> {
    guard?: Guard<TContext, TExpressionEvent, undefined, TGuard>;
    actions?: Actions<TContext, TExpressionEvent, TEvent, undefined, TActor, TAction, TGuard, TDelay, TEmitted>;
    reenter?: boolean;
    target?: TransitionTarget | undefined;
    meta?: TMeta;
    description?: string;
}

declare type TransitionConfigOrTarget<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject, TMeta extends MetaObject> = SingleOrArray<TransitionConfigTarget | TransitionConfig<TContext, TExpressionEvent, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>>;

declare type TransitionConfigTarget = string | undefined;

declare interface TransitionDefinition<TContext extends MachineContext, TEvent extends EventObject> extends Omit<TransitionConfig<TContext, TEvent, TEvent, TODO, TODO, TODO, TODO, TODO, // TEmitted
TODO>, 'target' | 'guard'> {
    target: ReadonlyArray<StateNode<TContext, TEvent>> | undefined;
    source: StateNode<TContext, TEvent>;
    actions: readonly UnknownAction[];
    reenter: boolean;
    guard?: UnknownGuard;
    eventType: EventDescriptor<TEvent>;
    toJSON: () => {
        target: string[] | undefined;
        source: string;
        actions: readonly UnknownAction[];
        guard?: UnknownGuard;
        eventType: EventDescriptor<TEvent>;
        meta?: Record<string, any>;
    };
}

declare type TransitionDefinitionMap<TContext extends MachineContext, TEvent extends EventObject> = {
    [K in EventDescriptor<TEvent>]: Array<TransitionDefinition<TContext, ExtractEvent<TEvent, K>>>;
};

declare type TransitionsConfig<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TEmitted extends EventObject, TMeta extends MetaObject> = {
    [K in EventDescriptor<TEvent>]?: TransitionConfigOrTarget<TContext, ExtractEvent<TEvent, K>, TEvent, TActor, TAction, TGuard, TDelay, TEmitted, TMeta>;
};

declare type TransitionTarget = SingleOrArray<string>;

declare type TXYMiniMap = typeof MiniMap_2<Types.AnyNode>

export declare namespace Types {
    export type LeafNodeData = Simplify<BaseNodeData & NonOptional<Pick<DiagramNode, 'id' | 'title' | 'technology' | 'description' | 'color' | 'shape' | 'width' | 'level' | 'height' | 'style' | 'tags' | 'x' | 'y'>> & {
        /**
         * View this node belongs to
         */
        viewId: ViewId;
        isMultiple?: boolean | undefined;
        icon: string | null;
        drifts: NonEmptyReadonlyArray<DiagramNodeDriftReason> | null;
    }>;
    /**
     * Represents element from logical model
     */
    export type ElementNodeData = Simplify<LeafNodeData & {
        modelFqn: Fqn;
        deploymentFqn?: never;
        /**
         * If set - this node has navigation to another view and diagram has handler for this
         */
        navigateTo: ViewId | null;
    }>;
    /**
     * Represents element from deployment model
     */
    export type DeploymentElementNodeData = Simplify<LeafNodeData & {
        navigateTo: ViewId | null;
        deploymentFqn: DeploymentFqn;
        modelFqn: Fqn | null;
    }>;
    export type SequenceActorNodePort = {
        id: string;
        cx: number;
        cy: number;
        height: number;
        type: 'target' | 'source';
        position: 'left' | 'right' | 'top' | 'bottom';
    };
    export type SequenceActorNodeData = Simplify<LeafNodeData & {
        navigateTo: ViewId | null;
        modelFqn: Fqn | null;
        ports: Array<SequenceActorNodePort>;
        viewHeight: number;
    }>;
    export type SequenceParallelAreaData = Simplify<LeafNodeData & {
        parallelPrefix: string;
    }>;
    export type CompoundNodeData = Simplify<BaseNodeData & NonOptional<Pick<DiagramNode, 'id' | 'title' | 'color' | 'shape' | 'style' | 'tags' | 'x' | 'y'>> & {
        /**
         * View this node belongs to
         */
        viewId: ViewId;
        depth: number;
        icon?: IconUrl;
        drifts: NonEmptyReadonlyArray<DiagramNodeDriftReason> | null;
    }>;
    export type CompoundElementNodeData = Simplify<CompoundNodeData & {
        modelFqn: Fqn;
        deploymentFqn?: never;
        /**
         * If set - this node has navigation to another view and diagram has handler for this
         */
        navigateTo: ViewId | null;
    }>;
    export type CompoundDeploymentNodeData = Simplify<CompoundNodeData & {
        deploymentFqn: DeploymentFqn;
        /**
         * If set - this node refers to a model element
         */
        modelFqn: Fqn | null;
        /**
         * If set - this node has navigation to another view and diagram has handler for this
         */
        navigateTo: ViewId | null;
    }>;
    export type ViewGroupNodeData = Simplify<CompoundNodeData & {
        isViewGroup: true;
    }>;
    export type ElementNode = BaseNode<ElementNodeData, 'element'>;
    export type DeploymentElementNode = BaseNode<DeploymentElementNodeData, 'deployment'>;
    export type SequenceActorNode = BaseNode<SequenceActorNodeData, 'seq-actor'>;
    export type SequenceParallelArea = BaseNode<SequenceParallelAreaData, 'seq-parallel'>;
    export type CompoundElementNode = BaseNode<CompoundElementNodeData, 'compound-element'>;
    export type CompoundDeploymentNode = BaseNode<CompoundDeploymentNodeData, 'compound-deployment'>;
    export type ViewGroupNode = BaseNode<ViewGroupNodeData, 'view-group'>;
    export type AnyNode = ElementNode | DeploymentElementNode | CompoundElementNode | CompoundDeploymentNode | ViewGroupNode | SequenceActorNode | SequenceParallelArea;
    export type NodeType = AnyNode['type'];
    export type NodeData = ExclusiveUnion<{
        ElementNodeData: ElementNodeData;
        DeploymentElementNodeData: DeploymentElementNodeData;
        CompoundElementNodeData: CompoundElementNodeData;
        CompoundDeploymentNodeData: CompoundDeploymentNodeData;
        ViewGroupNodeData: ViewGroupNodeData;
        SequenceActorNodeData: SequenceActorNodeData;
        SequenceParallelAreaData: SequenceParallelAreaData;
    }>;
    export type Node<Type extends NodeType = NodeType> = Extract<AnyNode, {
        type: Type;
    }>;
    export type NodeProps<Type extends NodeType = NodeType> = BaseNodeProps<Node<Type>>;
    export type RelationshipEdgeData = Simplify<BaseEdgeData & NonOptional<Pick<DiagramEdge, 'id' | 'label' | 'labelBBox' | 'technology' | 'points' | 'dir' | 'color' | 'line' | 'head' | 'tail' | 'navigateTo' | 'astPath' | 'drifts'>> & {
        notes: MarkdownOrString | null;
        labelXY: XYPosition | null;
        controlPoints: XYPosition[] | undefined | null;
    }>;
    export type SequenceStepEdgeData = Simplify<BaseEdgeData & NonOptional<Pick<DiagramEdge, 'id' | 'label' | 'technology' | 'points' | 'dir' | 'color' | 'line' | 'head' | 'tail' | 'navigateTo' | 'astPath' | 'drifts'>> & {
        notes: MarkdownOrString | null;
        labelXY: XYPosition | null;
        labelBBox: BBox;
        controlPoints: XYPosition[] | undefined | null;
    }>;
    export type RelationshipEdge = BaseEdge<RelationshipEdgeData, 'relationship'>;
    export type SequenceStepEdge = BaseEdge<SequenceStepEdgeData, 'seq-step'>;
    export type AnyEdge = RelationshipEdge | SequenceStepEdge;
    export type EdgeType = AnyEdge['type'];
    export type Edge<Type extends EdgeType = EdgeType> = Extract<AnyEdge, {
        type: Type;
    }>;
    export type EdgeProps<Type extends EdgeType = EdgeType> = BaseEdgeProps<Edge<Type>>;
    export type EdgeData = ExclusiveUnion<{
        RelationshipEdgeData: RelationshipEdgeData;
        SequenceStepEdgeData: SequenceStepEdgeData;
    }>;
    export type NodeRenderer<T extends NodeType> = FunctionComponent<NodeProps<T>>;
    export type NodeRenderers = {
        [T in NodeType]: NodeRenderer<T>;
    };
    export type EdgeRenderer<T extends EdgeType> = FunctionComponent<EdgeProps<T>>;
    export type EdgeRenderers = {
        [T in EdgeType]: EdgeRenderer<T>;
    };
}

declare interface UnifiedArg<TContext extends MachineContext, TExpressionEvent extends EventObject, TEvent extends EventObject> {
    context: TContext;
    event: TExpressionEvent;
    self: ActorRef<MachineSnapshot<TContext, TEvent, Record<string, AnyActorRef | undefined>, // TODO: this should be replaced with `TChildren`
    StateValue, string, unknown, TODO, // TMeta
    TODO>, TEvent, AnyEventObject>;
    system: AnyActorSystem;
}

declare type Unknown = t.aux.UnknownLayouted;

declare type Unknown_2 = t.aux.UnknownLayouted;

declare type Unknown_3 = aux.UnknownLayouted;

declare type UnknownAction = Action<MachineContext, EventObject, EventObject, ParameterizedObject['params'] | undefined, ProvidedActor, ParameterizedObject, ParameterizedObject, string, EventObject>;

declare type UnknownActorLogic = ActorLogic<any, // snapshot
any, // event
any, // input
AnyActorSystem, any>;

declare type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;

declare type UnknownInlineGuard = Guard<MachineContext, EventObject, undefined, ParameterizedObject>;

declare type UnknownLayouted_2 = t.aux.UnknownLayouted;

declare type UnknownReferencedGuard = Guard<MachineContext, EventObject, ParameterizedObject['params'], ParameterizedObject>;

/**
 * @returns The callback to change current project.
 */
export declare function useChangeLikeC4Project(): (id: ProjectId) => void;

/**
 * Returns current view
 * Should be used only inside LikeC4Diagram
 */
export declare function useCurrentView(): LayoutedView;

/**
 * Returns current view id
 * Should be used only inside LikeC4Diagram
 */
export declare function useCurrentViewId(): ViewId;

export declare function useCurrentViewModel(): CurrentViewModel;

export declare function useDiagram(): DiagramApi< UnknownLayouted>;

export declare function useDiagramActorRef(): DiagramActorRef;

/**
 * Read diagram context
 */
export declare function useDiagramContext<T = unknown>(selector: (context: DiagramContext) => T, compare?: (a: NoInfer<T>, b: NoInfer<T>) => boolean, deps?: DependencyList): T;

export declare function useDiagramEventHandlers(): DiagramEventHandlersContext;

export declare function useEnabledFeatures(): EnabledFeatures;

/**
 * @returns True if there are more than one project available in the context.
 */
export declare function useHasProjects(): boolean;

export declare function useLikeC4Model<A extends Any_4 = t.aux.UnknownLayouted>(): LikeC4Model<A>;

/**
 * Returns current LikeC4 project.
 * Requires both LikeC4ModelProvider and LikeC4ProjectsProvider in the tree.*
 */
export declare function useLikeC4Project(): LikeC4Project;

/**
 * @returns Current project id, as provided by LikeC4Model
 */
export declare function useLikeC4ProjectId(): ProjectId;

/**
 * @returns The list of available projects, or empty array if no projects are available.
 */
export declare function useLikeC4Projects(): ReadonlyArray<LikeC4Project>;

/**
 * @returns The callback to change current project.
 */
export declare function useLikeC4ProjectsContext(): LikeC4ProjectsContext;

export declare function useLikeC4Specification(): t.Specification<t.aux.UnknownLayouted>;

export declare function useLikeC4Styles(): LikeC4Styles;

export declare function useLikeC4ViewModel<A extends Any_4 = t.aux.UnknownLayouted>(viewId: t.aux.ViewId<A>): LikeC4ViewModel<A>;

/**
 * Subscribe to diagram emitted events
 * @example
 * ```tsx
 * useOnDiagramEvent('navigateTo', ({viewId}) => {
 *   console.log('Navigating to view', viewId)
 * })
 * ```
 */
export declare function useOnDiagramEvent<T extends DiagramEmittedEvents['type'] | '*'>(event: T, callback: (event: PickEmittedEvent<T>) => void, options?: {
    once?: boolean;
}): void;

export declare function useSetState<T extends object>(initialState: T | (() => T)): readonly [T, (statePartial: NonEmptyObject<Partial<T>> | ((current: T) => NonEmptyObject<Partial<T>>)) => void];

export declare function useUpdateEffect<Callback extends EffectCallback = EffectCallback, Deps extends DependencyList = DependencyList>(callback: Callback, deps: Deps, equalityFn?: DependenciesComparator<Deps>, effectHook?: EffectHook<Callback, Deps>): void;

declare type Values<T> = T[keyof T];

export declare function ViewGroupNode(props: Types.NodeProps<'view-group'>): JSX.Element;

/**
 * Node that will be used to render the view group from the model.
 *
 * Custom node renderer receives these props:
 * - `nodeProps`: props from XYFlow
 * - `nodeModel`: LikeC4 {@link NodeModel.IsGroup}
 *
 * @see [Default implementation](https://github.com/likec4/likec4/blob/main/packages/diagram/src/likec4diagram/custom/nodes/nodes.tsx)
 *
 * @example
 * ```tsx
 * import {
 *   viewGroupNode,
 *   CompoundNodeContainer,
 *   CompoundTitle,
 *   DefaultHandles,
 * } from '@likec4/diagram/custom'
 *
 * const CustomViewGroupNode = viewGroupNode(({ nodeProps, nodeModel }) => (
 *   <CompoundNodeContainer nodeProps={nodeProps}>
 *     <CompoundTitle {...nodeProps} />
 *     <DefaultHandles />
 *   </CompoundNodeContainer>
 * ```
 */
export declare function viewGroupNode<A extends Any_5 = Unknown_3>(component: FC<ViewGroupNodeProps<A>>): Types.NodeRenderer<'view-group'>;

export declare type ViewGroupNodeProps<A extends Any_5 = Unknown_3> = {
    nodeProps: Types.NodeProps<'view-group'>;
    nodeModel: NodeModel.IsGroup<A>;
};

declare type ViewId_2<A> = t.aux.ViewId<A>;

declare type ViewId_4<A> = t.aux.ViewId<A>;

/**
 * Padding around the diagram
 *
 * @example
 * {
 *   top: '8px',
 *   right: '8px',
 *   bottom: '8px',
 *   left: '8px',
 * }
 *
 * {
 *   x: '16px',
 *   y: '16px',
 * }
 */
export declare type ViewPadding = PaddingWithUnit | ViewPaddings;

declare type ViewPaddings = {
    top?: PaddingWithUnit;
    right?: PaddingWithUnit;
    bottom?: PaddingWithUnit;
    left?: PaddingWithUnit;
    x?: PaddingWithUnit;
    y?: PaddingWithUnit;
};

export { WhereOperator }

declare type WithData<D> = {
    data: D;
};

declare type WithDimmed = {
    data: {
        dimmed?: Base.Dimmed;
    };
};

declare type WithDynamicParams<TContext extends MachineContext, TExpressionEvent extends EventObject, T extends ParameterizedObject> = T extends any ? ConditionalRequired<{
    type: T['type'];
    params?: T['params'] | (({ context, event }: {
        context: TContext;
        event: TExpressionEvent;
    }) => T['params']);
}, undefined extends T['params'] ? false : true> : never;

declare type WithExtraButtons = {
    /**
     * Add extra action buttons
     * @example
     * ```tsx
     * <ElementActions
     *   extraButtons={[
     *     {
     *       key: 'extra',
     *       icon: <IconZoomScan />,
     *       onClick: (e) => {
     *         e.stopPropagation()
     *         console.log('extra action clicked')
     *       },
     *       },
     *     },
     *   ]}
     * />
     * ```
     */
    extraButtons?: ElementActionButtons.Item[];
};

declare type WithHovered = {
    data: {
        hovered?: boolean;
    };
};

export declare namespace XYFlow {
    export {
        MiniMap,
        MiniMapNodes,
        Align,
        ControlButton,
        Controls,
        MiniMapNode,
        MiniMapNodeProps,
        NodeToolbar,
        NodeToolbarProps,
        Panel,
        Position,
        ViewportPortal
    }
}

declare type XYFLowInstance = ReactFlowInstance<RelationshipsBrowserTypes.AnyNode, RelationshipsBrowserTypes.Edge>;

declare type XYFlowInstance = ReactFlowInstance<Types.AnyNode, Types.AnyEdge>;

declare type XYFLowInstance_2 = ReactFlowInstance<RelationshipDetailsTypes.AnyNode, RelationshipDetailsTypes.Edge>;

declare type XYStoreApi = {
    getState: () => XYStoreState;
    setState: (state: Partial<XYStoreState> | ((state: XYStoreState) => Partial<XYStoreState>)) => void;
    subscribe: (listener: (state: XYStoreState, prevState: XYStoreState) => void) => () => void;
};

declare type XYStoreApi_2 = {
    getState: () => XYStoreState_2;
    setState: (state: XYStoreState_2) => void;
};

declare type XYStoreApi_3 = {
    getState: () => XYStoreState_3;
};

declare type XYStoreState = ReactFlowState<Types.AnyNode, Types.AnyEdge>;

declare type XYStoreState_2 = ReactFlowState<RelationshipsBrowserTypes.AnyNode, RelationshipsBrowserTypes.Edge>;

declare type XYStoreState_3 = ReactFlowState<RelationshipDetailsTypes.AnyNode, RelationshipDetailsTypes.Edge>;

export { }
