import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import * as React from "react";
import React__default, { forwardRef, createElement, createContext, useContext, useRef, useMemo, useEffect, useCallback, useLayoutEffect, useState, memo as memo$3, Fragment as Fragment$1, Children, useId as useId$3, cloneElement, Component, useInsertionEffect as useInsertionEffect$1, isValidElement, useDeferredValue } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { createPortal, flushSync } from "react-dom";
import { isTagColorSpecified, BBox, nonexhaustive, nonNullable, ancestorsFqn, isStepEdgeId, extractStep, invariant as invariant$2, nameFromFqn, isAncestor as isAncestor$1, Queue, GroupElementKind, RichText as RichText$1, DefaultMap as DefaultMap$1, whereOperatorAsPredicate, getParallelStepsPrefix } from "@likec4/core";
import { DefaultTagColors, LikeC4Styles as LikeC4Styles$1, ElementShapes } from "@likec4/core/styles";
import { vector, BBox as BBox$2 } from "@likec4/core/geometry";
import { invariant as invariant$1, toArray as toArray$1, ifind, nonNullable as nonNullable$1, DefaultMap, compareNatural, isAncestor, sortParentsFirst, ifilter, nameFromFqn as nameFromFqn$1, nonexhaustive as nonexhaustive$1, delay as delay$1, ifirst, compareNaturalHierarchically, isome } from "@likec4/core/utils";
import { computeRelationshipsView, treeFromElements } from "@likec4/core/compute-view/relationships";
import { preferSummary, exact, ensureSizes, RichText, BBox as BBox$1 } from "@likec4/core/types";
import { modelConnection, extractViewTitleFromPath, VIEW_FOLDERS_SEPARATOR, normalizeViewPath } from "@likec4/core/model";
function isObject$2(value) {
  return typeof value == "object" && value != null && !Array.isArray(value);
}
var isObjectOrArray = (obj) => typeof obj == "object" && obj !== null;
function compact(value) {
  return Object.fromEntries(Object.entries(value ?? {}).filter(([_, value2]) => value2 !== void 0));
}
var isBaseCondition = (v2) => v2 === "base";
function filterBaseConditions(c) {
  return c.slice().filter((v2) => !isBaseCondition(v2));
}
function toChar(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
}
function toName(code) {
  let name = "", x2;
  for (x2 = Math.abs(code); x2 > 52; x2 = x2 / 52 | 0) name = toChar(x2 % 52) + name;
  return toChar(x2 % 52) + name;
}
function toPhash(h2, x2) {
  let i2 = x2.length;
  for (; i2; ) h2 = h2 * 33 ^ x2.charCodeAt(--i2);
  return h2;
}
function toHash(value) {
  return toName(toPhash(5381, value) >>> 0);
}
var importantRegex = /\s*!(important)?/i;
function isImportant(value) {
  return typeof value == "string" ? importantRegex.test(value) : !1;
}
function withoutImportant(value) {
  return typeof value == "string" ? value.replace(importantRegex, "").trim() : value;
}
function withoutSpace(str) {
  return typeof str == "string" ? str.replaceAll(" ", "_") : str;
}
var memo$2 = (fn) => {
  const cache2 = /* @__PURE__ */ new Map();
  return (...args) => {
    const key2 = JSON.stringify(args);
    if (cache2.has(key2))
      return cache2.get(key2);
    const result = fn(...args);
    return cache2.set(key2, result), result;
  };
}, MERGE_OMIT = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function mergeProps$1(...sources) {
  return sources.reduce((prev, obj) => (obj && Object.keys(obj).forEach((key2) => {
    if (MERGE_OMIT.has(key2)) return;
    const prevValue = prev[key2], value = obj[key2];
    isObject$2(prevValue) && isObject$2(value) ? prev[key2] = mergeProps$1(prevValue, value) : prev[key2] = value;
  }), prev), {});
}
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObjectOrArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key2 = getKey?.(prop, child) ?? prop, childPath = [...path, key2];
        if (stop?.(value, childPath))
          return predicate(value, path);
        const next = inner(child, childPath);
        isNotNullish(next) && (result[key2] = next);
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  return Array.isArray(obj) ? obj.map((value) => fn(value)) : isObject$2(obj) ? walkObject(obj, (value) => fn(value)) : fn(obj);
}
function toResponsiveObject(values2, breakpoints) {
  return values2.reduce(
    (acc, current2, index2) => {
      const key2 = breakpoints[index2];
      return current2 != null && (acc[key2] = current2), acc;
    },
    {}
  );
}
function normalizeStyleObject(styles, context2, shorthand = !0) {
  const { utility, conditions: conditions2 } = context2, { hasShorthand, resolveShorthand: resolveShorthand2 } = utility;
  return walkObject(
    styles,
    (value) => Array.isArray(value) ? toResponsiveObject(value, conditions2.breakpoints.keys) : value,
    {
      stop: (value) => Array.isArray(value),
      getKey: shorthand ? (prop) => hasShorthand ? resolveShorthand2(prop) : prop : void 0
    }
  );
}
var fallbackCondition = {
  shift: (v2) => v2,
  finalize: (v2) => v2,
  breakpoints: { keys: [] }
}, sanitize$1 = (value) => typeof value == "string" ? value.replaceAll(/[\n\s]+/g, " ") : value;
function createCss(context2) {
  const { utility, hash, conditions: conds = fallbackCondition } = context2, formatClassName = (str) => [utility.prefix, str].filter(Boolean).join("-"), hashFn = (conditions2, className) => {
    let result;
    if (hash) {
      const baseArray = [...conds.finalize(conditions2), className];
      result = formatClassName(utility.toHash(baseArray, toHash));
    } else
      result = [...conds.finalize(conditions2), formatClassName(className)].join(":");
    return result;
  };
  return memo$2(({ base, ...styles } = {}) => {
    const styleObject = Object.assign(styles, base), normalizedObject = normalizeStyleObject(styleObject, context2), classNames = /* @__PURE__ */ new Set();
    return walkObject(normalizedObject, (value, paths) => {
      if (value == null) return;
      const important = isImportant(value), [prop, ...allConditions] = conds.shift(paths), conditions2 = filterBaseConditions(allConditions), transformed = utility.transform(prop, withoutImportant(sanitize$1(value)));
      let className = hashFn(conditions2, transformed.className);
      important && (className = `${className}!`), classNames.add(className);
    }), Array.from(classNames).join(" ");
  });
}
function compactStyles(...styles) {
  return styles.flat().filter((style2) => isObject$2(style2) && Object.keys(compact(style2)).length > 0);
}
function createMergeCss(context2) {
  function resolve(styles) {
    const allStyles = compactStyles(...styles);
    return allStyles.length === 1 ? allStyles : allStyles.map((style2) => normalizeStyleObject(style2, context2));
  }
  function mergeCss2(...styles) {
    return mergeProps$1(...resolve(styles));
  }
  function assignCss(...styles) {
    return Object.assign({}, ...resolve(styles));
  }
  return { mergeCss: memo$2(mergeCss2), assignCss };
}
var wordRegex = /([A-Z])/g, msRegex = /^ms-/, hypenateProperty = memo$2((property) => property.startsWith("--") ? property : property.replace(wordRegex, "-$1").replace(msRegex, "-ms-").toLowerCase()), fns = ["min", "max", "clamp", "calc"], fnRegExp = new RegExp(`^(${fns.join("|")})\\(.*\\)`), isCssFunction = (v2) => typeof v2 == "string" && fnRegExp.test(v2), lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%", lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`, lengthRegExp = new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`), isCssUnit = (v2) => typeof v2 == "string" && lengthRegExp.test(v2), isCssVar = (v2) => typeof v2 == "string" && /^var\(--.+\)$/.test(v2), patternFns = {
  map: mapObject,
  isCssFunction,
  isCssVar,
  isCssUnit
}, getPatternStyles = (pattern, styles) => {
  if (!pattern?.defaultValues) return styles;
  const defaults2 = typeof pattern.defaultValues == "function" ? pattern.defaultValues(styles) : pattern.defaultValues;
  return Object.assign({}, defaults2, compact(styles));
}, getSlotRecipes = (recipe = {}) => {
  const init2 = (slot) => ({
    className: [recipe.className, slot].filter(Boolean).join("__"),
    base: recipe.base?.[slot] ?? {},
    variants: {},
    defaultVariants: recipe.defaultVariants ?? {},
    compoundVariants: recipe.compoundVariants ? getSlotCompoundVariant(recipe.compoundVariants, slot) : []
  }), recipeParts = (recipe.slots ?? []).map((slot) => [slot, init2(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(recipe.variants ?? {}))
    for (const [variantKey, variantSpec] of Object.entries(variantsSpec))
      recipeParts.forEach(([slot, slotRecipe]) => {
        slotRecipe.variants[variantsKey] ??= {}, slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
  return Object.fromEntries(recipeParts);
}, getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({ ...compoundVariant, css: compoundVariant.css[slotName] }));
function splitProps(props, ...keys2) {
  const descriptors = Object.getOwnPropertyDescriptors(props), dKeys = Object.keys(descriptors), split = (k) => {
    const clone = {};
    for (let i2 = 0; i2 < k.length; i2++) {
      const key2 = k[i2];
      descriptors[key2] && (Object.defineProperty(clone, key2, descriptors[key2]), delete descriptors[key2]);
    }
    return clone;
  }, fn = (key2) => split(Array.isArray(key2) ? key2 : dKeys.filter(key2));
  return keys2.map(fn).concat(split(dKeys));
}
var uniq = (...items) => {
  const set2 = items.reduce((acc, currItems) => (currItems && currItems.forEach((item) => acc.add(item)), acc), /* @__PURE__ */ new Set([]));
  return Array.from(set2);
}, htmlProps = ["htmlSize", "htmlTranslate", "htmlWidth", "htmlHeight"];
function convert(key2) {
  return htmlProps.includes(key2) ? key2.replace("html", "").toLowerCase() : key2;
}
function normalizeHTMLProps(props) {
  return Object.fromEntries(Object.entries(props).map(([key2, value]) => [convert(key2), value]));
}
normalizeHTMLProps.keys = htmlProps;
const conditionsStr = "_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_noscript,_invertedColors,_shapeSizeXs,_shapeSizeSm,_shapeSizeMd,_shapeSizeLg,_shapeSizeXl,_shapeRectangle,_shapePerson,_shapeBrowser,_shapeMobile,_shapeCylinder,_shapeStorage,_shapeQueue,_shapeBucket,_shapeDocument,_notDisabled,_reduceGraphics,_reduceGraphicsOnPan,_noReduceGraphics,_whenPanning,_smallZoom,_compoundTransparent,_edgeActive,_whenHovered,_whenSelectable,_whenSelected,_whenDimmed,_whenFocused,_p3,_srgb,_rec2020,xs,xsOnly,xsDown,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,xsToSm,xsToMd,xsToLg,xsToXl,smToMd,smToLg,smToXl,mdToLg,mdToXl,lgToXl,@/xs,@/sm,@/md,@/lg,@likec4-root/xs,@likec4-root/sm,@likec4-root/md,@likec4-root/lg,@likec4-dialog/xs,@likec4-dialog/sm,@likec4-dialog/md,@likec4-dialog/lg,base", conditions = new Set(conditionsStr.split(",")), conditionRegex = /^@|&|&$/;
function isCondition(value) {
  return conditions.has(value) || conditionRegex.test(value);
}
const underscoreRegex = /^_/, conditionsSelectorRegex = /&|@/;
function finalizeConditions(paths) {
  return paths.map((path) => conditions.has(path) ? path.replace(underscoreRegex, "") : conditionsSelectorRegex.test(path) ? `[${withoutSpace(path.trim())}]` : path);
}
function sortConditions(paths) {
  return paths.sort((a2, b2) => {
    const aa = isCondition(a2), bb = isCondition(b2);
    return aa && !bb ? 1 : !aa && bb ? -1 : 0;
  });
}
const utilities = "aspectRatio:asp,boxDecorationBreak:bx-db,zIndex:z,boxSizing:bx-s,objectPosition:obj-p,objectFit:obj-f,overscrollBehavior:ovs-b,overscrollBehaviorX:ovs-bx,overscrollBehaviorY:ovs-by,position:pos/1,top:top,left:left,inset:inset,insetInline:inset-x/insetX,insetBlock:inset-y/insetY,insetBlockEnd:inset-be,insetBlockStart:inset-bs,insetInlineEnd:inset-e/insetEnd/end,insetInlineStart:inset-s/insetStart/start,right:right,bottom:bottom,float:float,visibility:vis,display:d,hideFrom:hide,hideBelow:show,flexBasis:flex-b,flex:flex,flexDirection:flex-d/flexDir,flexGrow:flex-g,flexShrink:flex-sh,gridTemplateColumns:grid-tc,gridTemplateRows:grid-tr,gridColumn:grid-c,gridRow:grid-r,gridColumnStart:grid-cs,gridColumnEnd:grid-ce,gridAutoFlow:grid-af,gridAutoColumns:grid-ac,gridAutoRows:grid-ar,gap:gap,gridGap:grid-g,gridRowGap:grid-rg,gridColumnGap:grid-cg,rowGap:rg,columnGap:cg,justifyContent:jc,alignContent:ac,alignItems:ai,alignSelf:as,padding:p/1,paddingLeft:pl/1,paddingRight:pr/1,paddingTop:pt/1,paddingBottom:pb/1,paddingBlock:py/1/paddingY,paddingBlockEnd:pbe,paddingBlockStart:pbs,paddingInline:px/paddingX/1,paddingInlineEnd:pe/1/paddingEnd,paddingInlineStart:ps/1/paddingStart,marginLeft:ml/1,marginRight:mr/1,marginTop:mt/1,marginBottom:mb/1,margin:m/1,marginBlock:my/1/marginY,marginBlockEnd:mbe,marginBlockStart:mbs,marginInline:mx/1/marginX,marginInlineEnd:me/1/marginEnd,marginInlineStart:ms/1/marginStart,spaceX:sx,spaceY:sy,outlineWidth:ring-w/ringWidth,outlineColor:ring-c/ringColor,outline:ring/1,outlineOffset:ring-o/ringOffset,focusRing:focus-ring,focusVisibleRing:focus-v-ring,focusRingColor:focus-ring-c,focusRingOffset:focus-ring-o,focusRingWidth:focus-ring-w,focusRingStyle:focus-ring-s,divideX:dvd-x,divideY:dvd-y,divideColor:dvd-c,divideStyle:dvd-s,width:w/1,inlineSize:w-is,minWidth:min-w/minW,minInlineSize:min-w-is,maxWidth:max-w/maxW,maxInlineSize:max-w-is,height:h/1,blockSize:h-bs,minHeight:min-h/minH,minBlockSize:min-h-bs,maxHeight:max-h/maxH,maxBlockSize:max-b,boxSize:size,color:c,fontFamily:ff,fontSize:fs,fontSizeAdjust:fs-a,fontPalette:fp,fontKerning:fk,fontFeatureSettings:ff-s,fontWeight:fw,fontSmoothing:fsmt,fontVariant:fv,fontVariantAlternates:fv-alt,fontVariantCaps:fv-caps,fontVariationSettings:fv-s,fontVariantNumeric:fv-num,letterSpacing:ls,lineHeight:lh,textAlign:ta,textDecoration:td,textDecorationColor:td-c,textEmphasisColor:te-c,textDecorationStyle:td-s,textDecorationThickness:td-t,textUnderlineOffset:tu-o,textTransform:tt,textIndent:ti,textShadow:tsh,textShadowColor:tsh-c/textShadowColor,WebkitTextFillColor:wktf-c,textOverflow:tov,verticalAlign:va,wordBreak:wb,textWrap:tw,truncate:trunc,lineClamp:lc,listStyleType:li-t,listStylePosition:li-pos,listStyleImage:li-img,listStyle:li-s,backgroundPosition:bg-p/bgPosition,backgroundPositionX:bg-p-x/bgPositionX,backgroundPositionY:bg-p-y/bgPositionY,backgroundAttachment:bg-a/bgAttachment,backgroundClip:bg-cp/bgClip,background:bg/1,backgroundColor:bg-c/bgColor,backgroundOrigin:bg-o/bgOrigin,backgroundImage:bg-i/bgImage,backgroundRepeat:bg-r/bgRepeat,backgroundBlendMode:bg-bm/bgBlendMode,backgroundSize:bg-s/bgSize,backgroundGradient:bg-grad/bgGradient,backgroundLinear:bg-linear/bgLinear,backgroundRadial:bg-radial/bgRadial,backgroundConic:bg-conic/bgConic,textGradient:txt-grad,gradientFromPosition:grad-from-pos,gradientToPosition:grad-to-pos,gradientFrom:grad-from,gradientTo:grad-to,gradientVia:grad-via,gradientViaPosition:grad-via-pos,borderRadius:bdr/rounded,borderTopLeftRadius:bdr-tl/roundedTopLeft,borderTopRightRadius:bdr-tr/roundedTopRight,borderBottomRightRadius:bdr-br/roundedBottomRight,borderBottomLeftRadius:bdr-bl/roundedBottomLeft,borderTopRadius:bdr-t/roundedTop,borderRightRadius:bdr-r/roundedRight,borderBottomRadius:bdr-b/roundedBottom,borderLeftRadius:bdr-l/roundedLeft,borderStartStartRadius:bdr-ss/roundedStartStart,borderStartEndRadius:bdr-se/roundedStartEnd,borderStartRadius:bdr-s/roundedStart,borderEndStartRadius:bdr-es/roundedEndStart,borderEndEndRadius:bdr-ee/roundedEndEnd,borderEndRadius:bdr-e/roundedEnd,border:bd,borderWidth:bd-w,borderTopWidth:bd-t-w,borderLeftWidth:bd-l-w,borderRightWidth:bd-r-w,borderBottomWidth:bd-b-w,borderBlockStartWidth:bd-bs-w,borderBlockEndWidth:bd-be-w,borderColor:bd-c,borderInline:bd-x/borderX,borderInlineWidth:bd-x-w/borderXWidth,borderInlineColor:bd-x-c/borderXColor,borderBlock:bd-y/borderY,borderBlockWidth:bd-y-w/borderYWidth,borderBlockColor:bd-y-c/borderYColor,borderLeft:bd-l,borderLeftColor:bd-l-c,borderInlineStart:bd-s/borderStart,borderInlineStartWidth:bd-s-w/borderStartWidth,borderInlineStartColor:bd-s-c/borderStartColor,borderRight:bd-r,borderRightColor:bd-r-c,borderInlineEnd:bd-e/borderEnd,borderInlineEndWidth:bd-e-w/borderEndWidth,borderInlineEndColor:bd-e-c/borderEndColor,borderTop:bd-t,borderTopColor:bd-t-c,borderBottom:bd-b,borderBottomColor:bd-b-c,borderBlockEnd:bd-be,borderBlockEndColor:bd-be-c,borderBlockStart:bd-bs,borderBlockStartColor:bd-bs-c,opacity:op,boxShadow:bx-sh/shadow,boxShadowColor:bx-sh-c/shadowColor,mixBlendMode:mix-bm,filter:filter,brightness:brightness,contrast:contrast,grayscale:grayscale,hueRotate:hue-rotate,invert:invert,saturate:saturate,sepia:sepia,dropShadow:drop-shadow,blur:blur,backdropFilter:bkdp,backdropBlur:bkdp-blur,backdropBrightness:bkdp-brightness,backdropContrast:bkdp-contrast,backdropGrayscale:bkdp-grayscale,backdropHueRotate:bkdp-hue-rotate,backdropInvert:bkdp-invert,backdropOpacity:bkdp-opacity,backdropSaturate:bkdp-saturate,backdropSepia:bkdp-sepia,borderCollapse:bd-cl,borderSpacing:bd-sp,borderSpacingX:bd-sx,borderSpacingY:bd-sy,tableLayout:tbl,transitionTimingFunction:trs-tmf,transitionDelay:trs-dly,transitionDuration:trs-dur,transitionProperty:trs-prop,transition:transition,animation:anim,animationName:anim-n,animationTimingFunction:anim-tmf,animationDuration:anim-dur,animationDelay:anim-dly,animationPlayState:anim-ps,animationComposition:anim-comp,animationFillMode:anim-fm,animationDirection:anim-dir,animationIterationCount:anim-ic,animationRange:anim-r,animationState:anim-s,animationRangeStart:anim-rs,animationRangeEnd:anim-re,animationTimeline:anim-tl,transformOrigin:trf-o,transformBox:trf-b,transformStyle:trf-s,transform:trf,rotate:rotate,rotateX:rotate-x,rotateY:rotate-y,rotateZ:rotate-z,scale:scale,scaleX:scale-x,scaleY:scale-y,translate:translate,translateX:translate-x/x,translateY:translate-y/y,translateZ:translate-z/z,accentColor:ac-c,caretColor:ca-c,scrollBehavior:scr-bhv,scrollbar:scr-bar,scrollbarColor:scr-bar-c,scrollbarGutter:scr-bar-g,scrollbarWidth:scr-bar-w,scrollMargin:scr-m,scrollMarginLeft:scr-ml,scrollMarginRight:scr-mr,scrollMarginTop:scr-mt,scrollMarginBottom:scr-mb,scrollMarginBlock:scr-my/scrollMarginY,scrollMarginBlockEnd:scr-mbe,scrollMarginBlockStart:scr-mbt,scrollMarginInline:scr-mx/scrollMarginX,scrollMarginInlineEnd:scr-me,scrollMarginInlineStart:scr-ms,scrollPadding:scr-p,scrollPaddingBlock:scr-py/scrollPaddingY,scrollPaddingBlockStart:scr-pbs,scrollPaddingBlockEnd:scr-pbe,scrollPaddingInline:scr-px/scrollPaddingX,scrollPaddingInlineEnd:scr-pe,scrollPaddingInlineStart:scr-ps,scrollPaddingLeft:scr-pl,scrollPaddingRight:scr-pr,scrollPaddingTop:scr-pt,scrollPaddingBottom:scr-pb,scrollSnapAlign:scr-sa,scrollSnapStop:scrs-s,scrollSnapType:scrs-t,scrollSnapStrictness:scrs-strt,scrollSnapMargin:scrs-m,scrollSnapMarginTop:scrs-mt,scrollSnapMarginBottom:scrs-mb,scrollSnapMarginLeft:scrs-ml,scrollSnapMarginRight:scrs-mr,scrollSnapCoordinate:scrs-c,scrollSnapDestination:scrs-d,scrollSnapPointsX:scrs-px,scrollSnapPointsY:scrs-py,scrollSnapTypeX:scrs-tx,scrollSnapTypeY:scrs-ty,scrollTimeline:scrtl,scrollTimelineAxis:scrtl-a,scrollTimelineName:scrtl-n,touchAction:tch-a,userSelect:us,overflow:ov,overflowWrap:ov-wrap,overflowX:ov-x,overflowY:ov-y,overflowAnchor:ov-a,overflowBlock:ov-b,overflowInline:ov-i,overflowClipBox:ovcp-bx,overflowClipMargin:ovcp-m,overscrollBehaviorBlock:ovs-bb,overscrollBehaviorInline:ovs-bi,fill:fill,stroke:stk,strokeWidth:stk-w,strokeDasharray:stk-dsh,strokeDashoffset:stk-do,strokeLinecap:stk-lc,strokeLinejoin:stk-lj,strokeMiterlimit:stk-ml,strokeOpacity:stk-op,srOnly:sr,debug:debug,appearance:ap,backfaceVisibility:bfv,clipPath:cp-path,hyphens:hy,mask:msk,maskImage:msk-i,maskSize:msk-s,textSizeAdjust:txt-adj,container:cq,containerName:cq-n,containerType:cq-t,cursor:cursor,textStyle:textStyle,layerStyle:layerStyle,animationStyle:animationStyle", classNameByProp = /* @__PURE__ */ new Map(), shorthands = /* @__PURE__ */ new Map();
utilities.split(",").forEach((utility) => {
  const [prop, meta] = utility.split(":"), [className, ...shorthandList] = meta.split("/");
  classNameByProp.set(prop, className), shorthandList.length && shorthandList.forEach((shorthand) => {
    shorthands.set(shorthand === "1" ? className : shorthand, prop);
  });
});
const resolveShorthand = (prop) => shorthands.get(prop) || prop, context = {
  conditions: {
    shift: sortConditions,
    finalize: finalizeConditions,
    breakpoints: { keys: ["base", "xs", "sm", "md", "lg", "xl"] }
  },
  utility: {
    transform: (prop, value) => {
      const key2 = resolveShorthand(prop);
      return { className: `${classNameByProp.get(key2) || hypenateProperty(key2)}_${withoutSpace(value)}` };
    },
    hasShorthand: !0,
    toHash: (path, hashFn) => hashFn(path.join(":")),
    resolveShorthand
  }
}, cssFn = createCss(context), css = (...styles) => cssFn(mergeCss(...styles));
css.raw = (...styles) => mergeCss(...styles);
const { mergeCss } = createMergeCss(context);
function cx() {
  let str = "", i2 = 0, arg;
  for (; i2 < arguments.length; )
    (arg = arguments[i2++]) && typeof arg == "string" && (str && (str += " "), str += arg);
  return str;
}
const defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function cva(config) {
  const { base, variants, defaultVariants, compoundVariants } = defaults(config), getVariantProps2 = (variants2) => ({ ...defaultVariants, ...compact(variants2) });
  function resolve(props = {}) {
    const computedVariants = getVariantProps2(props);
    let variantCss = { ...base };
    for (const [key2, value] of Object.entries(computedVariants))
      variants[key2]?.[value] && (variantCss = mergeCss(variantCss, variants[key2][value]));
    const compoundVariantCss = getCompoundVariantCss(compoundVariants, computedVariants);
    return mergeCss(variantCss, compoundVariantCss);
  }
  function merge(__cva) {
    const override = defaults(__cva.config), variantKeys2 = uniq(__cva.variantKeys, Object.keys(variants));
    return cva({
      base: mergeCss(base, override.base),
      variants: Object.fromEntries(
        variantKeys2.map((key2) => [key2, mergeCss(variants[key2], override.variants[key2])])
      ),
      defaultVariants: mergeProps$1(defaultVariants, override.defaultVariants),
      compoundVariants: [...compoundVariants, ...override.compoundVariants]
    });
  }
  function cvaFn(props) {
    return css(resolve(props));
  }
  const variantKeys = Object.keys(variants);
  function splitVariantProps(props) {
    return splitProps(props, variantKeys);
  }
  const variantMap = Object.fromEntries(Object.entries(variants).map(([key2, value]) => [key2, Object.keys(value)]));
  return Object.assign(memo$2(cvaFn), {
    __cva__: !0,
    variantMap,
    variantKeys,
    raw: resolve,
    config,
    merge,
    splitVariantProps,
    getVariantProps: getVariantProps2
  });
}
function getCompoundVariantCss(compoundVariants, variantMap) {
  let result = {};
  return compoundVariants.forEach((compoundVariant) => {
    Object.entries(compoundVariant).every(([key2, value]) => key2 === "css" ? !0 : (Array.isArray(value) ? value : [value]).some((value2) => variantMap[key2] === value2)) && (result = mergeCss(result, compoundVariant.css));
  }), result;
}
function assertCompoundVariant(name, compoundVariants, variants, prop) {
  if (compoundVariants.length > 0 && typeof variants?.[prop] == "object")
    throw new Error(`[recipe:${name}:${prop}] Conditions are not supported when using compound variants.`);
}
function sva(config) {
  const slots = Object.entries(getSlotRecipes(config)).map(([slot, slotCva]) => [slot, cva(slotCva)]), defaultVariants = config.defaultVariants ?? {}, classNameMap = slots.reduce((acc, [slot, cvaFn]) => (config.className && (acc[slot] = cvaFn.config.className), acc), {});
  function svaFn(props) {
    const result = slots.map(([slot, cvaFn]) => [slot, cx(cvaFn(props), classNameMap[slot])]);
    return Object.fromEntries(result);
  }
  function raw(props) {
    const result = slots.map(([slot, cvaFn]) => [slot, cvaFn.raw(props)]);
    return Object.fromEntries(result);
  }
  const variants = config.variants ?? {}, variantKeys = Object.keys(variants);
  function splitVariantProps(props) {
    return splitProps(props, variantKeys);
  }
  const getVariantProps2 = (variants2) => ({ ...defaultVariants, ...compact(variants2) }), variantMap = Object.fromEntries(
    Object.entries(variants).map(([key2, value]) => [key2, Object.keys(value)])
  );
  return Object.assign(memo$2(svaFn), {
    __cva__: !1,
    raw,
    config,
    variantMap,
    variantKeys,
    classNameMap,
    splitVariantProps,
    getVariantProps: getVariantProps2
  });
}
var defaultAttributes = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
const createReactComponent = (type, iconName, iconNamePascal, iconNode) => {
  const Component2 = forwardRef(
    ({ color: color2 = "currentColor", size: size2 = 24, stroke = 2, title: title2, className, children: children2, ...rest }, ref) => createElement(
      "svg",
      {
        ref,
        ...defaultAttributes[type],
        width: size2,
        height: size2,
        className: ["tabler-icon", `tabler-icon-${iconName}`, className].join(" "),
        ...type === "filled" ? {
          fill: color2
        } : {
          strokeWidth: stroke,
          stroke: color2
        },
        ...rest
      },
      [
        title2 && createElement("title", { key: "svg-title" }, title2),
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children2) ? children2 : [children2]
      ]
    )
  );
  return Component2.displayName = `${iconNamePascal}`, Component2;
};
const __iconNode$N = [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M9 9l1 0", key: "svg-2" }], ["path", { d: "M9 13l6 0", key: "svg-3" }], ["path", { d: "M9 17l6 0", key: "svg-4" }]], IconFileText = createReactComponent("outline", "file-text", "FileText", __iconNode$N);
const __iconNode$M = [["path", { d: "M12 6m-7 0a7 3 0 1 0 14 0a7 3 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M5 6v12c0 1.657 3.134 3 7 3s7 -1.343 7 -3v-12", key: "svg-1" }]], IconCylinder = createReactComponent("outline", "cylinder", "Cylinder", __iconNode$M);
const __iconNode$L = [["path", { d: "M21 14.008v-5.018a1.98 1.98 0 0 0 -1 -1.717l-4 -2.008a2.016 2.016 0 0 0 -2 0l-10 5.008c-.619 .355 -1 1.01 -1 1.718v5.018c0 .709 .381 1.363 1 1.717l4 2.008a2.016 2.016 0 0 0 2 0l10 -5.008c.619 -.355 1 -1.01 1 -1.718z", key: "svg-0" }], ["path", { d: "M9 21v-7.5", key: "svg-1" }], ["path", { d: "M9 13.5l11.5 -5.5", key: "svg-2" }], ["path", { d: "M3.5 11l5.5 2.5", key: "svg-3" }]], IconRectangularPrism = createReactComponent("outline", "rectangular-prism", "RectangularPrism", __iconNode$L);
const __iconNode$K = [["path", { d: "M3 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-0" }], ["path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-1" }], ["path", { d: "M17 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-2" }], ["path", { d: "M5 11v-3a3 3 0 0 1 3 -3h8a3 3 0 0 1 3 3v3", key: "svg-3" }], ["path", { d: "M16.5 8.5l2.5 2.5l2.5 -2.5", key: "svg-4" }]], IconReorder = createReactComponent("outline", "reorder", "Reorder", __iconNode$K);
const __iconNode$J = [["path", { d: "M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0", key: "svg-0" }], ["path", { d: "M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }]], IconUser = createReactComponent("outline", "user", "User", __iconNode$J);
const __iconNode$I = [["path", { d: "M6 5a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-14z", key: "svg-0" }], ["path", { d: "M11 4h2", key: "svg-1" }], ["path", { d: "M12 17v.01", key: "svg-2" }]], IconDeviceMobile = createReactComponent("outline", "device-mobile", "DeviceMobile", __iconNode$I);
const __iconNode$H = [["path", { d: "M4 8h16", key: "svg-0" }], ["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-1" }], ["path", { d: "M8 4v4", key: "svg-2" }]], IconBrowser = createReactComponent("outline", "browser", "Browser", __iconNode$H), IconRendererContext = createContext(null);
function IconRendererProvider({
  value,
  children: children2
}) {
  return useContext(IconRendererContext) ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : /* @__PURE__ */ jsx(IconRendererContext.Provider, { value, children: children2 });
}
function IconRenderer({
  element,
  className,
  style: style2
}) {
  const RenderIcon = useContext(IconRendererContext);
  if (!element || !element.icon || element.icon === "none")
    return null;
  let icon2;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon2 = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon && (icon2 = /* @__PURE__ */ jsx(RenderIcon, { node: element })), icon2 ? /* @__PURE__ */ jsx(
    "div",
    {
      className: cx(
        className,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      style: style2,
      children: icon2
    }
  ) : null;
}
const ShapeIcons = {
  browser: IconBrowser,
  cylinder: IconCylinder,
  mobile: IconDeviceMobile,
  person: IconUser,
  queue: IconReorder,
  rectangle: IconRectangularPrism,
  storage: IconCylinder,
  bucket: IconCylinder,
  document: IconFileText
};
function IconOrShapeRenderer({
  element,
  className
}) {
  const icon2 = /* @__PURE__ */ jsx(IconRenderer, { element, className });
  if (icon2)
    return icon2;
  const ShapeIcon = ShapeIcons[element.shape];
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: cx(
        className,
        "likec4-shape-icon"
      ),
      children: /* @__PURE__ */ jsx(ShapeIcon, {})
    }
  );
}
function useSyncedRef(value) {
  const ref = useRef(value);
  return ref.current = value, useMemo(() => Object.freeze({
    get current() {
      return ref.current;
    }
  }), []);
}
function useUnmountEffect(effect) {
  const effectRef = useSyncedRef(effect);
  useEffect(
    () => () => {
      effectRef.current();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
}
function useDebouncedCallback$1(callback, deps, delay2, maxWait = 0) {
  const timeout2 = useRef(void 0), waitTimeout = useRef(void 0), cb = useRef(callback), lastCall = useRef(void 0), clear = () => {
    timeout2.current && (clearTimeout(timeout2.current), timeout2.current = void 0), waitTimeout.current && (clearTimeout(waitTimeout.current), waitTimeout.current = void 0);
  };
  return useUnmountEffect(clear), useEffect(() => {
    cb.current = callback;
  }, deps), useMemo(() => {
    const execute = () => {
      if (clear(), !lastCall.current)
        return;
      const context2 = lastCall.current;
      lastCall.current = void 0, cb.current.apply(context2.this, context2.args);
    }, wrapped = function(...args) {
      timeout2.current && clearTimeout(timeout2.current), lastCall.current = { args, this: this }, timeout2.current = setTimeout(execute, delay2), maxWait > 0 && !waitTimeout.current && (waitTimeout.current = setTimeout(execute, maxWait));
    };
    return Object.defineProperties(wrapped, {
      length: { value: callback.length },
      name: { value: `${callback.name || "anonymous"}__debounced__${delay2}` }
    }), wrapped;
  }, [delay2, maxWait, ...deps]);
}
const noop$6 = () => {
}, isBrowser$1 = typeof globalThis < "u" && typeof navigator < "u" && typeof document < "u";
function useRafCallback(cb) {
  const cbRef = useSyncedRef(cb), frame2 = useRef(0), cancel2 = useCallback(() => {
    isBrowser$1 && frame2.current && (cancelAnimationFrame(frame2.current), frame2.current = 0);
  }, []);
  return useUnmountEffect(cancel2), [
    useMemo(() => {
      const wrapped = (...args) => {
        isBrowser$1 && (cancel2(), frame2.current = requestAnimationFrame(() => {
          cbRef.current(...args), frame2.current = 0;
        }));
      };
      return Object.defineProperties(wrapped, {
        length: { value: cb.length },
        name: { value: `${cb.name || "anonymous"}__raf` }
      }), wrapped;
    }, []),
    cancel2
  ];
}
const basicDepsComparator = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (element !== d2[i2])
      return !1;
  return !0;
};
function useCustomCompareEffect(callback, deps, comparator = basicDepsComparator, effectHook = useEffect, ...effectHookRestArgs) {
  const dependencies = useRef(void 0);
  (dependencies.current === void 0 || isBrowser$1 && !comparator(dependencies.current, deps)) && (dependencies.current = deps), effectHook(callback, dependencies.current, ...effectHookRestArgs);
}
function useFirstMountState() {
  const isFirstMount = useRef(!0);
  return useEffect(() => {
    isFirstMount.current = !1;
  }, []), isFirstMount.current;
}
const useIsomorphicLayoutEffect$3 = isBrowser$1 ? useLayoutEffect : useEffect;
function useMountEffect(effect) {
  useEffect(() => {
    effect();
  }, []);
}
function useRafEffect(callback, deps) {
  const [rafCallback, cancelRaf] = useRafCallback(callback);
  useEffect(
    () => (rafCallback(), cancelRaf),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
}
const stateChanger = (state) => (state + 1) % Number.MAX_SAFE_INTEGER;
function useRerender() {
  const [, setState] = useState(0);
  return useCallback(() => {
    setState(stateChanger);
  }, []);
}
function useUpdateEffect$1(effect, deps) {
  const isFirstMount = useFirstMountState();
  useEffect(isFirstMount ? noop$6 : effect, deps);
}
const cancelTimeout = (id2) => {
  id2 && clearTimeout(id2);
};
function useTimeoutEffect(callback, ms) {
  const cbRef = useSyncedRef(callback), msRef = useSyncedRef(ms), timeoutIdRef = useRef(null), cancel2 = useCallback(() => {
    cancelTimeout(timeoutIdRef.current);
  }, []), reset = useCallback(() => {
    msRef.current !== void 0 && (cancel2(), timeoutIdRef.current = setTimeout(() => {
      cbRef.current();
    }, msRef.current));
  }, []);
  return useEffect(() => (reset(), cancel2), [ms]), [cancel2, reset];
}
const useCustomCompareMemo = (factory2, deps, comparator) => {
  const dependencies = useRef(void 0);
  return (dependencies.current === void 0 || !comparator(dependencies.current, deps)) && (dependencies.current = deps), useMemo(factory2, dependencies.current);
};
function cc(names) {
  if (typeof names == "string" || typeof names == "number") return "" + names;
  let out = "";
  if (Array.isArray(names))
    for (let i2 = 0, tmp; i2 < names.length; i2++)
      (tmp = cc(names[i2])) !== "" && (out += (out && " ") + tmp);
  else
    for (let k in names)
      names[k] && (out += (out && " ") + k);
  return out;
}
var noop$5 = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _ = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _ || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _[t2] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T2 = parseTypenames$1(typename + "", _), t2, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      for (; ++i2 < n2; ) if ((t2 = (typename = T2[i2]).type) && (t2 = get$2(_[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback != "function") throw new Error("invalid callback: " + callback);
    for (; ++i2 < n2; )
      if (t2 = (typename = T2[i2]).type) _[t2] = set$2(_[t2], typename.name, callback);
      else if (callback == null) for (t2 in _) _[t2] = set$2(_[t2], typename.name, null);
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t2 in _) copy[t2] = _[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  }
};
function get$2(type, name) {
  for (var i2 = 0, n2 = type.length, c; i2 < n2; ++i2)
    if ((c = type[i2]).name === name)
      return c.value;
}
function set$2(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2)
    if (type[i2].name === name) {
      type[i2] = noop$5, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  return callback != null && type.push({ name, value: callback }), type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  return i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns" && (name = name.slice(i2 + 1)), namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector$o(selector3) {
  return selector3 == null ? none : function() {
    return this.querySelector(selector3);
  };
}
function selection_select(select2) {
  typeof select2 != "function" && (select2 = selector$o(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subnode = select2.call(node2, node2.__data__, i2, group)) && ("__data__" in node2 && (subnode.__data__ = node2.__data__), subgroup[i2] = subnode);
  return new Selection$1(subgroups, this._parents);
}
function array$1(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector3) {
  return selector3 == null ? empty : function() {
    return this.querySelectorAll(selector3);
  };
}
function arrayAll(select2) {
  return function() {
    return array$1(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  typeof select2 == "function" ? select2 = arrayAll(select2) : select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subgroups.push(select2.call(node2, node2.__data__, i2, group)), parents.push(node2));
  return new Selection$1(subgroups, parents);
}
function matcher(selector3) {
  return function() {
    return this.matches(selector3);
  };
}
function childMatcher(selector3) {
  return function(node2) {
    return node2.matches(selector3);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match == "function" ? match : childMatcher(match)));
}
var filter$1 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter$1.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match == "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && match.call(node2, node2.__data__, i2, group) && subgroup.push(node2);
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument, this.namespaceURI = parent.namespaceURI, this._next = null, this._parent = parent, this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector3) {
    return this._parent.querySelector(selector3);
  },
  querySelectorAll: function(selector3) {
    return this._parent.querySelectorAll(selector3);
  }
};
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  for (var i2 = 0, node2, groupLength = group.length, dataLength = data.length; i2 < dataLength; ++i2)
    (node2 = group[i2]) ? (node2.__data__ = data[i2], update[i2] = node2) : enter[i2] = new EnterNode(parent, data[i2]);
  for (; i2 < groupLength; ++i2)
    (node2 = group[i2]) && (exit[i2] = node2);
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i2, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2)
    (node2 = group[i2]) && (keyValues[i2] = keyValue = key2.call(node2, node2.__data__, i2, group) + "", nodeByKeyValue.has(keyValue) ? exit[i2] = node2 : nodeByKeyValue.set(keyValue, node2));
  for (i2 = 0; i2 < dataLength; ++i2)
    keyValue = key2.call(parent, data[i2], i2, data) + "", (node2 = nodeByKeyValue.get(keyValue)) ? (update[i2] = node2, node2.__data__ = data[i2], nodeByKeyValue.delete(keyValue)) : enter[i2] = new EnterNode(parent, data[i2]);
  for (i2 = 0; i2 < groupLength; ++i2)
    (node2 = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node2 && (exit[i2] = node2);
}
function datum(node2) {
  return node2.__data__;
}
function selection_data(value, key2) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  typeof value != "function" && (value = constant$4(value));
  for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    var parent = parents[j2], group = groups[j2], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0)
      if (previous = enterGroup[i0]) {
        for (i0 >= i1 && (i1 = i0 + 1); !(next = updateGroup[i1]) && ++i1 < dataLength; ) ;
        previous._next = next || null;
      }
  }
  return update = new Selection$1(update, parents), update._enter = enter, update._exit = exit, update;
}
function arraylike(data) {
  return typeof data == "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  return typeof onenter == "function" ? (enter = onenter(enter), enter && (enter = enter.selection())) : enter = enter.append(onenter + ""), onupdate != null && (update = onupdate(update), update && (update = update.selection())), onexit == null ? exit.remove() : onexit(exit), enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context2) {
  for (var selection2 = context2.selection ? context2.selection() : context2, groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2)
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group0[i2] || group1[i2]) && (merge[i2] = node2);
  for (; j2 < m0; ++j2)
    merges[j2] = groups0[j2];
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m2 = groups.length; ++j2 < m2; )
    for (var group = groups[j2], i2 = group.length - 1, next = group[i2], node2; --i2 >= 0; )
      (node2 = group[i2]) && (next && node2.compareDocumentPosition(next) ^ 4 && next.parentNode.insertBefore(node2, next), next = node2);
  return this;
}
function selection_sort(compare2) {
  compare2 || (compare2 = ascending);
  function compareNode(a2, b2) {
    return a2 && b2 ? compare2(a2.__data__, b2.__data__) : !a2 - !b2;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j2 = 0; j2 < m2; ++j2) {
    for (var group = groups[j2], n2 = group.length, sortgroup = sortgroups[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (sortgroup[i2] = node2);
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  return arguments[0] = this, callback.apply(null, arguments), this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node2 = group[i2];
      if (node2) return node2;
    }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node2 of this) ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2)
      (node2 = group[i2]) && callback.call(node2, node2.__data__, i2, group);
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? this.removeAttribute(name) : this.setAttribute(name, v2);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? this.removeAttributeNS(fullname.space, fullname.local) : this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value == "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? this.style.removeProperty(name) : this.style.setProperty(name, v2, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value == "function" ? styleFunction$1 : styleConstant$1)(name, value, priority ?? "")) : styleValue(this.node(), name);
}
function styleValue(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    v2 == null ? delete this[name] : this[name] = v2;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value == "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2, this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    i2 < 0 && (this._names.push(name), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    i2 >= 0 && (this._names.splice(i2, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node2, names) {
  for (var list2 = classList(node2), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.add(names[i2]);
}
function classedRemove(node2, names) {
  for (var list2 = classList(node2), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    for (var list2 = classList(this.node()), i2 = -1, n2 = names.length; ++i2 < n2; ) if (!list2.contains(names[i2])) return !1;
    return !0;
  }
  return this.each((typeof value == "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 ?? "";
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value == "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 ?? "";
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value == "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise$1() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise$1);
}
function lower() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name == "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name == "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before == "function" ? before : selector$o(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  parent && parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(!1), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(!0), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    return i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (on) {
      for (var j2 = 0, i2 = -1, m2 = on.length, o; j2 < m2; ++j2)
        o = on[j2], (!typename.type || o.type === typename.type) && o.name === typename.name ? this.removeEventListener(o.type, o.listener, o.options) : on[++i2] = o;
      ++i2 ? on.length = i2 : delete this.__on;
    }
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) {
      for (var j2 = 0, m2 = on.length; j2 < m2; ++j2)
        if ((o = on[j2]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = listener, o.options = options), o.value = value;
          return;
        }
    }
    this.addEventListener(typename.type, listener, options), o = { type: typename.type, name: typename.name, value, listener, options }, on ? on.push(o) : this.__on = [o];
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) {
      for (var j2 = 0, m2 = on.length, o; j2 < m2; ++j2)
        for (i2 = 0, o = on[j2]; i2 < n2; ++i2)
          if ((t2 = typenames[i2]).type === o.type && t2.name === o.name)
            return o.value;
    }
    return;
  }
  for (on = value ? onAdd : onRemove, i2 = 0; i2 < n2; ++i2) this.each(on(typenames[i2], value, options));
  return this;
}
function dispatchEvent(node2, type, params) {
  var window2 = defaultView(node2), event = window2.CustomEvent;
  typeof event == "function" ? event = new event(type, params) : (event = window2.document.createEvent("Event"), params ? (event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail) : event.initEvent(type, !1, !1)), node2.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params == "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j2 = 0, m2 = groups.length; j2 < m2; ++j2)
    for (var group = groups[j2], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2)
      (node2 = group[i2]) && (yield node2);
}
var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups, this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select$2(selector3) {
  return typeof selector3 == "string" ? new Selection$1([[document.querySelector(selector3)]], [document.documentElement]) : new Selection$1([[selector3]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  for (; sourceEvent2 = event.sourceEvent; ) event = sourceEvent2;
  return event;
}
function pointer(event, node2) {
  if (event = sourceEvent(event), node2 === void 0 && (node2 = event.currentTarget), node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      return point2.x = event.clientX, point2.y = event.clientY, point2 = point2.matrixTransform(node2.getScreenCTM().inverse()), [point2.x, point2.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassive = { passive: !1 }, nonpassivecapture = { capture: !0, passive: !1 };
function nopropagation$1(event) {
  event.stopImmediatePropagation();
}
function noevent$1(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select$2(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  "onselectstart" in root2 ? selection2.on("selectstart.drag", noevent$1, nonpassivecapture) : (root2.__noselect = root2.style.MozUserSelect, root2.style.MozUserSelect = "none");
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select$2(view).on("dragstart.drag", null);
  noclick && (selection2.on("click.drag", noevent$1, nonpassivecapture), setTimeout(function() {
    selection2.on("click.drag", null);
  }, 0)), "onselectstart" in root2 ? selection2.on("selectstart.drag", null) : (root2.style.MozUserSelect = root2.__noselect, delete root2.__noselect);
}
const constant$3 = (x2) => () => x2;
function DragEvent(type, {
  sourceEvent: sourceEvent2,
  subject,
  target,
  identifier,
  active,
  x: x2,
  y: y2,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    subject: { value: subject, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    identifier: { value: identifier, enumerable: !0, configurable: !0 },
    active: { value: active, enumerable: !0, configurable: !0 },
    x: { value: x2, enumerable: !0, configurable: !0 },
    y: { value: y2, enumerable: !0, configurable: !0 },
    dx: { value: dx, enumerable: !0, configurable: !0 },
    dy: { value: dy, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$1(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d2) {
  return d2 ?? { x: event.x, y: event.y };
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag$1() {
  var filter2 = defaultFilter$1, container2 = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d2) {
    if (!(touchending || !filter2.call(this, event, d2))) {
      var gesture = beforestart(this, container2.call(this, event, d2), event, d2, "mouse");
      gesture && (select$2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture), dragDisable(event.view), nopropagation$1(event), mousemoving = !1, mousedownx = event.clientX, mousedowny = event.clientY, gesture("start", event));
    }
  }
  function mousemoved(event) {
    if (noevent$1(event), !mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select$2(event.view).on("mousemove.drag mouseup.drag", null), yesdrag(event.view, mousemoving), noevent$1(event), gestures.mouse("end", event);
  }
  function touchstarted(event, d2) {
    if (filter2.call(this, event, d2)) {
      var touches = event.changedTouches, c = container2.call(this, event, d2), n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2)
        (gesture = beforestart(this, c, event, d2, touches[i2].identifier, touches[i2])) && (nopropagation$1(event), gesture("start", event, touches[i2]));
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (noevent$1(event), gesture("drag", event, touches[i2]));
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (touchending && clearTimeout(touchending), touchending = setTimeout(function() {
      touchending = null;
    }, 500), i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (nopropagation$1(event), gesture("end", event, touches[i2]));
  }
  function beforestart(that, container3, event, d2, identifier, touch) {
    var dispatch2 = listeners.copy(), p2 = pointer(touch || event, container3), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p2[0],
      y: p2[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d2)) != null)
      return dx = s2.x - p2[0] || 0, dy = s2.y - p2[1] || 0, function gesture(type, event2, touch2) {
        var p0 = p2, n2;
        switch (type) {
          case "start":
            gestures[identifier] = gesture, n2 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          // falls through
          case "drag":
            p2 = pointer(touch2 || event2, container3), n2 = active;
            break;
        }
        dispatch2.call(
          type,
          that,
          new DragEvent(type, {
            sourceEvent: event2,
            subject: s2,
            target: drag2,
            identifier,
            active: n2,
            x: p2[0] + dx,
            y: p2[1] + dy,
            dx: p2[0] - p0[0],
            dy: p2[1] - p0[1],
            dispatch: dispatch2
          }),
          d2
        );
      };
  }
  return drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ == "function" ? _ : constant$3(!!_), drag2) : filter2;
  }, drag2.container = function(_) {
    return arguments.length ? (container2 = typeof _ == "function" ? _ : constant$3(_), drag2) : container2;
  }, drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ == "function" ? _ : constant$3(_), drag2) : subject;
  }, drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ == "function" ? _ : constant$3(!!_), drag2) : touchable;
  }, drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  }, drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  }, drag2;
}
function define(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype, prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition) prototype[key2] = definition[key2];
  return prototype;
}
function Color$1() {
}
var darker = 0.7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color$1, color$1, {
  copy(channels2) {
    return Object.assign(new this.constructor(), this, channels2);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format) {
  var m2, l;
  return format = (format + "").trim().toLowerCase(), (m2 = reHex.exec(format)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba$3(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba$3(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format)) ? rgba$3(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format)) ? rgba$3(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba$3(r2, g2, b2, a2) {
  return a2 <= 0 && (r2 = g2 = b2 = NaN), new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o) {
  return o instanceof Color$1 || (o = color$1(o)), o ? (o = o.rgb(), new Rgb(o.r, o.g, o.b, o.opacity)) : new Rgb();
}
function rgb(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity ?? 1);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2, this.g = +g2, this.b = +b2, this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color$1, {
  brighter(k) {
    return k = k == null ? brighter : Math.pow(brighter, k), new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    return k = k == null ? darker : Math.pow(darker, k), new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  return value = clampi(value), (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h2, s2, l, a2) {
  return a2 <= 0 ? h2 = s2 = l = NaN : l <= 0 || l >= 1 ? h2 = s2 = NaN : s2 <= 0 && (h2 = NaN), new Hsl(h2, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (o instanceof Color$1 || (o = color$1(o)), !o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r2 = o.r / 255, g2 = o.g / 255, b2 = o.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
  return s2 ? (r2 === max2 ? h2 = (g2 - b2) / s2 + (g2 < b2) * 6 : g2 === max2 ? h2 = (b2 - r2) / s2 + 2 : h2 = (r2 - g2) / s2 + 4, s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2, h2 *= 60) : s2 = l > 0 && l < 1 ? 0 : h2, new Hsl(h2, s2, l, o.opacity);
}
function hsl(h2, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l, opacity ?? 1);
}
function Hsl(h2, s2, l, opacity) {
  this.h = +h2, this.s = +s2, this.l = +l, this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color$1, {
  brighter(k) {
    return k = k == null ? brighter : Math.pow(brighter, k), new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    return k = k == null ? darker : Math.pow(darker, k), new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  return value = (value || 0) % 360, value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) == 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant$2(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear(a2, d2) : constant$2(isNaN(a2) ? b2 : a2);
}
const interpolateRgb = (function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      return start2.r = r2(t2), start2.g = g2(t2), start2.b = b2(t2), start2.opacity = opacity(t2), start2 + "";
    };
  }
  return rgb$1.gamma = rgbGamma, rgb$1;
})(1);
function numberArray(a2, b2) {
  b2 || (b2 = []);
  var n2 = a2 ? Math.min(b2.length, a2.length) : 0, c = b2.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2) c[i2] = a2[i2] * (1 - t2) + b2[i2] * t2;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2) x2[i2] = interpolate$2(a2[i2], b2[i2]);
  for (; i2 < nb; ++i2) c[i2] = b2[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2) c[i2] = x2[i2](t2);
    return c;
  };
}
function date(a2, b2) {
  var d2 = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
  };
}
function interpolateNumber(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
function object(a2, b2) {
  var i2 = {}, c = {}, k;
  (a2 === null || typeof a2 != "object") && (a2 = {}), (b2 === null || typeof b2 != "object") && (b2 = {});
  for (k in b2)
    k in a2 ? i2[k] = interpolate$2(a2[k], b2[k]) : c[k] = b2[k];
  return function(t2) {
    for (k in i2) c[k] = i2[k](t2);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function interpolateString(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q = [];
  for (a2 = a2 + "", b2 = b2 + ""; (am = reA.exec(a2)) && (bm = reB.exec(b2)); )
    (bs = bm.index) > bi && (bs = b2.slice(bi, bs), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), (am = am[0]) === (bm = bm[0]) ? s2[i2] ? s2[i2] += bm : s2[++i2] = bm : (s2[++i2] = null, q.push({ i: i2, x: interpolateNumber(am, bm) })), bi = reB.lastIndex;
  return bi < b2.length && (bs = b2.slice(bi), s2[i2] ? s2[i2] += bs : s2[++i2] = bs), s2.length < 2 ? q[0] ? one(q[0].x) : zero(b2) : (b2 = q.length, function(t2) {
    for (var i3 = 0, o; i3 < b2; ++i3) s2[(o = q[i3]).i] = o.x(t2);
    return s2.join("");
  });
}
function interpolate$2(a2, b2) {
  var t2 = typeof b2, c;
  return b2 == null || t2 === "boolean" ? constant$2(b2) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c = color$1(b2)) ? (b2 = c, interpolateRgb) : interpolateString : b2 instanceof color$1 ? interpolateRgb : b2 instanceof Date ? date : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf != "function" && typeof b2.toString != "function" || isNaN(b2) ? object : interpolateNumber)(a2, b2);
}
var degrees$1 = 180 / Math.PI, identity$3 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b2, c, d2, e2, f2) {
  var scaleX2, scaleY2, skewX;
  return (scaleX2 = Math.sqrt(a2 * a2 + b2 * b2)) && (a2 /= scaleX2, b2 /= scaleX2), (skewX = a2 * c + b2 * d2) && (c -= a2 * skewX, d2 -= b2 * skewX), (scaleY2 = Math.sqrt(c * c + d2 * d2)) && (c /= scaleY2, d2 /= scaleY2, skewX /= scaleY2), a2 * d2 < b2 * c && (a2 = -a2, b2 = -b2, skewX = -skewX, scaleX2 = -scaleX2), {
    translateX: e2,
    translateY: f2,
    rotate: Math.atan2(b2, a2) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity$3 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  return value == null || (svgNode || (svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g")), svgNode.setAttribute("transform", value), !(value = svgNode.transform.baseVal.consolidate())) ? identity$3 : (value = value.matrix, decompose(value.a, value.b, value.c, value.d, value.e, value.f));
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb || yb) && s2.push("translate(" + xb + pxComma + yb + pxParen);
  }
  function rotate2(a2, b2, s2, q) {
    a2 !== b2 ? (a2 - b2 > 180 ? b2 += 360 : b2 - a2 > 180 && (a2 += 360), q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b2) })) : b2 && s2.push(pop(s2) + "rotate(" + b2 + degParen);
  }
  function skewX(a2, b2, s2, q) {
    a2 !== b2 ? q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b2) }) : b2 && s2.push(pop(s2) + "skewX(" + b2 + degParen);
  }
  function scale2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb !== 1 || yb !== 1) && s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
  }
  return function(a2, b2) {
    var s2 = [], q = [];
    return a2 = parse2(a2), b2 = parse2(b2), translate(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s2, q), rotate2(a2.rotate, b2.rotate, s2, q), skewX(a2.skewX, b2.skewX, s2, q), scale2(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s2, q), a2 = b2 = null, function(t2) {
      for (var i2 = -1, n2 = q.length, o; ++i2 < n2; ) s2[(o = q[i2]).i] = o.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)"), interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")"), epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = (function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
    if (d2 < epsilon2)
      S2 = Math.log(w1 / w0) / rho, i2 = function(t2) {
        return [
          ux0 + t2 * dx,
          uy0 + t2 * dy,
          w0 * Math.exp(rho * t2 * S2)
        ];
      };
    else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho, i2 = function(t2) {
        var s2 = t2 * S2, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    return i2.duration = S2 * 1e3 * rho / Math.SQRT2, i2;
  }
  return zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  }, zoom2;
})(Math.SQRT2, 2, 4);
var frame$1 = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance == "object" && performance.now ? performance : Date, setFrame = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now$1() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time2) {
    if (typeof callback != "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now$1() : +time2) + (delay2 == null ? 0 : +delay2), !this._next && taskTail !== this && (taskTail ? taskTail._next = this : taskHead = this, taskTail = this), this._call = callback, this._time = time2, sleep$1();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sleep$1());
  }
};
function timer(callback, delay2, time2) {
  var t2 = new Timer();
  return t2.restart(callback, delay2, time2), t2;
}
function timerFlush() {
  now$1(), ++frame$1;
  for (var t2 = taskHead, e2; t2; )
    (e2 = clockNow - t2._time) >= 0 && t2._call.call(void 0, e2), t2 = t2._next;
  --frame$1;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew, frame$1 = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame$1 = 0, nap(), clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay2 = now2 - clockLast;
  delay2 > pokeDelay && (clockSkew -= delay2, clockLast = now2);
}
function nap() {
  for (var t0, t1 = taskHead, t2, time2 = 1 / 0; t1; )
    t1._call ? (time2 > t1._time && (time2 = t1._time), t0 = t1, t1 = t1._next) : (t2 = t1._next, t1._next = null, t1 = t0 ? t0._next = t2 : taskHead = t2);
  taskTail = t0, sleep$1(time2);
}
function sleep$1(time2) {
  if (!frame$1) {
    timeout$1 && (timeout$1 = clearTimeout(timeout$1));
    var delay2 = time2 - clockNow;
    delay2 > 24 ? (time2 < 1 / 0 && (timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew)), interval && (interval = clearInterval(interval))) : (interval || (clockLast = clock.now(), interval = setInterval(poke, pokeDelay)), frame$1 = 1, setFrame(wake));
  }
}
function timeout(callback, delay2, time2) {
  var t2 = new Timer();
  return delay2 = delay2 == null ? 0 : +delay2, t2.restart((elapsed) => {
    t2.stop(), callback(elapsed + delay2);
  }, delay2, time2), t2;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt"), emptyTween = [], CREATED = 0, SCHEDULED = 1, STARTING = 2, STARTED = 3, RUNNING = 4, ENDING = 5, ENDED = 6;
function schedule(node2, name, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules) node2.__transition = {};
  else if (id2 in schedules) return;
  create(node2, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node2, id2) {
  var schedule2 = get$1(node2, id2);
  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
  return schedule2;
}
function set$1(node2, id2) {
  var schedule2 = get$1(node2, id2);
  if (schedule2.state > STARTED) throw new Error("too late; already running");
  return schedule2;
}
function get$1(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2, self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED, self2.timer.restart(start2, self2.delay, self2.time), self2.delay <= elapsed && start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j2, n2, o;
    if (self2.state !== SCHEDULED) return stop();
    for (i2 in schedules)
      if (o = schedules[i2], o.name === self2.name) {
        if (o.state === STARTED) return timeout(start2);
        o.state === RUNNING ? (o.state = ENDED, o.timer.stop(), o.on.call("interrupt", node2, node2.__data__, o.index, o.group), delete schedules[i2]) : +i2 < id2 && (o.state = ENDED, o.timer.stop(), o.on.call("cancel", node2, node2.__data__, o.index, o.group), delete schedules[i2]);
      }
    if (timeout(function() {
      self2.state === STARTED && (self2.state = RUNNING, self2.timer.restart(tick, self2.delay, self2.time), tick(elapsed));
    }), self2.state = STARTING, self2.on.call("start", node2, node2.__data__, self2.index, self2.group), self2.state === STARTING) {
      for (self2.state = STARTED, tween = new Array(n2 = self2.tween.length), i2 = 0, j2 = -1; i2 < n2; ++i2)
        (o = self2.tween[i2].value.call(node2, node2.__data__, self2.index, self2.group)) && (tween[++j2] = o);
      tween.length = j2 + 1;
    }
  }
  function tick(elapsed) {
    for (var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length; ++i2 < n2; )
      tween[i2].call(node2, t2);
    self2.state === ENDING && (self2.on.call("end", node2, node2.__data__, self2.index, self2.group), stop());
  }
  function stop() {
    self2.state = ENDED, self2.timer.stop(), delete schedules[id2];
    for (var i2 in schedules) return;
    delete node2.__transition;
  }
}
function interrupt(node2, name) {
  var schedules = node2.__transition, schedule2, active, empty2 = !0, i2;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule2 = schedules[i2]).name !== name) {
        empty2 = !1;
        continue;
      }
      active = schedule2.state > STARTING && schedule2.state < ENDING, schedule2.state = ENDED, schedule2.timer.stop(), schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group), delete schedules[i2];
    }
    empty2 && delete node2.__transition;
  }
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1 = tween1.slice(), tween1.splice(i2, 1);
          break;
        }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value != "function") throw new Error();
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      i2 === n2 && tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  if (name += "", arguments.length < 2) {
    for (var tween = get$1(this.node(), id2).tween, i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2)
      if ((t2 = tween[i2]).name === name)
        return t2.value;
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  return transition.each(function() {
    var schedule2 = set$1(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  }), function(node2) {
    return get$1(node2, id2).value[name];
  };
}
function interpolate$1(a2, b2) {
  var c;
  return (typeof b2 == "number" ? interpolateNumber : b2 instanceof color$1 ? interpolateRgb : (c = color$1(b2)) ? (b2 = c, interpolateRgb) : interpolateString)(a2, b2);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttribute(name) : (string0 = this.getAttribute(name), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttributeNS(fullname.space, fullname.local) : (string0 = this.getAttributeNS(fullname.space, fullname.local), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name, typeof value == "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
}
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolateNS(fullname, i2)), t0;
  }
  return tween._value = value, tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolate(name, i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_attrTween(name, value) {
  var key2 = "attr." + name;
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value != "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? delayFunction : delayConstant)(id2, value)) : get$1(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$1(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$1(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? durationFunction : durationConstant)(id2, value)) : get$1(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value != "function") throw new Error();
  return function() {
    set$1(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get$1(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 != "function") throw new Error();
    set$1(this, id2).ease = v2;
  };
}
function transition_easeVarying(value) {
  if (typeof value != "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = [], node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && match.call(node2, node2.__data__, i2, group) && subgroup.push(node2);
  return new Transition$1(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m2; ++j2)
    for (var group0 = groups0[j2], group1 = groups1[j2], n2 = group0.length, merge = merges[j2] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group0[i2] || group1[i2]) && (merge[i2] = node2);
  for (; j2 < m0; ++j2)
    merges[j2] = groups0[j2];
  return new Transition$1(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    return i2 >= 0 && (t2 = t2.slice(0, i2)), !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set$1;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    on !== on0 && (on1 = (on0 = on).copy()).on(name, listener), schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$1(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition) if (+i2 !== id2) return;
    parent && parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selector$o(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, subgroup = subgroups[j2] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && (subnode = select2.call(node2, node2.__data__, i2, group)) && ("__data__" in node2 && (subnode.__data__ = node2.__data__), subgroup[i2] = subnode, schedule(subgroup[i2], name, id2, i2, subgroup, get$1(node2, id2)));
  return new Transition$1(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selectorAll(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      if (node2 = group[i2]) {
        for (var children2 = select2.call(node2, node2.__data__, i2, group), child, inherit2 = get$1(node2, id2), k = 0, l = children2.length; k < l; ++k)
          (child = children2[k]) && schedule(child, name, id2, k, children2, inherit2);
        subgroups.push(children2), parents.push(node2);
      }
  return new Transition$1(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    return value1 == null && (string1 = value1 = (this.style.removeProperty(name), styleValue(this, name))), string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event = "end." + key2, remove2;
  return function() {
    var schedule2 = set$1(this, id2), on = schedule2.on, listener = schedule2.value[key2] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    (on !== on0 || listener0 !== listener) && (on1 = (on0 = on).copy()).on(event, listener0 = listener), schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i2 = (name += "") == "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value == "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t2 = (i0 = i2) && styleInterpolate(name, i2, priority)), t2;
  }
  return tween._value = value, tween;
}
function transition_styleTween(name, value, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key2, styleTween(name, value, priority ?? ""));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 ?? "";
  };
}
function transition_text(value) {
  return this.tween("text", typeof value == "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && textInterpolate(i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_textTween(value) {
  var key2 = "text";
  if (arguments.length < 1) return (key2 = this.tween(key2)) && key2._value;
  if (value == null) return this.tween(key2, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key2, textTween(value));
}
function transition_transition() {
  for (var name = this._name, id0 = this._id, id1 = newId(), groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      if (node2 = group[i2]) {
        var inherit2 = get$1(node2, id0);
        schedule(node2, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
  return new Transition$1(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel2 = { value: reject }, end = { value: function() {
      --size2 === 0 && resolve();
    } };
    that.each(function() {
      var schedule2 = set$1(this, id2), on = schedule2.on;
      on !== on0 && (on1 = (on0 = on).copy(), on1._.cancel.push(cancel2), on1._.interrupt.push(cancel2), on1._.end.push(end)), schedule2.on = on1;
    }), size2 === 0 && resolve();
  });
}
var id$2 = 0;
function Transition$1(groups, parents, name, id2) {
  this._groups = groups, this._parents = parents, this._name = name, this._id = id2;
}
function newId() {
  return ++id$2;
}
var selection_prototype = selection.prototype;
Transition$1.prototype = {
  constructor: Transition$1,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  for (var timing; !(timing = node2.__transition) || !(timing = timing[id2]); )
    if (!(node2 = node2.parentNode))
      throw new Error(`transition ${id2} not found`);
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  name instanceof Transition$1 ? (id2 = name._id, name = name._name) : (id2 = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "");
  for (var groups = this._groups, m2 = groups.length, j2 = 0; j2 < m2; ++j2)
    for (var group = groups[j2], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2)
      (node2 = group[i2]) && schedule(node2, name, id2, i2, group, timing || inherit(node2, id2));
  return new Transition$1(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const constant$1 = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    transform: { value: transform2, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
function Transform(k, x2, y2) {
  this.k = k, this.x = x2, this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$2 = new Transform(1, 0, 0);
transform$1.prototype = Transform.prototype;
function transform$1(node2) {
  for (; !node2.__zoom; ) if (!(node2 = node2.parentNode)) return identity$2;
  return node2.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  return e2 instanceof SVGElement ? (e2 = e2.ownerSVGElement || e2, e2.hasAttribute("viewBox") ? (e2 = e2.viewBox.baseVal, [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]]) : [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]]) : [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity$2;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, 1 / 0], translateExtent = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: !1 }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point2, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform), collection !== selection2 ? schedule2(collection, transform2, point2, event) : selection2.interrupt().each(function() {
      gesture(this, arguments).event(event).start().zoom(null, typeof transform2 == "function" ? transform2.apply(this, arguments) : transform2).end();
    });
  }, zoom2.scaleBy = function(selection2, k, p2, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k == "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p2, event);
  }, zoom2.scaleTo = function(selection2, k, p2, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 == "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k == "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale2(t0, k1), p0, p1), e2, translateExtent);
    }, p2, event);
  }, zoom2.translateBy = function(selection2, x2, y2, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 == "function" ? x2.apply(this, arguments) : x2,
        typeof y2 == "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  }, zoom2.translateTo = function(selection2, x2, y2, p2, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 == "function" ? p2.apply(this, arguments) : p2;
      return constrain(identity$2.translate(p0[0], p0[1]).scale(t2.k).translate(
        typeof x2 == "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 == "function" ? -y2.apply(this, arguments) : -y2
      ), e2, translateExtent);
    }, p2, event);
  };
  function scale2(transform2, k) {
    return k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k)), k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point2, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g2 = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point2 == null ? centroid(e2) : typeof point2 == "function" ? point2.apply(that, args) : point2, w2 = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b2 = typeof transform2 == "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p2).concat(w2 / a2.k), b2.invert(p2).concat(w2 / b2.k));
      return function(t2) {
        if (t2 === 1) t2 = b2;
        else {
          var l = i2(t2), k = w2 / l[2];
          t2 = new Transform(k, p2[0] - l[0] * k, p2[1] - l[1] * k);
        }
        g2.zoom(null, t2);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that, this.args = args, this.active = 0, this.sourceEvent = null, this.extent = extent.apply(that, args), this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      return event && (this.sourceEvent = event), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(key2, transform2) {
      return this.mouse && key2 !== "mouse" && (this.mouse[1] = transform2.invert(this.mouse[0])), this.touch0 && key2 !== "touch" && (this.touch0[1] = transform2.invert(this.touch0[0])), this.touch1 && key2 !== "touch" && (this.touch1[1] = transform2.invert(this.touch1[0])), this.that.__zoom = transform2, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(type) {
      var d2 = select$2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d2
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g2 = gesture(this, args).event(event), t2 = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p2 = pointer(event);
    if (g2.wheel)
      (g2.mouse[0][0] !== p2[0] || g2.mouse[0][1] !== p2[1]) && (g2.mouse[1] = t2.invert(g2.mouse[0] = p2)), clearTimeout(g2.wheel);
    else {
      if (t2.k === k) return;
      g2.mouse = [p2, t2.invert(p2)], interrupt(this), g2.start();
    }
    noevent(event), g2.wheel = setTimeout(wheelidled, wheelDelay), g2.zoom("mouse", constrain(translate(scale2(t2, k), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
    function wheelidled() {
      g2.wheel = null, g2.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g2 = gesture(this, args, !0).event(event), v2 = select$2(event.view).on("mousemove.zoom", mousemoved, !0).on("mouseup.zoom", mouseupped, !0), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view), nopropagation(event), g2.mouse = [p2, this.__zoom.invert(p2)], interrupt(this), g2.start();
    function mousemoved(event2) {
      if (noevent(event2), !g2.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g2.moved = dx * dx + dy * dy > clickDistance2;
      }
      g2.event(event2).zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = pointer(event2, currentTarget), g2.mouse[1]), g2.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null), yesdrag(event2.view, g2.moved), noevent(event2), g2.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale2(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent(event), duration > 0 ? select$2(this).transition().duration(duration).call(schedule2, t1, p0, event) : select$2(this).call(zoom2.transform, t1, p0, event);
    }
  }
  function touchstarted(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var touches = event.touches, n2 = touches.length, g2 = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p2;
      for (nopropagation(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p2 = pointer(t2, this), p2 = [p2, this.__zoom.invert(p2), t2.identifier], g2.touch0 ? !g2.touch1 && g2.touch0[2] !== p2[2] && (g2.touch1 = p2, g2.taps = 0) : (g2.touch0 = p2, started = !0, g2.taps = 1 + !!touchstarting);
      touchstarting && (touchstarting = clearTimeout(touchstarting)), started && (g2.taps < 2 && (touchfirst = p2[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay)), interrupt(this), g2.start());
    }
  }
  function touchmoved(event, ...args) {
    if (this.__zooming) {
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p2, l;
      for (noevent(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p2 = pointer(t2, this), g2.touch0 && g2.touch0[2] === t2.identifier ? g2.touch0[0] = p2 : g2.touch1 && g2.touch1[2] === t2.identifier && (g2.touch1[0] = p2);
      if (t2 = g2.that.__zoom, g2.touch1) {
        var p0 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale2(t2, Math.sqrt(dp / dl)), p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2], l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g2.touch0) p2 = g2.touch0[0], l = g2.touch0[1];
      else return;
      g2.zoom("touch", constrain(translate(t2, p2, l), g2.extent, translateExtent));
    }
  }
  function touchended(event, ...args) {
    if (this.__zooming) {
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
      for (nopropagation(event), touchending && clearTimeout(touchending), touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], g2.touch0 && g2.touch0[2] === t2.identifier ? delete g2.touch0 : g2.touch1 && g2.touch1[2] === t2.identifier && delete g2.touch1;
      if (g2.touch1 && !g2.touch0 && (g2.touch0 = g2.touch1, delete g2.touch1), g2.touch0) g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
      else if (g2.end(), g2.taps === 2 && (t2 = pointer(t2, this), Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance)) {
        var p2 = select$2(this).on("dblclick.zoom");
        p2 && p2.apply(this, arguments);
      }
    }
  }
  return zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta2 = typeof _ == "function" ? _ : constant$1(+_), zoom2) : wheelDelta2;
  }, zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ == "function" ? _ : constant$1(!!_), zoom2) : filter2;
  }, zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ == "function" ? _ : constant$1(!!_), zoom2) : touchable;
  }, zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ == "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  }, zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  }, zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  }, zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  }, zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  }, zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
  }, zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  }, zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  }, zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  }, zoom2;
}
const errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib2 = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib2}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], elementSelectionKeys = ["Enter", " ", "Escape"], defaultAriaLabelConfig = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction, x: x2, y: y2 }) => `Moved selected node ${direction}. New position, x: ${x2}, y: ${y2}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2.Strict = "strict", ConnectionMode2.Loose = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2.Free = "free", PanOnScrollMode2.Vertical = "vertical", PanOnScrollMode2.Horizontal = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2.Partial = "partial", SelectionMode2.Full = "full";
})(SelectionMode || (SelectionMode = {}));
const initialConnection = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
  pointer: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2.Bezier = "default", ConnectionLineType2.Straight = "straight", ConnectionLineType2.Step = "step", ConnectionLineType2.SmoothStep = "smoothstep", ConnectionLineType2.SimpleBezier = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2.Arrow = "arrow", MarkerType2.ArrowClosed = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2.Left = "left", Position2.Top = "top", Position2.Right = "right", Position2.Bottom = "bottom";
})(Position || (Position = {}));
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
const isEdgeBase = (element) => "id" in element && "source" in element && "target" in element, isNodeBase = (element) => "id" in element && "position" in element && !("source" in element) && !("target" in element), isInternalNodeBase = (element) => "id" in element && "internals" in element && !("source" in element) && !("target" in element), getNodePositionWithOrigin = (node2, nodeOrigin = [0, 0]) => {
  const { width, height } = getNodeDimensions(node2), origin = node2.origin ?? nodeOrigin, offsetX = width * origin[0], offsetY = height * origin[1];
  return {
    x: node2.position.x - offsetX,
    y: node2.position.y - offsetY
  };
}, getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {
  if (nodes.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId == "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    params.nodeLookup && (currentNode = isId ? params.nodeLookup.get(nodeOrId) : isInternalNodeBase(nodeOrId) ? nodeOrId : params.nodeLookup.get(nodeOrId.id));
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return boxToRect(box);
}, getInternalNodesBounds = (nodeLookup, params = {}) => {
  let box = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, hasVisibleNodes = !1;
  return nodeLookup.forEach((node2) => {
    (params.filter === void 0 || params.filter(node2)) && (box = getBoundsOfBoxes(box, nodeToBox(node2)), hasVisibleNodes = !0);
  }), hasVisibleNodes ? boxToRect(box) : { x: 0, y: 0, width: 0, height: 0 };
}, getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = !1, excludeNonSelectableNodes = !1) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  }, visibleNodes = [];
  for (const node2 of nodes.values()) {
    const { measured, selectable = !0, hidden: hidden2 = !1 } = node2;
    if (excludeNonSelectableNodes && !selectable || hidden2)
      continue;
    const width = measured.width ?? node2.width ?? node2.initialWidth ?? null, height = measured.height ?? node2.height ?? node2.initialHeight ?? null, overlappingArea = getOverlappingArea(paneRect, nodeToRect$1(node2)), area = (width ?? 0) * (height ?? 0), partiallyVisible = partially && overlappingArea > 0;
    (!node2.internals.handleBounds || partiallyVisible || overlappingArea >= area || node2.dragging) && visibleNodes.push(node2);
  }
  return visibleNodes;
}, getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  return nodes.forEach((node2) => {
    nodeIds.add(node2.id);
  }), edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map(), optionNodeIds = options?.nodes ? new Set(options.nodes.map((node2) => node2.id)) : null;
  return nodeLookup.forEach((n2) => {
    n2.measured.width && n2.measured.height && (options?.includeHiddenNodes || !n2.hidden) && (!optionNodeIds || optionNodeIds.has(n2.id)) && fitViewNodes.set(n2.id, n2);
  }), fitViewNodes;
}
async function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0)
    return Promise.resolve(!0);
  const nodesToFit = getFitViewNodes(nodes, options), bounds = getInternalNodesBounds(nodesToFit), viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);
  return await panZoom.setViewport(viewport, {
    duration: options?.duration,
    ease: options?.ease,
    interpolate: options?.interpolate
  }), Promise.resolve(!0);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node2 = nodeLookup.get(nodeId), parentNode = node2.parentId ? nodeLookup.get(node2.parentId) : void 0, { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 }, origin = node2.origin ?? nodeOrigin;
  let extent = node2.extent || nodeExtent;
  if (node2.extent === "parent" && !node2.expandParent)
    if (!parentNode)
      onError?.("005", errorMessages.error005());
    else {
      const parentWidth = parentNode.measured.width, parentHeight = parentNode.measured.height;
      parentWidth && parentHeight && (extent = [
        [parentX, parentY],
        [parentX + parentWidth, parentY + parentHeight]
      ]);
    }
  else parentNode && isCoordinateExtent(node2.extent) && (extent = [
    [node2.extent[0][0] + parentX, node2.extent[0][1] + parentY],
    [node2.extent[1][0] + parentX, node2.extent[1][1] + parentY]
  ]);
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node2.measured) : nextPosition;
  return (node2.measured.width === void 0 || node2.measured.height === void 0) && onError?.("015", errorMessages.error015()), {
    position: {
      x: positionAbsolute.x - parentX + (node2.measured.width ?? 0) * origin[0],
      y: positionAbsolute.y - parentY + (node2.measured.height ?? 0) * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node2) => node2.id)), matchingNodes = [];
  for (const node2 of nodes) {
    if (node2.deletable === !1)
      continue;
    const isIncluded = nodeIds.has(node2.id), parentHit = !isIncluded && node2.parentId && matchingNodes.find((n2) => n2.id === node2.parentId);
    (isIncluded || parentHit) && matchingNodes.push(node2);
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id)), deletableEdges = edges.filter((edge) => edge.deletable !== !1), matchingEdges = getConnectedEdges(matchingNodes, deletableEdges);
  for (const edge of deletableEdges)
    edgeIds.has(edge.id) && !matchingEdges.find((e2) => e2.id === edge.id) && matchingEdges.push(edge);
  if (!onBeforeDelete)
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  return typeof onBeforeDeleteResult == "boolean" ? onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] } : onBeforeDeleteResult;
}
const clamp$4 = (val, min2 = 0, max2 = 1) => Math.min(Math.max(val, min2), max2), clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({
  x: clamp$4(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),
  y: clamp$4(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0))
});
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent), { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
const calcAutoPanVelocity = (value, min2, max2) => value < min2 ? clamp$4(Math.abs(value - min2), 1, min2) / min2 : value > max2 ? -clamp$4(Math.abs(value - max2), 1, min2) / min2 : 0, calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed, yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
}, getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
}), rectToBox = ({ x: x2, y: y2, width, height }) => ({
  x: x2,
  y: y2,
  x2: x2 + width,
  y2: y2 + height
}), boxToRect = ({ x: x2, y: y2, x2: x22, y2: y22 }) => ({
  x: x2,
  y: y2,
  width: x22 - x2,
  height: y22 - y2
}), nodeToRect$1 = (node2, nodeOrigin = [0, 0]) => {
  const { x: x2, y: y2 } = isInternalNodeBase(node2) ? node2.internals.positionAbsolute : getNodePositionWithOrigin(node2, nodeOrigin);
  return {
    x: x2,
    y: y2,
    width: node2.measured?.width ?? node2.width ?? node2.initialWidth ?? 0,
    height: node2.measured?.height ?? node2.height ?? node2.initialHeight ?? 0
  };
}, nodeToBox = (node2, nodeOrigin = [0, 0]) => {
  const { x: x2, y: y2 } = isInternalNodeBase(node2) ? node2.internals.positionAbsolute : getNodePositionWithOrigin(node2, nodeOrigin);
  return {
    x: x2,
    y: y2,
    x2: x2 + (node2.measured?.width ?? node2.width ?? node2.initialWidth ?? 0),
    y2: y2 + (node2.measured?.height ?? node2.height ?? node2.initialHeight ?? 0)
  };
}, getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2))), getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x)), yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
}, isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y), isNumeric = (n2) => !isNaN(n2) && isFinite(n2), devWarn = (id2, message) => {
}, snapPosition = (position, snapGrid = [1, 1]) => ({
  x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
  y: snapGrid[1] * Math.round(position.y / snapGrid[1])
}), pointToRendererPoint = ({ x: x2, y: y2 }, [tx, ty, tScale], snapToGrid = !1, snapGrid = [1, 1]) => {
  const position = {
    x: (x2 - tx) / tScale,
    y: (y2 - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
}, rendererPointToPoint = ({ x: x2, y: y2 }, [tx, ty, tScale]) => ({
  x: x2 * tScale + tx,
  y: y2 * tScale + ty
});
function parsePadding(padding, viewport) {
  if (typeof padding == "number")
    return Math.floor((viewport - viewport / (1 + padding)) * 0.5);
  if (typeof padding == "string" && padding.endsWith("px")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue))
      return Math.floor(paddingValue);
  }
  if (typeof padding == "string" && padding.endsWith("%")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue))
      return Math.floor(viewport * paddingValue * 0.01);
  }
  return console.error(`[React Flow] The padding value "${padding}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function parsePaddings(padding, width, height) {
  if (typeof padding == "string" || typeof padding == "number") {
    const paddingY = parsePadding(padding, height), paddingX = parsePadding(padding, width);
    return {
      top: paddingY,
      right: paddingX,
      bottom: paddingY,
      left: paddingX,
      x: paddingX * 2,
      y: paddingY * 2
    };
  }
  if (typeof padding == "object") {
    const top = parsePadding(padding.top ?? padding.y ?? 0, height), bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height), left = parsePadding(padding.left ?? padding.x ?? 0, width), right = parsePadding(padding.right ?? padding.x ?? 0, width);
    return { top, right, bottom, left, x: left + right, y: top + bottom };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function calculateAppliedPaddings(bounds, x2, y2, zoom2, width, height) {
  const { x: left, y: top } = rendererPointToPoint(bounds, [x2, y2, zoom2]), { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x2, y2, zoom2]), right = width - boundRight, bottom = height - boundBottom;
  return {
    left: Math.floor(left),
    top: Math.floor(top),
    right: Math.floor(right),
    bottom: Math.floor(bottom)
  };
}
const getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const p2 = parsePaddings(padding, width, height), xZoom = (width - p2.x) / bounds.width, yZoom = (height - p2.y) / bounds.height, zoom2 = Math.min(xZoom, yZoom), clampedZoom = clamp$4(zoom2, minZoom, maxZoom), boundsCenterX = bounds.x + bounds.width / 2, boundsCenterY = bounds.y + bounds.height / 2, x2 = width / 2 - boundsCenterX * clampedZoom, y2 = height / 2 - boundsCenterY * clampedZoom, newPadding = calculateAppliedPaddings(bounds, x2, y2, clampedZoom, width, height), offset2 = {
    left: Math.min(newPadding.left - p2.left, 0),
    top: Math.min(newPadding.top - p2.top, 0),
    right: Math.min(newPadding.right - p2.right, 0),
    bottom: Math.min(newPadding.bottom - p2.bottom, 0)
  };
  return {
    x: x2 - offset2.left + offset2.right,
    y: y2 - offset2.top + offset2.bottom,
    zoom: clampedZoom
  };
}, isMacOs = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function isCoordinateExtent(extent) {
  return extent != null && extent !== "parent";
}
function getNodeDimensions(node2) {
  return {
    width: node2.measured?.width ?? node2.width ?? node2.initialWidth ?? 0,
    height: node2.measured?.height ?? node2.height ?? node2.initialHeight ?? 0
  };
}
function nodeHasDimensions(node2) {
  return (node2.measured?.width ?? node2.width ?? node2.initialWidth) !== void 0 && (node2.measured?.height ?? node2.height ?? node2.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  const positionAbsolute = { ...position }, parent = nodeLookup.get(parentId);
  if (parent) {
    const origin = parent.origin || nodeOrigin;
    positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0], positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];
  }
  return positionAbsolute;
}
function areSetsEqual$1(a2, b2) {
  if (a2.size !== b2.size)
    return !1;
  for (const item of a2)
    if (!b2.has(item))
      return !1;
  return !0;
}
function withResolvers() {
  let resolve, reject;
  return { promise: new Promise((res, rej) => {
    resolve = res, reject = rej;
  }), resolve, reject };
}
function mergeAriaLabelConfig(partial) {
  return { ...defaultAriaLabelConfig, ...partial || {} };
}
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = !1, transform: transform2, containerBounds }) {
  const { x: x2, y: y2 } = getEventPosition(event), pointerPos = pointToRendererPoint({ x: x2 - (containerBounds?.left ?? 0), y: y2 - (containerBounds?.top ?? 0) }, transform2), { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
const getDimensions$1 = (node2) => ({
  width: node2.offsetWidth,
  height: node2.offsetHeight
}), getHostForElement = (element) => element?.getRootNode?.() || window?.document, inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event) {
  const target = event.composedPath?.()?.[0] || event.target;
  return target?.nodeType !== 1 ? !1 : inputTags.includes(target.nodeName) || target.hasAttribute("contenteditable") || !!target.closest(".nokey");
}
const isMouseEvent = (event) => "clientX" in event, getEventPosition = (event, bounds) => {
  const isMouse = isMouseEvent(event), evtX = isMouse ? event.clientX : event.touches?.[0].clientX, evtY = isMouse ? event.clientY : event.touches?.[0].clientY;
  return {
    x: evtX - (bounds?.left ?? 0),
    y: evtY - (bounds?.top ?? 0)
  };
}, getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  return !handles || !handles.length ? null : Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions$1(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125, centerY2 = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125, offsetX = Math.abs(centerX - sourceX), offsetY = Math.abs(centerY2 - sourceY);
  return [centerX, centerY2, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  return distance2 >= 0 ? 0.5 * distance2 : curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  }), [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter$1({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2, centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset, yOffset = Math.abs(targetY - sourceY) / 2, centerY2 = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY2, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected: selected2 = !1, zIndex = 0, elevateOnSelect = !1, zIndexMode = "basic" }) {
  if (zIndexMode === "manual")
    return zIndex;
  const edgeZ = elevateOnSelect && selected2 ? zIndex + 1e3 : zIndex, nodeZ = Math.max(sourceNode.parentId || elevateOnSelect && sourceNode.selected ? sourceNode.internals.z : 0, targetNode.parentId || elevateOnSelect && targetNode.selected ? targetNode.internals.z : 0);
  return edgeZ + nodeZ;
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  edgeBox.x === edgeBox.x2 && (edgeBox.x2 += 1), edgeBox.y === edgeBox.y2 && (edgeBox.y2 += 1);
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
const getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`, connectionExists = (edge, edges) => edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle)), addEdge = (edgeParams, edges, options = {}) => {
  if (!edgeParams.source || !edgeParams.target)
    return edges;
  const edgeIdGenerator = options.getEdgeId || getEdgeId;
  let edge;
  return isEdgeBase(edgeParams) ? edge = { ...edgeParams } : edge = {
    ...edgeParams,
    id: edgeIdGenerator(edgeParams)
  }, connectionExists(edge, edges) ? edges : (edge.sourceHandle === null && delete edge.sourceHandle, edge.targetHandle === null && delete edge.targetHandle, edges.concat(edge));
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter$1({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
}, getDirection = ({ source, sourcePosition = Position.Bottom, target }) => sourcePosition === Position.Left || sourcePosition === Position.Right ? source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, distance$1 = (a2, b2) => Math.sqrt(Math.pow(b2.x - a2.x, 2) + Math.pow(b2.y - a2.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset: offset2, stepPosition }) {
  const sourceDir = handleDirections[sourcePosition], targetDir = handleDirections[targetPosition], sourceGapped = { x: source.x + sourceDir.x * offset2, y: source.y + sourceDir.y * offset2 }, targetGapped = { x: target.x + targetDir.x * offset2, y: target.y + targetDir.y * offset2 }, dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  }), dirAccessor = dir.x !== 0 ? "x" : "y", currDir = dir[dirAccessor];
  let points = [], centerX, centerY2;
  const sourceGapOffset = { x: 0, y: 0 }, targetGapOffset = { x: 0, y: 0 }, [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter$1({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    dirAccessor === "x" ? (centerX = center.x ?? sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition, centerY2 = center.y ?? (sourceGapped.y + targetGapped.y) / 2) : (centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2, centerY2 = center.y ?? sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ], horizontalSplit = [
      { x: sourceGapped.x, y: centerY2 },
      { x: targetGapped.x, y: centerY2 }
    ];
    sourceDir[dirAccessor] === currDir ? points = dirAccessor === "x" ? verticalSplit : horizontalSplit : points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }], targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x" ? points = sourceDir.x === currDir ? targetSource : sourceTarget : points = sourceDir.y === currDir ? sourceTarget : targetSource, sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset2) {
        const gapOffset = Math.min(offset2 - 1, offset2 - diff);
        sourceDir[dirAccessor] === currDir ? sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset : targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x", isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite], sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite], sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      (sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo)) && (points = dirAccessor === "x" ? sourceTarget : targetSource);
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y }, targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y }, maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x)), maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    maxXDistance >= maxYDistance ? (centerX = (sourceGapPoint.x + targetGapPoint.x) / 2, centerY2 = points[0].y) : (centerX = points[0].x, centerY2 = (sourceGapPoint.y + targetGapPoint.y) / 2);
  }
  return [[
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ], centerX, centerY2, defaultOffsetX, defaultOffsetY];
}
function getBend(a2, b2, c, size2) {
  const bendSize = Math.min(distance$1(a2, b2) / 2, distance$1(b2, c) / 2, size2), { x: x2, y: y2 } = b2;
  if (a2.x === x2 && x2 === c.x || a2.y === y2 && y2 === c.y)
    return `L${x2} ${y2}`;
  if (a2.y === y2) {
    const xDir2 = a2.x < c.x ? -1 : 1, yDir2 = a2.y < c.y ? 1 : -1;
    return `L ${x2 + bendSize * xDir2},${y2}Q ${x2},${y2} ${x2},${y2 + bendSize * yDir2}`;
  }
  const xDir = a2.x < c.x ? 1 : -1, yDir = a2.y < c.y ? -1 : 1;
  return `L ${x2},${y2 + bendSize * yDir}Q ${x2},${y2} ${x2 + bendSize * xDir},${y2}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY: centerY2, offset: offset2 = 20, stepPosition = 0.5 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY2 },
    offset: offset2,
    stepPosition
  });
  return [points.reduce((res, p2, i2) => {
    let segment = "";
    return i2 > 0 && i2 < points.length - 1 ? segment = getBend(points[i2 - 1], p2, points[i2 + 1], borderRadius) : segment = `${i2 === 0 ? "M" : "L"}${p2.x} ${p2.y}`, res += segment, res;
  }, ""), labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node2) {
  return node2 && !!(node2.internals.handleBounds || node2.handles?.length) && !!(node2.measured.width || node2.width || node2.initialWidth);
}
function getEdgePosition(params) {
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode))
    return null;
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles), targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles), sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle), targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? targetHandleBounds?.target ?? [] : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle)
    return params.onError?.("008", errorMessages.error008(sourceHandle ? "target" : "source", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    })), null;
  const sourcePosition = sourceHandle?.position || Position.Bottom, targetPosition = targetHandle?.position || Position.Top, source = getHandlePosition(sourceNode, sourceHandle, sourcePosition), target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles)
    return null;
  const source = [], target = [];
  for (const handle of handles)
    handle.width = handle.width ?? 1, handle.height = handle.height ?? 1, handle.type === "source" ? source.push(handle) : handle.type === "target" && target.push(handle);
  return {
    source,
    target
  };
}
function getHandlePosition(node2, handle, fallbackPosition = Position.Left, center = !1) {
  const x2 = (handle?.x ?? 0) + node2.internals.positionAbsolute.x, y2 = (handle?.y ?? 0) + node2.internals.positionAbsolute.y, { width, height } = handle ?? getNodeDimensions(node2);
  if (center)
    return { x: x2 + width / 2, y: y2 + height / 2 };
  switch (handle?.position ?? fallbackPosition) {
    case Position.Top:
      return { x: x2 + width / 2, y: y2 };
    case Position.Right:
      return { x: x2 + width, y: y2 + height / 2 };
    case Position.Bottom:
      return { x: x2 + width / 2, y: y2 + height };
    case Position.Left:
      return { x: x2, y: y2 + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  return bounds && (handleId ? bounds.find((d2) => d2.id === handleId) : bounds[0]) || null;
}
function getMarkerId(marker, id2) {
  return marker ? typeof marker == "string" ? marker : `${id2 ? `${id2}__` : ""}${Object.keys(marker).sort().map((key2) => `${key2}=${marker[key2]}`).join("&")}` : "";
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => ([edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
    if (marker && typeof marker == "object") {
      const markerId = getMarkerId(marker, id2);
      ids.has(markerId) || (markers.push({ id: markerId, color: marker.color || defaultColor, ...marker }), ids.add(markerId));
    }
  }), markers), []).sort((a2, b2) => a2.id.localeCompare(b2.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset2, align) {
  let alignmentOffset = 0.5;
  align === "start" ? alignmentOffset = 0 : align === "end" && (alignmentOffset = 1);
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset2
  ], shift2 = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset2, shift2[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift2[0]}%, ${shift2[1]}%)`;
}
const SELECTED_NODE_Z = 1e3, ROOT_PARENT_Z_INCREMENT = 10, defaultOptions$1 = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: !0,
  zIndexMode: "basic",
  defaults: {}
}, adoptUserNodesDefaultOptions = {
  ...defaultOptions$1,
  checkEquality: !0
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key2 in incoming)
    incoming[key2] !== void 0 && (result[key2] = incoming[key2]);
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  const _options = mergeObjects(defaultOptions$1, options);
  for (const node2 of nodeLookup.values())
    if (node2.parentId)
      updateChildNode(node2, nodeLookup, parentLookup, _options);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(node2, _options.nodeOrigin), extent = isCoordinateExtent(node2.extent) ? node2.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node2));
      node2.internals.positionAbsolute = clampedPosition;
    }
}
function parseHandles(userNode, internalNode) {
  if (!userNode.handles)
    return userNode.measured ? internalNode?.internals.handleBounds : void 0;
  const source = [], target = [];
  for (const handle of userNode.handles) {
    const handleBounds = {
      id: handle.id,
      width: handle.width ?? 1,
      height: handle.height ?? 1,
      nodeId: userNode.id,
      x: handle.x,
      y: handle.y,
      position: handle.position,
      type: handle.type
    };
    handle.type === "source" ? source.push(handleBounds) : handle.type === "target" && target.push(handleBounds);
  }
  return {
    source,
    target
  };
}
function isManualZIndexMode(zIndexMode) {
  return zIndexMode === "manual";
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options = {}) {
  const _options = mergeObjects(adoptUserNodesDefaultOptions, options), rootParentIndex = { i: 0 }, tmpLookup = new Map(nodeLookup), selectedNodeZ = _options?.elevateNodesOnSelect && !isManualZIndexMode(_options.zIndexMode) ? SELECTED_NODE_Z : 0;
  let nodesInitialized = nodes.length > 0;
  nodeLookup.clear(), parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === internalNode?.internals.userNode)
      nodeLookup.set(userNode.id, internalNode);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin), extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: userNode.measured?.width,
          height: userNode.measured?.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: parseHandles(userNode, internalNode),
          z: calculateZ(userNode, selectedNodeZ, _options.zIndexMode),
          userNode
        }
      }, nodeLookup.set(userNode.id, internalNode);
    }
    (internalNode.measured === void 0 || internalNode.measured.width === void 0 || internalNode.measured.height === void 0) && !internalNode.hidden && (nodesInitialized = !1), userNode.parentId && updateChildNode(internalNode, nodeLookup, parentLookup, options, rootParentIndex);
  }
  return nodesInitialized;
}
function updateParentLookup(node2, parentLookup) {
  if (!node2.parentId)
    return;
  const childNodes = parentLookup.get(node2.parentId);
  childNodes ? childNodes.set(node2.id, node2) : parentLookup.set(node2.parentId, /* @__PURE__ */ new Map([[node2.id, node2]]));
}
function updateChildNode(node2, nodeLookup, parentLookup, options, rootParentIndex) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent, zIndexMode } = mergeObjects(defaultOptions$1, options), parentId = node2.parentId, parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node2, parentLookup), rootParentIndex && !parentNode.parentId && parentNode.internals.rootParentIndex === void 0 && zIndexMode === "auto" && (parentNode.internals.rootParentIndex = ++rootParentIndex.i, parentNode.internals.z = parentNode.internals.z + rootParentIndex.i * ROOT_PARENT_Z_INCREMENT), rootParentIndex && parentNode.internals.rootParentIndex !== void 0 && (rootParentIndex.i = parentNode.internals.rootParentIndex);
  const selectedNodeZ = elevateNodesOnSelect && !isManualZIndexMode(zIndexMode) ? SELECTED_NODE_Z : 0, { x: x2, y: y2, z: z2 } = calculateChildXYZ(node2, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode), { positionAbsolute } = node2.internals, positionChanged = x2 !== positionAbsolute.x || y2 !== positionAbsolute.y;
  (positionChanged || z2 !== node2.internals.z) && nodeLookup.set(node2.id, {
    ...node2,
    internals: {
      ...node2.internals,
      positionAbsolute: positionChanged ? { x: x2, y: y2 } : positionAbsolute,
      z: z2
    }
  });
}
function calculateZ(node2, selectedNodeZ, zIndexMode) {
  const zIndex = isNumeric(node2.zIndex) ? node2.zIndex : 0;
  return isManualZIndexMode(zIndexMode) ? zIndex : zIndex + (node2.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode) {
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute, childDimensions = getNodeDimensions(childNode), positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin), clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  childNode.extent === "parent" && (absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode));
  const childZ = calculateZ(childNode, selectedNodeZ, zIndexMode), parentZ = parentNode.internals.z ?? 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ >= childZ ? parentZ + 1 : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  const changes = [], parentExpansions = /* @__PURE__ */ new Map();
  for (const child of children2) {
    const parent = nodeLookup.get(child.parentId);
    if (!parent)
      continue;
    const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect$1(parent), expandedRect = getBoundsOfRects(parentRect, child.rect);
    parentExpansions.set(child.parentId, { expandedRect, parent });
  }
  return parentExpansions.size > 0 && parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
    const positionAbsolute = parent.internals.positionAbsolute, dimensions = getNodeDimensions(parent), origin = parent.origin ?? nodeOrigin, xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0, yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0, newWidth = Math.max(dimensions.width, Math.round(expandedRect.width)), newHeight = Math.max(dimensions.height, Math.round(expandedRect.height)), widthChange = (newWidth - dimensions.width) * origin[0], heightChange = (newHeight - dimensions.height) * origin[1];
    (xChange > 0 || yChange > 0 || widthChange || heightChange) && (changes.push({
      id: parentId,
      type: "position",
      position: {
        x: parent.position.x - xChange + widthChange,
        y: parent.position.y - yChange + heightChange
      }
    }), parentLookup.get(parentId)?.forEach((childNode) => {
      children2.some((child) => child.id === childNode.id) || changes.push({
        id: childNode.id,
        type: "position",
        position: {
          x: childNode.position.x + xChange,
          y: childNode.position.y + yChange
        }
      });
    })), (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) && changes.push({
      id: parentId,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
      }
    });
  }), changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, zIndexMode) {
  const viewportNode = domNode?.querySelector(".xyflow__viewport");
  let updatedInternals = !1;
  if (!viewportNode)
    return { changes: [], updatedInternals };
  const changes = [], style2 = window.getComputedStyle(viewportNode), { m22: zoom2 } = new window.DOMMatrixReadOnly(style2.transform), parentExpandChildren = [];
  for (const update of updates.values()) {
    const node2 = nodeLookup.get(update.id);
    if (!node2)
      continue;
    if (node2.hidden) {
      nodeLookup.set(node2.id, {
        ...node2,
        internals: {
          ...node2.internals,
          handleBounds: void 0
        }
      }), updatedInternals = !0;
      continue;
    }
    const dimensions = getDimensions$1(update.nodeElement), dimensionChanged = node2.measured.width !== dimensions.width || node2.measured.height !== dimensions.height;
    if (!!(dimensions.width && dimensions.height && (dimensionChanged || !node2.internals.handleBounds || update.force))) {
      const nodeBounds = update.nodeElement.getBoundingClientRect(), extent = isCoordinateExtent(node2.extent) ? node2.extent : nodeExtent;
      let { positionAbsolute } = node2.internals;
      node2.parentId && node2.extent === "parent" ? positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node2.parentId)) : extent && (positionAbsolute = clampPosition(positionAbsolute, extent, dimensions));
      const newNode = {
        ...node2,
        measured: dimensions,
        internals: {
          ...node2.internals,
          positionAbsolute,
          handleBounds: {
            source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node2.id),
            target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node2.id)
          }
        }
      };
      nodeLookup.set(node2.id, newNode), node2.parentId && updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin, zIndexMode }), updatedInternals = !0, dimensionChanged && (changes.push({
        id: node2.id,
        type: "dimensions",
        dimensions
      }), node2.expandParent && node2.parentId && parentExpandChildren.push({
        id: node2.id,
        parentId: node2.parentId,
        rect: nodeToRect$1(newNode, nodeOrigin)
      }));
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y)
    return Promise.resolve(!1);
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent), transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {
  let key2 = nodeId;
  const nodeMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
  connectionLookup.set(key2, nodeMap.set(connectionKey, connection)), key2 = `${nodeId}-${type}`;
  const typeMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
  if (connectionLookup.set(key2, typeMap.set(connectionKey, connection)), handleId) {
    key2 = `${nodeId}-${type}-${handleId}`;
    const handleMap = connectionLookup.get(key2) || /* @__PURE__ */ new Map();
    connectionLookup.set(key2, handleMap.set(connectionKey, connection));
  }
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear(), edgeLookup.clear();
  for (const edge of edges) {
    const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge, connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle }, sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`, targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;
    addConnectionToLookup("source", connection, targetKey, connectionLookup, sourceNode, sourceHandle), addConnectionToLookup("target", connection, sourceKey, connectionLookup, targetNode, targetHandle), edgeLookup.set(edge.id, edge);
  }
}
function isParentSelected(node2, nodeLookup) {
  if (!node2.parentId)
    return !1;
  const parentNode = nodeLookup.get(node2.parentId);
  return parentNode ? parentNode.selected ? !0 : isParentSelected(parentNode, nodeLookup) : !1;
}
function hasSelector(target, selector3, domNode) {
  let current2 = target;
  do {
    if (current2?.matches?.(selector3))
      return !0;
    if (current2 === domNode)
      return !1;
    current2 = current2?.parentElement;
  } while (current2);
  return !1;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node2] of nodeLookup)
    if ((node2.selected || node2.id === nodeId) && (!node2.parentId || !isParentSelected(node2, nodeLookup)) && (node2.draggable || nodesDraggable && typeof node2.draggable > "u")) {
      const internalNode = nodeLookup.get(id2);
      internalNode && dragItems.set(id2, {
        id: id2,
        position: internalNode.position || { x: 0, y: 0 },
        distance: {
          x: mousePos.x - internalNode.internals.positionAbsolute.x,
          y: mousePos.y - internalNode.internals.positionAbsolute.y
        },
        extent: internalNode.extent,
        parentId: internalNode.parentId,
        origin: internalNode.origin,
        expandParent: internalNode.expandParent,
        internals: {
          positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: internalNode.measured.width ?? 0,
          height: internalNode.measured.height ?? 0
        }
      });
    }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = !0 }) {
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node22 = nodeLookup.get(id2)?.internals.userNode;
    node22 && nodesFromDragItems.push({
      ...node22,
      position: dragItem.position,
      dragging
    });
  }
  if (!nodeId)
    return [nodesFromDragItems[0], nodesFromDragItems];
  const node2 = nodeLookup.get(nodeId)?.internals.userNode;
  return [
    node2 ? {
      ...node2,
      position: dragItems.get(nodeId)?.position || node2.position,
      dragging
    } : nodesFromDragItems[0],
    nodesFromDragItems
  ];
}
function calculateSnapOffset({ dragItems, snapGrid, x: x2, y: y2 }) {
  const refDragItem = dragItems.values().next().value;
  if (!refDragItem)
    return null;
  const refPos = {
    x: x2 - refDragItem.distance.x,
    y: y2 - refDragItem.distance.y
  }, refPosSnapped = snapPosition(refPos, snapGrid);
  return {
    x: refPosSnapped.x - refPos.x,
    y: refPosSnapped.y - refPos.y
  };
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null }, autoPanId = 0, dragItems = /* @__PURE__ */ new Map(), autoPanStarted = !1, mousePosition = { x: 0, y: 0 }, containerBounds = null, dragStarted = !1, d3Selection = null, abortDrag = !1, nodePositionsChanged = !1, dragEvent = null;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select$2(domNode);
    function updateNodes2({ x: x2, y: y2 }) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x: x2, y: y2 };
      let hasChange = !1;
      const isMultiDrag = dragItems.size > 1, nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null, multiDragSnapOffset = isMultiDrag && snapToGrid ? calculateSnapOffset({
        dragItems,
        snapGrid,
        x: x2,
        y: y2
      }) : null;
      for (const [id2, dragItem] of dragItems) {
        if (!nodeLookup.has(id2))
          continue;
        let nextPosition = { x: x2 - dragItem.distance.x, y: y2 - dragItem.distance.y };
        snapToGrid && (nextPosition = multiDragSnapOffset ? {
          x: Math.round(nextPosition.x + multiDragSnapOffset.x),
          y: Math.round(nextPosition.y + multiDragSnapOffset.y)
        } : snapPosition(nextPosition, snapGrid));
        let adjustedNodeExtent = null;
        if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals, x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0], x22 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0], y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1], y22 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x22, y22]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent || nodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y, dragItem.position = position, dragItem.internals.positionAbsolute = positionAbsolute;
      }
      if (nodePositionsChanged = nodePositionsChanged || hasChange, !!hasChange && (updateNodePositions(dragItems, !0), dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag))) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag?.(dragEvent, dragItems, currentNode, currentNodes), onNodeDrag?.(dragEvent, currentNode, currentNodes), nodeId || onSelectionDrag?.(dragEvent, currentNodes);
      }
    }
    async function autoPan() {
      if (!containerBounds)
        return;
      const { transform: transform2, panBy: panBy2, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();
      if (!autoPanOnNodeDrag) {
        autoPanStarted = !1, cancelAnimationFrame(autoPanId);
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      (xMovement !== 0 || yMovement !== 0) && (lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2], lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2], await panBy2({ x: xMovement, y: yMovement }) && updateNodes2(lastPos)), autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = !0, (!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId && (nodeLookup.get(nodeId)?.selected || unselectNodesAndEdges()), isSelectable && selectNodesOnDrag && nodeId && onNodeMouseDown?.(nodeId);
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if (lastPos = pointerPos, dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId), dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStart?.(event.sourceEvent, currentNodes);
      }
    }
    const d3DragInstance = drag$1().clickDistance(nodeClickDistance).on("start", (event) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      containerBounds = domNode2?.getBoundingClientRect() || null, abortDrag = !1, nodePositionsChanged = !1, dragEvent = event.sourceEvent, nodeDragThreshold === 0 && startDrag(event), lastPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds }), mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems(), pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if (dragEvent = event.sourceEvent, (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) && (abortDrag = !0), !abortDrag) {
        if (!autoPanStarted && autoPanOnNodeDrag && dragStarted && (autoPanStarted = !0, autoPan()), !dragStarted) {
          const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds), x2 = currentMousePosition.x - mousePosition.x, y2 = currentMousePosition.y - mousePosition.y;
          Math.sqrt(x2 * x2 + y2 * y2) > nodeDragThreshold && startDrag(event);
        }
        (lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted && (mousePosition = getEventPosition(event.sourceEvent, containerBounds), updateNodes2(pointerPos));
      }
    }).on("end", (event) => {
      if (!(!dragStarted || abortDrag) && (autoPanStarted = !1, dragStarted = !1, cancelAnimationFrame(autoPanId), dragItems.size > 0)) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        if (nodePositionsChanged && (updateNodePositions(dragItems, !1), nodePositionsChanged = !1), onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: !1
          });
          onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStop?.(event.sourceEvent, currentNodes);
        }
      }
    }).filter((event) => {
      const target = event.target;
      return !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection?.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance2) {
  const nodes = [], rect = {
    x: position.x - distance2,
    y: position.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node2 of nodeLookup.values())
    getOverlappingArea(rect, nodeToRect$1(node2)) > 0 && nodes.push(node2);
  return nodes;
}
const ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  let closestHandles = [], minDistance = 1 / 0;
  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node2 of closeNodes) {
    const allHandles = [...node2.internals.handleBounds?.source ?? [], ...node2.internals.handleBounds?.target ?? []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id)
        continue;
      const { x: x2, y: y2 } = getHandlePosition(node2, handle, handle.position, !0), distance2 = Math.sqrt(Math.pow(x2 - position.x, 2) + Math.pow(y2 - position.y, 2));
      distance2 > connectionRadius || (distance2 < minDistance ? (closestHandles = [{ ...handle, x: x2, y: y2 }], minDistance = distance2) : distance2 === minDistance && closestHandles.push({ ...handle, x: x2, y: y2 }));
    }
  }
  if (!closestHandles.length)
    return null;
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = !1) {
  const node2 = nodeLookup.get(nodeId);
  if (!node2)
    return null;
  const handles = connectionMode === "strict" ? node2.internals.handleBounds?.[handleType] : [...node2.internals.handleBounds?.source ?? [], ...node2.internals.handleBounds?.target ?? []], handle = (handleId ? handles?.find((h2) => h2.id === handleId) : handles?.[0]) ?? null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node2, handle, handle.position, !0) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  return edgeUpdaterType || (handleDomNode?.classList.contains("target") ? "target" : handleDomNode?.classList.contains("source") ? "source" : null);
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  return isHandleValid ? isValid = !0 : isInsideConnectionRadius && !isHandleValid && (isValid = !1), isValid;
}
const alwaysValid = () => !0;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib: lib2, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0, closestHandle;
  const { x: x2, y: y2 } = getEventPosition(event), handleType = getHandleType(edgeUpdaterType, handleDomNode), containerBounds = domNode?.getBoundingClientRect();
  let connectionStarted = !1;
  if (!containerBounds || !handleType)
    return;
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal)
    return;
  let position = getEventPosition(event, containerBounds), autoPanStarted = !1, connection = null, isValid = !1, resultHandleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds)
      return;
    const [x22, y22] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x22, y: y22 }), autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  }, fromInternalNode = nodeLookup.get(nodeId);
  let previousConnection = {
    inProgress: !0,
    isValid: null,
    from: getHandlePosition(fromInternalNode, fromHandle, Position.Left, !0),
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromInternalNode,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null,
    pointer: position
  };
  function startConnection() {
    connectionStarted = !0, updateConnection(previousConnection), onConnectStart?.(event, { nodeId, handleId, handleType });
  }
  dragThreshold === 0 && startConnection();
  function onPointerMove(event2) {
    if (!connectionStarted) {
      const { x: evtX, y: evtY } = getEventPosition(event2), dx = evtX - x2, dy = evtY - y2;
      if (!(dx * dx + dy * dy > dragThreshold * dragThreshold))
        return;
      startConnection();
    }
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event2);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event2, containerBounds), closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, !1, [1, 1]), connectionRadius, nodeLookup, fromHandle), autoPanStarted || (autoPan(), autoPanStarted = !0);
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib: lib2,
      flowId,
      nodeLookup
    });
    resultHandleDomNode = result.handleDomNode, connection = result.connection, isValid = isConnectionValid(!!closestHandle, result.isValid);
    const fromInternalNode2 = nodeLookup.get(nodeId), from2 = fromInternalNode2 ? getHandlePosition(fromInternalNode2, fromHandle, Position.Left, !0) : previousConnection.from, newConnection = {
      ...previousConnection,
      from: from2,
      isValid,
      to: result.toHandle && isValid ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,
      pointer: position
    };
    updateConnection(newConnection), previousConnection = newConnection;
  }
  function onPointerUp(event2) {
    if (!("touches" in event2 && event2.touches.length > 0)) {
      if (connectionStarted) {
        (closestHandle || resultHandleDomNode) && connection && isValid && onConnect?.(connection);
        const { inProgress, ...connectionState } = previousConnection, finalConnectionState = {
          ...connectionState,
          toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
        };
        onConnectEnd?.(event2, finalConnectionState), edgeUpdaterType && onReconnectEnd?.(event2, finalConnectionState);
      }
      cancelConnection(), cancelAnimationFrame(autoPanId), autoPanStarted = !1, isValid = !1, connection = null, resultHandleDomNode = null, doc.removeEventListener("mousemove", onPointerMove), doc.removeEventListener("mouseup", onPointerUp), doc.removeEventListener("touchmove", onPointerMove), doc.removeEventListener("touchend", onPointerUp);
    }
  }
  doc.addEventListener("mousemove", onPointerMove), doc.addEventListener("mouseup", onPointerUp), doc.addEventListener("touchmove", onPointerMove), doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib: lib2, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target", handleDomNode = handle ? doc.querySelector(`.${lib2}-flow__handle[data-id="${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}"]`) : null, { x: x2, y: y2 } = getEventPosition(event), handleBelow = doc.elementFromPoint(x2, y2), handleToCheck = handleBelow?.classList.contains(`${lib2}-flow__handle`) ? handleBelow : handleDomNode, result = {
    handleDomNode: handleToCheck,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck), handleNodeId = handleToCheck.getAttribute("data-nodeid"), handleId = handleToCheck.getAttribute("data-handleid"), connectable = handleToCheck.classList.contains("connectable"), connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType)
      return result;
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isValid = connectable && connectableEnd && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection), result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, !0);
  }
  return result;
}
const XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select$2(domNode);
  function update({ translateExtent, width, height, zoomStep = 1, pannable = !0, zoomable = !0, inversePan = !1 }) {
    const zoomHandler = (event) => {
      if (event.sourceEvent.type !== "wheel" || !panZoom)
        return;
      const transform2 = getTransform(), factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1, pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep, nextZoom = transform2[2] * Math.pow(2, pinchDelta * factor);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event) => {
      (event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart") && (panStart = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ]);
    }, panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" && event.sourceEvent.type !== "touchmove" || !panZoom)
        return;
      const panCurrent = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ], panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1), position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      }, extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    }, zoomAndPanHandler = zoom().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer
  };
}
const transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
}), viewportToTransform = ({ x: x2, y: y2, zoom: zoom2 }) => identity$2.translate(x2, y2).scale(zoom2), isWrappedWithClass = (event, className) => event.target.closest(`.${className}`), isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2), defaultEase = (t2) => ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2, getD3Transition = (selection2, duration = 0, ease2 = defaultEase, onEnd = () => {
}) => {
  const hasDuration = typeof duration == "number" && duration > 0;
  return hasDuration || onEnd(), hasDuration ? selection2.transition().duration(duration).ease(ease2).on("end", onEnd) : selection2;
}, wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName))
      return event.ctrlKey && event.preventDefault(), !1;
    event.preventDefault(), event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event.ctrlKey && zoomOnPinch) {
      const point2 = pointer(event), pinchDelta = wheelDelta(event), zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point2, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize, deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    !isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical && (deltaX = event.deltaY * deltaNormalize, deltaY = 0), d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: !0 }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout), zoomPanValues.isPanScrolling ? (onPanZoom?.(event, nextViewport), zoomPanValues.panScrollTimeout = setTimeout(() => {
      onPanZoomEnd?.(event, nextViewport), zoomPanValues.isPanScrolling = !1;
    }, 150)) : (zoomPanValues.isPanScrolling = !0, onPanZoomStart?.(event, nextViewport));
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d2) {
    const isWheel = event.type === "wheel", preventZoom = !preventScrolling && isWheel && !event.ctrlKey, hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);
    if (event.ctrlKey && isWheel && hasNoWheelClass && event.preventDefault(), preventZoom || hasNoWheelClass)
      return null;
    event.preventDefault(), d3ZoomHandler.call(this, event, d2);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    if (event.sourceEvent?.internal)
      return;
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = event.sourceEvent?.button || 0, zoomPanValues.isZoomingOrPanning = !0, zoomPanValues.prevViewport = viewport, event.sourceEvent?.type === "mousedown" && onDraggingChange(!0), onPanZoomStart && onPanZoomStart?.(event.sourceEvent, viewport);
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0)), event.sourceEvent?.sync || onTransformChange([event.transform.x, event.transform.y, event.transform.k]), onPanZoom && !event.sourceEvent?.internal && onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    if (!event.sourceEvent?.internal && (zoomPanValues.isZoomingOrPanning = !1, onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent && onPaneContextMenu(event.sourceEvent), zoomPanValues.usedRightMouseButton = !1, onDraggingChange(!1), onPanZoomEnd)) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport, clearTimeout(zoomPanValues.timerId), zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd?.(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib: lib2, connectionInProgress }) {
  return (event) => {
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll, pinchZoom = zoomOnPinch && event.ctrlKey, isWheelEvent = event.type === "wheel";
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib2}-flow__node`) || isWrappedWithClass(event, `${lib2}-flow__edge`)))
      return !0;
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch || userSelectionActive || connectionInProgress && !isWheelEvent || isWrappedWithClass(event, noWheelClassName) && isWheelEvent || isWrappedWithClass(event, noPanClassName) && (!isWheelEvent || panOnScroll && isWheelEvent && !zoomActivationKeyPressed) || !zoomOnPinch && event.ctrlKey && isWheelEvent)
      return !1;
    if (!zoomOnPinch && event.type === "touchstart" && event.touches?.length > 1)
      return event.preventDefault(), !1;
    if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent || !panOnDrag && (event.type === "mousedown" || event.type === "touchstart") || Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown")
      return !1;
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || isWheelEvent) && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: {},
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, bbox = domNode.getBoundingClientRect(), d3ZoomInstance = zoom().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent), d3Selection = select$2(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp$4(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom"), d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? interpolate$2 : interpolateZoom).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(!0)), transform2);
    }) : Promise.resolve(!1);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib: lib2, onTransformChange, connectionInProgress, paneClickDistance, selectionOnDrag }) {
    userSelectionActive && !zoomPanValues.isZoomingOrPanning && destroy();
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    d3ZoomInstance.clickDistance(selectionOnDrag ? 1 / 0 : !isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance);
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    if (d3Selection.on("wheel.zoom", wheelHandler, { passive: !1 }), !userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib: lib2,
      connectionInProgress
    });
    d3ZoomInstance.filter(filter2), zoomOnDoubleClick ? d3Selection.on("dblclick.zoom", d3DblClickZoomHandler) : d3Selection.on("dblclick.zoom", null);
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2), contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent2);
    return contrainedTransform && await setTransform(contrainedTransform), new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport2(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    return await setTransform(nextTransform, options), new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2), currentTransform = d3Selection.property("__zoom");
      (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) && d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: !0 });
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform$1(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? interpolate$2 : interpolateZoom).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(!0)), zoom2);
    }) : Promise.resolve(!1);
  }
  function scaleBy(factor, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? interpolate$2 : interpolateZoom).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(!0)), factor);
    }) : Promise.resolve(!1);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance?.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance?.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance?.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport: setViewport2,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2.Line = "line", ResizeControlVariant2.Handle = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth, deltaHeight = height - prevHeight, direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  return deltaWidth && affectsX && (direction[0] = direction[0] * -1), deltaHeight && affectsY && (direction[1] = direction[1] * -1), direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left"), isVertical = controlPosition.includes("bottom") || controlPosition.includes("top"), affectsX = controlPosition.includes("left"), affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size2, minSize, maxSize) {
  return Math.max(0, minSize - size2, size2 - maxSize);
}
function xor(a2, b2) {
  return a2 ? !b2 : b2;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection, isDiagonal = isHorizontal && isVertical, { xSnapped, ySnapped } = pointerPosition, { minWidth, maxWidth, minHeight, maxHeight } = boundaries, { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio: aspectRatio2 } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0), distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX), newHeight = startHeight + (affectsY ? -distY : distY), originOffsetX = -nodeOrigin[0] * startWidth, originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth), clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX < 0 ? xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]) : !affectsX && distX > 0 && (xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0])), affectsY && distY < 0 ? yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]) : !affectsY && distY > 0 && (yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX > 0 ? xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]) : !affectsX && distX < 0 && (xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0])), affectsY && distY > 0 ? yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]) : !affectsY && distY < 0 && (yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio2, minHeight, maxHeight) * aspectRatio2;
      if (clampX = Math.max(clampX, aspectHeightClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio2, extent[1][1]) * aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio2, extent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio2, childExtent[1][1]) * aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio2, childExtent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio2, minWidth, maxWidth) / aspectRatio2;
      if (clampY = Math.max(clampY, aspectWidthClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio2 + originOffsetX, extent[1][0]) / aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2 + originOffsetX, extent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio2, childExtent[1][0]) / aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2, childExtent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY), distX = distX + (distX < 0 ? clampX : -clampX), keepAspectRatio && (isDiagonal ? newWidth > newHeight * aspectRatio2 ? distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio2 : distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio2 : isHorizontal ? (distY = distX / aspectRatio2, affectsY = affectsX) : (distX = distY * aspectRatio2, affectsX = affectsY));
  const x2 = affectsX ? startX + distX : startX, y2 = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (affectsX ? -1 : 1) + x2,
    y: nodeOrigin[1] * distY * (affectsY ? -1 : 1) + y2
  };
}
const initPrevValues$1 = { width: 0, height: 0, x: 0, y: 0 }, initStartValues = {
  ...initPrevValues$1,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node2) {
  return [
    [0, 0],
    [node2.measured.width, node2.measured.height]
  ];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  const x2 = parent.position.x + child.position.x, y2 = parent.position.y + child.position.y, width = child.measured.width ?? 0, height = child.measured.height ?? 0, originOffsetX = nodeOrigin[0] * width, originOffsetY = nodeOrigin[1] * height;
  return [
    [x2 - originOffsetX, y2 - originOffsetY],
    [x2 + width - originOffsetX, y2 + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection2 = select$2(domNode);
  let params = {
    controlDirection: getControlDirection("bottom-right"),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE
    },
    resizeDirection: void 0,
    keepAspectRatio: !1
  };
  function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues$1 }, startValues = { ...initStartValues };
    params = {
      boundaries,
      resizeDirection,
      keepAspectRatio,
      controlDirection: getControlDirection(controlPosition)
    };
    let node2, containerBounds = null, childNodes = [], parentNode, parentExtent, childExtent, resizeDetected = !1;
    const dragHandler = drag$1().on("start", (event) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();
      if (node2 = nodeLookup.get(nodeId), !node2)
        return;
      containerBounds = paneDomNode?.getBoundingClientRect() ?? null;
      const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      prevValues = {
        width: node2.measured.width ?? 0,
        height: node2.measured.height ?? 0,
        x: node2.position.x ?? 0,
        y: node2.position.y ?? 0
      }, startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      }, parentNode = void 0, node2.parentId && (node2.extent === "parent" || node2.expandParent) && (parentNode = nodeLookup.get(node2.parentId), parentExtent = parentNode && node2.extent === "parent" ? nodeToParentExtent(parentNode) : void 0), childNodes = [], childExtent = void 0;
      for (const [childId, child] of nodeLookup)
        if (child.parentId === nodeId && (childNodes.push({
          id: childId,
          position: { ...child.position },
          extent: child.extent
        }), child.extent === "parent" || child.expandParent)) {
          const extent = nodeToChildExtent(child, node2, child.origin ?? nodeOrigin);
          childExtent ? childExtent = [
            [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
            [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
          ] : childExtent = extent;
        }
      onResizeStart?.(event, { ...prevValues });
    }).on("drag", (event) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems(), pointerPosition = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      }), childChanges = [];
      if (!node2)
        return;
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues, change2 = {}, nodeOrigin = node2.origin ?? storeNodeOrigin, { width, height, x: x2, y: y2 } = getDimensionsAfterResize(startValues, params.controlDirection, pointerPosition, params.boundaries, params.keepAspectRatio, nodeOrigin, parentExtent, childExtent), isWidthChange = width !== prevWidth, isHeightChange = height !== prevHeight, isXPosChange = x2 !== prevX && isWidthChange, isYPosChange = y2 !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange)
        return;
      if ((isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) && (change2.x = isXPosChange ? x2 : prevValues.x, change2.y = isYPosChange ? y2 : prevValues.y, prevValues.x = change2.x, prevValues.y = change2.y, childNodes.length > 0)) {
        const xChange = x2 - prevX, yChange = y2 - prevY;
        for (const childNode of childNodes)
          childNode.position = {
            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
          }, childChanges.push(childNode);
      }
      if ((isWidthChange || isHeightChange) && (change2.width = isWidthChange && (!params.resizeDirection || params.resizeDirection === "horizontal") ? width : prevValues.width, change2.height = isHeightChange && (!params.resizeDirection || params.resizeDirection === "vertical") ? height : prevValues.height, prevValues.width = change2.width, prevValues.height = change2.height), parentNode && node2.expandParent) {
        const xLimit = nodeOrigin[0] * (change2.width ?? 0);
        change2.x && change2.x < xLimit && (prevValues.x = xLimit, startValues.x = startValues.x - (change2.x - xLimit));
        const yLimit = nodeOrigin[1] * (change2.height ?? 0);
        change2.y && change2.y < yLimit && (prevValues.y = yLimit, startValues.y = startValues.y - (change2.y - yLimit));
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: params.controlDirection.affectsX,
        affectsY: params.controlDirection.affectsY
      }), nextValues = { ...prevValues, direction };
      shouldResize?.(event, nextValues) !== !1 && (resizeDetected = !0, onResize?.(event, nextValues), onChange(change2, childChanges));
    }).on("end", (event) => {
      resizeDetected && (onResizeEnd?.(event, { ...prevValues }), onEnd?.({ ...prevValues }), resizeDetected = !1);
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var withSelector = { exports: {} }, withSelector_production = {}, shim = { exports: {} }, useSyncExternalStoreShim_production = {};
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = React__default;
  function is2(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is2, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue2 = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState2({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    return useLayoutEffect2(
      function() {
        inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    ), useEffect2(
      function() {
        return checkIfSnapshotChanged(inst) && forceUpdate({ inst }), subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    ), useDebugValue2(value), value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch {
      return !0;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? useSyncExternalStore$1 : useSyncExternalStore$2;
  return useSyncExternalStoreShim_production.useSyncExternalStore = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim2, useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, shim.exports = requireUseSyncExternalStoreShim_production()), shim.exports;
}
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = React__default, shim2 = requireShim();
  function is2(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is2, useSyncExternalStore = shim2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue2 = React2.useDebugValue;
  return withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector3, isEqual) {
    var instRef = useRef2(null);
    if (instRef.current === null) {
      var inst = { hasValue: !1, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo2(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector3(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector3(nextSnapshot);
          return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector3, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    return useEffect2(
      function() {
        inst.hasValue = !0, inst.value = value;
      },
      [value]
    ), useDebugValue2(value), value;
  }, withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  return hasRequiredWithSelector || (hasRequiredWithSelector = 1, withSelector.exports = requireWithSelector_production()), withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports), __vite_import_meta_env__ = {}, createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set(), setState = (partial, replace) => {
    const nextState = typeof partial == "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = replace ?? (typeof nextState != "object" || nextState === null) ? nextState : Object.assign({}, state, nextState), listeners.forEach((listener) => listener(state, previousState));
    }
  }, getState = () => state, api = { setState, getState, getInitialState: () => initialState2, subscribe: (listener) => (listeners.add(listener), () => listeners.delete(listener)), destroy: () => {
    (__vite_import_meta_env__ ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), listeners.clear();
  } }, initialState2 = state = createState2(setState, getState, api);
  return api;
}, createStore$1 = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl, { useDebugValue } = React__default, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports, identity$1 = (arg) => arg;
function useStoreWithEqualityFn(api, selector3 = identity$1, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector3,
    equalityFn
  );
  return useDebugValue(slice), slice;
}
const createWithEqualityFnImpl = (createState2, defaultEqualityFn) => {
  const api = createStore$1(createState2), useBoundStoreWithEqualityFn = (selector3, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector3, equalityFn);
  return Object.assign(useBoundStoreWithEqualityFn, api), useBoundStoreWithEqualityFn;
}, createWithEqualityFn = (createState2, defaultEqualityFn) => createState2 ? createWithEqualityFnImpl(createState2, defaultEqualityFn) : createWithEqualityFnImpl;
function shallow$1(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return !1;
    for (const [key2, value] of objA)
      if (!Object.is(value, objB.get(key2)))
        return !1;
    return !0;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return !1;
    for (const value of objA)
      if (!objB.has(value))
        return !1;
    return !0;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (const keyA of keysA)
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA]))
      return !1;
  return !0;
}
const StoreContext = createContext(null), Provider$1 = StoreContext.Provider, zustandErrorMessage = errorMessages.error001();
function useStore(selector22, equalityFn) {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useStoreWithEqualityFn(store, selector22, equalityFn);
}
function useStoreApi() {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useMemo(() => ({
    getState: store.getState,
    setState: store.setState,
    subscribe: store.subscribe
  }), [store]);
}
const style = { display: "none" }, ariaLiveStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, ARIA_NODE_DESC_KEY = "react-flow__node-desc", ARIA_EDGE_DESC_KEY = "react-flow__edge-desc", ARIA_LIVE_MESSAGE = "react-flow__aria-live", ariaLiveSelector = (s2) => s2.ariaLiveMessage, ariaLabelConfigSelector = (s2) => s2.ariaLabelConfig;
function AriaLiveMessage({ rfId }) {
  const ariaLiveMessage = useStore(ariaLiveSelector);
  return jsx("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle, children: ariaLiveMessage });
}
function A11yDescriptions({ rfId, disableKeyboardA11y }) {
  const ariaLabelConfig = useStore(ariaLabelConfigSelector);
  return jsxs(Fragment, { children: [jsx("div", { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style, children: disableKeyboardA11y ? ariaLabelConfig["node.a11yDescription.default"] : ariaLabelConfig["node.a11yDescription.keyboardDisabled"] }), jsx("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style, children: ariaLabelConfig["edge.a11yDescription.default"] }), !disableKeyboardA11y && jsx(AriaLiveMessage, { rfId })] });
}
const Panel = forwardRef(({ position = "top-left", children: children2, className, style: style2, ...rest }, ref) => {
  const positionClasses = `${position}`.split("-");
  return jsx("div", { className: cc(["react-flow__panel", className, ...positionClasses]), style: style2, ref, ...rest, children: children2 });
});
Panel.displayName = "Panel";
function Attribution({ proOptions, position = "bottom-right" }) {
  return proOptions?.hideAttribution ? null : jsx(Panel, { position, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const selector$m = (s2) => {
  const selectedNodes = [], selectedEdges = [];
  for (const [, node2] of s2.nodeLookup)
    node2.selected && selectedNodes.push(node2.internals.userNode);
  for (const [, edge] of s2.edgeLookup)
    edge.selected && selectedEdges.push(edge);
  return { selectedNodes, selectedEdges };
}, selectId = (obj) => obj.id;
function areEqual(a2, b2) {
  return shallow$1(a2.selectedNodes.map(selectId), b2.selectedNodes.map(selectId)) && shallow$1(a2.selectedEdges.map(selectId), b2.selectedEdges.map(selectId));
}
function SelectionListenerInner({ onSelectionChange }) {
  const store = useStoreApi(), { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);
  return useEffect(() => {
    const params = { nodes: selectedNodes, edges: selectedEdges };
    onSelectionChange?.(params), store.getState().onSelectionChangeHandlers.forEach((fn) => fn(params));
  }, [selectedNodes, selectedEdges, onSelectionChange]), null;
}
const changeSelector = (s2) => !!s2.onSelectionChangeHandlers;
function SelectionListener({ onSelectionChange }) {
  const storeHasSelectionChangeHandlers = useStore(changeSelector);
  return onSelectionChange || storeHasSelectionChangeHandlers ? jsx(SelectionListenerInner, { onSelectionChange }) : null;
}
const defaultNodeOrigin = [0, 0], defaultViewport = { x: 0, y: 0, zoom: 1 }, reactFlowFieldsToTrack = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "ariaLabelConfig",
  "zIndexMode"
], fieldsToTrack = [...reactFlowFieldsToTrack, "rfId"], selector$l = (s2) => ({
  setNodes: s2.setNodes,
  setEdges: s2.setEdges,
  setMinZoom: s2.setMinZoom,
  setMaxZoom: s2.setMaxZoom,
  setTranslateExtent: s2.setTranslateExtent,
  setNodeExtent: s2.setNodeExtent,
  reset: s2.reset,
  setDefaultNodesAndEdges: s2.setDefaultNodesAndEdges
}), initPrevValues = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: infiniteExtent,
  nodeOrigin: defaultNodeOrigin,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1"
};
function StoreUpdater(props) {
  const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges } = useStore(selector$l, shallow$1), store = useStoreApi();
  useEffect(() => (setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges), () => {
    previousFields.current = initPrevValues, reset();
  }), []);
  const previousFields = useRef(initPrevValues);
  return useEffect(
    () => {
      for (const fieldName of fieldsToTrack) {
        const fieldValue = props[fieldName], previousFieldValue = previousFields.current[fieldName];
        fieldValue !== previousFieldValue && (typeof props[fieldName] > "u" || (fieldName === "nodes" ? setNodes(fieldValue) : fieldName === "edges" ? setEdges(fieldValue) : fieldName === "minZoom" ? setMinZoom(fieldValue) : fieldName === "maxZoom" ? setMaxZoom(fieldValue) : fieldName === "translateExtent" ? setTranslateExtent(fieldValue) : fieldName === "nodeExtent" ? setNodeExtent(fieldValue) : fieldName === "ariaLabelConfig" ? store.setState({ ariaLabelConfig: mergeAriaLabelConfig(fieldValue) }) : fieldName === "fitView" ? store.setState({ fitViewQueued: fieldValue }) : fieldName === "fitViewOptions" ? store.setState({ fitViewOptions: fieldValue }) : store.setState({ [fieldName]: fieldValue })));
      }
      previousFields.current = props;
    },
    // Only re-run the effect if one of the fields we track changes
    fieldsToTrack.map((fieldName) => props[fieldName])
  ), null;
}
function getMediaQuery() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode) {
  const [colorModeClass, setColorModeClass] = useState(colorMode === "system" ? null : colorMode);
  return useEffect(() => {
    if (colorMode !== "system") {
      setColorModeClass(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery(), updateColorModeClass = () => setColorModeClass(mediaQuery?.matches ? "dark" : "light");
    return updateColorModeClass(), mediaQuery?.addEventListener("change", updateColorModeClass), () => {
      mediaQuery?.removeEventListener("change", updateColorModeClass);
    };
  }, [colorMode]), colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? "dark" : "light";
}
const defaultDoc = typeof document < "u" ? document : null;
function useKeyPress(keyCode = null, options = { target: defaultDoc, actInsideInputWithModifier: !0 }) {
  const [keyPressed, setKeyPressed] = useState(!1), modifierPressed = useRef(!1), pressedKeys = useRef(/* @__PURE__ */ new Set([])), [keyCodes, keysToWatch] = useMemo(() => {
    if (keyCode !== null) {
      const keys2 = (Array.isArray(keyCode) ? keyCode : [keyCode]).filter((kc) => typeof kc == "string").map((kc) => kc.replace("+", `
`).replace(`

`, `
+`).split(`
`)), keysFlat = keys2.reduce((res, item) => res.concat(...item), []);
      return [keys2, keysFlat];
    }
    return [[], []];
  }, [keyCode]);
  return useEffect(() => {
    const target = options?.target ?? defaultDoc, actInsideInputWithModifier = options?.actInsideInputWithModifier ?? !0;
    if (keyCode !== null) {
      const downHandler = (event) => {
        if (modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey, (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && isInputDOMNode(event))
          return !1;
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        if (pressedKeys.current.add(event[keyOrCode]), isMatchingKey(keyCodes, pressedKeys.current, !1)) {
          const target2 = event.composedPath?.()?.[0] || event.target, isInteractiveElement = target2?.nodeName === "BUTTON" || target2?.nodeName === "A";
          options.preventDefault !== !1 && (modifierPressed.current || !isInteractiveElement) && event.preventDefault(), setKeyPressed(!0);
        }
      }, upHandler = (event) => {
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        isMatchingKey(keyCodes, pressedKeys.current, !0) ? (setKeyPressed(!1), pressedKeys.current.clear()) : pressedKeys.current.delete(event[keyOrCode]), event.key === "Meta" && pressedKeys.current.clear(), modifierPressed.current = !1;
      }, resetHandler = () => {
        pressedKeys.current.clear(), setKeyPressed(!1);
      };
      return target?.addEventListener("keydown", downHandler), target?.addEventListener("keyup", upHandler), window.addEventListener("blur", resetHandler), window.addEventListener("contextmenu", resetHandler), () => {
        target?.removeEventListener("keydown", downHandler), target?.removeEventListener("keyup", upHandler), window.removeEventListener("blur", resetHandler), window.removeEventListener("contextmenu", resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]), keyPressed;
}
function isMatchingKey(keyCodes, pressedKeys, isUp) {
  return keyCodes.filter((keys2) => isUp || keys2.length === pressedKeys.size).some((keys2) => keys2.every((k) => pressedKeys.has(k)));
}
function useKeyOrCode(eventCode, keysToWatch) {
  return keysToWatch.includes(eventCode) ? "code" : "key";
}
const useViewportHelper = () => {
  const store = useStoreApi();
  return useMemo(() => ({
    zoomIn: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1.2, { duration: options?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1 / 1.2, { duration: options?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (zoomLevel, options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => store.getState().transform[2],
    setViewport: async (viewport, options) => {
      const { transform: [tX, tY, tZoom], panZoom } = store.getState();
      return panZoom ? (await panZoom.setViewport({
        x: viewport.x ?? tX,
        y: viewport.y ?? tY,
        zoom: viewport.zoom ?? tZoom
      }, options), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [x2, y2, zoom2] = store.getState().transform;
      return { x: x2, y: y2, zoom: zoom2 };
    },
    setCenter: async (x2, y2, options) => store.getState().setCenter(x2, y2, options),
    fitBounds: async (bounds, options) => {
      const { width, height, minZoom, maxZoom, panZoom } = store.getState(), viewport = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);
      return panZoom ? (await panZoom.setViewport(viewport, {
        duration: options?.duration,
        ease: options?.ease,
        interpolate: options?.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (clientPosition, options = {}) => {
      const { transform: transform2, snapGrid, snapToGrid, domNode } = store.getState();
      if (!domNode)
        return clientPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), correctedPosition = {
        x: clientPosition.x - domX,
        y: clientPosition.y - domY
      }, _snapGrid = options.snapGrid ?? snapGrid, _snapToGrid = options.snapToGrid ?? snapToGrid;
      return pointToRendererPoint(correctedPosition, transform2, _snapToGrid, _snapGrid);
    },
    flowToScreenPosition: (flowPosition) => {
      const { transform: transform2, domNode } = store.getState();
      if (!domNode)
        return flowPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), rendererPosition = rendererPointToPoint(flowPosition, transform2);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    }
  }), []);
};
function applyChanges(changes, elements) {
  const updatedElements = [], changesMap = /* @__PURE__ */ new Map(), addItemChanges = [];
  for (const change2 of changes)
    if (change2.type === "add") {
      addItemChanges.push(change2);
      continue;
    } else if (change2.type === "remove" || change2.type === "replace")
      changesMap.set(change2.id, [change2]);
    else {
      const elementChanges = changesMap.get(change2.id);
      elementChanges ? elementChanges.push(change2) : changesMap.set(change2.id, [change2]);
    }
  for (const element of elements) {
    const changes2 = changesMap.get(element.id);
    if (!changes2) {
      updatedElements.push(element);
      continue;
    }
    if (changes2[0].type === "remove")
      continue;
    if (changes2[0].type === "replace") {
      updatedElements.push({ ...changes2[0].item });
      continue;
    }
    const updatedElement = { ...element };
    for (const change2 of changes2)
      applyChange(change2, updatedElement);
    updatedElements.push(updatedElement);
  }
  return addItemChanges.length && addItemChanges.forEach((change2) => {
    change2.index !== void 0 ? updatedElements.splice(change2.index, 0, { ...change2.item }) : updatedElements.push({ ...change2.item });
  }), updatedElements;
}
function applyChange(change2, element) {
  switch (change2.type) {
    case "select": {
      element.selected = change2.selected;
      break;
    }
    case "position": {
      typeof change2.position < "u" && (element.position = change2.position), typeof change2.dragging < "u" && (element.dragging = change2.dragging);
      break;
    }
    case "dimensions": {
      typeof change2.dimensions < "u" && (element.measured = {
        ...change2.dimensions
      }, change2.setAttributes && ((change2.setAttributes === !0 || change2.setAttributes === "width") && (element.width = change2.dimensions.width), (change2.setAttributes === !0 || change2.setAttributes === "height") && (element.height = change2.dimensions.height))), typeof change2.resizing == "boolean" && (element.resizing = change2.resizing);
      break;
    }
  }
}
function applyNodeChanges(changes, nodes) {
  return applyChanges(changes, nodes);
}
function applyEdgeChanges(changes, edges) {
  return applyChanges(changes, edges);
}
function createSelectionChange(id2, selected2) {
  return {
    id: id2,
    type: "select",
    selected: selected2
  };
}
function getSelectionChanges(items, selectedIds = /* @__PURE__ */ new Set(), mutateItem = !1) {
  const changes = [];
  for (const [id2, item] of items) {
    const willBeSelected = selectedIds.has(id2);
    !(item.selected === void 0 && !willBeSelected) && item.selected !== willBeSelected && (mutateItem && (item.selected = willBeSelected), changes.push(createSelectionChange(item.id, willBeSelected)));
  }
  return changes;
}
function getElementsDiffChanges({ items = [], lookup }) {
  const changes = [], itemsLookup = new Map(items.map((item) => [item.id, item]));
  for (const [index2, item] of items.entries()) {
    const lookupItem = lookup.get(item.id), storeItem = lookupItem?.internals?.userNode ?? lookupItem;
    storeItem !== void 0 && storeItem !== item && changes.push({ id: item.id, item, type: "replace" }), storeItem === void 0 && changes.push({ item, type: "add", index: index2 });
  }
  for (const [id2] of lookup)
    itemsLookup.get(id2) === void 0 && changes.push({ id: id2, type: "remove" });
  return changes;
}
function elementToRemoveChange(item) {
  return {
    id: item.id,
    type: "remove"
  };
}
const isNode$1 = (element) => isNodeBase(element), isEdge = (element) => isEdgeBase(element);
function fixedForwardRef(render) {
  return forwardRef(render);
}
const useIsomorphicLayoutEffect$2 = typeof window < "u" ? useLayoutEffect : useEffect;
function useQueue(runQueue) {
  const [serial, setSerial] = useState(BigInt(0)), [queue] = useState(() => createQueue(() => setSerial((n2) => n2 + BigInt(1))));
  return useIsomorphicLayoutEffect$2(() => {
    const queueItems = queue.get();
    queueItems.length && (runQueue(queueItems), queue.reset());
  }, [serial]), queue;
}
function createQueue(cb) {
  let queue = [];
  return {
    get: () => queue,
    reset: () => {
      queue = [];
    },
    push: (item) => {
      queue.push(item), cb();
    }
  };
}
const BatchContext = createContext(null);
function BatchProvider({ children: children2 }) {
  const store = useStoreApi(), nodeQueueHandler = useCallback((queueItems) => {
    const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued, onNodesChangeMiddlewareMap } = store.getState();
    let next = nodes;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    let changes = getElementsDiffChanges({
      items: next,
      lookup: nodeLookup
    });
    for (const middleware of onNodesChangeMiddlewareMap.values())
      changes = middleware(changes);
    hasDefaultNodes && setNodes(next), changes.length > 0 ? onNodesChange?.(changes) : fitViewQueued && window.requestAnimationFrame(() => {
      const { fitViewQueued: fitViewQueued2, nodes: nodes2, setNodes: setNodes2 } = store.getState();
      fitViewQueued2 && setNodes2(nodes2);
    });
  }, []), nodeQueue = useQueue(nodeQueueHandler), edgeQueueHandler = useCallback((queueItems) => {
    const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();
    let next = edges;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    hasDefaultEdges ? setEdges(next) : onEdgesChange && onEdgesChange(getElementsDiffChanges({
      items: next,
      lookup: edgeLookup
    }));
  }, []), edgeQueue = useQueue(edgeQueueHandler), value = useMemo(() => ({ nodeQueue, edgeQueue }), []);
  return jsx(BatchContext.Provider, { value, children: children2 });
}
function useBatchContext() {
  const batchContext = useContext(BatchContext);
  if (!batchContext)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return batchContext;
}
const selector$k = (s2) => !!s2.panZoom;
function useReactFlow() {
  const viewportHelper = useViewportHelper(), store = useStoreApi(), batchContext = useBatchContext(), viewportInitialized = useStore(selector$k), generalHelper = useMemo(() => {
    const getInternalNode = (id2) => store.getState().nodeLookup.get(id2), setNodes = (payload) => {
      batchContext.nodeQueue.push(payload);
    }, setEdges = (payload) => {
      batchContext.edgeQueue.push(payload);
    }, getNodeRect = (node2) => {
      const { nodeLookup, nodeOrigin } = store.getState(), nodeToUse = isNode$1(node2) ? node2 : nodeLookup.get(node2.id), position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position, nodeWithPosition = {
        ...nodeToUse,
        position,
        width: nodeToUse.measured?.width ?? nodeToUse.width,
        height: nodeToUse.measured?.height ?? nodeToUse.height
      };
      return nodeToRect$1(nodeWithPosition);
    }, updateNode = (id2, nodeUpdate, options = { replace: !1 }) => {
      setNodes((prevNodes) => prevNodes.map((node2) => {
        if (node2.id === id2) {
          const nextNode = typeof nodeUpdate == "function" ? nodeUpdate(node2) : nodeUpdate;
          return options.replace && isNode$1(nextNode) ? nextNode : { ...node2, ...nextNode };
        }
        return node2;
      }));
    }, updateEdge = (id2, edgeUpdate, options = { replace: !1 }) => {
      setEdges((prevEdges) => prevEdges.map((edge) => {
        if (edge.id === id2) {
          const nextEdge = typeof edgeUpdate == "function" ? edgeUpdate(edge) : edgeUpdate;
          return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
        }
        return edge;
      }));
    };
    return {
      getNodes: () => store.getState().nodes.map((n2) => ({ ...n2 })),
      getNode: (id2) => getInternalNode(id2)?.internals.userNode,
      getInternalNode,
      getEdges: () => {
        const { edges = [] } = store.getState();
        return edges.map((e2) => ({ ...e2 }));
      },
      getEdge: (id2) => store.getState().edgeLookup.get(id2),
      setNodes,
      setEdges,
      addNodes: (payload) => {
        const newNodes = Array.isArray(payload) ? payload : [payload];
        batchContext.nodeQueue.push((nodes) => [...nodes, ...newNodes]);
      },
      addEdges: (payload) => {
        const newEdges = Array.isArray(payload) ? payload : [payload];
        batchContext.edgeQueue.push((edges) => [...edges, ...newEdges]);
      },
      toObject: () => {
        const { nodes = [], edges = [], transform: transform2 } = store.getState(), [x2, y2, zoom2] = transform2;
        return {
          nodes: nodes.map((n2) => ({ ...n2 })),
          edges: edges.map((e2) => ({ ...e2 })),
          viewport: {
            x: x2,
            y: y2,
            zoom: zoom2
          }
        };
      },
      deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState(), { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
          nodesToRemove,
          edgesToRemove,
          nodes,
          edges,
          onBeforeDelete
        }), hasMatchingEdges = matchingEdges.length > 0, hasMatchingNodes = matchingNodes.length > 0;
        if (hasMatchingEdges) {
          const edgeChanges = matchingEdges.map(elementToRemoveChange);
          onEdgesDelete?.(matchingEdges), triggerEdgeChanges(edgeChanges);
        }
        if (hasMatchingNodes) {
          const nodeChanges = matchingNodes.map(elementToRemoveChange);
          onNodesDelete?.(matchingNodes), triggerNodeChanges(nodeChanges);
        }
        return (hasMatchingNodes || hasMatchingEdges) && onDelete?.({ nodes: matchingNodes, edges: matchingEdges }), { deletedNodes: matchingNodes, deletedEdges: matchingEdges };
      },
      /**
       * Partial is defined as "the 2 nodes/areas are intersecting partially".
       * If a is contained in b or b is contained in a, they are both
       * considered fully intersecting.
       */
      getIntersectingNodes: (nodeOrRect, partially = !0, nodes) => {
        const isRect = isRectObject(nodeOrRect), nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect), hasNodesOption = nodes !== void 0;
        return nodeRect ? (nodes || store.getState().nodes).filter((n2) => {
          const internalNode = store.getState().nodeLookup.get(n2.id);
          if (internalNode && !isRect && (n2.id === nodeOrRect.id || !internalNode.internals.positionAbsolute))
            return !1;
          const currNodeRect = nodeToRect$1(hasNodesOption ? n2 : internalNode), overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
          return partially && overlappingArea > 0 || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;
        }) : [];
      },
      isNodeIntersecting: (nodeOrRect, area, partially = !0) => {
        const nodeRect = isRectObject(nodeOrRect) ? nodeOrRect : getNodeRect(nodeOrRect);
        if (!nodeRect)
          return !1;
        const overlappingArea = getOverlappingArea(nodeRect, area);
        return partially && overlappingArea > 0 || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;
      },
      updateNode,
      updateNodeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateNode(id2, (node2) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(node2) : dataUpdate;
          return options.replace ? { ...node2, data: nextData } : { ...node2, data: { ...node2.data, ...nextData } };
        }, options);
      },
      updateEdge,
      updateEdgeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateEdge(id2, (edge) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(edge) : dataUpdate;
          return options.replace ? { ...edge, data: nextData } : { ...edge, data: { ...edge.data, ...nextData } };
        }, options);
      },
      getNodesBounds: (nodes) => {
        const { nodeLookup, nodeOrigin } = store.getState();
        return getNodesBounds(nodes, { nodeLookup, nodeOrigin });
      },
      getHandleConnections: ({ type, id: id2, nodeId }) => Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id2 ? `-${id2}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type, handleId, nodeId }) => Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ""}`)?.values() ?? []),
      fitView: async (options) => {
        const fitViewResolver = store.getState().fitViewResolver ?? withResolvers();
        return store.setState({ fitViewQueued: !0, fitViewOptions: options, fitViewResolver }), batchContext.nodeQueue.push((nodes) => [...nodes]), fitViewResolver.promise;
      }
    };
  }, []);
  return useMemo(() => ({
    ...generalHelper,
    ...viewportHelper,
    viewportInitialized
  }), [viewportInitialized]);
}
const selected = (item) => item.selected, win$1 = typeof window < "u" ? window : void 0;
function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {
  const store = useStoreApi(), { deleteElements } = useReactFlow(), deleteKeyPressed = useKeyPress(deleteKeyCode, { actInsideInputWithModifier: !1 }), multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, { target: win$1 });
  useEffect(() => {
    if (deleteKeyPressed) {
      const { edges, nodes } = store.getState();
      deleteElements({ nodes: nodes.filter(selected), edges: edges.filter(selected) }), store.setState({ nodesSelectionActive: !1 });
    }
  }, [deleteKeyPressed]), useEffect(() => {
    store.setState({ multiSelectionActive: multiSelectionKeyPressed });
  }, [multiSelectionKeyPressed]);
}
function useResizeHandler(domNode) {
  const store = useStoreApi();
  useEffect(() => {
    const updateDimensions = () => {
      if (!domNode.current || !(domNode.current.checkVisibility?.() ?? !0))
        return !1;
      const size2 = getDimensions$1(domNode.current);
      (size2.height === 0 || size2.width === 0) && store.getState().onError?.("004", errorMessages.error004()), store.setState({ width: size2.width || 500, height: size2.height || 500 });
    };
    if (domNode.current) {
      updateDimensions(), window.addEventListener("resize", updateDimensions);
      const resizeObserver = new ResizeObserver(() => updateDimensions());
      return resizeObserver.observe(domNode.current), () => {
        window.removeEventListener("resize", updateDimensions), resizeObserver && domNode.current && resizeObserver.unobserve(domNode.current);
      };
    }
  }, []);
}
const containerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, selector$j = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  lib: s2.lib,
  connectionInProgress: s2.connection.inProgress
});
function ZoomPane({ onPaneContextMenu, zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = !0, children: children2, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, selectionOnDrag }) {
  const store = useStoreApi(), zoomPane = useRef(null), { userSelectionActive, lib: lib2, connectionInProgress } = useStore(selector$j, shallow$1), zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode), panZoom = useRef();
  useResizeHandler(zoomPane);
  const onTransformChange = useCallback((transform2) => {
    onViewportChange?.({ x: transform2[0], y: transform2[1], zoom: transform2[2] }), isControlledViewport || store.setState({ transform: transform2 });
  }, [onViewportChange, isControlledViewport]);
  return useEffect(() => {
    if (zoomPane.current) {
      panZoom.current = XYPanZoom({
        domNode: zoomPane.current,
        minZoom,
        maxZoom,
        translateExtent,
        viewport: defaultViewport2,
        onDraggingChange: (paneDragging) => store.setState({ paneDragging }),
        onPanZoomStart: (event, vp) => {
          const { onViewportChangeStart, onMoveStart } = store.getState();
          onMoveStart?.(event, vp), onViewportChangeStart?.(vp);
        },
        onPanZoom: (event, vp) => {
          const { onViewportChange: onViewportChange2, onMove } = store.getState();
          onMove?.(event, vp), onViewportChange2?.(vp);
        },
        onPanZoomEnd: (event, vp) => {
          const { onViewportChangeEnd, onMoveEnd } = store.getState();
          onMoveEnd?.(event, vp), onViewportChangeEnd?.(vp);
        }
      });
      const { x: x2, y: y2, zoom: zoom2 } = panZoom.current.getViewport();
      return store.setState({
        panZoom: panZoom.current,
        transform: [x2, y2, zoom2],
        domNode: zoomPane.current.closest(".react-flow")
      }), () => {
        panZoom.current?.destroy();
      };
    }
  }, []), useEffect(() => {
    panZoom.current?.update({
      onPaneContextMenu,
      zoomOnScroll,
      zoomOnPinch,
      panOnScroll,
      panOnScrollSpeed,
      panOnScrollMode,
      zoomOnDoubleClick,
      panOnDrag,
      zoomActivationKeyPressed,
      preventScrolling,
      noPanClassName,
      userSelectionActive,
      noWheelClassName,
      lib: lib2,
      onTransformChange,
      connectionInProgress,
      selectionOnDrag,
      paneClickDistance
    });
  }, [
    onPaneContextMenu,
    zoomOnScroll,
    zoomOnPinch,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    zoomOnDoubleClick,
    panOnDrag,
    zoomActivationKeyPressed,
    preventScrolling,
    noPanClassName,
    userSelectionActive,
    noWheelClassName,
    lib2,
    onTransformChange,
    connectionInProgress,
    selectionOnDrag,
    paneClickDistance
  ]), jsx("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle, children: children2 });
}
const selector$i = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  userSelectionRect: s2.userSelectionRect
});
function UserSelection() {
  const { userSelectionActive, userSelectionRect } = useStore(selector$i, shallow$1);
  return userSelectionActive && userSelectionRect ? jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: userSelectionRect.width,
    height: userSelectionRect.height,
    transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`
  } }) : null;
}
const wrapHandler = (handler, containerRef) => (event) => {
  event.target === containerRef.current && handler?.(event);
}, selector$h = (s2) => ({
  userSelectionActive: s2.userSelectionActive,
  elementsSelectable: s2.elementsSelectable,
  connectionInProgress: s2.connection.inProgress,
  dragging: s2.paneDragging
});
function Pane({ isSelecting, selectionKeyPressed, selectionMode = SelectionMode.Full, panOnDrag, paneClickDistance, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children: children2 }) {
  const store = useStoreApi(), { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, shallow$1), isSelectionEnabled = elementsSelectable && (isSelecting || userSelectionActive), container2 = useRef(null), containerBounds = useRef(), selectedNodeIds = useRef(/* @__PURE__ */ new Set()), selectedEdgeIds = useRef(/* @__PURE__ */ new Set()), selectionInProgress = useRef(!1), onClick = (event) => {
    if (selectionInProgress.current || connectionInProgress) {
      selectionInProgress.current = !1;
      return;
    }
    onPaneClick?.(event), store.getState().resetSelectedElements(), store.setState({ nodesSelectionActive: !1 });
  }, onContextMenu = (event) => {
    if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {
      event.preventDefault();
      return;
    }
    onPaneContextMenu?.(event);
  }, onWheel = onPaneScroll ? (event) => onPaneScroll(event) : void 0, onClickCapture = (event) => {
    selectionInProgress.current && (event.stopPropagation(), selectionInProgress.current = !1);
  }, onPointerDownCapture = (event) => {
    const { domNode } = store.getState();
    if (containerBounds.current = domNode?.getBoundingClientRect(), !containerBounds.current)
      return;
    const eventTargetIsContainer = event.target === container2.current;
    if (!eventTargetIsContainer && !!event.target.closest(".nokey") || !isSelecting || !(selectionOnDrag && eventTargetIsContainer || selectionKeyPressed) || event.button !== 0 || !event.isPrimary)
      return;
    event.target?.setPointerCapture?.(event.pointerId), selectionInProgress.current = !1;
    const { x: x2, y: y2 } = getEventPosition(event.nativeEvent, containerBounds.current);
    store.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: x2,
        startY: y2,
        x: x2,
        y: y2
      }
    }), eventTargetIsContainer || (event.stopPropagation(), event.preventDefault());
  }, onPointerMove = (event) => {
    const { userSelectionRect, transform: transform2, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions, resetSelectedElements } = store.getState();
    if (!containerBounds.current || !userSelectionRect)
      return;
    const { x: mouseX, y: mouseY } = getEventPosition(event.nativeEvent, containerBounds.current), { startX, startY } = userSelectionRect;
    if (!selectionInProgress.current) {
      const requiredDistance = selectionKeyPressed ? 0 : paneClickDistance;
      if (Math.hypot(mouseX - startX, mouseY - startY) <= requiredDistance)
        return;
      resetSelectedElements(), onSelectionStart?.(event);
    }
    selectionInProgress.current = !0;
    const nextUserSelectRect = {
      startX,
      startY,
      x: mouseX < startX ? mouseX : startX,
      y: mouseY < startY ? mouseY : startY,
      width: Math.abs(mouseX - startX),
      height: Math.abs(mouseY - startY)
    }, prevSelectedNodeIds = selectedNodeIds.current, prevSelectedEdgeIds = selectedEdgeIds.current;
    selectedNodeIds.current = new Set(getNodesInside(nodeLookup, nextUserSelectRect, transform2, selectionMode === SelectionMode.Partial, !0).map((node2) => node2.id)), selectedEdgeIds.current = /* @__PURE__ */ new Set();
    const edgesSelectable = defaultEdgeOptions?.selectable ?? !0;
    for (const nodeId of selectedNodeIds.current) {
      const connections = connectionLookup.get(nodeId);
      if (connections)
        for (const { edgeId } of connections.values()) {
          const edge = edgeLookup.get(edgeId);
          edge && (edge.selectable ?? edgesSelectable) && selectedEdgeIds.current.add(edgeId);
        }
    }
    if (!areSetsEqual$1(prevSelectedNodeIds, selectedNodeIds.current)) {
      const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, !0);
      triggerNodeChanges(changes);
    }
    if (!areSetsEqual$1(prevSelectedEdgeIds, selectedEdgeIds.current)) {
      const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);
      triggerEdgeChanges(changes);
    }
    store.setState({
      userSelectionRect: nextUserSelectRect,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, onPointerUp = (event) => {
    event.button === 0 && (event.target?.releasePointerCapture?.(event.pointerId), !userSelectionActive && event.target === container2.current && store.getState().userSelectionRect && onClick?.(event), store.setState({
      userSelectionActive: !1,
      userSelectionRect: null
    }), selectionInProgress.current && (onSelectionEnd?.(event), store.setState({
      nodesSelectionActive: selectedNodeIds.current.size > 0
    })));
  }, draggable = panOnDrag === !0 || Array.isArray(panOnDrag) && panOnDrag.includes(0);
  return jsxs("div", { className: cc(["react-flow__pane", { draggable, dragging, selection: isSelecting }]), onClick: isSelectionEnabled ? void 0 : wrapHandler(onClick, container2), onContextMenu: wrapHandler(onContextMenu, container2), onWheel: wrapHandler(onWheel, container2), onPointerEnter: isSelectionEnabled ? void 0 : onPaneMouseEnter, onPointerMove: isSelectionEnabled ? onPointerMove : onPaneMouseMove, onPointerUp: isSelectionEnabled ? onPointerUp : void 0, onPointerDownCapture: isSelectionEnabled ? onPointerDownCapture : void 0, onClickCapture: isSelectionEnabled ? onClickCapture : void 0, onPointerLeave: onPaneMouseLeave, ref: container2, style: containerStyle, children: [children2, jsx(UserSelection, {})] });
}
function handleNodeClick({ id: id2, store, unselect = !1, nodeRef: nodeRef2 }) {
  const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState(), node2 = nodeLookup.get(id2);
  if (!node2) {
    onError?.("012", errorMessages.error012(id2));
    return;
  }
  store.setState({ nodesSelectionActive: !1 }), node2.selected ? (unselect || node2.selected && multiSelectionActive) && (unselectNodesAndEdges({ nodes: [node2], edges: [] }), requestAnimationFrame(() => nodeRef2?.current?.blur())) : addSelectedNodes([id2]);
}
function useDrag({ nodeRef: nodeRef2, disabled = !1, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {
  const store = useStoreApi(), [dragging, setDragging] = useState(!1), xyDrag = useRef();
  return useEffect(() => {
    xyDrag.current = XYDrag({
      getStoreItems: () => store.getState(),
      onNodeMouseDown: (id2) => {
        handleNodeClick({
          id: id2,
          store,
          nodeRef: nodeRef2
        });
      },
      onDragStart: () => {
        setDragging(!0);
      },
      onDragStop: () => {
        setDragging(!1);
      }
    });
  }, []), useEffect(() => {
    if (disabled)
      xyDrag.current?.destroy();
    else if (nodeRef2.current)
      return xyDrag.current?.update({
        noDragClassName,
        handleSelector,
        domNode: nodeRef2.current,
        isSelectable,
        nodeId,
        nodeClickDistance
      }), () => {
        xyDrag.current?.destroy();
      };
  }, [noDragClassName, handleSelector, disabled, isSelectable, nodeRef2, nodeId]), dragging;
}
const selectedAndDraggable = (nodesDraggable) => (n2) => n2.selected && (n2.draggable || nodesDraggable && typeof n2.draggable > "u");
function useMoveSelectedNodes() {
  const store = useStoreApi();
  return useCallback((params) => {
    const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState(), nodeUpdates = /* @__PURE__ */ new Map(), isSelected = selectedAndDraggable(nodesDraggable), xVelo = snapToGrid ? snapGrid[0] : 5, yVelo = snapToGrid ? snapGrid[1] : 5, xDiff = params.direction.x * xVelo * params.factor, yDiff = params.direction.y * yVelo * params.factor;
    for (const [, node2] of nodeLookup) {
      if (!isSelected(node2))
        continue;
      let nextPosition = {
        x: node2.internals.positionAbsolute.x + xDiff,
        y: node2.internals.positionAbsolute.y + yDiff
      };
      snapToGrid && (nextPosition = snapPosition(nextPosition, snapGrid));
      const { position, positionAbsolute } = calculateNodePosition({
        nodeId: node2.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError
      });
      node2.position = position, node2.internals.positionAbsolute = positionAbsolute, nodeUpdates.set(node2.id, node2);
    }
    updateNodePositions(nodeUpdates);
  }, []);
}
const NodeIdContext = createContext(null), Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => useContext(NodeIdContext), selector$g = (s2) => ({
  connectOnClick: s2.connectOnClick,
  noPanClassName: s2.noPanClassName,
  rfId: s2.rfId
}), connectingSelector = (nodeId, handleId, type) => (state) => {
  const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state, { fromHandle, toHandle, isValid } = connection, connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;
  return {
    connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,
    connectingTo,
    clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,
    isPossibleEndHandle: connectionMode === ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,
    connectionInProcess: !!fromHandle,
    clickConnectionInProcess: !!clickHandle,
    valid: connectingTo && isValid
  };
};
function HandleComponent({ type = "source", position = Position.Top, isValidConnection, isConnectable = !0, isConnectableStart = !0, isConnectableEnd = !0, id: id2, onConnect, children: children2, className, onMouseDown, onTouchStart, ...rest }, ref) {
  const handleId = id2 || null, isTarget = type === "target", store = useStoreApi(), nodeId = useNodeId(), { connectOnClick, noPanClassName, rfId } = useStore(selector$g, shallow$1), { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), shallow$1);
  nodeId || store.getState().onError?.("010", errorMessages.error010());
  const onConnectExtended = (params) => {
    const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState(), edgeParams = {
      ...defaultEdgeOptions,
      ...params
    };
    if (hasDefaultEdges) {
      const { edges, setEdges } = store.getState();
      setEdges(addEdge(edgeParams, edges));
    }
    onConnectAction?.(edgeParams), onConnect?.(edgeParams);
  }, onPointerDown2 = (event) => {
    if (!nodeId)
      return;
    const isMouseTriggered = isMouseEvent(event.nativeEvent);
    if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
      const currentStore = store.getState();
      XYHandle.onPointerDown(event.nativeEvent, {
        handleDomNode: event.currentTarget,
        autoPanOnConnect: currentStore.autoPanOnConnect,
        connectionMode: currentStore.connectionMode,
        connectionRadius: currentStore.connectionRadius,
        domNode: currentStore.domNode,
        nodeLookup: currentStore.nodeLookup,
        lib: currentStore.lib,
        isTarget,
        handleId,
        nodeId,
        flowId: currentStore.rfId,
        panBy: currentStore.panBy,
        cancelConnection: currentStore.cancelConnection,
        onConnectStart: currentStore.onConnectStart,
        onConnectEnd: currentStore.onConnectEnd,
        updateConnection: currentStore.updateConnection,
        onConnect: onConnectExtended,
        isValidConnection: isValidConnection || currentStore.isValidConnection,
        getTransform: () => store.getState().transform,
        getFromHandle: () => store.getState().connection.fromHandle,
        autoPanSpeed: currentStore.autoPanSpeed,
        dragThreshold: currentStore.connectionDragThreshold
      });
    }
    isMouseTriggered ? onMouseDown?.(event) : onTouchStart?.(event);
  }, onClick = (event) => {
    const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib: lib2, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();
    if (!nodeId || !connectionClickStartHandle && !isConnectableStart)
      return;
    if (!connectionClickStartHandle) {
      onClickConnectStart?.(event.nativeEvent, { nodeId, handleId, handleType: type }), store.setState({ connectionClickStartHandle: { nodeId, type, id: handleId } });
      return;
    }
    const doc = getHostForElement(event.target), isValidConnectionHandler = isValidConnection || isValidConnectionStore, { connection, isValid } = XYHandle.isValid(event.nativeEvent, {
      handle: {
        nodeId,
        id: handleId,
        type
      },
      connectionMode,
      fromNodeId: connectionClickStartHandle.nodeId,
      fromHandleId: connectionClickStartHandle.id || null,
      fromType: connectionClickStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: lib2,
      nodeLookup
    });
    isValid && connection && onConnectExtended(connection);
    const connectionClone = structuredClone(connectionState);
    delete connectionClone.inProgress, connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null, onClickConnectEnd?.(event, connectionClone), store.setState({ connectionClickStartHandle: null });
  };
  return jsx("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position, "data-id": `${rfId}-${nodeId}-${handleId}-${type}`, className: cc([
    "react-flow__handle",
    `react-flow__handle-${position}`,
    "nodrag",
    noPanClassName,
    className,
    {
      source: !isTarget,
      target: isTarget,
      connectable: isConnectable,
      connectablestart: isConnectableStart,
      connectableend: isConnectableEnd,
      clickconnecting: clickConnecting,
      connectingfrom: connectingFrom,
      connectingto: connectingTo,
      valid,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)
    }
  ]), onMouseDown: onPointerDown2, onTouchStart: onPointerDown2, onClick: connectOnClick ? onClick : void 0, ref, ...rest, children: children2 });
}
const Handle = memo$3(fixedForwardRef(HandleComponent));
function InputNode({ data, isConnectable, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment, { children: [data?.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function DefaultNode({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data?.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function GroupNode() {
  return null;
}
function OutputNode({ data, isConnectable, targetPosition = Position.Top }) {
  return jsxs(Fragment, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data?.label] });
}
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, builtinNodeTypes = {
  input: InputNode,
  default: DefaultNode,
  output: OutputNode,
  group: GroupNode
};
function getNodeInlineStyleDimensions(node2) {
  return node2.internals.handleBounds === void 0 ? {
    width: node2.width ?? node2.initialWidth ?? node2.style?.width,
    height: node2.height ?? node2.initialHeight ?? node2.style?.height
  } : {
    width: node2.width ?? node2.style?.width,
    height: node2.height ?? node2.style?.height
  };
}
const selector$f = (s2) => {
  const { width, height, x: x2, y: y2 } = getInternalNodesBounds(s2.nodeLookup, {
    filter: (node2) => !!node2.selected
  });
  return {
    width: isNumeric(width) ? width : null,
    height: isNumeric(height) ? height : null,
    userSelectionActive: s2.userSelectionActive,
    transformString: `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]}) translate(${x2}px,${y2}px)`
  };
};
function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
  const store = useStoreApi(), { width, height, transformString, userSelectionActive } = useStore(selector$f, shallow$1), moveSelectedNodes = useMoveSelectedNodes(), nodeRef2 = useRef(null);
  if (useEffect(() => {
    disableKeyboardA11y || nodeRef2.current?.focus({
      preventScroll: !0
    });
  }, [disableKeyboardA11y]), useDrag({
    nodeRef: nodeRef2
  }), userSelectionActive || !width || !height)
    return null;
  const onContextMenu = onSelectionContextMenu ? (event) => {
    const selectedNodes = store.getState().nodes.filter((n2) => n2.selected);
    onSelectionContextMenu(event, selectedNodes);
  } : void 0, onKeyDown = (event) => {
    Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key) && (event.preventDefault(), moveSelectedNodes({
      direction: arrowKeyDiffs[event.key],
      factor: event.shiftKey ? 4 : 1
    }));
  };
  return jsx("div", { className: cc(["react-flow__nodesselection", "react-flow__container", noPanClassName]), style: {
    transform: transformString
  }, children: jsx("div", { ref: nodeRef2, className: "react-flow__nodesselection-rect", onContextMenu, tabIndex: disableKeyboardA11y ? void 0 : -1, onKeyDown: disableKeyboardA11y ? void 0 : onKeyDown, style: {
    width,
    height
  } }) });
}
const win = typeof window < "u" ? window : void 0, selector$e = (s2) => ({ nodesSelectionActive: s2.nodesSelectionActive, userSelectionActive: s2.userSelectionActive });
function FlowRendererComponent({ children: children2, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {
  const { nodesSelectionActive, userSelectionActive } = useStore(selector$e, shallow$1), selectionKeyPressed = useKeyPress(selectionKeyCode, { target: win }), panActivationKeyPressed = useKeyPress(panActivationKeyCode, { target: win }), panOnDrag = panActivationKeyPressed || _panOnDrag, panOnScroll = panActivationKeyPressed || _panOnScroll, _selectionOnDrag = selectionOnDrag && panOnDrag !== !0, isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;
  return useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }), jsx(ZoomPane, { onPaneContextMenu, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, selectionOnDrag: _selectionOnDrag, children: jsxs(Pane, { onSelectionStart, onSelectionEnd, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, panOnDrag, isSelecting: !!isSelecting, selectionMode, selectionKeyPressed, paneClickDistance, selectionOnDrag: _selectionOnDrag, children: [children2, nodesSelectionActive && jsx(NodesSelection, { onSelectionContextMenu, noPanClassName, disableKeyboardA11y })] }) });
}
FlowRendererComponent.displayName = "FlowRenderer";
const FlowRenderer = memo$3(FlowRendererComponent), selector$d = (onlyRenderVisible) => (s2) => onlyRenderVisible ? getNodesInside(s2.nodeLookup, { x: 0, y: 0, width: s2.width, height: s2.height }, s2.transform, !0).map((node2) => node2.id) : Array.from(s2.nodeLookup.keys());
function useVisibleNodeIds(onlyRenderVisible) {
  return useStore(useCallback(selector$d(onlyRenderVisible), [onlyRenderVisible]), shallow$1);
}
const selector$c = (s2) => s2.updateNodeInternals;
function useResizeObserver$1() {
  const updateNodeInternals2 = useStore(selector$c), [resizeObserver] = useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, {
        id: id2,
        nodeElement: entry.target,
        force: !0
      });
    }), updateNodeInternals2(updates);
  }));
  return useEffect(() => () => {
    resizeObserver?.disconnect();
  }, [resizeObserver]), resizeObserver;
}
function useNodeObserver({ node: node2, nodeType, hasDimensions, resizeObserver }) {
  const store = useStoreApi(), nodeRef2 = useRef(null), observedNode = useRef(null), prevSourcePosition = useRef(node2.sourcePosition), prevTargetPosition = useRef(node2.targetPosition), prevType = useRef(nodeType), isInitialized = hasDimensions && !!node2.internals.handleBounds;
  return useEffect(() => {
    nodeRef2.current && !node2.hidden && (!isInitialized || observedNode.current !== nodeRef2.current) && (observedNode.current && resizeObserver?.unobserve(observedNode.current), resizeObserver?.observe(nodeRef2.current), observedNode.current = nodeRef2.current);
  }, [isInitialized, node2.hidden]), useEffect(() => () => {
    observedNode.current && (resizeObserver?.unobserve(observedNode.current), observedNode.current = null);
  }, []), useEffect(() => {
    if (nodeRef2.current) {
      const typeChanged = prevType.current !== nodeType, sourcePosChanged = prevSourcePosition.current !== node2.sourcePosition, targetPosChanged = prevTargetPosition.current !== node2.targetPosition;
      (typeChanged || sourcePosChanged || targetPosChanged) && (prevType.current = nodeType, prevSourcePosition.current = node2.sourcePosition, prevTargetPosition.current = node2.targetPosition, store.getState().updateNodeInternals(/* @__PURE__ */ new Map([[node2.id, { id: node2.id, nodeElement: nodeRef2.current, force: !0 }]])));
    }
  }, [node2.id, nodeType, node2.sourcePosition, node2.targetPosition]), nodeRef2;
}
function NodeWrapper({ id: id2, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes: nodeTypes2, nodeClickDistance, onError }) {
  const { node: node2, internals, isParent: isParent2 } = useStore((s2) => {
    const node22 = s2.nodeLookup.get(id2), isParent22 = s2.parentLookup.has(id2);
    return {
      node: node22,
      internals: node22.internals,
      isParent: isParent22
    };
  }, shallow$1);
  let nodeType = node2.type || "default", NodeComponent = nodeTypes2?.[nodeType] || builtinNodeTypes[nodeType];
  NodeComponent === void 0 && (onError?.("003", errorMessages.error003(nodeType)), nodeType = "default", NodeComponent = nodeTypes2?.default || builtinNodeTypes.default);
  const isDraggable = !!(node2.draggable || nodesDraggable && typeof node2.draggable > "u"), isSelectable = !!(node2.selectable || elementsSelectable && typeof node2.selectable > "u"), isConnectable = !!(node2.connectable || nodesConnectable && typeof node2.connectable > "u"), isFocusable = !!(node2.focusable || nodesFocusable && typeof node2.focusable > "u"), store = useStoreApi(), hasDimensions = nodeHasDimensions(node2), nodeRef2 = useNodeObserver({ node: node2, nodeType, hasDimensions, resizeObserver }), dragging = useDrag({
    nodeRef: nodeRef2,
    disabled: node2.hidden || !isDraggable,
    noDragClassName,
    handleSelector: node2.dragHandle,
    nodeId: id2,
    isSelectable,
    nodeClickDistance
  }), moveSelectedNodes = useMoveSelectedNodes();
  if (node2.hidden)
    return null;
  const nodeDimensions = getNodeDimensions(node2), inlineDimensions = getNodeInlineStyleDimensions(node2), hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave, onMouseEnterHandler = onMouseEnter ? (event) => onMouseEnter(event, { ...internals.userNode }) : void 0, onMouseMoveHandler = onMouseMove ? (event) => onMouseMove(event, { ...internals.userNode }) : void 0, onMouseLeaveHandler = onMouseLeave ? (event) => onMouseLeave(event, { ...internals.userNode }) : void 0, onContextMenuHandler = onContextMenu ? (event) => onContextMenu(event, { ...internals.userNode }) : void 0, onDoubleClickHandler = onDoubleClick ? (event) => onDoubleClick(event, { ...internals.userNode }) : void 0, onSelectNodeHandler = (event) => {
    const { selectNodesOnDrag, nodeDragThreshold } = store.getState();
    isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0) && handleNodeClick({
      id: id2,
      store,
      nodeRef: nodeRef2
    }), onClick && onClick(event, { ...internals.userNode });
  }, onKeyDown = (event) => {
    if (!(isInputDOMNode(event.nativeEvent) || disableKeyboardA11y)) {
      if (elementSelectionKeys.includes(event.key) && isSelectable) {
        const unselect = event.key === "Escape";
        handleNodeClick({
          id: id2,
          store,
          unselect,
          nodeRef: nodeRef2
        });
      } else if (isDraggable && node2.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
        event.preventDefault();
        const { ariaLabelConfig } = store.getState();
        store.setState({
          ariaLiveMessage: ariaLabelConfig["node.a11yDescription.ariaLiveMessage"]({
            direction: event.key.replace("Arrow", "").toLowerCase(),
            x: ~~internals.positionAbsolute.x,
            y: ~~internals.positionAbsolute.y
          })
        }), moveSelectedNodes({
          direction: arrowKeyDiffs[event.key],
          factor: event.shiftKey ? 4 : 1
        });
      }
    }
  }, onFocus = () => {
    if (disableKeyboardA11y || !nodeRef2.current?.matches(":focus-visible"))
      return;
    const { transform: transform2, width, height, autoPanOnNodeFocus, setCenter } = store.getState();
    if (!autoPanOnNodeFocus)
      return;
    getNodesInside(/* @__PURE__ */ new Map([[id2, node2]]), { x: 0, y: 0, width, height }, transform2, !0).length > 0 || setCenter(node2.position.x + nodeDimensions.width / 2, node2.position.y + nodeDimensions.height / 2, {
      zoom: transform2[2]
    });
  };
  return jsx("div", { className: cc([
    "react-flow__node",
    `react-flow__node-${nodeType}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [noPanClassName]: isDraggable
    },
    node2.className,
    {
      selected: node2.selected,
      selectable: isSelectable,
      parent: isParent2,
      draggable: isDraggable,
      dragging
    }
  ]), ref: nodeRef2, style: {
    zIndex: internals.z,
    transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,
    pointerEvents: hasPointerEvents ? "all" : "none",
    visibility: hasDimensions ? "visible" : "hidden",
    ...node2.style,
    ...inlineDimensions
  }, "data-id": id2, "data-testid": `rf__node-${id2}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, onFocus: isFocusable ? onFocus : void 0, role: node2.ariaRole ?? (isFocusable ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": node2.ariaLabel, ...node2.domAttributes, children: jsx(Provider, { value: id2, children: jsx(NodeComponent, { id: id2, data: node2.data, type: nodeType, positionAbsoluteX: internals.positionAbsolute.x, positionAbsoluteY: internals.positionAbsolute.y, selected: node2.selected ?? !1, selectable: isSelectable, draggable: isDraggable, deletable: node2.deletable ?? !0, isConnectable, sourcePosition: node2.sourcePosition, targetPosition: node2.targetPosition, dragging, dragHandle: node2.dragHandle, zIndex: internals.z, parentId: node2.parentId, ...nodeDimensions }) }) });
}
var NodeWrapper$1 = memo$3(NodeWrapper);
const selector$b = (s2) => ({
  nodesDraggable: s2.nodesDraggable,
  nodesConnectable: s2.nodesConnectable,
  nodesFocusable: s2.nodesFocusable,
  elementsSelectable: s2.elementsSelectable,
  onError: s2.onError
});
function NodeRendererComponent(props) {
  const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, shallow$1), nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements), resizeObserver = useResizeObserver$1();
  return jsx("div", { className: "react-flow__nodes", style: containerStyle, children: nodeIds.map((nodeId) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    jsx(NodeWrapper$1, { id: nodeId, nodeTypes: props.nodeTypes, nodeExtent: props.nodeExtent, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, resizeObserver, nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, nodeClickDistance: props.nodeClickDistance, onError }, nodeId)
  )) });
}
NodeRendererComponent.displayName = "NodeRenderer";
const NodeRenderer = memo$3(NodeRendererComponent);
function useVisibleEdgeIds(onlyRenderVisible) {
  return useStore(useCallback((s2) => {
    if (!onlyRenderVisible)
      return s2.edges.map((edge) => edge.id);
    const visibleEdgeIds = [];
    if (s2.width && s2.height)
      for (const edge of s2.edges) {
        const sourceNode = s2.nodeLookup.get(edge.source), targetNode = s2.nodeLookup.get(edge.target);
        sourceNode && targetNode && isEdgeVisible({
          sourceNode,
          targetNode,
          width: s2.width,
          height: s2.height,
          transform: s2.transform
        }) && visibleEdgeIds.push(edge.id);
      }
    return visibleEdgeIds;
  }, [onlyRenderVisible]), shallow$1);
}
const ArrowSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => {
  const style2 = {
    strokeWidth,
    ...color2 && { stroke: color2 }
  };
  return jsx("polyline", { className: "arrow", style: style2, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
}, ArrowClosedSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => {
  const style2 = {
    strokeWidth,
    ...color2 && { stroke: color2, fill: color2 }
  };
  return jsx("polyline", { className: "arrowclosed", style: style2, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
}, MarkerSymbols = {
  [MarkerType.Arrow]: ArrowSymbol,
  [MarkerType.ArrowClosed]: ArrowClosedSymbol
};
function useMarkerSymbol(type) {
  const store = useStoreApi();
  return useMemo(() => Object.prototype.hasOwnProperty.call(MarkerSymbols, type) ? MarkerSymbols[type] : (store.getState().onError?.("009", errorMessages.error009(type)), null), [type]);
}
const Marker = ({ id: id2, type, color: color2, width = 12.5, height = 12.5, markerUnits = "strokeWidth", strokeWidth, orient = "auto-start-reverse" }) => {
  const Symbol2 = useMarkerSymbol(type);
  return Symbol2 ? jsx("marker", { className: "react-flow__arrowhead", id: id2, markerWidth: `${width}`, markerHeight: `${height}`, viewBox: "-10 -10 20 20", markerUnits, orient, refX: "0", refY: "0", children: jsx(Symbol2, { color: color2, strokeWidth }) }) : null;
}, MarkerDefinitions = ({ defaultColor, rfId }) => {
  const edges = useStore((s2) => s2.edges), defaultEdgeOptions = useStore((s2) => s2.defaultEdgeOptions), markers = useMemo(() => createMarkerIds(edges, {
    id: rfId,
    defaultColor,
    defaultMarkerStart: defaultEdgeOptions?.markerStart,
    defaultMarkerEnd: defaultEdgeOptions?.markerEnd
  }), [edges, defaultEdgeOptions, rfId, defaultColor]);
  return markers.length ? jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: jsx("defs", { children: markers.map((marker) => jsx(Marker, { id: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient }, marker.id)) }) }) : null;
};
MarkerDefinitions.displayName = "MarkerDefinitions";
var MarkerDefinitions$1 = memo$3(MarkerDefinitions);
function EdgeTextComponent({ x: x2, y: y2, label: label2, labelStyle, labelShowBg = !0, labelBgStyle, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children: children2, className, ...rest }) {
  const [edgeTextBbox, setEdgeTextBbox] = useState({ x: 1, y: 0, width: 0, height: 0 }), edgeTextClasses = cc(["react-flow__edge-textwrapper", className]), edgeTextRef = useRef(null);
  return useEffect(() => {
    if (edgeTextRef.current) {
      const textBbox = edgeTextRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label2]), label2 ? jsxs("g", { transform: `translate(${x2 - edgeTextBbox.width / 2} ${y2 - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? "visible" : "hidden", ...rest, children: [labelShowBg && jsx("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius }), jsx("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeTextRef, style: labelStyle, children: label2 }), children2] }) : null;
}
EdgeTextComponent.displayName = "EdgeText";
const EdgeText = memo$3(EdgeTextComponent);
function BaseEdge({ path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {
  return jsxs(Fragment, { children: [jsx("path", { ...props, d: path, fill: "none", className: cc(["react-flow__edge-path", props.className]) }), interactionWidth ? jsx("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" }) : null, label2 && isNumeric(labelX) && isNumeric(labelY) ? jsx(EdgeText, { x: labelX, y: labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius }) : null] });
}
function getControl({ pos, x1, y1, x2, y2 }) {
  return pos === Position.Left || pos === Position.Right ? [0.5 * (x1 + x2), y1] : [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {
  const [sourceControlX, sourceControlY] = getControl({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY
  }), [targetControlX, targetControlY] = getControl({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function createSimpleBezierEdge(params) {
  return memo$3(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getSimpleBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SimpleBezierEdge = createSimpleBezierEdge({ isInternal: !1 }), SimpleBezierEdgeInternal = createSimpleBezierEdge({ isInternal: !0 });
SimpleBezierEdge.displayName = "SimpleBezierEdge";
SimpleBezierEdgeInternal.displayName = "SimpleBezierEdgeInternal";
function createSmoothStepEdge(params) {
  return memo$3(({ id: id2, sourceX, sourceY, targetX, targetY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      borderRadius: pathOptions?.borderRadius,
      offset: pathOptions?.offset,
      stepPosition: pathOptions?.stepPosition
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SmoothStepEdge = createSmoothStepEdge({ isInternal: !1 }), SmoothStepEdgeInternal = createSmoothStepEdge({ isInternal: !0 });
SmoothStepEdge.displayName = "SmoothStepEdge";
SmoothStepEdgeInternal.displayName = "SmoothStepEdgeInternal";
function createStepEdge(params) {
  return memo$3(({ id: id2, ...props }) => {
    const _id = params.isInternal ? void 0 : id2;
    return jsx(SmoothStepEdge, { ...props, id: _id, pathOptions: useMemo(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) });
  });
}
const StepEdge = createStepEdge({ isInternal: !1 }), StepEdgeInternal = createStepEdge({ isInternal: !0 });
StepEdge.displayName = "StepEdge";
StepEdgeInternal.displayName = "StepEdgeInternal";
function createStraightEdge(params) {
  return memo$3(({ id: id2, sourceX, sourceY, targetX, targetY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const StraightEdge = createStraightEdge({ isInternal: !1 }), StraightEdgeInternal = createStraightEdge({ isInternal: !0 });
StraightEdge.displayName = "StraightEdge";
StraightEdgeInternal.displayName = "StraightEdgeInternal";
function createBezierEdge(params) {
  return memo$3(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      curvature: pathOptions?.curvature
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label: label2, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const BezierEdge = createBezierEdge({ isInternal: !1 }), BezierEdgeInternal = createBezierEdge({ isInternal: !0 });
BezierEdge.displayName = "BezierEdge";
BezierEdgeInternal.displayName = "BezierEdgeInternal";
const builtinEdgeTypes = {
  default: BezierEdgeInternal,
  straight: StraightEdgeInternal,
  step: StepEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  simplebezier: SimpleBezierEdgeInternal
}, nullPosition = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, shiftX = (x2, shift2, position) => position === Position.Left ? x2 - shift2 : position === Position.Right ? x2 + shift2 : x2, shiftY = (y2, shift2, position) => position === Position.Top ? y2 - shift2 : position === Position.Bottom ? y2 + shift2 : y2, EdgeUpdaterClassName = "react-flow__edgeupdater";
function EdgeAnchor({ position, centerX, centerY: centerY2, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {
  return jsx("circle", { onMouseDown, onMouseEnter, onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position), cy: shiftY(centerY2, radius, position), r: radius, stroke: "transparent", fill: "transparent" });
}
function EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {
  const store = useStoreApi(), handleEdgeUpdater = (event, oppositeHandle) => {
    if (event.button !== 0)
      return;
    const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib: lib2, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy: panBy2, updateConnection } = store.getState(), isTarget = oppositeHandle.type === "target", _onReconnectEnd = (evt, connectionState) => {
      setReconnecting(!1), onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);
    }, onConnectEdge = (connection) => onReconnect?.(edge, connection), _onConnectStart = (_event, params) => {
      setReconnecting(!0), onReconnectStart?.(event, edge, oppositeHandle.type), onConnectStart?.(_event, params);
    };
    XYHandle.onPointerDown(event.nativeEvent, {
      autoPanOnConnect,
      connectionMode,
      connectionRadius,
      domNode,
      handleId: oppositeHandle.id,
      nodeId: oppositeHandle.nodeId,
      nodeLookup,
      isTarget,
      edgeUpdaterType: oppositeHandle.type,
      lib: lib2,
      flowId,
      cancelConnection,
      panBy: panBy2,
      isValidConnection,
      onConnect: onConnectEdge,
      onConnectStart: _onConnectStart,
      onConnectEnd,
      onReconnectEnd: _onReconnectEnd,
      updateConnection,
      getTransform: () => store.getState().transform,
      getFromHandle: () => store.getState().connection.fromHandle,
      dragThreshold: store.getState().connectionDragThreshold,
      handleDomNode: event.currentTarget
    });
  }, onReconnectSourceMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.target, id: edge.targetHandle ?? null, type: "target" }), onReconnectTargetMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.source, id: edge.sourceHandle ?? null, type: "source" }), onReconnectMouseEnter = () => setUpdateHover(!0), onReconnectMouseOut = () => setUpdateHover(!1);
  return jsxs(Fragment, { children: [(isReconnectable === !0 || isReconnectable === "source") && jsx(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onReconnectSourceMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "source" }), (isReconnectable === !0 || isReconnectable === "target") && jsx(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onReconnectTargetMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "target" })] });
}
function EdgeWrapper({ id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes: edgeTypes2, noPanClassName, onError, disableKeyboardA11y }) {
  let edge = useStore((s2) => s2.edgeLookup.get(id2));
  const defaultEdgeOptions = useStore((s2) => s2.defaultEdgeOptions);
  edge = defaultEdgeOptions ? { ...defaultEdgeOptions, ...edge } : edge;
  let edgeType = edge.type || "default", EdgeComponent = edgeTypes2?.[edgeType] || builtinEdgeTypes[edgeType];
  EdgeComponent === void 0 && (onError?.("011", errorMessages.error011(edgeType)), edgeType = "default", EdgeComponent = edgeTypes2?.default || builtinEdgeTypes.default);
  const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable > "u"), isReconnectable = typeof onReconnect < "u" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable > "u"), isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable > "u"), edgeRef = useRef(null), [updateHover, setUpdateHover] = useState(!1), [reconnecting, setReconnecting] = useState(!1), store = useStoreApi(), { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore(useCallback((store2) => {
    const sourceNode = store2.nodeLookup.get(edge.source), targetNode = store2.nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode)
      return {
        zIndex: edge.zIndex,
        ...nullPosition
      };
    const edgePosition = getEdgePosition({
      id: id2,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode: store2.connectionMode,
      onError
    });
    return {
      zIndex: getElevatedEdgeZIndex({
        selected: edge.selected,
        zIndex: edge.zIndex,
        sourceNode,
        targetNode,
        elevateOnSelect: store2.elevateEdgesOnSelect,
        zIndexMode: store2.zIndexMode
      }),
      ...edgePosition || nullPosition
    };
  }, [edge.source, edge.target, edge.sourceHandle, edge.targetHandle, edge.selected, edge.zIndex]), shallow$1), markerStartUrl = useMemo(() => edge.markerStart ? `url('#${getMarkerId(edge.markerStart, rfId)}')` : void 0, [edge.markerStart, rfId]), markerEndUrl = useMemo(() => edge.markerEnd ? `url('#${getMarkerId(edge.markerEnd, rfId)}')` : void 0, [edge.markerEnd, rfId]);
  if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null)
    return null;
  const onEdgeClick = (event) => {
    const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
    isSelectable && (store.setState({ nodesSelectionActive: !1 }), edge.selected && multiSelectionActive ? (unselectNodesAndEdges({ nodes: [], edges: [edge] }), edgeRef.current?.blur()) : addSelectedEdges([id2])), onClick && onClick(event, edge);
  }, onEdgeDoubleClick2 = onDoubleClick ? (event) => {
    onDoubleClick(event, { ...edge });
  } : void 0, onEdgeContextMenu = onContextMenu ? (event) => {
    onContextMenu(event, { ...edge });
  } : void 0, onEdgeMouseEnter2 = onMouseEnter ? (event) => {
    onMouseEnter(event, { ...edge });
  } : void 0, onEdgeMouseMove = onMouseMove ? (event) => {
    onMouseMove(event, { ...edge });
  } : void 0, onEdgeMouseLeave2 = onMouseLeave ? (event) => {
    onMouseLeave(event, { ...edge });
  } : void 0, onKeyDown = (event) => {
    if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && isSelectable) {
      const { unselectNodesAndEdges, addSelectedEdges } = store.getState();
      event.key === "Escape" ? (edgeRef.current?.blur(), unselectNodesAndEdges({ edges: [edge] })) : addSelectedEdges([id2]);
    }
  };
  return jsx("svg", { style: { zIndex }, children: jsxs("g", { className: cc([
    "react-flow__edge",
    `react-flow__edge-${edgeType}`,
    edge.className,
    noPanClassName,
    {
      selected: edge.selected,
      animated: edge.animated,
      inactive: !isSelectable && !onClick,
      updating: updateHover,
      selectable: isSelectable
    }
  ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClick2, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter2, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave2, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: edge.ariaRole ?? (isFocusable ? "group" : "img"), "aria-roledescription": "edge", "data-id": id2, "data-testid": `rf__edge-${id2}`, "aria-label": edge.ariaLabel === null ? void 0 : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : void 0, ref: edgeRef, ...edge.domAttributes, children: [!reconnecting && jsx(EdgeComponent, { id: id2, source: edge.source, target: edge.target, type: edge.type, selected: edge.selected, animated: edge.animated, selectable: isSelectable, deletable: edge.deletable ?? !0, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, data: edge.data, style: edge.style, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions: "pathOptions" in edge ? edge.pathOptions : void 0, interactionWidth: edge.interactionWidth }), isReconnectable && jsx(EdgeUpdateAnchors, { edge, isReconnectable, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, setUpdateHover, setReconnecting })] }) });
}
var EdgeWrapper$1 = memo$3(EdgeWrapper);
const selector$a = (s2) => ({
  edgesFocusable: s2.edgesFocusable,
  edgesReconnectable: s2.edgesReconnectable,
  elementsSelectable: s2.elementsSelectable,
  connectionMode: s2.connectionMode,
  onError: s2.onError
});
function EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes: edgeTypes2, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter: onEdgeMouseEnter2, onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave2, onEdgeClick, reconnectRadius, onEdgeDoubleClick: onEdgeDoubleClick2, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {
  const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, shallow$1), edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);
  return jsxs("div", { className: "react-flow__edges", children: [jsx(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId }), edgeIds.map((id2) => jsx(EdgeWrapper$1, { id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, noPanClassName, onReconnect, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter2, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave2, onClick: onEdgeClick, reconnectRadius, onDoubleClick: onEdgeDoubleClick2, onReconnectStart, onReconnectEnd, rfId, onError, edgeTypes: edgeTypes2, disableKeyboardA11y }, id2))] });
}
EdgeRendererComponent.displayName = "EdgeRenderer";
const EdgeRenderer = memo$3(EdgeRendererComponent), selector$9 = (s2) => `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]})`;
function Viewport({ children: children2 }) {
  const transform2 = useStore(selector$9);
  return jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: transform2 }, children: children2 });
}
function useOnInitHandler(onInit) {
  const rfInstance = useReactFlow(), isInitialized = useRef(!1);
  useEffect(() => {
    !isInitialized.current && rfInstance.viewportInitialized && onInit && (setTimeout(() => onInit(rfInstance), 1), isInitialized.current = !0);
  }, [onInit, rfInstance.viewportInitialized]);
}
const selector$8 = (state) => state.panZoom?.syncViewport;
function useViewportSync(viewport) {
  const syncViewport = useStore(selector$8), store = useStoreApi();
  return useEffect(() => {
    viewport && (syncViewport?.(viewport), store.setState({ transform: [viewport.x, viewport.y, viewport.zoom] }));
  }, [viewport, syncViewport]), null;
}
function storeSelector$1(s2) {
  return s2.connection.inProgress ? { ...s2.connection, to: pointToRendererPoint(s2.connection.to, s2.transform) } : { ...s2.connection };
}
function getSelector(connectionSelector) {
  return storeSelector$1;
}
function useConnection(connectionSelector) {
  const combinedSelector = getSelector();
  return useStore(combinedSelector, shallow$1);
}
const selector$7$1 = (s2) => ({
  nodesConnectable: s2.nodesConnectable,
  isValid: s2.connection.isValid,
  inProgress: s2.connection.inProgress,
  width: s2.width,
  height: s2.height
});
function ConnectionLineWrapper({ containerStyle: containerStyle2, style: style2, type, component }) {
  const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7$1, shallow$1);
  return !(width && nodesConnectable && inProgress) ? null : jsx("svg", { style: containerStyle2, width, height, className: "react-flow__connectionline react-flow__container", children: jsx("g", { className: cc(["react-flow__connection", getConnectionStatus(isValid)]), children: jsx(ConnectionLine, { style: style2, type, CustomComponent: component, isValid }) }) });
}
const ConnectionLine = ({ style: style2, type = ConnectionLineType.Bezier, CustomComponent, isValid }) => {
  const { inProgress, from, fromNode, fromHandle, fromPosition, to: to2, toNode, toHandle, toPosition, pointer: pointer2 } = useConnection();
  if (!inProgress)
    return;
  if (CustomComponent)
    return jsx(CustomComponent, { connectionLineType: type, connectionLineStyle: style2, fromNode, fromHandle, fromX: from.x, fromY: from.y, toX: to2.x, toY: to2.y, fromPosition, toPosition, connectionStatus: getConnectionStatus(isValid), toNode, toHandle, pointer: pointer2 });
  let path = "";
  const pathParams = {
    sourceX: from.x,
    sourceY: from.y,
    sourcePosition: fromPosition,
    targetX: to2.x,
    targetY: to2.y,
    targetPosition: toPosition
  };
  switch (type) {
    case ConnectionLineType.Bezier:
      [path] = getBezierPath(pathParams);
      break;
    case ConnectionLineType.SimpleBezier:
      [path] = getSimpleBezierPath(pathParams);
      break;
    case ConnectionLineType.Step:
      [path] = getSmoothStepPath({
        ...pathParams,
        borderRadius: 0
      });
      break;
    case ConnectionLineType.SmoothStep:
      [path] = getSmoothStepPath(pathParams);
      break;
    default:
      [path] = getStraightPath(pathParams);
  }
  return jsx("path", { d: path, fill: "none", className: "react-flow__connection-path", style: style2 });
};
ConnectionLine.displayName = "ConnectionLine";
const emptyTypes = {};
function useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {
  useRef(nodeOrEdgeTypes), useStoreApi(), useEffect(() => {
  }, [nodeOrEdgeTypes]);
}
function useStylesLoadedWarning() {
  useStoreApi(), useRef(!1), useEffect(() => {
  }, []);
}
function GraphViewComponent({ nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick: onEdgeDoubleClick2, onNodeMouseEnter: onNodeMouseEnter2, onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave2, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter: onEdgeMouseEnter2, onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave2, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {
  return useNodeOrEdgeTypesWarning(nodeTypes2), useNodeOrEdgeTypesWarning(edgeTypes2), useStylesLoadedWarning(), useOnInitHandler(onInit), useViewportSync(viewport), jsx(FlowRenderer, { onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, onSelectionContextMenu, preventScrolling, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport: !!viewport, children: jsxs(Viewport, { children: [jsx(EdgeRenderer, { edgeTypes: edgeTypes2, onEdgeClick, onEdgeDoubleClick: onEdgeDoubleClick2, onReconnect, onReconnectStart, onReconnectEnd, onlyRenderVisibleElements, onEdgeContextMenu, onEdgeMouseEnter: onEdgeMouseEnter2, onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave2, reconnectRadius, defaultMarkerColor, noPanClassName, disableKeyboardA11y, rfId }), jsx(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle }), jsx("div", { className: "react-flow__edgelabel-renderer" }), jsx(NodeRenderer, { nodeTypes: nodeTypes2, onNodeClick, onNodeDoubleClick, onNodeMouseEnter: onNodeMouseEnter2, onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave2, onNodeContextMenu, nodeClickDistance, onlyRenderVisibleElements, noPanClassName, noDragClassName, disableKeyboardA11y, nodeExtent, rfId }), jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
GraphViewComponent.displayName = "GraphView";
const GraphView = memo$3(GraphViewComponent), getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent, zIndexMode = "basic" } = {}) => {
  const nodeLookup = /* @__PURE__ */ new Map(), parentLookup = /* @__PURE__ */ new Map(), connectionLookup = /* @__PURE__ */ new Map(), edgeLookup = /* @__PURE__ */ new Map(), storeEdges = defaultEdges ?? edges ?? [], storeNodes = defaultNodes ?? nodes ?? [], storeNodeOrigin = nodeOrigin ?? [0, 0], storeNodeExtent = nodeExtent ?? infiniteExtent;
  updateConnectionLookup(connectionLookup, edgeLookup, storeEdges);
  const nodesInitialized = adoptUserNodes(storeNodes, nodeLookup, parentLookup, {
    nodeOrigin: storeNodeOrigin,
    nodeExtent: storeNodeExtent,
    zIndexMode
  });
  let transform2 = [0, 0, 1];
  if (fitView && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node2) => !!((node2.width || node2.initialWidth) && (node2.height || node2.initialHeight))
    }), { x: x2, y: y2, zoom: zoom2 } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);
    transform2 = [x2, y2, zoom2];
  }
  return {
    rfId: "1",
    width: width ?? 0,
    height: height ?? 0,
    transform: transform2,
    nodes: storeNodes,
    nodesInitialized,
    nodeLookup,
    parentLookup,
    edges: storeEdges,
    edgeLookup,
    connectionLookup,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: defaultNodes !== void 0,
    hasDefaultEdges: defaultEdges !== void 0,
    panZoom: null,
    minZoom,
    maxZoom,
    translateExtent: infiniteExtent,
    nodeExtent: storeNodeExtent,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: ConnectionMode.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: storeNodeOrigin,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: fitView ?? !1,
    fitViewOptions,
    fitViewResolver: null,
    connection: { ...initialConnection },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: devWarn,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: defaultAriaLabelConfig,
    zIndexMode,
    onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
    onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
  };
}, createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode }) => createWithEqualityFn((set2, get2) => {
  async function resolveFitView() {
    const { nodeLookup, panZoom, fitViewOptions: fitViewOptions2, fitViewResolver, width: width2, height: height2, minZoom: minZoom2, maxZoom: maxZoom2 } = get2();
    panZoom && (await fitViewport({
      nodes: nodeLookup,
      width: width2,
      height: height2,
      panZoom,
      minZoom: minZoom2,
      maxZoom: maxZoom2
    }, fitViewOptions2), fitViewResolver?.resolve(!0), set2({ fitViewResolver: null }));
  }
  return {
    ...getInitialState({
      nodes,
      edges,
      width,
      height,
      fitView,
      fitViewOptions,
      minZoom,
      maxZoom,
      nodeOrigin,
      nodeExtent,
      defaultNodes,
      defaultEdges,
      zIndexMode
    }),
    setNodes: (nodes2) => {
      const { nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, fitViewQueued, zIndexMode: zIndexMode2 } = get2(), nodesInitialized = adoptUserNodes(nodes2, nodeLookup, parentLookup, {
        nodeOrigin: nodeOrigin2,
        nodeExtent,
        elevateNodesOnSelect,
        checkEquality: !0,
        zIndexMode: zIndexMode2
      });
      fitViewQueued && nodesInitialized ? (resolveFitView(), set2({ nodes: nodes2, nodesInitialized, fitViewQueued: !1, fitViewOptions: void 0 })) : set2({ nodes: nodes2, nodesInitialized });
    },
    setEdges: (edges2) => {
      const { connectionLookup, edgeLookup } = get2();
      updateConnectionLookup(connectionLookup, edgeLookup, edges2), set2({ edges: edges2 });
    },
    setDefaultNodesAndEdges: (nodes2, edges2) => {
      if (nodes2) {
        const { setNodes } = get2();
        setNodes(nodes2), set2({ hasDefaultNodes: !0 });
      }
      if (edges2) {
        const { setEdges } = get2();
        setEdges(edges2), set2({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (updates) => {
      const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2, debug: debug2, fitViewQueued, zIndexMode: zIndexMode2 } = get2(), { changes, updatedInternals } = updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin2, nodeExtent2, zIndexMode2);
      updatedInternals && (updateAbsolutePositions(nodeLookup, parentLookup, { nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2, zIndexMode: zIndexMode2 }), fitViewQueued ? (resolveFitView(), set2({ fitViewQueued: !1, fitViewOptions: void 0 })) : set2({}), changes?.length > 0 && (debug2 && console.log("React Flow: trigger node changes", changes), triggerNodeChanges?.(changes)));
    },
    updateNodePositions: (nodeDragItems, dragging = !1) => {
      const parentExpandChildren = [];
      let changes = [];
      const { nodeLookup, triggerNodeChanges, connection, updateConnection, onNodesChangeMiddlewareMap } = get2();
      for (const [id2, dragItem] of nodeDragItems) {
        const node2 = nodeLookup.get(id2), expandParent = !!(node2?.expandParent && node2?.parentId && dragItem?.position), change2 = {
          id: id2,
          type: "position",
          position: expandParent ? {
            x: Math.max(0, dragItem.position.x),
            y: Math.max(0, dragItem.position.y)
          } : dragItem.position,
          dragging
        };
        if (node2 && connection.inProgress && connection.fromNode.id === node2.id) {
          const updatedFrom = getHandlePosition(node2, connection.fromHandle, Position.Left, !0);
          updateConnection({ ...connection, from: updatedFrom });
        }
        expandParent && node2.parentId && parentExpandChildren.push({
          id: id2,
          parentId: node2.parentId,
          rect: {
            ...dragItem.internals.positionAbsolute,
            width: dragItem.measured.width ?? 0,
            height: dragItem.measured.height ?? 0
          }
        }), changes.push(change2);
      }
      if (parentExpandChildren.length > 0) {
        const { parentLookup, nodeOrigin: nodeOrigin2 } = get2(), parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin2);
        changes.push(...parentExpandChanges);
      }
      for (const middleware of onNodesChangeMiddlewareMap.values())
        changes = middleware(changes);
      triggerNodeChanges(changes);
    },
    triggerNodeChanges: (changes) => {
      const { onNodesChange, setNodes, nodes: nodes2, hasDefaultNodes, debug: debug2 } = get2();
      if (changes?.length) {
        if (hasDefaultNodes) {
          const updatedNodes = applyNodeChanges(changes, nodes2);
          setNodes(updatedNodes);
        }
        debug2 && console.log("React Flow: trigger node changes", changes), onNodesChange?.(changes);
      }
    },
    triggerEdgeChanges: (changes) => {
      const { onEdgesChange, setEdges, edges: edges2, hasDefaultEdges, debug: debug2 } = get2();
      if (changes?.length) {
        if (hasDefaultEdges) {
          const updatedEdges = applyEdgeChanges(changes, edges2);
          setEdges(updatedEdges);
        }
        debug2 && console.log("React Flow: trigger edge changes", changes), onEdgesChange?.(changes);
      }
    },
    addSelectedNodes: (selectedNodeIds) => {
      const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
      if (multiSelectionActive) {
        const nodeChanges = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, !0));
        triggerNodeChanges(nodeChanges);
        return;
      }
      triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set([...selectedNodeIds]), !0)), triggerEdgeChanges(getSelectionChanges(edgeLookup));
    },
    addSelectedEdges: (selectedEdgeIds) => {
      const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
      if (multiSelectionActive) {
        const changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, !0));
        triggerEdgeChanges(changedEdges);
        return;
      }
      triggerEdgeChanges(getSelectionChanges(edgeLookup, /* @__PURE__ */ new Set([...selectedEdgeIds]))), triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: nodes2, edges: edges2 } = {}) => {
      const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2(), nodesToUnselect = nodes2 || storeNodes, edgesToUnselect = edges2 || storeEdges, nodeChanges = nodesToUnselect.map((n2) => {
        const internalNode = nodeLookup.get(n2.id);
        return internalNode && (internalNode.selected = !1), createSelectionChange(n2.id, !1);
      }), edgeChanges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, !1));
      triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
    },
    setMinZoom: (minZoom2) => {
      const { panZoom, maxZoom: maxZoom2 } = get2();
      panZoom?.setScaleExtent([minZoom2, maxZoom2]), set2({ minZoom: minZoom2 });
    },
    setMaxZoom: (maxZoom2) => {
      const { panZoom, minZoom: minZoom2 } = get2();
      panZoom?.setScaleExtent([minZoom2, maxZoom2]), set2({ maxZoom: maxZoom2 });
    },
    setTranslateExtent: (translateExtent) => {
      get2().panZoom?.setTranslateExtent(translateExtent), set2({ translateExtent });
    },
    resetSelectedElements: () => {
      const { edges: edges2, nodes: nodes2, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get2();
      if (!elementsSelectable)
        return;
      const nodeChanges = nodes2.reduce((res, node2) => node2.selected ? [...res, createSelectionChange(node2.id, !1)] : res, []), edgeChanges = edges2.reduce((res, edge) => edge.selected ? [...res, createSelectionChange(edge.id, !1)] : res, []);
      triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
    },
    setNodeExtent: (nextNodeExtent) => {
      const { nodes: nodes2, nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, nodeExtent: nodeExtent2, zIndexMode: zIndexMode2 } = get2();
      nextNodeExtent[0][0] === nodeExtent2[0][0] && nextNodeExtent[0][1] === nodeExtent2[0][1] && nextNodeExtent[1][0] === nodeExtent2[1][0] && nextNodeExtent[1][1] === nodeExtent2[1][1] || (adoptUserNodes(nodes2, nodeLookup, parentLookup, {
        nodeOrigin: nodeOrigin2,
        nodeExtent: nextNodeExtent,
        elevateNodesOnSelect,
        checkEquality: !1,
        zIndexMode: zIndexMode2
      }), set2({ nodeExtent: nextNodeExtent }));
    },
    panBy: (delta) => {
      const { transform: transform2, width: width2, height: height2, panZoom, translateExtent } = get2();
      return panBy({ delta, panZoom, transform: transform2, translateExtent, width: width2, height: height2 });
    },
    setCenter: async (x2, y2, options) => {
      const { width: width2, height: height2, maxZoom: maxZoom2, panZoom } = get2();
      if (!panZoom)
        return Promise.resolve(!1);
      const nextZoom = typeof options?.zoom < "u" ? options.zoom : maxZoom2;
      return await panZoom.setViewport({
        x: width2 / 2 - x2 * nextZoom,
        y: height2 / 2 - y2 * nextZoom,
        zoom: nextZoom
      }, { duration: options?.duration, ease: options?.ease, interpolate: options?.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      set2({
        connection: { ...initialConnection }
      });
    },
    updateConnection: (connection) => {
      set2({ connection });
    },
    reset: () => set2({ ...getInitialState() })
  };
}, Object.is);
function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, zIndexMode, children: children2 }) {
  const [store] = useState(() => createStore({
    nodes,
    edges,
    defaultNodes,
    defaultEdges,
    width,
    height,
    fitView,
    minZoom,
    maxZoom,
    fitViewOptions,
    nodeOrigin,
    nodeExtent,
    zIndexMode
  }));
  return jsx(Provider$1, { value: store, children: jsx(BatchProvider, { children: children2 }) });
}
function Wrapper({ children: children2, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode }) {
  return useContext(StoreContext) ? jsx(Fragment, { children: children2 }) : jsx(ReactFlowProvider, { initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, initialFitViewOptions: fitViewOptions, initialMinZoom: minZoom, initialMaxZoom: maxZoom, nodeOrigin, nodeExtent, zIndexMode, children: children2 });
}
const wrapperStyle = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter: onNodeMouseEnter2, onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave2, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = "Backspace", selectionKeyCode = "Shift", selectionOnDrag = !1, selectionMode = SelectionMode.Full, panActivationKeyCode = "Space", multiSelectionKeyCode = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode = isMacOs() ? "Meta" : "Control", snapToGrid, snapGrid, onlyRenderVisibleElements = !1, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = !0, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = !0, nodeExtent, defaultMarkerColor = "#b1b1b7", zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 1, nodeClickDistance = 0, children: children2, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick: onEdgeDoubleClick2, onEdgeMouseEnter: onEdgeMouseEnter2, onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave2, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = "nodrag", noWheelClassName = "nowheel", noPanClassName = "nopan", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = !0, elevateEdgesOnSelect = !1, disableKeyboardA11y = !1, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style: style2, id: id2, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = "light", debug: debug2, onScroll, ariaLabelConfig, zIndexMode = "basic", ...rest }, ref) {
  const rfId = id2 || "1", colorModeClassName = useColorModeClass(colorMode), wrapperOnScroll = useCallback((e2) => {
    e2.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), onScroll?.(e2);
  }, [onScroll]);
  return jsx("div", { "data-testid": "rf__wrapper", ...rest, onScroll: wrapperOnScroll, style: { ...style2, ...wrapperStyle }, ref, className: cc(["react-flow", className, colorModeClassName]), id: id2, role: "application", children: jsxs(Wrapper, { nodes, edges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode, children: [jsx(GraphView, { onInit, onNodeClick, onEdgeClick, onNodeMouseEnter: onNodeMouseEnter2, onNodeMouseMove, onNodeMouseLeave: onNodeMouseLeave2, onNodeContextMenu, onNodeDoubleClick, nodeTypes: nodeTypes2, edgeTypes: edgeTypes2, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, deleteKeyCode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, onlyRenderVisibleElements, defaultViewport: defaultViewport$1, translateExtent, minZoom, maxZoom, preventScrolling, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick: onEdgeDoubleClick2, onEdgeMouseEnter: onEdgeMouseEnter2, onEdgeMouseMove, onEdgeMouseLeave: onEdgeMouseLeave2, reconnectRadius, defaultMarkerColor, noDragClassName, noWheelClassName, noPanClassName, rfId, disableKeyboardA11y, nodeExtent, viewport, onViewportChange }), jsx(StoreUpdater, { nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, edgesFocusable, edgesReconnectable, elementsSelectable, elevateNodesOnSelect, elevateEdgesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, snapToGrid, snapGrid, connectionMode, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onDelete, onNodeDragStart, onNodeDrag, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, onMove, onMoveStart, onMoveEnd, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, onError, connectionRadius, isValidConnection, selectNodesOnDrag, nodeDragThreshold, connectionDragThreshold, onBeforeDelete, debug: debug2, ariaLabelConfig, zIndexMode }), jsx(SelectionListener, { onSelectionChange }), children2, jsx(Attribution, { proOptions, position: attributionPosition }), jsx(A11yDescriptions, { rfId, disableKeyboardA11y })] }) });
}
var index$3 = fixedForwardRef(ReactFlow);
const selector$6$1 = (s2) => s2.domNode?.querySelector(".react-flow__edgelabel-renderer");
function EdgeLabelRenderer({ children: children2 }) {
  const edgeLabelRenderer = useStore(selector$6$1);
  return edgeLabelRenderer ? createPortal(children2, edgeLabelRenderer) : null;
}
const selector$5$1 = (s2) => s2.domNode?.querySelector(".react-flow__viewport-portal");
function ViewportPortal({ children: children2 }) {
  const viewPortalDiv = useStore(selector$5$1);
  return viewPortalDiv ? createPortal(children2, viewPortalDiv) : null;
}
function LinePattern({ dimensions, lineWidth, variant, className }) {
  return jsx("path", { strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`, className: cc(["react-flow__background-pattern", variant, className]) });
}
function DotPattern({ radius, className }) {
  return jsx("circle", { cx: radius, cy: radius, r: radius, className: cc(["react-flow__background-pattern", "dots", className]) });
}
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2.Lines = "lines", BackgroundVariant2.Dots = "dots", BackgroundVariant2.Cross = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
const defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
}, selector$3$1 = (s2) => ({ transform: s2.transform, patternId: `pattern-${s2.rfId}` });
function BackgroundComponent({
  id: id2,
  variant = BackgroundVariant.Dots,
  // only used for dots and cross
  gap = 20,
  // only used for lines and cross
  size: size2,
  lineWidth = 1,
  offset: offset2 = 0,
  color: color2,
  bgColor,
  style: style2,
  className,
  patternClassName
}) {
  const ref = useRef(null), { transform: transform2, patternId } = useStore(selector$3$1, shallow$1), patternSize = size2 || defaultSize[variant], isDots = variant === BackgroundVariant.Dots, isCross = variant === BackgroundVariant.Cross, gapXY = Array.isArray(gap) ? gap : [gap, gap], scaledGap = [gapXY[0] * transform2[2] || 1, gapXY[1] * transform2[2] || 1], scaledSize = patternSize * transform2[2], offsetXY = Array.isArray(offset2) ? offset2 : [offset2, offset2], patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap, scaledOffset = [
    offsetXY[0] * transform2[2] || 1 + patternDimensions[0] / 2,
    offsetXY[1] * transform2[2] || 1 + patternDimensions[1] / 2
  ], _patternId = `${patternId}${id2 || ""}`;
  return jsxs("svg", { className: cc(["react-flow__background", className]), style: {
    ...style2,
    ...containerStyle,
    "--xy-background-color-props": bgColor,
    "--xy-background-pattern-color-props": color2
  }, ref, "data-testid": "rf__background", children: [jsx("pattern", { id: _patternId, x: transform2[0] % scaledGap[0], y: transform2[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`, children: isDots ? jsx(DotPattern, { radius: scaledSize / 2, className: patternClassName }) : jsx(LinePattern, { dimensions: patternDimensions, lineWidth, variant, className: patternClassName }) }), jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${_patternId})` })] });
}
BackgroundComponent.displayName = "Background";
const Background$1 = memo$3(BackgroundComponent);
function PlusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function MinusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function FitViewIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function LockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function UnlockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function ControlButton({ children: children2, className, ...rest }) {
  return jsx("button", { type: "button", className: cc(["react-flow__controls-button", className]), ...rest, children: children2 });
}
const selector$2$1 = (s2) => ({
  isInteractive: s2.nodesDraggable || s2.nodesConnectable || s2.elementsSelectable,
  minZoomReached: s2.transform[2] <= s2.minZoom,
  maxZoomReached: s2.transform[2] >= s2.maxZoom,
  ariaLabelConfig: s2.ariaLabelConfig
});
function ControlsComponent({ style: style2, showZoom = !0, showFitView = !0, showInteractive = !0, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children: children2, position = "bottom-left", orientation = "vertical", "aria-label": ariaLabel }) {
  const store = useStoreApi(), { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2$1, shallow$1), { zoomIn, zoomOut, fitView } = useReactFlow(), onZoomInHandler = () => {
    zoomIn(), onZoomIn?.();
  }, onZoomOutHandler = () => {
    zoomOut(), onZoomOut?.();
  }, onFitViewHandler = () => {
    fitView(fitViewOptions), onFitView?.();
  }, onToggleInteractivity = () => {
    store.setState({
      nodesDraggable: !isInteractive,
      nodesConnectable: !isInteractive,
      elementsSelectable: !isInteractive
    }), onInteractiveChange?.(!isInteractive);
  };
  return jsxs(Panel, { className: cc(["react-flow__controls", orientation === "horizontal" ? "horizontal" : "vertical", className]), position, style: style2, "data-testid": "rf__controls", "aria-label": ariaLabel ?? ariaLabelConfig["controls.ariaLabel"], children: [showZoom && jsxs(Fragment, { children: [jsx(ControlButton, { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: ariaLabelConfig["controls.zoomIn.ariaLabel"], "aria-label": ariaLabelConfig["controls.zoomIn.ariaLabel"], disabled: maxZoomReached, children: jsx(PlusIcon, {}) }), jsx(ControlButton, { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: ariaLabelConfig["controls.zoomOut.ariaLabel"], "aria-label": ariaLabelConfig["controls.zoomOut.ariaLabel"], disabled: minZoomReached, children: jsx(MinusIcon, {}) })] }), showFitView && jsx(ControlButton, { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: ariaLabelConfig["controls.fitView.ariaLabel"], "aria-label": ariaLabelConfig["controls.fitView.ariaLabel"], children: jsx(FitViewIcon, {}) }), showInteractive && jsx(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: ariaLabelConfig["controls.interactive.ariaLabel"], "aria-label": ariaLabelConfig["controls.interactive.ariaLabel"], children: isInteractive ? jsx(UnlockIcon, {}) : jsx(LockIcon, {}) }), children2] });
}
ControlsComponent.displayName = "Controls";
const Controls = memo$3(ControlsComponent);
function MiniMapNodeComponent({ id: id2, x: x2, y: y2, width, height, style: style2, color: color2, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected: selected2, onClick }) {
  const { background, backgroundColor } = style2 || {}, fill = color2 || background || backgroundColor;
  return jsx("rect", { className: cc(["react-flow__minimap-node", { selected: selected2 }, className]), x: x2, y: y2, rx: borderRadius, ry: borderRadius, width, height, style: {
    fill,
    stroke: strokeColor,
    strokeWidth
  }, shapeRendering, onClick: onClick ? (event) => onClick(event, id2) : void 0 });
}
const MiniMapNode = memo$3(MiniMapNodeComponent), selectorNodeIds = (s2) => s2.nodes.map((node2) => node2.id), getAttrFunction = (func) => func instanceof Function ? func : () => func;
function MiniMapNodes({
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: NodeComponent = MiniMapNode,
  onClick
}) {
  const nodeIds = useStore(selectorNodeIds, shallow$1), nodeColorFunc = getAttrFunction(nodeColor), nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor), nodeClassNameFunc = getAttrFunction(nodeClassName), shapeRendering = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return jsx(Fragment, { children: nodeIds.map((nodeId) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    jsx(NodeComponentWrapper, { id: nodeId, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, NodeComponent, onClick, shapeRendering }, nodeId)
  )) });
}
function NodeComponentWrapperInner({ id: id2, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {
  const { node: node2, x: x2, y: y2, width, height } = useStore((s2) => {
    const { internals } = s2.nodeLookup.get(id2), node22 = internals.userNode, { x: x22, y: y22 } = internals.positionAbsolute, { width: width2, height: height2 } = getNodeDimensions(node22);
    return {
      node: node22,
      x: x22,
      y: y22,
      width: width2,
      height: height2
    };
  }, shallow$1);
  return !node2 || node2.hidden || !nodeHasDimensions(node2) ? null : jsx(NodeComponent, { x: x2, y: y2, width, height, style: node2.style, selected: !!node2.selected, className: nodeClassNameFunc(node2), color: nodeColorFunc(node2), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node2), strokeWidth: nodeStrokeWidth, shapeRendering, onClick, id: node2.id });
}
const NodeComponentWrapper = memo$3(NodeComponentWrapperInner);
var MiniMapNodes$1 = memo$3(MiniMapNodes);
const defaultWidth = 200, defaultHeight = 150, filterHidden = (node2) => !node2.hidden, selector$1$1 = (s2) => {
  const viewBB = {
    x: -s2.transform[0] / s2.transform[2],
    y: -s2.transform[1] / s2.transform[2],
    width: s2.width / s2.transform[2],
    height: s2.height / s2.transform[2]
  };
  return {
    viewBB,
    boundingRect: s2.nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds(s2.nodeLookup, { filter: filterHidden }), viewBB) : viewBB,
    rfId: s2.rfId,
    panZoom: s2.panZoom,
    translateExtent: s2.translateExtent,
    flowWidth: s2.width,
    flowHeight: s2.height,
    ariaLabelConfig: s2.ariaLabelConfig
  };
}, ARIA_LABEL_KEY = "react-flow__minimap-desc";
function MiniMapComponent({
  style: style2,
  className,
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent,
  bgColor,
  maskColor,
  maskStrokeColor,
  maskStrokeWidth,
  position = "bottom-right",
  onClick,
  onNodeClick,
  pannable = !1,
  zoomable = !1,
  ariaLabel,
  inversePan,
  zoomStep = 1,
  offsetScale = 5
}) {
  const store = useStoreApi(), svg = useRef(null), { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1$1, shallow$1), elementWidth = style2?.width ?? defaultWidth, elementHeight = style2?.height ?? defaultHeight, scaledWidth = boundingRect.width / elementWidth, scaledHeight = boundingRect.height / elementHeight, viewScale = Math.max(scaledWidth, scaledHeight), viewWidth = viewScale * elementWidth, viewHeight = viewScale * elementHeight, offset2 = offsetScale * viewScale, x2 = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset2, y2 = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset2, width = viewWidth + offset2 * 2, height = viewHeight + offset2 * 2, labelledBy = `${ARIA_LABEL_KEY}-${rfId}`, viewScaleRef = useRef(0), minimapInstance = useRef();
  viewScaleRef.current = viewScale, useEffect(() => {
    if (svg.current && panZoom)
      return minimapInstance.current = XYMinimap({
        domNode: svg.current,
        panZoom,
        getTransform: () => store.getState().transform,
        getViewScale: () => viewScaleRef.current
      }), () => {
        minimapInstance.current?.destroy();
      };
  }, [panZoom]), useEffect(() => {
    minimapInstance.current?.update({
      translateExtent,
      width: flowWidth,
      height: flowHeight,
      inversePan,
      pannable,
      zoomStep,
      zoomable
    });
  }, [pannable, zoomable, inversePan, zoomStep, translateExtent, flowWidth, flowHeight]);
  const onSvgClick = onClick ? (event) => {
    const [x22, y22] = minimapInstance.current?.pointer(event) || [0, 0];
    onClick(event, { x: x22, y: y22 });
  } : void 0, onSvgNodeClick = onNodeClick ? useCallback((event, nodeId) => {
    const node2 = store.getState().nodeLookup.get(nodeId).internals.userNode;
    onNodeClick(event, node2);
  }, []) : void 0, _ariaLabel = ariaLabel ?? ariaLabelConfig["minimap.ariaLabel"];
  return jsx(Panel, { position, style: {
    ...style2,
    "--xy-minimap-background-color-props": typeof bgColor == "string" ? bgColor : void 0,
    "--xy-minimap-mask-background-color-props": typeof maskColor == "string" ? maskColor : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof maskStrokeColor == "string" ? maskStrokeColor : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof maskStrokeWidth == "number" ? maskStrokeWidth * viewScale : void 0,
    "--xy-minimap-node-background-color-props": typeof nodeColor == "string" ? nodeColor : void 0,
    "--xy-minimap-node-stroke-color-props": typeof nodeStrokeColor == "string" ? nodeStrokeColor : void 0,
    "--xy-minimap-node-stroke-width-props": typeof nodeStrokeWidth == "number" ? nodeStrokeWidth : void 0
  }, className: cc(["react-flow__minimap", className]), "data-testid": "rf__minimap", children: jsxs("svg", { width: elementWidth, height: elementHeight, viewBox: `${x2} ${y2} ${width} ${height}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick, children: [_ariaLabel && jsx("title", { id: labelledBy, children: _ariaLabel }), jsx(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor, nodeStrokeColor, nodeBorderRadius, nodeClassName, nodeStrokeWidth, nodeComponent }), jsx("path", { className: "react-flow__minimap-mask", d: `M${x2 - offset2},${y2 - offset2}h${width + offset2 * 2}v${height + offset2 * 2}h${-width - offset2 * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
MiniMapComponent.displayName = "MiniMap";
const MiniMap$1 = memo$3(MiniMapComponent), scaleSelector = (calculateScale) => (store) => calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : void 0, defaultPositions = {
  [ResizeControlVariant.Line]: "right",
  [ResizeControlVariant.Handle]: "bottom-right"
};
function ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style: style2 = void 0, children: children2, color: color2, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = !1, resizeDirection, autoScale = !0, shouldResize, onResizeStart, onResize, onResizeEnd }) {
  const contextNodeId = useNodeId(), id2 = typeof nodeId == "string" ? nodeId : contextNodeId, store = useStoreApi(), resizeControlRef = useRef(null), isHandleControl = variant === ResizeControlVariant.Handle, scale2 = useStore(useCallback(scaleSelector(isHandleControl && autoScale), [isHandleControl, autoScale]), shallow$1), resizer = useRef(null), controlPosition = position ?? defaultPositions[variant];
  useEffect(() => {
    if (!(!resizeControlRef.current || !id2))
      return resizer.current || (resizer.current = XYResizer({
        domNode: resizeControlRef.current,
        nodeId: id2,
        getStoreItems: () => {
          const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();
          return {
            nodeLookup,
            transform: transform2,
            snapGrid,
            snapToGrid,
            nodeOrigin,
            paneDomNode: domNode
          };
        },
        onChange: (change2, childChanges) => {
          const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState(), changes = [], nextPosition = { x: change2.x, y: change2.y }, node2 = nodeLookup.get(id2);
          if (node2 && node2.expandParent && node2.parentId) {
            const origin = node2.origin ?? nodeOrigin, width = change2.width ?? node2.measured.width ?? 0, height = change2.height ?? node2.measured.height ?? 0, child = {
              id: node2.id,
              parentId: node2.parentId,
              rect: {
                width,
                height,
                ...evaluateAbsolutePosition({
                  x: change2.x ?? node2.position.x,
                  y: change2.y ?? node2.position.y
                }, { width, height }, node2.parentId, nodeLookup, origin)
              }
            }, parentExpandChanges = handleExpandParent([child], nodeLookup, parentLookup, nodeOrigin);
            changes.push(...parentExpandChanges), nextPosition.x = change2.x ? Math.max(origin[0] * width, change2.x) : void 0, nextPosition.y = change2.y ? Math.max(origin[1] * height, change2.y) : void 0;
          }
          if (nextPosition.x !== void 0 && nextPosition.y !== void 0) {
            const positionChange = {
              id: id2,
              type: "position",
              position: { ...nextPosition }
            };
            changes.push(positionChange);
          }
          if (change2.width !== void 0 && change2.height !== void 0) {
            const dimensionChange = {
              id: id2,
              type: "dimensions",
              resizing: !0,
              setAttributes: resizeDirection ? resizeDirection === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: change2.width,
                height: change2.height
              }
            };
            changes.push(dimensionChange);
          }
          for (const childChange of childChanges) {
            const positionChange = {
              ...childChange,
              type: "position"
            };
            changes.push(positionChange);
          }
          triggerNodeChanges(changes);
        },
        onEnd: ({ width, height }) => {
          const dimensionChange = {
            id: id2,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width,
              height
            }
          };
          store.getState().triggerNodeChanges([dimensionChange]);
        }
      })), resizer.current.update({
        controlPosition,
        boundaries: {
          minWidth,
          minHeight,
          maxWidth,
          maxHeight
        },
        keepAspectRatio,
        resizeDirection,
        onResizeStart,
        onResize,
        onResizeEnd,
        shouldResize
      }), () => {
        resizer.current?.destroy();
      };
  }, [
    controlPosition,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    onResizeStart,
    onResize,
    onResizeEnd,
    shouldResize
  ]);
  const positionClassNames = controlPosition.split("-");
  return jsx("div", { className: cc(["react-flow__resize-control", "nodrag", ...positionClassNames, variant, className]), ref: resizeControlRef, style: {
    ...style2,
    scale: scale2,
    ...color2 && { [isHandleControl ? "backgroundColor" : "borderColor"]: color2 }
  }, children: children2 });
}
memo$3(ResizeControl);
const selector$n = (state) => state.domNode?.querySelector(".react-flow__renderer");
function NodeToolbarPortal({ children: children2 }) {
  const wrapperRef = useStore(selector$n);
  return wrapperRef ? createPortal(children2, wrapperRef) : null;
}
const nodeEqualityFn = (a2, b2) => a2?.internals.positionAbsolute.x !== b2?.internals.positionAbsolute.x || a2?.internals.positionAbsolute.y !== b2?.internals.positionAbsolute.y || a2?.measured.width !== b2?.measured.width || a2?.measured.height !== b2?.measured.height || a2?.selected !== b2?.selected || a2?.internals.z !== b2?.internals.z, nodesEqualityFn = (a2, b2) => {
  if (a2.size !== b2.size)
    return !1;
  for (const [key2, node2] of a2)
    if (nodeEqualityFn(node2, b2.get(key2)))
      return !1;
  return !0;
}, storeSelector = (state) => ({
  x: state.transform[0],
  y: state.transform[1],
  zoom: state.transform[2],
  selectedNodesCount: state.nodes.filter((node2) => node2.selected).length
});
function NodeToolbar({ nodeId, children: children2, className, style: style2, isVisible, position = Position.Top, offset: offset2 = 10, align = "center", ...rest }) {
  const contextNodeId = useNodeId(), nodesSelector2 = useCallback((state) => (Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ""]).reduce((res, id2) => {
    const node2 = state.nodeLookup.get(id2);
    return node2 && res.set(node2.id, node2), res;
  }, /* @__PURE__ */ new Map()), [nodeId, contextNodeId]), nodes = useStore(nodesSelector2, nodesEqualityFn), { x: x2, y: y2, zoom: zoom2, selectedNodesCount } = useStore(storeSelector, shallow$1);
  if (!(typeof isVisible == "boolean" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1) || !nodes.size)
    return null;
  const nodeRect = getInternalNodesBounds(nodes), nodesArray = Array.from(nodes.values()), zIndex = Math.max(...nodesArray.map((node2) => node2.internals.z + 1)), wrapperStyle2 = {
    position: "absolute",
    transform: getNodeToolbarTransform(nodeRect, { x: x2, y: y2, zoom: zoom2 }, position, offset2, align),
    zIndex,
    ...style2
  };
  return jsx(NodeToolbarPortal, { children: jsx("div", { style: wrapperStyle2, className: cc(["react-flow__node-toolbar", className]), ...rest, "data-id": nodesArray.reduce((acc, node2) => `${acc}${node2.id} `, "").trim(), children: children2 }) });
}
const { getOwnPropertyNames, getOwnPropertySymbols } = Object, { hasOwnProperty } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
  return function(a2, b2, state) {
    return comparatorA(a2, b2, state) && comparatorB(a2, b2, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function(a2, b2, state) {
    if (!a2 || !b2 || typeof a2 != "object" || typeof b2 != "object")
      return areItemsEqual(a2, b2, state);
    const { cache: cache2 } = state, cachedA = cache2.get(a2), cachedB = cache2.get(b2);
    if (cachedA && cachedB)
      return cachedA === b2 && cachedB === a2;
    cache2.set(a2, b2), cache2.set(b2, a2);
    const result = areItemsEqual(a2, b2, state);
    return cache2.delete(a2), cache2.delete(b2), result;
  };
}
function getStrictProperties(object2) {
  return getOwnPropertyNames(object2).concat(getOwnPropertySymbols(object2));
}
const hasOwn = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((object2, property) => hasOwnProperty.call(object2, property))
), PREACT_VNODE = "__v", PREACT_OWNER = "__o", REACT_OWNER = "_owner", { getOwnPropertyDescriptor, keys: keys$1 } = Object, sameValueEqual = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.is || function(a2, b2) {
    return a2 === b2 ? a2 !== 0 || 1 / a2 === 1 / b2 : a2 !== a2 && b2 !== b2;
  }
);
function strictEqual(a2, b2) {
  return a2 === b2;
}
function areArrayBuffersEqual(a2, b2) {
  return a2.byteLength === b2.byteLength && areTypedArraysEqual(new Uint8Array(a2), new Uint8Array(b2));
}
function areArraysEqual(a2, b2, state) {
  let index2 = a2.length;
  if (b2.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!state.equals(a2[index2], b2[index2], index2, index2, a2, b2, state))
      return !1;
  return !0;
}
function areDataViewsEqual(a2, b2) {
  return a2.byteLength === b2.byteLength && areTypedArraysEqual(new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), new Uint8Array(b2.buffer, b2.byteOffset, b2.byteLength));
}
function areDatesEqual(a2, b2) {
  return sameValueEqual(a2.getTime(), b2.getTime());
}
function areErrorsEqual(a2, b2) {
  return a2.name === b2.name && a2.message === b2.message && a2.cause === b2.cause && a2.stack === b2.stack;
}
function areMapsEqual(a2, b2, state) {
  const size2 = a2.size;
  if (size2 !== b2.size)
    return !1;
  if (!size2)
    return !0;
  const matchedIndices = new Array(size2), aIterable = a2.entries();
  let aResult, bResult, index2 = 0;
  for (; (aResult = aIterable.next()) && !aResult.done; ) {
    const bIterable = b2.entries();
    let hasMatch = !1, matchIndex = 0;
    for (; (bResult = bIterable.next()) && !bResult.done; ) {
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      const aEntry = aResult.value, bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index2, matchIndex, a2, b2, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a2, b2, state)) {
        hasMatch = matchedIndices[matchIndex] = !0;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch)
      return !1;
    index2++;
  }
  return !0;
}
function areObjectsEqual(a2, b2, state) {
  const properties2 = keys$1(a2);
  let index2 = properties2.length;
  if (keys$1(b2).length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!isPropertyEqual(a2, b2, state, properties2[index2]))
      return !1;
  return !0;
}
function areObjectsEqualStrict(a2, b2, state) {
  const properties2 = getStrictProperties(a2);
  let index2 = properties2.length;
  if (getStrictProperties(b2).length !== index2)
    return !1;
  let property, descriptorA, descriptorB;
  for (; index2-- > 0; )
    if (property = properties2[index2], !isPropertyEqual(a2, b2, state, property) || (descriptorA = getOwnPropertyDescriptor(a2, property), descriptorB = getOwnPropertyDescriptor(b2, property), (descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)))
      return !1;
  return !0;
}
function arePrimitiveWrappersEqual(a2, b2) {
  return sameValueEqual(a2.valueOf(), b2.valueOf());
}
function areRegExpsEqual(a2, b2) {
  return a2.source === b2.source && a2.flags === b2.flags;
}
function areSetsEqual(a2, b2, state) {
  const size2 = a2.size;
  if (size2 !== b2.size)
    return !1;
  if (!size2)
    return !0;
  const matchedIndices = new Array(size2), aIterable = a2.values();
  let aResult, bResult;
  for (; (aResult = aIterable.next()) && !aResult.done; ) {
    const bIterable = b2.values();
    let hasMatch = !1, matchIndex = 0;
    for (; (bResult = bIterable.next()) && !bResult.done; ) {
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a2, b2, state)) {
        hasMatch = matchedIndices[matchIndex] = !0;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch)
      return !1;
  }
  return !0;
}
function areTypedArraysEqual(a2, b2) {
  let index2 = a2.byteLength;
  if (b2.byteLength !== index2 || a2.byteOffset !== b2.byteOffset)
    return !1;
  for (; index2-- > 0; )
    if (a2[index2] !== b2[index2])
      return !1;
  return !0;
}
function areUrlsEqual(a2, b2) {
  return a2.hostname === b2.hostname && a2.pathname === b2.pathname && a2.protocol === b2.protocol && a2.port === b2.port && a2.hash === b2.hash && a2.username === b2.username && a2.password === b2.password;
}
function isPropertyEqual(a2, b2, state, property) {
  return (property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a2.$$typeof || b2.$$typeof) ? !0 : hasOwn(b2, property) && state.equals(a2[property], b2[property], property, property, a2, b2, state);
}
const toString = Object.prototype.toString;
function createEqualityComparator(config) {
  const supportedComparatorMap = createSupportedComparatorMap(config), { areArraysEqual: areArraysEqual2, areDatesEqual: areDatesEqual2, areFunctionsEqual, areMapsEqual: areMapsEqual2, areNumbersEqual, areObjectsEqual: areObjectsEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, getUnsupportedCustomComparator } = config;
  return function(a2, b2, state) {
    if (a2 === b2)
      return !0;
    if (a2 == null || b2 == null)
      return !1;
    const type = typeof a2;
    if (type !== typeof b2)
      return !1;
    if (type !== "object")
      return type === "number" || type === "bigint" ? areNumbersEqual(a2, b2, state) : type === "function" ? areFunctionsEqual(a2, b2, state) : !1;
    const constructor = a2.constructor;
    if (constructor !== b2.constructor)
      return !1;
    if (constructor === Object)
      return areObjectsEqual2(a2, b2, state);
    if (constructor === Array)
      return areArraysEqual2(a2, b2, state);
    if (constructor === Date)
      return areDatesEqual2(a2, b2, state);
    if (constructor === RegExp)
      return areRegExpsEqual2(a2, b2, state);
    if (constructor === Map)
      return areMapsEqual2(a2, b2, state);
    if (constructor === Set)
      return areSetsEqual2(a2, b2, state);
    if (constructor === Promise)
      return !1;
    if (Array.isArray(a2))
      return areArraysEqual2(a2, b2, state);
    const tag = toString.call(a2), supportedComparator = supportedComparatorMap[tag];
    if (supportedComparator)
      return supportedComparator(a2, b2, state);
    const unsupportedCustomComparator = getUnsupportedCustomComparator && getUnsupportedCustomComparator(a2, b2, state, tag);
    return unsupportedCustomComparator ? unsupportedCustomComparator(a2, b2, state) : !1;
  };
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
  let config = {
    areArrayBuffersEqual,
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDataViewsEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual: strictEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual: sameValueEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
    areUrlsEqual,
    getUnsupportedCustomComparator: void 0
  };
  if (createCustomConfig && (config = Object.assign({}, config, createCustomConfig(config))), circular) {
    const areArraysEqual2 = createIsCircular(config.areArraysEqual), areMapsEqual2 = createIsCircular(config.areMapsEqual), areObjectsEqual2 = createIsCircular(config.areObjectsEqual), areSetsEqual2 = createIsCircular(config.areSetsEqual);
    config = Object.assign({}, config, {
      areArraysEqual: areArraysEqual2,
      areMapsEqual: areMapsEqual2,
      areObjectsEqual: areObjectsEqual2,
      areSetsEqual: areSetsEqual2
    });
  }
  return config;
}
function createInternalEqualityComparator(compare2) {
  return function(a2, b2, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare2(a2, b2, state);
  };
}
function createIsEqual({ circular, comparator, createState: createState2, equals, strict }) {
  if (createState2)
    return function(a2, b2) {
      const { cache: cache2 = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta } = createState2();
      return comparator(a2, b2, {
        cache: cache2,
        equals,
        meta,
        strict
      });
    };
  if (circular)
    return function(a2, b2) {
      return comparator(a2, b2, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  const state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function(a2, b2) {
    return comparator(a2, b2, state);
  };
}
function createSupportedComparatorMap({ areArrayBuffersEqual: areArrayBuffersEqual2, areArraysEqual: areArraysEqual2, areDataViewsEqual: areDataViewsEqual2, areDatesEqual: areDatesEqual2, areErrorsEqual: areErrorsEqual2, areFunctionsEqual, areMapsEqual: areMapsEqual2, areNumbersEqual, areObjectsEqual: areObjectsEqual2, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, areTypedArraysEqual: areTypedArraysEqual2, areUrlsEqual: areUrlsEqual2 }) {
  return {
    "[object Arguments]": areObjectsEqual2,
    "[object Array]": areArraysEqual2,
    "[object ArrayBuffer]": areArrayBuffersEqual2,
    "[object AsyncGeneratorFunction]": areFunctionsEqual,
    "[object BigInt]": areNumbersEqual,
    "[object BigInt64Array]": areTypedArraysEqual2,
    "[object BigUint64Array]": areTypedArraysEqual2,
    "[object Boolean]": arePrimitiveWrappersEqual2,
    "[object DataView]": areDataViewsEqual2,
    "[object Date]": areDatesEqual2,
    // If an error tag, it should be tested explicitly. Like RegExp, the properties are not
    // enumerable, and therefore will give false positives if tested like a standard object.
    "[object Error]": areErrorsEqual2,
    "[object Float16Array]": areTypedArraysEqual2,
    "[object Float32Array]": areTypedArraysEqual2,
    "[object Float64Array]": areTypedArraysEqual2,
    "[object Function]": areFunctionsEqual,
    "[object GeneratorFunction]": areFunctionsEqual,
    "[object Int8Array]": areTypedArraysEqual2,
    "[object Int16Array]": areTypedArraysEqual2,
    "[object Int32Array]": areTypedArraysEqual2,
    "[object Map]": areMapsEqual2,
    "[object Number]": arePrimitiveWrappersEqual2,
    "[object Object]": (a2, b2, state) => (
      // The exception for value comparison is custom `Promise`-like class instances. These should
      // be treated the same as standard `Promise` objects, which means strict equality, and if
      // it reaches this point then that strict equality comparison has already failed.
      typeof a2.then != "function" && typeof b2.then != "function" && areObjectsEqual2(a2, b2, state)
    ),
    // For RegExp, the properties are not enumerable, and therefore will give false positives if
    // tested like a standard object.
    "[object RegExp]": areRegExpsEqual2,
    "[object Set]": areSetsEqual2,
    "[object String]": arePrimitiveWrappersEqual2,
    "[object URL]": areUrlsEqual2,
    "[object Uint8Array]": areTypedArraysEqual2,
    "[object Uint8ClampedArray]": areTypedArraysEqual2,
    "[object Uint16Array]": areTypedArraysEqual2,
    "[object Uint32Array]": areTypedArraysEqual2
  };
}
const deepEqual$1 = createCustomEqual();
createCustomEqual({ strict: !0 });
createCustomEqual({ circular: !0 });
createCustomEqual({
  circular: !0,
  strict: !0
});
const shallowEqual$1 = createCustomEqual({
  createInternalComparator: () => sameValueEqual
});
createCustomEqual({
  strict: !0,
  createInternalComparator: () => sameValueEqual
});
createCustomEqual({
  circular: !0,
  createInternalComparator: () => sameValueEqual
});
createCustomEqual({
  circular: !0,
  createInternalComparator: () => sameValueEqual,
  strict: !0
});
function createCustomEqual(options = {}) {
  const { circular = !1, createInternalComparator: createCustomInternalComparator, createState: createState2, strict = !1 } = options, config = createEqualityComparatorConfig(options), comparator = createEqualityComparator(config), equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState: createState2, equals, strict });
}
function e$h(e2, t2, n2) {
  let r2 = (n3) => e2(n3, ...t2);
  return n2 === void 0 ? r2 : Object.assign(r2, { lazy: n2, lazyArgs: t2 });
}
function t$x(t2, n2, r2) {
  let i2 = t2.length - n2.length;
  if (i2 === 0) return t2(...n2);
  if (i2 === 1) return e$h(t2, n2, r2);
  throw Error("Wrong number of arguments");
}
const e$g = (e2) => (n2, r2) => {
  if (r2 === 0) return e2(n2);
  if (!Number.isInteger(r2)) throw TypeError(`precision must be an integer: ${r2.toString()}`);
  if (r2 > 15 || r2 < -15) throw RangeError("precision must be between -15 and 15");
  if (Number.isNaN(n2) || !Number.isFinite(n2)) return e2(n2);
  let i2 = t$w(n2, r2), a2 = e2(i2);
  return t$w(a2, -r2);
};
function t$w(e2, t2) {
  let [n2, r2] = e2.toString().split("e"), i2 = (r2 === void 0 ? 0 : Number.parseInt(r2, 10)) + t2, a2 = `${n2}e${i2.toString()}`;
  return Number.parseFloat(a2);
}
function n$v(...n2) {
  return t$x(e$g(Math.ceil), n2);
}
function t$v(...t2) {
  return t$x(n$u, t2);
}
const n$u = (e2, { min: t2, max: n2 }) => t2 !== void 0 && e2 < t2 ? t2 : n2 !== void 0 && e2 > n2 ? n2 : e2;
function t$u(...t2) {
  return t$x(n$t, t2);
}
const n$t = (e2, t2) => [...e2, ...t2], t$t = { done: !1, hasNext: !1 }, r$f = (e2) => ({ hasNext: !0, next: e2, done: !1 });
function t$s(e2, ...t2) {
  let a2 = e2, o = t2.map((e3) => "lazy" in e3 ? r$e(e3) : void 0), s2 = 0;
  for (; s2 < t2.length; ) {
    if (o[s2] === void 0 || !i$7(a2)) {
      let e4 = t2[s2];
      a2 = e4(a2), s2 += 1;
      continue;
    }
    let e3 = [];
    for (let n2 = s2; n2 < t2.length; n2++) {
      let t3 = o[n2];
      if (t3 === void 0 || (e3.push(t3), t3.isSingle)) break;
    }
    let r2 = [];
    for (let t3 of a2) if (n$s(t3, r2, e3)) break;
    let { isSingle: c } = e3.at(-1);
    a2 = c ? r2[0] : r2, s2 += e3.length;
  }
  return a2;
}
function n$s(t2, r2, i2) {
  if (i2.length === 0) return r2.push(t2), !1;
  let a2 = t2, o = t$t, s2 = !1;
  for (let [e2, t3] of i2.entries()) {
    let { index: c, items: l } = t3;
    if (l.push(a2), o = t3(a2, c, l), t3.index += 1, o.hasNext) {
      if (o.hasMany ?? !1) {
        for (let t4 of o.next) if (n$s(t4, r2, i2.slice(e2 + 1))) return !0;
        return s2;
      }
      a2 = o.next;
    }
    if (!o.hasNext) break;
    o.done && (s2 = !0);
  }
  return o.hasNext && r2.push(a2), s2;
}
function r$e(e2) {
  let { lazy: t2, lazyArgs: n2 } = e2, r2 = t2(...n2);
  return Object.assign(r2, { isSingle: t2.single ?? !1, index: 0, items: [] });
}
function i$7(e2) {
  return typeof e2 == "string" || typeof e2 == "object" && !!e2 && Symbol.iterator in e2;
}
function t$r(t2, n2) {
  let r2 = n2.length - t2.length;
  if (r2 === 1) {
    let [r3, ...i2] = n2;
    return t$s(r3, { lazy: t2, lazyArgs: i2 });
  }
  if (r2 === 0) {
    let r3 = { lazy: t2, lazyArgs: n2 };
    return Object.assign((t3) => t$s(t3, r3), r3);
  }
  throw Error("Wrong number of arguments");
}
function r$d(...e2) {
  return t$r(i$6, e2);
}
function i$6(n2) {
  if (n2.length === 0) return r$f;
  let r2 = /* @__PURE__ */ new Map();
  for (let e2 of n2) r2.set(e2, (r2.get(e2) ?? 0) + 1);
  return (t2) => {
    let n3 = r2.get(t2);
    return n3 === void 0 || n3 === 0 ? { done: !1, hasNext: !0, next: t2 } : (r2.set(t2, n3 - 1), t$t);
  };
}
function t$q(...t2) {
  return t$x(n$r, t2);
}
const n$r = (e2, t2) => e2.length >= t2, e$f = { asc: (e2, t2) => e2 > t2, desc: (e2, t2) => e2 < t2 };
function t$p(e2, t2) {
  let [n2, ...a2] = t2;
  if (!i$5(n2)) {
    let t3 = r$c(...a2);
    return e2(n2, t3);
  }
  let o = r$c(n2, ...a2);
  return (t3) => e2(t3, o);
}
function r$c(t2, n2, ...i2) {
  let a2 = typeof t2 == "function" ? t2 : t2[0], o = typeof t2 == "function" ? "asc" : t2[1], { [o]: s2 } = e$f, c = n2 === void 0 ? void 0 : r$c(n2, ...i2);
  return (e2, t3) => {
    let n3 = a2(e2), r2 = a2(t3);
    return s2(n3, r2) ? 1 : s2(r2, n3) ? -1 : c?.(e2, t3) ?? 0;
  };
}
function i$5(t2) {
  if (a$3(t2)) return !0;
  if (typeof t2 != "object" || !Array.isArray(t2)) return !1;
  let [n2, r2, ...i2] = t2;
  return a$3(n2) && typeof r2 == "string" && r2 in e$f && i2.length === 0;
}
const a$3 = (e2) => typeof e2 == "function" && e2.length === 1;
function t$o(...t2) {
  return t$x(Object.entries, t2);
}
function n$q(...t2) {
  return t$x(r$b, t2, i$4);
}
const r$b = (e2, t2) => e2.filter(t2), i$4 = (e2) => (n2, r2, i2) => e2(n2, r2, i2) ? { done: !1, hasNext: !0, next: n2 } : t$t, e$e = (e2) => Object.assign(e2, { single: !0 });
function r$a(...t2) {
  return t$x(i$3, t2, e$e(a$2));
}
const i$3 = (e2, t2) => e2.find(t2), a$2 = (e2) => (n2, r2, i2) => e2(n2, r2, i2) ? { done: !0, hasNext: !0, next: n2 } : t$t;
function n$p(...n2) {
  return t$x(r$9, n2, e$e(i$2));
}
const r$9 = ([e2]) => e2, i$2 = () => a$1, a$1 = (e2) => ({ hasNext: !0, next: e2, done: !0 });
function t$n(...t2) {
  return t$x(n$o, t2, r$8);
}
const n$o = (e2, t2) => e2.flatMap(t2), r$8 = (e2) => (t2, n2, r2) => {
  let i2 = e2(t2, n2, r2);
  return Array.isArray(i2) ? { done: !1, hasNext: !0, hasMany: !0, next: i2 } : { done: !1, hasNext: !0, next: i2 };
};
function t$m(...t2) {
  return t$x(n$n, t2);
}
function n$n(e2, t2) {
  for (let [n2, r2] of Object.entries(e2)) t2(r2, n2, e2);
  return e2;
}
function t$l(...t2) {
  return t$x(n$m, t2);
}
const n$m = (e2, t2) => {
  let n2 = /* @__PURE__ */ Object.create(null);
  for (let r2 = 0; r2 < e2.length; r2++) {
    let i2 = e2[r2], a2 = t2(i2, r2, e2);
    if (a2 !== void 0) {
      let e3 = n2[a2];
      e3 === void 0 ? n2[a2] = [i2] : e3.push(i2);
    }
  }
  return Object.setPrototypeOf(n2, Object.prototype), n2;
};
function t$k(...t2) {
  return t$x(n$l, t2);
}
function n$l(e2, t2) {
  if (e2 === t2 || Object.is(e2, t2)) return !0;
  if (typeof e2 != "object" || typeof t2 != "object" || e2 === null || t2 === null || Object.getPrototypeOf(e2) !== Object.getPrototypeOf(t2)) return !1;
  if (Array.isArray(e2)) return r$7(e2, t2);
  if (e2 instanceof Map) return i$1(e2, t2);
  if (e2 instanceof Set) return a(e2, t2);
  if (e2 instanceof Date) return e2.getTime() === t2.getTime();
  if (e2 instanceof RegExp) return e2.toString() === t2.toString();
  if (Object.keys(e2).length !== Object.keys(t2).length) return !1;
  for (let [r2, i2] of Object.entries(e2)) if (!(r2 in t2) || !n$l(i2, t2[r2])) return !1;
  return !0;
}
function r$7(e2, t2) {
  if (e2.length !== t2.length) return !1;
  for (let [r2, i2] of e2.entries()) if (!n$l(i2, t2[r2])) return !1;
  return !0;
}
function i$1(e2, t2) {
  if (e2.size !== t2.size) return !1;
  for (let [r2, i2] of e2.entries()) if (!t2.has(r2) || !n$l(i2, t2.get(r2))) return !1;
  return !0;
}
function a(e2, t2) {
  if (e2.size !== t2.size) return !1;
  let r2 = [...t2];
  for (let t3 of e2) {
    let e3 = !1;
    for (let [i2, a2] of r2.entries()) if (n$l(t3, a2)) {
      e3 = !0, r2.splice(i2, 1);
      break;
    }
    if (!e3) return !1;
  }
  return !0;
}
function n$k(...t2) {
  return t$x(r$6, t2);
}
function r$6(e2, n2) {
  for (let [r2, i2] of Object.entries(n2)) if (!Object.hasOwn(e2, r2) || !t$k(i2, e2[r2])) return !1;
  return !0;
}
function e$d(e2) {
  return Array.isArray(e2);
}
function e$c(e2) {
  return typeof e2 == "boolean";
}
function e$b(e2) {
  return e2 !== void 0;
}
function e$a(e2) {
  return e2 === "" || e2 === void 0 ? !0 : Array.isArray(e2) ? e2.length === 0 : Object.keys(e2).length === 0;
}
const e$9 = (e2) => typeof e2 == "function";
function e$8(e2) {
  return e2 !== null;
}
function e$7(e2) {
  return e2 != null;
}
function e$6(e2) {
  return (t2) => !e2(t2);
}
function e$5(e2) {
  return e2 == null;
}
function e$4(e2) {
  return typeof e2 == "number" && !Number.isNaN(e2);
}
function e$3(e2) {
  if (typeof e2 != "object" || !e2) return !1;
  let t2 = Object.getPrototypeOf(e2);
  return t2 === null || t2 === Object.prototype;
}
function t$j(...t2) {
  return t$x(n$j, t2);
}
function n$j(e2, t2) {
  if (e2 === t2 || Object.is(e2, t2)) return !0;
  if (typeof e2 != "object" || !e2 || typeof t2 != "object" || !t2) return !1;
  if (e2 instanceof Map && t2 instanceof Map) return r$5(e2, t2);
  if (e2 instanceof Set && t2 instanceof Set) return i(e2, t2);
  let n2 = Object.keys(e2);
  if (n2.length !== Object.keys(t2).length) return !1;
  for (let r2 of n2) {
    if (!Object.hasOwn(t2, r2)) return !1;
    let { [r2]: n3 } = e2, { [r2]: i2 } = t2;
    if (n3 !== i2 || !Object.is(n3, i2)) return !1;
  }
  return !0;
}
function r$5(e2, t2) {
  if (e2.size !== t2.size) return !1;
  for (let [n2, r2] of e2) {
    let e3 = t2.get(n2);
    if (r2 !== e3 || !Object.is(r2, e3)) return !1;
  }
  return !0;
}
function i(e2, t2) {
  if (e2.size !== t2.size) return !1;
  for (let n2 of e2) if (!t2.has(n2)) return !1;
  return !0;
}
function e$2(e2) {
  return typeof e2 == "string";
}
function e$1(e2) {
  return !!e2;
}
function t$i(...t2) {
  return t$x(n$i, t2);
}
const n$i = (e2, t2) => e2.join(t2);
function t$h(...t2) {
  return t$x(Object.keys, t2);
}
function t$g(...t2) {
  return t$x(n$h, t2);
}
const n$h = (e2) => e2.at(-1);
function t$f(...t2) {
  return t$x(n$g, t2, r$4);
}
const n$g = (e2, t2) => e2.map(t2), r$4 = (e2) => (t2, n2, r2) => ({ done: !1, hasNext: !0, next: e2(t2, n2, r2) });
function t$e(...t2) {
  return t$x(n$f, t2);
}
function n$f(e2, t2) {
  let n2 = {};
  for (let [r2, i2] of e2.entries()) {
    let [a2, o] = t2(i2, r2, e2);
    n2[a2] = o;
  }
  return n2;
}
function t$d(...t2) {
  return t$x(n$e, t2);
}
function n$e(e2, t2) {
  let n2 = {};
  for (let [r2, i2] of Object.entries(e2)) n2[r2] = t2(i2, r2, e2);
  return n2;
}
function n$d(...t2) {
  return t$x(r$3, t2);
}
function r$3(e2, n2) {
  let i2 = { ...e2, ...n2 };
  for (let a2 in n2) {
    if (!(a2 in e2)) continue;
    let { [a2]: o } = e2;
    if (!e$3(o)) continue;
    let { [a2]: s2 } = n2;
    e$3(s2) && (i2[a2] = r$3(o, s2));
  }
  return i2;
}
function n$c(...t2) {
  return t$x(r$2, t2);
}
function r$2(e2, n2) {
  if (!t$q(n2, 1)) return { ...e2 };
  if (!t$q(n2, 2)) {
    let { [n2[0]]: t2, ...r3 } = e2;
    return r3;
  }
  let r2 = { ...e2 };
  for (let e3 of n2) delete r2[e3];
  return r2;
}
function t$c(...t2) {
  return t$x(n$b, t2);
}
function n$b(e2, t2) {
  let n2 = { ...e2 };
  for (let [r2, i2] of Object.entries(n2)) t2(i2, r2, e2) && delete n2[r2];
  return n2;
}
function t$b(...t2) {
  return t$x(n$a, t2);
}
const n$a = (e2) => e2.length === 1 ? e2[0] : void 0;
function t$a(...t2) {
  return t$x(n$9, t2);
}
const n$9 = (e2, t2) => {
  let n2 = [[], []];
  for (let [r2, i2] of e2.entries()) t2(i2, r2, e2) ? n2[0].push(i2) : n2[1].push(i2);
  return n2;
};
function t$9(...t2) {
  return t$x(n$8, t2);
}
function n$8(e2, t2) {
  let n2 = {};
  for (let r2 of t2) r2 in e2 && (n2[r2] = e2[r2]);
  return n2;
}
function t$8(...t2) {
  return t$x(n$7, t2);
}
function n$7(e2, t2) {
  let n2 = {};
  for (let [r2, i2] of Object.entries(e2)) t2(i2, r2, e2) && (n2[r2] = i2);
  return n2;
}
function e(e2, ...n2) {
  return typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "symbol" ? (r2) => t$7(r2, e2, ...n2) : t$7(e2, ...n2);
}
function t$7(e2, ...t2) {
  let n2 = e2;
  for (let e3 of t2) {
    if (n2 == null) return;
    n2 = n2[e3];
  }
  return n2;
}
function t$6(...t2) {
  return t$x(n$6, t2);
}
function n$6(e2, t2) {
  let n2 = [];
  for (let r2 = e2; r2 < t2; r2++) n2.push(r2);
  return n2;
}
function t$5(...t2) {
  return t$x(n$5, t2);
}
const n$5 = (e2, t2, n2) => e2.reduce(t2, n2);
function t$4(...t2) {
  return t$x(n$4, t2);
}
function n$4(e2) {
  return [...e2].reverse();
}
function t$3(...t2) {
  return t$x(n$3, t2);
}
function n$3(e2, t2) {
  let n2 = [...e2];
  return n2.sort(t2), n2;
}
function t$2(...t2) {
  return t$p(n$2, t2);
}
const n$2 = (e2, t2) => [...e2].sort(t2);
function t$1(...t2) {
  return t$x(n$1, t2);
}
function n$1(e2, t2) {
  return t2(e2), e2;
}
function n(...e2) {
  return t$r(r$1, e2);
}
function r$1() {
  let t2 = /* @__PURE__ */ new Set();
  return (n2) => t2.has(n2) ? t$t : (t2.add(n2), { done: !1, hasNext: !0, next: n2 });
}
let listenerQueue = [], lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4, atom = /* @__NO_SIDE_EFFECTS__ */ (initialValue) => {
  let listeners = [], $atom = {
    get() {
      return $atom.lc || $atom.listen(() => {
      })(), $atom.value;
    },
    lc: 0,
    listen(listener) {
      return $atom.lc = listeners.push(listener), () => {
        for (let i2 = lqIndex + QUEUE_ITEMS_PER_LISTENER; i2 < listenerQueue.length; )
          listenerQueue[i2] === listener ? listenerQueue.splice(i2, QUEUE_ITEMS_PER_LISTENER) : i2 += QUEUE_ITEMS_PER_LISTENER;
        let index2 = listeners.indexOf(listener);
        ~index2 && (listeners.splice(index2, 1), --$atom.lc || $atom.off());
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners)
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER)
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      oldValue !== newValue && ($atom.value = newValue, $atom.notify(oldValue));
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      return listener($atom.value), unbind;
    },
    value: initialValue
  };
  return $atom;
};
var __assign = function() {
  return __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && (t2[p2] = s2[p2]);
    }
    return t2;
  }, __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
  if (s2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++)
      e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
  return t2;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++)
    (ar || !(i2 in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i2)), ar[i2] = from[i2]);
  return to2.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  return typeof ref == "function" ? ref(value) : ref && (ref.current = value), ref;
}
function useCallbackRef$2(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          last !== value && (ref.value = value, ref.callback(value, last));
        }
      }
    };
  })[0];
  return ref.callback = callback, ref.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window < "u" ? React.useLayoutEffect : React.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs$1(refs, defaultValue) {
  var callbackRef = useCallbackRef$2(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  return useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        nextRefs_1.has(ref) || assignRef$1(ref, null);
      }), nextRefs_1.forEach(function(ref) {
        prevRefs_1.has(ref) || assignRef$1(ref, current_1);
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]), callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  middleware === void 0 && (middleware = ItoI);
  var buffer = [], assigned = !1, medium = {
    read: function() {
      if (assigned)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return buffer.length ? buffer[buffer.length - 1] : defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      return buffer.push(item), function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      for (assigned = !0; buffer.length; ) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = !0;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb), pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [], cbs2.forEach(cb);
      }, cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle(), buffer = {
        push: function(x2) {
          pendingQueue.push(x2), cycle();
        },
        filter: function(filter2) {
          return pendingQueue = pendingQueue.filter(filter2), buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  options === void 0 && (options = {});
  var medium = innerCreateMedium(null);
  return medium.options = __assign({ async: !0, ssr: !1 }, options), medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var Target = sideCar.read();
  if (!Target)
    throw new Error("Sidecar medium not found");
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(medium, exported) {
  return medium.useMedium(exported), SideCar$1;
}
var effectCar = createSidecarMedium(), nothing = function() {
}, RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null), _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1], forwardProps = props.forwardProps, children2 = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), SideCar2 = sideCar, containerRef = useMergeRefs$1([ref, parentRef]), containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children2), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children2)
  );
});
RemoveScroll.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  return nonce && tag.setAttribute("nonce", nonce), tag;
}
function injectStyles(tag, css2) {
  tag.styleSheet ? tag.styleSheet.cssText = css2 : tag.appendChild(document.createTextNode(css2));
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0, stylesheet = null;
  return {
    add: function(style2) {
      counter == 0 && (stylesheet = makeStyleTag()) && (injectStyles(stylesheet, style2), insertStyleTag(stylesheet)), counter++;
    },
    remove: function() {
      counter--, !counter && stylesheet && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null);
    }
  };
}, styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      return sheet.add(styles), function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
}, styleSingleton = function() {
  var useStyle2 = styleHookSingleton(), Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    return useStyle2(styles, dynamic), null;
  };
  return Sheet;
}, zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
}, getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body), left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"], top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"], right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
}, getGapWidth = function(gapMode) {
  if (gapMode === void 0 && (gapMode = "margin"), typeof window > "u")
    return zeroGap;
  var offsets = getOffset(gapMode), documentWidth = document.documentElement.clientWidth, windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  return gapMode === void 0 && (gapMode = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
}, getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
}, useLockAttribute = function() {
  React.useEffect(function() {
    return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
      var newCounter = getCurrentUseCounter() - 1;
      newCounter <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, newCounter.toString());
    };
  }, []);
}, RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, noImportant ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        return passiveSupported = !0, !0;
      }
    });
    window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(node2, overflow) {
  if (!(node2 instanceof Element))
    return !1;
  var styles = window.getComputedStyle(node2);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node2) && styles[overflow] === "visible")
  );
}, elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
}, elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
}, locationCouldBeScrolled = function(axis, node2) {
  var ownerDocument = node2.ownerDocument, current2 = node2;
  do {
    typeof ShadowRoot < "u" && current2 instanceof ShadowRoot && (current2 = current2.host);
    var isScrollable = elementCouldBeScrolled(axis, current2);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current2), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight)
        return !0;
    }
    current2 = current2.parentNode;
  } while (current2 && current2 !== ownerDocument.body);
  return !1;
}, getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
}, getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
}, elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
}, getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
}, getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
}, handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction), delta = directionFactor * sourceDelta, target = event.target, targetInLock = endTarget.contains(target), shouldCancelScroll = !1, isDeltaPositive = delta > 0, availableScroll = 0, availableScrollTop = 0;
  do {
    if (!target)
      break;
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2], elementScroll = scroll_1 - capacity - directionFactor * position;
    (position || elementScroll) && elementCouldBeScrolled(axis, target) && (availableScroll += elementScroll, availableScrollTop += position);
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  return (isDeltaPositive && Math.abs(availableScroll) < 1 || !isDeltaPositive && Math.abs(availableScrollTop) < 1) && (shouldCancelScroll = !0), shouldCancelScroll;
}, getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
}, extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
}, generateStyle = function(id2) {
  return `
  .block-interactivity-`.concat(id2, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id2, ` {pointer-events: all;}
`);
}, idCounter$1 = 0, lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]), touchStartRef = React.useRef([0, 0]), activeAxis = React.useRef(), id2 = React.useState(idCounter$1++)[0], Style2 = React.useState(styleSingleton)[0], lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]), React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean);
      return allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(id2)), allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey)
      return !lastProps.current.allowPinchZoom;
    var touch = getTouchXY(event), touchStart = touchStartRef.current, deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0], deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1], currentAxis, target = event.target, moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range")
      return !1;
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection)
      return !0;
    if (canBeScrolledInMainDirection ? currentAxis = moveDirection : (currentAxis = moveDirection === "v" ? "h" : "v", canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)), !canBeScrolledInMainDirection)
      return !1;
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY) && (activeAxis.current = currentAxis), !currentAxis)
      return !0;
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []), shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style2)) {
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event), sourceEvent2 = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent2 && sourceEvent2.should) {
        event.cancelable && event.preventDefault();
        return;
      }
      if (!sourceEvent2) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
          return node2.contains(event.target);
        }), shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        shouldStop && event.cancelable && event.preventDefault();
      }
    }
  }, []), shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event), setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []), scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event), activeAxis.current = void 0;
  }, []), scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []), scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    return lockStack.push(Style2), props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    }), document.addEventListener("wheel", shouldPrevent, nonPassive), document.addEventListener("touchmove", shouldPrevent, nonPassive), document.addEventListener("touchstart", scrollTouchStart, nonPassive), function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      }), document.removeEventListener("wheel", shouldPrevent, nonPassive), document.removeEventListener("touchmove", shouldPrevent, nonPassive), document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node2) {
  for (var shadowParent = null; node2 !== null; )
    node2 instanceof ShadowRoot && (shadowParent = node2.host, node2 = node2.host), node2 = node2.parentNode;
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
function keys(object2) {
  return Object.keys(object2);
}
function isObject$1(item) {
  return item && typeof item == "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target }, _source = source;
  return isObject$1(target) && isObject$1(source) && Object.keys(source).forEach((key2) => {
    isObject$1(_source[key2]) && key2 in target ? result[key2] = deepMerge(result[key2], _source[key2]) : result[key2] = _source[key2];
  }), result;
}
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function getTransformedScaledValue(value) {
  return typeof value != "string" || !value.includes("var(--mantine-scale)") ? value : value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px$1(value) {
  const transformedValue = getTransformedScaledValue(value);
  return typeof transformedValue == "number" ? transformedValue : typeof transformedValue == "string" ? transformedValue.includes("calc") || transformedValue.includes("var") ? transformedValue : transformedValue.includes("px") ? Number(transformedValue.replace("px", "")) : transformedValue.includes("rem") ? Number(transformedValue.replace("rem", "")) * 16 : transformedValue.includes("em") ? Number(transformedValue.replace("em", "")) * 16 : Number(transformedValue) : NaN;
}
function scaleRem(remValue) {
  return remValue === "0rem" ? "0rem" : `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = !1 } = {}) {
  function converter(value) {
    if (value === 0 || value === "0")
      return `0${units}`;
    if (typeof value == "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value == "string") {
      if (value === "" || value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba("))
        return value;
      if (value.includes(","))
        return value.split(",").map((val) => converter(val)).join(",");
      if (value.includes(" "))
        return value.split(" ").map((val) => converter(val)).join(" ");
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
const rem = createConverter("rem", { shouldScale: !0 }), em = createConverter("em");
function filterProps$1(props) {
  return Object.keys(props).reduce((acc, key2) => (props[key2] !== void 0 && (acc[key2] = props[key2]), acc), {});
}
function isNumberLike(value) {
  if (typeof value == "number")
    return !0;
  if (typeof value == "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "")
      return !0;
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return value.trim().split(/\s+/).every((val) => cssUnitsRegex.test(val));
  }
  return !1;
}
function isElement$1(value) {
  return Array.isArray(value) || value === null ? !1 : typeof value == "object" ? value.type !== Fragment$1 : !1;
}
function createSafeContext$1(errorMessage) {
  const Context = createContext(null);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => {
    const ctx = useContext(Context);
    if (ctx === null)
      throw new Error(errorMessage);
    return ctx;
  }];
}
function createOptionalContext(initialValue = null) {
  const Context = createContext(initialValue);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => useContext(Context)];
}
function getSafeId(uid, errorMessage) {
  return (value) => {
    if (typeof value != "string" || value.trim().length === 0)
      throw new Error(errorMessage);
    return `${uid}-${value}`;
  };
}
function findElementAncestor(element, selector3) {
  let _element = element;
  for (; (_element = _element.parentElement) && !_element.matches(selector3); )
    ;
  return _element;
}
function getPreviousIndex$1(current2, elements, loop) {
  for (let i2 = current2 - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current2;
}
function getNextIndex$1(current2, elements, loop) {
  for (let i2 = current2 + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current2;
}
function onSameLevel(target, sibling, parentSelector) {
  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({
  parentSelector,
  siblingSelector,
  onKeyDown,
  loop = !0,
  activateOnFocus = !1,
  dir = "rtl",
  orientation
}) {
  return (event) => {
    onKeyDown?.(event);
    const elements = Array.from(
      findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll(
        siblingSelector
      ) || []
    ).filter((node2) => onSameLevel(event.currentTarget, node2, parentSelector)), current2 = elements.findIndex((el) => event.currentTarget === el), _nextIndex = getNextIndex$1(current2, elements, loop), _previousIndex = getPreviousIndex$1(current2, elements, loop), nextIndex = dir === "rtl" ? _previousIndex : _nextIndex, previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
    switch (event.key) {
      case "ArrowRight": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[nextIndex].focus(), activateOnFocus && elements[nextIndex].click());
        break;
      }
      case "ArrowLeft": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[previousIndex].focus(), activateOnFocus && elements[previousIndex].click());
        break;
      }
      case "ArrowUp": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_previousIndex].focus(), activateOnFocus && elements[_previousIndex].click());
        break;
      }
      case "ArrowDown": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_nextIndex].focus(), activateOnFocus && elements[_nextIndex].click());
        break;
      }
      case "Home": {
        event.stopPropagation(), event.preventDefault(), !elements[0].disabled && elements[0].focus();
        break;
      }
      case "End": {
        event.stopPropagation(), event.preventDefault();
        const last = elements.length - 1;
        !elements[last].disabled && elements[last].focus();
        break;
      }
    }
  };
}
const elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function getDefaultZIndex(level) {
  return elevations[level];
}
const noop$4 = () => {
};
function closeOnEscape(callback, options = { active: !0 }) {
  return typeof callback != "function" || !options.active ? options.onKeyDown || noop$4 : (event) => {
    event.key === "Escape" && (callback(event), options.onTrigger?.());
  };
}
function getSize(size2, prefix = "size", convertToRem = !0) {
  if (size2 !== void 0)
    return isNumberLike(size2) ? convertToRem ? rem(size2) : size2 : `var(--${prefix}-${size2})`;
}
function getSpacing(size2) {
  return getSize(size2, "mantine-spacing");
}
function getRadius$1(size2) {
  return size2 === void 0 ? "var(--mantine-radius-default)" : getSize(size2, "mantine-radius");
}
function getFontSize(size2) {
  return getSize(size2, "mantine-font-size");
}
function getLineHeight(size2) {
  return getSize(size2, "mantine-line-height", !1);
}
function getShadow(size2) {
  if (size2)
    return getSize(size2, "mantine-shadow", !1);
}
function createEventHandler(parentEventHandler, eventHandler) {
  return (event) => {
    parentEventHandler?.(event), eventHandler?.(event);
  };
}
function getBreakpointValue$1(breakpoint, breakpoints) {
  return breakpoint in breakpoints ? px$1(breakpoints[breakpoint]) : px$1(breakpoint);
}
function getSortedBreakpoints(values2, breakpoints) {
  const convertedBreakpoints = values2.map((breakpoint) => ({
    value: breakpoint,
    px: getBreakpointValue$1(breakpoint, breakpoints)
  }));
  return convertedBreakpoints.sort((a2, b2) => a2.px - b2.px), convertedBreakpoints;
}
function getBaseValue$1(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getContextItemIndex(elementSelector, parentSelector, node2) {
  return node2 ? Array.from(
    findElementAncestor(node2, parentSelector)?.querySelectorAll(elementSelector) || []
  ).findIndex((element) => element === node2) : null;
}
function clamp$3(value, min2, max2) {
  return min2 === void 0 && max2 === void 0 ? value : min2 !== void 0 && max2 === void 0 ? Math.max(value, min2) : Math.min(min2 === void 0 && max2 !== void 0 ? value : Math.max(value, min2), max2);
}
function randomId(prefix = "mantine-") {
  return `${prefix}${Math.random().toString(36).slice(2, 11)}`;
}
function shallowEqual(a2, b2) {
  if (a2 === b2 || Number.isNaN(a2) && Number.isNaN(b2))
    return !0;
  if (!(a2 instanceof Object) || !(b2 instanceof Object))
    return !1;
  const keys2 = Object.keys(a2), { length } = keys2;
  if (length !== Object.keys(b2).length)
    return !1;
  for (let i2 = 0; i2 < length; i2 += 1) {
    const key2 = keys2[i2];
    if (!(key2 in b2) || a2[key2] !== b2[key2] && !(Number.isNaN(a2[key2]) && Number.isNaN(b2[key2])))
      return !1;
  }
  return !0;
}
function useCallbackRef$1(callback) {
  const callbackRef = useRef(callback);
  return useEffect(() => {
    callbackRef.current = callback;
  }), useMemo(() => ((...args) => callbackRef.current?.(...args)), []);
}
function useDebouncedCallback(callback, options) {
  const { delay: delay2, flushOnUnmount, leading } = typeof options == "number" ? { delay: options, flushOnUnmount: !1, leading: !1 } : options, handleCallback = useCallbackRef$1(callback), debounceTimerRef = useRef(0), lastCallback = useMemo(() => {
    const currentCallback = Object.assign(
      (...args) => {
        window.clearTimeout(debounceTimerRef.current);
        const isFirstCall = currentCallback._isFirstCall;
        currentCallback._isFirstCall = !1;
        function clearTimeoutAndLeadingRef() {
          window.clearTimeout(debounceTimerRef.current), debounceTimerRef.current = 0, currentCallback._isFirstCall = !0;
        }
        if (leading && isFirstCall) {
          handleCallback(...args);
          const resetLeadingState = () => {
            clearTimeoutAndLeadingRef();
          }, flush2 = () => {
            debounceTimerRef.current !== 0 && (clearTimeoutAndLeadingRef(), handleCallback(...args));
          }, cancel22 = () => {
            clearTimeoutAndLeadingRef();
          };
          currentCallback.flush = flush2, currentCallback.cancel = cancel22, debounceTimerRef.current = window.setTimeout(resetLeadingState, delay2);
          return;
        }
        if (leading && !isFirstCall) {
          const flush2 = () => {
            debounceTimerRef.current !== 0 && (clearTimeoutAndLeadingRef(), handleCallback(...args));
          }, cancel22 = () => {
            clearTimeoutAndLeadingRef();
          };
          currentCallback.flush = flush2, currentCallback.cancel = cancel22;
          const resetLeadingState = () => {
            clearTimeoutAndLeadingRef();
          };
          debounceTimerRef.current = window.setTimeout(resetLeadingState, delay2);
          return;
        }
        const flush = () => {
          debounceTimerRef.current !== 0 && (clearTimeoutAndLeadingRef(), handleCallback(...args));
        }, cancel2 = () => {
          clearTimeoutAndLeadingRef();
        };
        currentCallback.flush = flush, currentCallback.cancel = cancel2, debounceTimerRef.current = window.setTimeout(flush, delay2);
      },
      {
        flush: () => {
        },
        cancel: () => {
        },
        _isFirstCall: !0
      }
    );
    return currentCallback;
  }, [handleCallback, delay2, leading]);
  return useEffect(
    () => () => {
      flushOnUnmount ? lastCallback.flush() : lastCallback.cancel();
    },
    [lastCallback, flushOnUnmount]
  ), lastCallback;
}
const DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(callback, events, nodes) {
  const ref = useRef(null), eventsList = events || DEFAULT_EVENTS;
  return useEffect(() => {
    const listener = (event) => {
      const { target } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = !document.body.contains(target) && target?.tagName !== "HTML";
        nodes.every((node2) => !!node2 && !event.composedPath().includes(node2)) && !shouldIgnore && callback(event);
      } else ref.current && !ref.current.contains(target) && callback(event);
    };
    return eventsList.forEach((fn) => document.addEventListener(fn, listener)), () => {
      eventsList.forEach((fn) => document.removeEventListener(fn, listener));
    };
  }, [ref, callback, nodes]), ref;
}
function useClipboard(options = { timeout: 2e3 }) {
  const [error, setError] = useState(null), [copied, setCopied] = useState(!1), [copyTimeout, setCopyTimeout] = useState(null), handleCopyResult = (value) => {
    window.clearTimeout(copyTimeout), setCopyTimeout(window.setTimeout(() => setCopied(!1), options.timeout)), setCopied(value);
  };
  return { copy: (value) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(value).then(() => handleCopyResult(!0)).catch((err) => setError(err)) : setError(new Error("useClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    setCopied(!1), setError(null), window.clearTimeout(copyTimeout);
  }, error, copied };
}
function attachMediaListener(query, callback) {
  try {
    return query.addEventListener("change", callback), () => query.removeEventListener("change", callback);
  } catch {
    return query.addListener(callback), () => query.removeListener(callback);
  }
}
function getInitialValue(query, initialValue) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(query).matches : !1;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = {
  getInitialValueInEffect: !0
}) {
  const [matches2, setMatches] = useState(
    getInitialValueInEffect ? initialValue : getInitialValue(query)
  );
  return useEffect(() => {
    try {
      const mediaQuery = window.matchMedia(query);
      return setMatches(mediaQuery.matches), attachMediaListener(mediaQuery, (event) => setMatches(event.matches));
    } catch {
      return;
    }
  }, [query]), matches2 || !1;
}
function useColorScheme$1(initialValue, options) {
  return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark", options) ? "dark" : "light";
}
function useDebouncedState(defaultValue, wait, options = { leading: !1 }) {
  const [value, setValue] = useState(defaultValue), timeoutRef = useRef(null), leadingRef = useRef(!0), clearTimeout2 = () => window.clearTimeout(timeoutRef.current);
  useEffect(() => clearTimeout2, []);
  const debouncedSetValue = useCallback(
    (newValue) => {
      clearTimeout2(), leadingRef.current && options.leading ? setValue(newValue) : timeoutRef.current = window.setTimeout(() => {
        leadingRef.current = !0, setValue(newValue);
      }, wait), leadingRef.current = !1;
    },
    [options.leading]
  );
  return [value, debouncedSetValue];
}
function useDebouncedValue(value, wait, options = { leading: !1 }) {
  const [_value, setValue] = useState(value), mountedRef = useRef(!1), timeoutRef = useRef(null), cooldownRef = useRef(!1), cancel2 = useCallback(() => window.clearTimeout(timeoutRef.current), []);
  return useEffect(() => {
    mountedRef.current && (!cooldownRef.current && options.leading ? (cooldownRef.current = !0, setValue(value)) : (cancel2(), timeoutRef.current = window.setTimeout(() => {
      cooldownRef.current = !1, setValue(value);
    }, wait)));
  }, [value, options.leading, wait]), useEffect(() => (mountedRef.current = !0, cancel2), []), [_value, cancel2];
}
const useIsomorphicEffect = typeof document < "u" ? useLayoutEffect : useEffect;
function useDidUpdate(fn, dependencies) {
  const mounted = useRef(!1);
  useEffect(
    () => () => {
      mounted.current = !1;
    },
    []
  ), useEffect(() => {
    if (mounted.current)
      return fn();
    mounted.current = !0;
  }, dependencies);
}
function useFocusReturn({
  opened,
  shouldReturnFocus = !0
}) {
  const lastActiveElement = useRef(null), returnFocus = () => {
    lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus == "function" && lastActiveElement.current?.focus({ preventScroll: !0 });
  };
  return useDidUpdate(() => {
    let timeout2 = -1;
    const clearFocusTimeout = (event) => {
      event.key === "Tab" && window.clearTimeout(timeout2);
    };
    return document.addEventListener("keydown", clearFocusTimeout), opened ? lastActiveElement.current = document.activeElement : shouldReturnFocus && (timeout2 = window.setTimeout(returnFocus, 10)), () => {
      window.clearTimeout(timeout2), document.removeEventListener("keydown", clearFocusTimeout);
    };
  }, [opened, shouldReturnFocus]), returnFocus;
}
const TABBABLE_NODES = /input|select|textarea|button|object/, FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  return element.style.display === "none";
}
function visible(element) {
  if (element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden")
    return !1;
  let parentElement = element;
  for (; parentElement && !(parentElement === document.body || parentElement.nodeType === 11); ) {
    if (hidden(parentElement))
      return !1;
    parentElement = parentElement.parentNode;
  }
  return !0;
}
function getElementTabIndex(element) {
  let tabIndex = element.getAttribute("tabindex");
  return tabIndex === null && (tabIndex = void 0), parseInt(tabIndex, 10);
}
function focusable$1(element) {
  const nodeName = element.nodeName.toLowerCase(), isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (TABBABLE_NODES.test(nodeName) && !element.disabled || element instanceof HTMLAnchorElement && element.href || isTabIndexNotNaN) && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  return (Number.isNaN(tabIndex) || tabIndex >= 0) && focusable$1(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}
function scopeTab(node2, event) {
  const tabbable2 = findTabbableDescendants(node2);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1], root2 = node2.getRootNode();
  let leavingFinalTabbable = finalTabbable === root2.activeElement || node2 === root2.activeElement;
  const activeElement2 = root2.activeElement;
  if (activeElement2.tagName === "INPUT" && activeElement2.getAttribute("type") === "radio" && (leavingFinalTabbable = tabbable2.filter(
    (element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement2.getAttribute("name")
  ).includes(finalTabbable)), !leavingFinalTabbable)
    return;
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  target && target.focus();
}
function useFocusTrap(active = !0) {
  const ref = useRef(null), focusNode = (node2) => {
    let focusElement = node2.querySelector("[data-autofocus]");
    if (!focusElement) {
      const children2 = Array.from(node2.querySelectorAll(FOCUS_SELECTOR));
      focusElement = children2.find(tabbable) || children2.find(focusable$1) || null, !focusElement && focusable$1(node2) && (focusElement = node2);
    }
    focusElement && focusElement.focus({ preventScroll: !0 });
  }, setRef2 = useCallback(
    (node2) => {
      active && node2 !== null && ref.current !== node2 && (node2 ? (setTimeout(() => {
        node2.getRootNode() && focusNode(node2);
      }), ref.current = node2) : ref.current = null);
    },
    [active]
  );
  return useEffect(() => {
    if (!active)
      return;
    ref.current && setTimeout(() => focusNode(ref.current));
    const handleKeyDown = (event) => {
      event.key === "Tab" && ref.current && scopeTab(ref.current, event);
    };
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [active]), setRef2;
}
const __useId = React__default.useId || (() => {
});
function useReactId$1() {
  const id2 = __useId();
  return id2 ? `mantine-${id2.replace(/:/g, "")}` : "";
}
function useId$2(staticId) {
  const reactId = useReactId$1(), [uuid, setUuid] = useState(reactId);
  return useIsomorphicEffect(() => {
    setUuid(randomId());
  }, []), typeof staticId == "string" ? staticId : typeof window > "u" ? reactId : uuid;
}
function useWindowEvent(type, listener, options) {
  useEffect(() => (window.addEventListener(type, listener, options), () => window.removeEventListener(type, listener, options)), [type, listener]);
}
function serializeJSON(value, hookName = "use-local-storage") {
  try {
    return JSON.stringify(value);
  } catch {
    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);
  }
}
function deserializeJSON(value) {
  try {
    return value && JSON.parse(value);
  } catch {
    return value;
  }
}
function createStorageHandler(type) {
  return { getItem: (key2) => {
    try {
      return window[type].getItem(key2);
    } catch {
      return console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked"), null;
    }
  }, setItem: (key2, value) => {
    try {
      window[type].setItem(key2, value);
    } catch {
      console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
    }
  }, removeItem: (key2) => {
    try {
      window[type].removeItem(key2);
    } catch {
      console.warn(
        "use-local-storage: Failed to remove value from storage, localStorage is blocked"
      );
    }
  } };
}
function createStorage(type, hookName) {
  const eventName = type === "localStorage" ? "mantine-local-storage" : "mantine-session-storage", { getItem, setItem, removeItem: removeItem2 } = createStorageHandler(type);
  return function({
    key: key2,
    defaultValue,
    getInitialValueInEffect = !0,
    sync = !0,
    deserialize = deserializeJSON,
    serialize = (value) => serializeJSON(value, hookName)
  }) {
    const readStorageValue = useCallback(
      (skipStorage) => {
        let storageBlockedOrSkipped;
        try {
          storageBlockedOrSkipped = typeof window > "u" || !(type in window) || window[type] === null || !!skipStorage;
        } catch {
          storageBlockedOrSkipped = !0;
        }
        if (storageBlockedOrSkipped)
          return defaultValue;
        const storageValue = getItem(key2);
        return storageValue !== null ? deserialize(storageValue) : defaultValue;
      },
      [key2, defaultValue]
    ), [value, setValue] = useState(readStorageValue(getInitialValueInEffect)), setStorageValue = useCallback(
      (val) => {
        val instanceof Function ? setValue((current2) => {
          const result = val(current2);
          return setItem(key2, serialize(result)), queueMicrotask(() => {
            window.dispatchEvent(
              new CustomEvent(eventName, { detail: { key: key2, value: val(current2) } })
            );
          }), result;
        }) : (setItem(key2, serialize(val)), window.dispatchEvent(new CustomEvent(eventName, { detail: { key: key2, value: val } })), setValue(val));
      },
      [key2]
    ), removeStorageValue = useCallback(() => {
      removeItem2(key2), setValue(defaultValue), window.dispatchEvent(new CustomEvent(eventName, { detail: { key: key2, value: defaultValue } }));
    }, [key2, defaultValue]);
    return useWindowEvent("storage", (event) => {
      sync && event.storageArea === window[type] && event.key === key2 && setValue(deserialize(event.newValue ?? void 0));
    }), useWindowEvent(eventName, (event) => {
      sync && event.detail.key === key2 && setValue(event.detail.value);
    }), useEffect(() => {
      defaultValue !== void 0 && value === void 0 && setStorageValue(defaultValue);
    }, [defaultValue, value, setStorageValue]), useEffect(() => {
      const val = readStorageValue();
      val !== void 0 && setStorageValue(val);
    }, [key2]), [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];
  };
}
function useLocalStorage(props) {
  return createStorage("localStorage", "use-local-storage")(props);
}
function useSessionStorage(props) {
  return createStorage("sessionStorage", "use-session-storage")(props);
}
function assignRef(ref, value) {
  if (typeof ref == "function")
    return ref(value);
  typeof ref == "object" && ref !== null && "current" in ref && (ref.current = value);
}
function mergeRefs(...refs) {
  const cleanupMap = /* @__PURE__ */ new Map();
  return (node2) => {
    if (refs.forEach((ref) => {
      const cleanup = assignRef(ref, node2);
      cleanup && cleanupMap.set(ref, cleanup);
    }), cleanupMap.size > 0)
      return () => {
        refs.forEach((ref) => {
          const cleanup = cleanupMap.get(ref);
          cleanup && typeof cleanup == "function" ? cleanup() : assignRef(ref, null);
        }), cleanupMap.clear();
      };
  };
}
function useMergedRef(...refs) {
  return useCallback(mergeRefs(...refs), refs);
}
function clampUseMovePosition(position) {
  return {
    x: clamp$3(position.x, 0, 1),
    y: clamp$3(position.y, 0, 1)
  };
}
function useMove(onChange, handlers, dir = "ltr") {
  const mounted = useRef(!1), isSliding = useRef(!1), frame2 = useRef(0), [active, setActive] = useState(!1), cleanupRef = useRef(null);
  return useEffect(() => {
    mounted.current = !0;
  }, []), { ref: useCallback(
    (node2) => {
      if (cleanupRef.current && (cleanupRef.current(), cleanupRef.current = null), !node2)
        return;
      const onScrub = ({ x: x2, y: y2 }) => {
        cancelAnimationFrame(frame2.current), frame2.current = requestAnimationFrame(() => {
          if (mounted.current && node2) {
            node2.style.userSelect = "none";
            const rect = node2.getBoundingClientRect();
            if (rect.width && rect.height) {
              const _x = clamp$3((x2 - rect.left) / rect.width, 0, 1);
              onChange({
                x: dir === "ltr" ? _x : 1 - _x,
                y: clamp$3((y2 - rect.top) / rect.height, 0, 1)
              });
            }
          }
        });
      }, bindEvents = () => {
        document.addEventListener("mousemove", onMouseMove), document.addEventListener("mouseup", stopScrubbing), document.addEventListener("touchmove", onTouchMove, { passive: !1 }), document.addEventListener("touchend", stopScrubbing);
      }, unbindEvents = () => {
        document.removeEventListener("mousemove", onMouseMove), document.removeEventListener("mouseup", stopScrubbing), document.removeEventListener("touchmove", onTouchMove), document.removeEventListener("touchend", stopScrubbing);
      }, startScrubbing = () => {
        !isSliding.current && mounted.current && (isSliding.current = !0, typeof handlers?.onScrubStart == "function" && handlers.onScrubStart(), setActive(!0), bindEvents());
      }, stopScrubbing = () => {
        isSliding.current && mounted.current && (isSliding.current = !1, setActive(!1), unbindEvents(), setTimeout(() => {
          typeof handlers?.onScrubEnd == "function" && handlers.onScrubEnd();
        }, 0));
      }, onMouseDown = (event) => {
        startScrubbing(), event.preventDefault(), onMouseMove(event);
      }, onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY }), onTouchStart = (event) => {
        event.cancelable && event.preventDefault(), startScrubbing(), onTouchMove(event);
      }, onTouchMove = (event) => {
        event.cancelable && event.preventDefault(), onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });
      };
      node2.addEventListener("mousedown", onMouseDown), node2.addEventListener("touchstart", onTouchStart, { passive: !1 }), cleanupRef.current = () => {
        node2.removeEventListener("mousedown", onMouseDown), node2.removeEventListener("touchstart", onTouchStart);
      };
    },
    [dir, onChange]
  ), active };
}
function useUncontrolled({
  value,
  defaultValue,
  finalValue,
  onChange = () => {
  }
}) {
  const [uncontrolledValue, setUncontrolledValue] = useState(
    defaultValue !== void 0 ? defaultValue : finalValue
  ), handleUncontrolledChange = (val, ...payload) => {
    setUncontrolledValue(val), onChange?.(val, ...payload);
  };
  return value !== void 0 ? [value, onChange, !0] : [uncontrolledValue, handleUncontrolledChange, !1];
}
function useReducedMotion$1(initialValue, options) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}
function shallowCompare$1(prevValue, currValue) {
  if (!prevValue || !currValue)
    return !1;
  if (prevValue === currValue)
    return !0;
  if (prevValue.length !== currValue.length)
    return !1;
  for (let i2 = 0; i2 < prevValue.length; i2 += 1)
    if (!shallowEqual(prevValue[i2], currValue[i2]))
      return !1;
  return !0;
}
function useShallowCompare(dependencies) {
  const ref = useRef([]), updateRef = useRef(0);
  return shallowCompare$1(ref.current, dependencies) || (ref.current = dependencies, updateRef.current += 1), [updateRef.current];
}
function useShallowEffect(cb, dependencies) {
  useEffect(cb, useShallowCompare(dependencies));
}
const eventListerOptions = {
  passive: !0
};
function useViewportSize() {
  const [windowSize, setWindowSize] = useState({
    width: 0,
    height: 0
  }), setSize = useCallback(() => {
    setWindowSize({ width: window.innerWidth || 0, height: window.innerHeight || 0 });
  }, []);
  return useWindowEvent("resize", setSize, eventListerOptions), useWindowEvent("orientationchange", setSize, eventListerOptions), useEffect(setSize, []), windowSize;
}
const keyNameMap = {
  " ": "space",
  ArrowLeft: "arrowleft",
  ArrowRight: "arrowright",
  ArrowUp: "arrowup",
  ArrowDown: "arrowdown",
  Escape: "escape",
  Esc: "escape",
  esc: "escape",
  Enter: "enter",
  Tab: "tab",
  Backspace: "backspace",
  Delete: "delete",
  Insert: "insert",
  Home: "home",
  End: "end",
  PageUp: "pageup",
  PageDown: "pagedown",
  "+": "plus",
  "-": "minus",
  "*": "asterisk",
  "/": "slash"
};
function normalizeKey(key2) {
  const lowerKey = key2.replace("Key", "").toLowerCase();
  return keyNameMap[key2] || lowerKey;
}
function parseHotkey(hotkey) {
  const keys2 = hotkey.toLowerCase().split("+").map((part) => part.trim()), modifiers = {
    alt: keys2.includes("alt"),
    ctrl: keys2.includes("ctrl"),
    meta: keys2.includes("meta"),
    mod: keys2.includes("mod"),
    shift: keys2.includes("shift"),
    plus: keys2.includes("[plus]")
  }, reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"], freeKey = keys2.find((key2) => !reservedKeys.includes(key2));
  return {
    ...modifiers,
    key: freeKey === "[plus]" ? "+" : freeKey
  };
}
function isExactHotkey(hotkey, event, usePhysicalKeys) {
  const { alt, ctrl, meta, mod, shift: shift2, key: key2 } = hotkey, { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey, code: pressedCode } = event;
  if (alt !== altKey)
    return !1;
  if (mod) {
    if (!ctrlKey && !metaKey)
      return !1;
  } else if (ctrl !== ctrlKey || meta !== metaKey)
    return !1;
  return shift2 !== shiftKey ? !1 : !!(key2 && (usePhysicalKeys ? normalizeKey(pressedCode) === normalizeKey(key2) : normalizeKey(pressedKey ?? pressedCode) === normalizeKey(key2)));
}
function getHotkeyMatcher(hotkey, usePhysicalKeys) {
  return (event) => isExactHotkey(parseHotkey(hotkey), event, usePhysicalKeys);
}
function getHotkeyHandler(hotkeys) {
  return (event) => {
    const _event = "nativeEvent" in event ? event.nativeEvent : event;
    hotkeys.forEach(
      ([hotkey, handler, options = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
        getHotkeyMatcher(hotkey, options.usePhysicalKeys)(_event) && (options.preventDefault && event.preventDefault(), handler(_event));
      }
    );
  };
}
function shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = !1) {
  return event.target instanceof HTMLElement ? (triggerOnContentEditable || !event.target.isContentEditable) && !tagsToIgnore.includes(event.target.tagName) : !0;
}
function useHotkeys(hotkeys, tagsToIgnore = ["INPUT", "TEXTAREA", "SELECT"], triggerOnContentEditable = !1) {
  useEffect(() => {
    const keydownListener = (event) => {
      hotkeys.forEach(
        ([hotkey, handler, options = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
          getHotkeyMatcher(hotkey, options.usePhysicalKeys)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable) && (options.preventDefault && event.preventDefault(), handler(event));
        }
      );
    };
    return document.documentElement.addEventListener("keydown", keydownListener), () => document.documentElement.removeEventListener("keydown", keydownListener);
  }, [hotkeys]);
}
function useHover$1() {
  const [hovered, setHovered2] = useState(!1), previousNode = useRef(null), handleMouseEnter = useCallback(() => {
    setHovered2(!0);
  }, []), handleMouseLeave = useCallback(() => {
    setHovered2(!1);
  }, []);
  return { ref: useCallback(
    (node2) => {
      previousNode.current && (previousNode.current.removeEventListener("mouseenter", handleMouseEnter), previousNode.current.removeEventListener("mouseleave", handleMouseLeave)), node2 && (node2.addEventListener("mouseenter", handleMouseEnter), node2.addEventListener("mouseleave", handleMouseLeave)), previousNode.current = node2;
    },
    [handleMouseEnter, handleMouseLeave]
  ), hovered };
}
function useDisclosure(initialState2 = !1, options = {}) {
  const [opened, setOpened] = useState(initialState2), open = useCallback(() => {
    setOpened((isOpened) => isOpened || (options.onOpen?.(), !0));
  }, [options.onOpen]), close = useCallback(() => {
    setOpened((isOpened) => isOpened && (options.onClose?.(), !1));
  }, [options.onClose]), toggle = useCallback(() => {
    opened ? close() : open();
  }, [close, open, opened]);
  return [opened, { open, close, toggle }];
}
function containsRelatedTarget(event) {
  return event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement ? event.currentTarget.contains(event.relatedTarget) : !1;
}
function useFocusWithin({
  onBlur,
  onFocus
} = {}) {
  const [focused2, setFocused] = useState(!1), focusedRef = useRef(!1), previousNode = useRef(null), _setFocused = useCallback((value) => {
    setFocused(value), focusedRef.current = value;
  }, []), handleFocusIn = useCallback(
    (event) => {
      focusedRef.current || (_setFocused(!0), onFocus?.(event));
    },
    [onFocus]
  ), handleFocusOut = useCallback(
    (event) => {
      focusedRef.current && !containsRelatedTarget(event) && (_setFocused(!1), onBlur?.(event));
    },
    [onBlur]
  ), callbackRef = useCallback(
    (node2) => {
      node2 && (previousNode.current && (previousNode.current.removeEventListener("focusin", handleFocusIn), previousNode.current.removeEventListener("focusout", handleFocusOut)), node2.addEventListener("focusin", handleFocusIn), node2.addEventListener("focusout", handleFocusOut), previousNode.current = node2);
    },
    [handleFocusIn, handleFocusOut]
  );
  return useEffect(
    () => () => {
      previousNode.current && (previousNode.current.removeEventListener("focusin", handleFocusIn), previousNode.current.removeEventListener("focusout", handleFocusOut));
    },
    []
  ), { ref: callbackRef, focused: focused2 };
}
function useTimeout(callback, delay2, options = { autoInvoke: !1 }) {
  const timeoutRef = useRef(null), start2 = useCallback(
    (...args) => {
      timeoutRef.current || (timeoutRef.current = window.setTimeout(() => {
        callback(args), timeoutRef.current = null;
      }, delay2));
    },
    [delay2]
  ), clear = useCallback(() => {
    timeoutRef.current && (window.clearTimeout(timeoutRef.current), timeoutRef.current = null);
  }, []);
  return useEffect(() => (options.autoInvoke && start2(), clear), [clear, start2]), { start: start2, clear };
}
function useMutationObserver(callback, options, target) {
  const observer = useRef(null), ref = useRef(null);
  return useEffect(() => {
    const targetElement = typeof target == "function" ? target() : target;
    return (targetElement || ref.current) && (observer.current = new MutationObserver(callback), observer.current.observe(targetElement || ref.current, options)), () => {
      observer.current?.disconnect();
    };
  }, [callback, options]), ref;
}
function useMounted() {
  const [mounted, setMounted] = useState(!1);
  return useEffect(() => setMounted(!0), []), mounted;
}
function useStateHistory(initialValue) {
  const [state, setState] = useState({
    history: [initialValue],
    current: 0
  }), set2 = useCallback(
    (val) => setState((currentState) => {
      const nextState = [...currentState.history.slice(0, currentState.current + 1), val];
      return {
        history: nextState,
        current: nextState.length - 1
      };
    }),
    []
  ), back = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.max(0, currentState.current - steps)
    })),
    []
  ), forward = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.min(currentState.history.length - 1, currentState.current + steps)
    })),
    []
  ), reset = useCallback(() => {
    setState({ history: [initialValue], current: 0 });
  }, [initialValue]), handlers = useMemo(() => ({ back, forward, reset, set: set2 }), [back, forward, reset, set2]);
  return [state.history[state.current], handlers, state];
}
function useThrottledCallbackWithClearTimeout(callback, wait) {
  const handleCallback = useCallbackRef$1(callback), latestInArgsRef = useRef(null), latestOutArgsRef = useRef(null), active = useRef(!0), waitRef = useRef(wait), timeoutRef = useRef(-1), clearTimeout2 = () => window.clearTimeout(timeoutRef.current), callThrottledCallback = useCallback(
    (...args) => {
      handleCallback(...args), latestInArgsRef.current = args, latestOutArgsRef.current = args, active.current = !1;
    },
    [handleCallback]
  ), timerCallback = useCallback(() => {
    latestInArgsRef.current && latestInArgsRef.current !== latestOutArgsRef.current ? (callThrottledCallback(...latestInArgsRef.current), timeoutRef.current = window.setTimeout(timerCallback, waitRef.current)) : active.current = !0;
  }, [callThrottledCallback]), throttled = useCallback(
    (...args) => {
      active.current ? (callThrottledCallback(...args), timeoutRef.current = window.setTimeout(timerCallback, waitRef.current)) : latestInArgsRef.current = args;
    },
    [callThrottledCallback, timerCallback]
  );
  return useEffect(() => {
    waitRef.current = wait;
  }, [wait]), [throttled, clearTimeout2];
}
function useThrottledCallback(callback, wait) {
  return useThrottledCallbackWithClearTimeout(callback, wait)[0];
}
function getEnv() {
  return typeof process < "u" && process.env ? "production" : "development";
}
function memoize(func) {
  const cache2 = /* @__PURE__ */ new Map();
  return (...args) => {
    const key2 = JSON.stringify(args);
    if (cache2.has(key2))
      return cache2.get(key2);
    const result = func(...args);
    return cache2.set(key2, result), result;
  };
}
function findClosestNumber(value, numbers) {
  return numbers.length === 0 ? value : numbers.reduce(
    (prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
  );
}
function getRefProp(element) {
  const version2 = React__default.version;
  return typeof React__default.version != "string" || version2.startsWith("18.") ? element?.ref : element?.props?.ref;
}
function findElementBySelector(selector3, root2 = document) {
  const element = root2.querySelector(selector3);
  if (element)
    return element;
  const allElements = root2.querySelectorAll("*");
  for (let i2 = 0; i2 < allElements.length; i2 += 1) {
    const el = allElements[i2];
    if (el.shadowRoot) {
      const shadowElement = findElementBySelector(selector3, el.shadowRoot);
      if (shadowElement)
        return shadowElement;
    }
  }
  return null;
}
function findElementsBySelector(selector3, root2 = document) {
  const results = [], elements = root2.querySelectorAll(selector3);
  results.push(...Array.from(elements));
  const allElements = root2.querySelectorAll("*");
  for (let i2 = 0; i2 < allElements.length; i2 += 1) {
    const el = allElements[i2];
    if (el.shadowRoot) {
      const shadowElements = findElementsBySelector(selector3, el.shadowRoot);
      results.push(...shadowElements);
    }
  }
  return results;
}
function getRootElement(targetElement) {
  if (!targetElement)
    return document;
  const root2 = targetElement.getRootNode();
  return root2 instanceof ShadowRoot || root2 instanceof Document ? root2 : document;
}
function getSingleElementChild(children2) {
  const _children = Children.toArray(children2);
  return _children.length !== 1 || !isElement$1(_children[0]) ? null : _children[0];
}
function r(e2) {
  var t2, f2, n2 = "";
  if (typeof e2 == "string" || typeof e2 == "number") n2 += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) {
    var o = e2.length;
    for (t2 = 0; t2 < o; t2++) e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e2 = arguments[f2]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  return objects.forEach((obj) => {
    Object.entries(obj).forEach(([key2, value]) => {
      merged[key2] ? merged[key2] = clsx(merged[key2], value) : merged[key2] = value;
    });
  }), merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
  const resolvedClassNames = (Array.isArray(classNames) ? classNames : [classNames]).map(
    (item) => typeof item == "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES
  );
  return mergeClassNames(resolvedClassNames);
}
function resolveStyles({ theme, styles, props, stylesCtx }) {
  return (Array.isArray(styles) ? styles : [styles]).reduce((acc, style2) => typeof style2 == "function" ? { ...acc, ...style2(theme, props, stylesCtx) } : { ...acc, ...style2 }, {});
}
const MantineContext = createContext(null);
function useMantineContext() {
  const ctx = useContext(MantineContext);
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
  return useMantineContext().stylesTransform?.styles;
}
function useMantineEnv() {
  return useMantineContext().env || "default";
}
function isHexColor(hex2) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(hex2);
}
function hexToRgba(color2) {
  let hexString = color2.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha2 = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha2
    };
  }
  const parsed = parseInt(hexString, 16), r2 = parsed >> 16 & 255, g2 = parsed >> 8 & 255, b2 = parsed & 255;
  return {
    r: r2,
    g: g2,
    b: b2,
    a: 1
  };
}
function rgbStringToRgba(color2) {
  const [r2, g2, b2, a2] = color2.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r2, g: g2, b: b2, a: a2 === void 0 ? 1 : a2 };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, matches2 = hslaString.match(hslaRegex);
  if (!matches2)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const h2 = parseInt(matches2[1], 10), s2 = parseInt(matches2[2], 10) / 100, l = parseInt(matches2[3], 10) / 100, a2 = matches2[5] ? parseFloat(matches2[5]) : void 0, chroma = (1 - Math.abs(2 * l - 1)) * s2, huePrime = h2 / 60, x2 = chroma * (1 - Math.abs(huePrime % 2 - 1)), m2 = l - chroma / 2;
  let r2, g2, b2;
  return huePrime >= 0 && huePrime < 1 ? (r2 = chroma, g2 = x2, b2 = 0) : huePrime >= 1 && huePrime < 2 ? (r2 = x2, g2 = chroma, b2 = 0) : huePrime >= 2 && huePrime < 3 ? (r2 = 0, g2 = chroma, b2 = x2) : huePrime >= 3 && huePrime < 4 ? (r2 = 0, g2 = x2, b2 = chroma) : huePrime >= 4 && huePrime < 5 ? (r2 = x2, g2 = 0, b2 = chroma) : (r2 = chroma, g2 = 0, b2 = x2), {
    r: Math.round((r2 + m2) * 255),
    g: Math.round((g2 + m2) * 255),
    b: Math.round((b2 + m2) * 255),
    a: a2 || 1
  };
}
function toRgba$1(color2) {
  return isHexColor(color2) ? hexToRgba(color2) : color2.startsWith("rgb") ? rgbStringToRgba(color2) : color2.startsWith("hsl") ? hslStringToRgba(color2) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function darken(color2, alpha2) {
  if (color2.startsWith("var("))
    return `color-mix(in srgb, ${color2}, black ${alpha2 * 100}%)`;
  const { r: r2, g: g2, b: b2, a: a2 } = toRgba$1(color2), f2 = 1 - alpha2, dark = (input2) => Math.round(input2 * f2);
  return `rgba(${dark(r2)}, ${dark(g2)}, ${dark(b2)}, ${a2})`;
}
function getPrimaryShade(theme, colorScheme) {
  return typeof theme.primaryShade == "number" ? theme.primaryShade : colorScheme === "dark" ? theme.primaryShade.dark : theme.primaryShade.light;
}
function gammaCorrect(c) {
  return c <= 0.03928 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match = oklchColor.match(/oklch\((.*?)%\s/);
  return match ? parseFloat(match[1]) : null;
}
function luminance(color2) {
  if (color2.startsWith("oklch("))
    return (getLightnessFromOklch(color2) || 0) / 100;
  const { r: r2, g: g2, b: b2 } = toRgba$1(color2), sR = r2 / 255, sG = g2 / 255, sB = b2 / 255, rLinear = gammaCorrect(sR), gLinear = gammaCorrect(sG), bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color2, luminanceThreshold = 0.179) {
  return color2.startsWith("var(") ? !1 : luminance(color2) > luminanceThreshold;
}
function parseThemeColor({
  color: color2,
  theme,
  colorScheme
}) {
  if (typeof color2 != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color2}`
    );
  if (color2 === "bright")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (color2 === "dimmed")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6],
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (color2 === "white" || color2 === "black")
    return {
      color: color2,
      value: color2 === "white" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        color2 === "white" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: `--mantine-color-${color2}`
    };
  const [_color, shade] = color2.split("."), colorShade = shade ? Number(shade) : void 0, isThemeColor = _color in theme.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== void 0 ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color: color2,
    value: color2,
    isThemeColor,
    isLight: isLightColor(color2, theme.luminanceThreshold),
    shade: colorShade,
    variable: void 0
  };
}
function getThemeColor(color2, theme) {
  const parsed = parseThemeColor({ color: color2 || theme.primaryColor, theme });
  return parsed.variable ? `var(${parsed.variable})` : color2;
}
function getGradient(gradient, theme) {
  const merged = {
    from: gradient?.from || theme.defaultGradient.from,
    to: gradient?.to || theme.defaultGradient.to,
    deg: gradient?.deg ?? theme.defaultGradient.deg ?? 0
  }, fromColor = getThemeColor(merged.from, theme), toColor = getThemeColor(merged.to, theme);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}
function rgba$2(color2, alpha2) {
  if (typeof color2 != "string" || alpha2 > 1 || alpha2 < 0)
    return "rgba(0, 0, 0, 1)";
  if (color2.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color2}, transparent ${mixPercentage}%)`;
  }
  if (color2.startsWith("oklch"))
    return color2.includes("/") ? color2.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`) : color2.replace(")", ` / ${alpha2})`);
  const { r: r2, g: g2, b: b2 } = toRgba$1(color2);
  return `rgba(${r2}, ${g2}, ${b2}, ${alpha2})`;
}
const alpha$1 = rgba$2, defaultVariantColorsResolver = ({
  color: color2,
  theme,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color: color2, theme }), _autoContrast = typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
  if (variant === "none")
    return {
      background: "transparent",
      hover: "transparent",
      color: "inherit",
      border: "none"
    };
  if (variant === "filled") {
    const textColor = _autoContrast && parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: `var(--mantine-color-${color2}-filled)`,
      hover: `var(--mantine-color-${color2}-filled-hover)`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: color2,
      hover: darken(color2, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: `var(--mantine-color-${color2}-light)`,
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: rgba$2(parsedColor, 0.1),
        hover: rgba$2(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba$2(color2, 0.1),
      hover: rgba$2(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline")
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${color2}-outline-hover)`,
      color: `var(--mantine-color-${color2}-outline)`,
      border: `${rem(1)} solid var(--mantine-color-${color2}-outline)`
    } : {
      background: "transparent",
      hover: rgba$2(theme.colors[parsed.color][parsed.shade], 0.05),
      color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
    } : {
      background: "transparent",
      hover: rgba$2(color2, 0.05),
      color: color2,
      border: `${rem(1)} solid ${color2}`
    };
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba$2(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba$2(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  return variant === "transparent" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${color2}-light-color)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "white" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${color2}-filled)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "gradient" ? {
    background: getGradient(gradient, theme),
    hover: getGradient(gradient, theme),
    color: "var(--mantine-color-white)",
    border: "none"
  } : variant === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${rem(1)} solid var(--mantine-color-default-border)`
  } : {};
}, DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(
      15
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(
      25
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(
      23
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(
      28
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}
function localStorageColorSchemeManager({
  key: key2 = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window > "u")
        return defaultValue;
      try {
        const storedColorScheme = window.localStorage.getItem(key2);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key2, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        event.storageArea === window.localStorage && event.key === key2 && isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
      }, window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key2);
    }
  };
}
const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more  https://mantine.dev/theming/colors/#primary-color", INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  return shade < 0 || shade > 9 ? !1 : parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
  if (!(theme.primaryColor in theme.colors))
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  if (typeof theme.primaryShade == "object" && (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  if (typeof theme.primaryShade == "number" && !isValidPrimaryShade(theme.primaryShade))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
  if (!themeOverride)
    return validateMantineTheme(currentTheme), currentTheme;
  const result = deepMerge(currentTheme, themeOverride);
  return themeOverride.fontFamily && !themeOverride.headings?.fontFamily && (result.headings.fontFamily = themeOverride.fontFamily), validateMantineTheme(result), result;
}
const MantineThemeContext = createContext(null), useSafeMantineTheme = () => useContext(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = useContext(MantineThemeContext);
  if (!ctx)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return ctx;
}
function MantineThemeProvider({
  theme,
  children: children2,
  inherit: inherit2 = !0
}) {
  const parentTheme = useSafeMantineTheme(), mergedTheme = useMemo(
    () => mergeMantineTheme(inherit2 ? parentTheme : DEFAULT_THEME, theme),
    [theme, parentTheme, inherit2]
  );
  return /* @__PURE__ */ jsx(MantineThemeContext.Provider, { value: mergedTheme, children: children2 });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";
function MantineClasses() {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), classes2 = keys(theme.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px"), pxValue = px$1(theme.breakpoints[breakpoint]), maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1), minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: classes2 }
    }
  );
}
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}
function convertCssVariables(input2, selectorOverride) {
  const selectors = selectorOverride ? [selectorOverride] : [":root", ":host"], sharedVariables = cssVariablesObjectToString(input2.variables), shared = sharedVariables ? `${selectors.join(", ")}{${sharedVariables}}` : "", dark = cssVariablesObjectToString(input2.dark), light = cssVariablesObjectToString(input2.light), selectorsWithScheme = (scheme2) => selectors.map(
    (selector3) => selector3 === ":host" ? `${selector3}([data-mantine-color-scheme="${scheme2}"])` : `${selector3}[data-mantine-color-scheme="${scheme2}"]`
  ).join(", "), darkForced = dark ? `${selectorsWithScheme("dark")}{${dark}}` : "", lightForced = light ? `${selectorsWithScheme("light")}{${light}}` : "";
  return `${shared}

${darkForced}

${lightForced}`;
}
function getContrastColor({ color: color2, theme, autoContrast }) {
  return (typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast) && parseThemeColor({ color: color2 || theme.primaryColor, theme }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
  return getContrastColor({
    color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
    theme,
    autoContrast: null
  });
}
function getCSSColorVariables({
  theme,
  color: color2,
  colorScheme,
  name = color2,
  withColorValues = !0
}) {
  if (!theme.colors[color2])
    return {};
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme, "light"), dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha$1(theme.colors[color2][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha$1(theme.colors[color2][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha$1(theme.colors[color2][primaryShade2], 0.05)
    };
    return withColorValues ? {
      [`--mantine-color-${name}-0`]: theme.colors[color2][0],
      [`--mantine-color-${name}-1`]: theme.colors[color2][1],
      [`--mantine-color-${name}-2`]: theme.colors[color2][2],
      [`--mantine-color-${name}-3`]: theme.colors[color2][3],
      [`--mantine-color-${name}-4`]: theme.colors[color2][4],
      [`--mantine-color-${name}-5`]: theme.colors[color2][5],
      [`--mantine-color-${name}-6`]: theme.colors[color2][6],
      [`--mantine-color-${name}-7`]: theme.colors[color2][7],
      [`--mantine-color-${name}-8`]: theme.colors[color2][8],
      [`--mantine-color-${name}-9`]: theme.colors[color2][9],
      ...dynamicVariables2
    } : dynamicVariables2;
  }
  const primaryShade = getPrimaryShade(theme, "dark"), dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha$1(
      theme.colors[color2][Math.max(0, primaryShade - 2)],
      0.15
    ),
    [`--mantine-color-${name}-light-hover`]: alpha$1(
      theme.colors[color2][Math.max(0, primaryShade - 2)],
      0.2
    ),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha$1(
      theme.colors[color2][Math.max(primaryShade - 4, 0)],
      0.05
    )
  };
  return withColorValues ? {
    [`--mantine-color-${name}-0`]: theme.colors[color2][0],
    [`--mantine-color-${name}-1`]: theme.colors[color2][1],
    [`--mantine-color-${name}-2`]: theme.colors[color2][2],
    [`--mantine-color-${name}-3`]: theme.colors[color2][3],
    [`--mantine-color-${name}-4`]: theme.colors[color2][4],
    [`--mantine-color-${name}-5`]: theme.colors[color2][5],
    [`--mantine-color-${name}-6`]: theme.colors[color2][6],
    [`--mantine-color-${name}-7`]: theme.colors[color2][7],
    [`--mantine-color-${name}-8`]: theme.colors[color2][8],
    [`--mantine-color-${name}-9`]: theme.colors[color2][9],
    ...dynamicVariables
  } : dynamicVariables;
}
function isVirtualColor(value) {
  return !!value && typeof value == "object" && "mantine-virtual-color" in value;
}
function assignSizeVariables(variables, sizes2, name) {
  keys(sizes2).forEach(
    (size2) => Object.assign(variables, { [`--mantine-${name}-${size2}`]: sizes2[size2] })
  );
}
const defaultCssVariablesResolver = (theme) => {
  const lightPrimaryShade = getPrimaryShade(theme, "light"), defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius), result = {
    variables: {
      "--mantine-z-index-app": "100",
      "--mantine-z-index-modal": "200",
      "--mantine-z-index-popover": "300",
      "--mantine-z-index-overlay": "400",
      "--mantine-z-index-max": "9999",
      "--mantine-scale": theme.scale.toString(),
      "--mantine-cursor-type": theme.cursorType,
      "--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme.white,
      "--mantine-color-black": theme.black,
      "--mantine-line-height": theme.lineHeights.md,
      "--mantine-font-family": theme.fontFamily,
      "--mantine-font-family-monospace": theme.fontFamilyMonospace,
      "--mantine-font-family-headings": theme.headings.fontFamily,
      "--mantine-heading-font-weight": theme.headings.fontWeight,
      "--mantine-heading-text-wrap": theme.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
    },
    light: {
      "--mantine-color-scheme": "light",
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme.black,
      "--mantine-color-body": theme.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)",
      "--mantine-color-disabled": "var(--mantine-color-gray-2)",
      "--mantine-color-disabled-color": "var(--mantine-color-gray-5)",
      "--mantine-color-disabled-border": "var(--mantine-color-gray-3)"
    },
    dark: {
      "--mantine-color-scheme": "dark",
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)",
      "--mantine-color-disabled": "var(--mantine-color-dark-6)",
      "--mantine-color-disabled-color": "var(--mantine-color-dark-3)",
      "--mantine-color-disabled-border": "var(--mantine-color-dark-4)"
    }
  };
  assignSizeVariables(result.variables, theme.breakpoints, "breakpoint"), assignSizeVariables(result.variables, theme.spacing, "spacing"), assignSizeVariables(result.variables, theme.fontSizes, "font-size"), assignSizeVariables(result.variables, theme.lineHeights, "line-height"), assignSizeVariables(result.variables, theme.shadows, "shadow"), assignSizeVariables(result.variables, theme.radius, "radius"), theme.colors[theme.primaryColor].forEach((_, index2) => {
    result.variables[`--mantine-primary-color-${index2}`] = `var(--mantine-color-${theme.primaryColor}-${index2})`;
  }), keys(theme.colors).forEach((color2) => {
    const value = theme.colors[color2];
    if (isVirtualColor(value)) {
      Object.assign(
        result.light,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        result.dark,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    value.forEach((shade, index2) => {
      result.variables[`--mantine-color-${color2}-${index2}`] = shade;
    }), Object.assign(
      result.light,
      getCSSColorVariables({
        theme,
        color: color2,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      result.dark,
      getCSSColorVariables({
        theme,
        color: color2,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const headings2 = theme.headings.sizes;
  return keys(headings2).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings2[heading].fontSize, result.variables[`--mantine-${heading}-line-height`] = headings2[heading].lineHeight, result.variables[`--mantine-${heading}-font-weight`] = headings2[heading].fontWeight || theme.headings.fontWeight;
  }), result;
};
function getMergedVariables({ theme, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme), providerGenerator = generator?.(theme);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}
const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input2) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  return keys(input2.variables).forEach((key2) => {
    defaultCssVariables.variables[key2] !== input2.variables[key2] && (cleaned.variables[key2] = input2.variables[key2]);
  }), keys(input2.light).forEach((key2) => {
    defaultCssVariables.light[key2] !== input2.light[key2] && (cleaned.light[key2] = input2.light[key2]);
  }), keys(input2.dark).forEach((key2) => {
    defaultCssVariables.dark[key2] !== input2.dark[key2] && (cleaned.dark[key2] = input2.dark[key2]);
  }), cleaned;
}
function getColorSchemeCssVariables(selectorOverride) {
  return convertCssVariables(
    {
      variables: {},
      dark: { "--mantine-color-scheme": "dark" },
      light: { "--mantine-color-scheme": "light" }
    },
    selectorOverride
  );
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), generator = useMantineCssVariablesResolver(), mergedVariables = getMergedVariables({ theme, generator }), shouldCleanVariables = (cssVariablesSelector === void 0 || cssVariablesSelector === ":root" || cssVariablesSelector === ":host") && deduplicateCssVariables, cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables, css2 = convertCssVariables(cleanedVariables, cssVariablesSelector);
  return css2 ? /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: nonce?.(),
      dangerouslySetInnerHTML: {
        __html: `${css2}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
      }
    }
  ) : null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";
function setColorSchemeAttribute(colorScheme, getRootElement2) {
  const hasDarkColorScheme = typeof window < "u" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches, computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
  getRootElement2()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement: getRootElement2,
  forceColorScheme
}) {
  const media = useRef(null), [value, setValue] = useState(() => manager.get(defaultColorScheme)), colorSchemeValue = forceColorScheme || value, setColorScheme = useCallback(
    (colorScheme) => {
      forceColorScheme || (setColorSchemeAttribute(colorScheme, getRootElement2), setValue(colorScheme), manager.set(colorScheme));
    },
    [manager.set, colorSchemeValue, forceColorScheme]
  ), clearColorScheme = useCallback(() => {
    setValue(defaultColorScheme), setColorSchemeAttribute(defaultColorScheme, getRootElement2), manager.clear();
  }, [manager.clear, defaultColorScheme]);
  return useEffect(() => (manager.subscribe(setColorScheme), manager.unsubscribe), [manager.subscribe, manager.unsubscribe]), useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement2);
  }, []), useEffect(() => {
    if (forceColorScheme)
      return setColorSchemeAttribute(forceColorScheme, getRootElement2), () => {
      };
    forceColorScheme === void 0 && setColorSchemeAttribute(value, getRootElement2), typeof window < "u" && "matchMedia" in window && (media.current = window.matchMedia("(prefers-color-scheme: dark)"));
    const listener = (event) => {
      value === "auto" && setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement2);
    };
    return media.current?.addEventListener("change", listener), () => media.current?.removeEventListener("change", listener);
  }, [value, forceColorScheme]), { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement: getRootElement2
}) {
  useIsomorphicEffect(() => {
    respectReducedMotion && getRootElement2()?.setAttribute("data-respect-reduced-motion", "true");
  }, [respectReducedMotion]);
}
function MantineProvider({
  theme,
  children: children2,
  getStyleNonce,
  withStaticClasses = !0,
  withGlobalClasses = !0,
  deduplicateCssVariables = !0,
  withCssVariables = !0,
  cssVariablesSelector,
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement: getRootElement2 = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform,
  env
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement: getRootElement2
  });
  return useRespectReduceMotion({
    respectReducedMotion: theme?.respectReducedMotion || !1,
    getRootElement: getRootElement2
  }), /* @__PURE__ */ jsx(
    MantineContext.Provider,
    {
      value: {
        colorScheme,
        setColorScheme,
        clearColorScheme,
        getRootElement: getRootElement2,
        classNamesPrefix,
        getStyleNonce,
        cssVariablesResolver,
        cssVariablesSelector: cssVariablesSelector ?? ":root",
        withStaticClasses,
        stylesTransform,
        env
      },
      children: /* @__PURE__ */ jsxs(MantineThemeProvider, { theme, children: [
        withCssVariables && /* @__PURE__ */ jsx(
          MantineCssVariables,
          {
            cssVariablesSelector,
            deduplicateCssVariables
          }
        ),
        withGlobalClasses && /* @__PURE__ */ jsx(MantineClasses, {}),
        children2
      ] })
    }
  );
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function useResolvedStylesApi({
  classNames,
  styles,
  props,
  stylesCtx
}) {
  const theme = useMantineTheme();
  return {
    resolvedClassNames: resolveClassNames({
      theme,
      classNames,
      props,
      stylesCtx: stylesCtx || void 0
    }),
    resolvedStyles: resolveStyles({
      theme,
      styles,
      props,
      stylesCtx: stylesCtx || void 0
    })
  };
}
const FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options, unstyled }) {
  return clsx(
    options?.focusable && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]),
    options?.active && !unstyled && theme.activeClassName
  );
}
function getOptionsClassNames({
  selector: selector3,
  stylesCtx,
  options,
  props,
  theme
}) {
  return resolveClassNames({
    theme,
    classNames: options?.classNames,
    props: options?.props || props,
    stylesCtx
  })[selector3];
}
function getResolvedClassNames({
  selector: selector3,
  stylesCtx,
  theme,
  classNames,
  props
}) {
  return resolveClassNames({ theme, classNames, props, stylesCtx })[selector3];
}
function getRootClassName({ rootSelector, selector: selector3, className }) {
  return rootSelector === selector3 ? className : void 0;
}
function getSelectorClassName({ selector: selector3, classes: classes2, unstyled }) {
  return unstyled ? void 0 : classes2[selector3];
}
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector: selector3,
  withStaticClass
}) {
  return withStaticClass === !1 ? [] : themeName.map((n2) => `${classNamesPrefix}-${n2}-${selector3}`);
}
function getThemeClassNames({
  themeName,
  theme,
  selector: selector3,
  props,
  stylesCtx
}) {
  return themeName.map(
    (n2) => resolveClassNames({
      theme,
      classNames: theme.components[n2]?.classNames,
      props,
      stylesCtx
    })?.[selector3]
  );
}
function getVariantClassName({
  options,
  classes: classes2,
  selector: selector3,
  unstyled
}) {
  return options?.variant && !unstyled ? classes2[`${selector3}--${options.variant}`] : void 0;
}
function getClassName({
  theme,
  options,
  themeName,
  selector: selector3,
  classNamesPrefix,
  classNames,
  classes: classes2,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx(
    getGlobalClassNames({ theme, options, unstyled: unstyled || headless }),
    getThemeClassNames({ theme, themeName, selector: selector3, props, stylesCtx }),
    getVariantClassName({ options, classes: classes2, selector: selector3, unstyled }),
    getResolvedClassNames({ selector: selector3, stylesCtx, theme, classNames, props }),
    getResolvedClassNames({ selector: selector3, stylesCtx, theme, classNames: transformedStyles, props }),
    getOptionsClassNames({ selector: selector3, stylesCtx, options, props, theme }),
    getRootClassName({ rootSelector, selector: selector3, className }),
    getSelectorClassName({ selector: selector3, classes: classes2, unstyled: unstyled || headless }),
    withStaticClasses && !headless && getStaticClassNames({
      themeName,
      classNamesPrefix,
      selector: selector3,
      withStaticClass: options?.withStaticClass
    }),
    options?.className
  );
}
function getThemeStyles({
  theme,
  themeName,
  props,
  stylesCtx,
  selector: selector3
}) {
  return themeName.map(
    (n2) => resolveStyles({
      theme,
      styles: theme.components[n2]?.styles,
      props,
      stylesCtx
    })[selector3]
  ).reduce((acc, val) => ({ ...acc, ...val }), {});
}
function resolveStyle({ style: style2, theme }) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme }) }),
    {}
  ) : typeof style2 == "function" ? style2(theme) : style2 ?? {};
}
function mergeVars(vars) {
  return vars.reduce((acc, current2) => (current2 && Object.keys(current2).forEach((key2) => {
    acc[key2] = { ...acc[key2], ...filterProps$1(current2[key2]) };
  }), acc), {});
}
function resolveVars({
  vars,
  varsResolver: varsResolver2,
  theme,
  props,
  stylesCtx,
  selector: selector3,
  themeName,
  headless
}) {
  return mergeVars([
    headless ? {} : varsResolver2?.(theme, props, stylesCtx),
    ...themeName.map((name) => theme.components?.[name]?.vars?.(theme, props, stylesCtx)),
    vars?.(theme, props, stylesCtx)
  ])?.[selector3];
}
function getStyle({
  theme,
  themeName,
  selector: selector3,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style: style2,
  vars,
  varsResolver: varsResolver2,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme, themeName, props, stylesCtx, selector: selector3 }),
    ...!withStylesTransform && resolveStyles({ theme, styles, props, stylesCtx })[selector3],
    ...!withStylesTransform && resolveStyles({ theme, styles: options?.styles, props: options?.props || props, stylesCtx })[selector3],
    ...resolveVars({ theme, props, stylesCtx, vars, varsResolver: varsResolver2, selector: selector3, themeName, headless }),
    ...rootSelector === selector3 ? resolveStyle({ style: style2, theme }) : null,
    ...resolveStyle({ style: options?.style, theme })
  };
}
function useStylesTransform({ props, stylesCtx, themeName }) {
  const theme = useMantineTheme(), stylesTransform = useMantineStylesTransform()?.();
  return {
    getTransformedStyles: (styles) => stylesTransform ? [
      ...styles.map(
        (style2) => stylesTransform(style2, { props, theme, ctx: stylesCtx })
      ),
      ...themeName.map(
        (n2) => stylesTransform(theme.components[n2]?.styles, { props, theme, ctx: stylesCtx })
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!stylesTransform
  };
}
function useStyles({
  name,
  classes: classes2,
  props,
  stylesCtx,
  className,
  style: style2,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars,
  varsResolver: varsResolver2,
  attributes
}) {
  const theme = useMantineTheme(), classNamesPrefix = useMantineClassNamesPrefix(), withStaticClasses = useMantineWithStaticClasses(), headless = useMantineIsHeadless(), themeName = (Array.isArray(name) ? name : [name]).filter((n2) => n2), { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector3, options) => ({
    className: getClassName({
      theme,
      options,
      themeName,
      selector: selector3,
      classNamesPrefix,
      classNames,
      classes: classes2,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options?.styles, styles])
    }),
    style: getStyle({
      theme,
      themeName,
      selector: selector3,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style: style2,
      vars,
      varsResolver: varsResolver2,
      headless,
      withStylesTransform
    }),
    ...attributes?.[selector3]
  });
}
function getAutoContrastValue(autoContrast, theme) {
  return typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
}
function disableTransition(nonce) {
  const style2 = document.createElement("style");
  return style2.setAttribute("data-mantine-styles", "inline"), style2.innerHTML = "*, *::before, *::after {transition: none !important;}", style2.setAttribute("data-mantine-disable-transition", "true"), nonce && style2.setAttribute("nonce", nonce), document.head.appendChild(style2), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((element) => element.remove());
}
function useMantineColorScheme({ keepTransitions } = {}) {
  const clearStylesRef = useRef(noop$4), timeoutRef = useRef(-1), ctx = useContext(MantineContext), nonce = useMantineStyleNonce(), nonceValue = useRef(nonce?.());
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  const setColorScheme = (value) => {
    ctx.setColorScheme(value), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, clearColorScheme = () => {
    ctx.clearColorScheme(), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, osColorScheme = useColorScheme$1("light", { getInitialValueInEffect: !1 }), computedColorScheme = ctx.colorScheme === "auto" ? osColorScheme : ctx.colorScheme, toggleColorScheme = useCallback(
    () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
    [setColorScheme, computedColorScheme]
  );
  return useEffect(
    () => () => {
      clearStylesRef.current?.(), window.clearTimeout(timeoutRef.current);
    },
    []
  ), {
    colorScheme: ctx.colorScheme,
    setColorScheme,
    clearColorScheme,
    toggleColorScheme
  };
}
function useProps(component, defaultProps2, props) {
  const theme = useMantineTheme(), contextPropsPayload = theme.components[component]?.defaultProps, contextProps = typeof contextPropsPayload == "function" ? contextPropsPayload(theme) : contextPropsPayload;
  return { ...defaultProps2, ...contextProps, ...filterProps$1(props) };
}
function cssObjectToString(css2) {
  return keys(css2).reduce(
    (acc, rule) => css2[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css2[rule]};` : acc,
    ""
  ).trim();
}
function stylesToString({ selector: selector3, styles, media, container: container2 }) {
  const baseStyles = styles ? cssObjectToString(styles) : "", mediaQueryStyles = Array.isArray(media) ? media.map((item) => `@media${item.query}{${selector3}{${cssObjectToString(item.styles)}}}`) : [], containerStyles = Array.isArray(container2) ? container2.map(
    (item) => `@container ${item.query}{${selector3}{${cssObjectToString(item.styles)}}}`
  ) : [];
  return `${baseStyles ? `${selector3}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: stylesToString(props) }
    }
  );
}
function extractStyleProps(others) {
  const {
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p: p2,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bdrs,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w: w2,
    miw,
    maw,
    h: h2,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  return { styleProps: filterProps$1({
    m: m2,
    mx,
    my,
    mt,
    mb,
    ml,
    mr,
    me,
    ms,
    p: p2,
    px: px2,
    py,
    pt,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt,
    td,
    w: w2,
    miw,
    maw,
    h: h2,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    bdrs,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  }), rest };
}
const STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bdrs: { type: "radius", property: "borderRadius" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function colorResolver(color2, theme) {
  const parsedColor = parseThemeColor({ color: color2, theme });
  return parsedColor.color === "dimmed" ? "var(--mantine-color-dimmed)" : parsedColor.color === "bright" ? "var(--mantine-color-bright)" : parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color2, theme) {
  const parsedColor = parseThemeColor({ color: color2, theme });
  return parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-text)` : colorResolver(color2, theme);
}
function borderResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const [size2, style2, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size2)}`;
    return style2 && (result += ` ${style2}`), colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`), result.trim();
  }
  return value;
}
const values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  return typeof fontFamily == "string" && fontFamily in values ? values[fontFamily] : fontFamily;
}
const headings$2 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme) {
  return typeof value == "string" && value in theme.fontSizes ? `var(--mantine-font-size-${value})` : typeof value == "string" && headings$2.includes(value) ? `var(--mantine-${value}-font-size)` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function identityResolver(value) {
  return value;
}
const headings$1 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme) {
  return typeof value == "string" && value in theme.lineHeights ? `var(--mantine-line-height-${value})` : typeof value == "string" && headings$1.includes(value) ? `var(--mantine-${value}-line-height)` : value;
}
function radiusResolver(value, theme) {
  return typeof value == "string" && value in theme.radius ? `var(--mantine-radius-${value})` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function sizeResolver(value) {
  return typeof value == "number" ? rem(value) : value;
}
function spacingResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme.spacing))
      return rem(value);
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}
const resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  radius: radiusResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const sortedMedia = Object.keys(media).sort((a2, b2) => Number(replaceMediaQuery(a2)) - Number(replaceMediaQuery(b2))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp != "object" || styleProp === null)
    return !1;
  const breakpoints = Object.keys(styleProp);
  return !(breakpoints.length === 1 && breakpoints[0] === "base");
}
function getBaseValue(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getBreakpointKeys(value) {
  return typeof value == "object" && value !== null ? keys(value).filter((key2) => key2 !== "base") : [];
}
function getBreakpointValue(value, breakpoint) {
  return typeof value == "object" && value !== null && breakpoint in value ? value[breakpoint] : value;
}
function parseStyleProps({
  styleProps,
  data,
  theme
}) {
  return sortMediaQueries(
    keys(styleProps).reduce(
      (acc, styleProp) => {
        if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx")
          return acc;
        const propertyData = data[styleProp], properties2 = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property], baseValue = getBaseValue(styleProps[styleProp]);
        if (!hasResponsiveStyles(styleProps[styleProp]))
          return properties2.forEach((property) => {
            acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
          }), acc;
        acc.hasResponsiveStyles = !0;
        const breakpoints = getBreakpointKeys(styleProps[styleProp]);
        return properties2.forEach((property) => {
          baseValue != null && (acc.styles[property] = resolvers[propertyData.type](baseValue, theme)), breakpoints.forEach((breakpoint) => {
            const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
            acc.media[bp] = {
              ...acc.media[bp],
              [property]: resolvers[propertyData.type](
                getBreakpointValue(styleProps[styleProp], breakpoint),
                theme
              )
            };
          });
        }), acc;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function useRandomClassName() {
  return `__m__-${useId$3().replace(/[:]/g, "")}`;
}
function getStyleObject(style2, theme) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...getStyleObject(item, theme) }),
    {}
  ) : typeof style2 == "function" ? style2(theme) : style2 ?? {};
}
function transformModKey(key2) {
  return key2.startsWith("data-") ? key2 : `data-${key2}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key2) => {
    const value = props[key2];
    return value === void 0 || value === "" || value === !1 || value === null || (acc[transformModKey(key2)] = props[key2]), acc;
  }, {});
}
function getBoxMod(mod) {
  return mod ? typeof mod == "string" ? { [transformModKey(mod)]: !0 } : Array.isArray(mod) ? [...mod].reduce(
    (acc, value) => ({ ...acc, ...getBoxMod(value) }),
    {}
  ) : getMod(mod) : null;
}
function mergeStyles(styles, theme) {
  return Array.isArray(styles) ? [...styles].reduce(
    (acc, item) => ({ ...acc, ...mergeStyles(item, theme) }),
    {}
  ) : typeof styles == "function" ? styles(theme) : styles ?? {};
}
function getBoxStyle$1({
  theme,
  style: style2,
  vars,
  styleProps
}) {
  const _style = mergeStyles(style2, theme), _vars = mergeStyles(vars, theme);
  return { ..._style, ..._vars, ...styleProps };
}
const _Box = forwardRef(
  ({
    component,
    style: style2,
    __vars,
    className,
    variant,
    mod,
    size: size2,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    renderRoot,
    __size,
    ...others
  }, ref) => {
    const theme = useMantineTheme(), Element2 = component || "div", { styleProps, rest } = extractStyleProps(others), transformedSx = useMantineSxTransform()?.()?.(styleProps.sx), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
      styleProps,
      theme,
      data: STYlE_PROPS_DATA
    }), props = {
      ref,
      style: getBoxStyle$1({
        theme,
        style: style2,
        vars: __vars,
        styleProps: parsedStyleProps.inlineStyles
      }),
      className: clsx(className, transformedSx, {
        [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
        "mantine-light-hidden": lightHidden,
        "mantine-dark-hidden": darkHidden,
        [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
        [`mantine-visible-from-${visibleFrom}`]: visibleFrom
      }),
      "data-variant": variant,
      "data-size": isNumberLike(size2) ? void 0 : size2 || void 0,
      size: __size,
      ...getBoxMod(mod),
      ...rest
    };
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
        InlineStyles,
        {
          selector: `.${responsiveClassName}`,
          styles: parsedStyleProps.styles,
          media: parsedStyleProps.media
        }
      ),
      typeof renderRoot == "function" ? renderRoot(props) : /* @__PURE__ */ jsx(Element2, { ...props })
    ] });
  }
);
_Box.displayName = "@mantine/core/Box";
const Box$1 = _Box;
function identity(value) {
  return value;
}
function getWithProps(Component2) {
  const _Component = Component2;
  return (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(_Component, { ...fixedProps, ...props, ref }));
    return Extended.extend = _Component.extend, Extended.displayName = `WithProps(${_Component.displayName})`, Extended;
  };
}
function factory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.extend = identity, Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2;
}
function polymorphicFactory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2.extend = identity, Component2;
}
const DirectionContext = createContext({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return useContext(DirectionContext);
}
function getAutoHeightDuration(height) {
  if (!height || typeof height == "string")
    return 0;
  const constant2 = height / 36;
  return Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10);
}
function getElementHeight(el) {
  return el?.current ? el.current.scrollHeight : "auto";
}
const raf = typeof window < "u" && window.requestAnimationFrame, collapsedHeight = 0, getCollapsedStyles = (keepMounted) => ({
  height: 0,
  overflow: "hidden",
  ...keepMounted ? {} : { display: "none" }
});
function useCollapse({
  transitionDuration,
  transitionTimingFunction = "ease",
  onTransitionEnd = () => {
  },
  opened,
  keepMounted = !1
}) {
  const el = useRef(null), collapsedStyles = getCollapsedStyles(keepMounted), [styles, setStylesRaw] = useState(opened ? {} : collapsedStyles), setStyles = (newStyles) => {
    flushSync(() => setStylesRaw(newStyles));
  }, mergeStyles2 = (newStyles) => {
    setStyles((oldStyles) => ({ ...oldStyles, ...newStyles }));
  };
  function getTransitionStyles2(height) {
    const _duration = transitionDuration || getAutoHeightDuration(height);
    return {
      transition: `height ${_duration}ms ${transitionTimingFunction}, opacity ${_duration}ms ${transitionTimingFunction}`
    };
  }
  useDidUpdate(() => {
    typeof raf == "function" && raf(opened ? () => {
      mergeStyles2({ willChange: "height", display: "block", overflow: "hidden" }), raf(() => {
        const height = getElementHeight(el);
        mergeStyles2({ ...getTransitionStyles2(height), height });
      });
    } : () => {
      const height = getElementHeight(el);
      mergeStyles2({ ...getTransitionStyles2(height), willChange: "height", height }), raf(() => mergeStyles2({ height: collapsedHeight, overflow: "hidden" }));
    });
  }, [opened]);
  const handleTransitionEnd = (e2) => {
    if (!(e2.target !== el.current || e2.propertyName !== "height"))
      if (opened) {
        const height = getElementHeight(el);
        height === styles.height ? setStyles({}) : mergeStyles2({ height }), onTransitionEnd();
      } else styles.height === collapsedHeight && (setStyles(collapsedStyles), onTransitionEnd());
  };
  function getCollapseProps({ style: style2 = {}, refKey = "ref", ...rest } = {}) {
    const theirRef = rest[refKey], props = {
      "aria-hidden": !opened,
      ...rest,
      [refKey]: mergeRefs(el, theirRef),
      onTransitionEnd: handleTransitionEnd,
      style: { boxSizing: "border-box", ...style2, ...styles }
    };
    return React__default.version.startsWith("18") ? opened || (props.inert = "") : props.inert = !opened, props;
  }
  return getCollapseProps;
}
const defaultProps$L = {
  transitionDuration: 200,
  transitionTimingFunction: "ease",
  animateOpacity: !0
}, Collapse = factory((props, ref) => {
  const {
    children: children2,
    in: opened,
    transitionDuration,
    transitionTimingFunction,
    style: style2,
    onTransitionEnd,
    animateOpacity,
    keepMounted,
    ...others
  } = useProps("Collapse", defaultProps$L, props), theme = useMantineTheme(), shouldReduceMotion = useReducedMotion$1(), duration = (theme.respectReducedMotion ? shouldReduceMotion : !1) ? 0 : transitionDuration, getCollapseProps = useCollapse({
    opened,
    transitionDuration: duration,
    transitionTimingFunction,
    onTransitionEnd,
    keepMounted
  });
  return duration === 0 ? opened ? /* @__PURE__ */ jsx(Box$1, { ...others, children: children2 }) : null : /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getCollapseProps({
        style: {
          opacity: opened || !animateOpacity ? 1 : 0,
          transition: animateOpacity ? `opacity ${duration}ms ${transitionTimingFunction}` : "none",
          ...getStyleObject(style2, theme)
        },
        ref,
        ...others
      }),
      children: children2
    }
  );
});
Collapse.displayName = "@mantine/core/Collapse";
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node2) {
  return isNode(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement$1(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector3) => {
    try {
      return element.matches(selector3);
    } catch {
      return !1;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"], willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"], containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css2 = isElement(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css2[value] ? css2[value] !== "none" : !1) || (css2.containerType ? css2.containerType !== "normal" : !1) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : !1) || !webkit && (css2.filter ? css2.filter !== "none" : !1) || willChangeValues.some((value) => (css2.willChange || "").includes(value)) || containValues.some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node2) {
  return lastTraversableNodeNames.has(getNodeName(node2));
}
function getComputedStyle$2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement$1(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win2 = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win2);
    return list2.concat(win2, win2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win2) {
  return win2.parent && Object.getPrototypeOf(win2.parent) ? win2.frameElement : null;
}
const sides = ["top", "right", "bottom", "left"], alignments = ["start", "end"], placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []), min$1 = Math.min, max$1 = Math.max, round = Math.round, floor = Math.floor, createCoords = (v2) => ({
  x: v2,
  y: v2
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$2(start2, value, end) {
  return max$1(start2, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rlPlacement : lrPlacement : isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list2 = list2.map((side) => side + "-" + alignment), flipAlignment && (list2 = list2.concat(list2.map(getOppositeAlignmentPlacement)))), list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {
    let {
      brand,
      version: version2
    } = _ref;
    return brand + "/" + version2;
  }).join(" ") : navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
const FOCUSABLE_ATTRIBUTE$1 = "data-floating-ui-focusable", TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  for (; ((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null; ) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child)
    return !1;
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
function isEventTargetWithin(event, node2) {
  if (node2 == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node2);
  const e2 = event;
  return e2.target != null && node2.contains(e2.target);
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node2) {
  return node2?.ownerDocument || document;
}
function isTypeableElement(element) {
  return isHTMLElement$1(element) && element.matches(TYPEABLE_SELECTOR);
}
function matchesFocusVisible(element) {
  if (!element || isJSDOM()) return !0;
  try {
    return element.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function getFloatingFocusElement(floatingElement) {
  return floatingElement ? floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE$1) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE$1 + "]") || floatingElement : null;
}
function getNodeChildren(nodes, id2, onlyOpenChildren) {
  return onlyOpenChildren === void 0 && (onlyOpenChildren = !0), nodes.filter((node2) => {
    var _node$context;
    return node2.parentId === id2 && (!onlyOpenChildren || ((_node$context = node2.context) == null ? void 0 : _node$context.open));
  }).flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  return values2.push("", void 0), values2.includes(pointerType);
}
var isClient$1 = typeof document < "u", noop$3 = function() {
}, index$2 = isClient$1 ? useLayoutEffect : noop$3;
const SafeReact$1 = {
  ...React
};
function useLatestRef$1(value) {
  const ref = React.useRef(value);
  return index$2(() => {
    ref.current = value;
  }), ref;
}
const useInsertionEffect = SafeReact$1.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
  });
  return useSafeInsertionEffect(() => {
    ref.current = callback;
  }), React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x: x2,
      y: y2
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = min$1(paddingObject[minProp], largestPossiblePadding), maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding), min$1$1 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp$2(min$1$1, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  return (alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement)).filter((placement) => alignment ? getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : !1) : !0);
}
const autoPlacement$1 = function(options) {
  return options === void 0 && (options = {}), {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state, {
        crossAxis = !1,
        alignment,
        allowedPlacements = placements,
        autoAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state), placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements, overflow = await detectOverflow(state, detectOverflowOptions), currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0, currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null)
        return {};
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement)
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]], allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }], nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement)
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      const placementsSortedByMostSpace = allOverflows.map((d2) => {
        const alignment2 = getAlignment(d2.placement);
        return [d2.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
        ) : (
          // Check only the mainAxis.
          d2.overflows[0]
        ), d2.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]), resetPlacement = ((_placementsThatFitOnE = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d2[0]) ? 2 : 3
      ).every((v2) => v2 <= 0))[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      return resetPlacement !== placement ? {
        data: {
          index: currentIndex + 1,
          overflows: allOverflows
        },
        reset: {
          placement: resetPlacement
        }
      } : {};
    }
  };
}, flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements2 = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements2[nextIndex];
        if (nextPlacement && (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : !0)))
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state, {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          }), offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: !0
          }), offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min$1(...rects.map((rect) => rect.left)), minY = min$1(...rects.map((rect) => rect.top)), maxX = max$1(...rects.map((rect) => rect.right)), maxY = max$1(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y), groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect), prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state, {
        padding = 2,
        x: x2,
        y: y2
      } = evaluate(options, state), nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []), clientRects = getRectsByLine(nativeClientRects), fallback = rectToClientRect(getBoundingRect(nativeClientRects)), paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null)
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0], lastRect = clientRects[clientRects.length - 1], isTop = getSide(placement) === "top", top2 = firstRect.top, bottom2 = lastRect.bottom, left2 = isTop ? firstRect.left : lastRect.left, right2 = isTop ? firstRect.right : lastRect.right, width2 = right2 - left2, height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left", maxRight = max$1(...clientRects.map((rect) => rect.right)), minLeft = min$1(...clientRects.map((rect) => rect.left)), measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight), top = measureRects[0].top, bottom = measureRects[measureRects.length - 1].bottom, left = minLeft, right = maxRight, width = right - left, height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      return rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height ? {
        reset: {
          rects: resetRects
        }
      } : {};
    }
  };
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = originSides.has(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = originSides.has(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x && (availableWidth = maximumClippingWidth), (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y && (availableHeight = maximumClippingHeight), noShift && !alignment) {
        const xMin = max$1(overflow.left, 0), xMax = max$1(overflow.right, 0), yMin = max$1(overflow.top, 0), yMax = max$1(overflow.bottom, 0);
        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element) {
  const css2 = getComputedStyle$2(element);
  let width = parseFloat(css2.width) || 0, height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement$1(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width, y2 = ($ ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win2 = getWindow(element);
  return !isWebKit() || !win2.visualViewport ? noOffsets : {
    x: win2.visualViewport.offsetLeft,
    y: win2.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale2 = getScale(offsetParent)) : scale2 = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x, y2 = (clientRect.top + visualOffsets.y) / scale2.y, width = clientRect.width / scale2.x, height = clientRect.height / scale2.y;
  if (domElement) {
    const win2 = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win2, currentIFrame = getFrameElement(currentWin);
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css2 = getComputedStyle$2(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect(), x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect), y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale2 = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement$1(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale2 = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element), scroll = getNodeScroll(element), body2 = element.ownerDocument.body, width = max$1(html.scrollWidth, html.clientWidth, body2.scrollWidth, body2.clientWidth), height = max$1(html.scrollHeight, html.clientHeight, body2.scrollHeight, body2.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$2(body2).direction === "rtl" && (x2 += max$1(html.clientWidth, body2.clientWidth) - width), {
    width,
    height,
    x: x2,
    y: y2
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win2 = getWindow(element), html = getDocumentElement(element), visualViewport = win2.visualViewport;
  let width = html.clientWidth, height = html.clientHeight, x2 = 0, y2 = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument, body2 = doc.body, bodyStyles = getComputedStyle(body2), bodyMarginInline = doc.compatMode === "CSS1Compat" && parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0, clippingStableScrollbarWidth = Math.abs(html.clientWidth - body2.clientWidth - bodyMarginInline);
    clippingStableScrollbarWidth <= SCROLLBAR_MAX && (width -= clippingStableScrollbarWidth);
  } else windowScrollbarX <= SCROLLBAR_MAX && (width += windowScrollbarX);
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale2 = isHTMLElement$1(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale2.x, height = element.clientHeight * scale2.y, x2 = left * scale2.x, y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$2(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache2.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max$1(rect.top, accRect.top), accRect.right = min$1(rect.right, accRect.right), accRect.bottom = min$1(rect.bottom, accRect.bottom), accRect.left = max$1(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && setLeftRTLScrollbarOffset();
  isFixed && !isOffsetParentAnElement && documentElement && setLeftRTLScrollbarOffset();
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0), x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x, y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed")
    return null;
  if (polyfill)
    return polyfill(element);
  let rawOffsetParent = element.offsetParent;
  return getDocumentElement(element) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body), rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win2 = getWindow(element);
  if (isTopLayer(element))
    return win2;
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win2 : offsetParent || getContainingBlock(element) || win2;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$2(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect(), {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left + width)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect()) && refresh(), isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo?.(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const offset$1 = offset$2, autoPlacement = autoPlacement$1, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, arrow$2 = arrow$3, inline$1 = inline$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document < "u", noop$2 = function() {
}, index$1 = isClient ? useLayoutEffect : noop$2;
function deepEqual(a2, b2) {
  if (a2 === b2)
    return !0;
  if (typeof a2 != typeof b2)
    return !1;
  if (typeof a2 == "function" && a2.toString() === b2.toString())
    return !0;
  let length, i2, keys2;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      if (length = a2.length, length !== b2.length) return !1;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual(a2[i2], b2[i2]))
          return !1;
      return !0;
    }
    if (keys2 = Object.keys(a2), length = keys2.length, length !== Object.keys(b2).length)
      return !1;
    for (i2 = length; i2-- !== 0; )
      if (!{}.hasOwnProperty.call(b2, keys2[i2]))
        return !1;
    for (i2 = length; i2-- !== 0; ) {
      const key2 = keys2[i2];
      if (!(key2 === "_owner" && a2.$$typeof) && !deepEqual(a2[key2], b2[key2]))
        return !1;
    }
    return !0;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  return index$1(() => {
    ref.current = value;
  }), ref;
}
function useFloating$1(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = !0,
    whileElementsMounted,
    open
  } = options, [data, setData2] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node2) => {
    node2 !== referenceRef.current && (referenceRef.current = node2, _setReference(node2));
  }, []), setFloating = React.useCallback((node2) => {
    node2 !== floatingRef.current && (floatingRef.current = node2, _setFloating(node2));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef(whileElementsMounted), platformRef = useLatestRef(platform2), openRef = useLatestRef(open), update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData2(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData2((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index$1(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index$1(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x2 = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);
    return transform2 ? {
      ...initialStyles,
      transform: "translate(" + x2 + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options == "function" ? options(state) : options;
      return element && isRef(element) ? element.current != null ? arrow$2({
        element: element.current,
        padding
      }).fn(state) : {} : element ? arrow$2({
        element,
        padding
      }).fn(state) : {};
    }
  };
}, offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
}), inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
}), arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
function useMergeRefs(refs) {
  const cleanupRef = React.useRef(void 0), refEffect = React.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref != null) {
        if (typeof ref == "function") {
          const refCallback = ref, refCleanup = refCallback(instance);
          return typeof refCleanup == "function" ? refCleanup : () => {
            refCallback(null);
          };
        }
        return ref.current = instance, () => {
          ref.current = null;
        };
      }
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup?.());
    };
  }, refs);
  return React.useMemo(() => refs.every((ref) => ref == null) ? null : (value) => {
    cleanupRef.current && (cleanupRef.current(), cleanupRef.current = void 0), value != null && (cleanupRef.current = refEffect(value));
  }, refs);
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable", ACTIVE_KEY = "active", SELECTED_KEY = "selected", SafeReact = {
  ...React
};
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index$2(() => {
    id2 == null && setId(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), id2;
}
const useReactId = SafeReact.useId, useId$1 = useReactId || useFloatingId;
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      map.has(event) || map.set(event, /* @__PURE__ */ new Set()), map.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function clearTimeoutIfSet(timeoutRef) {
  timeoutRef.current !== -1 && (clearTimeout(timeoutRef.current), timeoutRef.current = -1);
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType))
    return 0;
  if (typeof value == "number")
    return value;
  if (typeof value == "function") {
    const result = value();
    return typeof result == "number" ? result : result?.[prop];
  }
  return value?.[prop];
}
function getRestMs(value) {
  return typeof value == "function" ? value() : value;
}
function useHover(context2, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context2, {
    enabled = !0,
    delay: delay2 = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree(), parentId = useFloatingParentNodeId(), handleCloseRef = useLatestRef$1(handleClose), delayRef = useLatestRef$1(delay2), openRef = useLatestRef$1(open), restMsRef = useLatestRef$1(restMs), pointerTypeRef = React.useRef(), timeoutRef = React.useRef(-1), handlerRef = React.useRef(), restTimeoutRef = React.useRef(-1), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = useEffectEvent(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return type?.includes("mouse") && type !== "mousedown";
  });
  React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      open2 || (clearTimeoutIfSet(timeoutRef), clearTimeoutIfSet(restTimeoutRef), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html = getDocument(elements.floating).documentElement;
    return html.addEventListener("mouseleave", onLeave), () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback(function(event, runElseBranch, reason) {
    runElseBranch === void 0 && (runElseBranch = !0), reason === void 0 && (reason = "hover");
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? (clearTimeoutIfSet(timeoutRef), timeoutRef.current = window.setTimeout(() => onOpenChange(!1, event, reason), closeDelay)) : runElseBranch && (clearTimeoutIfSet(timeoutRef), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange]), cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body2 = getDocument(elements.floating).body;
      body2.style.pointerEvents = "", body2.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEffectEvent(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled) return;
    function onReferenceMouseEnter(event) {
      if (clearTimeoutIfSet(timeoutRef), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeoutRef.current = window.setTimeout(() => {
        openRef.current || onOpenChange(!0, event, "hover");
      }, openDelay) : open || onOpenChange(!0, event, "hover");
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (clearTimeoutIfSet(restTimeoutRef), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || clearTimeoutIfSet(timeoutRef), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current !== "touch" || !contains(elements.floating, event.relatedTarget)) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      isClickLikeOpenEvent() || dataRef.current.floatingContext && (handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event, !1);
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference, floating = elements.floating;
      return open && reference2.addEventListener("mouseleave", onScrollMouseLeave), move && reference2.addEventListener("mousemove", onReferenceMouseEnter, {
        once: !0
      }), reference2.addEventListener("mouseenter", onReferenceMouseEnter), reference2.addEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.addEventListener("mouseleave", onScrollMouseLeave), floating.addEventListener("mouseenter", onFloatingMouseEnter), floating.addEventListener("mouseleave", onFloatingMouseLeave)), () => {
        open && reference2.removeEventListener("mouseleave", onScrollMouseLeave), move && reference2.removeEventListener("mousemove", onReferenceMouseEnter), reference2.removeEventListener("mouseenter", onReferenceMouseEnter), reference2.removeEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.removeEventListener("mouseleave", onScrollMouseLeave), floating.removeEventListener("mouseenter", onFloatingMouseEnter), floating.removeEventListener("mouseleave", onFloatingMouseLeave));
      };
    }
  }, [elements, enabled, context2, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]), index$2(() => {
    var _handleCloseRef$curre;
    if (enabled && open && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body2 = getDocument(elements.floating).body;
        body2.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body2.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body2.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), index$2(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), clearTimeoutIfSet(timeoutRef), clearTimeoutIfSet(restTimeoutRef), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || getRestMs(restMsRef.current) === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (clearTimeoutIfSet(restTimeoutRef), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current))));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const NOOP = () => {
}, FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: !1
}), useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children: children2,
    delay: delay2,
    timeoutMs = 0
  } = props, [state, setState] = React.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay: delay2,
    timeoutMs,
    initialDelay: delay2,
    currentId: null,
    isInstantPhase: !1
  }), initialCurrentIdRef = React.useRef(null), setCurrentId = React.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  return index$2(() => {
    state.currentId ? initialCurrentIdRef.current === null ? initialCurrentIdRef.current = state.currentId : state.isInstantPhase || setState({
      isInstantPhase: !0
    }) : (state.isInstantPhase && setState({
      isInstantPhase: !1
    }), initialCurrentIdRef.current = null);
  }, [state.currentId, state.isInstantPhase]), /* @__PURE__ */ jsx(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId]),
    children: children2
  });
}
function useDelayGroup(context2, options) {
  options === void 0 && (options = {});
  const {
    open,
    onOpenChange,
    floatingId
  } = context2, {
    id: optionId,
    enabled = !0
  } = options, id2 = optionId ?? floatingId, groupContext = useDelayGroupContext(), {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  return index$2(() => {
    enabled && currentId && (setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    }), currentId !== id2 && onOpenChange(!1));
  }, [enabled, id2, onOpenChange, setState, currentId, initialDelay]), index$2(() => {
    function unset() {
      onOpenChange(!1), setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (enabled && currentId && !open && currentId === id2) {
      if (timeoutMs) {
        const timeout2 = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout2);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id2, onOpenChange, initialDelay, timeoutMs]), index$2(() => {
    enabled && (setCurrentId === NOOP || !open || setCurrentId(id2));
  }, [enabled, open, setCurrentId, id2]), groupContext;
}
const bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (_normalizable$escapeK = normalizable?.escapeKey) != null ? _normalizable$escapeK : !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (_normalizable$outside = normalizable?.outsidePress) != null ? _normalizable$outside : !0
  };
};
function useDismiss(context2, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context2, {
    enabled = !0,
    escapeKey = !0,
    outsidePress: unstable_outsidePress = !0,
    outsidePressEvent = "pointerdown",
    referencePress = !1,
    referencePressEvent = "pointerdown",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree(), outsidePressFn = useEffectEvent(typeof unstable_outsidePress == "function" ? unstable_outsidePress : () => !1), outsidePress = typeof unstable_outsidePress == "function" ? outsidePressFn : unstable_outsidePress, endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), isComposingRef = React.useRef(!1), closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId, children2 = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children2.length > 0)) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context;
        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event), (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = dataRef.current.insideReactTree;
    dataRef.current.insideReactTree = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, outsidePressEvent === "click" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = "[" + createAttribute("inert") + "]", markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement$1(target) && floating) {
      const lastTraversableNode = isLastTraversableNode(target), style2 = getComputedStyle$2(target), scrollRe = /auto|scroll/, isScrollableX = lastTraversableNode || scrollRe.test(style2.overflowX), isScrollableY = lastTraversableNode || scrollRe.test(style2.overflowY), canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight, isRTL2 = style2.direction === "rtl", pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth), pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar)
        return;
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId, targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node2) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node2.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children2 = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children2.length > 0) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event), (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    escapeKey && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      escapeKey && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]), React.useEffect(() => {
    dataRef.current.insideReactTree = !1;
  }, [dataRef, outsidePress, outsidePressEvent]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(!1, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "click" && {
        onClick(event) {
          onOpenChange(!1, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = !0;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = !0;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      dataRef.current.insideReactTree = !0;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent, dataRef]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId$1(), dataRef = React.useRef({}), [events] = React.useState(() => createEventEmitter()), nested = useFloatingParentNodeId() != null, [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0, events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    }), onOpenChangeProp?.(open2, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = computedElements?.domReference || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  index$2(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      getClientRects: () => node2.getClientRects(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference), position.refs.setReference(computedPositionReference);
  }, [position.refs]), setReference = React.useCallback((node2) => {
    (isElement(node2) || node2 === null) && (domReferenceRef.current = node2, setDomReference(node2)), (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) && position.refs.setReference(node2);
  }, [position.refs]), refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]), context2 = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  return index$2(() => {
    rootContext.dataRef.current.floatingContext = context2;
    const node2 = tree?.nodesRef.current.find((node22) => node22.id === nodeId);
    node2 && (node2.context = context2);
  }), React.useMemo(() => ({
    ...position,
    context: context2,
    refs,
    elements
  }), [position, refs, elements, context2]);
}
function isMacSafari() {
  return isMac() && isSafari();
}
function useFocus(context2, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context2, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeoutRef = React.useRef(-1), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled) return;
    const win2 = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement$1(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    function onPointerDown2() {
      keyboardModalityRef.current = !1;
    }
    return win2.addEventListener("blur", onBlur), isMacSafari() && (win2.addEventListener("keydown", onKeyDown, !0), win2.addEventListener("pointerdown", onPointerDown2, !0)), () => {
      win2.removeEventListener("blur", onBlur), isMacSafari() && (win2.removeEventListener("keydown", onKeyDown, !0), win2.removeEventListener("pointerdown", onPointerDown2, !0));
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]), React.useEffect(() => () => {
    clearTimeoutIfSet(timeoutRef);
  }, []);
  const reference = React.useMemo(() => ({
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        if (isMacSafari() && !event.relatedTarget) {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        } else if (!matchesFocusVisible(target))
          return;
      }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map(), isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      return typeof propsOrGetProps == "function" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {
      let [key2, value] = _ref;
      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key2)))
        if (key2.indexOf("on") === 0) {
          if (map.has(key2) || map.set(key2, []), typeof value == "function") {
            var _map$get;
            (_map$get = map.get(key2)) == null || _map$get.push(value), acc[key2] = function() {
              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (_map$get2 = map.get(key2)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else
          acc[key2] = value;
    }), acc), {})
  };
}
function useInteractions(propsList) {
  propsList === void 0 && (propsList = []);
  const referenceDeps = propsList.map((key2) => key2?.reference), floatingDeps = propsList.map((key2) => key2?.floating), itemDeps = propsList.map((key2) => key2?.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function useRole(context2, props) {
  var _elements$domReferenc, _componentRoleToAriaR;
  props === void 0 && (props = {});
  const {
    open,
    elements,
    floatingId: defaultFloatingId
  } = context2, {
    enabled = !0,
    role = "dialog"
  } = props, defaultReferenceId = useId$1(), referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId, floatingId = React.useMemo(() => {
    var _getFloatingFocusElem;
    return ((_getFloatingFocusElem = getFloatingFocusElement(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
  }, [elements.floating, defaultFloatingId]), ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role, isNested = useFloatingParentNodeId() != null, reference = React.useMemo(() => ariaRole === "tooltip" || role === "label" ? {
    ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
  } : {
    "aria-expanded": open ? "true" : "false",
    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
    "aria-controls": open ? floatingId : void 0,
    ...ariaRole === "listbox" && {
      role: "combobox"
    },
    ...ariaRole === "menu" && {
      id: referenceId
    },
    ...ariaRole === "menu" && isNested && {
      role: "menuitem"
    },
    ...role === "select" && {
      "aria-autocomplete": "none"
    },
    ...role === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [ariaRole, floatingId, isNested, open, referenceId, role]), floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    return ariaRole === "tooltip" || role === "label" ? floatingProps : {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]), item = React.useCallback((_ref) => {
    let {
      active,
      selected: selected2
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-fui-option"
      }
    };
    switch (role) {
      case "select":
      case "combobox":
        return {
          ...commonProps,
          "aria-selected": selected2
        };
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext$1(
  "ScrollArea.Root component was not found in tree"
);
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef$1(onResize);
  useIsomorphicEffect(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize);
      });
      return resizeObserver.observe(element), () => {
        window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
const Corner = forwardRef((props, ref) => {
  const { style: style2, ...others } = props, ctx = useScrollAreaContext(), [width, setWidth] = useState(0), [height, setHeight] = useState(0), hasSize = !!(width && height);
  return useResizeObserver(ctx.scrollbarX, () => {
    const h2 = ctx.scrollbarX?.offsetHeight || 0;
    ctx.onCornerHeightChange(h2), setHeight(h2);
  }), useResizeObserver(ctx.scrollbarY, () => {
    const w2 = ctx.scrollbarY?.offsetWidth || 0;
    ctx.onCornerWidthChange(w2), setWidth(w2);
  }), hasSize ? /* @__PURE__ */ jsx("div", { ...others, ref, style: { ...style2, width, height } }) : null;
}), ScrollAreaCorner = forwardRef((props, ref) => {
  const ctx = useScrollAreaContext(), hasBothScrollbarsVisible = !!(ctx.scrollbarX && ctx.scrollbarY);
  return ctx.type !== "scroll" && hasBothScrollbarsVisible ? /* @__PURE__ */ jsx(Corner, { ...props, ref }) : null;
}), defaultProps$K = {
  scrollHideDelay: 1e3,
  type: "hover"
}, ScrollAreaRoot = forwardRef((_props, ref) => {
  const { type, scrollHideDelay, scrollbars, getStyles: getStyles2, ...others } = useProps(
    "ScrollAreaRoot",
    defaultProps$K,
    _props
  ), [scrollArea2, setScrollArea] = useState(null), [viewport, setViewport2] = useState(null), [content, setContent] = useState(null), [scrollbarX, setScrollbarX] = useState(null), [scrollbarY, setScrollbarY] = useState(null), [cornerWidth, setCornerWidth] = useState(0), [cornerHeight, setCornerHeight] = useState(0), [scrollbarXEnabled, setScrollbarXEnabled] = useState(!1), [scrollbarYEnabled, setScrollbarYEnabled] = useState(!1), rootRef = useMergedRef(ref, (node2) => setScrollArea(node2));
  return /* @__PURE__ */ jsx(
    ScrollAreaProvider,
    {
      value: {
        type,
        scrollHideDelay,
        scrollArea: scrollArea2,
        viewport,
        onViewportChange: setViewport2,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box$1,
        {
          ...others,
          ref: rootRef,
          __vars: {
            "--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
            "--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
          }
        }
      )
    }
  );
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes2) {
  const ratio = getThumbRatio(sizes2.viewport, sizes2.content), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, thumbSize = (sizes2.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function linearScale(input2, output) {
  return (value) => {
    if (input2[0] === input2[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input2[1] - input2[0]);
    return output[0] + ratio * (value - input2[0]);
  };
}
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, scrollbar = sizes2.scrollbar.size - scrollbarPadding, maxScrollPos = sizes2.content - sizes2.viewport, maxThumbPos = scrollbar - thumbSizePx, scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0], scrollWithoutMomentum = clamp$1(scrollPos, scrollClampRange);
  return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), thumbCenter = thumbSizePx / 2, offset2 = pointerOffset || thumbCenter, thumbOffsetFromEnd = thumbSizePx - offset2, minPointerPos = sizes2.scrollbar.paddingStart + offset2, maxPointerPos = sizes2.scrollbar.size - sizes2.scrollbar.paddingEnd - thumbOffsetFromEnd, maxScrollPos = sizes2.content - sizes2.viewport, scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
  return (event) => {
    originalEventHandler?.(event), (checkForDefaultPrevented === !1 || !event.defaultPrevented) && ourEventHandler?.(event);
  };
}
const [ScrollbarProvider, useScrollbarContext] = createSafeContext$1(
  "ScrollAreaScrollbar was not found in tree"
), Scrollbar = forwardRef((props, forwardedRef) => {
  const {
    sizes: sizes2,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props, context2 = useScrollAreaContext(), [scrollbar, setScrollbar] = useState(null), composeRefs2 = useMergedRef(forwardedRef, (node2) => setScrollbar(node2)), rectRef = useRef(null), prevWebkitUserSelectRef = useRef(""), { viewport } = context2, maxScrollPos = sizes2.content - sizes2.viewport, handleWheelScroll = useCallbackRef$1(onWheelScroll), handleThumbPositionChange = useCallbackRef$1(onThumbPositionChange), handleResize = useDebouncedCallback(onResize, 10), handleDragScroll = (event) => {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left, y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  };
  return useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      scrollbar?.contains(element) && handleWheelScroll(event, maxScrollPos);
    };
    return document.addEventListener("wheel", handleWheel, { passive: !1 }), () => document.removeEventListener("wheel", handleWheel, { passive: !1 });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]), useEffect(handleThumbPositionChange, [sizes2, handleThumbPositionChange]), useResizeObserver(scrollbar, handleResize), useResizeObserver(context2.content, handleResize), /* @__PURE__ */ jsx(
    ScrollbarProvider,
    {
      value: {
        scrollbar,
        hasThumb,
        onThumbChange: useCallbackRef$1(onThumbChange),
        onThumbPointerUp: useCallbackRef$1(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: useCallbackRef$1(onThumbPointerDown)
      },
      children: /* @__PURE__ */ jsx(
        "div",
        {
          ...scrollbarProps,
          ref: composeRefs2,
          "data-mantine-scrollbar": !0,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            event.preventDefault(), event.button === 0 && (event.target.setPointerCapture(event.pointerId), rectRef.current = scrollbar.getBoundingClientRect(), prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", handleDragScroll(event));
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            element.hasPointerCapture(event.pointerId) && (event.preventDefault(), element.releasePointerCapture(event.pointerId));
          }),
          onLostPointerCapture: () => {
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current, rectRef.current = null;
          }
        }
      )
    }
  );
}), ScrollAreaScrollbarX = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style: style2, ...others } = props, ctx = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs2 = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
    return useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current));
    }, [ref]), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        "data-orientation": "horizontal",
        ...others,
        ref: composeRefs2,
        sizes: sizes2,
        style: {
          ...style2,
          "--sa-thumb-width": `${getThumbSize(sizes2)}px`
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (ctx.viewport) {
            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && ctx.viewport && computedStyle && onSizesChange({
            content: ctx.viewport.scrollWidth,
            viewport: ctx.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";
const ScrollAreaScrollbarY = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style: style2, ...others } = props, context2 = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs2 = useMergedRef(forwardedRef, ref, context2.onScrollbarYChange);
    return useEffect(() => {
      ref.current && setComputedStyle(window.getComputedStyle(ref.current));
    }, []), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        ...others,
        "data-orientation": "vertical",
        ref: composeRefs2,
        sizes: sizes2,
        style: {
          "--sa-thumb-height": `${getThumbSize(sizes2)}px`,
          ...style2
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context2.viewport) {
            const scrollPos = context2.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && context2.viewport && computedStyle && onSizesChange({
            content: context2.viewport.scrollHeight,
            viewport: context2.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";
const ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props, { dir } = useDirection(), context2 = useScrollAreaContext(), thumbRef = useRef(null), pointerOffsetRef = useRef(0), [sizes2, setSizes] = useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), thumbRatio = getThumbRatio(sizes2.viewport, sizes2.content), commonProps = {
    ...scrollbarProps,
    sizes: sizes2,
    onSizesChange: setSizes,
    hasThumb: thumbRatio > 0 && thumbRatio < 1,
    onThumbChange: (thumb) => {
      thumbRef.current = thumb;
    },
    onThumbPointerUp: () => {
      pointerOffsetRef.current = 0;
    },
    onThumbPointerDown: (pointerPos) => {
      pointerOffsetRef.current = pointerPos;
    }
  }, getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes2, direction);
  return orientation === "horizontal" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarX,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context2.viewport && thumbRef.current) {
          const scrollPos = context2.viewport.scrollLeft, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2, dir);
          thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context2.viewport && (context2.viewport.scrollLeft = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context2.viewport && (context2.viewport.scrollLeft = getScrollPosition(pointerPos, dir));
      }
    }
  ) : orientation === "vertical" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarY,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context2.viewport && thumbRef.current) {
          const scrollPos = context2.viewport.scrollTop, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2);
          sizes2.scrollbar.size === 0 ? thumbRef.current.style.setProperty("--thumb-opacity", "0") : thumbRef.current.style.setProperty("--thumb-opacity", "1"), thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context2.viewport && (context2.viewport.scrollTop = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context2.viewport && (context2.viewport.scrollTop = getScrollPosition(pointerPos));
      }
    }
  ) : null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
const ScrollAreaScrollbarAuto = forwardRef(
  (props, ref) => {
    const context2 = useScrollAreaContext(), { forceMount, ...scrollbarProps } = props, [visible2, setVisible] = useState(!1), isHorizontal = props.orientation === "horizontal", handleResize = useDebouncedCallback(() => {
      if (context2.viewport) {
        const isOverflowX = context2.viewport.offsetWidth < context2.viewport.scrollWidth, isOverflowY = context2.viewport.offsetHeight < context2.viewport.scrollHeight;
        setVisible(isHorizontal ? isOverflowX : isOverflowY);
      }
    }, 10);
    return useResizeObserver(context2.viewport, handleResize), useResizeObserver(context2.content, handleResize), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
const ScrollAreaScrollbarHover = forwardRef(
  (props, ref) => {
    const { forceMount, ...scrollbarProps } = props, context2 = useScrollAreaContext(), [visible2, setVisible] = useState(!1);
    return useEffect(() => {
      const { scrollArea: scrollArea2 } = context2;
      let hideTimer = 0;
      if (scrollArea2) {
        const handlePointerEnter = () => {
          window.clearTimeout(hideTimer), setVisible(!0);
        }, handlePointerLeave = () => {
          hideTimer = window.setTimeout(() => setVisible(!1), context2.scrollHideDelay);
        };
        return scrollArea2.addEventListener("pointerenter", handlePointerEnter), scrollArea2.addEventListener("pointerleave", handlePointerLeave), () => {
          window.clearTimeout(hideTimer), scrollArea2.removeEventListener("pointerenter", handlePointerEnter), scrollArea2.removeEventListener("pointerleave", handlePointerLeave);
        };
      }
    }, [context2.scrollArea, context2.scrollHideDelay]), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarAuto,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";
const ScrollAreaScrollbarScroll = forwardRef(
  (props, red) => {
    const { forceMount, ...scrollbarProps } = props, context2 = useScrollAreaContext(), isHorizontal = props.orientation === "horizontal", [state, setState] = useState("hidden"), debounceScrollEnd = useDebouncedCallback(() => setState("idle"), 100);
    return useEffect(() => {
      if (state === "idle") {
        const hideTimer = window.setTimeout(() => setState("hidden"), context2.scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    }, [state, context2.scrollHideDelay]), useEffect(() => {
      const { viewport } = context2, scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll2 = () => {
          const scrollPos = viewport[scrollDirection];
          prevScrollPos !== scrollPos && (setState("scrolling"), debounceScrollEnd()), prevScrollPos = scrollPos;
        };
        return viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [context2.viewport, isHorizontal, debounceScrollEnd]), forceMount || state !== "hidden" ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": state === "hidden" ? "hidden" : "visible",
        ...scrollbarProps,
        ref: red,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
      }
    ) : null;
  }
), ScrollAreaScrollbar = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props, context2 = useScrollAreaContext(), { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context2, isHorizontal = props.orientation === "horizontal";
    return useEffect(() => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
      isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1);
    }), [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]), context2.type === "hover" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context2.type === "scroll" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context2.type === "auto" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context2.type === "always" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";
function addUnlinkedScrollListener(node2, handler = () => {
}) {
  let prevPosition = { left: node2.scrollLeft, top: node2.scrollTop }, rAF = 0;
  return (function loop() {
    const position = { left: node2.scrollLeft, top: node2.scrollTop }, isHorizontalScroll = prevPosition.left !== position.left, isVerticalScroll = prevPosition.top !== position.top;
    (isHorizontalScroll || isVerticalScroll) && handler(), prevPosition = position, rAF = window.requestAnimationFrame(loop);
  })(), () => window.cancelAnimationFrame(rAF);
}
const Thumb$1 = forwardRef((props, forwardedRef) => {
  const { style: style2, ...others } = props, scrollAreaContext = useScrollAreaContext(), scrollbarContext = useScrollbarContext(), { onThumbPositionChange } = scrollbarContext, composedRef = useMergedRef(forwardedRef, (node2) => scrollbarContext.onThumbChange(node2)), removeUnlinkedScrollListenerRef = useRef(void 0), debounceScrollEnd = useDebouncedCallback(() => {
    removeUnlinkedScrollListenerRef.current && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0);
  }, 100);
  return useEffect(() => {
    const { viewport } = scrollAreaContext;
    if (viewport) {
      const handleScroll2 = () => {
        if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange();
        }
      };
      return onThumbPositionChange(), viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]), /* @__PURE__ */ jsx(
    "div",
    {
      "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
      ...others,
      ref: composedRef,
      style: {
        width: "var(--sa-thumb-width)",
        height: "var(--sa-thumb-height)",
        ...style2
      },
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
        const thumbRect = event.target.getBoundingClientRect(), x2 = event.clientX - thumbRect.left, y2 = event.clientY - thumbRect.top;
        scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
      }),
      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
    }
  );
});
Thumb$1.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaThumb = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props, scrollbarContext = useScrollbarContext();
    return forceMount || scrollbarContext.hasThumb ? /* @__PURE__ */ jsx(Thumb$1, { ref: forwardedRef, ...thumbProps }) : null;
  }
);
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaViewport = forwardRef(
  ({ children: children2, style: style2, ...others }, ref) => {
    const ctx = useScrollAreaContext(), rootRef = useMergedRef(ref, ctx.onViewportChange);
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        ...others,
        ref: rootRef,
        style: {
          overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
          ...style2
        },
        children: /* @__PURE__ */ jsx("div", { ...ctx.getStyles("content"), ref: ctx.onContentChange, children: children2 })
      }
    );
  }
);
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";
var classes$A = { root: "m_d57069b5", content: "m_b1336c6", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };
const defaultProps$J = {
  scrollHideDelay: 1e3,
  type: "hover",
  scrollbars: "xy"
}, varsResolver$G = (_, { scrollbarSize, overscrollBehavior }) => ({
  root: {
    "--scrollarea-scrollbar-size": rem(scrollbarSize),
    "--scrollarea-over-scroll-behavior": overscrollBehavior
  }
}), ScrollArea = factory((_props, ref) => {
  const props = useProps("ScrollArea", defaultProps$J, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    scrollbarSize,
    vars,
    type,
    scrollHideDelay,
    viewportProps,
    viewportRef,
    onScrollPositionChange,
    children: children2,
    offsetScrollbars,
    scrollbars,
    onBottomReached,
    onTopReached,
    overscrollBehavior,
    attributes,
    ...others
  } = props, [scrollbarHovered, setScrollbarHovered] = useState(!1), [verticalThumbVisible, setVerticalThumbVisible] = useState(!1), [horizontalThumbVisible, setHorizontalThumbVisible] = useState(!1), getStyles2 = useStyles({
    name: "ScrollArea",
    props,
    classes: classes$A,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$G
  }), localViewportRef = useRef(null), combinedViewportRef = useMergeRefs([viewportRef, localViewportRef]);
  return useEffect(() => {
    if (!localViewportRef.current || offsetScrollbars !== "present")
      return;
    const element = localViewportRef.current, observer = new ResizeObserver(() => {
      const { scrollHeight, clientHeight, scrollWidth, clientWidth } = element;
      setVerticalThumbVisible(scrollHeight > clientHeight), setHorizontalThumbVisible(scrollWidth > clientWidth);
    });
    return observer.observe(element), () => observer.disconnect();
  }, [localViewportRef, offsetScrollbars]), /* @__PURE__ */ jsxs(
    ScrollAreaRoot,
    {
      getStyles: getStyles2,
      type: type === "never" ? "always" : type,
      scrollHideDelay,
      ref,
      scrollbars,
      ...getStyles2("root"),
      ...others,
      children: [
        /* @__PURE__ */ jsx(
          ScrollAreaViewport,
          {
            ...viewportProps,
            ...getStyles2("viewport", { style: viewportProps?.style }),
            ref: combinedViewportRef,
            "data-offset-scrollbars": offsetScrollbars === !0 ? "xy" : offsetScrollbars || void 0,
            "data-scrollbars": scrollbars || void 0,
            "data-horizontal-hidden": offsetScrollbars === "present" && !horizontalThumbVisible ? "true" : void 0,
            "data-vertical-hidden": offsetScrollbars === "present" && !verticalThumbVisible ? "true" : void 0,
            onScroll: (e2) => {
              viewportProps?.onScroll?.(e2), onScrollPositionChange?.({ x: e2.currentTarget.scrollLeft, y: e2.currentTarget.scrollTop });
              const { scrollTop, scrollHeight, clientHeight } = e2.currentTarget;
              scrollTop - (scrollHeight - clientHeight) >= -0.6 && onBottomReached?.(), scrollTop === 0 && onTopReached?.();
            },
            children: children2
          }
        ),
        (scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "horizontal",
            "data-hidden": type === "never" || offsetScrollbars === "present" && !horizontalThumbVisible ? !0 : void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        (scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "vertical",
            "data-hidden": type === "never" || offsetScrollbars === "present" && !verticalThumbVisible ? !0 : void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        /* @__PURE__ */ jsx(
          ScrollAreaCorner,
          {
            ...getStyles2("corner"),
            "data-hovered": scrollbarHovered || void 0,
            "data-hidden": type === "never" || void 0
          }
        )
      ]
    }
  );
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
const ScrollAreaAutosize = factory((props, ref) => {
  const {
    children: children2,
    classNames,
    styles,
    scrollbarSize,
    scrollHideDelay,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    scrollbars,
    style: style2,
    vars,
    onBottomReached,
    onTopReached,
    onOverflowChange,
    ...others
  } = useProps("ScrollAreaAutosize", defaultProps$J, props), viewportObserverRef = useRef(null), combinedViewportRef = useMergeRefs([viewportRef, viewportObserverRef]), [overflowing, setOverflowing] = useState(!1), didMount = useRef(!1);
  return useEffect(() => {
    if (!onOverflowChange)
      return;
    const el = viewportObserverRef.current;
    if (!el)
      return;
    const update = () => {
      const isOverflowing = el.scrollHeight > el.clientHeight;
      isOverflowing !== overflowing && (didMount.current ? onOverflowChange?.(isOverflowing) : (didMount.current = !0, isOverflowing && onOverflowChange?.(!0)), setOverflowing(isOverflowing));
    };
    update();
    const ro = new ResizeObserver(update);
    return ro.observe(el), () => ro.disconnect();
  }, [onOverflowChange, overflowing]), /* @__PURE__ */ jsx(Box$1, { ...others, ref, style: [{ display: "flex", overflow: "hidden" }, style2], children: /* @__PURE__ */ jsx(
    Box$1,
    {
      style: {
        display: "flex",
        flexDirection: "column",
        flex: 1,
        overflow: "hidden",
        ...scrollbars === "y" && { minWidth: 0 },
        ...scrollbars === "x" && { minHeight: 0 },
        ...scrollbars === "xy" && { minWidth: 0, minHeight: 0 },
        ...scrollbars === !1 && { minWidth: 0, minHeight: 0 }
      },
      children: /* @__PURE__ */ jsx(
        ScrollArea,
        {
          classNames,
          styles,
          scrollHideDelay,
          scrollbarSize,
          type,
          dir,
          offsetScrollbars,
          viewportRef: combinedViewportRef,
          onScrollPositionChange,
          unstyled,
          variant,
          viewportProps,
          vars,
          scrollbars,
          onBottomReached,
          onTopReached,
          "data-autosize": "true",
          children: children2
        }
      )
    }
  ) });
});
ScrollArea.classes = classes$A;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$A;
ScrollArea.Autosize = ScrollAreaAutosize;
var classes$z = { root: "m_87cf2631" };
const defaultProps$I = {
  __staticSelector: "UnstyledButton"
}, UnstyledButton = polymorphicFactory(
  (_props, ref) => {
    const props = useProps("UnstyledButton", defaultProps$I, _props), {
      className,
      component = "button",
      __staticSelector,
      unstyled,
      classNames,
      styles,
      style: style2,
      attributes,
      ...others
    } = props, getStyles2 = useStyles({
      name: __staticSelector,
      props,
      classes: classes$z,
      className,
      style: style2,
      classNames,
      styles,
      unstyled,
      attributes
    });
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        ...getStyles2("root", { focusable: !0 }),
        component,
        ref,
        type: component === "button" ? "button" : void 0,
        ...others
      }
    );
  }
);
UnstyledButton.classes = classes$z;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";
var classes$y = { root: "m_515a97f8" };
const VisuallyHidden = factory((_props, ref) => {
  const props = useProps("VisuallyHidden", null, _props), { classNames, className, style: style2, styles, unstyled, vars, attributes, ...others } = props, getStyles2 = useStyles({
    name: "VisuallyHidden",
    classes: classes$y,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes
  });
  return /* @__PURE__ */ jsx(Box$1, { component: "span", ref, ...getStyles2("root"), ...others });
});
VisuallyHidden.classes = classes$y;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";
var classes$x = { root: "m_1b7284a3" };
const varsResolver$F = (_, { radius, shadow }) => ({
  root: {
    "--paper-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--paper-shadow": getShadow(shadow)
  }
}), Paper = polymorphicFactory((_props, ref) => {
  const props = useProps("Paper", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    withBorder,
    vars,
    radius,
    shadow,
    variant,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Paper",
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$F
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      mod: [{ "data-with-border": withBorder }, mod],
      ...getStyles2("root"),
      variant,
      ...others
    }
  );
});
Paper.classes = classes$x;
Paper.displayName = "@mantine/core/Paper";
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
  return placement === "center" || arrowPosition === "center" ? { top: arrowY } : placement === "end" ? { bottom: arrowOffset } : placement === "start" ? { top: arrowOffset } : {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
  return placement === "center" || arrowPosition === "center" ? { left: arrowX } : placement === "end" ? { [dir === "ltr" ? "right" : "left"]: arrowOffset } : placement === "start" ? { [dir === "ltr" ? "left" : "right"]: arrowOffset } : {};
}
const radiusByFloatingSide = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function getArrowPositionStyles({
  position,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  arrowX,
  arrowY,
  dir
}) {
  const [side, placement = "center"] = position.split("-"), baseStyles = {
    width: arrowSize,
    height: arrowSize,
    transform: "rotate(45deg)",
    position: "absolute",
    [radiusByFloatingSide[side]]: arrowRadius
  }, arrowPlacement = -arrowSize / 2;
  return side === "left" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    right: arrowPlacement,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent",
    clipPath: "polygon(100% 0, 0 0, 100% 100%)"
  } : side === "right" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    left: arrowPlacement,
    borderRightColor: "transparent",
    borderTopColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 100%)"
  } : side === "top" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    bottom: arrowPlacement,
    borderTopColor: "transparent",
    borderLeftColor: "transparent",
    clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
  } : side === "bottom" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    top: arrowPlacement,
    borderBottomColor: "transparent",
    borderRightColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 0)"
  } : {};
}
const FloatingArrow = forwardRef(
  ({
    position,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    visible: visible2,
    arrowX,
    arrowY,
    style: style2,
    ...others
  }, ref) => {
    const { dir } = useDirection();
    return visible2 ? /* @__PURE__ */ jsx(
      "div",
      {
        ...others,
        ref,
        style: {
          ...style2,
          ...getArrowPositionStyles({
            position,
            arrowSize,
            arrowOffset,
            arrowRadius,
            arrowPosition,
            dir,
            arrowX,
            arrowY
          })
        }
      }
    ) : null;
  }
);
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
function getFloatingPosition(dir, position) {
  if (dir === "rtl" && (position.includes("right") || position.includes("left"))) {
    const [side, placement] = position.split("-"), flippedPosition = side === "right" ? "left" : "right";
    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
  }
  return position;
}
var classes$w = { root: "m_9814e45f" };
const defaultProps$H = {
  zIndex: getDefaultZIndex("modal")
}, varsResolver$E = (_, { gradient, color: color2, backgroundOpacity, blur, radius, zIndex }) => ({
  root: {
    "--overlay-bg": gradient || (color2 !== void 0 || backgroundOpacity !== void 0) && rgba$2(color2 || "#000", backgroundOpacity ?? 0.6) || void 0,
    "--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
    "--overlay-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--overlay-z-index": zIndex?.toString()
  }
}), Overlay$1 = polymorphicFactory((_props, ref) => {
  const props = useProps("Overlay", defaultProps$H, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    fixed,
    center,
    children: children2,
    radius,
    zIndex,
    gradient,
    blur,
    color: color2,
    backgroundOpacity,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Overlay",
    props,
    classes: classes$w,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$E
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), mod: [{ center, fixed }, mod], ...others, children: children2 });
});
Overlay$1.classes = classes$w;
Overlay$1.displayName = "@mantine/core/Overlay";
function createPortalNode(props) {
  const node2 = document.createElement("div");
  return node2.setAttribute("data-portal", "true"), typeof props.className == "string" && node2.classList.add(...props.className.split(" ").filter(Boolean)), typeof props.style == "object" && Object.assign(node2.style, props.style), typeof props.id == "string" && node2.setAttribute("id", props.id), node2;
}
function getTargetNode({ target, reuseTargetNode, ...others }) {
  if (target)
    return typeof target == "string" ? document.querySelector(target) || createPortalNode(others) : target;
  if (reuseTargetNode) {
    const existingNode = document.querySelector("[data-mantine-shared-portal-node]");
    if (existingNode)
      return existingNode;
    const node2 = createPortalNode(others);
    return node2.setAttribute("data-mantine-shared-portal-node", "true"), document.body.appendChild(node2), node2;
  }
  return createPortalNode(others);
}
const defaultProps$G = {
  reuseTargetNode: !0
}, Portal = factory((props, ref) => {
  const { children: children2, target, reuseTargetNode, ...others } = useProps("Portal", defaultProps$G, props), [mounted, setMounted] = useState(!1), nodeRef2 = useRef(null);
  return useIsomorphicEffect(() => (setMounted(!0), nodeRef2.current = getTargetNode({ target, reuseTargetNode, ...others }), assignRef(ref, nodeRef2.current), !target && !reuseTargetNode && nodeRef2.current && document.body.appendChild(nodeRef2.current), () => {
    !target && !reuseTargetNode && nodeRef2.current && document.body.removeChild(nodeRef2.current);
  }), [target]), !mounted || !nodeRef2.current ? null : createPortal(/* @__PURE__ */ jsx(Fragment, { children: children2 }), nodeRef2.current);
});
Portal.displayName = "@mantine/core/Portal";
const OptionalPortal = factory(
  ({ withinPortal = !0, children: children2, ...others }, ref) => useMantineEnv() === "test" || !withinPortal ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : /* @__PURE__ */ jsx(Portal, { ref, ...others, children: children2 })
);
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
const popIn = (from) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${from === "bottom" ? 10 : -10}px)` },
  transitionProperty: "transform, opacity"
}), transitions = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-30px)" },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...popIn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...popIn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...popIn("top"),
    common: { transformOrigin: "top right" }
  }
}, transitionStatuses = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function getTransitionStyles({
  transition,
  state,
  duration,
  timingFunction
}) {
  const shared = {
    WebkitBackfaceVisibility: "hidden",
    transitionDuration: `${duration}ms`,
    transitionTimingFunction: timingFunction
  };
  return typeof transition == "string" ? transition in transitions ? {
    transitionProperty: transitions[transition].transitionProperty,
    ...shared,
    ...transitions[transition].common,
    ...transitions[transition][transitionStatuses[state]]
  } : {} : {
    transitionProperty: transition.transitionProperty,
    ...shared,
    ...transition.common,
    ...transition[transitionStatuses[state]]
  };
}
function useTransition({
  duration,
  exitDuration,
  timingFunction,
  mounted,
  onEnter,
  onExit,
  onEntered,
  onExited,
  enterDelay,
  exitDelay
}) {
  const theme = useMantineTheme(), shouldReduceMotion = useReducedMotion$1(), reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : !1, [transitionDuration, setTransitionDuration] = useState(reduceMotion ? 0 : duration), [transitionStatus, setStatus] = useState(mounted ? "entered" : "exited"), transitionTimeoutRef = useRef(-1), delayTimeoutRef = useRef(-1), rafRef = useRef(-1);
  function clearAllTimeouts() {
    window.clearTimeout(transitionTimeoutRef.current), window.clearTimeout(delayTimeoutRef.current), cancelAnimationFrame(rafRef.current);
  }
  const handleStateChange = (shouldMount) => {
    clearAllTimeouts();
    const preHandler = shouldMount ? onEnter : onExit, handler = shouldMount ? onEntered : onExited, newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration : exitDuration;
    setTransitionDuration(newTransitionDuration), newTransitionDuration === 0 ? (typeof preHandler == "function" && preHandler(), typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited")) : rafRef.current = requestAnimationFrame(() => {
      ReactDOM__default.flushSync(() => {
        setStatus(shouldMount ? "pre-entering" : "pre-exiting");
      }), rafRef.current = requestAnimationFrame(() => {
        typeof preHandler == "function" && preHandler(), setStatus(shouldMount ? "entering" : "exiting"), transitionTimeoutRef.current = window.setTimeout(() => {
          typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited");
        }, newTransitionDuration);
      });
    });
  }, handleTransitionWithDelay = (shouldMount) => {
    if (clearAllTimeouts(), typeof (shouldMount ? enterDelay : exitDelay) != "number") {
      handleStateChange(shouldMount);
      return;
    }
    delayTimeoutRef.current = window.setTimeout(
      () => {
        handleStateChange(shouldMount);
      },
      shouldMount ? enterDelay : exitDelay
    );
  };
  return useDidUpdate(() => {
    handleTransitionWithDelay(mounted);
  }, [mounted]), useEffect(
    () => () => {
      clearAllTimeouts();
    },
    []
  ), {
    transitionDuration,
    transitionStatus,
    transitionTimingFunction: timingFunction || "ease"
  };
}
function Transition({
  keepMounted,
  transition = "fade",
  duration = 250,
  exitDuration = duration,
  mounted,
  children: children2,
  timingFunction = "ease",
  onExit,
  onEntered,
  onEnter,
  onExited,
  enterDelay,
  exitDelay
}) {
  const env = useMantineEnv(), { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
    mounted,
    exitDuration,
    duration,
    timingFunction,
    onExit,
    onEntered,
    onEnter,
    onExited,
    enterDelay,
    exitDelay
  });
  return transitionDuration === 0 || env === "test" ? mounted ? /* @__PURE__ */ jsx(Fragment, { children: children2({}) }) : keepMounted ? children2({ display: "none" }) : null : transitionStatus === "exited" ? keepMounted ? children2({ display: "none" }) : null : /* @__PURE__ */ jsx(Fragment, { children: children2(
    getTransitionStyles({
      transition,
      duration: transitionDuration,
      state: transitionStatus,
      timingFunction: transitionTimingFunction
    })
  ) });
}
Transition.displayName = "@mantine/core/Transition";
const [PopoverContextProvider, usePopoverContext] = createSafeContext$1(
  "Popover component was not found in the tree"
);
function FocusTrap({
  children: children2,
  active = !0,
  refProp = "ref",
  innerRef
}) {
  const focusTrapRef = useFocusTrap(active), ref = useMergedRef(focusTrapRef, innerRef), child = getSingleElementChild(children2);
  return child ? cloneElement(child, { [refProp]: ref }) : children2;
}
function FocusTrapInitialFocus(props) {
  return /* @__PURE__ */ jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": !0, ...props });
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;
var classes$v = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" };
const PopoverDropdown = factory((_props, ref) => {
  const props = useProps("PopoverDropdown", null, _props), {
    className,
    style: style2,
    vars,
    children: children2,
    onKeyDownCapture,
    variant,
    classNames,
    styles,
    ...others
  } = props, ctx = usePopoverContext(), returnFocus = useFocusReturn({
    opened: ctx.opened,
    shouldReturnFocus: ctx.returnFocus
  }), accessibleProps = ctx.withRoles ? {
    "aria-labelledby": ctx.getTargetId(),
    id: ctx.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, mergedRef = useMergedRef(ref, ctx.floating);
  return ctx.disabled ? null : /* @__PURE__ */ jsx(OptionalPortal, { ...ctx.portalProps, withinPortal: ctx.withinPortal, children: /* @__PURE__ */ jsx(
    Transition,
    {
      mounted: ctx.opened,
      ...ctx.transitionProps,
      transition: ctx.transitionProps?.transition || "fade",
      duration: ctx.transitionProps?.duration ?? 150,
      keepMounted: ctx.keepMounted,
      exitDuration: typeof ctx.transitionProps?.exitDuration == "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
      children: (transitionStyles) => /* @__PURE__ */ jsx(FocusTrap, { active: ctx.trapFocus && ctx.opened, innerRef: mergedRef, children: /* @__PURE__ */ jsxs(
        Box$1,
        {
          ...accessibleProps,
          ...others,
          variant,
          onKeyDownCapture: closeOnEscape(
            () => {
              ctx.onClose?.(), ctx.onDismiss?.();
            },
            {
              active: ctx.closeOnEscape,
              onTrigger: returnFocus,
              onKeyDown: onKeyDownCapture
            }
          ),
          "data-position": ctx.placement,
          "data-fixed": ctx.floatingStrategy === "fixed" || void 0,
          ...ctx.getStyles("dropdown", {
            className,
            props,
            classNames,
            styles,
            style: [
              {
                ...transitionStyles,
                zIndex: ctx.zIndex,
                top: ctx.y ?? 0,
                left: ctx.x ?? 0,
                width: ctx.width === "target" ? void 0 : rem(ctx.width),
                ...ctx.referenceHidden ? { display: "none" } : null
              },
              ctx.resolvedStyles.dropdown,
              styles?.dropdown,
              style2
            ]
          }),
          children: [
            children2,
            /* @__PURE__ */ jsx(
              FloatingArrow,
              {
                ref: ctx.arrowRef,
                arrowX: ctx.arrowX,
                arrowY: ctx.arrowY,
                visible: ctx.withArrow,
                position: ctx.placement,
                arrowSize: ctx.arrowSize,
                arrowRadius: ctx.arrowRadius,
                arrowOffset: ctx.arrowOffset,
                arrowPosition: ctx.arrowPosition,
                ...ctx.getStyles("arrow", {
                  props,
                  classNames,
                  styles
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
PopoverDropdown.classes = classes$v;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
const defaultProps$F = {
  refProp: "ref",
  popupType: "dialog"
}, PopoverTarget = factory((props, ref) => {
  const { children: children2, refProp, popupType, ...others } = useProps(
    "PopoverTarget",
    defaultProps$F,
    props
  ), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const forwardedProps = others, ctx = usePopoverContext(), targetRef = useMergedRef(ctx.reference, getRefProp(child), ref), accessibleProps = ctx.withRoles ? {
    "aria-haspopup": popupType,
    "aria-expanded": ctx.opened,
    "aria-controls": ctx.getDropdownId(),
    id: ctx.getTargetId()
  } : {}, childProps = child.props;
  return cloneElement(child, {
    ...forwardedProps,
    ...accessibleProps,
    ...ctx.targetProps,
    className: clsx(ctx.targetProps.className, forwardedProps.className, childProps.className),
    [refProp]: targetRef,
    ...ctx.controlled ? null : {
      onClick: () => {
        ctx.onToggle(), childProps.onClick?.();
      }
    }
  });
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
function getDefaultMiddlewares$1(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getPopoverMiddlewares(options, getFloating, env) {
  const middlewaresOptions = getDefaultMiddlewares$1(options.middlewares), middlewares = [offset(options.offset), hide()];
  return options.dropdownVisible && env !== "test" && options.preventPositionChangeWhenVisible && (middlewaresOptions.flip = !1), middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { limiter: limitShift(), padding: 5 } : { limiter: limitShift(), padding: 5, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewaresOptions.inline && middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ), middlewares.push(arrow({ element: options.arrowRef, padding: options.arrowOffset })), (middlewaresOptions.size || options.width === "target") && middlewares.push(
    size({
      ...typeof middlewaresOptions.size == "boolean" ? {} : middlewaresOptions.size,
      apply({ rects, availableWidth, availableHeight, ...rest }) {
        const styles = getFloating().refs.floating.current?.style ?? {};
        middlewaresOptions.size && (typeof middlewaresOptions.size == "object" && middlewaresOptions.size.apply ? middlewaresOptions.size.apply({ rects, availableWidth, availableHeight, ...rest }) : Object.assign(styles, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        })), options.width === "target" && Object.assign(styles, {
          width: `${rects.reference.width}px`
        });
      }
    })
  ), middlewares;
}
function usePopover(options) {
  const env = useMantineEnv(), [_opened, setOpened] = useUncontrolled({
    value: options.opened,
    defaultValue: options.defaultOpened,
    finalValue: !1,
    onChange: options.onChange
  }), previouslyOpened = useRef(_opened), onClose = () => {
    _opened && !options.disabled && setOpened(!1);
  }, onToggle = () => {
    options.disabled || setOpened(!_opened);
  }, floating = useFloating({
    strategy: options.strategy,
    placement: options.preventPositionChangeWhenVisible ? options.positionRef.current : options.position,
    middleware: getPopoverMiddlewares(options, () => floating, env),
    whileElementsMounted: options.keepMounted ? void 0 : autoUpdate
  });
  return useEffect(() => {
    if (!(!floating.refs.reference.current || !floating.refs.floating.current) && _opened)
      return autoUpdate(
        floating.refs.reference.current,
        floating.refs.floating.current,
        floating.update
      );
  }, [_opened, floating.update]), useDidUpdate(() => {
    options.onPositionChange?.(floating.placement), options.positionRef.current = floating.placement;
  }, [floating.placement, options.preventPositionChangeWhenVisible]), useDidUpdate(() => {
    _opened !== previouslyOpened.current && (_opened ? options.onOpen?.() : options.onClose?.()), previouslyOpened.current = _opened;
  }, [_opened, options.onClose, options.onOpen]), useIsomorphicEffect(() => {
    let timeout2 = -1;
    return _opened && (timeout2 = window.setTimeout(() => options.setDropdownVisible(!0), 4)), () => {
      window.clearTimeout(timeout2);
    };
  }, [_opened, options.position]), {
    floating,
    controlled: typeof options.opened == "boolean",
    opened: _opened,
    onClose,
    onToggle
  };
}
const defaultProps$E = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  withOverlay: !1,
  hideDetached: !0,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: getDefaultZIndex("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, varsResolver$D = (_, { radius, shadow }) => ({
  dropdown: {
    "--popover-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--popover-shadow": getShadow(shadow)
  }
});
function Popover(_props) {
  const props = useProps("Popover", defaultProps$E, _props), {
    children: children2,
    position,
    offset: offset2,
    onPositionChange,
    // Scheduled for removal in 9.0
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionDependencies,
    opened,
    transitionProps,
    onExitTransitionEnd,
    onEnterTransitionEnd,
    width,
    middlewares,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    unstyled,
    classNames,
    styles,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    closeOnEscape: closeOnEscape2,
    clickOutsideEvents,
    trapFocus,
    onClose,
    onDismiss,
    onOpen,
    onChange,
    zIndex,
    radius,
    shadow,
    id: id2,
    defaultOpened,
    __staticSelector,
    withRoles,
    disabled,
    returnFocus,
    variant,
    keepMounted,
    vars,
    floatingStrategy,
    withOverlay,
    overlayProps,
    hideDetached,
    attributes,
    preventPositionChangeWhenVisible,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes$v,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "dropdown",
    vars,
    varsResolver: varsResolver$D
  }), { resolvedStyles } = useResolvedStylesApi({ classNames, styles, props }), [dropdownVisible, setDropdownVisible] = useState(opened ?? defaultOpened ?? !1), positionRef = useRef(position), arrowRef = useRef(null), [targetNode, setTargetNode] = useState(null), [dropdownNode, setDropdownNode] = useState(null), { dir } = useDirection(), env = useMantineEnv(), uid = useId$2(id2), popover = usePopover({
    middlewares,
    width,
    position: getFloatingPosition(dir, position),
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    arrowRef,
    arrowOffset,
    onPositionChange,
    positionDependencies,
    opened,
    defaultOpened,
    onChange,
    onOpen,
    onClose,
    onDismiss,
    strategy: floatingStrategy,
    dropdownVisible,
    setDropdownVisible,
    positionRef,
    disabled,
    preventPositionChangeWhenVisible,
    keepMounted
  });
  useClickOutside(
    () => {
      closeOnClickOutside && (popover.onClose(), onDismiss?.());
    },
    clickOutsideEvents,
    [targetNode, dropdownNode]
  );
  const reference = useCallback(
    (node2) => {
      setTargetNode(node2), popover.floating.refs.setReference(node2);
    },
    [popover.floating.refs.setReference]
  ), floating = useCallback(
    (node2) => {
      setDropdownNode(node2), popover.floating.refs.setFloating(node2);
    },
    [popover.floating.refs.setFloating]
  ), onExited = useCallback(() => {
    transitionProps?.onExited?.(), onExitTransitionEnd?.(), setDropdownVisible(!1), preventPositionChangeWhenVisible || (positionRef.current = position);
  }, [transitionProps?.onExited, onExitTransitionEnd, preventPositionChangeWhenVisible, position]), onEntered = useCallback(() => {
    transitionProps?.onEntered?.(), onEnterTransitionEnd?.();
  }, [transitionProps?.onEntered, onEnterTransitionEnd]);
  return /* @__PURE__ */ jsxs(
    PopoverContextProvider,
    {
      value: {
        returnFocus,
        disabled,
        controlled: popover.controlled,
        reference,
        floating,
        x: popover.floating.x,
        y: popover.floating.y,
        arrowX: popover.floating?.middlewareData?.arrow?.x,
        arrowY: popover.floating?.middlewareData?.arrow?.y,
        opened: popover.opened,
        arrowRef,
        transitionProps: { ...transitionProps, onExited, onEntered },
        width,
        withArrow,
        arrowSize,
        arrowOffset,
        arrowRadius,
        arrowPosition,
        placement: popover.floating.placement,
        trapFocus,
        withinPortal,
        portalProps,
        zIndex,
        radius,
        shadow,
        closeOnEscape: closeOnEscape2,
        onDismiss,
        onClose: popover.onClose,
        onToggle: popover.onToggle,
        getTargetId: () => `${uid}-target`,
        getDropdownId: () => `${uid}-dropdown`,
        withRoles,
        targetProps: others,
        __staticSelector,
        classNames,
        styles,
        unstyled,
        variant,
        keepMounted,
        getStyles: getStyles2,
        resolvedStyles,
        floatingStrategy,
        referenceHidden: hideDetached && env !== "test" ? popover.floating.middlewareData.hide?.referenceHidden : !1
      },
      children: [
        children2,
        withOverlay && /* @__PURE__ */ jsx(
          Transition,
          {
            transition: "fade",
            mounted: popover.opened,
            duration: transitionProps?.duration || 250,
            exitDuration: transitionProps?.exitDuration || 250,
            children: (transitionStyles) => /* @__PURE__ */ jsx(OptionalPortal, { withinPortal, children: /* @__PURE__ */ jsx(
              Overlay$1,
              {
                ...overlayProps,
                ...getStyles2("overlay", {
                  className: overlayProps?.className,
                  style: [transitionStyles, overlayProps?.style]
                })
              }
            ) })
          }
        )
      ]
    }
  );
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input2) => input2;
var classes$u = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const Bars = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box$1, { component: "span", className: clsx(classes$u.barsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$u.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$u.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$u.bar })
] }));
Bars.displayName = "@mantine/core/Bars";
const Dots = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box$1, { component: "span", className: clsx(classes$u.dotsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$u.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$u.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$u.dot })
] }));
Dots.displayName = "@mantine/core/Dots";
const Oval = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsx(Box$1, { component: "span", className: clsx(classes$u.ovalLoader, className), ...others, ref }));
Oval.displayName = "@mantine/core/Oval";
const defaultLoaders = {
  bars: Bars,
  oval: Oval,
  dots: Dots
}, defaultProps$D = {
  loaders: defaultLoaders,
  type: "oval"
}, varsResolver$C = (theme, { size: size2, color: color2 }) => ({
  root: {
    "--loader-size": getSize(size2, "loader-size"),
    "--loader-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Loader = factory((_props, ref) => {
  const props = useProps("Loader", defaultProps$D, _props), {
    size: size2,
    color: color2,
    type,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    loaders,
    variant,
    children: children2,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Loader",
    props,
    classes: classes$u,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$C
  });
  return children2 ? /* @__PURE__ */ jsx(Box$1, { ...getStyles2("root"), ref, ...others, children: children2 }) : /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root"),
      ref,
      component: loaders[type],
      variant,
      size: size2,
      ...others
    }
  );
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$u;
Loader.displayName = "@mantine/core/Loader";
var classes$t = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" };
const defaultProps$C = {
  orientation: "horizontal"
}, varsResolver$B = (_, { borderWidth }) => ({
  group: { "--ai-border-width": rem(borderWidth) }
}), ActionIconGroup = factory((_props, ref) => {
  const props = useProps("ActionIconGroup", defaultProps$C, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    attributes,
    ...others
  } = useProps("ActionIconGroup", defaultProps$C, _props), getStyles2 = useStyles({
    name: "ActionIconGroup",
    props,
    classes: classes$t,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$B,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ActionIconGroup.classes = classes$t;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";
const varsResolver$A = (theme, { radius, color: color2, gradient, variant, autoContrast, size: size2 }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size2, "section-height"),
      "--section-padding-x": getSize(size2, "section-padding-x"),
      "--section-fz": getFontSize(size2),
      "--section-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--section-bg": color2 || variant ? colors.background : void 0,
      "--section-color": colors.color,
      "--section-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ActionIconGroupSection = factory((_props, ref) => {
  const props = useProps("ActionIconGroupSection", null, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "ActionIconGroupSection",
    props,
    classes: classes$t,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$A,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ jsx(Box$1, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ActionIconGroupSection.classes = classes$t;
ActionIconGroupSection.displayName = "@mantine/core/ActionIconGroupSection";
const varsResolver$z = (theme, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ai-size": getSize(size2, "ai-size"),
      "--ai-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ai-bg": color2 || variant ? colors.background : void 0,
      "--ai-hover": color2 || variant ? colors.hover : void 0,
      "--ai-hover-color": color2 || variant ? colors.hoverColor : void 0,
      "--ai-color": colors.color,
      "--ai-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ActionIcon = polymorphicFactory((_props, ref) => {
  const props = useProps("ActionIcon", null, _props), {
    className,
    unstyled,
    variant,
    classNames,
    styles,
    style: style2,
    loading,
    loaderProps,
    size: size2,
    color: color2,
    radius,
    __staticSelector,
    gradient,
    vars,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["ActionIcon", __staticSelector],
    props,
    className,
    style: style2,
    classes: classes$t,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$z
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      ...others,
      unstyled,
      variant,
      size: size2,
      disabled: disabled || loading,
      ref,
      mod: [{ loading, disabled: disabled || dataDisabled }, mod],
      children: [
        typeof loading == "boolean" && /* @__PURE__ */ jsx(Transition, { mounted: loading, transition: "slide-down", duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(Loader, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...loaderProps }) }) }),
        /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { loading }, ...getStyles2("icon"), children: children2 })
      ]
    }
  );
});
ActionIcon.classes = classes$t;
ActionIcon.displayName = "@mantine/core/ActionIcon";
ActionIcon.Group = ActionIconGroup;
ActionIcon.GroupSection = ActionIconGroupSection;
const CloseIcon = forwardRef(
  ({ size: size2 = "var(--cb-icon-size, 70%)", style: style2, ...others }, ref) => /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style2, width: size2, height: size2 },
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
CloseIcon.displayName = "@mantine/core/CloseIcon";
var classes$s = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const defaultProps$B = {
  variant: "subtle"
}, varsResolver$y = (_, { size: size2, radius, iconSize: iconSize2 }) => ({
  root: {
    "--cb-size": getSize(size2, "cb-size"),
    "--cb-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cb-icon-size": rem(iconSize2)
  }
}), CloseButton = polymorphicFactory((_props, ref) => {
  const props = useProps("CloseButton", defaultProps$B, _props), {
    iconSize: iconSize2,
    children: children2,
    vars,
    radius,
    className,
    classNames,
    style: style2,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    disabled,
    variant,
    icon: icon2,
    mod,
    attributes,
    __staticSelector,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector || "CloseButton",
    props,
    className,
    style: style2,
    classes: classes$s,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$y
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...others,
      unstyled,
      variant,
      disabled,
      mod: [{ disabled: disabled || dataDisabled }, mod],
      ...getStyles2("root", { variant, active: !disabled && !dataDisabled }),
      children: [
        icon2 || /* @__PURE__ */ jsx(CloseIcon, {}),
        children2
      ]
    }
  );
});
CloseButton.classes = classes$s;
CloseButton.displayName = "@mantine/core/CloseButton";
function filterFalsyChildren(children2) {
  return Children.toArray(children2).filter(Boolean);
}
var classes$r = { root: "m_4081bf90" };
const defaultProps$A = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, varsResolver$x = (_, { grow, preventGrowOverflow, gap, align, justify, wrap: wrap2 }, { childWidth }) => ({
  root: {
    "--group-child-width": grow && preventGrowOverflow ? childWidth : void 0,
    "--group-gap": getSpacing(gap),
    "--group-align": align,
    "--group-justify": justify,
    "--group-wrap": wrap2
  }
}), Group = factory((_props, ref) => {
  const props = useProps("Group", defaultProps$A, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    children: children2,
    gap,
    align,
    justify,
    wrap: wrap2,
    grow,
    preventGrowOverflow,
    vars,
    variant,
    __size,
    mod,
    attributes,
    ...others
  } = props, filteredChildren = filterFalsyChildren(children2), childrenCount = filteredChildren.length, resolvedGap = getSpacing(gap ?? "md"), stylesCtx = { childWidth: `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))` }, getStyles2 = useStyles({
    name: "Group",
    props,
    stylesCtx,
    className,
    style: style2,
    classes: classes$r,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$x
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root"),
      ref,
      variant,
      mod: [{ grow }, mod],
      size: __size,
      ...others,
      children: filteredChildren
    }
  );
});
Group.classes = classes$r;
Group.displayName = "@mantine/core/Group";
const [InputContext, useInputContext] = createOptionalContext({
  size: "sm"
}), InputClearButton = factory((_props, ref) => {
  const props = useProps("InputClearButton", null, _props), { size: size2, variant, vars, classNames, styles, ...others } = props, ctx = useInputContext(), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return /* @__PURE__ */ jsx(
    CloseButton,
    {
      variant: variant || "transparent",
      ref,
      size: size2 || ctx?.size || "sm",
      classNames: resolvedClassNames,
      styles: resolvedStyles,
      __staticSelector: "InputClearButton",
      style: { pointerEvents: "all", background: "var(--input-bg)", ...others.style },
      ...others
    }
  );
});
InputClearButton.displayName = "@mantine/core/InputClearButton";
const clearSectionOffset = {
  xs: 7,
  sm: 8,
  md: 10,
  lg: 12,
  xl: 15
};
function InputClearSection({
  __clearable,
  __clearSection,
  rightSection,
  __defaultRightSection,
  size: size2 = "sm"
}) {
  const clearSection = __clearable && __clearSection;
  return clearSection && (rightSection || __defaultRightSection) ? /* @__PURE__ */ jsxs(
    "div",
    {
      "data-combined-clear-section": !0,
      style: {
        display: "flex",
        gap: 2,
        alignItems: "center",
        paddingInlineEnd: clearSectionOffset[size2]
      },
      children: [
        clearSection,
        rightSection || __defaultRightSection
      ]
    }
  ) : rightSection === null ? null : rightSection || clearSection || __defaultRightSection;
}
const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
});
var classes$q = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const varsResolver$w = (_, { size: size2 }) => ({
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputDescription = factory((_props, ref) => {
  const props = useProps("InputDescription", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    attributes,
    variant,
    ...others
  } = useProps("InputDescription", null, props), ctx = useInputWrapperContext(), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "description",
    vars,
    varsResolver: varsResolver$w
  }), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("description", ctx?.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputDescription.classes = classes$q;
InputDescription.displayName = "@mantine/core/InputDescription";
const varsResolver$v = (_, { size: size2 }) => ({
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputError = factory((_props, ref) => {
  const props = useProps("InputError", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    attributes,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = props, _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "error",
    vars,
    varsResolver: varsResolver$v
  }), ctx = useInputWrapperContext(), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("error", ctx?.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputError.classes = classes$q;
InputError.displayName = "@mantine/core/InputError";
const defaultProps$z = {
  labelElement: "label"
}, varsResolver$u = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  }
}), InputLabel = factory((_props, ref) => {
  const props = useProps("InputLabel", defaultProps$z, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    labelElement,
    size: size2,
    required,
    htmlFor,
    onMouseDown,
    children: children2,
    __staticSelector,
    variant,
    mod,
    attributes,
    ...others
  } = useProps("InputLabel", defaultProps$z, props), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "label",
    vars,
    varsResolver: varsResolver$u
  }), ctx = useInputWrapperContext(), getStyles2 = ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("label", ctx?.getStyles ? { className, style: style2 } : void 0),
      component: labelElement,
      variant,
      size: size2,
      ref,
      htmlFor: labelElement === "label" ? htmlFor : void 0,
      mod: [{ required }, mod],
      onMouseDown: (event) => {
        onMouseDown?.(event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      ...others,
      children: [
        children2,
        required && /* @__PURE__ */ jsx("span", { ...getStyles2("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
InputLabel.classes = classes$q;
InputLabel.displayName = "@mantine/core/InputLabel";
const InputPlaceholder = factory((_props, ref) => {
  const props = useProps("InputPlaceholder", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    __staticSelector,
    variant,
    error,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputPlaceholder", __staticSelector],
    props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("placeholder"),
      mod: [{ error: !!error }, mod],
      component: "span",
      variant,
      ref,
      ...others
    }
  );
});
InputPlaceholder.classes = classes$q;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
  const inputIndex = inputWrapperOrder.findIndex((part) => part === "input"), aboveInput = inputWrapperOrder.slice(0, inputIndex), belowInput = inputWrapperOrder.slice(inputIndex + 1), offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
  return { offsetBottom: hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error"), offsetTop };
}
const defaultProps$y = {
  labelElement: "label",
  inputContainer: (children2) => children2,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, varsResolver$t = (_, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  },
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputWrapper = factory((_props, ref) => {
  const props = useProps("InputWrapper", defaultProps$y, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    variant,
    __staticSelector,
    inputContainer,
    inputWrapperOrder,
    label: label2,
    error,
    description: description2,
    labelProps,
    descriptionProps,
    errorProps,
    labelElement,
    children: children2,
    withAsterisk,
    id: id2,
    required,
    __stylesApiProps,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputWrapper", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$t
  }), sharedProps = {
    size: size2,
    variant,
    __staticSelector
  }, idBase = useId$2(id2), isRequired = typeof withAsterisk == "boolean" ? withAsterisk : required, errorId = errorProps?.id || `${idBase}-error`, descriptionId = descriptionProps?.id || `${idBase}-description`, inputId = idBase, hasError = !!error && typeof error != "boolean", hasDescription = !!description2, _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`, describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0, labelId = labelProps?.id || `${idBase}-label`, _label = label2 && /* @__PURE__ */ jsx(
    InputLabel,
    {
      labelElement,
      id: labelId,
      htmlFor: inputId,
      required: isRequired,
      ...sharedProps,
      ...labelProps,
      children: label2
    },
    "label"
  ), _description = hasDescription && /* @__PURE__ */ jsx(
    InputDescription,
    {
      ...descriptionProps,
      ...sharedProps,
      size: descriptionProps?.size || sharedProps.size,
      id: descriptionProps?.id || descriptionId,
      children: description2
    },
    "description"
  ), _input = /* @__PURE__ */ jsx(Fragment$1, { children: inputContainer(children2) }, "input"), _error = hasError && /* @__PURE__ */ createElement(
    InputError,
    {
      ...errorProps,
      ...sharedProps,
      size: errorProps?.size || sharedProps.size,
      key: "error",
      id: errorProps?.id || errorId
    },
    error
  ), content = inputWrapperOrder.map((part) => {
    switch (part) {
      case "label":
        return _label;
      case "input":
        return _input;
      case "description":
        return _description;
      case "error":
        return _error;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsx(
    InputWrapperProvider,
    {
      value: {
        getStyles: getStyles2,
        describedBy,
        inputId,
        labelId,
        ...getInputOffsets(inputWrapperOrder, { hasDescription, hasError })
      },
      children: /* @__PURE__ */ jsx(
        Box$1,
        {
          ref,
          variant,
          size: size2,
          mod: [{ error: !!error }, mod],
          ...getStyles2("root"),
          ...others,
          children: content
        }
      )
    }
  );
});
InputWrapper.classes = classes$q;
InputWrapper.displayName = "@mantine/core/InputWrapper";
const defaultProps$x = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0,
  size: "sm"
}, varsResolver$s = (_, props, ctx) => ({
  wrapper: {
    "--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": getSize(props.size, "input-height"),
    "--input-fz": getFontSize(props.size),
    "--input-radius": props.radius === void 0 ? void 0 : getRadius$1(props.radius),
    "--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
    "--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
    "--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": props.leftSectionPointerEvents,
    "--input-right-section-pointer-events": props.rightSectionPointerEvents
  }
}), Input = polymorphicFactory((_props, ref) => {
  const props = useProps("Input", defaultProps$x, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    required,
    __staticSelector,
    __stylesApiProps,
    size: size2,
    wrapperProps,
    error,
    disabled,
    leftSection,
    leftSectionProps,
    leftSectionWidth,
    rightSection,
    rightSectionProps,
    rightSectionWidth,
    rightSectionPointerEvents,
    leftSectionPointerEvents,
    variant,
    vars,
    pointer: pointer2,
    multiline,
    radius,
    id: id2,
    withAria,
    withErrorStyles,
    mod,
    inputSize,
    attributes,
    __clearSection,
    __clearable,
    __defaultRightSection,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), ctx = useInputWrapperContext(), stylesCtx = { offsetBottom: ctx?.offsetBottom, offsetTop: ctx?.offsetTop }, getStyles2 = useStyles({
    name: ["Input", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    stylesCtx,
    rootSelector: "wrapper",
    vars,
    varsResolver: varsResolver$s
  }), ariaAttributes = withAria ? {
    required,
    disabled,
    "aria-invalid": !!error,
    "aria-describedby": ctx?.describedBy,
    id: ctx?.inputId || id2
  } : {}, _rightSection = InputClearSection({
    __clearable,
    __clearSection,
    rightSection,
    __defaultRightSection,
    size: size2
  });
  return /* @__PURE__ */ jsx(InputContext, { value: { size: size2 || "sm" }, children: /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("wrapper"),
      ...styleProps,
      ...wrapperProps,
      mod: [
        {
          error: !!error && withErrorStyles,
          pointer: pointer2,
          disabled,
          multiline,
          "data-with-right-section": !!_rightSection,
          "data-with-left-section": !!leftSection
        },
        mod
      ],
      variant,
      size: size2,
      children: [
        leftSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...leftSectionProps,
            "data-position": "left",
            ...getStyles2("section", {
              className: leftSectionProps?.className,
              style: leftSectionProps?.style
            }),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsx(
          Box$1,
          {
            component: "input",
            ...rest,
            ...ariaAttributes,
            ref,
            required,
            mod: { disabled, error: !!error && withErrorStyles },
            variant,
            __size: inputSize,
            ...getStyles2("input")
          }
        ),
        _rightSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...rightSectionProps,
            "data-position": "right",
            ...getStyles2("section", {
              className: rightSectionProps?.className,
              style: rightSectionProps?.style
            }),
            children: _rightSection
          }
        )
      ]
    }
  ) });
});
Input.classes = classes$q;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.ClearButton = InputClearButton;
Input.displayName = "@mantine/core/Input";
const FLEX_STYLE_PROPS_DATA = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var classes$p = { root: "m_8bffd616" };
const Flex = polymorphicFactory((_props, ref) => {
  const props = useProps("Flex", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    gap,
    rowGap,
    columnGap,
    align,
    justify,
    wrap: wrap2,
    direction,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Flex",
    classes: classes$p,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars
  }), theme = useMantineTheme(), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
    styleProps: { gap, rowGap, columnGap, align, justify, wrap: wrap2, direction },
    theme,
    data: FLEX_STYLE_PROPS_DATA
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
      InlineStyles,
      {
        selector: `.${responsiveClassName}`,
        styles: parsedStyleProps.styles,
        media: parsedStyleProps.media
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        ref,
        ...getStyles2("root", {
          className: responsiveClassName,
          style: filterProps$1(parsedStyleProps.inlineStyles)
        }),
        ...others
      }
    )
  ] });
});
Flex.classes = classes$p;
Flex.displayName = "@mantine/core/Flex";
function isParent(parentElement, childElement) {
  if (!childElement || !parentElement)
    return !1;
  let parent = childElement.parentNode;
  for (; parent != null; ) {
    if (parent === parentElement)
      return !0;
    parent = parent.parentNode;
  }
  return !1;
}
function useFloatingIndicator({
  target,
  parent,
  ref,
  displayAfterTransitionEnd
}) {
  const transitionTimeout = useRef(-1), [initialized, setInitialized] = useState(!1), [hidden2, setHidden] = useState(
    typeof displayAfterTransitionEnd == "boolean" ? displayAfterTransitionEnd : !1
  ), updatePosition = () => {
    if (!target || !parent || !ref.current)
      return;
    const targetRect = target.getBoundingClientRect(), parentRect = parent.getBoundingClientRect(), targetComputedStyle = window.getComputedStyle(target), parentComputedStyle = window.getComputedStyle(parent), borderTopWidth = toInt(targetComputedStyle.borderTopWidth) + toInt(parentComputedStyle.borderTopWidth), borderLeftWidth = toInt(targetComputedStyle.borderLeftWidth) + toInt(parentComputedStyle.borderLeftWidth), position = {
      top: targetRect.top - parentRect.top - borderTopWidth,
      left: targetRect.left - parentRect.left - borderLeftWidth,
      width: targetRect.width,
      height: targetRect.height
    };
    ref.current.style.transform = `translateY(${position.top}px) translateX(${position.left}px)`, ref.current.style.width = `${position.width}px`, ref.current.style.height = `${position.height}px`;
  }, updatePositionWithoutAnimation = () => {
    window.clearTimeout(transitionTimeout.current), ref.current && (ref.current.style.transitionDuration = "0ms"), updatePosition(), transitionTimeout.current = window.setTimeout(() => {
      ref.current && (ref.current.style.transitionDuration = "");
    }, 30);
  }, targetResizeObserver = useRef(null), parentResizeObserver = useRef(null);
  return useEffect(() => {
    if (updatePosition(), target)
      return targetResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), targetResizeObserver.current.observe(target), parent && (parentResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), parentResizeObserver.current.observe(parent)), () => {
        targetResizeObserver.current?.disconnect(), parentResizeObserver.current?.disconnect();
      };
  }, [parent, target]), useEffect(() => {
    if (parent) {
      const handleTransitionEnd = (event) => {
        isParent(event.target, parent) && (updatePositionWithoutAnimation(), setHidden(!1));
      };
      return parent.addEventListener("transitionend", handleTransitionEnd), () => {
        parent.removeEventListener("transitionend", handleTransitionEnd);
      };
    }
  }, [parent]), useTimeout(
    () => {
      getEnv() !== "test" && setInitialized(!0);
    },
    20,
    { autoInvoke: !0 }
  ), useMutationObserver(
    (mutations) => {
      mutations.forEach((mutation) => {
        mutation.type === "attributes" && mutation.attributeName === "dir" && updatePositionWithoutAnimation();
      });
    },
    { attributes: !0, attributeFilter: ["dir"] },
    () => document.documentElement
  ), { initialized, hidden: hidden2 };
}
var classes$o = { root: "m_96b553a6" };
const varsResolver$r = (_theme, { transitionDuration }) => ({
  root: {
    "--transition-duration": typeof transitionDuration == "number" ? `${transitionDuration}ms` : transitionDuration
  }
}), FloatingIndicator = factory((_props, ref) => {
  const props = useProps("FloatingIndicator", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    target,
    parent,
    transitionDuration,
    mod,
    displayAfterTransitionEnd,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "FloatingIndicator",
    classes: classes$o,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$r
  }), innerRef = useRef(null), { initialized, hidden: hidden2 } = useFloatingIndicator({
    target,
    parent,
    ref: innerRef,
    displayAfterTransitionEnd
  }), mergedRef = useMergedRef(ref, innerRef);
  return !target || !parent ? null : /* @__PURE__ */ jsx(Box$1, { ref: mergedRef, mod: [{ initialized, hidden: hidden2 }, mod], ...getStyles2("root"), ...others });
});
FloatingIndicator.displayName = "@mantine/core/FloatingIndicator";
FloatingIndicator.classes = classes$o;
function useDelayedHover({ open, close, openDelay, closeDelay }) {
  const openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = () => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, openDropdown = () => {
    clearTimeouts(), openDelay === 0 || openDelay === void 0 ? open() : openTimeout.current = window.setTimeout(open, openDelay);
  }, closeDropdown = () => {
    clearTimeouts(), closeDelay === 0 || closeDelay === void 0 ? close() : closeTimeout.current = window.setTimeout(close, closeDelay);
  };
  return useEffect(() => clearTimeouts, []), { openDropdown, closeDropdown };
}
function AccordionChevron({ style: style2, size: size2 = 16, ...others }) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style2, width: rem(size2), height: rem(size2), display: "block" },
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
AccordionChevron.displayName = "@mantine/core/AccordionChevron";
var classes$n = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };
const varsResolver$q = (theme, { radius, color: color2, variant, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--alert-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--alert-bg": color2 || variant ? colors.background : void 0,
      "--alert-color": colors.color,
      "--alert-bd": color2 || variant ? colors.border : void 0
    }
  };
}, Alert = factory((_props, ref) => {
  const props = useProps("Alert", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color: color2,
    title: title2,
    children: children2,
    id: id2,
    icon: icon2,
    withCloseButton,
    onClose,
    closeButtonLabel,
    variant,
    autoContrast,
    role,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Alert",
    classes: classes$n,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$q
  }), rootId = useId$2(id2), titleId = title2 && `${rootId}-title` || void 0, bodyId = `${rootId}-body`;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      id: rootId,
      ...getStyles2("root", { variant }),
      variant,
      ref,
      role: role || "alert",
      ...others,
      "aria-describedby": children2 ? bodyId : void 0,
      "aria-labelledby": title2 ? titleId : void 0,
      children: /* @__PURE__ */ jsxs("div", { ...getStyles2("wrapper"), children: [
        icon2 && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon2 }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title2 && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), "data-with-close-button": withCloseButton || void 0, children: /* @__PURE__ */ jsx("span", { id: titleId, ...getStyles2("label"), children: title2 }) }),
          children2 && /* @__PURE__ */ jsx("div", { id: bodyId, ...getStyles2("message"), "data-variant": variant, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            ...getStyles2("closeButton"),
            onClick: onClose,
            variant: "transparent",
            size: 16,
            iconSize: 16,
            "aria-label": closeButtonLabel,
            unstyled
          }
        )
      ] })
    }
  );
});
Alert.classes = classes$n;
Alert.displayName = "@mantine/core/Alert";
var classes$m = { root: "m_b6d8b162" };
function getTextTruncate(truncate) {
  if (truncate === "start")
    return "start";
  if (truncate === "end" || truncate)
    return "end";
}
const defaultProps$w = {
  inherit: !1
}, varsResolver$p = /* Will be removed in 9.0 */ /* eslint-disable-next-line @typescript-eslint/no-deprecated */ (theme, { variant, lineClamp, gradient, size: size2, color: color2 }) => ({
  root: {
    "--text-fz": getFontSize(size2),
    "--text-lh": getLineHeight(size2),
    "--text-gradient": variant === "gradient" ? getGradient(gradient, theme) : void 0,
    "--text-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
    "--text-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Text = polymorphicFactory((_props, ref) => {
  const props = useProps("Text", defaultProps$w, _props), {
    lineClamp,
    truncate,
    inline: inline2,
    inherit: inherit2,
    gradient,
    span,
    __staticSelector,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    variant,
    mod,
    size: size2,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["Text", __staticSelector],
    props,
    classes: classes$m,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$p
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root", { focusable: !0 }),
      ref,
      component: span ? "span" : "p",
      variant,
      mod: [
        {
          "data-truncate": getTextTruncate(truncate),
          "data-line-clamp": typeof lineClamp == "number",
          "data-inline": inline2,
          "data-inherit": inherit2
        },
        mod
      ],
      size: size2,
      ...others
    }
  );
});
Text.classes = classes$m;
Text.displayName = "@mantine/core/Text";
var classes$l = { root: "m_849cf0da" };
const defaultProps$v = {
  underline: "hover"
}, Anchor = polymorphicFactory((props, ref) => {
  const { underline, className, unstyled, mod, ...others } = useProps(
    "Anchor",
    defaultProps$v,
    props
  );
  return /* @__PURE__ */ jsx(
    Text,
    {
      component: "a",
      ref,
      className: clsx({ [classes$l.root]: !unstyled }, className),
      ...others,
      mod: [{ underline }, mod],
      __staticSelector: "Anchor",
      unstyled
    }
  );
});
Anchor.classes = classes$l;
Anchor.displayName = "@mantine/core/Anchor";
var classes$k = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2", optionsDropdownCheckPlaceholder: "m_a530ee0a" };
const defaultProps$u = {
  error: null
}, varsResolver$o = (theme, { size: size2, color: color2 }) => ({
  chevron: {
    "--combobox-chevron-size": getSize(size2, "combobox-chevron-size"),
    "--combobox-chevron-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), ComboboxChevron = factory((_props, ref) => {
  const props = useProps("ComboboxChevron", defaultProps$u, _props), { size: size2, error, style: style2, className, classNames, styles, unstyled, vars, mod, ...others } = props, getStyles2 = useStyles({
    name: "ComboboxChevron",
    classes: classes$k,
    props,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$o,
    rootSelector: "chevron"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "svg",
      ...others,
      ...getStyles2("chevron"),
      size: size2,
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      mod: ["combobox-chevron", { error }, mod],
      ref,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
});
ComboboxChevron.classes = classes$k;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";
const [ComboboxProvider, useComboboxContext] = createSafeContext$1(
  "Combobox component was not found in tree"
), ComboboxClearButton = forwardRef(
  ({ size: size2, onMouseDown, onClick, onClear, ...others }, ref) => /* @__PURE__ */ jsx(
    Input.ClearButton,
    {
      ref,
      tabIndex: -1,
      "aria-hidden": !0,
      ...others,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onClick: (event) => {
        onClear(), onClick?.(event);
      }
    }
  )
);
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";
const ComboboxDropdown = factory((props, ref) => {
  const { classNames, styles, className, style: style2, hidden: hidden2, ...others } = useProps(
    "ComboboxDropdown",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Popover.Dropdown,
    {
      ...others,
      ref,
      role: "presentation",
      "data-hidden": hidden2 || void 0,
      ...ctx.getStyles("dropdown", { className, style: style2, classNames, styles })
    }
  );
});
ComboboxDropdown.classes = classes$k;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";
const defaultProps$t = {
  refProp: "ref"
}, ComboboxDropdownTarget = factory((props, ref) => {
  const { children: children2, refProp } = useProps("ComboboxDropdownTarget", defaultProps$t, props);
  if (useComboboxContext(), !isElement$1(children2))
    throw new Error(
      "Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return /* @__PURE__ */ jsx(Popover.Target, { ref, refProp, children: children2 });
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";
const ComboboxEmpty = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxEmpty",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("empty", { className, classNames, styles, style: style2 }),
      ...others
    }
  );
});
ComboboxEmpty.classes = classes$k;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";
function useComboboxTargetProps({
  onKeyDown,
  withKeyboardNavigation,
  withAriaAttributes,
  withExpandedAttribute,
  targetType,
  autoComplete
}) {
  const ctx = useComboboxContext(), [selectedOptionId, setSelectedOptionId] = useState(null), handleKeyDown = (event) => {
    if (onKeyDown?.(event), !ctx.readOnly && withKeyboardNavigation) {
      if (event.nativeEvent.isComposing)
        return;
      if (event.nativeEvent.code === "ArrowDown" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectNextOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "ArrowUp" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectPreviousOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
        if (event.nativeEvent.keyCode === 229)
          return;
        const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
        ctx.store.dropdownOpened && selectedOptionIndex !== -1 ? (event.preventDefault(), ctx.store.clickSelectedOption()) : targetType === "button" && (event.preventDefault(), ctx.store.openDropdown("keyboard"));
      }
      event.key === "Escape" && ctx.store.closeDropdown("keyboard"), event.nativeEvent.code === "Space" && targetType === "button" && (event.preventDefault(), ctx.store.toggleDropdown("keyboard"));
    }
  };
  return {
    ...withAriaAttributes ? {
      "aria-haspopup": "listbox",
      "aria-expanded": withExpandedAttribute ? !!(ctx.store.listId && ctx.store.dropdownOpened) : void 0,
      "aria-controls": ctx.store.dropdownOpened && ctx.store.listId ? ctx.store.listId : void 0,
      "aria-activedescendant": ctx.store.dropdownOpened && selectedOptionId || void 0,
      autoComplete,
      "data-expanded": ctx.store.dropdownOpened || void 0,
      "data-mantine-stop-propagation": ctx.store.dropdownOpened || void 0
    } : {},
    onKeyDown: handleKeyDown
  };
}
const defaultProps$s = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxEventsTarget = factory((props, ref) => {
  const {
    children: children2,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxEventsTarget", defaultProps$s, props), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: child.props.onKeyDown,
    autoComplete
  });
  return cloneElement(child, {
    ...targetProps,
    ...others,
    [refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(child))
  });
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";
const ComboboxFooter = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxFooter",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("footer", { className, classNames, style: style2, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxFooter.classes = classes$k;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";
const ComboboxGroup = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, children: children2, label: label2, id: id2, ...others } = useProps(
    "ComboboxGroup",
    null,
    props
  ), ctx = useComboboxContext(), _id = useId$2(id2);
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ref,
      role: "group",
      "aria-labelledby": label2 ? _id : void 0,
      ...ctx.getStyles("group", { className, classNames, style: style2, styles }),
      ...others,
      children: [
        label2 && /* @__PURE__ */ jsx("div", { id: _id, ...ctx.getStyles("groupLabel", { classNames, styles }), children: label2 }),
        children2
      ]
    }
  );
});
ComboboxGroup.classes = classes$k;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";
const ComboboxHeader = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxHeader",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("header", { className, classNames, style: style2, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxHeader.classes = classes$k;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";
function ComboboxHiddenInput({
  value,
  valuesDivider = ",",
  ...others
}) {
  return /* @__PURE__ */ jsx(
    "input",
    {
      type: "hidden",
      value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
      ...others
    }
  );
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";
const ComboboxOption = factory((_props, ref) => {
  const props = useProps("ComboboxOption", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onClick,
    id: id2,
    active,
    onMouseDown,
    onMouseOver,
    disabled,
    selected: selected2,
    mod,
    ...others
  } = props, ctx = useComboboxContext(), uuid = useId$3(), _id = id2 || uuid;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...ctx.getStyles("option", { className, classNames, styles, style: style2 }),
      ...others,
      ref,
      id: _id,
      mod: [
        "combobox-option",
        { "combobox-active": active, "combobox-disabled": disabled, "combobox-selected": selected2 },
        mod
      ],
      role: "option",
      onClick: (event) => {
        disabled ? event.preventDefault() : (ctx.onOptionSubmit?.(props.value, props), onClick?.(event));
      },
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onMouseOver: (event) => {
        ctx.resetSelectionOnOptionHover && ctx.store.resetSelectedOption(), onMouseOver?.(event);
      }
    }
  );
});
ComboboxOption.classes = classes$k;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";
const ComboboxOptions = factory((_props, ref) => {
  const props = useProps("ComboboxOptions", null, _props), { classNames, className, style: style2, styles, id: id2, onMouseDown, labelledBy, ...others } = props, ctx = useComboboxContext(), _id = useId$2(id2);
  return useEffect(() => {
    ctx.store.setListId(_id);
  }, [_id]), /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("options", { className, style: style2, classNames, styles }),
      ...others,
      id: _id,
      role: "listbox",
      "aria-labelledby": labelledBy,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      }
    }
  );
});
ComboboxOptions.classes = classes$k;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";
const defaultProps$r = {
  withAriaAttributes: !0,
  withKeyboardNavigation: !0
}, ComboboxSearch = factory((_props, ref) => {
  const props = useProps("ComboboxSearch", defaultProps$r, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    withAriaAttributes,
    onKeyDown,
    withKeyboardNavigation,
    size: size2,
    ...others
  } = props, ctx = useComboboxContext(), _styles = ctx.getStyles("search"), targetProps = useComboboxTargetProps({
    targetType: "input",
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute: !1,
    onKeyDown,
    autoComplete: "off"
  });
  return /* @__PURE__ */ jsx(
    Input,
    {
      ref: useMergedRef(ref, ctx.store.searchRef),
      classNames: [{ input: _styles.className }, classNames],
      styles: [{ input: _styles.style }, styles],
      size: size2 || ctx.size,
      ...targetProps,
      ...others,
      __staticSelector: "Combobox"
    }
  );
});
ComboboxSearch.classes = classes$k;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";
const defaultProps$q = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxTarget = factory((props, ref) => {
  const {
    children: children2,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxTarget", defaultProps$q, props), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: child.props.onKeyDown,
    autoComplete
  }), clonedElement = cloneElement(child, {
    ...targetProps,
    ...others
  });
  return /* @__PURE__ */ jsx(Popover.Target, { ref: useMergedRef(ref, ctx.store.targetRef), children: clonedElement });
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";
function getPreviousIndex(currentIndex, elements, loop) {
  for (let i2 = currentIndex - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].hasAttribute("data-combobox-disabled"))
        return i2;
  }
  return currentIndex;
}
function getNextIndex(currentIndex, elements, loop) {
  for (let i2 = currentIndex + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].hasAttribute("data-combobox-disabled"))
        return i2;
  }
  return currentIndex;
}
function getFirstIndex(elements) {
  for (let i2 = 0; i2 < elements.length; i2 += 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  return -1;
}
function useCombobox({
  defaultOpened,
  opened,
  onOpenedChange,
  onDropdownClose,
  onDropdownOpen,
  loop = !0,
  scrollBehavior = "instant"
} = {}) {
  const [dropdownOpened, setDropdownOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange: onOpenedChange
  }), listId = useRef(null), selectedOptionIndex = useRef(-1), searchRef = useRef(null), targetRef = useRef(null), focusSearchTimeout = useRef(-1), focusTargetTimeout = useRef(-1), selectedIndexUpdateTimeout = useRef(-1), openDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened || (setDropdownOpened(!0), onDropdownOpen?.(eventSource));
    },
    [setDropdownOpened, onDropdownOpen, dropdownOpened]
  ), closeDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened && (setDropdownOpened(!1), onDropdownClose?.(eventSource));
    },
    [setDropdownOpened, onDropdownClose, dropdownOpened]
  ), toggleDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened ? closeDropdown(eventSource) : openDropdown(eventSource);
    },
    [closeDropdown, openDropdown, dropdownOpened]
  ), clearSelectedItem = useCallback(() => {
    const root2 = getRootElement(targetRef.current), selected2 = findElementBySelector(`#${listId.current} [data-combobox-selected]`, root2);
    selected2?.removeAttribute("data-combobox-selected"), selected2?.removeAttribute("aria-selected");
  }, []), selectOption = useCallback(
    (index2) => {
      const root2 = getRootElement(targetRef.current), list2 = findElementBySelector(`#${listId.current}`, root2), items = list2 ? findElementsBySelector("[data-combobox-option]", list2) : null;
      if (!items)
        return null;
      const nextIndex = index2 >= items.length ? 0 : index2 < 0 ? items.length - 1 : index2;
      return selectedOptionIndex.current = nextIndex, items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled") ? (clearSelectedItem(), items[nextIndex].setAttribute("data-combobox-selected", "true"), items[nextIndex].setAttribute("aria-selected", "true"), items[nextIndex].scrollIntoView({ block: "nearest", behavior: scrollBehavior }), items[nextIndex].id) : null;
    },
    [scrollBehavior, clearSelectedItem]
  ), selectActiveOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), activeOption = findElementBySelector(
      `#${listId.current} [data-combobox-active]`,
      root2
    );
    if (activeOption) {
      const index2 = findElementsBySelector(
        `#${listId.current} [data-combobox-option]`,
        root2
      ).findIndex((option) => option === activeOption);
      return selectOption(index2);
    }
    return selectOption(0);
  }, [selectOption]), selectNextOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    );
    return selectOption(getNextIndex(selectedOptionIndex.current, items, loop));
  }, [selectOption, loop]), selectPreviousOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    );
    return selectOption(getPreviousIndex(selectedOptionIndex.current, items, loop));
  }, [selectOption, loop]), selectFirstOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    );
    return selectOption(getFirstIndex(items));
  }, [selectOption]), updateSelectedOptionIndex = useCallback(
    (target = "selected", options) => {
      selectedIndexUpdateTimeout.current = window.setTimeout(() => {
        const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
          `#${listId.current} [data-combobox-option]`,
          root2
        ), index2 = items.findIndex((option) => option.hasAttribute(`data-combobox-${target}`));
        selectedOptionIndex.current = index2, options?.scrollIntoView && items[index2]?.scrollIntoView({ block: "nearest", behavior: scrollBehavior });
      }, 0);
    },
    []
  ), resetSelectedOption = useCallback(() => {
    selectedOptionIndex.current = -1, clearSelectedItem();
  }, [clearSelectedItem]), clickSelectedOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current);
    findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    )?.[selectedOptionIndex.current]?.click();
  }, []), setListId = useCallback((id2) => {
    listId.current = id2;
  }, []), focusSearchInput = useCallback(() => {
    focusSearchTimeout.current = window.setTimeout(() => searchRef.current?.focus(), 0);
  }, []), focusTarget = useCallback(() => {
    focusTargetTimeout.current = window.setTimeout(() => targetRef.current?.focus(), 0);
  }, []), getSelectedOptionIndex = useCallback(() => selectedOptionIndex.current, []);
  return useEffect(
    () => () => {
      window.clearTimeout(focusSearchTimeout.current), window.clearTimeout(focusTargetTimeout.current), window.clearTimeout(selectedIndexUpdateTimeout.current);
    },
    []
  ), {
    dropdownOpened,
    openDropdown,
    closeDropdown,
    toggleDropdown,
    selectedOptionIndex: selectedOptionIndex.current,
    getSelectedOptionIndex,
    selectOption,
    selectFirstOption,
    selectActiveOption,
    selectNextOption,
    selectPreviousOption,
    resetSelectedOption,
    updateSelectedOptionIndex,
    listId: listId.current,
    setListId,
    clickSelectedOption,
    searchRef,
    focusSearchInput,
    targetRef,
    focusTarget
  };
}
const defaultProps$p = {
  keepMounted: !0,
  withinPortal: !0,
  resetSelectionOnOptionHover: !1,
  width: "target",
  transitionProps: { transition: "fade", duration: 0 },
  size: "sm"
}, varsResolver$n = (_, { size: size2, dropdownPadding }) => ({
  options: {
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  },
  dropdown: {
    "--combobox-padding": dropdownPadding === void 0 ? void 0 : rem(dropdownPadding),
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  }
});
function Combobox(_props) {
  const props = useProps("Combobox", defaultProps$p, _props), {
    classNames,
    styles,
    unstyled,
    children: children2,
    store: controlledStore,
    vars,
    onOptionSubmit,
    onClose,
    size: size2,
    dropdownPadding,
    resetSelectionOnOptionHover,
    __staticSelector,
    readOnly,
    attributes,
    ...others
  } = props, uncontrolledStore = useCombobox(), store = controlledStore || uncontrolledStore, getStyles2 = useStyles({
    name: __staticSelector || "Combobox",
    classes: classes$k,
    props,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$n
  }), onDropdownClose = () => {
    onClose?.(), store.closeDropdown();
  };
  return /* @__PURE__ */ jsx(
    ComboboxProvider,
    {
      value: {
        getStyles: getStyles2,
        store,
        onOptionSubmit,
        size: size2,
        resetSelectionOnOptionHover,
        readOnly
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          opened: store.dropdownOpened,
          preventPositionChangeWhenVisible: !0,
          ...others,
          onChange: (_opened) => !_opened && onDropdownClose(),
          withRoles: !1,
          unstyled,
          children: children2
        }
      )
    }
  );
}
const extendCombobox = (c) => c;
Combobox.extend = extendCombobox;
Combobox.classes = classes$k;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;
function CheckIcon({ size: size2, style: style2, ...others }) {
  const _style = size2 !== void 0 ? { width: rem(size2), height: rem(size2), ...style2 } : style2;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: _style,
      "aria-hidden": !0,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
var classes$j = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const varsResolver$m = (theme, { radius, color: color2, gradient, variant, size: size2, autoContrast, circle }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--badge-height": getSize(size2, "badge-height"),
      "--badge-padding-x": getSize(size2, "badge-padding-x"),
      "--badge-fz": getSize(size2, "badge-fz"),
      "--badge-radius": circle || radius === void 0 ? void 0 : getRadius$1(radius),
      "--badge-bg": color2 || variant ? colors.background : void 0,
      "--badge-color": color2 || variant ? colors.color : void 0,
      "--badge-bd": color2 || variant ? colors.border : void 0,
      "--badge-dot-color": variant === "dot" ? getThemeColor(color2, theme) : void 0
    }
  };
}, Badge = polymorphicFactory((_props, ref) => {
  const props = useProps("Badge", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color: color2,
    gradient,
    leftSection,
    rightSection,
    children: children2,
    variant,
    fullWidth,
    autoContrast,
    circle,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Badge",
    props,
    classes: classes$j,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$m
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      variant,
      mod: [
        {
          block: fullWidth,
          circle,
          "with-right-section": !!rightSection,
          "with-left-section": !!leftSection
        },
        mod
      ],
      ...getStyles2("root", { variant }),
      ref,
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "left", children: leftSection }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "right", children: rightSection })
      ]
    }
  );
});
Badge.classes = classes$j;
Badge.displayName = "@mantine/core/Badge";
var classes$i = { root: "m_8b3717df", breadcrumb: "m_f678d540", separator: "m_3b8f2208" };
const defaultProps$o = {
  separator: "/"
}, varsResolver$l = (_, { separatorMargin }) => ({
  root: {
    "--bc-separator-margin": getSpacing(separatorMargin)
  }
}), Breadcrumbs = factory((_props, ref) => {
  const props = useProps("Breadcrumbs", defaultProps$o, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children: children2,
    separator,
    separatorMargin,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Breadcrumbs",
    classes: classes$i,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$l
  }), items = Children.toArray(children2).reduce((acc, child, index2, array2) => {
    const item = isElement$1(child) ? cloneElement(child, {
      ...getStyles2("breadcrumb", { className: child.props?.className }),
      key: index2
    }) : /* @__PURE__ */ createElement("div", { ...getStyles2("breadcrumb"), key: index2 }, child);
    return acc.push(item), index2 !== array2.length - 1 && acc.push(
      /* @__PURE__ */ createElement(Box$1, { ...getStyles2("separator"), key: `separator-${index2}` }, separator)
    ), acc;
  }, []);
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), ...others, children: items });
});
Breadcrumbs.classes = classes$i;
Breadcrumbs.displayName = "@mantine/core/Breadcrumbs";
var classes$h = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" };
const defaultProps$n = {
  orientation: "horizontal"
}, varsResolver$k = (_, { borderWidth }) => ({
  group: { "--button-border-width": rem(borderWidth) }
}), ButtonGroup = factory((_props, ref) => {
  const props = useProps("ButtonGroup", defaultProps$n, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    attributes,
    ...others
  } = useProps("ButtonGroup", defaultProps$n, _props), getStyles2 = useStyles({
    name: "ButtonGroup",
    props,
    classes: classes$h,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$k,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ButtonGroup.classes = classes$h;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
const varsResolver$j = (theme, { radius, color: color2, gradient, variant, autoContrast, size: size2 }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size2, "section-height"),
      "--section-padding-x": getSize(size2, "section-padding-x"),
      "--section-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--section-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--section-bg": color2 || variant ? colors.background : void 0,
      "--section-color": colors.color,
      "--section-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ButtonGroupSection = factory((_props, ref) => {
  const props = useProps("ButtonGroupSection", null, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "ButtonGroupSection",
    props,
    classes: classes$h,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$j,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ jsx(Box$1, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ButtonGroupSection.classes = classes$h;
ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection";
const loaderTransition = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, varsResolver$i = (theme, { radius, color: color2, gradient, variant, size: size2, justify, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--button-justify": justify,
      "--button-height": getSize(size2, "button-height"),
      "--button-padding-x": getSize(size2, "button-padding-x"),
      "--button-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--button-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--button-bg": color2 || variant ? colors.background : void 0,
      "--button-hover": color2 || variant ? colors.hover : void 0,
      "--button-color": colors.color,
      "--button-bd": color2 || variant ? colors.border : void 0,
      "--button-hover-color": color2 || variant ? colors.hoverColor : void 0
    }
  };
}, Button = polymorphicFactory((_props, ref) => {
  const props = useProps("Button", null, _props), {
    style: style2,
    vars,
    className,
    color: color2,
    disabled,
    children: children2,
    leftSection,
    rightSection,
    fullWidth,
    variant,
    radius,
    loading,
    loaderProps,
    gradient,
    classNames,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Button",
    props,
    classes: classes$h,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$i
  }), hasLeftSection = !!leftSection, hasRightSection = !!rightSection;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      unstyled,
      variant,
      disabled: disabled || loading,
      mod: [
        {
          disabled: disabled || dataDisabled,
          loading,
          block: fullWidth,
          "with-left-section": hasLeftSection,
          "with-right-section": hasRightSection
        },
        mod
      ],
      ...others,
      children: [
        typeof loading == "boolean" && /* @__PURE__ */ jsx(Transition, { mounted: loading, transition: loaderTransition, duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(
          Loader,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...loaderProps
          }
        ) }) }),
        /* @__PURE__ */ jsxs("span", { ...getStyles2("inner"), children: [
          leftSection && /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { loading }, ...getStyles2("label"), children: children2 }),
          rightSection && /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("section"), mod: { position: "right" }, children: rightSection })
        ] })
      ]
    }
  );
});
Button.classes = classes$h;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
Button.GroupSection = ButtonGroupSection;
const [CardProvider, useCardContext] = createSafeContext$1(
  "Card component was not found in tree"
);
var classes$g = { root: "m_e615b15f", section: "m_599a2148" };
const CardSection = polymorphicFactory((_props, ref) => {
  const props = useProps("CardSection", null, _props), { classNames, className, style: style2, styles, vars, withBorder, inheritPadding, mod, ...others } = props, ctx = useCardContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      mod: [{ "with-border": withBorder, "inherit-padding": inheritPadding }, mod],
      ...ctx.getStyles("section", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
CardSection.classes = classes$g;
CardSection.displayName = "@mantine/core/CardSection";
const varsResolver$h = (_, { padding }) => ({
  root: {
    "--card-padding": getSpacing(padding)
  }
}), Card = polymorphicFactory((_props, ref) => {
  const props = useProps("Card", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children: children2,
    padding,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Card",
    props,
    classes: classes$g,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$h
  }), _children = Children.toArray(children2), content = _children.map((child, index2) => typeof child == "object" && child && "type" in child && child.type === CardSection ? cloneElement(child, {
    "data-first-section": index2 === 0 || void 0,
    "data-last-section": index2 === _children.length - 1 || void 0
  }) : child);
  return /* @__PURE__ */ jsx(CardProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsx(Paper, { ref, unstyled, ...getStyles2("root"), ...others, children: content }) });
});
Card.classes = classes$g;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;
var classes$f = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" };
const defaultProps$m = {
  withShadow: !0
}, varsResolver$g = (_, { radius, size: size2 }) => ({
  root: {
    "--cs-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cs-size": rem(size2)
  }
}), ColorSwatch = polymorphicFactory((_props, ref) => {
  const props = useProps("ColorSwatch", defaultProps$m, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    size: size2,
    radius,
    withShadow,
    children: children2,
    variant,
    attributes,
    ...others
  } = useProps("ColorSwatch", defaultProps$m, props), getStyles2 = useStyles({
    name: "ColorSwatch",
    props,
    classes: classes$f,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$g
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ref,
      variant,
      size: size2,
      ...getStyles2("root", { focusable: !0 }),
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("alphaOverlay") }),
        withShadow && /* @__PURE__ */ jsx("span", { ...getStyles2("shadowOverlay") }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("colorOverlay", { style: { backgroundColor: color2 } }) }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("childrenOverlay"), children: children2 })
      ]
    }
  );
});
ColorSwatch.classes = classes$f;
ColorSwatch.displayName = "@mantine/core/ColorSwatch";
const defaultProps$l = {
  timeout: 1e3
};
function CopyButton(props) {
  const { children: children2, timeout: timeout2, value, ...others } = useProps("CopyButton", defaultProps$l, props), clipboard = useClipboard({ timeout: timeout2 });
  return /* @__PURE__ */ jsx(Fragment, { children: children2({ copy: () => clipboard.copy(value), copied: clipboard.copied, ...others }) });
}
CopyButton.displayName = "@mantine/core/CopyButton";
var classes$e = { root: "m_3eebeb36", label: "m_9e365f20" };
const defaultProps$k = {
  orientation: "horizontal"
}, varsResolver$f = (theme, { color: color2, variant, size: size2 }) => ({
  root: {
    "--divider-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--divider-border-style": variant,
    "--divider-size": getSize(size2, "divider-size")
  }
}), Divider$2 = factory((_props, ref) => {
  const props = useProps("Divider", defaultProps$k, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    orientation,
    label: label2,
    labelPosition,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Divider",
    classes: classes$e,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$f
  });
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      mod: [{ orientation, "with-label": !!label2 }, mod],
      ...getStyles2("root"),
      ...others,
      role: "separator",
      children: label2 && /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { position: labelPosition }, ...getStyles2("label"), children: label2 })
    }
  );
});
Divider$2.classes = classes$e;
Divider$2.displayName = "@mantine/core/Divider";
const [GridProvider, useGridContext] = createSafeContext$1(
  "Grid component was not found in tree"
), getColumnFlexBasis = (colSpan, columns) => colSpan === "content" ? "auto" : colSpan === "auto" ? "0rem" : colSpan ? `${100 / (columns / colSpan)}%` : void 0, getColumnMaxWidth = (colSpan, columns, grow) => grow || colSpan === "auto" ? "100%" : colSpan === "content" ? "unset" : getColumnFlexBasis(colSpan, columns), getColumnFlexGrow = (colSpan, grow) => {
  if (colSpan)
    return colSpan === "auto" || grow ? "1" : "auto";
}, getColumnOffset = (offset2, columns) => offset2 === 0 ? "0" : offset2 ? `${100 / (columns / offset2)}%` : void 0;
function GridColVariables({ span, order, offset: offset2, selector: selector3 }) {
  const theme = useMantineTheme(), ctx = useGridContext(), _breakpoints = ctx.breakpoints || theme.breakpoints, baseSpan = getBaseValue$1(span) === void 0 ? 12 : getBaseValue$1(span), baseStyles = filterProps$1({
    "--col-order": getBaseValue$1(order)?.toString(),
    "--col-flex-grow": getColumnFlexGrow(baseSpan, ctx.grow),
    "--col-flex-basis": getColumnFlexBasis(baseSpan, ctx.columns),
    "--col-width": baseSpan === "content" ? "auto" : void 0,
    "--col-max-width": getColumnMaxWidth(baseSpan, ctx.columns, ctx.grow),
    "--col-offset": getColumnOffset(getBaseValue$1(offset2), ctx.columns)
  }), queries = keys(_breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof order == "object" && order[breakpoint] !== void 0 && (acc[breakpoint]["--col-order"] = order[breakpoint]?.toString()), typeof span == "object" && span[breakpoint] !== void 0 && (acc[breakpoint]["--col-flex-grow"] = getColumnFlexGrow(span[breakpoint], ctx.grow), acc[breakpoint]["--col-flex-basis"] = getColumnFlexBasis(span[breakpoint], ctx.columns), acc[breakpoint]["--col-width"] = span[breakpoint] === "content" ? "auto" : void 0, acc[breakpoint]["--col-max-width"] = getColumnMaxWidth(
      span[breakpoint],
      ctx.columns,
      ctx.grow
    )), typeof offset2 == "object" && offset2[breakpoint] !== void 0 && (acc[breakpoint]["--col-offset"] = getColumnOffset(offset2[breakpoint], ctx.columns)), acc),
    {}
  ), values2 = getSortedBreakpoints(keys(queries), _breakpoints).filter(
    (breakpoint) => keys(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: ctx.type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(
    InlineStyles,
    {
      styles: baseStyles,
      media: ctx.type === "container" ? void 0 : values2,
      container: ctx.type === "container" ? values2 : void 0,
      selector: selector3
    }
  );
}
var classes$d = { container: "m_8478a6da", root: "m_410352e9", inner: "m_dee7bd2f", col: "m_96bdd299" };
const defaultProps$j = {
  span: 12
}, GridCol = factory((_props, ref) => {
  const props = useProps("GridCol", defaultProps$j, _props), { classNames, className, style: style2, styles, vars, span, order, offset: offset2, ...others } = props, ctx = useGridContext(), responsiveClassName = useRandomClassName();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      GridColVariables,
      {
        selector: `.${responsiveClassName}`,
        span,
        order,
        offset: offset2
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        ref,
        ...ctx.getStyles("col", {
          className: clsx(className, responsiveClassName),
          style: style2,
          classNames,
          styles
        }),
        ...others
      }
    )
  ] });
});
GridCol.classes = classes$d;
GridCol.displayName = "@mantine/core/GridCol";
function GridVariables({ gutter, selector: selector3, breakpoints, type }) {
  const theme = useMantineTheme(), _breakpoints = breakpoints || theme.breakpoints, baseStyles = filterProps$1({
    "--grid-gutter": getSpacing(getBaseValue$1(gutter))
  }), queries = keys(_breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof gutter == "object" && gutter[breakpoint] !== void 0 && (acc[breakpoint]["--grid-gutter"] = getSpacing(gutter[breakpoint])), acc),
    {}
  ), values2 = getSortedBreakpoints(keys(queries), _breakpoints).filter(
    (breakpoint) => keys(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(
    InlineStyles,
    {
      styles: baseStyles,
      media: type === "container" ? void 0 : values2,
      container: type === "container" ? values2 : void 0,
      selector: selector3
    }
  );
}
const defaultProps$i = {
  gutter: "md",
  grow: !1,
  columns: 12
}, varsResolver$e = (_, { justify, align, overflow }) => ({
  root: {
    "--grid-justify": justify,
    "--grid-align": align,
    "--grid-overflow": overflow
  }
}), Grid = factory((_props, ref) => {
  const props = useProps("Grid", defaultProps$i, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    grow,
    gutter,
    columns,
    align,
    justify,
    children: children2,
    breakpoints,
    type,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Grid",
    classes: classes$d,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$e
  }), responsiveClassName = useRandomClassName();
  return type === "container" && breakpoints ? /* @__PURE__ */ jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns, breakpoints, type }, children: [
    /* @__PURE__ */ jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ jsx("div", { ...getStyles2("inner"), children: children2 }) }) })
  ] }) : /* @__PURE__ */ jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns, breakpoints, type }, children: [
    /* @__PURE__ */ jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ jsx("div", { ...getStyles2("inner"), children: children2 }) })
  ] });
});
Grid.classes = classes$d;
Grid.displayName = "@mantine/core/Grid";
Grid.Col = GridCol;
function getMarkColor({ color: color2, theme, defaultShade }) {
  const parsed = parseThemeColor({ color: color2, theme });
  return parsed.isThemeColor ? parsed.shade === void 0 ? `var(--mantine-color-${parsed.color}-${defaultShade})` : `var(${parsed.variable})` : color2;
}
var classes$c = { root: "m_bcb3f3c2" };
const defaultProps$h = {
  color: "yellow"
}, varsResolver$d = (theme, { color: color2 }) => ({
  root: {
    "--mark-bg-dark": getMarkColor({ color: color2, theme, defaultShade: 5 }),
    "--mark-bg-light": getMarkColor({ color: color2, theme, defaultShade: 2 })
  }
}), Mark = factory((_props, ref) => {
  const props = useProps("Mark", defaultProps$h, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    variant,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Mark",
    props,
    className,
    style: style2,
    classes: classes$c,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$d
  });
  return /* @__PURE__ */ jsx(Box$1, { component: "mark", ref, variant, ...getStyles2("root"), ...others });
});
Mark.classes = classes$c;
Mark.displayName = "@mantine/core/Mark";
function escapeRegex(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function highlighter(value, _highlight) {
  if (_highlight == null)
    return [{ chunk: value, highlighted: !1 }];
  const highlight = Array.isArray(_highlight) ? _highlight.map(escapeRegex) : escapeRegex(_highlight);
  if (!(Array.isArray(highlight) ? highlight.filter((part) => part.trim().length > 0).length > 0 : highlight.trim() !== ""))
    return [{ chunk: value, highlighted: !1 }];
  const matcher2 = typeof highlight == "string" ? highlight.trim() : highlight.filter((part) => part.trim().length !== 0).map((part) => part.trim()).sort((a2, b2) => b2.length - a2.length).join("|"), re = new RegExp(`(${matcher2})`, "gi");
  return value.split(re).map((part) => ({ chunk: part, highlighted: re.test(part) })).filter(({ chunk }) => chunk);
}
const Highlight = polymorphicFactory((props, ref) => {
  const { unstyled, children: children2, highlight, highlightStyles, color: color2, ...others } = useProps(
    "Highlight",
    null,
    props
  ), highlightChunks = highlighter(children2, highlight);
  return /* @__PURE__ */ jsx(Text, { unstyled, ref, ...others, __staticSelector: "Highlight", children: highlightChunks.map(
    ({ chunk, highlighted }, i2) => highlighted ? /* @__PURE__ */ jsx(
      Mark,
      {
        unstyled,
        color: color2,
        style: highlightStyles,
        "data-highlight": chunk,
        children: chunk
      },
      i2
    ) : /* @__PURE__ */ jsx("span", { children: chunk }, i2)
  ) });
});
Highlight.classes = Text.classes;
Highlight.displayName = "@mantine/core/Highlight";
const [HoverCardContextProvider, useHoverCardContext] = createSafeContext$1(
  "HoverCard component was not found in the tree"
), HoverCardGroupContext = createContext(!1), HoverCardGroupProvider = HoverCardGroupContext.Provider, useHoverCardGroupContext = () => useContext(HoverCardGroupContext);
function HoverCardDropdown(props) {
  const { children: children2, onMouseEnter, onMouseLeave, ...others } = useProps(
    "HoverCardDropdown",
    null,
    props
  ), ctx = useHoverCardContext();
  if (useHoverCardGroupContext() && ctx.getFloatingProps && ctx.floating) {
    const floatingProps = ctx.getFloatingProps();
    return /* @__PURE__ */ jsx(
      Popover.Dropdown,
      {
        ref: ctx.floating,
        ...floatingProps,
        onMouseEnter: createEventHandler(onMouseEnter, floatingProps.onMouseEnter),
        onMouseLeave: createEventHandler(onMouseLeave, floatingProps.onMouseLeave),
        ...others,
        children: children2
      }
    );
  }
  const handleMouseEnter = createEventHandler(onMouseEnter, ctx.openDropdown), handleMouseLeave = createEventHandler(onMouseLeave, ctx.closeDropdown);
  return /* @__PURE__ */ jsx(Popover.Dropdown, { onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...others, children: children2 });
}
HoverCardDropdown.displayName = "@mantine/core/HoverCardDropdown";
const defaultProps$g = {
  openDelay: 0,
  closeDelay: 0
};
function HoverCardGroup(props) {
  const { openDelay, closeDelay, children: children2 } = useProps("HoverCardGroup", defaultProps$g, props);
  return /* @__PURE__ */ jsx(HoverCardGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children: children2 }) });
}
HoverCardGroup.displayName = "@mantine/core/HoverCardGroup";
HoverCardGroup.extend = (c) => c;
const defaultProps$f = {
  refProp: "ref"
}, HoverCardTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, eventPropsWrapperName, ...others } = useProps(
    "HoverCardTarget",
    defaultProps$f,
    props
  ), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useHoverCardContext();
  if (useHoverCardGroupContext() && ctx.getReferenceProps && ctx.reference) {
    const referenceProps = ctx.getReferenceProps();
    return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
      child,
      eventPropsWrapperName ? { [eventPropsWrapperName]: { ...referenceProps, ref: ctx.reference } } : { ...referenceProps, ref: ctx.reference }
    ) });
  }
  const onMouseEnter = createEventHandler(child.props.onMouseEnter, ctx.openDropdown), onMouseLeave = createEventHandler(child.props.onMouseLeave, ctx.closeDropdown), eventListeners = { onMouseEnter, onMouseLeave };
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
    child,
    eventPropsWrapperName ? { [eventPropsWrapperName]: eventListeners } : eventListeners
  ) });
});
HoverCardTarget.displayName = "@mantine/core/HoverCardTarget";
function useHoverCard(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useHoverCardGroupContext(), uid = useId$2(), openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = useCallback(() => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, []), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened ? (setCurrentId(uid), settings.onOpen?.()) : settings.onClose?.();
    },
    [uid, settings.onOpen, settings.onClose]
  ), { context: context2, refs } = useFloating({
    open: opened,
    onOpenChange: onChange
  }), { delay: groupDelay, setCurrentId } = useDelayGroup(context2, { id: uid }), { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context2, {
      enabled: !0,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay }
    }),
    useRole(context2, { role: "dialog" }),
    useDismiss(context2, { enabled: withinGroup })
  ]), openDropdown = useCallback(() => {
    withinGroup || (clearTimeouts(), settings.openDelay === 0 || settings.openDelay === void 0 ? onChange(!0) : openTimeout.current = window.setTimeout(() => onChange(!0), settings.openDelay));
  }, [withinGroup, clearTimeouts, settings.openDelay, onChange]), closeDropdown = useCallback(() => {
    withinGroup || (clearTimeouts(), settings.closeDelay === 0 || settings.closeDelay === void 0 ? onChange(!1) : closeTimeout.current = window.setTimeout(() => onChange(!1), settings.closeDelay));
  }, [withinGroup, clearTimeouts, settings.closeDelay, onChange]);
  return useEffect(() => () => clearTimeouts(), [clearTimeouts]), {
    opened,
    reference: refs.setReference,
    floating: refs.setFloating,
    getReferenceProps,
    getFloatingProps,
    openDropdown,
    closeDropdown
  };
}
const defaultProps$e = {
  openDelay: 0,
  closeDelay: 150,
  initiallyOpened: !1
};
function HoverCard(props) {
  const { children: children2, onOpen, onClose, openDelay, closeDelay, initiallyOpened, ...others } = useProps(
    "HoverCard",
    defaultProps$e,
    props
  ), hoverCard = useHoverCard({
    openDelay,
    closeDelay,
    defaultOpened: initiallyOpened,
    onOpen,
    onClose
  });
  return /* @__PURE__ */ jsx(
    HoverCardContextProvider,
    {
      value: {
        openDropdown: hoverCard.openDropdown,
        closeDropdown: hoverCard.closeDropdown,
        getReferenceProps: hoverCard.getReferenceProps,
        getFloatingProps: hoverCard.getFloatingProps,
        reference: hoverCard.reference,
        floating: hoverCard.floating
      },
      children: /* @__PURE__ */ jsx(Popover, { ...others, opened: hoverCard.opened, __staticSelector: "HoverCard", children: children2 })
    }
  );
}
HoverCard.displayName = "@mantine/core/HoverCard";
HoverCard.Target = HoverCardTarget;
HoverCard.Dropdown = HoverCardDropdown;
HoverCard.Group = HoverCardGroup;
HoverCard.extend = (input2) => input2;
var index = useLayoutEffect;
const [MenuContextProvider, useMenuContext] = createSafeContext$1(
  "Menu component was not found in the tree"
);
var classes$b = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504", chevron: "m_b85b0bed" };
const MenuDivider = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "MenuDivider",
    null,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("divider", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuDivider.classes = classes$b;
MenuDivider.displayName = "@mantine/core/MenuDivider";
const MenuDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children: children2,
    ...others
  } = useProps("MenuDropdown", null, props), wrapperRef = useRef(null), ctx = useMenuContext(), handleKeyDown = createEventHandler(onKeyDown, (event) => {
    (event.key === "ArrowUp" || event.key === "ArrowDown") && (event.preventDefault(), wrapperRef.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus());
  }), handleMouseEnter = createEventHandler(
    onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), handleMouseLeave = createEventHandler(
    onMouseLeave,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown()
  );
  return /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style: style2,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: handleKeyDown,
      children: [
        ctx.withInitialFocusPlaceholder && /* @__PURE__ */ jsx("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        children2
      ]
    }
  );
});
MenuDropdown.classes = classes$b;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";
const [SubMenuProvider, useSubMenuContext] = createOptionalContext(), MenuItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    color: color2,
    closeMenuOnClick,
    leftSection,
    rightSection,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    ...others
  } = useProps("MenuItem", null, props), ctx = useMenuContext(), subCtx = useSubMenuContext(), theme = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(null), _others = others, handleClick2 = createEventHandler(_others.onClick, () => {
    dataDisabled || (typeof closeMenuOnClick == "boolean" ? closeMenuOnClick && ctx.closeDropdownImmediately() : ctx.closeOnItemClick && ctx.closeDropdownImmediately());
  }), colors = color2 ? theme.variantColorResolver({ color: color2, theme, variant: "light" }) : void 0, parsedThemeColor = color2 ? parseThemeColor({ color: color2, theme }) : null, handleKeydown = createEventHandler(_others.onKeyDown, (event) => {
    event.key === "ArrowLeft" && subCtx && (subCtx.close(), subCtx.focusParentItem());
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      onMouseDown: (event) => event.preventDefault(),
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-disabled": disabled || dataDisabled || void 0,
      "data-mantine-stop-propagation": !0,
      onClick: handleClick2,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: handleKeydown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
        "--menu-item-hover": colors?.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection })
      ]
    }
  );
});
MenuItem.classes = classes$b;
MenuItem.displayName = "@mantine/core/MenuItem";
const MenuLabel = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "MenuLabel",
    null,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ref,
      ...ctx.getStyles("label", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuLabel.classes = classes$b;
MenuLabel.displayName = "@mantine/core/MenuLabel";
const MenuSubDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children: children2,
    ...others
  } = useProps("MenuSubDropdown", null, props), wrapperRef = useRef(null), ctx = useMenuContext(), subCtx = useSubMenuContext(), handleMouseEnter = createEventHandler(onMouseEnter, subCtx?.open), handleMouseLeave = createEventHandler(onMouseLeave, subCtx?.close);
  return /* @__PURE__ */ jsx(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style: style2,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      children: children2
    }
  );
});
MenuSubDropdown.classes = classes$b;
MenuSubDropdown.displayName = "@mantine/core/MenuSubDropdown";
const MenuSubItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    color: color2,
    leftSection,
    rightSection,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    closeMenuOnClick,
    ...others
  } = useProps("MenuSubItem", null, props), ctx = useMenuContext(), subCtx = useSubMenuContext(), theme = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(null), _others = others, colors = color2 ? theme.variantColorResolver({ color: color2, theme, variant: "light" }) : void 0, parsedThemeColor = color2 ? parseThemeColor({ color: color2, theme }) : null, handleKeydown = createEventHandler(_others.onKeyDown, (event) => {
    event.key === "ArrowRight" && (subCtx?.open(), subCtx?.focusFirstItem()), event.key === "ArrowLeft" && subCtx?.parentContext && (subCtx.parentContext.close(), subCtx.parentContext.focusParentItem());
  }), handleClick2 = createEventHandler(_others.onClick, () => {
    !dataDisabled && closeMenuOnClick && ctx.closeDropdownImmediately();
  }), handleMouseEnter = createEventHandler(_others.onMouseEnter, subCtx?.open), handleMouseLeave = createEventHandler(_others.onMouseLeave, subCtx?.close);
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      onMouseDown: (event) => event.preventDefault(),
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-sub-menu-item": !0,
      "data-disabled": disabled || dataDisabled || void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick2,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: handleKeydown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
        "--menu-item-hover": colors?.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children: children2 }),
        /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection || /* @__PURE__ */ jsx(AccordionChevron, { ...ctx.getStyles("chevron"), size: 14 }) })
      ]
    }
  );
});
MenuSubItem.classes = classes$b;
MenuSubItem.displayName = "@mantine/core/MenuSubItem";
function MenuSubTarget({ children: children2, refProp }) {
  if (!isElement$1(children2))
    throw new Error(
      "Menu.Sub.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return useMenuContext(), /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", children: children2 });
}
MenuSubTarget.displayName = "@mantine/core/MenuSubTarget";
const defaultProps$d = {
  offset: 0,
  position: "right-start",
  transitionProps: { duration: 0 },
  openDelay: 0,
  middlewares: {
    shift: {
      // Enable crossAxis shift to keep submenu dropdown within viewport bounds when positioned horizontally
      crossAxis: !0
    }
  }
};
function MenuSub(_props) {
  const { children: children2, closeDelay, openDelay, ...others } = useProps("MenuSub", defaultProps$d, _props), id2 = useId$2(), [opened, { open, close }] = useDisclosure(!1), ctx = useSubMenuContext(), { openDropdown, closeDropdown } = useDelayedHover({
    open,
    close,
    closeDelay,
    openDelay
  });
  return /* @__PURE__ */ jsx(
    SubMenuProvider,
    {
      value: {
        opened,
        close: closeDropdown,
        open: openDropdown,
        focusFirstItem: () => window.setTimeout(() => {
          document.getElementById(`${id2}-dropdown`)?.querySelectorAll("[data-menu-item]:not([data-disabled])")[0]?.focus();
        }, 16),
        focusParentItem: () => window.setTimeout(() => {
          document.getElementById(`${id2}-target`)?.focus();
        }, 16),
        parentContext: ctx
      },
      children: /* @__PURE__ */ jsx(Popover, { opened, withinPortal: !1, withArrow: !1, id: id2, ...others, children: children2 })
    }
  );
}
MenuSub.extend = (input2) => input2;
MenuSub.displayName = "@mantine/core/MenuSub";
MenuSub.Target = MenuSubTarget;
MenuSub.Dropdown = MenuSubDropdown;
MenuSub.Item = MenuSubItem;
const defaultProps$c = {
  refProp: "ref"
}, MenuTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, ...others } = useProps("MenuTarget", defaultProps$c, props), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useMenuContext(), _childProps = child.props, onClick = createEventHandler(_childProps.onClick, () => {
    ctx.trigger === "click" ? ctx.toggleDropdown() : ctx.trigger === "click-hover" && (ctx.setOpenedViaClick(!0), ctx.opened || ctx.openDropdown());
  }), onMouseEnter = createEventHandler(
    _childProps.onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), onMouseLeave = createEventHandler(_childProps.onMouseLeave, () => {
    (ctx.trigger === "hover" || ctx.trigger === "click-hover" && !ctx.openedViaClick) && ctx.closeDropdown();
  });
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", ref, ...others, children: cloneElement(child, {
    onClick,
    onMouseEnter,
    onMouseLeave,
    "data-expanded": ctx.opened ? !0 : void 0
  }) });
});
MenuTarget.displayName = "@mantine/core/MenuTarget";
const defaultProps$b = {
  trapFocus: !0,
  closeOnItemClick: !0,
  withInitialFocusPlaceholder: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function Menu(_props) {
  const props = useProps("Menu", defaultProps$b, _props), {
    children: children2,
    onOpen,
    onClose,
    opened,
    defaultOpened,
    trapFocus,
    onChange,
    closeOnItemClick,
    loop,
    closeOnEscape: closeOnEscape2,
    trigger,
    openDelay,
    closeDelay,
    classNames,
    styles,
    unstyled,
    variant,
    vars,
    menuItemTabIndex,
    keepMounted,
    withInitialFocusPlaceholder,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Menu",
    classes: classes$b,
    props,
    classNames,
    styles,
    unstyled,
    attributes
  }), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), [openedViaClick, setOpenedViaClick] = useState(!1), close = () => {
    setOpened(!1), setOpenedViaClick(!1), _opened && onClose?.();
  }, open = () => {
    setOpened(!0), !_opened && onOpen?.();
  }, toggleDropdown = () => {
    _opened ? close() : open();
  }, { openDropdown, closeDropdown } = useDelayedHover({ open, close, closeDelay, openDelay }), getItemIndex = (node2) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node2), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return /* @__PURE__ */ jsx(
    MenuContextProvider,
    {
      value: {
        getStyles: getStyles2,
        opened: _opened,
        toggleDropdown,
        getItemIndex,
        openedViaClick,
        setOpenedViaClick,
        closeOnItemClick,
        closeDropdown: trigger === "click" ? close : closeDropdown,
        openDropdown: trigger === "click" ? open : openDropdown,
        closeDropdownImmediately: close,
        loop,
        trigger,
        unstyled,
        menuItemTabIndex,
        withInitialFocusPlaceholder
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          returnFocus: !0,
          ...others,
          opened: _opened,
          onChange: toggleDropdown,
          defaultOpened,
          trapFocus: keepMounted ? !1 : trapFocus,
          closeOnEscape: closeOnEscape2,
          __staticSelector: "Menu",
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          variant,
          keepMounted,
          children: children2
        }
      )
    }
  );
}
Menu.extend = (input2) => input2;
Menu.withProps = getWithProps(Menu);
Menu.classes = classes$b;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
Menu.Sub = MenuSub;
const [PillsInputProvider, usePillsInputContext] = createOptionalContext(), [PillGroupProvider, usePillGroupContext] = createOptionalContext();
var classes$a = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };
const varsResolver$c = (_, { gap }, { size: size2 }) => ({
  group: {
    "--pg-gap": gap !== void 0 ? getSize(gap) : getSize(size2, "pg-gap")
  }
}), PillGroup = factory((_props, ref) => {
  const props = useProps("PillGroup", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    disabled,
    attributes,
    ...others
  } = props, _size = usePillsInputContext()?.size || size2 || void 0, getStyles2 = useStyles({
    name: "PillGroup",
    classes: classes$a,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$c,
    stylesCtx: { size: _size },
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(PillGroupProvider, { value: { size: _size, disabled }, children: /* @__PURE__ */ jsx(Box$1, { ref, size: _size, ...getStyles2("group"), ...others }) });
});
PillGroup.classes = classes$a;
PillGroup.displayName = "@mantine/core/PillGroup";
const defaultProps$a = {
  variant: "default"
}, varsResolver$b = (_, { radius }, { size: size2 }) => ({
  root: {
    "--pill-fz": getSize(size2, "pill-fz"),
    "--pill-height": getSize(size2, "pill-height"),
    "--pill-radius": radius === void 0 ? void 0 : getRadius$1(radius)
  }
}), Pill = factory((_props, ref) => {
  const props = useProps("Pill", defaultProps$a, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    variant,
    children: children2,
    withRemoveButton,
    onRemove: onRemove2,
    removeButtonProps,
    radius,
    size: size2,
    disabled,
    mod,
    attributes,
    ...others
  } = props, ctx = usePillGroupContext(), pillsInputCtx = usePillsInputContext(), _size = size2 || ctx?.size || void 0, _variant = pillsInputCtx?.variant === "filled" ? "contrast" : variant || "default", getStyles2 = useStyles({
    name: "Pill",
    classes: classes$a,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$b,
    stylesCtx: { size: _size }
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      component: "span",
      ref,
      variant: _variant,
      size: _size,
      ...getStyles2("root", { variant: _variant }),
      mod: [
        { "with-remove": withRemoveButton && !disabled, disabled: disabled || ctx?.disabled },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        withRemoveButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            variant: "transparent",
            radius,
            tabIndex: -1,
            "aria-hidden": !0,
            unstyled,
            ...removeButtonProps,
            ...getStyles2("remove", {
              className: removeButtonProps?.className,
              style: removeButtonProps?.style
            }),
            onMouseDown: (event) => {
              event.preventDefault(), event.stopPropagation(), removeButtonProps?.onMouseDown?.(event);
            },
            onClick: (event) => {
              event.stopPropagation(), onRemove2?.(), removeButtonProps?.onClick?.(event);
            }
          }
        )
      ]
    }
  );
});
Pill.classes = classes$a;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;
var classes$9 = { root: "m_f0824112", description: "m_57492dcc", section: "m_690090b5", label: "m_1f6ac4c4", body: "m_f07af9d2", children: "m_e17b862f", chevron: "m_1fd8a00b" };
const varsResolver$a = (theme, { variant, color: color2, childrenOffset, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--nl-bg": color2 || variant ? colors.background : void 0,
      "--nl-hover": color2 || variant ? colors.hover : void 0,
      "--nl-color": color2 || variant ? colors.color : void 0
    },
    children: {
      "--nl-offset": getSpacing(childrenOffset)
    }
  };
}, NavLink = polymorphicFactory((_props, ref) => {
  const props = useProps("NavLink", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    opened,
    defaultOpened,
    onChange,
    children: children2,
    active,
    disabled,
    leftSection,
    rightSection,
    label: label2,
    description: description2,
    disableRightSectionRotation,
    noWrap,
    childrenOffset,
    autoContrast,
    mod,
    attributes,
    onClick,
    onKeyDown,
    ...others
  } = props, getStyles2 = useStyles({
    name: "NavLink",
    props,
    classes: classes$9,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$a
  }), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), withChildren = !!children2, handleClick2 = (event) => {
    onClick?.(event), withChildren && (event.preventDefault(), setOpened(!_opened));
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        ...getStyles2("root"),
        component: "a",
        ref,
        onClick: handleClick2,
        onKeyDown: (event) => {
          onKeyDown?.(event), event.nativeEvent.code === "Space" && withChildren && (event.preventDefault(), setOpened(!_opened));
        },
        unstyled,
        mod: [{ disabled, active, expanded: _opened }, mod],
        ...others,
        children: [
          leftSection && /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsxs(Box$1, { ...getStyles2("body"), mod: { "no-wrap": noWrap }, children: [
            /* @__PURE__ */ jsx(Box$1, { component: "span", ...getStyles2("label"), children: label2 }),
            /* @__PURE__ */ jsx(Box$1, { component: "span", mod: { active }, ...getStyles2("description"), children: description2 })
          ] }),
          (withChildren || rightSection !== void 0) && /* @__PURE__ */ jsx(
            Box$1,
            {
              ...getStyles2("section"),
              component: "span",
              mod: { rotate: _opened && !disableRightSectionRotation, position: "right" },
              children: withChildren ? rightSection !== void 0 ? rightSection : /* @__PURE__ */ jsx(AccordionChevron, { ...getStyles2("chevron") }) : rightSection
            }
          )
        ]
      }
    ),
    withChildren && /* @__PURE__ */ jsx(Collapse, { in: _opened, ...getStyles2("collapse"), children: /* @__PURE__ */ jsx("div", { ...getStyles2("children"), children: children2 }) })
  ] });
});
NavLink.classes = classes$9;
NavLink.displayName = "@mantine/core/NavLink";
var classes$8 = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" };
const defaultProps$9 = {
  withCloseButton: !0
}, varsResolver$9 = (theme, { radius, color: color2 }) => ({
  root: {
    "--notification-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--notification-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Notification = factory((_props, ref) => {
  const props = useProps("Notification", defaultProps$9, _props), {
    className,
    color: color2,
    radius,
    loading,
    withCloseButton,
    withBorder,
    title: title2,
    icon: icon2,
    children: children2,
    onClose,
    closeButtonProps,
    classNames,
    style: style2,
    styles,
    unstyled,
    variant,
    vars,
    mod,
    loaderProps,
    role,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Notification",
    classes: classes$8,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$9
  });
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("root"),
      mod: [{ "data-with-icon": !!icon2 || loading, "data-with-border": withBorder }, mod],
      ref,
      variant,
      role: role || "alert",
      ...others,
      children: [
        icon2 && !loading && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon2 }),
        loading && /* @__PURE__ */ jsx(Loader, { size: 28, color: color2, ...loaderProps, ...getStyles2("loader") }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title2 && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), children: title2 }),
          /* @__PURE__ */ jsx(Box$1, { ...getStyles2("description"), mod: { "data-with-title": !!title2 }, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            iconSize: 16,
            color: "gray",
            ...closeButtonProps,
            unstyled,
            onClick: onClose,
            ...getStyles2("closeButton")
          }
        )
      ]
    }
  );
});
Notification.classes = classes$8;
Notification.displayName = "@mantine/core/Notification";
const defaultTransition = {
  duration: 100,
  transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
  return { ...defaultTransition, ...componentTransition, ...transitionProps };
}
function useFloatingTooltip({
  offset: offset2,
  position,
  defaultOpened
}) {
  const [opened, setOpened] = useState(defaultOpened), boundaryRef = useRef(null), { x: x2, y: y2, elements, refs, update, placement } = useFloating({
    placement: position,
    middleware: [
      shift({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), horizontalOffset = placement.includes("right") ? offset2 : position.includes("left") ? offset2 * -1 : 0, verticalOffset = placement.includes("bottom") ? offset2 : position.includes("top") ? offset2 * -1 : 0, handleMouseMove = useCallback(
    ({ clientX, clientY }) => {
      refs.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: clientX,
            y: clientY,
            left: clientX + horizontalOffset,
            top: clientY + verticalOffset,
            right: clientX,
            bottom: clientY
          };
        }
      });
    },
    [elements.reference]
  );
  return useEffect(() => {
    if (refs.floating.current) {
      const boundary = boundaryRef.current;
      boundary.addEventListener("mousemove", handleMouseMove);
      const parents = getOverflowAncestors(refs.floating.current);
      return parents.forEach((parent) => {
        parent.addEventListener("scroll", update);
      }), () => {
        boundary.removeEventListener("mousemove", handleMouseMove), parents.forEach((parent) => {
          parent.removeEventListener("scroll", update);
        });
      };
    }
  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]), { handleMouseMove, x: x2, y: y2, opened, setOpened, boundaryRef, floating: refs.setFloating };
}
var classes$7 = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
const defaultProps$8 = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  position: "right",
  zIndex: getDefaultZIndex("popover")
}, varsResolver$8 = (theme, { radius, color: color2 }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--tooltip-bg": color2 ? getThemeColor(color2, theme) : void 0,
    "--tooltip-color": color2 ? "var(--mantine-color-white)" : void 0
  }
}), TooltipFloating = factory((_props, ref) => {
  const props = useProps("TooltipFloating", defaultProps$8, _props), {
    children: children2,
    refProp,
    withinPortal,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    radius,
    color: color2,
    label: label2,
    offset: offset2,
    position,
    multiline,
    zIndex,
    disabled,
    defaultOpened,
    variant,
    vars,
    portalProps,
    attributes,
    ...others
  } = props, theme = useMantineTheme(), getStyles2 = useStyles({
    name: "TooltipFloating",
    props,
    classes: classes$7,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$8
  }), { handleMouseMove, x: x2, y: y2, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
    offset: offset2,
    position,
    defaultOpened
  }), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(boundaryRef, getRefProp(child), ref), childProps = child.props, onMouseEnter = (event) => {
    childProps.onMouseEnter?.(event), handleMouseMove(event), setOpened(!0);
  }, onMouseLeave = (event) => {
    childProps.onMouseLeave?.(event), setOpened(!1);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Box$1,
      {
        ...others,
        ...getStyles2("tooltip", {
          style: {
            ...getStyleObject(style2, theme),
            zIndex,
            display: !disabled && opened ? "block" : "none",
            top: (y2 && Math.round(y2)) ?? "",
            left: (x2 && Math.round(x2)) ?? ""
          }
        }),
        variant,
        ref: floating,
        mod: { multiline },
        children: label2
      }
    ) }),
    cloneElement(child, {
      ...childProps,
      [refProp]: targetRef,
      onMouseEnter,
      onMouseLeave
    })
  ] });
});
TooltipFloating.classes = classes$7;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";
const TooltipGroupContext = createContext(!1), TooltipGroupProvider = TooltipGroupContext.Provider, useTooltipGroupContext = () => useContext(TooltipGroupContext), defaultProps$7 = {
  openDelay: 0,
  closeDelay: 0
};
function TooltipGroup(props) {
  const { openDelay, closeDelay, children: children2 } = useProps("TooltipGroup", defaultProps$7, props);
  return /* @__PURE__ */ jsx(TooltipGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children: children2 }) });
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c) => c;
function getDefaultMiddlewares(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getTooltipMiddlewares(settings) {
  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares), middlewares = [offset(settings.offset)];
  return middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { padding: 8 } : { padding: 8, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewares.push(arrow({ element: settings.arrowRef, padding: settings.arrowOffset })), middlewaresOptions.inline ? middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ) : settings.inline && middlewares.push(inline()), middlewares;
}
function useTooltip(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useTooltipGroupContext(), uid = useId$2(), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened && setCurrentId(uid);
    },
    [uid]
  ), {
    x: x2,
    y: y2,
    context: context2,
    refs,
    placement,
    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
  } = useFloating({
    strategy: settings.strategy,
    placement: settings.position,
    open: opened,
    onOpenChange: onChange,
    middleware: getTooltipMiddlewares(settings),
    whileElementsMounted: autoUpdate
  }), { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context2, { id: uid }), { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context2, {
      enabled: settings.events?.hover,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },
      mouseOnly: !settings.events?.touch
    }),
    useFocus(context2, { enabled: settings.events?.focus, visibleOnly: !0 }),
    useRole(context2, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    useDismiss(context2, { enabled: typeof settings.opened > "u" })
  ]);
  useDidUpdate(() => {
    settings.onPositionChange?.(placement);
  }, [placement]);
  const isGroupPhase = opened && currentId && currentId !== uid;
  return {
    x: x2,
    y: y2,
    arrowX,
    arrowY,
    reference: refs.setReference,
    floating: refs.setFloating,
    getFloatingProps,
    getReferenceProps,
    isGroupPhase,
    opened,
    placement
  };
}
const defaultProps$6 = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: getDefaultZIndex("popover"),
  positionDependencies: [],
  middlewares: { flip: !0, shift: !0, inline: !1 }
}, varsResolver$7 = (theme, { radius, color: color2, variant, autoContrast }) => {
  const colors = theme.variantColorResolver({
    theme,
    color: color2 || theme.primaryColor,
    autoContrast,
    variant: variant || "filled"
  });
  return {
    tooltip: {
      "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--tooltip-bg": color2 ? colors.background : void 0,
      "--tooltip-color": color2 ? colors.color : void 0
    }
  };
}, Tooltip$6 = factory((_props, ref) => {
  const props = useProps("Tooltip", defaultProps$6, _props), {
    children: children2,
    position,
    refProp,
    label: label2,
    openDelay,
    closeDelay,
    onPositionChange,
    opened,
    defaultOpened,
    withinPortal,
    radius,
    color: color2,
    classNames,
    styles,
    unstyled,
    style: style2,
    className,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    offset: offset2,
    transitionProps,
    multiline,
    events,
    zIndex,
    disabled,
    // Scheduled for removal in 9.0
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionDependencies,
    onClick,
    onMouseEnter,
    onMouseLeave,
    inline: inline2,
    variant,
    keepMounted,
    vars,
    portalProps,
    mod,
    floatingStrategy,
    middlewares,
    autoContrast,
    attributes,
    target,
    ...others
  } = useProps("Tooltip", defaultProps$6, props), { dir } = useDirection(), arrowRef = useRef(null), tooltip = useTooltip({
    position: getFloatingPosition(dir, position),
    closeDelay,
    openDelay,
    onPositionChange,
    opened,
    defaultOpened,
    events,
    arrowRef,
    arrowOffset,
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    positionDependencies: [...positionDependencies, target ?? children2],
    inline: inline2,
    strategy: floatingStrategy,
    middlewares
  });
  useEffect(() => {
    const targetNode = target instanceof HTMLElement ? target : typeof target == "string" ? document.querySelector(target) : target?.current || null;
    targetNode && tooltip.reference(targetNode);
  }, [target, tooltip]);
  const getStyles2 = useStyles({
    name: "Tooltip",
    props,
    classes: classes$7,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$7
  }), child = getSingleElementChild(children2);
  if (!target && !child)
    return null;
  if (target) {
    const transition2 = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
    return /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition,
      {
        ...transition2,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition2.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box$1,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label2,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }) });
  }
  const childProps = child.props, targetRef = useMergedRef(tooltip.reference, getRefProp(child), ref), transition = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition,
      {
        ...transition,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box$1,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label2,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    cloneElement(
      child,
      tooltip.getReferenceProps({
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseMove: props.onMouseMove,
        onPointerDown: props.onPointerDown,
        onPointerEnter: props.onPointerEnter,
        ...childProps,
        className: clsx(className, childProps.className),
        [refProp]: targetRef
      })
    )
  ] });
});
Tooltip$6.classes = classes$7;
Tooltip$6.displayName = "@mantine/core/Tooltip";
Tooltip$6.Floating = TooltipFloating;
Tooltip$6.Group = TooltipGroup;
var classes$6 = { root: "m_cf365364", indicator: "m_9e182ccd", label: "m_1738fcb2", input: "m_1714d588", control: "m_69686b9b", innerLabel: "m_78882f40" };
const defaultProps$5 = {
  withItemsBorders: !0
}, varsResolver$6 = (theme, { radius, color: color2, transitionDuration, size: size2, transitionTimingFunction }) => ({
  root: {
    "--sc-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--sc-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--sc-shadow": color2 ? void 0 : "var(--mantine-shadow-xs)",
    "--sc-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--sc-transition-timing-function": transitionTimingFunction,
    "--sc-padding": getSize(size2, "sc-padding"),
    "--sc-font-size": getFontSize(size2)
  }
}), SegmentedControl = factory((_props, ref) => {
  const props = useProps("SegmentedControl", defaultProps$5, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    value,
    defaultValue,
    onChange,
    size: size2,
    name,
    disabled,
    readOnly,
    fullWidth,
    orientation,
    radius,
    color: color2,
    transitionDuration,
    transitionTimingFunction,
    variant,
    autoContrast,
    withItemsBorders,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SegmentedControl",
    props,
    classes: classes$6,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$6
  }), theme = useMantineTheme(), _data = data.map(
    (item) => typeof item == "string" ? { label: item, value: item } : item
  ), initialized = useMounted(), [key2, setKey] = useState(randomId()), [parent, setParent] = useState(null), [refs, setRefs] = useState({}), setElementRef = (element, val) => {
    refs[val] = element, setRefs(refs);
  }, [_value, handleValueChange] = useUncontrolled({
    value,
    defaultValue,
    finalValue: Array.isArray(data) ? _data.find((item) => !item.disabled)?.value ?? data[0]?.value ?? null : null,
    onChange
  }), uuid = useId$2(name), controls = _data.map((item) => /* @__PURE__ */ createElement(
    Box$1,
    {
      ...getStyles2("control"),
      mod: { active: _value === item.value, orientation },
      key: item.value
    },
    /* @__PURE__ */ createElement(
      "input",
      {
        ...getStyles2("input"),
        disabled: disabled || item.disabled,
        type: "radio",
        name: uuid,
        value: item.value,
        id: `${uuid}-${item.value}`,
        checked: _value === item.value,
        onChange: () => !readOnly && handleValueChange(item.value),
        "data-focus-ring": theme.focusRing,
        key: `${item.value}-input`
      }
    ),
    /* @__PURE__ */ createElement(
      Box$1,
      {
        component: "label",
        ...getStyles2("label"),
        mod: {
          active: _value === item.value && !(disabled || item.disabled),
          disabled: disabled || item.disabled,
          "read-only": readOnly
        },
        htmlFor: `${uuid}-${item.value}`,
        ref: (node2) => setElementRef(node2, item.value),
        __vars: {
          "--sc-label-color": color2 !== void 0 ? getContrastColor({ color: color2, theme, autoContrast }) : void 0
        },
        key: `${item.value}-label`
      },
      /* @__PURE__ */ jsx("span", { ...getStyles2("innerLabel"), children: item.label })
    )
  )), mergedRef = useMergedRef(ref, (node2) => setParent(node2));
  return useShallowEffect(() => {
    setKey(randomId());
  }, [data.length]), data.length === 0 ? null : /* @__PURE__ */ jsxs(
    Box$1,
    {
      ...getStyles2("root"),
      variant,
      size: size2,
      ref: mergedRef,
      mod: [
        {
          "full-width": fullWidth,
          orientation,
          initialized,
          "with-items-borders": withItemsBorders
        },
        mod
      ],
      ...others,
      role: "radiogroup",
      "data-disabled": disabled,
      children: [
        typeof _value == "string" && /* @__PURE__ */ jsx(
          FloatingIndicator,
          {
            target: refs[_value],
            parent,
            component: "span",
            transitionDuration: "var(--sc-transition-duration)",
            ...getStyles2("indicator")
          },
          key2
        ),
        controls
      ]
    }
  );
});
SegmentedControl.classes = classes$6;
SegmentedControl.displayName = "@mantine/core/SegmentedControl";
const [SliderProvider, useSliderContext] = createSafeContext$1(
  "SliderProvider was not found in tree"
), SliderRoot = forwardRef(
  ({ size: size2, disabled, variant, color: color2, thumbSize, radius, ...others }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext();
    return /* @__PURE__ */ jsx(
      Box$1,
      {
        tabIndex: -1,
        variant,
        size: size2,
        ref,
        ...getStyles2("root"),
        ...others
      }
    );
  }
);
SliderRoot.displayName = "@mantine/core/SliderRoot";
const Thumb = forwardRef(
  ({
    max: max2,
    min: min2,
    value,
    position,
    label: label2,
    dragging,
    onMouseDown,
    onKeyDownCapture,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    onFocus,
    onBlur,
    showLabelOnHover,
    isHovered,
    children: children2 = null,
    disabled
  }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext(), [focused2, setFocused] = useState(!1), isVisible = labelAlwaysOn || dragging || focused2 || showLabelOnHover && isHovered;
    return /* @__PURE__ */ jsxs(
      Box$1,
      {
        tabIndex: 0,
        role: "slider",
        "aria-label": thumbLabel,
        "aria-valuemax": max2,
        "aria-valuemin": min2,
        "aria-valuenow": value,
        ref,
        __vars: { "--slider-thumb-offset": `${position}%` },
        ...getStyles2("thumb", { focusable: !0 }),
        mod: { dragging, disabled },
        onFocus: (event) => {
          setFocused(!0), typeof onFocus == "function" && onFocus(event);
        },
        onBlur: (event) => {
          setFocused(!1), typeof onBlur == "function" && onBlur(event);
        },
        onTouchStart: onMouseDown,
        onMouseDown,
        onKeyDownCapture,
        onClick: (event) => event.stopPropagation(),
        children: [
          children2,
          /* @__PURE__ */ jsx(
            Transition,
            {
              mounted: label2 != null && !!isVisible,
              transition: "fade",
              duration: 0,
              ...labelTransitionProps,
              children: (transitionStyles) => /* @__PURE__ */ jsx("div", { ...getStyles2("label", { style: transitionStyles }), children: label2 })
            }
          )
        ]
      }
    );
  }
);
Thumb.displayName = "@mantine/core/SliderThumb";
function getPosition({ value, min: min2, max: max2 }) {
  const position = (value - min2) / (max2 - min2) * 100;
  return Math.min(Math.max(position, 0), 100);
}
function isMarkFilled({ mark, offset: offset2, value, inverted = !1 }) {
  return inverted ? typeof offset2 == "number" && mark.value <= offset2 || mark.value >= value : typeof offset2 == "number" ? mark.value >= offset2 && mark.value <= value : mark.value <= value;
}
function Marks({ marks, min: min2, max: max2, disabled, value, offset: offset2, inverted }) {
  const { getStyles: getStyles2 } = useSliderContext();
  if (!marks)
    return null;
  const items = marks.map((mark, index2) => /* @__PURE__ */ createElement(
    Box$1,
    {
      ...getStyles2("markWrapper"),
      __vars: { "--mark-offset": `${getPosition({ value: mark.value, min: min2, max: max2 })}%` },
      key: index2
    },
    /* @__PURE__ */ jsx(
      Box$1,
      {
        ...getStyles2("mark"),
        mod: { filled: isMarkFilled({ mark, value, offset: offset2, inverted }), disabled }
      }
    ),
    mark.label && /* @__PURE__ */ jsx("div", { ...getStyles2("markLabel"), children: mark.label })
  ));
  return /* @__PURE__ */ jsx("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";
function Track({
  filled,
  children: children2,
  offset: offset2,
  disabled,
  marksOffset,
  inverted,
  containerProps,
  ...others
}) {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ jsx(Box$1, { ...getStyles2("trackContainer"), mod: { disabled }, ...containerProps, children: /* @__PURE__ */ jsxs(Box$1, { ...getStyles2("track"), mod: { inverted, disabled }, children: [
    /* @__PURE__ */ jsx(
      Box$1,
      {
        mod: { inverted, disabled },
        __vars: {
          "--slider-bar-width": `calc(${filled}% + 2 * var(--slider-size))`,
          "--slider-bar-offset": `calc(${offset2}% - var(--slider-size))`
        },
        ...getStyles2("bar")
      }
    ),
    children2,
    /* @__PURE__ */ jsx(Marks, { ...others, offset: marksOffset, disabled, inverted })
  ] }) });
}
Track.displayName = "@mantine/core/SliderTrack";
function getChangeValue({
  value,
  containerWidth,
  min: min2,
  max: max2,
  step,
  precision
}) {
  const dx = (containerWidth ? Math.min(Math.max(value, 0), containerWidth) / containerWidth : value) * (max2 - min2), nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min2, nextValueWithinStep = Math.max(nextValue, min2);
  return precision !== void 0 ? Number(nextValueWithinStep.toFixed(precision)) : nextValueWithinStep;
}
function getFloatingValue(value, precision) {
  return parseFloat(value.toFixed(precision));
}
function getPrecision(step) {
  if (!step)
    return 0;
  const split = step.toString().split(".");
  return split.length > 1 ? split[1].length : 0;
}
function getNextMarkValue(currentValue, marks) {
  const nextMark = [...marks].sort((a2, b2) => a2.value - b2.value).find((mark) => mark.value > currentValue);
  return nextMark ? nextMark.value : currentValue;
}
function getPreviousMarkValue(currentValue, marks) {
  const previousMark = [...marks].sort((a2, b2) => b2.value - a2.value).find((mark) => mark.value < currentValue);
  return previousMark ? previousMark.value : currentValue;
}
function getFirstMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b2) => a2.value - b2.value);
  return sortedMarks.length > 0 ? sortedMarks[0].value : 0;
}
function getLastMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b2) => a2.value - b2.value);
  return sortedMarks.length > 0 ? sortedMarks[sortedMarks.length - 1].value : 100;
}
var classes$5 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };
const defaultProps$4 = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (f2) => f2,
  labelTransitionProps: { transition: "fade", duration: 0 },
  thumbLabel: "",
  showLabelOnHover: !0,
  scale: (v2) => v2,
  size: "md"
}, varsResolver$5 = (theme, { size: size2, color: color2, thumbSize, radius }) => ({
  root: {
    "--slider-size": getSize(size2, "slider-size"),
    "--slider-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--slider-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
  }
}), Slider = factory((_props, ref) => {
  const props = useProps("Slider", defaultProps$4, _props), {
    classNames,
    styles,
    value,
    onChange,
    onChangeEnd,
    size: size2,
    min: min2,
    max: max2,
    domain,
    step,
    precision: _precision,
    defaultValue,
    name,
    marks,
    label: label2,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    showLabelOnHover,
    thumbChildren,
    disabled,
    unstyled,
    scale: scale2,
    inverted,
    className,
    style: style2,
    vars,
    hiddenInputProps,
    restrictToMarks,
    thumbProps,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Slider",
    props,
    classes: classes$5,
    classNames,
    className,
    styles,
    style: style2,
    attributes,
    vars,
    varsResolver: varsResolver$5,
    unstyled
  }), { dir } = useDirection(), [hovered, setHovered2] = useState(!1), [_value, setValue] = useUncontrolled({
    value: typeof value == "number" ? clamp$3(value, min2, max2) : value,
    defaultValue: typeof defaultValue == "number" ? clamp$3(defaultValue, min2, max2) : defaultValue,
    finalValue: clamp$3(0, min2, max2),
    onChange
  }), valueRef = useRef(_value), onChangeEndRef = useRef(onChangeEnd);
  useEffect(() => {
    onChangeEndRef.current = onChangeEnd;
  }, [onChangeEnd]);
  const root2 = useRef(null), thumb = useRef(null), [domainMin, domainMax] = domain || [min2, max2], position = getPosition({ value: _value, min: domainMin, max: domainMax }), scaledValue = scale2(_value), _label = typeof label2 == "function" ? label2(scaledValue) : label2, precision = _precision ?? getPrecision(step), handleChange = useCallback(
    ({ x: x2 }) => {
      if (!disabled) {
        const nextValue = getChangeValue({
          value: x2,
          min: domainMin,
          max: domainMax,
          step,
          precision
        }), clampedValue = clamp$3(nextValue, min2, max2);
        setValue(
          restrictToMarks && marks?.length ? findClosestNumber(
            clampedValue,
            marks.map((mark) => mark.value)
          ) : clampedValue
        ), valueRef.current = clampedValue;
      }
    },
    [disabled, min2, max2, domainMin, domainMax, step, precision, setValue, marks, restrictToMarks]
  ), handleScrubEnd = useCallback(() => {
    if (!disabled && onChangeEndRef.current) {
      const finalValue = restrictToMarks && marks?.length ? findClosestNumber(
        valueRef.current,
        marks.map((mark) => mark.value)
      ) : valueRef.current;
      onChangeEndRef.current(finalValue);
    }
  }, [disabled, marks, restrictToMarks]), { ref: container2, active } = useMove(handleChange, { onScrubEnd: handleScrubEnd }, dir), callOnChangeEnd = useCallback(
    (value2) => {
      !disabled && onChangeEndRef.current && onChangeEndRef.current(value2);
    },
    [disabled]
  ), handleTrackKeydownCapture = (event) => {
    if (!disabled)
      switch (event.key) {
        case "ArrowUp": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = getNextMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value + step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowRight": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getPreviousMarkValue(_value, marks) : getNextMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowDown": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = getPreviousMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value - step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowLeft": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getNextMarkValue(_value, marks) : getPreviousMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "Home": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            setValue(getFirstMarkValue(marks)), callOnChangeEnd(getFirstMarkValue(marks));
            break;
          }
          setValue(min2), callOnChangeEnd(min2);
          break;
        }
        case "End": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            setValue(getLastMarkValue(marks)), callOnChangeEnd(getLastMarkValue(marks));
            break;
          }
          setValue(max2), callOnChangeEnd(max2);
          break;
        }
      }
  };
  return /* @__PURE__ */ jsx(SliderProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsxs(
    SliderRoot,
    {
      ...others,
      ref: useMergedRef(ref, root2),
      onKeyDownCapture: handleTrackKeydownCapture,
      onMouseDownCapture: () => root2.current?.focus(),
      size: size2,
      disabled,
      children: [
        /* @__PURE__ */ jsx(
          Track,
          {
            inverted,
            offset: 0,
            filled: position,
            marks,
            min: domainMin,
            max: domainMax,
            value: scaledValue,
            disabled,
            containerProps: {
              ref: container2,
              onMouseEnter: showLabelOnHover ? () => setHovered2(!0) : void 0,
              onMouseLeave: showLabelOnHover ? () => setHovered2(!1) : void 0
            },
            children: /* @__PURE__ */ jsx(
              Thumb,
              {
                max: domainMax,
                min: domainMin,
                value: scaledValue,
                position,
                dragging: active,
                label: _label,
                ref: thumb,
                labelTransitionProps,
                labelAlwaysOn,
                thumbLabel,
                showLabelOnHover,
                isHovered: hovered,
                disabled,
                ...thumbProps,
                children: thumbChildren
              }
            )
          }
        ),
        /* @__PURE__ */ jsx("input", { type: "hidden", name, value: scaledValue, ...hiddenInputProps })
      ]
    }
  ) });
});
Slider.classes = classes$5;
Slider.displayName = "@mantine/core/Slider";
const Space = factory((props, ref) => {
  const { w: w2, h: h2, miw, mih, ...others } = useProps("Space", null, props);
  return /* @__PURE__ */ jsx(Box$1, { ref, ...others, w: w2, miw: miw ?? w2, h: h2, mih: mih ?? h2 });
});
Space.displayName = "@mantine/core/Space";
var classes$4 = { root: "m_6d731127" };
const defaultProps$3 = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, varsResolver$4 = (_, { gap, align, justify }) => ({
  root: {
    "--stack-gap": getSpacing(gap),
    "--stack-align": align,
    "--stack-justify": justify
  }
}), Stack = factory((_props, ref) => {
  const props = useProps("Stack", defaultProps$3, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    align,
    justify,
    gap,
    variant,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Stack",
    props,
    classes: classes$4,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$4
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), variant, ...others });
});
Stack.classes = classes$4;
Stack.displayName = "@mantine/core/Stack";
const [TabsProvider, useTabsContext] = createSafeContext$1(
  "Tabs component was not found in the tree"
);
var classes$3 = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", tab: "m_4ec4dce6", panel: "m_b0c91715", tabSection: "m_fc420b1f", tabLabel: "m_42bbd1ae", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const TabsList = factory((_props, ref) => {
  const props = useProps("TabsList", null, _props), { children: children2, className, grow, justify, classNames, styles, style: style2, mod, ...others } = props, ctx = useTabsContext();
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...others,
      ...ctx.getStyles("list", {
        className,
        style: style2,
        classNames,
        styles,
        props,
        variant: ctx.variant
      }),
      ref,
      role: "tablist",
      variant: ctx.variant,
      mod: [
        {
          grow,
          orientation: ctx.orientation,
          placement: ctx.orientation === "vertical" && ctx.placement,
          inverted: ctx.inverted
        },
        mod
      ],
      "aria-orientation": ctx.orientation,
      __vars: { "--tabs-justify": justify },
      children: children2
    }
  );
});
TabsList.classes = classes$3;
TabsList.displayName = "@mantine/core/TabsList";
const TabsPanel = factory((_props, ref) => {
  const props = useProps("TabsPanel", null, _props), { children: children2, className, value, classNames, styles, style: style2, mod, keepMounted, ...others } = props, ctx = useTabsContext(), active = ctx.value === value, content = ctx.keepMounted || keepMounted || active ? children2 : null;
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      ...ctx.getStyles("panel", {
        className,
        classNames,
        styles,
        style: [style2, active ? void 0 : { display: "none" }],
        props
      }),
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      role: "tabpanel",
      id: ctx.getPanelId(value),
      "aria-labelledby": ctx.getTabId(value),
      ...others,
      children: content
    }
  );
});
TabsPanel.classes = classes$3;
TabsPanel.displayName = "@mantine/core/TabsPanel";
const TabsTab = factory((_props, ref) => {
  const props = useProps("TabsTab", null, _props), {
    className,
    children: children2,
    rightSection,
    leftSection,
    value,
    onClick,
    onKeyDown,
    disabled,
    color: color2,
    style: style2,
    classNames,
    styles,
    vars,
    mod,
    tabIndex,
    ...others
  } = props, theme = useMantineTheme(), { dir } = useDirection(), ctx = useTabsContext(), active = value === ctx.value, activateTab = (event) => {
    ctx.onChange(ctx.allowTabDeactivation && value === ctx.value ? null : value), onClick?.(event);
  }, stylesApiProps = { classNames, styles, props };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...ctx.getStyles("tab", { className, style: style2, variant: ctx.variant, ...stylesApiProps }),
      disabled,
      unstyled: ctx.unstyled,
      variant: ctx.variant,
      mod: [
        {
          active,
          disabled,
          orientation: ctx.orientation,
          inverted: ctx.inverted,
          placement: ctx.orientation === "vertical" && ctx.placement
        },
        mod
      ],
      ref,
      role: "tab",
      id: ctx.getTabId(value),
      "aria-selected": active,
      tabIndex: tabIndex !== void 0 ? tabIndex : active || ctx.value === null ? 0 : -1,
      "aria-controls": ctx.getPanelId(value),
      onClick: activateTab,
      __vars: { "--tabs-color": color2 ? getThemeColor(color2, theme) : void 0 },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: ctx.activateTabWithKeyboard,
        loop: ctx.loop,
        orientation: ctx.orientation || "horizontal",
        dir,
        onKeyDown
      }),
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabLabel", stylesApiProps), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "right", children: rightSection })
      ]
    }
  );
});
TabsTab.classes = classes$3;
TabsTab.displayName = "@mantine/core/TabsTab";
const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", defaultProps$2 = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  variant: "default",
  placement: "left"
}, varsResolver$3 = (theme, { radius, color: color2, autoContrast }) => ({
  root: {
    "--tabs-radius": getRadius$1(radius),
    "--tabs-color": getThemeColor(color2, theme),
    "--tabs-text-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({ color: color2, theme, autoContrast }) : void 0
  }
}), Tabs = factory((_props, ref) => {
  const props = useProps("Tabs", defaultProps$2, _props), {
    defaultValue,
    value,
    onChange,
    orientation,
    children: children2,
    loop,
    id: id2,
    activateTabWithKeyboard,
    allowTabDeactivation,
    variant,
    color: color2,
    radius,
    inverted,
    placement,
    keepMounted,
    classNames,
    styles,
    unstyled,
    className,
    style: style2,
    vars,
    autoContrast,
    mod,
    attributes,
    ...others
  } = props, uid = useId$2(id2), [currentTab, setCurrentTab] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), getStyles2 = useStyles({
    name: "Tabs",
    props,
    classes: classes$3,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$3
  });
  return /* @__PURE__ */ jsx(
    TabsProvider,
    {
      value: {
        placement,
        value: currentTab,
        orientation,
        id: uid,
        loop,
        activateTabWithKeyboard,
        getTabId: getSafeId(`${uid}-tab`, VALUE_ERROR),
        getPanelId: getSafeId(`${uid}-panel`, VALUE_ERROR),
        onChange: setCurrentTab,
        allowTabDeactivation,
        variant,
        color: color2,
        radius,
        inverted,
        keepMounted,
        unstyled,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box$1,
        {
          ref,
          id: uid,
          variant,
          mod: [
            {
              orientation,
              inverted: orientation === "horizontal" && inverted,
              placement: orientation === "vertical" && placement
            },
            mod
          ],
          ...getStyles2("root"),
          ...others,
          children: children2
        }
      )
    }
  );
});
Tabs.classes = classes$3;
Tabs.displayName = "@mantine/core/Tabs";
Tabs.Tab = TabsTab;
Tabs.Panel = TabsPanel;
Tabs.List = TabsList;
var classes$2 = { root: "m_7341320d" };
const varsResolver$2 = (theme, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ti-size": getSize(size2, "ti-size"),
      "--ti-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ti-bg": color2 || variant ? colors.background : void 0,
      "--ti-color": color2 || variant ? colors.color : void 0,
      "--ti-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ThemeIcon = factory((_props, ref) => {
  const props = useProps("ThemeIcon", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    autoContrast,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "ThemeIcon",
    classes: classes$2,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$2
  });
  return /* @__PURE__ */ jsx(Box$1, { ref, ...getStyles2("root"), ...others });
});
ThemeIcon.classes = classes$2;
ThemeIcon.displayName = "@mantine/core/ThemeIcon";
const headings = ["h1", "h2", "h3", "h4", "h5", "h6"], sizes = ["xs", "sm", "md", "lg", "xl"];
function getTitleSize(order, size2) {
  const titleSize = size2 !== void 0 ? size2 : `h${order}`;
  return headings.includes(titleSize) ? {
    fontSize: `var(--mantine-${titleSize}-font-size)`,
    fontWeight: `var(--mantine-${titleSize}-font-weight)`,
    lineHeight: `var(--mantine-${titleSize}-line-height)`
  } : sizes.includes(titleSize) ? {
    fontSize: `var(--mantine-font-size-${titleSize})`,
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  } : {
    fontSize: rem(titleSize),
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  };
}
var classes$1 = { root: "m_8a5d1357" };
const defaultProps$1 = {
  order: 1
}, varsResolver$1 = (_, { order, size: size2, lineClamp, textWrap }) => {
  const sizeVariables = getTitleSize(order || 1, size2);
  return {
    root: {
      "--title-fw": sizeVariables.fontWeight,
      "--title-lh": sizeVariables.lineHeight,
      "--title-fz": sizeVariables.fontSize,
      "--title-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
      "--title-text-wrap": textWrap
    }
  };
}, Title$1 = factory((_props, ref) => {
  const props = useProps("Title", defaultProps$1, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    order,
    vars,
    size: size2,
    variant,
    lineClamp,
    textWrap,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Title",
    props,
    classes: classes$1,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$1
  });
  return [1, 2, 3, 4, 5, 6].includes(order) ? /* @__PURE__ */ jsx(
    Box$1,
    {
      ...getStyles2("root"),
      component: `h${order}`,
      variant,
      ref,
      mod: [{ order, "data-line-clamp": typeof lineClamp == "number" }, mod],
      size: size2,
      ...others
    }
  ) : null;
});
Title$1.classes = classes$1;
Title$1.displayName = "@mantine/core/Title";
function getValuesRange(anchor, value, flatValues) {
  if (!anchor || !value)
    return [];
  const anchorIndex = flatValues.indexOf(anchor), valueIndex = flatValues.indexOf(value), start2 = Math.min(anchorIndex, valueIndex), end = Math.max(anchorIndex, valueIndex);
  return flatValues.slice(start2, end + 1);
}
function TreeNode({
  node: node2,
  getStyles: getStyles2,
  rootIndex,
  controller,
  expandOnClick,
  selectOnClick,
  isSubtree,
  level = 1,
  renderNode,
  flatValues,
  allowRangeSelection,
  expandOnSpace,
  checkOnSpace
}) {
  const ref = useRef(null), nested = (node2.children || []).map((child) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: child,
      flatValues,
      getStyles: getStyles2,
      rootIndex: void 0,
      level: level + 1,
      controller,
      expandOnClick,
      isSubtree: !0,
      renderNode,
      selectOnClick,
      allowRangeSelection,
      expandOnSpace,
      checkOnSpace
    },
    child.value
  )), handleKeyDown = (event) => {
    if (event.nativeEvent.code === "ArrowRight" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node2.value] ? event.currentTarget.querySelector("[role=treeitem]")?.focus() : controller.expand(node2.value)), event.nativeEvent.code === "ArrowLeft" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node2.value] && (node2.children || []).length > 0 ? controller.collapse(node2.value) : isSubtree && findElementAncestor(event.currentTarget, "[role=treeitem]")?.focus()), event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
      const root2 = findElementAncestor(event.currentTarget, "[data-tree-root]");
      if (!root2)
        return;
      event.stopPropagation(), event.preventDefault();
      const nodes = Array.from(root2.querySelectorAll("[role=treeitem]")), index2 = nodes.indexOf(event.currentTarget);
      if (index2 === -1)
        return;
      const nextIndex = event.nativeEvent.code === "ArrowDown" ? index2 + 1 : index2 - 1;
      if (nodes[nextIndex]?.focus(), event.shiftKey) {
        const selectNode = nodes[nextIndex];
        selectNode && controller.setSelectedState(
          getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues)
        );
      }
    }
    event.nativeEvent.code === "Space" && (expandOnSpace && (event.stopPropagation(), event.preventDefault(), controller.toggleExpanded(node2.value)), checkOnSpace && (event.stopPropagation(), event.preventDefault(), controller.isNodeChecked(node2.value) ? controller.uncheckNode(node2.value) : controller.checkNode(node2.value)));
  }, handleNodeClick2 = (event) => {
    event.stopPropagation(), allowRangeSelection && event.shiftKey && controller.anchorNode ? (controller.setSelectedState(getValuesRange(controller.anchorNode, node2.value, flatValues)), ref.current?.focus()) : (expandOnClick && controller.toggleExpanded(node2.value), selectOnClick && controller.select(node2.value), ref.current?.focus());
  }, selected2 = controller.selectedState.includes(node2.value), elementProps = {
    ...getStyles2("label"),
    onClick: handleNodeClick2,
    "data-selected": selected2 || void 0,
    "data-value": node2.value,
    "data-hovered": controller.hoveredNode === node2.value || void 0
  };
  return /* @__PURE__ */ jsxs(
    "li",
    {
      ...getStyles2("node", {
        style: { "--label-offset": `calc(var(--level-offset) * ${level - 1})` }
      }),
      role: "treeitem",
      "aria-selected": selected2,
      "data-value": node2.value,
      "data-selected": selected2 || void 0,
      "data-hovered": controller.hoveredNode === node2.value || void 0,
      "data-level": level,
      tabIndex: rootIndex === 0 ? 0 : -1,
      onKeyDown: handleKeyDown,
      ref,
      onMouseOver: (event) => {
        event.stopPropagation(), controller.setHoveredNode(node2.value);
      },
      onMouseLeave: (event) => {
        event.stopPropagation(), controller.setHoveredNode(null);
      },
      children: [
        typeof renderNode == "function" ? renderNode({
          node: node2,
          level,
          selected: selected2,
          tree: controller,
          expanded: controller.expandedState[node2.value] || !1,
          hasChildren: Array.isArray(node2.children) && node2.children.length > 0,
          elementProps
        }) : /* @__PURE__ */ jsx("div", { ...elementProps, children: node2.label }),
        controller.expandedState[node2.value] && nested.length > 0 && /* @__PURE__ */ jsx(Box$1, { component: "ul", role: "group", ...getStyles2("subtree"), "data-level": level, children: nested })
      ]
    }
  );
}
TreeNode.displayName = "@mantine/core/TreeNode";
function getAllCheckedNodes(data, checkedState, acc = []) {
  const currentTreeChecked = [];
  for (const node2 of data)
    if (Array.isArray(node2.children) && node2.children.length > 0) {
      const innerChecked = getAllCheckedNodes(node2.children, checkedState, acc);
      if (innerChecked.currentTreeChecked.length === node2.children.length) {
        const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked), item = {
          checked: isChecked,
          indeterminate: !isChecked,
          value: node2.value,
          hasChildren: !0
        };
        currentTreeChecked.push(item), acc.push(item);
      } else if (innerChecked.currentTreeChecked.length > 0) {
        const item = { checked: !1, indeterminate: !0, value: node2.value, hasChildren: !0 };
        currentTreeChecked.push(item), acc.push(item);
      }
    } else if (checkedState.includes(node2.value)) {
      const item = {
        checked: !0,
        indeterminate: !1,
        value: node2.value,
        hasChildren: !1
      };
      currentTreeChecked.push(item), acc.push(item);
    }
  return { result: acc, currentTreeChecked };
}
function findTreeNode(value, data) {
  for (const node2 of data) {
    if (node2.value === value)
      return node2;
    if (Array.isArray(node2.children)) {
      const childNode = findTreeNode(value, node2.children);
      if (childNode)
        return childNode;
    }
  }
  return null;
}
function getChildrenNodesValues(value, data, acc = []) {
  const node2 = findTreeNode(value, data);
  return node2 ? !Array.isArray(node2.children) || node2.children.length === 0 ? [node2.value] : (node2.children.forEach((child) => {
    Array.isArray(child.children) && child.children.length > 0 ? getChildrenNodesValues(child.value, data, acc) : acc.push(child.value);
  }), acc) : acc;
}
function getAllChildrenNodes(data) {
  return data.reduce((acc, node2) => (Array.isArray(node2.children) && node2.children.length > 0 ? acc.push(...getAllChildrenNodes(node2.children)) : acc.push(node2.value), acc), []);
}
function isNodeChecked(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : checkedState.includes(value) ? !0 : getAllCheckedNodes(data, checkedState).result.some((node2) => node2.value === value && node2.checked);
}
const memoizedIsNodeChecked = memoize(isNodeChecked);
function isNodeIndeterminate(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : getAllCheckedNodes(data, checkedState).result.some((node2) => node2.value === value && node2.indeterminate);
}
const memoizedIsNodeIndeterminate = memoize(isNodeIndeterminate);
function getInitialTreeExpandedState(initialState2, data, value, acc = {}) {
  return data.forEach((node2) => {
    acc[node2.value] = node2.value in initialState2 ? initialState2[node2.value] : node2.value === value, Array.isArray(node2.children) && getInitialTreeExpandedState(initialState2, node2.children, value, acc);
  }), acc;
}
function getInitialCheckedState(initialState2, data) {
  const acc = [];
  return initialState2.forEach((node2) => acc.push(...getChildrenNodesValues(node2, data))), Array.from(new Set(acc));
}
function useTree({
  initialSelectedState = [],
  initialCheckedState = [],
  initialExpandedState = {},
  multiple = !1,
  onNodeCollapse,
  onNodeExpand
} = {}) {
  const [data, setData2] = useState([]), [expandedState, setExpandedState] = useState(initialExpandedState), [selectedState, setSelectedState] = useState(initialSelectedState), [checkedState, setCheckedState] = useState(initialCheckedState), [anchorNode, setAnchorNode] = useState(null), [hoveredNode, setHoveredNode2] = useState(null), initialize = useCallback(
    (_data) => {
      setExpandedState((current2) => getInitialTreeExpandedState(current2, _data, selectedState)), setCheckedState((current2) => getInitialCheckedState(current2, _data)), setData2(_data);
    },
    [selectedState, checkedState]
  ), toggleExpanded = useCallback(
    (value) => {
      setExpandedState((current2) => {
        const nextState = { ...current2, [value]: !current2[value] };
        return nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value), nextState;
      });
    },
    [onNodeCollapse, onNodeExpand]
  ), collapse = useCallback(
    (value) => {
      setExpandedState((current2) => (current2[value] !== !1 && onNodeCollapse?.(value), { ...current2, [value]: !1 }));
    },
    [onNodeCollapse]
  ), expand = useCallback(
    (value) => {
      setExpandedState((current2) => (current2[value] !== !0 && onNodeExpand?.(value), { ...current2, [value]: !0 }));
    },
    [onNodeExpand]
  ), expandAllNodes = useCallback(() => {
    setExpandedState((current2) => {
      const next = { ...current2 };
      return Object.keys(next).forEach((key2) => {
        next[key2] = !0;
      }), next;
    });
  }, []), collapseAllNodes = useCallback(() => {
    setExpandedState((current2) => {
      const next = { ...current2 };
      return Object.keys(next).forEach((key2) => {
        next[key2] = !1;
      }), next;
    });
  }, []), toggleSelected = useCallback(
    (value) => setSelectedState((current2) => multiple ? current2.includes(value) ? (setAnchorNode(null), current2.filter((item) => item !== value)) : (setAnchorNode(value), [...current2, value]) : current2.includes(value) ? (setAnchorNode(null), []) : (setAnchorNode(value), [value])),
    []
  ), select2 = useCallback((value) => {
    setAnchorNode(value), setSelectedState(
      (current2) => multiple ? current2.includes(value) ? current2 : [...current2, value] : [value]
    );
  }, []), deselect = useCallback((value) => {
    anchorNode === value && setAnchorNode(null), setSelectedState((current2) => current2.filter((item) => item !== value));
  }, []), clearSelected = useCallback(() => {
    setSelectedState([]), setAnchorNode(null);
  }, []), checkNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current2) => Array.from(/* @__PURE__ */ new Set([...current2, ...checkedNodes])));
    },
    [data]
  ), uncheckNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current2) => current2.filter((item) => !checkedNodes.includes(item)));
    },
    [data]
  ), checkAllNodes = useCallback(() => {
    setCheckedState(() => getAllChildrenNodes(data));
  }, [data]), uncheckAllNodes = useCallback(() => {
    setCheckedState([]);
  }, []);
  return {
    multiple,
    expandedState,
    selectedState,
    checkedState,
    anchorNode,
    initialize,
    toggleExpanded,
    collapse,
    expand,
    expandAllNodes,
    collapseAllNodes,
    setExpandedState,
    checkNode,
    uncheckNode,
    checkAllNodes,
    uncheckAllNodes,
    setCheckedState,
    toggleSelected,
    select: select2,
    deselect,
    clearSelected,
    setSelectedState,
    hoveredNode,
    setHoveredNode: setHoveredNode2,
    getCheckedNodes: () => getAllCheckedNodes(data, checkedState).result,
    isNodeChecked: (value) => memoizedIsNodeChecked(value, data, checkedState),
    isNodeIndeterminate: (value) => memoizedIsNodeIndeterminate(value, data, checkedState)
  };
}
var classes = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };
function getFlatValues(data) {
  return data.reduce((acc, item) => (acc.push(item.value), item.children && acc.push(...getFlatValues(item.children)), acc), []);
}
const defaultProps = {
  expandOnClick: !0,
  allowRangeSelection: !0,
  expandOnSpace: !0
}, varsResolver = (_theme, { levelOffset }) => ({
  root: {
    "--level-offset": getSpacing(levelOffset)
  }
}), Tree = factory((_props, ref) => {
  const props = useProps("Tree", defaultProps, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    expandOnClick,
    tree,
    renderNode,
    selectOnClick,
    clearSelectionOnOutsideClick,
    allowRangeSelection,
    expandOnSpace,
    levelOffset,
    checkOnSpace,
    attributes,
    ...others
  } = props, defaultController = useTree(), controller = tree || defaultController, getStyles2 = useStyles({
    name: "Tree",
    classes,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver
  }), clickOutsideRef = useClickOutside(
    () => clearSelectionOnOutsideClick && controller.clearSelected()
  ), mergedRef = useMergedRef(ref, clickOutsideRef), flatValues = useMemo(() => getFlatValues(data), [data]);
  useEffect(() => {
    controller.initialize(data);
  }, [data]);
  const nodes = data.map((node2, index2) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: node2,
      getStyles: getStyles2,
      rootIndex: index2,
      expandOnClick,
      selectOnClick,
      controller,
      renderNode,
      flatValues,
      allowRangeSelection,
      expandOnSpace,
      checkOnSpace
    },
    node2.value
  ));
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      component: "ul",
      ref: mergedRef,
      ...getStyles2("root"),
      ...others,
      role: "tree",
      "aria-multiselectable": controller.multiple,
      "data-tree-root": !0,
      children: nodes
    }
  );
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes;
const RootContainerContext = createContext(null);
function useRootContainer() {
  const ctx = useContext(RootContainerContext);
  if (!ctx)
    throw new Error("useRootContainer must be used within a RootContainer");
  return ctx;
}
function useRootContainerRef() {
  return useRootContainer().ref;
}
function useRootContainerElement() {
  return useRootContainer().ref.current;
}
const ReduceGraphicsModeCtx = createContext(null);
function useIsReducedGraphics() {
  const isReduced = useContext(ReduceGraphicsModeCtx);
  return isReduced === null && console.warn("ReduceGraphicsMode is not provided"), isReduced ?? !1;
}
const [PanningAtomSafeCtx, usePanningAtom] = createSafeContext$1(
  "PanningAtomSafeCtx is not provided"
);
function RootContainer({
  id: id2,
  className,
  reduceGraphics = !1,
  children: children2
}) {
  const [mounted, setMounted] = useState(!1), ref = useRef(null), $isPanningRef = useRef(null);
  $isPanningRef.current || ($isPanningRef.current = /* @__PURE__ */ atom(!1)), useIsomorphicLayoutEffect$3(() => {
    setMounted(!0);
  }, []), useEffect(() => $isPanningRef.current?.subscribe((isPanning) => {
    ref.current?.setAttribute("data-likec4-diagram-panning", isPanning ? "true" : "false");
  }), []);
  const ctx = useMemo(() => ({ id: id2, ref }), [id2, ref]);
  return /* @__PURE__ */ jsx(PanningAtomSafeCtx, { value: $isPanningRef.current, children: /* @__PURE__ */ jsx(ReduceGraphicsModeCtx.Provider, { value: reduceGraphics, children: /* @__PURE__ */ jsx(
    "div",
    {
      id: id2,
      className: cx("likec4-root", className),
      ref,
      ...reduceGraphics && {
        "data-likec4-reduced-graphics": !0
      },
      children: mounted && !!ctx.ref.current && /* @__PURE__ */ jsx(RootContainerContext.Provider, { value: ctx, children: children2 })
    }
  ) }) });
}
const LikeC4ModelContext = createContext(null), CurrentViewModelContext = createContext(null);
function useOptionalLikeC4Model() {
  return useContext(LikeC4ModelContext);
}
function useLikeC4Model() {
  const model = useContext(LikeC4ModelContext);
  if (!model)
    throw new Error("LikeC4Model not found. Make sure you have LikeC4ModelProvider.");
  return model;
}
function useLikeC4ViewModel(viewId) {
  return useLikeC4Model().view(viewId);
}
function useLikeC4Specification() {
  const model = useLikeC4Model(), [specification, setSpecification] = useState(model.$data.specification);
  return useEffect(() => {
    setSpecification((current2) => deepEqual$1(current2, model.$data.specification) ? current2 : model.$data.specification);
  }, [model]), specification;
}
const TagStylesContext = createContext({}), radixColors = DefaultTagColors, generateColorVars = (spec) => {
  const color2 = spec.color;
  if (isTagColorSpecified(spec))
    return `
      --colors-likec4-tag-bg: ${color2};
      --colors-likec4-tag-bg-hover: color-mix(in oklab, ${color2}, var(--colors-likec4-mix-color) 20%);
    `;
  if (!radixColors.includes(color2))
    return "";
  let textcolor = "12";
  return ["mint", "grass", "lime", "yellow", "amber"].includes(color2) && (textcolor = "dark-2"), `
  --colors-likec4-tag-border: var(--colors-${color2}-8);
  --colors-likec4-tag-bg: var(--colors-${color2}-9);
  --colors-likec4-tag-bg-hover: var(--colors-${color2}-10);
  --colors-likec4-tag-text: var(--colors-${color2}-${textcolor});
  `;
};
function generateStylesheet(tags, rootSelector) {
  return !tags || e$a(tags) ? "" : t$s(
    t$o(tags),
    t$n(([tag, spec]) => [
      `:is(${rootSelector} [data-likec4-tag="${tag}"]) {`,
      generateColorVars(spec),
      "}"
    ]),
    t$i(`
`)
  );
}
function TagStylesProvider({ children: children2, rootSelector }) {
  const tags = useLikeC4Specification().tags, stylesheet = generateStylesheet(tags, rootSelector);
  return /* @__PURE__ */ jsxs(TagStylesContext.Provider, { value: tags, children: [
    stylesheet !== "" && /* @__PURE__ */ jsx(TagStylesheet, { stylesheet }),
    children2
  ] });
}
const TagStylesheet = memo$3(({ stylesheet }) => {
  const nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx("style", { "data-likec4-tags": !0, type: "text/css", dangerouslySetInnerHTML: { __html: stylesheet }, nonce });
});
function useTagSpecification(tag) {
  return useContext(TagStylesContext)[tag] ?? {
    color: "tomato"
  };
}
function useId() {
  return useId$2().replace("mantine-", "likec4-");
}
var userGeneratedStr = "css,pos,insetX,insetY,insetEnd,end,insetStart,start,flexDir,p,pl,pr,pt,pb,py,paddingY,paddingX,px,pe,paddingEnd,ps,paddingStart,ml,mr,mt,mb,m,my,marginY,mx,marginX,me,marginEnd,ms,marginStart,ringWidth,ringColor,ring,ringOffset,w,minW,maxW,h,minH,maxH,textShadowColor,bgPosition,bgPositionX,bgPositionY,bgAttachment,bgClip,bg,bgColor,bgOrigin,bgImage,bgRepeat,bgBlendMode,bgSize,bgGradient,bgLinear,bgRadial,bgConic,rounded,roundedTopLeft,roundedTopRight,roundedBottomRight,roundedBottomLeft,roundedTop,roundedRight,roundedBottom,roundedLeft,roundedStartStart,roundedStartEnd,roundedStart,roundedEndStart,roundedEndEnd,roundedEnd,borderX,borderXWidth,borderXColor,borderY,borderYWidth,borderYColor,borderStart,borderStartWidth,borderStartColor,borderEnd,borderEndWidth,borderEndColor,shadow,shadowColor,x,y,z,scrollMarginY,scrollMarginX,scrollPaddingY,scrollPaddingX,aspectRatio,boxDecorationBreak,zIndex,boxSizing,objectPosition,objectFit,overscrollBehavior,overscrollBehaviorX,overscrollBehaviorY,position,top,left,inset,insetInline,insetBlock,insetBlockEnd,insetBlockStart,insetInlineEnd,insetInlineStart,right,bottom,float,visibility,display,hideFrom,hideBelow,flexBasis,flex,flexDirection,flexGrow,flexShrink,gridTemplateColumns,gridTemplateRows,gridColumn,gridRow,gridColumnStart,gridColumnEnd,gridAutoFlow,gridAutoColumns,gridAutoRows,gap,gridGap,gridRowGap,gridColumnGap,rowGap,columnGap,justifyContent,alignContent,alignItems,alignSelf,padding,paddingLeft,paddingRight,paddingTop,paddingBottom,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingInline,paddingInlineEnd,paddingInlineStart,marginLeft,marginRight,marginTop,marginBottom,margin,marginBlock,marginBlockEnd,marginBlockStart,marginInline,marginInlineEnd,marginInlineStart,spaceX,spaceY,outlineWidth,outlineColor,outline,outlineOffset,focusRing,focusVisibleRing,focusRingColor,focusRingOffset,focusRingWidth,focusRingStyle,divideX,divideY,divideColor,divideStyle,width,inlineSize,minWidth,minInlineSize,maxWidth,maxInlineSize,height,blockSize,minHeight,minBlockSize,maxHeight,maxBlockSize,boxSize,color,fontFamily,fontSize,fontSizeAdjust,fontPalette,fontKerning,fontFeatureSettings,fontWeight,fontSmoothing,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariationSettings,fontVariantNumeric,letterSpacing,lineHeight,textAlign,textDecoration,textDecorationColor,textEmphasisColor,textDecorationStyle,textDecorationThickness,textUnderlineOffset,textTransform,textIndent,textShadow,WebkitTextFillColor,textOverflow,verticalAlign,wordBreak,textWrap,truncate,lineClamp,listStyleType,listStylePosition,listStyleImage,listStyle,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundAttachment,backgroundClip,background,backgroundColor,backgroundOrigin,backgroundImage,backgroundRepeat,backgroundBlendMode,backgroundSize,backgroundGradient,backgroundLinear,backgroundRadial,backgroundConic,textGradient,gradientFromPosition,gradientToPosition,gradientFrom,gradientTo,gradientVia,gradientViaPosition,borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomRightRadius,borderBottomLeftRadius,borderTopRadius,borderRightRadius,borderBottomRadius,borderLeftRadius,borderStartStartRadius,borderStartEndRadius,borderStartRadius,borderEndStartRadius,borderEndEndRadius,borderEndRadius,border,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,borderBlockStartWidth,borderBlockEndWidth,borderColor,borderInline,borderInlineWidth,borderInlineColor,borderBlock,borderBlockWidth,borderBlockColor,borderLeft,borderLeftColor,borderInlineStart,borderInlineStartWidth,borderInlineStartColor,borderRight,borderRightColor,borderInlineEnd,borderInlineEndWidth,borderInlineEndColor,borderTop,borderTopColor,borderBottom,borderBottomColor,borderBlockEnd,borderBlockEndColor,borderBlockStart,borderBlockStartColor,opacity,boxShadow,boxShadowColor,mixBlendMode,filter,brightness,contrast,grayscale,hueRotate,invert,saturate,sepia,dropShadow,blur,backdropFilter,backdropBlur,backdropBrightness,backdropContrast,backdropGrayscale,backdropHueRotate,backdropInvert,backdropOpacity,backdropSaturate,backdropSepia,borderCollapse,borderSpacing,borderSpacingX,borderSpacingY,tableLayout,transitionTimingFunction,transitionDelay,transitionDuration,transitionProperty,transition,animation,animationName,animationTimingFunction,animationDuration,animationDelay,animationPlayState,animationComposition,animationFillMode,animationDirection,animationIterationCount,animationRange,animationState,animationRangeStart,animationRangeEnd,animationTimeline,transformOrigin,transformBox,transformStyle,transform,rotate,rotateX,rotateY,rotateZ,scale,scaleX,scaleY,translate,translateX,translateY,translateZ,accentColor,caretColor,scrollBehavior,scrollbar,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollMargin,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollMarginBottom,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollPaddingBottom,scrollSnapAlign,scrollSnapStop,scrollSnapType,scrollSnapStrictness,scrollSnapMargin,scrollSnapMarginTop,scrollSnapMarginBottom,scrollSnapMarginLeft,scrollSnapMarginRight,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,touchAction,userSelect,overflow,overflowWrap,overflowX,overflowY,overflowAnchor,overflowBlock,overflowInline,overflowClipBox,overflowClipMargin,overscrollBehaviorBlock,overscrollBehaviorInline,fill,stroke,strokeWidth,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,srOnly,debug,appearance,backfaceVisibility,clipPath,hyphens,mask,maskImage,maskSize,textSizeAdjust,container,containerName,containerType,cursor,colorPalette,_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_noscript,_invertedColors,_shapeSizeXs,_shapeSizeSm,_shapeSizeMd,_shapeSizeLg,_shapeSizeXl,_shapeRectangle,_shapePerson,_shapeBrowser,_shapeMobile,_shapeCylinder,_shapeStorage,_shapeQueue,_shapeBucket,_shapeDocument,_notDisabled,_reduceGraphics,_reduceGraphicsOnPan,_noReduceGraphics,_whenPanning,_smallZoom,_compoundTransparent,_edgeActive,_whenHovered,_whenSelectable,_whenSelected,_whenDimmed,_whenFocused,_p3,_srgb,_rec2020,xs,xsOnly,xsDown,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,xsToSm,xsToMd,xsToLg,xsToXl,smToMd,smToLg,smToXl,mdToLg,mdToXl,lgToXl,@/xs,@/sm,@/md,@/lg,@likec4-root/xs,@likec4-root/sm,@likec4-root/md,@likec4-root/lg,@likec4-dialog/xs,@likec4-dialog/sm,@likec4-dialog/md,@likec4-dialog/lg,textStyle,layerStyle,animationStyle", userGenerated = userGeneratedStr.split(","), cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,WebkitUserSelect,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,anchorName,anchorScope,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimeline,animationTimingFunction,appearance,aspectRatio,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBlockStyle,borderBlockWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineColor,borderInlineEnd,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderInlineStyle,borderInlineWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,clipRule,color,colorInterpolationFilters,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,cx,cy,d,direction,display,dominantBaseline,emptyCells,fieldSizing,fill,fillOpacity,fillRule,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,floodColor,floodOpacity,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontVariationSettings,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,interpolateSize,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lightingColor,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,marker,markerEnd,markerMid,markerStart,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,positionAnchor,positionArea,positionTry,positionTryFallbacks,positionTryOrder,positionVisibility,printColorAdjust,quotes,r,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,rx,ry,scale,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginBottom,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockEnd,scrollPaddingBlockStart,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,scrollbarColor,scrollbarGutter,scrollbarWidth,shapeImageThreshold,shapeMargin,shapeOutside,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,tabSize,tableLayout,textAlign,textAlignLast,textAnchor,textBox,textBoxEdge,textBoxTrim,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textSpacingTrim,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,textWrapMode,textWrapStyle,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,vectorEffect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,x,y,zIndex,zoom,alignmentBaseline,baselineShift,colorInterpolation,colorRendering,glyphOrientationVertical", allCssProperties = cssPropertiesStr.split(",").concat(userGenerated), properties = new Map(allCssProperties.map((prop) => [prop, !0])), cssPropertySelectorRegex = /&|@/, isCssProperty = /* @__PURE__ */ memo$2((prop) => properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop));
const defaultShouldForwardProp = (prop, variantKeys) => !variantKeys.includes(prop) && !isCssProperty(prop), composeShouldForwardProps = (tag, shouldForwardProp2) => tag.__shouldForwardProps__ && shouldForwardProp2 ? (propName) => tag.__shouldForwardProps__(propName) && shouldForwardProp2(propName) : shouldForwardProp2, composeCvaFn = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  if (cvaA.__cva__ && cvaB.__cva__ || cvaA.__recipe__ && cvaB.__recipe__) return cvaA.merge(cvaB);
  const error = new TypeError("Cannot merge cva with recipe. Please use either cva or recipe.");
  throw TypeError.captureStackTrace?.(error), error;
}, getDisplayName = (Component2) => typeof Component2 == "string" ? Component2 : Component2?.displayName || Component2?.name || "Component";
function styledFn(Dynamic, configOrCva = {}, options = {}) {
  const cvaFn = configOrCva.__cva__ || configOrCva.__recipe__ ? configOrCva : cva(configOrCva), forwardFn = options.shouldForwardProp || defaultShouldForwardProp, shouldForwardProp2 = (prop) => options.forwardProps?.includes(prop) ? !0 : forwardFn(prop, cvaFn.variantKeys), defaultProps2 = Object.assign(
    options.dataAttr && configOrCva.__name__ ? { "data-recipe": configOrCva.__name__ } : {},
    options.defaultProps
  ), __cvaFn__ = composeCvaFn(Dynamic.__cva__, cvaFn), __shouldForwardProps__ = composeShouldForwardProps(Dynamic, shouldForwardProp2), __base__ = Dynamic.__base__ || Dynamic, StyledComponent = /* @__PURE__ */ forwardRef(function(props, ref) {
    const { as: Element2 = __base__, unstyled, children: children2, ...restProps } = props, combinedProps = useMemo(() => Object.assign({}, defaultProps2, restProps), [restProps]), [htmlProps2, forwardedProps, variantProps2, styleProps, elementProps] = useMemo(() => splitProps(combinedProps, normalizeHTMLProps.keys, __shouldForwardProps__, __cvaFn__.variantKeys, isCssProperty), [combinedProps]);
    function recipeClass() {
      const { css: cssStyles, ...propStyles } = styleProps, compoundVariantStyles = __cvaFn__.__getCompoundVariantCss__?.(variantProps2);
      return cx(__cvaFn__(variantProps2, !1), css(compoundVariantStyles, propStyles, cssStyles), combinedProps.className);
    }
    function cvaClass() {
      const { css: cssStyles, ...propStyles } = styleProps, cvaStyles = __cvaFn__.raw(variantProps2);
      return cx(css(cvaStyles, propStyles, cssStyles), combinedProps.className);
    }
    const classes2 = () => {
      if (unstyled) {
        const { css: cssStyles, ...propStyles } = styleProps;
        return cx(css(propStyles, cssStyles), combinedProps.className);
      }
      return configOrCva.__recipe__ ? recipeClass() : cvaClass();
    };
    return createElement(Element2, {
      ref,
      ...forwardedProps,
      ...elementProps,
      ...normalizeHTMLProps(htmlProps2),
      className: classes2()
    }, children2 ?? combinedProps.children);
  }), name = getDisplayName(__base__);
  return StyledComponent.displayName = `styled.${name}`, StyledComponent.__cva__ = __cvaFn__, StyledComponent.__base__ = __base__, StyledComponent.__shouldForwardProps__ = shouldForwardProp2, StyledComponent;
}
function createJsxFactory() {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(styledFn, {
    apply(_, __, args) {
      return styledFn(...args);
    },
    get(_, el) {
      return cache2.has(el) || cache2.set(el, styledFn(el)), cache2.get(el);
    }
  });
}
const styled = /* @__PURE__ */ createJsxFactory();
function createSafeContext(contextName) {
  const Context = createContext(void 0);
  return [Context, (componentName, slot) => {
    const context2 = useContext(Context);
    if (context2 === void 0) {
      const componentInfo = componentName ? `Component "${componentName}"` : "A component", slotInfo = slot ? ` (slot: "${slot}")` : "";
      throw new Error(
        `${componentInfo}${slotInfo} cannot access ${contextName} because it's missing its Provider.`
      );
    }
    return context2;
  }];
}
function createStyleContext(recipe) {
  const isConfigRecipe = "__recipe__" in recipe, recipeName = isConfigRecipe && recipe.__name__ ? recipe.__name__ : void 0, contextName = recipeName ? `createStyleContext("${recipeName}")` : "createStyleContext", [StyleContext, useStyleContext] = createSafeContext(contextName), svaFn = isConfigRecipe ? recipe : sva(recipe.config), getResolvedProps = (props, slotStyles) => {
    const { unstyled, ...restProps } = props;
    return unstyled ? restProps : isConfigRecipe ? { ...restProps, className: cx(slotStyles, restProps.className) } : { ...slotStyles, ...restProps };
  };
  return {
    withRootProvider: (Component2, options) => {
      const WithRootProvider = (props) => {
        const [variantProps2, otherProps] = svaFn.splitVariantProps(props), slotStyles = isConfigRecipe ? svaFn(variantProps2) : svaFn.raw(variantProps2);
        slotStyles._classNameMap = svaFn.classNameMap;
        const mergedProps = options?.defaultProps ? { ...options.defaultProps, ...otherProps } : otherProps;
        return createElement(StyleContext.Provider, {
          value: slotStyles,
          children: createElement(Component2, mergedProps)
        });
      }, componentName = getDisplayName(Component2);
      return WithRootProvider.displayName = `withRootProvider(${componentName})`, WithRootProvider;
    },
    withProvider: (Component2, slot, options) => {
      const StyledComponent = styled(Component2, {}, options), WithProvider = forwardRef((props, ref) => {
        const [variantProps2, restProps] = svaFn.splitVariantProps(props), slotStyles = isConfigRecipe ? svaFn(variantProps2) : svaFn.raw(variantProps2);
        slotStyles._classNameMap = svaFn.classNameMap;
        const propsWithClass = { ...restProps, className: restProps.className ?? options?.defaultProps?.className }, resolvedProps = getResolvedProps(propsWithClass, slotStyles[slot]);
        return createElement(StyleContext.Provider, {
          value: slotStyles,
          children: createElement(StyledComponent, {
            ...resolvedProps,
            className: cx(resolvedProps.className, slotStyles._classNameMap[slot]),
            ref
          })
        });
      }), componentName = getDisplayName(Component2);
      return WithProvider.displayName = `withProvider(${componentName})`, WithProvider;
    },
    withContext: (Component2, slot, options) => {
      const StyledComponent = styled(Component2, {}, options), componentName = getDisplayName(Component2), WithContext = forwardRef((props, ref) => {
        const slotStyles = useStyleContext(componentName, slot), propsWithClass = { ...props, className: props.className ?? options?.defaultProps?.className }, resolvedProps = getResolvedProps(propsWithClass, slotStyles[slot]);
        return createElement(StyledComponent, {
          ...resolvedProps,
          className: cx(resolvedProps.className, slotStyles._classNameMap[slot]),
          ref
        });
      });
      return WithContext.displayName = `withContext(${componentName})`, WithContext;
    }
  };
}
const boxConfig = {
  transform(props) {
    return props;
  }
}, getBoxStyle = (styles = {}) => {
  const _styles = getPatternStyles(boxConfig, styles);
  return boxConfig.transform(_styles, patternFns);
}, Box = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, []), styleProps = getBoxStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), vstackConfig = {
  transform(props) {
    const { justify, gap, ...rest } = props;
    return {
      display: "flex",
      alignItems: "center",
      justifyContent: justify,
      gap,
      flexDirection: "column",
      ...rest
    };
  },
  defaultValues: { alignItems: "stretch", gap: "sm" }
}, getVstackStyle = (styles = {}) => {
  const _styles = getPatternStyles(vstackConfig, styles);
  return vstackConfig.transform(_styles, patternFns);
}, vstack = (styles) => css(getVstackStyle(styles));
vstack.raw = getVstackStyle;
const VStack = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, ["justify", "gap"]), styleProps = getVstackStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), hstackConfig = {
  transform(props) {
    const { justify, gap, ...rest } = props;
    return {
      display: "flex",
      alignItems: "center",
      justifyContent: justify,
      gap,
      flexDirection: "row",
      ...rest
    };
  },
  defaultValues: { gap: "sm" }
}, getHstackStyle = (styles = {}) => {
  const _styles = getPatternStyles(hstackConfig, styles);
  return hstackConfig.transform(_styles, patternFns);
}, hstack = (styles) => css(getHstackStyle(styles));
hstack.raw = getHstackStyle;
const HStack = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, ["justify", "gap"]), styleProps = getHstackStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), containerConfig = {
  transform(props) {
    return {
      position: "relative",
      maxWidth: "8xl",
      mx: "auto",
      px: { base: "4", md: "6", lg: "8" },
      ...props
    };
  }
}, getContainerStyle = (styles = {}) => {
  const _styles = getPatternStyles(containerConfig, styles);
  return containerConfig.transform(_styles, patternFns);
}, container$3 = (styles) => css(getContainerStyle(styles));
container$3.raw = getContainerStyle;
const bleedConfig = {
  transform(props, { map, isCssUnit: isCssUnit2, isCssVar: isCssVar2 }) {
    const { inline: inline2, block, ...rest } = props, valueFn = (v2) => isCssUnit2(v2) || isCssVar2(v2) ? v2 : `token(spacing.${v2}, ${v2})`;
    return {
      "--bleed-x": map(inline2, valueFn),
      "--bleed-y": map(block, valueFn),
      marginInline: "calc(var(--bleed-x, 0) * -1)",
      marginBlock: "calc(var(--bleed-y, 0) * -1)",
      ...rest
    };
  },
  defaultValues: { inline: "0", block: "0" }
}, getBleedStyle = (styles = {}) => {
  const _styles = getPatternStyles(bleedConfig, styles);
  return bleedConfig.transform(_styles, patternFns);
}, bleed = (styles) => css(getBleedStyle(styles));
bleed.raw = getBleedStyle;
const ErrorBoundaryContext = createContext(null), initialState = {
  didCatch: !1,
  error: null
};
let ErrorBoundary$1 = class extends Component {
  constructor(props) {
    super(props), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: !0,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      for (var _this$props$onReset, _this$props, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 || _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      }), this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 || _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state, {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 || _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      }), this.setState(initialState);
    }
  }
  render() {
    const {
      children: children2,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props, {
      didCatch,
      error
    } = this.state;
    let childToRender = children2;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender == "function")
        childToRender = fallbackRender(props);
      else if (FallbackComponent)
        childToRender = createElement(FallbackComponent, props);
      else if (fallback !== void 0)
        childToRender = fallback;
      else
        throw error;
    }
    return createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
};
function hasArrayChanged() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b2.length || a2.some((item, index2) => !Object.is(item, b2[index2]));
}
const __iconNode$G = [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]], IconX = createReactComponent("outline", "x", "X", __iconNode$G);
function ErrorFallback({ error, resetErrorBoundary }) {
  const errorString = error instanceof Error ? error.message : "Unknown error", dialogRef = useRef(null);
  return useEffect(() => {
    dialogRef.current?.showModal();
  }, []), /* @__PURE__ */ jsx(
    "dialog",
    {
      ref: dialogRef,
      className: css({
        margin: "0",
        padding: "0",
        position: "fixed",
        top: "10",
        left: "10",
        width: "[calc(100vw - ({spacing.10} * 2))]",
        height: "max-content",
        maxHeight: "[calc(100vh - ({spacing.10} * 3))]",
        background: "likec4.overlay.body",
        rounded: "sm",
        borderWidth: 3,
        borderColor: "likec4.overlay.border",
        shadow: "xl",
        outline: "none",
        _backdrop: {
          cursor: "zoom-out",
          backdropFilter: "blur(18px)",
          bg: "[color-mix(in oklab, {colors.likec4.overlay.backdrop} 60%, transparent)]"
        }
      }),
      onClick: (e2) => {
        if (e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG") {
          dialogRef.current?.close();
          return;
        }
      },
      onClose: (e2) => {
        e2.stopPropagation(), resetErrorBoundary();
      },
      children: /* @__PURE__ */ jsxs(HStack, { p: "xl", gap: "lg", alignItems: "flex-start", flexWrap: "nowrap", children: [
        /* @__PURE__ */ jsx(ThemeIcon, { size: "md", radius: "xl", color: "red", children: /* @__PURE__ */ jsx(IconX, { style: { width: 20, height: 20 } }) }),
        /* @__PURE__ */ jsxs(VStack, { flex: "1", children: [
          /* @__PURE__ */ jsx(Text, { fz: "md", children: "Oops, something went wrong" }),
          /* @__PURE__ */ jsx(ScrollAreaAutosize, { maw: "100%", mah: 400, type: "auto", children: /* @__PURE__ */ jsx(Text, { fz: "md", c: "red", style: { whiteSpace: "pre-wrap", userSelect: "all" }, children: errorString }) }),
          /* @__PURE__ */ jsxs(HStack, { gap: "md", mt: "md", children: [
            /* @__PURE__ */ jsx(Button, { size: "sm", variant: "default", onClick: () => resetErrorBoundary(), children: "Reset" }),
            /* @__PURE__ */ jsx(Text, { fz: "sm", c: "dimmed", children: "See console for more details and report the issue if it persists." })
          ] })
        ] })
      ] })
    }
  );
}
function ErrorBoundary2(props) {
  return /* @__PURE__ */ jsx(
    ErrorBoundary$1,
    {
      FallbackComponent: ErrorFallback,
      onError: (err, info) => {
        console.error(err, info);
      },
      ...props
    }
  );
}
const DefaultFeatures = {
  enableEditor: !1,
  enableReadOnly: !0,
  enableCompareWithLatest: !1,
  enableControls: !1,
  enableDynamicViewWalkthrough: !1,
  enableElementDetails: !1,
  enableFocusMode: !1,
  enableNavigateTo: !1,
  enableNotations: !1,
  enableRelationshipBrowser: !1,
  enableRelationshipDetails: !1,
  enableSearch: !1,
  enableNavigationButtons: !1,
  enableFitView: !1,
  enableVscode: !1,
  enableElementTags: !1
}, DiagramFeaturesContext = createContext(DefaultFeatures);
function DiagramFeatures({
  children: children2,
  features,
  overrides
}) {
  const outerScope = useContext(DiagramFeaturesContext), [scope, setScope] = useState(outerScope);
  return useEffect(
    () => {
      setScope((current2) => {
        const next = {
          ...outerScope,
          ...features,
          ...overrides
        };
        return shallowEqual$1(current2, next) ? current2 : next;
      });
    },
    [outerScope, features, overrides]
  ), /* @__PURE__ */ jsx(DiagramFeaturesContext.Provider, { value: scope, children: children2 });
}
const overridesForOverlays = {
  enableControls: !1,
  enableReadOnly: !0,
  enableCompareWithLatest: !1
};
DiagramFeatures.Overlays = ({ children: children2 }) => /* @__PURE__ */ jsx(DiagramFeatures, { overrides: overridesForOverlays, children: children2 });
function useEnabledFeatures() {
  return useContext(DiagramFeaturesContext);
}
function IfEnabled({
  feature,
  children: children2,
  and = !0
}) {
  return useEnabledFeatures()[`enable${feature}`] === !0 && and ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : null;
}
function IfNotEnabled({ feature, children: children2 }) {
  return useEnabledFeatures()[`enable${feature}`] !== !0 ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : null;
}
function IfReadOnly({ children: children2 }) {
  return useEnabledFeatures().enableReadOnly === !0 ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : null;
}
function IfNotReadOnly({ children: children2 }) {
  return useEnabledFeatures().enableReadOnly === !0 ? null : /* @__PURE__ */ jsx(Fragment, { children: children2 });
}
function getGlobal() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
}
function getDevTools() {
  const w2 = getGlobal();
  if (w2.__xstate__)
    return w2.__xstate__;
}
const devToolsAdapter = (service) => {
  if (typeof window > "u")
    return;
  const devTools = getDevTools();
  devTools && devTools.register(service);
};
class Mailbox {
  constructor(_process) {
    this._process = _process, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(event) {
    const enqueued = {
      value: event,
      next: null
    };
    if (this._current) {
      this._last.next = enqueued, this._last = enqueued;
      return;
    }
    this._current = enqueued, this._last = enqueued, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const consumed = this._current;
      this._process(consumed.value), this._current = consumed.next;
    }
    this._last = null;
  }
}
const STATE_DELIMITER = ".", TARGETLESS_KEY = "", NULL_EVENT = "", STATE_IDENTIFIER$1 = "#", WILDCARD = "*", XSTATE_INIT = "xstate.init", XSTATE_ERROR = "xstate.error", XSTATE_STOP = "xstate.stop";
function createAfterEvent(delayRef, id2) {
  return {
    type: `xstate.after.${delayRef}.${id2}`
  };
}
function createDoneStateEvent(id2, output) {
  return {
    type: `xstate.done.state.${id2}`,
    output
  };
}
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output,
    actorId: invokeId
  };
}
function createErrorActorEvent(id2, error) {
  return {
    type: `xstate.error.actor.${id2}`,
    error,
    actorId: id2
  };
}
function createInitEvent(input2) {
  return {
    type: XSTATE_INIT,
    input: input2
  };
}
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err;
  });
}
const symbolObservable = typeof Symbol == "function" && Symbol.observable || "@@observable";
function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId), childStateValue = toStateValue(childStateId);
  return typeof childStateValue == "string" ? typeof parentStateValue == "string" ? childStateValue === parentStateValue : !1 : typeof parentStateValue == "string" ? parentStateValue in childStateValue : Object.keys(parentStateValue).every((key2) => key2 in childStateValue ? matchesState(parentStateValue[key2], childStateValue[key2]) : !1);
}
function toStatePath(stateId) {
  if (isArray$1(stateId))
    return stateId;
  const result = [];
  let segment = "";
  for (let i2 = 0; i2 < stateId.length; i2++) {
    switch (stateId.charCodeAt(i2)) {
      // \
      case 92:
        segment += stateId[i2 + 1], i2++;
        continue;
      // .
      case 46:
        result.push(segment), segment = "";
        continue;
    }
    segment += stateId[i2];
  }
  return result.push(segment), result;
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue))
    return stateValue.value;
  if (typeof stateValue != "string")
    return stateValue;
  const statePath = toStatePath(stateValue);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1)
    return statePath[0];
  const value = {};
  let marker = value;
  for (let i2 = 0; i2 < statePath.length - 1; i2++)
    if (i2 === statePath.length - 2)
      marker[statePath[i2]] = statePath[i2 + 1];
    else {
      const previous = marker;
      marker = {}, previous[statePath[i2]] = marker;
    }
  return value;
}
function mapValues(collection, iteratee) {
  const result = {}, collectionKeys = Object.keys(collection);
  for (let i2 = 0; i2 < collectionKeys.length; i2++) {
    const key2 = collectionKeys[i2];
    result[key2] = iteratee(collection[key2], key2, collection, i2);
  }
  return result;
}
function toArrayStrict(value) {
  return isArray$1(value) ? value : [value];
}
function toArray(value) {
  return value === void 0 ? [] : toArrayStrict(value);
}
function resolveOutput(mapper, context2, event, self2) {
  return typeof mapper == "function" ? mapper({
    context: context2,
    event,
    self: self2
  }) : mapper;
}
function isArray$1(value) {
  return Array.isArray(value);
}
function isErrorActorEvent(event) {
  return event.type.startsWith("xstate.error.actor");
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map((transitionLike) => typeof transitionLike > "u" || typeof transitionLike == "string" ? {
    target: transitionLike
  } : transitionLike);
}
function normalizeTarget(target) {
  if (!(target === void 0 || target === TARGETLESS_KEY))
    return toArray(target);
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  const isObserver = typeof nextHandler == "object", self2 = isObserver ? nextHandler : void 0;
  return {
    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self2),
    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self2),
    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self2)
  };
}
function createInvokeId(stateNodeId, index2) {
  return `${index2}.${stateNodeId}`;
}
function resolveReferencedActor(machine2, src) {
  const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!match)
    return machine2.implementations.actors[src];
  const [, indexStr, nodeId] = match, invokeConfig = machine2.getStateNodeById(nodeId).config.invoke;
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
}
function createScheduledEventId(actorRef, id2) {
  return `${actorRef.sessionId}.${id2}`;
}
let idCounter = 0;
function createSystem(rootActor, options) {
  const children2 = /* @__PURE__ */ new Map(), keyedActors = /* @__PURE__ */ new Map(), reverseKeyedActors = /* @__PURE__ */ new WeakMap(), inspectionObservers = /* @__PURE__ */ new Set(), timerMap = {}, {
    clock: clock2,
    logger
  } = options, scheduler = {
    schedule: (source, target, event, delay2, id2 = Math.random().toString(36).slice(2)) => {
      const scheduledEvent = {
        source,
        target,
        event,
        delay: delay2,
        id: id2,
        startedAt: Date.now()
      }, scheduledEventId = createScheduledEventId(source, id2);
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
      const timeout2 = clock2.setTimeout(() => {
        delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], system._relay(source, target, event);
      }, delay2);
      timerMap[scheduledEventId] = timeout2;
    },
    cancel: (source, id2) => {
      const scheduledEventId = createScheduledEventId(source, id2), timeout2 = timerMap[scheduledEventId];
      delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], timeout2 !== void 0 && clock2.clearTimeout(timeout2);
    },
    cancelAll: (actorRef) => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
        scheduledEvent.source === actorRef && scheduler.cancel(actorRef, scheduledEvent.id);
      }
    }
  }, sendInspectionEvent = (event) => {
    if (!inspectionObservers.size)
      return;
    const resolvedInspectionEvent = {
      ...event,
      rootId: rootActor.sessionId
    };
    inspectionObservers.forEach((observer) => observer.next?.(resolvedInspectionEvent));
  }, system = {
    _snapshot: {
      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => (children2.set(sessionId, actorRef), sessionId),
    _unregister: (actorRef) => {
      children2.delete(actorRef.sessionId);
      const systemId = reverseKeyedActors.get(actorRef);
      systemId !== void 0 && (keyedActors.delete(systemId), reverseKeyedActors.delete(actorRef));
    },
    get: (systemId) => keyedActors.get(systemId),
    getAll: () => Object.fromEntries(keyedActors.entries()),
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId);
      if (existing && existing !== actorRef)
        throw new Error(`Actor with system ID '${systemId}' already exists.`);
      keyedActors.set(systemId, actorRef), reverseKeyedActors.set(actorRef, systemId);
    },
    inspect: (observerOrFn) => {
      const observer = toObserver(observerOrFn);
      return inspectionObservers.add(observer), {
        unsubscribe() {
          inspectionObservers.delete(observer);
        }
      };
    },
    _sendInspectionEvent: sendInspectionEvent,
    _relay: (source, target, event) => {
      system._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: source,
        actorRef: target,
        event
      }), target._send(event);
    },
    scheduler,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...system._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const scheduledEvents = system._snapshot._scheduledEvents;
      system._snapshot._scheduledEvents = {};
      for (const scheduledId in scheduledEvents) {
        const {
          source,
          target,
          event,
          delay: delay2,
          id: id2
        } = scheduledEvents[scheduledId];
        scheduler.schedule(source, target, event, delay2, id2);
      }
    },
    _clock: clock2,
    _logger: logger
  };
  return system;
}
let executingCustomAction = !1;
const $$ACTOR_TYPE = 1;
let ProcessingStatus = /* @__PURE__ */ (function(ProcessingStatus2) {
  return ProcessingStatus2[ProcessingStatus2.NotStarted = 0] = "NotStarted", ProcessingStatus2[ProcessingStatus2.Running = 1] = "Running", ProcessingStatus2[ProcessingStatus2.Stopped = 2] = "Stopped", ProcessingStatus2;
})({});
const defaultOptions = {
  clock: {
    setTimeout: (fn, ms) => setTimeout(fn, ms),
    clearTimeout: (id2) => clearTimeout(id2)
  },
  logger: console.log.bind(console),
  devTools: !1
};
class Actor {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(logic, options) {
    this.logic = logic, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new Mailbox(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = ProcessingStatus.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this.systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const resolvedOptions = {
      ...defaultOptions,
      ...options
    }, {
      clock: clock2,
      logger,
      parent,
      syncSnapshot,
      id: id2,
      systemId,
      inspect
    } = resolvedOptions;
    this.system = parent ? parent.system : createSystem(this, {
      clock: clock2,
      logger
    }), inspect && !parent && this.system.inspect(toObserver(inspect)), this.sessionId = this.system._bookId(), this.id = id2 ?? this.sessionId, this.logger = options?.logger ?? this.system._logger, this.clock = options?.clock ?? this.system._clock, this._parent = parent, this._syncSnapshot = syncSnapshot, this.options = resolvedOptions, this.src = resolvedOptions.src ?? logic, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (fn) => {
        this._deferred.push(fn);
      },
      system: this.system,
      stopChild: (child) => {
        if (child._parent !== this)
          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
        child._stop();
      },
      emit: (emittedEvent) => {
        const listeners = this.eventListeners.get(emittedEvent.type), wildcardListener = this.eventListeners.get("*");
        if (!listeners && !wildcardListener)
          return;
        const allListeners = [...listeners ? listeners.values() : [], ...wildcardListener ? wildcardListener.values() : []];
        for (const handler of allListeners)
          try {
            handler(emittedEvent);
          } catch (err) {
            reportUnhandledError(err);
          }
      },
      actionExecutor: (action) => {
        const exec = () => {
          if (this._actorScope.system._sendInspectionEvent({
            type: "@xstate.action",
            actorRef: this,
            action: {
              type: action.type,
              params: action.params
            }
          }), !action.exec)
            return;
          const saveExecutingCustomAction = executingCustomAction;
          try {
            executingCustomAction = !0, action.exec(action.info, action.params);
          } finally {
            executingCustomAction = saveExecutingCustomAction;
          }
        };
        this._processingStatus === ProcessingStatus.Running ? exec() : this._deferred.push(exec);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), systemId && (this.systemId = systemId, this.system._set(systemId, this)), this._initState(options?.snapshot ?? options?.state), systemId && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(persistedState) {
    try {
      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
    } catch (err) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: err
      };
    }
  }
  update(snapshot, event) {
    this._snapshot = snapshot;
    let deferredFn;
    for (; deferredFn = this._deferred.shift(); )
      try {
        deferredFn();
      } catch (err) {
        this._deferred.length = 0, this._snapshot = {
          ...snapshot,
          status: "error",
          error: err
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const observer of this.observers)
          try {
            observer.next?.(snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        break;
      case "done":
        for (const observer of this.observers)
          try {
            observer.next?.(snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event,
      snapshot
    });
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(nextListenerOrObserver, errorListener, completeListener) {
    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
    if (this._processingStatus !== ProcessingStatus.Stopped)
      this.observers.add(observer);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            observer.complete?.();
          } catch (err) {
            reportUnhandledError(err);
          }
          break;
        case "error": {
          const err = this._snapshot.error;
          if (!observer.error)
            reportUnhandledError(err);
          else
            try {
              observer.error(err);
            } catch (err2) {
              reportUnhandledError(err2);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(observer);
      }
    };
  }
  on(type, handler) {
    let listeners = this.eventListeners.get(type);
    listeners || (listeners = /* @__PURE__ */ new Set(), this.eventListeners.set(type, listeners));
    const wrappedHandler = handler.bind(void 0);
    return listeners.add(wrappedHandler), {
      unsubscribe: () => {
        listeners.delete(wrappedHandler);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === ProcessingStatus.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (snapshot) => {
        snapshot.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this.systemId && this.system._set(this.systemId, this), this._processingStatus = ProcessingStatus.Running;
    const initEvent = createInitEvent(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: initEvent
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, initEvent), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (err) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: err
        }, this._error(err), this;
      }
    return this.update(this._snapshot, initEvent), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(event) {
    let nextState, caughtError;
    try {
      nextState = this.logic.transition(this._snapshot, event, this._actorScope);
    } catch (err) {
      caughtError = {
        err
      };
    }
    if (caughtError) {
      const {
        err
      } = caughtError;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: err
      }, this._error(err);
      return;
    }
    this.update(nextState, event), event.type === XSTATE_STOP && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === ProcessingStatus.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ProcessingStatus.NotStarted ? (this._processingStatus = ProcessingStatus.Stopped, this) : (this.mailbox.enqueue({
      type: XSTATE_STOP
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    for (const observer of this.observers)
      try {
        observer.complete?.();
      } catch (err) {
        reportUnhandledError(err);
      }
    this.observers.clear();
  }
  _reportError(err) {
    if (!this.observers.size) {
      this._parent || reportUnhandledError(err);
      return;
    }
    let reportError = !1;
    for (const observer of this.observers) {
      const errorListener = observer.error;
      reportError ||= !errorListener;
      try {
        errorListener?.(err);
      } catch (err2) {
        reportUnhandledError(err2);
      }
    }
    this.observers.clear(), reportError && reportUnhandledError(err);
  }
  _error(err) {
    this._stopProcedure(), this._reportError(err), this._parent && this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== ProcessingStatus.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new Mailbox(this._process.bind(this)), this._processingStatus = ProcessingStatus.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(event) {
    this._processingStatus !== ProcessingStatus.Stopped && this.mailbox.enqueue(event);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(event) {
    this.system._relay(void 0, this, event);
  }
  attachDevTools() {
    const {
      devTools
    } = this.options;
    devTools && (typeof devTools == "function" ? devTools : devToolsAdapter)(this);
  }
  toJSON() {
    return {
      xstate$$type: $$ACTOR_TYPE,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(options) {
    return this.logic.getPersistedSnapshot(this._snapshot, options);
  }
  [symbolObservable]() {
    return this;
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function createActor(logic, ...[options]) {
  return new Actor(logic, options);
}
function resolveCancel(_, snapshot, actionArgs, actionParams, {
  sendId
}) {
  const resolvedSendId = typeof sendId == "function" ? sendId(actionArgs, actionParams) : sendId;
  return [snapshot, {
    sendId: resolvedSendId
  }, void 0];
}
function executeCancel(actorScope, params) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
  });
}
function cancel(sendId) {
  function cancel2(_args, _params) {
  }
  return cancel2.type = "xstate.cancel", cancel2.sendId = sendId, cancel2.resolve = resolveCancel, cancel2.execute = executeCancel, cancel2;
}
function resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {
  id: id2,
  systemId,
  src,
  input: input2,
  syncSnapshot
}) {
  const logic = typeof src == "string" ? resolveReferencedActor(snapshot.machine, src) : src, resolvedId = typeof id2 == "function" ? id2(actionArgs) : id2;
  let actorRef, resolvedInput;
  return logic && (resolvedInput = typeof input2 == "function" ? input2({
    context: snapshot.context,
    event: actionArgs.event,
    self: actorScope.self
  }) : input2, actorRef = createActor(logic, {
    id: resolvedId,
    src,
    parent: actorScope.self,
    syncSnapshot,
    systemId,
    input: resolvedInput
  })), [cloneMachineSnapshot(snapshot, {
    children: {
      ...snapshot.children,
      [resolvedId]: actorRef
    }
  }), {
    id: id2,
    systemId,
    actorRef,
    src,
    input: resolvedInput
  }, void 0];
}
function executeSpawn(actorScope, {
  actorRef
}) {
  actorRef && actorScope.defer(() => {
    actorRef._processingStatus !== ProcessingStatus.Stopped && actorRef.start();
  });
}
function spawnChild(...[src, {
  id: id2,
  systemId,
  input: input2,
  syncSnapshot = !1
} = {}]) {
  function spawnChild2(_args, _params) {
  }
  return spawnChild2.type = "xstate.spawnChild", spawnChild2.id = id2, spawnChild2.systemId = systemId, spawnChild2.src = src, spawnChild2.input = input2, spawnChild2.syncSnapshot = syncSnapshot, spawnChild2.resolve = resolveSpawn, spawnChild2.execute = executeSpawn, spawnChild2;
}
function resolveStop(_, snapshot, args, actionParams, {
  actorRef
}) {
  const actorRefOrString = typeof actorRef == "function" ? actorRef(args, actionParams) : actorRef, resolvedActorRef = typeof actorRefOrString == "string" ? snapshot.children[actorRefOrString] : actorRefOrString;
  let children2 = snapshot.children;
  return resolvedActorRef && (children2 = {
    ...children2
  }, delete children2[resolvedActorRef.id]), [cloneMachineSnapshot(snapshot, {
    children: children2
  }), resolvedActorRef, void 0];
}
function executeStop(actorScope, actorRef) {
  if (actorRef) {
    if (actorScope.system._unregister(actorRef), actorRef._processingStatus !== ProcessingStatus.Running) {
      actorScope.stopChild(actorRef);
      return;
    }
    actorScope.defer(() => {
      actorScope.stopChild(actorRef);
    });
  }
}
function stopChild(actorRef) {
  function stop(_args, _params) {
  }
  return stop.type = "xstate.stopChild", stop.actorRef = actorRef, stop.resolve = resolveStop, stop.execute = executeStop, stop;
}
function evaluateGuard(guard, context2, event, snapshot) {
  const {
    machine: machine2
  } = snapshot, isInline = typeof guard == "function", resolved = isInline ? guard : machine2.implementations.guards[typeof guard == "string" ? guard : guard.type];
  if (!isInline && !resolved)
    throw new Error(`Guard '${typeof guard == "string" ? guard : guard.type}' is not implemented.'.`);
  if (typeof resolved != "function")
    return evaluateGuard(resolved, context2, event, snapshot);
  const guardArgs = {
    context: context2,
    event
  }, guardParams = isInline || typeof guard == "string" ? void 0 : "params" in guard ? typeof guard.params == "function" ? guard.params({
    context: context2,
    event
  }) : guard.params : void 0;
  return "check" in resolved ? resolved.check(
    snapshot,
    guardArgs,
    resolved
    // this holds all params
  ) : resolved(guardArgs, guardParams);
}
const isAtomicStateNode = (stateNode) => stateNode.type === "atomic" || stateNode.type === "final";
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter((sn) => sn.type !== "history");
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = [];
  if (toStateNode === stateNode)
    return ancestors;
  let m2 = stateNode.parent;
  for (; m2 && m2 !== toStateNode; )
    ancestors.push(m2), m2 = m2.parent;
  return ancestors;
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes), adjList = getAdjList(nodeSet);
  for (const s2 of nodeSet)
    if (s2.type === "compound" && (!adjList.get(s2) || !adjList.get(s2).length))
      getInitialStateNodesWithTheirAncestors(s2).forEach((sn) => nodeSet.add(sn));
    else if (s2.type === "parallel") {
      for (const child of getChildren(s2))
        if (child.type !== "history" && !nodeSet.has(child)) {
          const initialStates = getInitialStateNodesWithTheirAncestors(child);
          for (const initialStateNode of initialStates)
            nodeSet.add(initialStateNode);
        }
    }
  for (const s2 of nodeSet) {
    let m2 = s2.parent;
    for (; m2; )
      nodeSet.add(m2), m2 = m2.parent;
  }
  return nodeSet;
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode);
  if (!childStateNodes)
    return {};
  if (baseNode.type === "compound") {
    const childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode))
        return childStateNode.key;
    } else
      return {};
  }
  const stateValue = {};
  for (const childStateNode of childStateNodes)
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
  return stateValue;
}
function getAdjList(stateNodes) {
  const adjList = /* @__PURE__ */ new Map();
  for (const s2 of stateNodes)
    adjList.has(s2) || adjList.set(s2, []), s2.parent && (adjList.has(s2.parent) || adjList.set(s2.parent, []), adjList.get(s2.parent).push(s2));
  return adjList;
}
function getStateValue(rootNode, stateNodes) {
  const config = getAllStateNodes(stateNodes);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function isInFinalState(stateNodeSet, stateNode) {
  return stateNode.type === "compound" ? getChildren(stateNode).some((s2) => s2.type === "final" && stateNodeSet.has(s2)) : stateNode.type === "parallel" ? getChildren(stateNode).every((sn) => isInFinalState(stateNodeSet, sn)) : stateNode.type === "final";
}
const isStateId = (str) => str[0] === STATE_IDENTIFIER$1;
function getCandidates(stateNode, receivedEventType) {
  return stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter((eventDescriptor) => {
    if (eventDescriptor === WILDCARD)
      return !0;
    if (!eventDescriptor.endsWith(".*"))
      return !1;
    const partialEventTokens = eventDescriptor.split("."), eventTokens = receivedEventType.split(".");
    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
      const partialEventToken = partialEventTokens[tokenIndex], eventToken = eventTokens[tokenIndex];
      if (partialEventToken === "*")
        return tokenIndex === partialEventTokens.length - 1;
      if (partialEventToken !== eventToken)
        return !1;
    }
    return !0;
  }).sort((a2, b2) => b2.length - a2.length).flatMap((key2) => stateNode.transitions.get(key2));
}
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after;
  if (!afterConfig)
    return [];
  const mutateEntryExit = (delay2) => {
    const afterEvent = createAfterEvent(delay2, stateNode.id), eventType = afterEvent.type;
    return stateNode.entry.push(raise(afterEvent, {
      id: eventType,
      delay: delay2
    })), stateNode.exit.push(cancel(eventType)), eventType;
  };
  return Object.keys(afterConfig).flatMap((delay2) => {
    const configTransition = afterConfig[delay2], resolvedTransition = typeof configTransition == "string" ? {
      target: configTransition
    } : configTransition, resolvedDelay = Number.isNaN(+delay2) ? delay2 : +delay2, eventType = mutateEntryExit(resolvedDelay);
    return toArray(resolvedTransition).map((transition) => ({
      ...transition,
      event: eventType,
      delay: resolvedDelay
    }));
  }).map((delayedTransition) => {
    const {
      delay: delay2
    } = delayedTransition;
    return {
      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
      delay: delay2
    };
  });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  const normalizedTarget = normalizeTarget(transitionConfig.target), reenter = transitionConfig.reenter ?? !1, target = resolveTarget(stateNode, normalizedTarget), transition = {
    ...transitionConfig,
    actions: toArray(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: target ? target.map((t2) => `#${t2.id}`) : void 0
    })
  };
  return transition;
}
function formatTransitions(stateNode) {
  const transitions2 = /* @__PURE__ */ new Map();
  if (stateNode.config.on)
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const transitionsConfig = stateNode.config.on[descriptor];
      transitions2.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`;
    transitions2.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t2) => formatTransition(stateNode, descriptor, t2)));
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions2.get(delayedTransition.eventType);
    existing || (existing = [], transitions2.set(delayedTransition.eventType, existing)), existing.push(delayedTransition);
  }
  return transitions2;
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget = typeof _target == "string" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : void 0;
  if (!resolvedTarget && _target)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${_target}" not found on parent state node #${stateNode.id}`
    );
  const transition = {
    source: stateNode,
    actions: !_target || typeof _target == "string" ? [] : toArray(_target.actions),
    eventType: null,
    reenter: !1,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
    })
  };
  return transition;
}
function resolveTarget(stateNode, targets) {
  if (targets !== void 0)
    return targets.map((target) => {
      if (typeof target != "string")
        return target;
      if (isStateId(target))
        return stateNode.machine.getStateNodeById(target);
      const isInternalTarget = target[0] === STATE_DELIMITER;
      if (isInternalTarget && !stateNode.parent)
        return getStateNodeByPath(stateNode, target.slice(1));
      const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
      if (stateNode.parent)
        try {
          return getStateNodeByPath(stateNode.parent, resolvedTarget);
        } catch (err) {
          throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
        }
      else
        throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    });
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target);
  return normalizedTarget ? {
    target: normalizedTarget.map((t2) => typeof t2 == "string" ? getStateNodeByPath(stateNode.parent, t2) : t2)
  } : stateNode.parent.initial;
}
function isHistoryNode(stateNode) {
  return stateNode.type === "history";
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode);
  for (const initialState2 of states)
    for (const ancestor of getProperAncestors(initialState2, stateNode))
      states.add(ancestor);
  return states;
}
function getInitialStateNodes(stateNode) {
  const set2 = /* @__PURE__ */ new Set();
  function iter(descStateNode) {
    if (!set2.has(descStateNode)) {
      if (set2.add(descStateNode), descStateNode.type === "compound")
        iter(descStateNode.initial.target[0]);
      else if (descStateNode.type === "parallel")
        for (const child of getChildren(descStateNode))
          iter(child);
    }
  }
  return iter(stateNode), set2;
}
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey))
    return stateNode.machine.getStateNodeById(stateKey);
  if (!stateNode.states)
    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
  const result = stateNode.states[stateKey];
  if (!result)
    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
  return result;
}
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath == "string" && isStateId(statePath))
    try {
      return stateNode.machine.getStateNodeById(statePath);
    } catch {
    }
  const arrayStatePath = toStatePath(statePath).slice();
  let currentStateNode = stateNode;
  for (; arrayStatePath.length; ) {
    const key2 = arrayStatePath.shift();
    if (!key2.length)
      break;
    currentStateNode = getStateNode(currentStateNode, key2);
  }
  return currentStateNode;
}
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue == "string") {
    const childStateNode = stateNode.states[stateValue];
    if (!childStateNode)
      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
    return [stateNode, childStateNode];
  }
  const childStateKeys = Object.keys(stateValue), childStateNodes = childStateKeys.map((subStateKey) => getStateNode(stateNode, subStateKey)).filter(Boolean);
  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
    const subStateNode = getStateNode(stateNode, subStateKey);
    if (!subStateNode)
      return allSubStateNodes;
    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
    return allSubStateNodes.concat(subStateNodes);
  }, []));
}
function transitionAtomicNode(stateNode, stateValue, snapshot, event) {
  const next = getStateNode(stateNode, stateValue).next(snapshot, event);
  return !next || !next.length ? stateNode.next(snapshot, event) : next;
}
function transitionCompoundNode(stateNode, stateValue, snapshot, event) {
  const subStateKeys = Object.keys(stateValue), childStateNode = getStateNode(stateNode, subStateKeys[0]), next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);
  return !next || !next.length ? stateNode.next(snapshot, event) : next;
}
function transitionParallelNode(stateNode, stateValue, snapshot, event) {
  const allInnerTransitions = [];
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey];
    if (!subStateValue)
      continue;
    const subStateNode = getStateNode(stateNode, subStateKey), innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);
    innerTransitions && allInnerTransitions.push(...innerTransitions);
  }
  return allInnerTransitions.length ? allInnerTransitions : stateNode.next(snapshot, event);
}
function transitionNode(stateNode, stateValue, snapshot, event) {
  return typeof stateValue == "string" ? transitionAtomicNode(stateNode, stateValue, snapshot, event) : Object.keys(stateValue).length === 1 ? transitionCompoundNode(stateNode, stateValue, snapshot, event) : transitionParallelNode(stateNode, stateValue, snapshot, event);
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states).map((key2) => stateNode.states[key2]).filter((sn) => sn.type === "history");
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode;
  for (; marker.parent && marker.parent !== parentStateNode; )
    marker = marker.parent;
  return marker.parent === parentStateNode;
}
function hasIntersection(s1, s2) {
  const set1 = new Set(s1), set2 = new Set(s2);
  for (const item of set1)
    if (set2.has(item))
      return !0;
  for (const item of set2)
    if (set1.has(item))
      return !0;
  return !1;
}
function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
  const filteredTransitions = /* @__PURE__ */ new Set();
  for (const t1 of enabledTransitions) {
    let t1Preempted = !1;
    const transitionsToRemove = /* @__PURE__ */ new Set();
    for (const t2 of filteredTransitions)
      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue)))
        if (isDescendant(t1.source, t2.source))
          transitionsToRemove.add(t2);
        else {
          t1Preempted = !0;
          break;
        }
    if (!t1Preempted) {
      for (const t3 of transitionsToRemove)
        filteredTransitions.delete(t3);
      filteredTransitions.add(t1);
    }
  }
  return Array.from(filteredTransitions);
}
function findLeastCommonAncestor(stateNodes) {
  const [head, ...tail] = stateNodes;
  for (const ancestor of getProperAncestors(head, void 0))
    if (tail.every((sn) => isDescendant(sn, ancestor)))
      return ancestor;
}
function getEffectiveTargetStates(transition, historyValue) {
  if (!transition.target)
    return [];
  const targets = /* @__PURE__ */ new Set();
  for (const targetNode of transition.target)
    if (isHistoryNode(targetNode))
      if (historyValue[targetNode.id])
        for (const node2 of historyValue[targetNode.id])
          targets.add(node2);
      else
        for (const node2 of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue))
          targets.add(node2);
    else
      targets.add(targetNode);
  return [...targets];
}
function getTransitionDomain(transition, historyValue) {
  const targetStates = getEffectiveTargetStates(transition, historyValue);
  if (!targetStates)
    return;
  if (!transition.reenter && targetStates.every((target) => target === transition.source || isDescendant(target, transition.source)))
    return transition.source;
  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));
  if (lca)
    return lca;
  if (!transition.reenter)
    return transition.source.machine.root;
}
function computeExitSet(transitions2, stateNodeSet, historyValue) {
  const statesToExit = /* @__PURE__ */ new Set();
  for (const t2 of transitions2)
    if (t2.target?.length) {
      const domain = getTransitionDomain(t2, historyValue);
      t2.reenter && t2.source === domain && statesToExit.add(domain);
      for (const stateNode of stateNodeSet)
        isDescendant(stateNode, domain) && statesToExit.add(stateNode);
    }
  return [...statesToExit];
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size)
    return !1;
  for (const node2 of prevStateNodes)
    if (!nextStateNodeSet.has(node2))
      return !1;
  return !0;
}
function microstep(transitions2, currentSnapshot, actorScope, event, isInitial, internalQueue) {
  if (!transitions2.length)
    return currentSnapshot;
  const mutStateNodeSet = new Set(currentSnapshot._nodes);
  let historyValue = currentSnapshot.historyValue;
  const filteredTransitions = removeConflictingTransitions(transitions2, mutStateNodeSet, historyValue);
  let nextState = currentSnapshot;
  isInitial || ([nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor)), nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t2) => t2.actions), internalQueue, void 0), nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
  const nextStateNodes = [...mutStateNodeSet];
  nextState.status === "done" && (nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a2, b2) => b2.order - a2.order).flatMap((state) => state.exit), internalQueue, void 0));
  try {
    return historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet) ? nextState : cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue
    });
  } catch (e2) {
    throw e2;
  }
}
function getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {
  if (rootNode.output === void 0)
    return;
  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== void 0 && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : void 0);
  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
}
function enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
  let nextSnapshot = currentSnapshot;
  const statesToEnter = /* @__PURE__ */ new Set(), statesForDefaultEntry = /* @__PURE__ */ new Set();
  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter), isInitial && statesForDefaultEntry.add(currentSnapshot.machine.root);
  const completedNodes = /* @__PURE__ */ new Set();
  for (const stateNodeToEnter of [...statesToEnter].sort((a2, b2) => a2.order - b2.order)) {
    mutStateNodeSet.add(stateNodeToEnter);
    const actions = [];
    actions.push(...stateNodeToEnter.entry);
    for (const invokeDef of stateNodeToEnter.invoke)
      actions.push(spawnChild(invokeDef.src, {
        ...invokeDef,
        syncSnapshot: !!invokeDef.onSnapshot
      }));
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions;
      actions.push(...initialActions);
    }
    if (nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)), stateNodeToEnter.type === "final") {
      const parent = stateNodeToEnter.parent;
      let ancestorMarker = parent?.type === "parallel" ? parent : parent?.parent, rootCompletionNode = ancestorMarker || stateNodeToEnter;
      for (parent?.type === "compound" && internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== void 0 ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : void 0)); ancestorMarker?.type === "parallel" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker); )
        completedNodes.add(ancestorMarker), internalQueue.push(createDoneStateEvent(ancestorMarker.id)), rootCompletionNode = ancestorMarker, ancestorMarker = ancestorMarker.parent;
      if (ancestorMarker)
        continue;
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: "done",
        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)
      });
    }
  }
  return nextSnapshot;
}
function computeEntrySet(transitions2, historyValue, statesForDefaultEntry, statesToEnter) {
  for (const t2 of transitions2) {
    const domain = getTransitionDomain(t2, historyValue);
    for (const s2 of t2.target || [])
      !isHistoryNode(s2) && // if the target is different than the source then it will *definitely* be entered
      (t2.source !== s2 || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      t2.source !== domain || // reentering transitions always enter the target, even if it's the source itself
      t2.reenter) && (statesToEnter.add(s2), statesForDefaultEntry.add(s2)), addDescendantStatesToEnter(s2, historyValue, statesForDefaultEntry, statesToEnter);
    const targetStates = getEffectiveTargetStates(t2, historyValue);
    for (const s2 of targetStates) {
      const ancestors = getProperAncestors(s2, domain);
      domain?.type === "parallel" && ancestors.push(domain), addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t2.source.parent && t2.reenter ? void 0 : domain);
    }
  }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
  if (isHistoryNode(stateNode))
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id];
      for (const s2 of historyStateNodes)
        statesToEnter.add(s2), addDescendantStatesToEnter(s2, historyValue, statesForDefaultEntry, statesToEnter);
      for (const s2 of historyStateNodes)
        addProperAncestorStatesToEnter(s2, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
    } else {
      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
      for (const s2 of historyDefaultTransition.target)
        statesToEnter.add(s2), historyDefaultTransition === stateNode.parent?.initial && statesForDefaultEntry.add(stateNode.parent), addDescendantStatesToEnter(s2, historyValue, statesForDefaultEntry, statesToEnter);
      for (const s2 of historyDefaultTransition.target)
        addProperAncestorStatesToEnter(s2, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
    }
  else if (stateNode.type === "compound") {
    const [initialState2] = stateNode.initial.target;
    isHistoryNode(initialState2) || (statesToEnter.add(initialState2), statesForDefaultEntry.add(initialState2)), addDescendantStatesToEnter(initialState2, historyValue, statesForDefaultEntry, statesToEnter), addProperAncestorStatesToEnter(initialState2, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
  } else if (stateNode.type === "parallel")
    for (const child of getChildren(stateNode).filter((sn) => !isHistoryNode(sn)))
      [...statesToEnter].some((s2) => isDescendant(s2, child)) || (isHistoryNode(child) || (statesToEnter.add(child), statesForDefaultEntry.add(child)), addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter));
}
function addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
  for (const anc of ancestors)
    if ((!reentrancyDomain || isDescendant(anc, reentrancyDomain)) && statesToEnter.add(anc), anc.type === "parallel")
      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn)))
        [...statesToEnter].some((s2) => isDescendant(s2, child)) || (statesToEnter.add(child), addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter));
}
function addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));
}
function exitStates(currentSnapshot, event, actorScope, transitions2, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {
  let nextSnapshot = currentSnapshot;
  const statesToExit = computeExitSet(transitions2, mutStateNodeSet, historyValue);
  statesToExit.sort((a2, b2) => b2.order - a2.order);
  let changedHistory;
  for (const exitStateNode of statesToExit)
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate;
      historyNode.history === "deep" ? predicate = (sn) => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode) : predicate = (sn) => sn.parent === exitStateNode, changedHistory ??= {
        ...historyValue
      }, changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
    }
  for (const s2 of statesToExit)
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s2.exit, ...s2.invoke.map((def) => stopChild(def.id))], internalQueue, void 0), mutStateNodeSet.delete(s2);
  return [nextSnapshot, changedHistory || historyValue];
}
function getAction(machine2, actionType) {
  return machine2.implementations.actions[actionType];
}
function resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {
  const {
    machine: machine2
  } = currentSnapshot;
  let intermediateSnapshot = currentSnapshot;
  for (const action of actions) {
    const isInline = typeof action == "function", resolvedAction = isInline ? action : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      getAction(machine2, typeof action == "string" ? action : action.type)
    ), actionArgs = {
      context: intermediateSnapshot.context,
      event,
      self: actorScope.self,
      system: actorScope.system
    }, actionParams = isInline || typeof action == "string" ? void 0 : "params" in action ? typeof action.params == "function" ? action.params({
      context: intermediateSnapshot.context,
      event
    }) : action.params : void 0;
    if (!resolvedAction || !("resolve" in resolvedAction)) {
      actorScope.actionExecutor({
        type: typeof action == "string" ? action : typeof action == "object" ? action.type : action.name || "(anonymous)",
        info: actionArgs,
        params: actionParams,
        exec: resolvedAction
      });
      continue;
    }
    const builtinAction = resolvedAction, [nextState, params, actions2] = builtinAction.resolve(
      actorScope,
      intermediateSnapshot,
      actionArgs,
      actionParams,
      resolvedAction,
      // this holds all params
      extra
    );
    intermediateSnapshot = nextState, "retryResolve" in builtinAction && retries?.push([builtinAction, params]), "execute" in builtinAction && actorScope.actionExecutor({
      type: builtinAction.type,
      info: actionArgs,
      params,
      exec: builtinAction.execute.bind(null, actorScope, params)
    }), actions2 && (intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions2, extra, retries));
  }
  return intermediateSnapshot;
}
function resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {
  const retries = deferredActorIds ? [] : void 0, nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {
    internalQueue,
    deferredActorIds
  }, retries);
  return retries?.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params);
  }), nextState;
}
function macrostep(snapshot, event, actorScope, internalQueue) {
  let nextSnapshot = snapshot;
  const microstates = [];
  function addMicrostate(microstate, event2, transitions2) {
    actorScope.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: actorScope.self,
      event: event2,
      snapshot: microstate,
      _transitions: transitions2
    }), microstates.push(microstate);
  }
  if (event.type === XSTATE_STOP)
    return nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {
      status: "stopped"
    }), addMicrostate(nextSnapshot, event, []), {
      snapshot: nextSnapshot,
      microstates
    };
  let nextEvent = event;
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent, isErr = isErrorActorEvent(currentEvent), transitions2 = selectTransitions(currentEvent, nextSnapshot);
    if (isErr && !transitions2.length)
      return nextSnapshot = cloneMachineSnapshot(snapshot, {
        status: "error",
        error: currentEvent.error
      }), addMicrostate(nextSnapshot, currentEvent, []), {
        snapshot: nextSnapshot,
        microstates
      };
    nextSnapshot = microstep(
      transitions2,
      snapshot,
      actorScope,
      nextEvent,
      !1,
      // isInitial
      internalQueue
    ), addMicrostate(nextSnapshot, currentEvent, transitions2);
  }
  let shouldSelectEventlessTransitions = !0;
  for (; nextSnapshot.status === "active"; ) {
    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];
    const previousState = enabledTransitions.length ? nextSnapshot : void 0;
    if (!enabledTransitions.length) {
      if (!internalQueue.length)
        break;
      nextEvent = internalQueue.shift(), enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
    }
    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, !1, internalQueue), shouldSelectEventlessTransitions = nextSnapshot !== previousState, addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
  }
  return nextSnapshot.status !== "active" && stopChildren(nextSnapshot, nextEvent, actorScope), {
    snapshot: nextSnapshot,
    microstates
  };
}
function stopChildren(nextState, event, actorScope) {
  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child) => stopChild(child)), [], void 0);
}
function selectTransitions(event, nextState) {
  return nextState.machine.getTransitionData(nextState, event);
}
function selectEventlessTransitions(nextState, event) {
  const enabledTransitionSet = /* @__PURE__ */ new Set(), atomicStates = nextState._nodes.filter(isAtomicStateNode);
  for (const stateNode of atomicStates)
    loop: for (const s2 of [stateNode].concat(getProperAncestors(stateNode, void 0)))
      if (s2.always) {
        for (const transition of s2.always)
          if (transition.guard === void 0 || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
            enabledTransitionSet.add(transition);
            break loop;
          }
      }
  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
}
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
  return getStateValue(rootNode, [...allStateNodes]);
}
function isMachineSnapshot(value) {
  return !!value && typeof value == "object" && "machine" in value && "value" in value;
}
const machineSnapshotMatches = function(testValue) {
  return matchesState(testValue, this.value);
}, machineSnapshotHasTag = function(tag) {
  return this.tags.has(tag);
}, machineSnapshotCan = function(event) {
  const transitionData = this.machine.getTransitionData(this, event);
  return !!transitionData?.length && // Check that at least one transition is not forbidden
  transitionData.some((t2) => t2.target !== void 0 || t2.actions.length);
}, machineSnapshotToJSON = function() {
  const {
    _nodes: nodes,
    tags,
    machine: machine2,
    getMeta: getMeta2,
    toJSON: toJSON2,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    ...jsonValues
  } = this;
  return {
    ...jsonValues,
    tags: Array.from(tags)
  };
}, machineSnapshotGetMeta = function() {
  return this._nodes.reduce((acc, stateNode) => (stateNode.meta !== void 0 && (acc[stateNode.id] = stateNode.meta), acc), {});
};
function createMachineSnapshot(config, machine2) {
  return {
    status: config.status,
    output: config.output,
    error: config.error,
    machine: machine2,
    context: config.context,
    _nodes: config._nodes,
    value: getStateValue(machine2.root, config._nodes),
    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),
    children: config.children,
    historyValue: config.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON
  };
}
function cloneMachineSnapshot(snapshot, config = {}) {
  return createMachineSnapshot({
    ...snapshot,
    ...config
  }, snapshot.machine);
}
function serializeHistoryValue(historyValue) {
  if (typeof historyValue != "object" || historyValue === null)
    return {};
  const result = {};
  for (const key2 in historyValue) {
    const value = historyValue[key2];
    Array.isArray(value) && (result[key2] = value.map((item) => ({
      id: item.id
    })));
  }
  return result;
}
function getPersistedSnapshot(snapshot, options) {
  const {
    _nodes: nodes,
    tags,
    machine: machine2,
    children: children2,
    context: context2,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    getMeta: getMeta2,
    toJSON: toJSON2,
    ...jsonValues
  } = snapshot, childrenJson = {};
  for (const id2 in children2) {
    const child = children2[id2];
    childrenJson[id2] = {
      snapshot: child.getPersistedSnapshot(options),
      src: child.src,
      systemId: child.systemId,
      syncSnapshot: child._syncSnapshot
    };
  }
  return {
    ...jsonValues,
    context: persistContext(context2),
    children: childrenJson,
    historyValue: serializeHistoryValue(jsonValues.historyValue)
  };
}
function persistContext(contextPart) {
  let copy;
  for (const key2 in contextPart) {
    const value = contextPart[key2];
    if (value && typeof value == "object")
      if ("sessionId" in value && "send" in value && "ref" in value)
        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
          ...contextPart
        }, copy[key2] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id
        };
      else {
        const result = persistContext(value);
        result !== value && (copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
          ...contextPart
        }, copy[key2] = result);
      }
  }
  return copy ?? contextPart;
}
function resolveRaise(_, snapshot, args, actionParams, {
  event: eventOrExpr,
  id: id2,
  delay: delay2
}, {
  internalQueue
}) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`
    );
  const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 == "string") {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
  } else
    resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
  return typeof resolvedDelay != "number" && internalQueue.push(resolvedEvent), [snapshot, {
    event: resolvedEvent,
    id: id2,
    delay: resolvedDelay
  }, void 0];
}
function executeRaise(actorScope, params) {
  const {
    event,
    delay: delay2,
    id: id2
  } = params;
  if (typeof delay2 == "number") {
    actorScope.defer(() => {
      const self2 = actorScope.self;
      actorScope.system.scheduler.schedule(self2, self2, event, delay2, id2);
    });
    return;
  }
}
function raise(eventOrExpr, options) {
  function raise2(_args, _params) {
  }
  return raise2.type = "xstate.raise", raise2.event = eventOrExpr, raise2.id = options?.id, raise2.delay = options?.delay, raise2.resolve = resolveRaise, raise2.execute = executeRaise, raise2;
}
const instanceStates = /* @__PURE__ */ new WeakMap();
function fromCallback(callback) {
  return {
    config: callback,
    start: (state, actorScope) => {
      const {
        self: self2,
        system,
        emit: emit2
      } = actorScope, callbackState = {
        receivers: void 0,
        dispose: void 0
      };
      instanceStates.set(self2, callbackState), callbackState.dispose = callback({
        input: state.input,
        system,
        self: self2,
        sendBack: (event) => {
          self2.getSnapshot().status !== "stopped" && self2._parent && system._relay(self2, self2._parent, event);
        },
        receive: (listener) => {
          callbackState.receivers ??= /* @__PURE__ */ new Set(), callbackState.receivers.add(listener);
        },
        emit: emit2
      });
    },
    transition: (state, event, actorScope) => {
      const callbackState = instanceStates.get(actorScope.self);
      return event.type === XSTATE_STOP ? (state = {
        ...state,
        status: "stopped",
        error: void 0
      }, callbackState.dispose?.(), state) : (callbackState.receivers?.forEach((receiver) => receiver(event)), state);
    },
    getInitialSnapshot: (_, input2) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input: input2
    }),
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
}
const XSTATE_PROMISE_RESOLVE = "xstate.promise.resolve", XSTATE_PROMISE_REJECT = "xstate.promise.reject", controllerMap = /* @__PURE__ */ new WeakMap();
function fromPromise(promiseCreator) {
  return {
    config: promiseCreator,
    transition: (state, event, scope) => {
      if (state.status !== "active")
        return state;
      switch (event.type) {
        case XSTATE_PROMISE_RESOLVE: {
          const resolvedValue = event.data;
          return {
            ...state,
            status: "done",
            output: resolvedValue,
            input: void 0
          };
        }
        case XSTATE_PROMISE_REJECT:
          return {
            ...state,
            status: "error",
            error: event.data,
            input: void 0
          };
        case XSTATE_STOP:
          return controllerMap.get(scope.self)?.abort(), {
            ...state,
            status: "stopped",
            input: void 0
          };
        default:
          return state;
      }
    },
    start: (state, {
      self: self2,
      system,
      emit: emit2
    }) => {
      if (state.status !== "active")
        return;
      const controller = new AbortController();
      controllerMap.set(self2, controller), Promise.resolve(promiseCreator({
        input: state.input,
        system,
        self: self2,
        signal: controller.signal,
        emit: emit2
      })).then((response) => {
        self2.getSnapshot().status === "active" && (controllerMap.delete(self2), system._relay(self2, self2, {
          type: XSTATE_PROMISE_RESOLVE,
          data: response
        }));
      }, (errorData) => {
        self2.getSnapshot().status === "active" && (controllerMap.delete(self2), system._relay(self2, self2, {
          type: XSTATE_PROMISE_REJECT,
          data: errorData
        }));
      });
    },
    getInitialSnapshot: (_, input2) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input: input2
    }),
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
}
function createSpawner(actorScope, {
  machine: machine2,
  context: context2
}, event, spawnedChildren) {
  const spawn = (src, options) => {
    if (typeof src == "string") {
      const logic = resolveReferencedActor(machine2, src);
      if (!logic)
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine2.id}'`);
      const actorRef = createActor(logic, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: typeof options?.input == "function" ? options.input({
          context: context2,
          event,
          self: actorScope.self
        }) : options?.input,
        src,
        systemId: options?.systemId
      });
      return spawnedChildren[actorRef.id] = actorRef, actorRef;
    } else
      return createActor(src, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: options?.input,
        src,
        systemId: options?.systemId
      });
  };
  return (src, options) => {
    const actorRef = spawn(src, options);
    return spawnedChildren[actorRef.id] = actorRef, actorScope.defer(() => {
      actorRef._processingStatus !== ProcessingStatus.Stopped && actorRef.start();
    }), actorRef;
  };
}
function resolveAssign(actorScope, snapshot, actionArgs, actionParams, {
  assignment
}) {
  if (!snapshot.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const spawnedChildren = {}, assignArgs = {
    context: snapshot.context,
    event: actionArgs.event,
    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),
    self: actorScope.self,
    system: actorScope.system
  };
  let partialUpdate = {};
  if (typeof assignment == "function")
    partialUpdate = assignment(assignArgs, actionParams);
  else
    for (const key2 of Object.keys(assignment)) {
      const propAssignment = assignment[key2];
      partialUpdate[key2] = typeof propAssignment == "function" ? propAssignment(assignArgs, actionParams) : propAssignment;
    }
  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
  return [cloneMachineSnapshot(snapshot, {
    context: updatedContext,
    children: Object.keys(spawnedChildren).length ? {
      ...snapshot.children,
      ...spawnedChildren
    } : snapshot.children
  }), void 0, void 0];
}
function assign(assignment) {
  function assign2(_args, _params) {
  }
  return assign2.type = "xstate.assign", assign2.assignment = assignment, assign2.resolve = resolveAssign, assign2;
}
const cache = /* @__PURE__ */ new WeakMap();
function memo$1(object2, key2, fn) {
  let memoizedData = cache.get(object2);
  return memoizedData ? key2 in memoizedData || (memoizedData[key2] = fn()) : (memoizedData = {
    [key2]: fn()
  }, cache.set(object2, memoizedData)), memoizedData[key2];
}
const EMPTY_OBJECT = {}, toSerializableAction = (action) => typeof action == "string" ? {
  type: action
} : typeof action == "function" ? "resolve" in action ? {
  type: action.type
} : {
  type: action.name
} : action;
class StateNode {
  constructor(config, options) {
    if (this.config = config, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = options._parent, this.key = options._key, this.machine = options._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key2) => new StateNode(stateConfig, {
      _parent: this,
      _key: key2,
      _machine: this.machine
    })) : EMPTY_OBJECT, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = toArray(this.config.entry).slice(), this.exit = toArray(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = toArray(config.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = formatTransitions(this), this.config.always && (this.always = toTransitionConfigArray(this.config.always).map((t2) => formatTransition(this, NULL_EVENT, t2))), Object.keys(this.states).forEach((key2) => {
      this.states[key2]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(toSerializableAction),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((t2) => `#${t2.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: mapValues(this.states, (state) => state.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t2) => ({
        ...t2,
        actions: t2.actions.map(toSerializableAction)
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return memo$1(this, "invoke", () => toArray(this.config.invoke).map((invokeConfig, i2) => {
      const {
        src,
        systemId
      } = invokeConfig, resolvedId = invokeConfig.id ?? createInvokeId(this.id, i2), sourceName = typeof src == "string" ? src : `xstate.invoke.${createInvokeId(this.id, i2)}`;
      return {
        ...invokeConfig,
        src: sourceName,
        id: resolvedId,
        systemId,
        toJSON() {
          const {
            onDone,
            onError,
            ...invokeDefValues
          } = invokeConfig;
          return {
            ...invokeDefValues,
            type: "xstate.invoke",
            src: sourceName,
            id: resolvedId
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return memo$1(this, "on", () => [...this.transitions].flatMap(([descriptor, t2]) => t2.map((t3) => [descriptor, t3])).reduce((map, [descriptor, transition]) => (map[descriptor] = map[descriptor] || [], map[descriptor].push(transition), map), {}));
  }
  get after() {
    return memo$1(this, "delayedTransitions", () => getDelayedTransitions(this));
  }
  get initial() {
    return memo$1(this, "initial", () => formatInitialTransition(this, this.config.initial));
  }
  /** @internal */
  next(snapshot, event) {
    const eventType = event.type, actions = [];
    let selectedTransition;
    const candidates = memo$1(this, `candidates-${eventType}`, () => getCandidates(this, eventType));
    for (const candidate of candidates) {
      const {
        guard
      } = candidate, resolvedContext = snapshot.context;
      let guardPassed = !1;
      try {
        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);
      } catch (err) {
        const guardType = typeof guard == "string" ? guard : typeof guard == "object" ? guard.type : void 0;
        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ""}in transition for event '${eventType}' in state node '${this.id}':
${err.message}`);
      }
      if (guardPassed) {
        actions.push(...candidate.actions), selectedTransition = candidate;
        break;
      }
    }
    return selectedTransition ? [selectedTransition] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return memo$1(this, "events", () => {
      const {
        states
      } = this, events = new Set(this.ownEvents);
      if (states)
        for (const stateId of Object.keys(states)) {
          const state = states[stateId];
          if (state.states)
            for (const event of state.events)
              events.add(`${event}`);
        }
      return Array.from(events);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set([...this.transitions.keys()].filter((descriptor) => this.transitions.get(descriptor).some((transition) => !(!transition.target && !transition.actions.length && !transition.reenter))));
    return Array.from(events);
  }
}
const STATE_IDENTIFIER = "#";
class StateMachine {
  constructor(config, implementations) {
    this.config = config, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = config.id || "(machine)", this.implementations = {
      actors: implementations?.actors ?? {},
      actions: implementations?.actions ?? {},
      delays: implementations?.delays ?? {},
      guards: implementations?.guards ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new StateNode(config, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations.
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to
   *   recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {
      actions,
      guards,
      actors,
      delays
    } = this.implementations;
    return new StateMachine(this.config, {
      actions: {
        ...actions,
        ...implementations.actions
      },
      guards: {
        ...guards,
        ...implementations.guards
      },
      actors: {
        ...actors,
        ...implementations.actors
      },
      delays: {
        ...delays,
        ...implementations.delays
      }
    });
  }
  resolveState(config) {
    const resolvedStateValue = resolveStateValue(this.root, config.value), nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));
    return createMachineSnapshot({
      _nodes: [...nodeSet],
      context: config.context || {},
      children: {},
      status: isInFinalState(nodeSet, this.root) ? "done" : config.status || "active",
      output: config.output,
      error: config.error,
      historyValue: config.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).microstates;
  }
  getTransitionData(snapshot, event) {
    return transitionNode(this.root, snapshot.value, snapshot, event) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorScope, initEvent, internalQueue) {
    const {
      context: context2
    } = this.config, preInitial = createMachineSnapshot({
      context: typeof context2 != "function" && context2 ? context2 : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof context2 == "function" ? resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(({
      spawn,
      event,
      self: self2
    }) => context2({
      spawn,
      input: event.input,
      self: self2
    }))], internalQueue, void 0) : preInitial;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(actorScope, input2) {
    const initEvent = createInitEvent(input2), internalQueue = [], preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue), nextState = microstep([{
      target: [...getInitialStateNodes(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], preInitialState, actorScope, initEvent, !0, internalQueue), {
      snapshot: macroState
    } = macrostep(nextState, initEvent, actorScope, internalQueue);
    return macroState;
  }
  start(snapshot) {
    Object.values(snapshot.children).forEach((child) => {
      child.getSnapshot().status === "active" && child.start();
    });
  }
  getStateNodeById(stateId) {
    const fullPath = toStatePath(stateId), relativePath = fullPath.slice(1), resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0], stateNode = this.idMap.get(resolvedStateId);
    if (!stateNode)
      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
    return getStateNodeByPath(stateNode, relativePath);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(snapshot, options) {
    return getPersistedSnapshot(snapshot, options);
  }
  restoreSnapshot(snapshot, _actorScope) {
    const children2 = {}, snapshotChildren = snapshot.children;
    Object.keys(snapshotChildren).forEach((actorId) => {
      const actorData = snapshotChildren[actorId], childState = actorData.snapshot, src = actorData.src, logic = typeof src == "string" ? resolveReferencedActor(this, src) : src;
      if (!logic)
        return;
      const actorRef = createActor(logic, {
        id: actorId,
        parent: _actorScope.self,
        syncSnapshot: actorData.syncSnapshot,
        snapshot: childState,
        src,
        systemId: actorData.systemId
      });
      children2[actorId] = actorRef;
    });
    function resolveHistoryReferencedState(root2, referenced) {
      if (referenced instanceof StateNode)
        return referenced;
      try {
        return root2.machine.getStateNodeById(referenced.id);
      } catch {
      }
    }
    function reviveHistoryValue(root2, historyValue) {
      if (!historyValue || typeof historyValue != "object")
        return {};
      const revived = {};
      for (const key2 in historyValue) {
        const arr = historyValue[key2];
        for (const item of arr) {
          const resolved = resolveHistoryReferencedState(root2, item);
          resolved && (revived[key2] ??= [], revived[key2].push(resolved));
        }
      }
      return revived;
    }
    const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue), restoredSnapshot = createMachineSnapshot({
      ...snapshot,
      children: children2,
      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value))),
      historyValue: revivedHistoryValue
    }, this), seen = /* @__PURE__ */ new Set();
    function reviveContext(contextPart, children3) {
      if (!seen.has(contextPart)) {
        seen.add(contextPart);
        for (const key2 in contextPart) {
          const value = contextPart[key2];
          if (value && typeof value == "object") {
            if ("xstate$$type" in value && value.xstate$$type === $$ACTOR_TYPE) {
              contextPart[key2] = children3[value.id];
              continue;
            }
            reviveContext(value, children3);
          }
        }
      }
    }
    return reviveContext(restoredSnapshot.context, children2), restoredSnapshot;
  }
}
function resolveEmit(_, snapshot, args, actionParams, {
  event: eventOrExpr
}) {
  const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  return [snapshot, {
    event: resolvedEvent
  }, void 0];
}
function executeEmit(actorScope, {
  event
}) {
  actorScope.defer(() => actorScope.emit(event));
}
function emit(eventOrExpr) {
  function emit2(_args, _params) {
  }
  return emit2.type = "xstate.emit", emit2.event = eventOrExpr, emit2.resolve = resolveEmit, emit2.execute = executeEmit, emit2;
}
let SpecialTargets = /* @__PURE__ */ (function(SpecialTargets2) {
  return SpecialTargets2.Parent = "#_parent", SpecialTargets2.Internal = "#_internal", SpecialTargets2;
})({});
function resolveSendTo(actorScope, snapshot, args, actionParams, {
  to: to2,
  event: eventOrExpr,
  id: id2,
  delay: delay2
}, extra) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`
    );
  const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 == "string") {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
  } else
    resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
  const resolvedTarget = typeof to2 == "function" ? to2(args, actionParams) : to2;
  let targetActorRef;
  if (typeof resolvedTarget == "string") {
    if (resolvedTarget === SpecialTargets.Parent ? targetActorRef = actorScope.self._parent : resolvedTarget === SpecialTargets.Internal ? targetActorRef = actorScope.self : resolvedTarget.startsWith("#_") ? targetActorRef = snapshot.children[resolvedTarget.slice(2)] : targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget], !targetActorRef)
      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);
  } else
    targetActorRef = resolvedTarget || actorScope.self;
  return [snapshot, {
    to: targetActorRef,
    targetId: typeof resolvedTarget == "string" ? resolvedTarget : void 0,
    event: resolvedEvent,
    id: id2,
    delay: resolvedDelay
  }, void 0];
}
function retryResolveSendTo(_, snapshot, params) {
  typeof params.to == "string" && (params.to = snapshot.children[params.to]);
}
function executeSendTo(actorScope, params) {
  actorScope.defer(() => {
    const {
      to: to2,
      event,
      delay: delay2,
      id: id2
    } = params;
    if (typeof delay2 == "number") {
      actorScope.system.scheduler.schedule(actorScope.self, to2, event, delay2, id2);
      return;
    }
    actorScope.system._relay(
      actorScope.self,
      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
      // if it initially started as a string
      to2,
      event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event
    );
  });
}
function sendTo(to2, eventOrExpr, options) {
  function sendTo2(_args, _params) {
  }
  return sendTo2.type = "xstate.sendTo", sendTo2.to = to2, sendTo2.event = eventOrExpr, sendTo2.id = options?.id, sendTo2.delay = options?.delay, sendTo2.resolve = resolveSendTo, sendTo2.retryResolve = retryResolveSendTo, sendTo2.execute = executeSendTo, sendTo2;
}
function sendParent(event, options) {
  return sendTo(SpecialTargets.Parent, event, options);
}
function resolveEnqueueActions(actorScope, snapshot, args, actionParams, {
  collect
}) {
  const actions = [], enqueue = function(action) {
    actions.push(action);
  };
  return enqueue.assign = (...args2) => {
    actions.push(assign(...args2));
  }, enqueue.cancel = (...args2) => {
    actions.push(cancel(...args2));
  }, enqueue.raise = (...args2) => {
    actions.push(raise(...args2));
  }, enqueue.sendTo = (...args2) => {
    actions.push(sendTo(...args2));
  }, enqueue.sendParent = (...args2) => {
    actions.push(sendParent(...args2));
  }, enqueue.spawnChild = (...args2) => {
    actions.push(spawnChild(...args2));
  }, enqueue.stopChild = (...args2) => {
    actions.push(stopChild(...args2));
  }, enqueue.emit = (...args2) => {
    actions.push(emit(...args2));
  }, collect({
    context: args.context,
    event: args.event,
    enqueue,
    check: (guard) => evaluateGuard(guard, snapshot.context, args.event, snapshot),
    self: actorScope.self,
    system: actorScope.system
  }, actionParams), [snapshot, void 0, actions];
}
function enqueueActions(collect) {
  function enqueueActions2(_args, _params) {
  }
  return enqueueActions2.type = "xstate.enqueueActions", enqueueActions2.collect = collect, enqueueActions2.resolve = resolveEnqueueActions, enqueueActions2;
}
function resolveLog(_, snapshot, actionArgs, actionParams, {
  value,
  label: label2
}) {
  return [snapshot, {
    value: typeof value == "function" ? value(actionArgs, actionParams) : value,
    label: label2
  }, void 0];
}
function executeLog({
  logger
}, {
  value,
  label: label2
}) {
  label2 ? logger(label2, value) : logger(value);
}
function log(value = ({
  context: context2,
  event
}) => ({
  context: context2,
  event
}), label2) {
  function log2(_args, _params) {
  }
  return log2.type = "xstate.log", log2.value = value, log2.label = label2, log2.resolve = resolveLog, log2.execute = executeLog, log2;
}
function assertEvent(event, type) {
  const types = toArray(type);
  if (!types.includes(event.type)) {
    const typesText = types.length === 1 ? `type "${types[0]}"` : `one of types "${types.join('", "')}"`;
    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);
  }
}
function createMachine(config, implementations) {
  return new StateMachine(config, implementations);
}
function setup({
  schemas,
  actors,
  actions,
  guards,
  delays
}) {
  return {
    assign,
    sendTo,
    raise,
    log,
    cancel,
    stopChild,
    enqueueActions,
    emit,
    spawnChild,
    createStateConfig: (config) => config,
    createAction: (fn) => fn,
    createMachine: (config) => createMachine({
      ...config,
      schemas
    }, {
      actors,
      actions,
      guards,
      delays
    }),
    extend: (extended) => setup({
      schemas,
      actors,
      actions: {
        ...actions,
        ...extended.actions
      },
      guards: {
        ...guards,
        ...extended.guards
      },
      delays: {
        ...delays,
        ...extended.delays
      }
    })
  };
}
requireShim();
const forEachActor = (actorRef, callback) => {
  callback(actorRef);
  const children2 = actorRef.getSnapshot().children;
  children2 && Object.values(children2).forEach((child) => {
    forEachActor(child, callback);
  });
};
function stopRootWithRehydration(actorRef) {
  const persistedSnapshots = [];
  forEachActor(actorRef, (ref) => {
    persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();
  });
  const systemSnapshot = actorRef.system.getSnapshot?.();
  actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {
    ref._processingStatus = 0, ref._snapshot = snapshot;
  });
}
function useIdleActorRef(logic, ...[options]) {
  let [[currentConfig, actorRef], setCurrent] = useState(() => {
    const actorRef2 = createActor(logic, options);
    return [logic.config, actorRef2];
  });
  if (logic.config !== currentConfig) {
    const newActorRef = createActor(logic, {
      ...options,
      snapshot: actorRef.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    setCurrent([logic.config, newActorRef]), actorRef = newActorRef;
  }
  return index(() => {
    actorRef.logic.implementations = logic.implementations;
  }), actorRef;
}
function useActorRef(machine2, ...[options, observerOrListener]) {
  const actorRef = useIdleActorRef(machine2, options);
  return useEffect(() => {
    if (!observerOrListener)
      return;
    const sub = actorRef.subscribe(toObserver(observerOrListener));
    return () => {
      sub.unsubscribe();
    };
  }, [observerOrListener]), useEffect(() => (actorRef.start(), () => {
    stopRootWithRehydration(actorRef);
  }), [actorRef]), actorRef;
}
function defaultCompare(a2, b2) {
  return a2 === b2;
}
function useSelector(actor, selector3, compare2 = defaultCompare) {
  const subscribe = useCallback((handleStoreChange) => {
    if (!actor)
      return () => {
      };
    const {
      unsubscribe
    } = actor.subscribe(handleStoreChange);
    return unsubscribe;
  }, [actor]), boundGetSnapshot = useCallback(() => actor?.getSnapshot(), [actor]);
  return withSelectorExports.useSyncExternalStoreWithSelector(subscribe, boundGetSnapshot, boundGetSnapshot, selector3, compare2);
}
const DiagramActorSafeContext = createContext(null);
DiagramActorSafeContext.displayName = "DiagramActorSafeContext";
const DiagramApiSafeContext = createContext(null);
DiagramApiSafeContext.displayName = "DiagramApiSafeContext";
const DiagramActorContextProvider = DiagramActorSafeContext.Provider, DiagramApiContextProvider = DiagramApiSafeContext.Provider;
function useDiagramActorRef() {
  const ctx = useContext(DiagramActorSafeContext);
  if (ctx === null)
    throw new Error("DiagramActorRef is not provided");
  return ctx;
}
function useDiagram() {
  const ctx = useContext(DiagramApiSafeContext);
  if (ctx === null)
    throw new Error("DiagramApi is not provided");
  return ctx;
}
function useCallbackRef(callback) {
  const ref = useRef(callback);
  ref.current = callback;
  const callbackRef = useRef(null);
  return callbackRef.current == null && (callbackRef.current = ((...args) => ref.current?.(...args))), callbackRef.current;
}
function useDiagramActorSnapshot(selector3, compare2 = shallowEqual$1) {
  const actorRef = useDiagramActorRef();
  return useSelector(actorRef, selector3, compare2);
}
function useDiagramContext(selector3, compare2 = shallowEqual$1, deps) {
  const actorRef = useDiagramActorRef(), selectorRef = useCallbackRef(selector3), select2 = useCallback((s2) => selectorRef(s2.context), deps ?? []);
  return useSelector(actorRef, select2, compare2);
}
function useOnDiagramEvent(event, callback, options) {
  const actorRef = useDiagramActorRef(), callbackRef = useCallbackRef(callback), wasCalled = useRef(!1), once = options?.once ?? !1;
  useEffect(() => {
    if (once && wasCalled.current)
      return;
    let subscription = actorRef.on(event, (payload) => {
      callbackRef(payload), wasCalled.current = !0, once && (subscription?.unsubscribe(), subscription = null);
    });
    return () => {
      subscription?.unsubscribe();
    };
  }, [actorRef, event, once]);
}
const select$1 = (s2) => s2.children.overlays;
function useOverlaysActorRef() {
  return useDiagramActorSnapshot(select$1, Object.is);
}
const select = (s2) => s2.children.search ?? null;
function useSearchActorRef() {
  return useDiagramActorSnapshot(select, Object.is);
}
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
const clamp = (min2, max2, v2) => v2 > max2 ? max2 : v2 < min2 ? min2 : v2;
let invariant = () => {
};
const MotionGlobalConfig = {}, isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);
function isObject(value) {
  return typeof value == "object" && value !== null;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => (result === void 0 && (result = callback()), result);
}
const noop$1 = /* @__NO_SIDE_EFFECTS__ */ (any) => any, combineFunctions = (a2, b2) => (v2) => b2(a2(v2)), pipe = (...transformers) => transformers.reduce(combineFunctions), progress = /* @__NO_SIDE_EFFECTS__ */ (from, to2, value) => {
  const toFromDifference = to2 - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c) {
    const numSubscriptions = this.subscriptions.length;
    if (numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a2, b2, c);
      else
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b2, c);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3, millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const wrap = (min2, max2, v2) => {
  const rangeSize = max2 - min2;
  return ((v2 - min2) % rangeSize + rangeSize) % rangeSize + min2;
}, calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i2 = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$1;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2, reverseEasing = (easing) => (p2) => 1 - easing(1 - p2), backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1))), circIn = (p2) => 1 - Math.sin(Math.acos(p2)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1), easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1), isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number";
function getEasingForSegment(easing, i2) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number", easingLookup = {
  linear: noop$1,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, isValidEasing = (easing) => typeof easing == "string", easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition))
    return easingLookup[definition];
  return definition;
}, stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set(), nextFrame = /* @__PURE__ */ new Set(), isProcessing = !1, flushNextFrame = !1;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function triggerCallback(callback) {
    toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame()), callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      const queue = immediate && isProcessing ? thisFrame : nextFrame;
      return keepAlive && toKeepAlive.add(callback), queue.has(callback) || queue.add(callback), callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback), toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (latestFrameData = frameData2, isProcessing) {
        flushNextFrame = !0;
        return;
      }
      isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], thisFrame.forEach(triggerCallback), thisFrame.clear(), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = !1, useDefaultElapsed = !0;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key2) => (acc[key2] = createRenderStep(flagRunNextFrame), acc), {}), { setup: setup2, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps, processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = !1, MotionGlobalConfig.useManualTiming || (state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1)), state.timestamp = timestamp, state.isProcessing = !0, setup2.process(state), read.process(state), resolveKeyframes.process(state), preUpdate.process(state), update.process(state), preRender.process(state), render.process(state), postRender.process(state), state.isProcessing = !1, runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
  }, wake2 = () => {
    runNextFrame = !0, useDefaultElapsed = !0, state.isProcessing || scheduleNextBatch(processBatch);
  };
  return { schedule: stepsOrder.reduce((acc, key2) => {
    const step = steps[key2];
    return acc[key2] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || wake2(), step.schedule(process2, keepAlive, immediate)), acc;
  }, {}), cancel: (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++)
      steps[stepsOrder[i2]].cancel(process2);
  }, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$1, !0);
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => (now === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
  set: (newTime) => {
    now = newTime, queueMicrotask(clearTime);
  }
}, checkStringStartsWith = (token) => (key2) => typeof key2 == "string" && key2.startsWith(token), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (value) => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, number = {
  test: (v2) => typeof v2 == "number",
  parse: parseFloat,
  transform: (v2) => v2
}, alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
}, scale$1 = {
  ...number,
  default: 1
}, sanitize = (v2) => Math.round(v2 * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v2) {
  return v2 == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (type, testProp) => (v2) => !!(typeof v2 == "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp)), splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 != "string")
    return v2;
  const [a2, b2, c, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, clampRgbUnit = (v2) => clamp(0, 255, v2), rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
}, rgba$1 = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
};
function parseHex(v2) {
  let r2 = "", g2 = "", b2 = "", a2 = "";
  return v2.length > 5 ? (r2 = v2.substring(1, 3), g2 = v2.substring(3, 5), b2 = v2.substring(5, 7), a2 = v2.substring(7, 9)) : (r2 = v2.substring(1, 2), g2 = v2.substring(2, 3), b2 = v2.substring(3, 4), a2 = v2.substring(4, 5), r2 += r2, g2 += g2, b2 += b2, a2 += a2), {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba$1.transform
}, createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v2) => typeof v2 == "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
}), degrees = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}, hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
}, color = {
  test: (v2) => rgba$1.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => rgba$1.test(v2) ? rgba$1.parse(v2) : hsla.test(v2) ? hsla.parse(v2) : hex.parse(v2),
  transform: (v2) => typeof v2 == "string" ? v2 : v2.hasOwnProperty("red") ? rgba$1.transform(v2) : hsla.transform(v2),
  getAnimatableNone: (v2) => {
    const parsed = color.parse(v2);
    return parsed.alpha = 0, color.transform(parsed);
  }
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v2) {
  return isNaN(v2) && typeof v2 == "string" && (v2.match(floatRegex)?.length || 0) + (v2.match(colorRegex)?.length || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString(), values2 = [], indexes = {
    color: [],
    number: [],
    var: []
  }, types = [];
  let i2 = 0;
  const split = originalValue.replace(complexRegex, (parsedValue) => (color.test(parsedValue) ? (indexes.color.push(i2), types.push(COLOR_TOKEN), values2.push(color.parse(parsedValue))) : parsedValue.startsWith(VAR_FUNCTION_TOKEN) ? (indexes.var.push(i2), types.push(VAR_TOKEN), values2.push(parsedValue)) : (indexes.number.push(i2), types.push(NUMBER_TOKEN), values2.push(parseFloat(parsedValue))), ++i2, SPLIT_TOKEN)).split(SPLIT_TOKEN);
  return { values: values2, split, indexes, types };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source), numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++)
      if (output += split[i2], v2[i2] !== void 0) {
        const type = types[i2];
        type === NUMBER_TOKEN ? output += sanitize(v2[i2]) : type === COLOR_TOKEN ? output += color.transform(v2[i2]) : output += v2[i2];
      }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 == "number" ? 0 : color.test(v2) ? color.getAnimatableNone(v2) : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  return createTransformer(v2)(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
function hueToRgb(p2, q, t2) {
  return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p2 + (q - p2) * 6 * t2 : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p2 + (q - p2) * (2 / 3 - t2) * 6 : p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red = 0, green = 0, blue = 0;
  if (!saturation)
    red = green = blue = lightness;
  else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p2 = 2 * lightness - q;
    red = hueToRgb(p2, q, hue + 1 / 3), green = hueToRgb(p2, q, hue), blue = hueToRgb(p2, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
const mixNumber$1 = (from, to2, progress2) => from + (to2 - from) * progress2, mixLinearColor = (from, to2, v2) => {
  const fromExpo = from * from, expo = v2 * (to2 * to2 - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, colorTypes = [hex, rgba$1, hsla], getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!type)
    return !1;
  let model = type.parse(color2);
  return type === hsla && (model = hslaToRgba(model)), model;
}
const mixColor = (from, to2) => {
  const fromRGBA = asRGBA(from), toRGBA = asRGBA(to2);
  if (!fromRGBA || !toRGBA)
    return mixImmediate(from, to2);
  const blended = { ...fromRGBA };
  return (v2) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2), blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2), rgba$1.transform(blended));
}, invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  return invisibleValues.has(origin) ? (p2) => p2 <= 0 ? origin : target : (p2) => p2 >= 1 ? target : origin;
}
function mixNumber(a2, b2) {
  return (p2) => mixNumber$1(a2, b2, p2);
}
function getMixer(a2) {
  return typeof a2 == "number" ? mixNumber : typeof a2 == "string" ? isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex : Array.isArray(a2) ? mixArray : typeof a2 == "object" ? color.test(a2) ? mixColor : mixObject : mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2], numValues = output.length, blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++)
      output[i2] = blendValue[i2](p2);
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 }, blendValue = {};
  for (const key2 in output)
    a2[key2] !== void 0 && b2[key2] !== void 0 && (blendValue[key2] = getMixer(a2[key2])(a2[key2], b2[key2]));
  return (v2) => {
    for (const key2 in blendValue)
      output[key2] = blendValue[key2](v2);
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [], pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2], originIndex = origin.indexes[type][pointers[type]], originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue, pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
  return originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length ? invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length ? mixVisibility(origin, target) : pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template) : mixImmediate(origin, target);
};
function mix$1(from, to2, p2) {
  return typeof from == "number" && typeof to2 == "number" && typeof p2 == "number" ? mixNumber$1(from, to2, p2) : getMixer(from)(from, to2);
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = !0) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
}, generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++)
    points += Math.round(easing(i2 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${points.substring(0, points.length - 2)})`;
}, maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  for (; !state.done && duration < maxGeneratorDuration; )
    duration += timeStep, state = generator.next(duration);
  return duration >= maxGeneratorDuration ? 1 / 0 : duration;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] }), duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => generator.next(duration * progress2).value / scale2,
    duration: /* @__PURE__ */ millisecondsToSeconds(duration)
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current2) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current2 - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope, derivative, dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio), duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    const exponentialDecay = undampedFreq2 * dampingRatio, delta = exponentialDecay * duration, a2 = exponentialDecay - velocity, b2 = calcAngularFreq(undampedFreq2, dampingRatio), c = Math.exp(-delta);
    return safeMin - a2 / b2 * c;
  }, derivative = (undampedFreq2) => {
    const delta = undampedFreq2 * dampingRatio * duration, d2 = delta * velocity + velocity, e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration, f2 = Math.exp(-delta), g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d2 - e2) * f2) / g2;
  }) : (envelope = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (undampedFreq2 - velocity) * duration + 1;
    return -safeMin + a2 * b2;
  }, derivative = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration), b2 = (velocity - undampedFreq2) * (duration * duration);
    return a2 * b2;
  });
  const initialGuess = 5 / duration, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration = /* @__PURE__ */ secondsToMilliseconds(duration), isNaN(undampedFreq))
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++)
    result = result - envelope(result) / derivative(result);
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: !1,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys))
    if (options.visualDuration) {
      const visualDuration = options.visualDuration, root2 = 2 * Math.PI / (visualDuration * 1.2), stiffness = root2 * root2, damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      }, springOptions.isResolvedFromDuration = !0;
    }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration != "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0], target = options.keyframes[options.keyframes.length - 1], state = { done: !1, value: origin }, { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  }), initialVelocity = velocity || 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - origin, undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default), restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2), freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration && duration || null,
    next: (t2) => {
      const current2 = resolveSpring(t2);
      if (isResolvedFromDuration)
        state.done = t2 >= duration;
      else {
        let currentVelocity = t2 === 0 ? initialVelocity : 0;
        dampingRatio < 1 && (currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current2));
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target - current2) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target : current2, state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration), easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  return options.ease = generatorOptions.ease, options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration), options.type = "keyframes", options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0], state = {
    done: !1,
    value: origin
  }, isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2, nearestBoundary = (v2) => min2 === void 0 ? max2 : max2 === void 0 || Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  let amplitude = power * velocity;
  const ideal = origin + amplitude, target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target !== ideal && (amplitude = target - origin);
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant), calcLatest = (t2) => target + calcDelta(t2), applyFriction = (t2) => {
    const delta = calcDelta(t2), latest2 = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta, state.value = state.done ? target : latest2;
  };
  let timeReachedBoundary, spring$1;
  const checkCatchBoundary = (t2) => {
    isOutOfBounds(state.value) && (timeReachedBoundary = t2, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t2), checkCatchBoundary(t2)), timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary ? spring$1.next(t2 - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t2), state);
    }
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [], mixerFactory = customMixer || MotionGlobalConfig.mix || mix$1, numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$1 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input2, output, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  const inputLength = input2.length;
  if (invariant(inputLength === output.length), inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input2[0] === input2[1];
  input2[0] > input2[inputLength - 1] && (input2 = [...input2].reverse(), output = [...output].reverse());
  const mixers = createMixers(output, ease2, mixer), numMixers = mixers.length, interpolator = (v2) => {
    if (isZeroDeltaRange && v2 < input2[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1)
      for (; i2 < input2.length - 2 && !(v2 < input2[i2 + 1]); i2++)
        ;
    const progressInRange = /* @__PURE__ */ progress(input2[i2], input2[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input2[0], input2[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  return fillOffset(offset2, arr.length - 1), offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}
function defaultEasing(values2, easing) {
  return values2.map(() => easing || easeInOut).splice(0, values2.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  ), mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => (state.value = mapTimeToKeyframe(t2), state.done = t2 >= duration, state)
  };
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1), index2 = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(transition) {
  typeof transition.type == "string" && (transition.type = transitionTypeMap[transition.type]);
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
class JSAnimation extends WithPromise {
  constructor(options) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: motionValue2 } = this.options;
      motionValue2 && motionValue2.updatedAt !== time.now() && this.tick(time.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = options, this.initAnimation(), this.play(), options.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type || keyframes;
    generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (this.mixKeyframes = pipe(percentToProgress, mix$1(keyframes$1[0], keyframes$1[1])), keyframes$1 = [0, 100]);
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    repeatType === "mirror" && (this.mirroredGenerator = generatorFactory({
      ...options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -velocity
    })), generator.calculatedDuration === null && (generator.calculatedDuration = calcGeneratorDuration(generator));
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration, this.resolvedDuration = calculatedDuration + repeatDelay, this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay, this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = animationTime;
  }
  tick(timestamp, sample = !1) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, timestamp) : this.speed < 0 && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime)), sample ? this.currentTime = timestamp : this.updateTime(timestamp);
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1), isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = totalDuration);
    let elapsed = this.currentTime, frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat + 1), currentIteration % 2 && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator)), elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: !1, value: keyframes2[0] } : frameGenerator.next(elapsed);
    mixKeyframes && (state.value = mixKeyframes(state.value));
    let { done } = state;
    !isInDelayPhase && calculatedDuration !== null && (done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0);
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    return isAnimationFinished && type !== inertia && (state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed)), onUpdate && onUpdate(state.value), isAnimationFinished && this.finish(), state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: delay2 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime), this.currentTime = newTime, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed, hasChanged && (this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    this.driver || (this.driver = driver((timestamp) => this.tick(timestamp))), this.options.onPlay?.();
    const now2 = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = now2) : this.holdTime !== null ? this.startTime = now2 - this.holdTime : this.startTime || (this.startTime = startTime ?? now2), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(time.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(sampleTime) {
    return this.startTime = 0, this.tick(sampleTime, !0);
  }
  attachTimeline(timeline) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), timeline.observe(this);
  }
}
function fillWildcards(keyframes2) {
  for (let i2 = 1; i2 < keyframes2.length; i2++)
    keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
}
const radToDeg = (rad) => rad * 180 / Math.PI, rotate = (v2) => {
  const angle = radToDeg(Math.atan2(v2[1], v2[0]));
  return rebaseAngle(angle);
}, matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v2) => radToDeg(Math.atan(v2[1])),
  skewY: (v2) => radToDeg(Math.atan(v2[2])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
}, rebaseAngle = (angle) => (angle = angle % 360, angle < 0 && (angle += 360), angle), rotateZ = rotate, scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]), scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]), matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
  rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
  rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v2) => radToDeg(Math.atan(v2[4])),
  skewY: (v2) => radToDeg(Math.atan(v2[1])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform2, name) {
  if (!transform2 || transform2 === "none")
    return defaultTransformValue(name);
  const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers, match;
  if (matrix3dMatch)
    parsers = matrix3dParsers, match = matrix3dMatch;
  else {
    const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers, match = matrix2dMatch;
  }
  if (!match)
    return defaultTransformValue(name);
  const valueParser = parsers[name], values2 = match[1].split(",").map(convertTransformToNumber);
  return typeof valueParser == "function" ? valueParser(values2) : values2[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform: transform2 = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform2, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder), isNumOrPxType = (v2) => v2 === number || v2 === px, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value !== void 0 && (removedTransforms.push([key2, value.get()]), value.set(key2.startsWith("scale") ? 1 : 0));
  }), removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
  y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = !1, anyNeedsMeasurement = !1, isForced = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element)), transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());
    }), resolversToMeasure.forEach((resolver) => resolver.measureInitialState()), elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      restore && restore.forEach(([key2, value]) => {
        element.getValue(key2)?.set(value);
      });
    }), resolversToMeasure.forEach((resolver) => resolver.measureEndState()), resolversToMeasure.forEach((resolver) => {
      resolver.suspendedScrollY !== void 0 && window.scrollTo(0, resolver.suspendedScrollY);
    });
  }
  anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((resolver) => resolver.complete(isForced)), toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes(), resolver.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  isForced = !0, readAllKeyframes(), measureAllKeyframes(), isForced = !1;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...unresolvedKeyframes], this.onComplete = onComplete, this.name = name, this.motionValue = motionValue2, this.element = element, this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2?.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0)
        unresolvedKeyframes[0] = currentValue;
      else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        valueAsRead != null && (unresolvedKeyframes[0] = valueAsRead);
      }
      unresolvedKeyframes[0] === void 0 && (unresolvedKeyframes[0] = finalKeyframe), motionValue2 && currentValue === void 0 && motionValue2.set(unresolvedKeyframes[0]);
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete), toResolve.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (toResolve.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const isCSSVar = (name) => name.startsWith("--");
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0), supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), cubicBezierAsString = ([a2, b2, c, d2]) => `cubic-bezier(${a2}, ${b2}, ${c}, ${d2})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (easing)
    return typeof easing == "function" ? supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out" : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  times && (keyframeOptions.offset = times);
  const easing = mapEasingToNativeEasing(ease2, duration);
  Array.isArray(easing) && (keyframeOptions.easing = easing);
  const options = {
    delay: delay2,
    duration,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  return pseudoElement && (options.pseudoElement = pseudoElement), element.animate(keyframeOptions, options);
}
function isGenerator(type) {
  return typeof type == "function" && "applyToOptions" in type;
}
function applyGeneratorOptions({ type, ...options }) {
  return isGenerator(type) && supportsLinearEasing() ? type.applyToOptions(options) : (options.duration ?? (options.duration = 300), options.ease ?? (options.ease = "easeOut"), options);
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !options)
      return;
    const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = !1, finalKeyframe, onComplete } = options;
    this.isPseudoElement = !!pseudoElement, this.allowFlatten = allowFlatten, this.options = options, invariant(typeof options.type != "string");
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement), transition.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !pseudoElement) {
        const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
        this.updateMotionValue ? this.updateMotionValue(keyframe) : setStyle(element, name, keyframe), this.animation.cancel();
      }
      onComplete?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state } = this;
    state === "idle" || state === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration));
  }
  get iterationDuration() {
    const { delay: delay2 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    newSpeed < 0 && (this.finishedTime = null), this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, timeline && supportsScrollTimeline() ? (this.animation.timeline = timeline, noop$1) : observe(this);
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key2) {
  return key2 in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  typeof transition.ease == "string" && isUnsupportedEase(transition.ease) && (transition.ease = unsupportedEasingFunctions[transition.ease]);
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options), replaceTransitionType(options), super(options), options.startTime && (this.startTime = options.startTime), this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: !1
    }), sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
    motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta), sampleAnimation.stop();
  }
}
const isAnimatable = (value, name) => name === "zIndex" ? !1 : !!(typeof value == "number" || Array.isArray(value) || typeof value == "string" && // It's animatable if we have a string
(complex.test(value) || value === "0") && // And it contains numbers and/or colors
!value.startsWith("url("));
function hasKeyframesChanged(keyframes2) {
  const current2 = keyframes2[0];
  if (keyframes2.length === 1)
    return !0;
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    if (keyframes2[i2] !== current2)
      return !0;
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return !1;
  if (name === "display" || name === "visibility")
    return !0;
  const targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(targetKeyframe, name);
  return !isOriginAnimatable || !isTargetAnimatable ? !1 : hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
function makeAnimationInstant(options) {
  options.duration = 0, options.type = "keyframes";
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
  if (!(motionValue2?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay = !0, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options
    }, KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    this.keyframeResolver = void 0;
    const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now(), canAnimate(keyframes2, name, type, velocity) || ((MotionGlobalConfig.instantAnimations || !delay2) && onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe)), keyframes2[0] = keyframes2[keyframes2.length - 1], makeAnimationInstant(options), options.repeat = 0);
    const resolvedOptions = {
      startTime: sync ? this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    }, animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
      ...resolvedOptions,
      element: resolvedOptions.motionValue.owner.current
    }) : new JSAnimation(resolvedOptions);
    animation.finished.then(() => this.notifyFinished()).catch(noop$1), this.pendingTimeline && (this.stopTimeline = animation.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = animation;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), flushKeyframeResolvers()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(timeline) : this.pendingTimeline = timeline, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
class GroupAnimation {
  constructor(animations2) {
    this.stop = () => this.runAll("stop"), this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => animation.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++)
      this.animations[i2][propName] = newValue;
  }
  attachTimeline(timeline) {
    const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));
    return () => {
      subscriptions.forEach((cancel2, i2) => {
        cancel2 && cancel2(), this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    return getMax(this.animations, "duration");
  }
  get iterationDuration() {
    return getMax(this.animations, "iterationDuration");
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function getMax(animations2, propName) {
  let max2 = 0;
  for (let i2 = 0; i2 < animations2.length; i2++) {
    const value = animations2[i2][propName];
    value !== null && value > max2 && (max2 = value);
  }
  return max2;
}
class GroupAnimationWithThen extends GroupAnimation {
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
}
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current2) {
  const match = splitCSSVariableRegex.exec(current2);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current2, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current2);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function getValueTransition$1(transition, key2) {
  return transition?.[key2] ?? transition?.default ?? transition;
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]), auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
}, testValueType = (v2) => (type) => type.test(v2), dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto], findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
function isNone(value) {
  return typeof value == "number" ? value === 0 : value !== null ? value === "none" || value === "0" || isZeroValueString(value) : !0;
}
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  return number2 !== value && (defaultValue *= 100), name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
}, int = {
  ...number,
  transform: Math.round
}, transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale: scale$1,
  scaleX: scale$1,
  scaleY: scale$1,
  scaleZ: scale$1,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
}, numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
}, getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  return defaultValueType !== filter && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0, animatableTemplate;
  for (; i2 < unresolvedKeyframes.length && !animatableTemplate; ) {
    const keyframe = unresolvedKeyframes[i2];
    typeof keyframe == "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (animatableTemplate = unresolvedKeyframes[i2]), i2++;
  }
  if (animatableTemplate && name)
    for (const noneIndex of noneKeyframeIndexes)
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe == "string" && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {
        const resolved = getVariableValue(keyframe, element.current);
        resolved !== void 0 && (unresolvedKeyframes[i2] = resolved), i2 === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);
      }
    }
    if (this.resolveNoneKeyframes(), !positionalKeys.has(name) || unresolvedKeyframes.length !== 2)
      return;
    const [origin, target] = unresolvedKeyframes, originType = findDimensionValueType(origin), targetType = findDimensionValueType(target);
    if (originType !== targetType)
      if (isNumOrPxType(originType) && isNumOrPxType(targetType))
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          typeof value == "string" && (unresolvedKeyframes[i2] = parseFloat(value));
        }
      else positionalValues[name] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this, noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) && noneKeyframeIndexes.push(i2);
    noneKeyframeIndexes.length && makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    name === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    measureKeyframe !== void 0 && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);
  }
  measureEndState() {
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, !1);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1, finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), finalKeyframe !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = finalKeyframe), this.removedTransforms?.length && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
      element.getValue(unsetTransformName).set(unsetTransformValue);
    }), this.resolveNoneKeyframes();
  }
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget)
    return [elementOrSelector];
  if (typeof elementOrSelector == "string") {
    let root2 = document;
    const elements = selectorCache?.[elementOrSelector] ?? root2.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
function createSelectorEffect(subjectEffect) {
  return (subject, values2) => {
    const elements = resolveElements(subject), subscriptions = [];
    for (const element of elements) {
      const remove2 = subjectEffect(element, values2);
      subscriptions.push(remove2);
    }
    return () => {
      for (const remove2 of subscriptions)
        remove2();
    };
  };
}
const getValueAsType = (value, type) => type && typeof value == "number" ? type.transform(value) : value;
class MotionValueState {
  constructor() {
    this.latest = {}, this.values = /* @__PURE__ */ new Map();
  }
  set(name, value, render, computed, useDefaultValueType = !0) {
    const existingValue = this.values.get(name);
    existingValue && existingValue.onRemove();
    const onChange = () => {
      const v2 = value.get();
      useDefaultValueType ? this.latest[name] = getValueAsType(v2, numberValueTypes[name]) : this.latest[name] = v2, render && frame.render(render);
    };
    onChange();
    const cancelOnChange = value.on("change", onChange);
    computed && value.addDependent(computed);
    const remove2 = () => {
      cancelOnChange(), render && cancelFrame(render), this.values.delete(name), computed && value.removeDependent(computed);
    };
    return this.values.set(name, { value, onRemove: remove2 }), remove2;
  }
  get(name) {
    return this.values.get(name)?.value;
  }
  destroy() {
    for (const value of this.values.values())
      value.onRemove();
  }
}
function createEffect(addValue) {
  const stateCache = /* @__PURE__ */ new WeakMap(), subscriptions = [];
  return (subject, values2) => {
    const state = stateCache.get(subject) ?? new MotionValueState();
    stateCache.set(subject, state);
    for (const key2 in values2) {
      const value = values2[key2], remove2 = addValue(subject, state, key2, value);
      subscriptions.push(remove2);
    }
    return () => {
      for (const cancel2 of subscriptions)
        cancel2();
    };
  };
}
function isHTMLElement(element) {
  return isObject(element) && "offsetHeight" in element;
}
const MAX_VELOCITY_DELTA = 30, isFloat = (value) => !isNaN(parseFloat(value)), collectMotionValues = {
  current: void 0
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init2, options = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (v2) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(v2), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const dependent of this.dependents)
          dependent.dirty();
    }, this.hasAnimated = !1, this.setCurrent(init2), this.owner = options.owner;
  }
  setCurrent(current2) {
    this.current = current2, this.updatedAt = time.now(), this.canTrackVelocity === null && current2 !== void 0 && (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    const unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), frame.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2) {
    this.passiveEffect ? this.passiveEffect(v2, this.updateAndNotify) : this.updateAndNotify(v2);
  }
  setWithVelocity(prev, current2, delta) {
    this.set(current2), this.prev = void 0, this.prevFrameValue = prev, this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = !0) {
    this.updateAndNotify(v2), this.prev = v2, this.prevUpdatedAt = this.prevFrameValue = void 0, endAnimation && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(dependent) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    this.dependents && this.dependents.delete(dependent);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return collectMotionValues.current && collectMotionValues.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    return this.stop(), new Promise((resolve) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
const translateAlias$1 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform$1(state) {
  let transform2 = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < transformPropOrder.length; i2++) {
    const key2 = transformPropOrder[i2], value = state.latest[key2];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key2.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault) {
      transformIsDefault = !1;
      const transformName = translateAlias$1[key2] || key2, valueToRender = state.latest[key2];
      transform2 += `${transformName}(${valueToRender}) `;
    }
  }
  return transformIsDefault ? "none" : transform2.trim();
}
const originProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]), addStyleValue = (element, state, key2, value) => {
  let render, computed;
  return transformProps.has(key2) ? (state.get("transform") || (!isHTMLElement(element) && !state.get("transformBox") && addStyleValue(element, state, "transformBox", new MotionValue("fill-box")), state.set("transform", new MotionValue("none"), () => {
    element.style.transform = buildTransform$1(state);
  })), computed = state.get("transform")) : originProps.has(key2) ? (state.get("transformOrigin") || state.set("transformOrigin", new MotionValue(""), () => {
    const originX = state.latest.originX ?? "50%", originY = state.latest.originY ?? "50%", originZ = state.latest.originZ ?? 0;
    element.style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }), computed = state.get("transformOrigin")) : isCSSVar(key2) ? render = () => {
    element.style.setProperty(key2, state.latest[key2]);
  } : render = () => {
    element.style[key2] = state.latest[key2];
  }, state.set(key2, value, render, computed);
}, styleEffect = /* @__PURE__ */ createSelectorEffect(
  /* @__PURE__ */ createEffect(addStyleValue)
), { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, !1), isDragging = {
  x: !1,
  y: !1
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  return axis === "x" || axis === "y" ? isDragging[axis] ? null : (isDragging[axis] = !0, () => {
    isDragging[axis] = !1;
  }) : isDragging.x || isDragging.y ? null : (isDragging.x = isDragging.y = !0, () => {
    isDragging.x = isDragging.y = !1;
  });
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector), gestureAbortController = new AbortController(), eventOptions = {
    passive: !0,
    ...options,
    signal: gestureAbortController.signal
  };
  return [elements, eventOptions, () => gestureAbortController.abort()];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel2] = setupGesture(elementOrSelector, options), onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent, onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd != "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      isValidHover(leaveEvent) && (onHoverEnd(leaveEvent), target.removeEventListener("pointerleave", onPointerLeave));
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  return elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  }), cancel2;
}
const isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1, isPrimaryPointer = (event) => event.pointerType === "mouse" ? typeof event.button != "number" || event.button <= 0 : event.isPrimary !== !1, focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    event.key === "Enter" && callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: !0, bubbles: !0 }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    }), handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions), element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions), element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options), startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent), onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp), window.removeEventListener("pointercancel", onPointerCancel), isPressing.has(target) && isPressing.delete(target), isValidPressEvent(endEvent) && typeof onPressEnd == "function" && onPressEnd(endEvent, { success });
    }, onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    }, onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, !1);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions), window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  return targets.forEach((target) => {
    (options.useGlobalTarget ? window : target).addEventListener("pointerdown", startPress, eventOptions), isHTMLElement(target) && (target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions)), !isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex") && (target.tabIndex = 0));
  }), cancelEvents;
}
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
function getOriginIndex(from, total) {
  if (from === "first")
    return 0;
  {
    const lastIndex = total - 1;
    return from === "last" ? lastIndex : lastIndex / 2;
  }
}
function stagger(duration = 0.1, { startDelay = 0, from = 0, ease: ease2 } = {}) {
  return (i2, total) => {
    const fromIndex = typeof from == "number" ? from : getOriginIndex(from, total), distance2 = Math.abs(fromIndex - i2);
    let delay2 = duration * distance2;
    if (ease2) {
      const maxDelay = total * duration;
      delay2 = easingDefinitionToFunction(ease2)(delay2 / maxDelay) * maxDelay;
    }
    return startDelay + delay2;
  };
}
function transform(...args) {
  const useImmediate = !Array.isArray(args[0]), argOffset = useImmediate ? 0 : -1, inputValue = args[0 + argOffset], inputRange = args[1 + argOffset], outputRange = args[2 + argOffset], options = args[3 + argOffset], interpolator = interpolate(inputRange, outputRange, options);
  return useImmediate ? interpolator(inputValue) : interpolator;
}
function subscribeValue(inputValues, outputValue, getLatest) {
  const update = () => outputValue.set(getLatest()), scheduleUpdate = () => frame.preRender(update, !1, !0), subscriptions = inputValues.map((v2) => v2.on("change", scheduleUpdate));
  outputValue.on("destroy", () => {
    subscriptions.forEach((unsubscribe) => unsubscribe()), cancelFrame(update);
  });
}
function transformValue(transform2) {
  const collectedValues = [];
  collectMotionValues.current = collectedValues;
  const initialValue = transform2();
  collectMotionValues.current = void 0;
  const value = motionValue(initialValue);
  return subscribeValue(collectedValues, value, transform2), value;
}
function mapValue(inputValue, inputRange, outputRange, options) {
  const map = transform(inputRange, outputRange, options);
  return transformValue(() => map(inputValue.get()));
}
const isMotionValue = (value) => !!(value && value.getVelocity), valueTypes = [...dimensionValueTypes, color, complex], findValueType = (v2) => valueTypes.find(testValueType(v2));
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 == "object" && !Array.isArray(keyframes2);
}
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  return typeof subject == "string" && isDOMKeyframes(keyframes2) ? resolveElements(subject, scope, selectorCache) : subject instanceof NodeList ? Array.from(subject) : Array.isArray(subject) ? subject : [subject];
}
function calculateRepeatDuration(duration, repeat, _repeatDelay) {
  return duration * (repeat + 1);
}
function calcNextTime(current2, next, prev, labels) {
  return typeof next == "number" ? next : next.startsWith("-") || next.startsWith("+") ? Math.max(0, current2 + parseFloat(next)) : next === "<" ? prev : next.startsWith("<") ? Math.max(0, prev + parseFloat(next.slice(1))) : labels.get(next) ?? current2;
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const keyframe = sequence[i2];
    keyframe.at > startTime && keyframe.at < endTime && (removeItem(sequence, keyframe), i2--);
  }
}
function addKeyframes(sequence, keyframes2, easing, offset2, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    sequence.push({
      value: keyframes2[i2],
      at: mixNumber$1(startTime, endTime, offset2[i2]),
      easing: getEasingForSegment(easing, i2)
    });
}
function normalizeTimes(times, repeat) {
  for (let i2 = 0; i2 < times.length; i2++)
    times[i2] = times[i2] / (repeat + 1);
}
function compareByTime(a2, b2) {
  return a2.at === b2.at ? a2.value === null ? 1 : b2.value === null ? -1 : 0 : a2.at - b2.at;
}
const defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition: defaultTransition2 = {}, ...sequenceTransition } = {}, scope, generators) {
  const defaultDuration = defaultTransition2.duration || 0.3, animationDefinitions = /* @__PURE__ */ new Map(), sequences = /* @__PURE__ */ new Map(), elementCache = {}, timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0, currentTime = 0, totalDuration = 0;
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const segment = sequence[i2];
    if (typeof segment == "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    transition.at !== void 0 && (currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels));
    let maxDuration = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes), { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition2.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay2 == "function" ? delay2(elementIndex, numSubjects) : delay2, numKeyframes = valueKeyframesAsList.length, createGenerator = isGenerator(type) ? type : generators?.[type || "keyframes"];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        duration !== void 0 && (springTransition.duration = /* @__PURE__ */ secondsToMilliseconds(duration));
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease, duration = springEasing.duration;
      }
      duration ?? (duration = defaultDuration);
      const startTime = currentTime + calculatedDelay;
      times.length === 1 && times[0] === 0 && (times[1] = 1);
      const remainder = times.length - valueKeyframesAsList.length;
      if (remainder > 0 && fillOffset(times, remainder), valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null), repeat) {
        duration = calculateRepeatDuration(duration, repeat);
        const originalKeyframes = [...valueKeyframesAsList], originalTimes = [...times];
        ease2 = Array.isArray(ease2) ? [...ease2] : [ease2];
        const originalEase = [...ease2];
        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
          valueKeyframesAsList.push(...originalKeyframes);
          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++)
            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1)), ease2.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
        }
        normalizeTimes(times, repeat);
      }
      const targetTime = startTime + duration;
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime), maxDuration = Math.max(calculatedDelay + duration, maxDuration), totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache), numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2, transition = transition;
        const thisSubject = subjects[subjectIndex], subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key2 in keyframes2)
          resolveValueSequence(keyframes2[key2], getValueTransition(transition, key2), getValueSequence(key2, subjectSequence), subjectIndex, numSubjects);
      }
    }
    prevTime = currentTime, currentTime += maxDuration;
  }
  return sequences.forEach((valueSequences, element) => {
    for (const key2 in valueSequences) {
      const valueSequence = valueSequences[key2];
      valueSequence.sort(compareByTime);
      const keyframes2 = [], valueOffset = [], valueEasing = [];
      for (let i2 = 0; i2 < valueSequence.length; i2++) {
        const { at, value, easing } = valueSequence[i2];
        keyframes2.push(value), valueOffset.push(/* @__PURE__ */ progress(0, totalDuration, at)), valueEasing.push(easing || "easeOut");
      }
      valueOffset[0] !== 0 && (valueOffset.unshift(0), keyframes2.unshift(keyframes2[0]), valueEasing.unshift(defaultSegmentEasing)), valueOffset[valueOffset.length - 1] !== 1 && (valueOffset.push(1), keyframes2.push(null)), animationDefinitions.has(element) || animationDefinitions.set(element, {
        keyframes: {},
        transition: {}
      });
      const definition = animationDefinitions.get(element);
      definition.keyframes[key2] = keyframes2, definition.transition[key2] = {
        ...defaultTransition2,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  }), animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  return !sequences.has(subject) && sequences.set(subject, {}), sequences.get(subject);
}
function getValueSequence(name, sequences) {
  return sequences[name] || (sequences[name] = []), sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition(transition, key2) {
  return transition && transition[key2] ? {
    ...transition,
    ...transition[key2]
  } : { ...transition };
}
const isNumber = (keyframe) => typeof keyframe == "number", isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber), visualElementStore = /* @__PURE__ */ new WeakMap(), isKeyframesTarget = (v2) => Array.isArray(v2);
function getValueState(visualElement) {
  const state = [{}, {}];
  return visualElement?.values.forEach((value, key2) => {
    state[0][key2] = value.get(), state[1][key2] = value.getVelocity();
  }), state;
}
function resolveVariantFromProps(props, definition, custom5, visualElement) {
  if (typeof definition == "function") {
    const [current2, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current2, velocity);
  }
  if (typeof definition == "string" && (definition = props.variants && props.variants[definition]), typeof definition == "function") {
    const [current2, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current2, velocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom5) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom5 !== void 0 ? custom5 : props.custom, visualElement);
}
function setMotionValue(visualElement, key2, value) {
  visualElement.hasValue(key2) ? visualElement.getValue(key2).set(value) : visualElement.addValue(key2, motionValue(value));
}
function resolveFinalValueInKeyframes(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function isWillChangeMotionValue(value) {
  return !!(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key2) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange))
    return willChange.add(key2);
  if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange), newWillChange.add(key2);
  }
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull), index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index2];
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease;
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition$1(transition, name) || {}, delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2), valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  isTransitionDefined(valueTransition) || Object.assign(options, getDefaultTransition(name, options)), options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration)), options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay)), options.from !== void 0 && (options.keyframes[0] = options.from);
  let shouldSkip = !1;
  if ((options.type === !1 || options.duration === 0 && !options.repeatDelay) && (makeAnimationInstant(options), options.delay === 0 && (shouldSkip = !0)), (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) && (shouldSkip = !0, makeAnimationInstant(options), options.delay = 0), options.allowFlatten = !valueTransition.type && !valueTransition.ease, shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe), options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== !0;
  return needsAnimating[key2] = !1, shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  transitionOverride && (transition = transitionOverride);
  const animations2 = [], animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target) {
    const value = visualElement.getValue(key2, visualElement.latestValues[key2] ?? null), valueTarget = target[key2];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2))
      continue;
    const valueTransition = {
      delay: delay2,
      ...getValueTransition$1(transition || {}, key2)
    }, currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity)
      continue;
    let isHandoff = !1;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key2, frame);
        startTime !== null && (valueTransition.startTime = startTime, isHandoff = !0);
      }
    }
    addValueToWillChange(visualElement, key2), value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key2) ? { type: !1 } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    animation && animations2.push(animation);
  }
  return transitionEnd && Promise.all(animations2).then(() => {
    frame.update(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }), animations2;
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top }), bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY || values2.skewX || values2.skewY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point2 = scalePoint(point2, boxScale, originPoint)), scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2, delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2], delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    visualElement && visualElement.props.style && visualElement.props.style.display === "contents" || (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(box, {
      x: -node2.scroll.offset.x,
      y: -node2.scroll.offset.y
    }), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node2.latestValues) && transformBox(box, node2.latestValues));
  }
  treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN && (treeScale.x = 1), treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN && (treeScale.y = 1);
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX), transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const key2 in featureProps)
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name) => !!props[name])
  };
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
}), isBrowser = typeof window < "u", prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser)
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 == "object" && typeof v2.start == "function";
}
function isVariantLabel(v2) {
  return typeof v2 == "string" || Array.isArray(v2);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return !!(isControllingVariants(props) || props.variants);
}
function updateMotionValuesFromProps(element, next, prev) {
  for (const key2 in next) {
    const nextValue = next[key2], prevValue = prev[key2];
    if (isMotionValue(nextValue))
      element.addValue(key2, nextValue);
    else if (isMotionValue(prevValue))
      element.addValue(key2, motionValue(nextValue, { owner: element }));
    else if (prevValue !== nextValue)
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        existingValue.liveStyle === !0 ? existingValue.jump(nextValue) : existingValue.hasAnimated || existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (const key2 in prev)
    next[key2] === void 0 && element.removeValue(key2);
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const now2 = time.now();
      this.renderScheduledAt < now2 && (this.renderScheduledAt = now2, frame.render(this.render, !1, !0));
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options, this.blockInitialAnimation = !!blockInitialAnimation, this.isControllingVariants = isControllingVariants(props), this.isVariantNode = isVariantNode(props), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      latestValues[key2] !== void 0 && isMotionValue(value) && value.set(latestValues[key2]);
    }
  }
  mount(instance) {
    this.current = instance, visualElementStore.set(instance, this), this.projection && !this.projection.instance && this.projection.mount(instance), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value, key2) => this.bindToMotionValue(key2, value)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((remove2) => remove2()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const key2 in this.events)
      this.events[key2].clear();
    for (const key2 in this.features) {
      const feature = this.features[key2];
      feature && (feature.unmount(), feature.isMounted = !1);
    }
    this.current = null;
  }
  addChild(child) {
    this.children.add(child), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(child);
  }
  removeChild(child) {
    this.children.delete(child), this.enteringChildren && this.enteringChildren.delete(child);
  }
  bindToMotionValue(key2, value) {
    this.valueSubscriptions.has(key2) && this.valueSubscriptions.get(key2)();
    const valueIsTransform = transformProps.has(key2);
    valueIsTransform && this.onBindTransform && this.onBindTransform();
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue, this.props.onUpdate && frame.preRender(this.notifyUpdate), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let removeSyncCheck;
    window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key2, value)), this.valueSubscriptions.set(key2, () => {
      removeOnChange(), removeSyncCheck && removeSyncCheck(), value.owner && value.stop();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key2 = "animation";
    for (key2 in featureDefinitions) {
      const featureDefinition = featureDefinitions[key2];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key2] && FeatureConstructor && isEnabled(this.props) && (this.features[key2] = new FeatureConstructor(this)), this.features[key2]) {
        const feature = this.features[key2];
        feature.isMounted ? feature.update() : (feature.mount(), feature.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key2 = propEventHandlers[i2];
      this.propEventSubscriptions[key2] && (this.propEventSubscriptions[key2](), delete this.propEventSubscriptions[key2]);
      const listenerName = "on" + key2, listener = props[listenerName];
      listener && (this.propEventSubscriptions[key2] = this.on(key2, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    const existingValue = this.values.get(key2);
    value !== existingValue && (existingValue && this.removeValue(key2), this.bindToMotionValue(key2, value), this.values.set(key2, value), this.latestValues[key2] = value.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key2)), delete this.latestValues[key2], this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2])
      return this.props.values[key2];
    let value = this.values.get(key2);
    return value === void 0 && defaultValue !== void 0 && (value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this }), this.addValue(key2, value)), value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2, target) {
    let value = this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.getBaseTargetFromProps(this.props, key2) ?? this.readValueFromInstance(this.current, key2, this.options);
    return value != null && (typeof value == "string" && (isNumericalString(value) || isZeroValueString(value)) ? value = parseFloat(value) : !findValueType(value) && complex.test(target) && (value = getAnimatableNone(key2, target)), this.setBaseTarget(key2, isMotionValue(value) ? value.get() : value)), isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial == "string" || typeof initial == "object") {
      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
      variant && (valueFromInitial = variant[key2]);
    }
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    const target = this.getBaseTargetFromProps(this.props, key2);
    return target !== void 0 && !isMotionValue(target) ? target : this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
  scheduleRenderMicrotask() {
    microtask.render(this.render);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style: style2 }) {
    delete vars[key2], delete style2[key2];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: children2 } = this.props;
    isMotionValue(children2) && (this.childSubscription = children2.on("change", (latest2) => {
      this.current && (this.current.textContent = `${latest2}`);
    }));
  }
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key2 = transformPropOrder[i2], value = latestValues[key2];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key2.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      if (!valueIsDefault) {
        transformIsDefault = !1;
        const transformName = translateAlias[key2] || key2;
        transformString += `${transformName}(${valueAsType}) `;
      }
      transformTemplate && (transform2[key2] = valueAsType);
    }
  }
  return transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString) : transformIsDefault && (transformString = "none"), transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style: style2, vars, transformOrigin } = state;
  let hasTransform2 = !1, hasTransformOrigin = !1;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (transformProps.has(key2)) {
      hasTransform2 = !0;
      continue;
    } else if (isCSSVariableName(key2)) {
      vars[key2] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      key2.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key2] = valueAsType) : style2[key2] = valueAsType;
    }
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style2.transform = buildTransform(latestValues, state.transform, transformTemplate) : style2.transform && (style2.transform = "none")), hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function renderHTML(element, { style: style2, vars }, styleProp, projection) {
  const elementStyle = element.style;
  let key2;
  for (key2 in style2)
    elementStyle[key2] = style2[key2];
  projection?.applyProjectionStyles(elementStyle, styleProp);
  for (key2 in vars)
    elementStyle.setProperty(key2, vars[key2]);
}
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest2, node2) => {
    if (!node2.target)
      return latest2;
    if (typeof latest2 == "string")
      if (px.test(latest2))
        latest2 = parseFloat(latest2);
      else
        return latest2;
    const x2 = pixelsToPercent(latest2, node2.target.x), y2 = pixelsToPercent(latest2, node2.target.y);
    return `${x2}% ${y2}%`;
  }
}, correctBoxShadow = {
  correct: (latest2, { treeScale, projectionDelta }) => {
    const original = latest2, shadow = complex.parse(latest2);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest2), offset2 = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale, shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    return typeof shadow[2 + offset2] == "number" && (shadow[2 + offset2] /= averageScale), typeof shadow[3 + offset2] == "number" && (shadow[3 + offset2] /= averageScale), template(shadow);
  }
}, scaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  const { style: style2 } = props, newValues = {};
  for (const key2 in style2)
    (isMotionValue(style2[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props) || visualElement?.getValue(key2)?.liveStyle !== void 0) && (newValues[key2] = style2[key2]);
  return newValues;
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2))
      return this.projection?.isProjecting ? defaultTransformValue(key2) : readTransformValue(instance, key2);
    {
      const computedStyle = getComputedStyle$1(instance), value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value == "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
function isObjectKey(key2, object2) {
  return key2 in object2;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(instance, key2) {
    if (isObjectKey(key2, instance)) {
      const value = instance[key2];
      if (typeof value == "string" || typeof value == "number")
        return value;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(key2, renderState) {
    delete renderState.output[key2];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length), pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest2
}, isSVGTag2, transformTemplate, styleProp) {
  if (buildHTMLStyles(state, latest2, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  const { attrs, style: style2 } = state;
  attrs.transform && (style2.transform = attrs.transform, delete attrs.transform), (style2.transform || attrs.transformOrigin) && (style2.transformOrigin = attrs.transformOrigin ?? "50% 50%", delete attrs.transformOrigin), style2.transform && (style2.transformBox = styleProp?.transformBox ?? "fill-box", delete attrs.transformBox), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), attrScale !== void 0 && (attrs.scale = attrScale), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg";
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), renderState.attrs[key2]);
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key2 in props)
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  return newValues;
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType && defaultType.default || 0;
    }
    return key2 = camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), instance.getAttribute(key2);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName), super.mount(instance);
  }
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, node2 = isSVGElement(element) && !isSVGSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node2.mount(element), visualElementStore.set(element, node2);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, node2 = new ObjectVisualElement(options);
  node2.mount(subject), visualElementStore.set(subject, node2);
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options)), motionValue$1.animation;
}
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject == "number" || typeof subject == "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations2 = [];
  if (isSingleValue(subject, keyframes2))
    animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) && keyframes2.default || keyframes2, options && (options.default || options)));
  else {
    const subjects = resolveSubjects(subject, keyframes2, scope), numSubjects = subjects.length;
    for (let i2 = 0; i2 < numSubjects; i2++) {
      const thisSubject = subjects[i2], createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      visualElementStore.has(thisSubject) || createVisualElement(thisSubject);
      const visualElement = visualElementStore.get(thisSubject), transition = { ...options };
      "delay" in transition && typeof transition.delay == "function" && (transition.delay = transition.delay(i2, numSubjects)), animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations2;
}
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  return createAnimationsFromSequence(sequence, options, scope, { spring }).forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations2.push(...animateSubject(subject, keyframes2, transition));
  }), animations2;
}
function isSequence(value) {
  return Array.isArray(value) && value.some(Array.isArray);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations2 = [], animationOnComplete;
    if (isSequence(subjectOrSequence))
      animations2 = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);
    else {
      const { onComplete, ...rest } = options || {};
      typeof onComplete == "function" && (animationOnComplete = onComplete), animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, rest, scope);
    }
    const animation = new GroupAnimationWithThen(animations2);
    return animationOnComplete && animation.finished.then(animationOnComplete), animation;
  }
  return scopedAnimate;
}
const animate = createScopedAnimate();
function delay(callback, timeout2) {
  const start2 = time.now(), checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    elapsed >= timeout2 && (cancelFrame(checkElapsed), callback(elapsed - timeout2));
  };
  return frame.setup(checkElapsed, !0), () => cancelFrame(checkElapsed);
}
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x), yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
const LayoutGroupContext = createContext({});
function useConstant(init2) {
  const ref = useRef(null);
  return ref.current === null && (ref.current = init2()), ref.current;
}
const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect, PresenceContext = /* @__PURE__ */ createContext(null), MotionConfigContext = createContext({
  transformPagePoint: (p2) => p2,
  isStatic: !1,
  reducedMotion: "never"
});
function setRef(ref, value) {
  if (typeof ref == "function")
    return ref(value);
  ref != null && (ref.current = value);
}
function composeRefs(...refs) {
  return (node2) => {
    let hasCleanup = !1;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node2);
      return !hasCleanup && typeof cleanup == "function" && (hasCleanup = !0), cleanup;
    });
    if (hasCleanup)
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          typeof cleanup == "function" ? cleanup() : setRef(refs[i2], null);
        }
      };
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
class PopChildMeasure extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent = element.offsetParent, parentWidth = isHTMLElement(parent) && parent.offsetWidth || 0, size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0, size2.width = element.offsetWidth || 0, size2.top = element.offsetTop, size2.left = element.offsetLeft, size2.right = parentWidth - size2.width - size2.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children: children2, isPresent, anchorX, root: root2 }) {
  const id2 = useId$3(), ref = useRef(null), size2 = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  }), { nonce } = useContext(MotionConfigContext), composedRef = useComposedRefs(ref, children2?.ref);
  return useInsertionEffect$1(() => {
    const { width, height, top, left, right } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    nonce && (style2.nonce = nonce);
    const parent = root2 ?? document.head;
    return parent.appendChild(style2), style2.sheet && style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `), () => {
      parent.contains(style2) && parent.removeChild(style2);
    };
  }, [isPresent]), jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: React.cloneElement(children2, { ref: composedRef }) });
}
const PresenceChild = ({ children: children2, initial, isPresent, onExitComplete, custom: custom5, presenceAffectsLayout, mode, anchorX, root: root2 }) => {
  const presenceChildren = useConstant(newChildrenMap), id2 = useId$3();
  let isReusedContext = !0, context2 = useMemo(() => (isReusedContext = !1, {
    id: id2,
    initial,
    isPresent,
    custom: custom5,
    onExitComplete: (childId) => {
      presenceChildren.set(childId, !0);
      for (const isComplete of presenceChildren.values())
        if (!isComplete)
          return;
      onExitComplete && onExitComplete();
    },
    register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
  }), [isPresent, presenceChildren, onExitComplete]);
  return presenceAffectsLayout && isReusedContext && (context2 = { ...context2 }), useMemo(() => {
    presenceChildren.forEach((_, key2) => presenceChildren.set(key2, !1));
  }, [isPresent]), React.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children2 = jsx(PopChild, { isPresent, anchorX, root: root2, children: children2 })), jsx(PresenceContext.Provider, { value: context2, children: children2 });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = !0) {
  const context2 = useContext(PresenceContext);
  if (context2 === null)
    return [!0, null];
  const { isPresent, onExitComplete, register } = context2, id2 = useId$3();
  useEffect(() => {
    if (subscribe)
      return register(id2);
  }, [subscribe]);
  const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [!1, safeToRemove] : [!0];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children2) {
  const filtered = [];
  return Children.forEach(children2, (child) => {
    isValidElement(child) && filtered.push(child);
  }), filtered;
}
const AnimatePresence = ({ children: children2, custom: custom5, initial = !0, onExitComplete, presenceAffectsLayout = !0, mode = "sync", propagate = !1, anchorX = "left", root: root2 }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate), presentChildren = useMemo(() => onlyElements(children2), [children2]), presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey), isInitialRender = useRef(!0), pendingPresentChildren = useRef(presentChildren), exitComplete = useConstant(() => /* @__PURE__ */ new Map()), [diffedChildren, setDiffedChildren] = useState(presentChildren), [renderedChildren, setRenderedChildren] = useState(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = !1, pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key2 = getChildKey(renderedChildren[i2]);
      presentKeys.includes(key2) ? exitComplete.delete(key2) : exitComplete.get(key2) !== !0 && exitComplete.set(key2, !1);
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2], key2 = getChildKey(child);
      presentKeys.includes(key2) || (nextChildren.splice(i2, 0, child), exitingChildren.push(child));
    }
    return mode === "wait" && exitingChildren.length && (nextChildren = exitingChildren), setRenderedChildren(onlyElements(nextChildren)), setDiffedChildren(presentChildren), null;
  }
  const { forceRender } = useContext(LayoutGroupContext);
  return jsx(Fragment, { children: renderedChildren.map((child) => {
    const key2 = getChildKey(child), isPresent = propagate && !isParentPresent ? !1 : presentChildren === renderedChildren || presentKeys.includes(key2), onExit = () => {
      if (exitComplete.has(key2))
        exitComplete.set(key2, !0);
      else
        return;
      let isEveryExitComplete = !0;
      exitComplete.forEach((isExitComplete) => {
        isExitComplete || (isEveryExitComplete = !1);
      }), isEveryExitComplete && (forceRender?.(), setRenderedChildren(pendingPresentChildren.current), propagate && safeToRemove?.(), onExitComplete && onExitComplete());
    };
    return jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : !1, custom: custom5, presenceAffectsLayout, mode, root: root2, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key2);
  }) });
}, DeprecatedLayoutGroupContext = createContext(null);
function useIsMounted() {
  const isMounted = useRef(!1);
  return useIsomorphicLayoutEffect(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = useState(0), forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [useCallback(() => frame.postRender(forceRender), [forceRender]), forcedRenderCount];
}
const notify = (node2) => !node2.isLayoutDirty && node2.willUpdate(!1);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set(), subscriptions = /* @__PURE__ */ new WeakMap(), dirtyAll = () => nodes.forEach(notify);
  return {
    add: (node2) => {
      nodes.add(node2), subscriptions.set(node2, node2.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node2) => {
      nodes.delete(node2);
      const unsubscribe = subscriptions.get(node2);
      unsubscribe && (unsubscribe(), subscriptions.delete(node2)), dirtyAll();
    },
    dirty: dirtyAll
  };
}
const shouldInheritGroup = (inherit2) => inherit2 === !0, shouldInheritId = (inherit2) => shouldInheritGroup(inherit2 === !0) || inherit2 === "id", LayoutGroup = ({ children: children2, id: id2, inherit: inherit2 = !0 }) => {
  const layoutGroupContext = useContext(LayoutGroupContext), deprecatedLayoutGroupContext = useContext(DeprecatedLayoutGroupContext), [forceRender, key2] = useForceUpdate(), context2 = useRef(null), upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  context2.current === null && (shouldInheritId(inherit2) && upstreamId && (id2 = id2 ? upstreamId + "-" + id2 : upstreamId), context2.current = {
    id: id2,
    group: shouldInheritGroup(inherit2) && layoutGroupContext.group || nodeGroup()
  });
  const memoizedContext = useMemo(() => ({ ...context2.current, forceRender }), [key2]);
  return jsx(LayoutGroupContext.Provider, { value: memoizedContext, children: children2 });
}, LazyContext = createContext({ strict: !1 });
function loadFeatures(features) {
  for (const key2 in features)
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
}
function LazyMotion({ children: children2, features, strict = !1 }) {
  const [, setIsLoaded] = useState(!isLazyBundle(features)), loadedRenderer = useRef(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer, loadFeatures(loadedFeatures);
  }
  return useEffect(() => {
    isLazyBundle(features) && features().then(({ renderer, ...loadedFeatures }) => {
      loadFeatures(loadedFeatures), loadedRenderer.current = renderer, setIsLoaded(!0);
    });
  }, []), jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children: children2 });
}
function isLazyBundle(features) {
  return typeof features == "function";
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || key2.startsWith("onLayout") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  typeof isValidProp == "function" && (shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2));
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props)
    key2 === "values" && typeof props.values == "object" || (shouldForward(key2) || forwardMotionProps === !0 && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props.draggable && key2.startsWith("onDrag")) && (filteredProps[key2] = props[key2]);
  return filteredProps;
}
function MotionConfig({ children: children2, isValidProp, ...config }) {
  isValidProp && loadExternalIsValidProp(isValidProp), config = { ...useContext(MotionConfigContext), ...config }, config.isStatic = useConstant(() => config.isStatic);
  const context2 = useMemo(() => config, [
    JSON.stringify(config.transition),
    config.transformPagePoint,
    config.reducedMotion
  ]);
  return jsx(MotionConfigContext.Provider, { value: context2, children: children2 });
}
const MotionContext = /* @__PURE__ */ createContext({});
function getCurrentTreeVariants(props, context2) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== !1 ? context2 : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source)
    !isMotionValue(source[key2]) && !isForcedMotionValue(key2, props) && (target[key2] = source[key2]);
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {}, style2 = {};
  return copyRawValuesOnly(style2, styleProp, props), Object.assign(style2, useInitialMotionValues(props, visualState)), style2;
}
function useHTMLProps(props, visualState) {
  const htmlProps2 = {}, style2 = useStyle(props, visualState);
  return props.drag && props.dragListener !== !1 && (htmlProps2.draggable = !1, style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none", style2.touchAction = props.drag === !0 ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`), props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps2.tabIndex = 0), htmlProps2.style = style2, htmlProps2;
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, isSVGTag(Component2), props.transformTemplate, props.style), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component2))
    )
  );
}
function useRender(Component2, props, ref, { latestValues }, isStatic, forwardMotionProps = !1) {
  const visualProps = (isSVGComponent(Component2) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component2), filteredProps = filterProps(props, typeof Component2 == "string", forwardMotionProps), elementProps = Component2 !== Fragment$1 ? { ...filteredProps, ...visualProps, ref } : {}, { children: children2 } = props, renderedChildren = useMemo(() => isMotionValue(children2) ? children2.get() : children2, [children2]);
  return createElement(Component2, {
    ...elementProps,
    children: renderedChildren
  });
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context2, presenceContext) {
  return {
    latestValues: makeLatestValues(props, context2, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
}
function makeLatestValues(props, context2, presenceContext, scrapeMotionValues) {
  const values2 = {}, motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues)
    values2[key2] = resolveMotionValue(motionValues[key2]);
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props), isVariantNode$1 = isVariantNode(props);
  context2 && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== !1 && (initial === void 0 && (initial = context2.initial), animate2 === void 0 && (animate2 = context2.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list2.length; i2++) {
      const resolved = resolveVariantFromProps(props, list2[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key2 in target) {
          let valueTarget = target[key2];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          valueTarget !== null && (values2[key2] = valueTarget);
        }
        for (const key2 in transitionEnd)
          values2[key2] = transitionEnd[key2];
      }
    }
  }
  return values2;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context2 = useContext(MotionContext), presenceContext = useContext(PresenceContext), make = () => makeState(config, props, context2, presenceContext);
  return isStatic ? make() : useConstant(make);
}, useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  createRenderState: createHtmlRenderState
}), useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps,
  createRenderState: createSvgRenderState
}), motionComponentSymbol = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function isRefObject(ref) {
  return ref && typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.onMount && visualState.onMount(instance), visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    },
    /**
     * Include externalRef in dependencies to ensure the callback updates
     * when the ref changes, allowing proper ref forwarding.
     */
    [visualElement]
  );
}
const SwitchLayoutGroupContext = createContext({});
function useVisualElement(Component2, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  const { visualElement: parent } = useContext(MotionContext), lazyContext = useContext(LazyContext), presenceContext = useContext(PresenceContext), reducedMotionConfig = useContext(MotionConfigContext).reducedMotion, visualElementRef = useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component2, {
    visualState,
    parent,
    props,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  const visualElement = visualElementRef.current, initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
  visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg") && createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  const isMounted = useRef(!1);
  useInsertionEffect$1(() => {
    visualElement && isMounted.current && visualElement.update(props, presenceContext);
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute], wantsHandoff = useRef(!!optimisedAppearId && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
  return useIsomorphicLayoutEffect(() => {
    visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), visualElement.scheduleRenderMicrotask(), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
  }), useEffect(() => {
    visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
    }), wantsHandoff.current = !1), visualElement.enteringChildren = void 0);
  }), visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent)), visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: !!drag2 || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 == "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (visualElement)
    return visualElement.options.allowProjection !== !1 ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createMotionComponent(Component2, { forwardMotionProps = !1 } = {}, preloadedFeatures, createVisualElement) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  const useVisualState = isSVGComponent(Component2) ? useSVGVisualState : useHTMLVisualState;
  function MotionDOMComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    }, { isStatic } = configAndProps, context2 = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout, context2.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxs(MotionContext.Provider, { value: context2, children: [MeasureLayout2 && context2.visualElement ? jsx(MeasureLayout2, { visualElement: context2.visualElement, ...configAndProps }) : null, useRender(Component2, props, useMotionRef(visualState, context2.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
  }
  MotionDOMComponent.displayName = `motion.${typeof Component2 == "string" ? Component2 : `create(${Component2.displayName ?? Component2.name ?? ""})`}`;
  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);
  return ForwardRefMotionComponent[motionComponentSymbol] = Component2, ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
function createMotionProxy(preloadedFeatures, createVisualElement) {
  if (typeof Proxy > "u")
    return createMotionComponent;
  const componentCache = /* @__PURE__ */ new Map(), factory2 = (Component2, options) => createMotionComponent(Component2, options, preloadedFeatures, createVisualElement), deprecatedFactoryFunction = (Component2, options) => factory2(Component2, options);
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => key2 === "create" ? factory2 : (componentCache.has(key2) || componentCache.set(key2, createMotionComponent(key2, void 0, preloadedFeatures, createVisualElement)), componentCache.get(key2))
  });
}
const m$1 = /* @__PURE__ */ createMotionProxy(), createDomVisualElement = (Component2, options) => isSVGComponent(Component2) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
  allowProjection: Component2 !== Fragment$1
});
function calcChildStagger(children2, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
  const index2 = Array.from(children2).sort((a2, b2) => a2.sortNodePosition(b2)).indexOf(child), numChildren = children2.size, maxStaggerDuration = (numChildren - 1) * staggerChildren;
  return typeof delayChildren == "function" ? delayChildren(index2, numChildren) : staggerDirection === 1 ? index2 * staggerChildren : maxStaggerDuration - index2 * staggerChildren;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options.transitionOverride && (transition = options.transitionOverride);
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
}
function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  for (const child of visualElement.variantChildren)
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delay2 + (typeof delayChildren == "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
    }).then(() => child.notify("AnimationComplete", variant)));
  return Promise.all(animations2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation = animateVariant(visualElement, definition, options);
  else {
    const resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return !1;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return !1;
  for (let i2 = 0; i2 < prevLength; i2++)
    if (prev[i2] !== next[i2])
      return !1;
  return !0;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return;
  if (!visualElement.isControllingVariants) {
    const context3 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    return visualElement.props.initial !== void 0 && (context3.initial = visualElement.props.initial), context3;
  }
  const context2 = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2], prop = visualElement.props[name];
    (isVariantLabel(prop) || prop === !1) && (context2[name] = prop);
  }
  return context2;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement), state = createState(), isInitialRender = !0;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement, context2 = getVariantContext(visualElement.parent) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2], typeState = state[type], prop = props[type] !== void 0 ? props[type] : context2[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i2);
      let isInherited = prop === context2[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
      isAnimationControls(prop) || typeof prop == "boolean")
        continue;
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      activeDelta === !1 && (resolvedValues = {});
      const { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key2) => {
        shouldAnimateType = !0, removedKeys.has(key2) && (handledRemovedValues = !0, removedKeys.delete(key2)), typeState.needsAnimating[key2] = !0;
        const motionValue2 = visualElement.getValue(key2);
        motionValue2 && (motionValue2.liveStyle = !1);
      };
      for (const key2 in allKeys) {
        const next = resolvedValues[key2], prev = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        let valueHasChanged = !1;
        isKeyframesTarget(next) && isKeyframesTarget(prev) ? valueHasChanged = !shallowCompare(next, prev) : valueHasChanged = next !== prev, valueHasChanged ? next != null ? markToAnimate(key2) : removedKeys.add(key2) : next !== void 0 && removedKeys.has(key2) ? markToAnimate(key2) : typeState.protectedKeys[key2] = !0;
      }
      typeState.prevProp = prop, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1);
      const willAnimateViaParent = isInherited && variantDidChange;
      shouldAnimateType && (!willAnimateViaParent || handledRemovedValues) && animations2.push(...definitionList.map((animation) => {
        const options = { type };
        if (typeof animation == "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
          const { parent } = visualElement, parentVariant = resolveVariant(parent, animation);
          if (parent.enteringChildren && parentVariant) {
            const { delayChildren } = parentVariant.transition || {};
            options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
          }
        }
        return {
          animation,
          options
        };
      }));
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial != "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        initialTransition && initialTransition.transition && (fallbackAnimation.transition = initialTransition.transition);
      }
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2), motionValue2 = visualElement.getValue(key2);
        motionValue2 && (motionValue2.liveStyle = !0), fallbackAnimation[key2] = fallbackTarget ?? null;
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = !!animations2.length;
    return isInitialRender && (props.initial === !1 || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    if (state[type].isActive === isActive)
      return Promise.resolve();
    visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive)), state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key2 in state)
      state[key2].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
    }
  };
}
function checkVariantsDidChange(prev, next) {
  return typeof next == "string" ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node2) {
    this.isMounted = !1, this.node = node2;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2), node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    isAnimationControls(animate2) && (this.unmountControls = animate2.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate2 !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    onExitComplete && !isPresent && exitAnimation.then(() => {
      onExitComplete(this.id);
    });
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    onExitComplete && onExitComplete(this.id), register && (this.unmount = register(this.id));
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: !0 }) {
  return target.addEventListener(eventName, handler, options), () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = 0.01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin, delta.originPoint = mixNumber$1(source.min, source.max, delta.origin), delta.scale = calcLength(target) / calcLength(source), delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint, (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) && (delta.scale = 1), (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) && (delta.translate = 0);
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0), calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min, target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x), calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min, target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x), calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
const getContextWindow = ({ current: current2 }) => current2 ? current2.ownerDocument.defaultView : null;
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = !1, distanceThreshold = 3 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2, { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info2), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info2);
    }, this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2, this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint), frame.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin && resumeAnimation && resumeAnimation(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event2, panInfo), onSessionEnd && onSessionEnd(event2, panInfo);
    }, !isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin, this.handlers = handlers, this.transformPagePoint = transformPagePoint, this.distanceThreshold = distanceThreshold, this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event), initialInfo = transformPoint(info, this.transformPagePoint), { point: point2 } = initialInfo, { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i2 = history.length - 1, timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  for (; i2 >= 0 && (timestampedPoint = history[i2], !(lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta))); )
    i2--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  return min2 !== void 0 && point2 < min2 ? point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2) : max2 !== void 0 && point2 > max2 && (point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2)), point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min, max2 = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min2, max2] = [max2, min2]), { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source), targetLength = calcLength(target);
  return targetLength > sourceLength ? origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min) : sourceLength > targetLength && (origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min)), clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label2) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label2] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1, distanceThreshold } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event).point);
    }, onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openDragLock && this.openDragLock(), this.openDragLock = setDragLock(drag2), !this.openDragLock))
        return;
      this.latestPointerEvent = event, this.latestPanInfo = info, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current2 = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current2)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current2 = calcLength(measuredAxis) * (parseFloat(current2) / 100));
          }
        }
        this.originPoint[axis] = current2;
      }), onDragStart && frame.postRender(() => onDragStart(event, info)), addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event, info) => {
      this.latestPointerEvent = event, this.latestPanInfo = info;
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info.point, offset2), this.updateAxis("y", info.point, offset2), this.visualElement.render(), onDrag && onDrag(event, info);
    }, onSessionEnd = (event, info) => {
      this.latestPointerEvent = event, this.latestPanInfo = info, this.stop(event, info), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play()), { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      distanceThreshold,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  /**
   * @internal
   */
  stop(event, panInfo) {
    const finalEvent = event || this.latestPointerEvent, finalPanInfo = panInfo || this.latestPanInfo, isDragging2 = this.isDragging;
    if (this.cancel(), !isDragging2 || !finalPanInfo || !finalEvent)
      return;
    const { velocity } = finalPanInfo;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd && frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    !dragPropagation && this.openDragLock && (this.openDragLock(), this.openDragLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    this.constraints && this.constraints[axis] && (next = applyConstraints(next, this.constraints[axis], this.elastic[axis])), axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps(), layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.constraints !== !1 && this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    const constraintsElement = constraints.current, { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      const bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return addValueToWillChange(this.visualElement, axis), axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
  }
  getAnimationState(axis) {
    return this.getAxisMotionValue(axis).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`, props = this.visualElement.getProps(), externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== !1) {
        const latest2 = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest2, max: latest2 }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis), { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event);
    }), measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        const motionValue2 = this.getAxisMotionValue(axis);
        motionValue2 && (this.originPoint[axis] += delta[axis].translate, motionValue2.set(motionValue2.get() + delta[axis].translate));
      }), this.visualElement.render());
    }));
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset2.y) > lockThreshold ? direction = "y" : Math.abs(offset2.x) > lockThreshold && (direction = "x"), direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2), this.removeGroupControls = noop$1, this.removeListeners = noop$1, this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$1;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  handler && frame.postRender(() => handler(event, info));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop$1;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session, onPanEnd && frame.postRender(() => onPanEnd(event, info));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
let hasTakenAnySnapshot = !1;
class MeasureLayoutWithContext extends Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), hasTakenAnySnapshot && projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, { projection } = visualElement;
    return projection && (projection.isPresent = isPresent, hasTakenAnySnapshot = !0, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {
      const stack = projection.getStack();
      (!stack || !stack.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), microtask.postRender(() => {
      !projection.currentAnimation && projection.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    hasTakenAnySnapshot = !0, projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence(), layoutGroup = useContext(LayoutGroupContext);
  return jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value) => typeof value == "string" ? parseFloat(value) : value, isPx = (value) => typeof value == "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2)), target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2));
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target[borderLabel] += "%")) : target[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$1);
function compress(min2, max2, easing) {
  return (p2) => p2 < min2 ? 0 : p2 > max2 ? 1 : easing(/* @__PURE__ */ progress(min2, max2, p2));
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate, delta.scale = originDelta.scale, delta.originPoint = originDelta.originPoint, delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  return point2 -= translate, point2 = scalePoint(point2, 1 / scale2, originPoint), boxScale !== void 0 && (point2 = scalePoint(point2, 1 / boxScale, originPoint)), point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min), typeof translate != "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  axis === originAxis && (originPoint -= translate), axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2), node2.scheduleRender();
  }
  remove(node2) {
    if (removeItem(this.members, node2), node2 === this.prevLead && (this.prevLead = void 0), node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 !== prevLead && (this.prevLead = prevLead, this.lead = node2, node2.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node2.scheduleRender(), node2.resumeFrom = prevLead, preserveFollowOpacity && (node2.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node2.snapshot = prevLead.snapshot, node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node2.root && node2.root.isUpdating && (node2.isLayoutDirty = !0);
      const { crossfade } = node2.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = latestTransform?.z || 0;
  if ((xTranslate || yTranslate || zTranslate) && (transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    transformPerspective && (transform2 = `perspective(${transformPerspective}px) ${transform2}`), rotate2 && (transform2 += `rotate(${rotate2}deg) `), rotateX && (transform2 += `rotateX(${rotateX}deg) `), rotateY && (transform2 += `rotateY(${rotateY}deg) `), skewX && (transform2 += `skewX(${skewX}deg) `), skewY && (transform2 += `skewY(${skewY}deg) `);
  }
  const elementScaleX = delta.x.scale * treeScale.x, elementScaleY = delta.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform2 += `scale(${elementScaleX}, ${elementScaleY})`), transform2 || "none";
}
const transformAxes = ["", "X", "Y", "Z"], animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key2, visualElement, values2, sharedAnimationValues) {
  const { latestValues } = visualElement;
  latestValues[key2] && (values2[key2] = latestValues[key2], visualElement.setStaticValue(key2, 0), sharedAnimationValues && (sharedAnimationValues[key2] = 0));
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  if (projectionNode.hasCheckedOptimisedAppear = !0, projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  parent && !parent.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(parent);
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++)
        this.path[i2].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name, handler) {
      return this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager()), this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance), this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay, innerWidth = 0;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        frame.read(() => {
          innerWidth = window.innerWidth;
        }), attachResizeListener(instance, () => {
          const newInnerWidth = window.innerWidth;
          newInnerWidth !== innerWidth && (innerWidth = newInnerWidth, this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation)));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout), hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
        if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const animationOptions = {
            ...getValueTransition$1(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions), this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
        } else
          hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = !0, node2.updateScroll("snapshot"), node2.options.layoutRoot && node2.willUpdate(!1);
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate)) : this.nodes.forEach(clearIsLayoutDirty), this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp), frameData.timestamp = now2, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i2 = 0; i2 < this.path.length; i2++)
          this.path[i2].updateScroll();
      const prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot))) {
        const { scroll } = this.root;
        scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y));
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      if (copyBoxInto(boxWithoutScroll, box), this.scroll?.wasRoot)
        return boxWithoutScroll;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2], { scroll, options } = node2;
        node2 !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        !transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(withTransforms, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        }), hasTransform(node2.latestValues) && transformBox(withTransforms, node2.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance || !hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox(), nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(forceRecalculation = !1) {
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = !!this.resumingFrom || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      const relativeParent = this.getClosestProjectingParent();
      relativeParent && this.linkedParentVersion !== relativeParent.layoutVersion && !relativeParent.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (relativeParent && relativeParent.layout ? this.createRelativeTarget(relativeParent, this.layout.layoutBox, relativeParent.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, relativeParent && !!relativeParent.resumingFrom == !!this.resumingFrom && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1 ? this.createRelativeTarget(relativeParent, this.target, relativeParent.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(relativeParent, layout2, parentLayout) {
      this.relativeParent = relativeParent, this.linkedParentVersion = relativeParent.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const lead = this.getLead(), isShared = !!this.resumingFrom || this !== lead;
      let canSkip = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox());
      const { target } = lead;
      if (!target) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues), (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      if (this.options.visualElement?.scheduleRender(), notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
      const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack = this.getStack(), isOnlyMember = !stack || stack.members.length <= 1, shouldCrossfadeOpacity = !!(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest2) => {
        const progress2 = latest2 / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2), mixAxisDelta(targetDelta.y, delta.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = motionValue(0)), this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: !0,
          onUpdate: (latest2) => {
            this.mixTargetDelta(latest2), options.onUpdate && options.onUpdate(latest2);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const stack = this.getStack();
      stack && stack.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min, target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min, target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node2) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : !0;
    }
    getLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      stack && stack.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      return stack ? stack.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = !1;
      const { latestValues } = visualElement;
      if ((latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) && (hasDistortingTransform = !0), !hasDistortingTransform)
        return;
      const resetValues = {};
      latestValues.z && resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      for (let i2 = 0; i2 < transformAxes.length; i2++)
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues), resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      visualElement.render();
      for (const key2 in resetValues)
        visualElement.setStaticValue(key2, resetValues[key2]), this.animationValues && (this.animationValues[key2] = resetValues[key2]);
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, targetStyle.visibility = "", targetStyle.opacity = "", targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "", targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        this.options.layoutId && (targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1);
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform2 = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      transformTemplate && (transform2 = transformTemplate(valuesToRender, transform2)), targetStyle.transform = transform2;
      const { x: x2, y: y2 } = this.projectionDelta;
      targetStyle.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key2], corrected = transform2 === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++)
            targetStyle[applyTo[i2]] = corrected;
        } else
          isCSSVariable ? this.options.visualElement.renderState.vars[key2] = corrected : targetStyle[key2] = corrected;
      }
      this.options.layoutId && (targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => node2.currentAnimation?.stop()), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  const snapshot = node2.resumeFrom?.snapshot || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout, { animationType } = node2.options, isShared = snapshot.source !== node2.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length, node2.relativeTarget && !node2.currentAnimation && (node2.isProjectionDirty = !0, node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length);
    });
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = !1;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEqualsRounded(relativeSnapshot, relativeLayout) || (hasRelativeLayoutChanged = !0), relativeParent.options.layoutRoot && (node2.relativeTarget = relativeLayout, node2.relativeTargetOrigin = relativeSnapshot, node2.relativeParent = relativeParent);
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  node2.parent && (node2.isProjecting() || (node2.isProjectionDirty = node2.parent.isProjectionDirty), node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = !!(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty)), node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty));
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = !1;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = !1;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation(), node2.targetDelta = node2.relativeTarget = node2.target = void 0, node2.isProjectionDirty = !0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2), output.scale = mixNumber$1(delta.scale, 1, p2), output.origin = delta.origin, output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to2, p2) {
  output.min = mixNumber$1(from.min, to2.min, p2), output.max = mixNumber$1(from.max, to2.max, p2);
}
function mixBox(output, from, to2, p2) {
  mixAxis(output.x, from.x, to2.x, p2), mixAxis(output.y, from.y, to2.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (string) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min), axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  return node2 !== node2.root && node2.scroll?.wasRoot;
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => window.getComputedStyle(instance).position === "fixed"
}), drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node2, event, lifecycle) {
  const { props } = node2;
  node2.animationState && props.whileHover && node2.animationState.setActive("whileHover", lifecycle === "Start");
  const eventName = "onHover" + lifecycle, callback = props[eventName];
  callback && frame.postRender(() => callback(event, extractEventInfo(event)));
}
class HoverGesture extends Feature {
  mount() {
    const { current: current2 } = this.node;
    current2 && (this.unmount = hover(current2, (_element, startEvent) => (handleHoverEvent(this.node, startEvent, "Start"), (endEvent) => handleHoverEvent(this.node, endEvent, "End"))));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.current instanceof HTMLButtonElement && node2.current.disabled)
    return;
  node2.animationState && props.whileTap && node2.animationState.setActive("whileTap", lifecycle === "Start");
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle), callback = props[eventName];
  callback && frame.postRender(() => callback(event, extractEventInfo(event)));
}
class PressGesture extends Feature {
  mount() {
    const { current: current2 } = this.node;
    current2 && (this.unmount = press(current2, (_element, startEvent) => (handlePressEvent(this.node, startEvent, "Start"), (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  const rootObservers = observers.get(lookupRoot), key2 = JSON.stringify(options);
  return rootObservers[key2] || (rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options })), rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps(), { root: root2, margin: rootMargin, amount = "some", once } = viewport, options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      const { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
}, layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
}, domMax = {
  ...domAnimation,
  ...drag,
  ...layout
};
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial)), { isStatic } = useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = useState(initial);
    useEffect(() => value.on("change", setLatest), []);
  }
  return value;
}
function useReducedMotion() {
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion] = useState(prefersReducedMotion.current);
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion(), { reducedMotion } = useContext(MotionConfigContext);
  return reducedMotion === "never" ? !1 : reducedMotion === "always" ? !0 : reducedMotionPreference;
}
class DragControls {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    return this.componentControls.add(controls), () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
  /**
   * Cancels a drag gesture.
   *
   * ```jsx
   * dragControls.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.componentControls.forEach((controls) => {
      controls.cancel();
    });
  }
  /**
   * Stops a drag gesture.
   *
   * ```jsx
   * dragControls.stop()
   * ```
   *
   * @public
   */
  stop() {
    this.componentControls.forEach((controls) => {
      controls.stop();
    });
  }
}
const createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}
const ElementDetailsActorContext = createContext(null);
ElementDetailsActorContext.displayName = "ElementDetailsActorContext";
const useElementDetailsActorRef = () => {
  const ctx = useContext(ElementDetailsActorContext);
  if (ctx === null)
    throw new Error("ElementDetailsActorRef is not provided");
  return ctx;
}, createRecipe = (name, defaultVariants, compoundVariants) => {
  const getVariantProps2 = (variants) => ({
    [name]: "__ignore__",
    ...defaultVariants,
    ...compact(variants)
  });
  return {
    recipeFn: (variants, withCompoundVariants = !0) => {
      const recipeCss = createCss({
        conditions: {
          shift: sortConditions,
          finalize: finalizeConditions,
          breakpoints: { keys: ["base", "xs", "sm", "md", "lg", "xl"] }
        },
        utility: {
          toHash: (path, hashFn) => hashFn(path.join(":")),
          transform: (prop, value) => (assertCompoundVariant(name, compoundVariants, variants, prop), value === "__ignore__" ? { className: name } : (value = withoutSpace(value), { className: `${name}--${prop}_${value}` }))
        }
      }), recipeStyles = getVariantProps2(variants);
      if (withCompoundVariants) {
        const compoundVariantStyles = getCompoundVariantCss(compoundVariants, recipeStyles);
        return cx(recipeCss(recipeStyles), css(compoundVariantStyles));
      }
      return recipeCss(recipeStyles);
    },
    getVariantProps: getVariantProps2,
    __getCompoundVariantCss__: (variants) => getCompoundVariantCss(compoundVariants, getVariantProps2(variants))
  };
}, mergeRecipes = (recipeA, recipeB) => {
  if (recipeA && !recipeB) return recipeA;
  if (!recipeA && recipeB) return recipeB;
  const recipeFn = (...args) => cx(recipeA(...args), recipeB(...args)), variantKeys = uniq(recipeA.variantKeys, recipeB.variantKeys), variantMap = variantKeys.reduce((acc, key2) => (acc[key2] = uniq(recipeA.variantMap[key2], recipeB.variantMap[key2]), acc), {});
  return Object.assign(recipeFn, {
    __recipe__: !0,
    __name__: `${recipeA.__name__} ${recipeB.__name__}`,
    raw: (props) => props,
    variantKeys,
    variantMap,
    splitVariantProps(props) {
      return splitProps(props, variantKeys);
    }
  });
}, actionBtnFn = /* @__PURE__ */ createRecipe("action-btn", {
  size: "md",
  radius: "md",
  variant: "filled"
}, []), actionBtnVariantMap = {
  variant: [
    "transparent",
    "filled"
  ],
  size: [
    "sm",
    "md"
  ],
  radius: [
    "sm",
    "md"
  ]
}, actionBtnVariantKeys = Object.keys(actionBtnVariantMap), actionBtn = /* @__PURE__ */ Object.assign(memo$2(actionBtnFn.recipeFn), {
  __recipe__: !0,
  __name__: "actionBtn",
  __getCompoundVariantCss__: actionBtnFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: actionBtnVariantKeys,
  variantMap: actionBtnVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, actionBtnVariantKeys);
  },
  getVariantProps: actionBtnFn.getVariantProps
}), compoundNodeFn = /* @__PURE__ */ createRecipe("likec4-compound-node", {}, []), compoundNodeVariantMap = {
  isTransparent: [
    "false",
    "true"
  ],
  inverseColor: [
    "true",
    "false"
  ],
  borderStyle: [
    "solid",
    "dashed",
    "dotted",
    "none"
  ]
}, compoundNodeVariantKeys = Object.keys(compoundNodeVariantMap), compoundNode = /* @__PURE__ */ Object.assign(memo$2(compoundNodeFn.recipeFn), {
  __recipe__: !0,
  __name__: "compoundNode",
  __getCompoundVariantCss__: compoundNodeFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: compoundNodeVariantKeys,
  variantMap: compoundNodeVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, compoundNodeVariantKeys);
  },
  getVariantProps: compoundNodeFn.getVariantProps
}), edgeActionBtnFn = /* @__PURE__ */ createRecipe("likec4-edge-action-btn", {}, []), edgeActionBtnVariantMap = {}, edgeActionBtnVariantKeys = Object.keys(edgeActionBtnVariantMap), edgeActionBtn = /* @__PURE__ */ Object.assign(memo$2(edgeActionBtnFn.recipeFn), {
  __recipe__: !0,
  __name__: "edgeActionBtn",
  __getCompoundVariantCss__: edgeActionBtnFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: edgeActionBtnVariantKeys,
  variantMap: edgeActionBtnVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, edgeActionBtnVariantKeys);
  },
  getVariantProps: edgeActionBtnFn.getVariantProps
}), edgeLabelFn = /* @__PURE__ */ createRecipe("likec4-edge-label", {
  pointerEvents: "all",
  isStepEdge: !1,
  cursor: "default"
}, []), edgeLabelVariantMap = {
  pointerEvents: [
    "none",
    "all"
  ],
  cursor: [
    "pointer",
    "default"
  ],
  isStepEdge: [
    "false",
    "true"
  ]
}, edgeLabelVariantKeys = Object.keys(edgeLabelVariantMap), edgeLabel$1 = /* @__PURE__ */ Object.assign(memo$2(edgeLabelFn.recipeFn), {
  __recipe__: !0,
  __name__: "edgeLabel",
  __getCompoundVariantCss__: edgeLabelFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: edgeLabelVariantKeys,
  variantMap: edgeLabelVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, edgeLabelVariantKeys);
  },
  getVariantProps: edgeLabelFn.getVariantProps
}), edgePathDefaultVariants = {}, edgePathCompoundVariants = [], edgePathSlotNames = [
  [
    "path",
    "likec4-edge__path"
  ],
  [
    "pathBg",
    "likec4-edge__pathBg"
  ],
  [
    "markersCtx",
    "likec4-edge__markersCtx"
  ],
  [
    "middlePoint",
    "likec4-edge__middlePoint"
  ]
], edgePathSlotFns = /* @__PURE__ */ edgePathSlotNames.map(([slotName, slotKey]) => [slotName, createRecipe(slotKey, edgePathDefaultVariants, getSlotCompoundVariant(edgePathCompoundVariants, slotName))]), edgePathFn = memo$2((props = {}) => Object.fromEntries(edgePathSlotFns.map(([slotName, slotFn]) => [slotName, slotFn.recipeFn(props)]))), edgePathVariantKeys = [], getVariantProps$2 = (variants) => ({ ...edgePathDefaultVariants, ...compact(variants) }), edgePath = /* @__PURE__ */ Object.assign(edgePathFn, {
  __recipe__: !1,
  __name__: "edgePath",
  raw: (props) => props,
  classNameMap: {},
  variantKeys: edgePathVariantKeys,
  variantMap: {},
  splitVariantProps(props) {
    return splitProps(props, edgePathVariantKeys);
  },
  getVariantProps: getVariantProps$2
}), elementNodeFn = /* @__PURE__ */ createRecipe("likec4-element-node", {}, []), elementNodeVariantMap = {}, elementNodeVariantKeys = Object.keys(elementNodeVariantMap), elementNode$1 = /* @__PURE__ */ Object.assign(memo$2(elementNodeFn.recipeFn), {
  __recipe__: !0,
  __name__: "elementNode",
  __getCompoundVariantCss__: elementNodeFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: elementNodeVariantKeys,
  variantMap: elementNodeVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, elementNodeVariantKeys);
  },
  getVariantProps: elementNodeFn.getVariantProps
}), elementNodeDataFn = /* @__PURE__ */ createRecipe("likec4-element-node-data", {}, []), elementNodeDataVariantMap = {}, elementNodeDataVariantKeys = Object.keys(elementNodeDataVariantMap), elementNodeData = /* @__PURE__ */ Object.assign(memo$2(elementNodeDataFn.recipeFn), {
  __recipe__: !0,
  __name__: "elementNodeData",
  __getCompoundVariantCss__: elementNodeDataFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: elementNodeDataVariantKeys,
  variantMap: elementNodeDataVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, elementNodeDataVariantKeys);
  },
  getVariantProps: elementNodeDataFn.getVariantProps
}), elementShapeRecipeFn = /* @__PURE__ */ createRecipe("likec4-element-shape", {
  withBorder: !1
}, [
  {
    shapetype: "html",
    withBorder: !0,
    css: {
      "&": {
        borderStyle: "solid",
        borderWidth: "3px",
        borderColor: "var(--likec4-palette-stroke)",
        "--likec4-outline-size": "6px"
      },
      "& .likec4-shape-outline": {
        borderRadius: "10px"
      }
    }
  }
]), elementShapeRecipeVariantMap = {
  shapetype: [
    "html",
    "svg"
  ],
  withBorder: [
    "true",
    "false"
  ]
}, elementShapeRecipeVariantKeys = Object.keys(elementShapeRecipeVariantMap), elementShapeRecipe = /* @__PURE__ */ Object.assign(memo$2(elementShapeRecipeFn.recipeFn), {
  __recipe__: !0,
  __name__: "elementShapeRecipe",
  __getCompoundVariantCss__: elementShapeRecipeFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: elementShapeRecipeVariantKeys,
  variantMap: elementShapeRecipeVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, elementShapeRecipeVariantKeys);
  },
  getVariantProps: elementShapeRecipeFn.getVariantProps
}), likec4tagFn = /* @__PURE__ */ createRecipe("likec4-tag", {
  autoTextColor: !1
}, []), likec4tagVariantMap = {
  autoTextColor: [
    "false",
    "true"
  ]
}, likec4tagVariantKeys = Object.keys(likec4tagVariantMap), likec4tag = /* @__PURE__ */ Object.assign(memo$2(likec4tagFn.recipeFn), {
  __recipe__: !0,
  __name__: "likec4tag",
  __getCompoundVariantCss__: likec4tagFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: likec4tagVariantKeys,
  variantMap: likec4tagVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, likec4tagVariantKeys);
  },
  getVariantProps: likec4tagFn.getVariantProps
}), markdownBlockFn = /* @__PURE__ */ createRecipe("likec4-markdown-block", {
  uselikec4palette: !1,
  value: "markdown"
}, []), markdownBlockVariantMap = {
  uselikec4palette: [
    "true",
    "false"
  ],
  value: [
    "markdown",
    "plaintext"
  ]
}, markdownBlockVariantKeys = Object.keys(markdownBlockVariantMap), markdownBlock = /* @__PURE__ */ Object.assign(memo$2(markdownBlockFn.recipeFn), {
  __recipe__: !0,
  __name__: "markdownBlock",
  __getCompoundVariantCss__: markdownBlockFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: markdownBlockVariantKeys,
  variantMap: markdownBlockVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, markdownBlockVariantKeys);
  },
  getVariantProps: markdownBlockFn.getVariantProps
}), navigationPanelActionIconFn = /* @__PURE__ */ createRecipe("likec4-navigation-panel-icon", {
  variant: "default",
  type: "default"
}, [
  {
    type: "warning",
    variant: "filled",
    css: {
      backgroundColor: {
        base: "likec4.panel.action.warning.bg",
        _hover: "likec4.panel.action.warning.bg.hover"
      }
    }
  }
]), navigationPanelActionIconVariantMap = {
  variant: [
    "default",
    "filled"
  ],
  type: [
    "default",
    "warning"
  ]
}, navigationPanelActionIconVariantKeys = Object.keys(navigationPanelActionIconVariantMap), navigationPanelActionIcon = /* @__PURE__ */ Object.assign(memo$2(navigationPanelActionIconFn.recipeFn), {
  __recipe__: !0,
  __name__: "navigationPanelActionIcon",
  __getCompoundVariantCss__: navigationPanelActionIconFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: navigationPanelActionIconVariantKeys,
  variantMap: navigationPanelActionIconVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, navigationPanelActionIconVariantKeys);
  },
  getVariantProps: navigationPanelActionIconFn.getVariantProps
}), overlayFn = /* @__PURE__ */ createRecipe("likec4-overlay", {
  fullscreen: !1,
  withBackdrop: !0
}, []), overlayVariantMap = {
  fullscreen: [
    "false",
    "true"
  ],
  withBackdrop: [
    "false",
    "true"
  ]
}, overlayVariantKeys = Object.keys(overlayVariantMap), overlay = /* @__PURE__ */ Object.assign(memo$2(overlayFn.recipeFn), {
  __recipe__: !0,
  __name__: "overlay",
  __getCompoundVariantCss__: overlayFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: overlayVariantKeys,
  variantMap: overlayVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, overlayVariantKeys);
  },
  getVariantProps: overlayFn.getVariantProps
}), navigationLinkDefaultVariants = {
  truncateLabel: !1
}, navigationLinkCompoundVariants = [], navigationLinkSlotNames = [
  [
    "root",
    "likec4-navlink__root"
  ],
  [
    "body",
    "likec4-navlink__body"
  ],
  [
    "section",
    "likec4-navlink__section"
  ],
  [
    "label",
    "likec4-navlink__label"
  ],
  [
    "description",
    "likec4-navlink__description"
  ]
], navigationLinkSlotFns = /* @__PURE__ */ navigationLinkSlotNames.map(([slotName, slotKey]) => [slotName, createRecipe(slotKey, navigationLinkDefaultVariants, getSlotCompoundVariant(navigationLinkCompoundVariants, slotName))]), navigationLinkFn = memo$2((props = {}) => Object.fromEntries(navigationLinkSlotFns.map(([slotName, slotFn]) => [slotName, slotFn.recipeFn(props)]))), navigationLinkVariantKeys = [
  "truncateLabel"
], getVariantProps$1 = (variants) => ({ ...navigationLinkDefaultVariants, ...compact(variants) }), navigationLink = /* @__PURE__ */ Object.assign(navigationLinkFn, {
  __recipe__: !1,
  __name__: "navigationLink",
  raw: (props) => props,
  classNameMap: {},
  variantKeys: navigationLinkVariantKeys,
  variantMap: {
    truncateLabel: [
      "true",
      "false"
    ]
  },
  splitVariantProps(props) {
    return splitProps(props, navigationLinkVariantKeys);
  },
  getVariantProps: getVariantProps$1
}), navigationPanelDefaultVariants = {
  size: "md"
}, navigationPanelCompoundVariants = [], navigationPanelSlotNames = [
  [
    "root",
    "likec4-navigation-panel__root"
  ],
  [
    "body",
    "likec4-navigation-panel__body"
  ],
  [
    "logo",
    "likec4-navigation-panel__logo"
  ],
  [
    "label",
    "likec4-navigation-panel__label"
  ],
  [
    "dropdown",
    "likec4-navigation-panel__dropdown"
  ]
], navigationPanelSlotFns = /* @__PURE__ */ navigationPanelSlotNames.map(([slotName, slotKey]) => [slotName, createRecipe(slotKey, navigationPanelDefaultVariants, getSlotCompoundVariant(navigationPanelCompoundVariants, slotName))]), navigationPanelFn = memo$2((props = {}) => Object.fromEntries(navigationPanelSlotFns.map(([slotName, slotFn]) => [slotName, slotFn.recipeFn(props)]))), navigationPanelVariantKeys = [
  "size"
], getVariantProps = (variants) => ({ ...navigationPanelDefaultVariants, ...compact(variants) }), navigationPanel = /* @__PURE__ */ Object.assign(navigationPanelFn, {
  __recipe__: !1,
  __name__: "navigationPanel",
  raw: (props) => props,
  classNameMap: {},
  variantKeys: navigationPanelVariantKeys,
  variantMap: {
    size: [
      "md",
      "lg"
    ]
  },
  splitVariantProps(props) {
    return splitProps(props, navigationPanelVariantKeys);
  },
  getVariantProps
});
function useXYFlow() {
  return useReactFlow();
}
function useXYStore(selector3, equalityFn) {
  return useStore(
    useCallbackRef(selector3),
    equalityFn ?? shallowEqual$1
  );
}
function useXYStoreApi() {
  return useStoreApi();
}
const selectCurrentZoom = (state) => Math.round(state.transform[2] * 100) / 100;
function useCurrentZoom() {
  return useStore(selectCurrentZoom);
}
const selectZoom = (state) => state.transform[2] < 0.2;
function useIsZoomTooSmall() {
  return useStore(selectZoom);
}
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v2) {
  return v2 < 0 ? -pow(-v2, 1 / 3) : pow(v2, 1 / 3);
}
const pi$2 = Math.PI, tau$1 = 2 * pi$2, quart = pi$2 / 2, epsilon$2 = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 }, utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d2 = derivativeFn(t2);
    let l = d2.x * d2.x + d2.y * d2.y;
    return typeof d2.z < "u" && (l += d2.z * d2.z), sqrt$1(l);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0)
      return points[0].t = 0, points[0];
    const order = points.length - 1;
    if (t2 === 1)
      return points[order].t = 1, points[order];
    const mt = 1 - t2;
    let p2 = points;
    if (order === 0)
      return points[0].t = t2, points[0];
    if (order === 1) {
      const ret = {
        x: mt * p2[0].x + t2 * p2[1].x,
        y: mt * p2[0].y + t2 * p2[1].y,
        t: t2
      };
      return _3d && (ret.z = mt * p2[0].z + t2 * p2[1].z), ret;
    }
    if (order < 4) {
      let mt2 = mt * mt, t22 = t2 * t2, a2, b2, c, d2 = 0;
      order === 2 ? (p2 = [p2[0], p2[1], p2[2], ZERO], a2 = mt2, b2 = mt * t2 * 2, c = t22) : order === 3 && (a2 = mt2 * mt, b2 = mt2 * t2 * 3, c = mt * t22 * 3, d2 = t2 * t22);
      const ret = {
        x: a2 * p2[0].x + b2 * p2[1].x + c * p2[2].x + d2 * p2[3].x,
        y: a2 * p2[0].y + b2 * p2[1].y + c * p2[2].y + d2 * p2[3].y,
        t: t2
      };
      return _3d && (ret.z = a2 * p2[0].z + b2 * p2[1].z + c * p2[2].z + d2 * p2[3].z), ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    for (; dCpts.length > 1; ) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++)
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
        }, typeof dCpts[i2].z < "u" && (dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2);
      dCpts.splice(dCpts.length - 1, 1);
    }
    return dCpts[0].t = t2, dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt = 1 - t2, r2 = ratios, p2 = points;
    let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d2;
    if (f1 *= mt, f2 *= t2, p2.length === 2)
      return d2 = f1 + f2, {
        x: (f1 * p2[0].x + f2 * p2[1].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 2 * mt, f3 *= t2 * t2, p2.length === 3)
      return d2 = f1 + f2 + f3, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z) / d2 : !1,
        t: t2
      };
    if (f1 *= mt, f2 *= 1.5 * mt, f3 *= 3 * mt, f4 *= t2 * t2 * t2, p2.length === 4)
      return d2 = f1 + f2 + f3 + f4, {
        x: (f1 * p2[0].x + f2 * p2[1].x + f3 * p2[2].x + f4 * p2[3].x) / d2,
        y: (f1 * p2[0].y + f2 * p2[1].y + f3 * p2[2].y + f4 * p2[3].y) / d2,
        z: _3d ? (f1 * p2[0].z + f2 * p2[1].z + f3 * p2[2].z + f4 * p2[3].z) / d2 : !1,
        t: t2
      };
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p2 = points, d2 = p2.length, c = d2 - 1; d2 > 1; d2--, c--) {
      const list2 = [];
      for (let j2 = 0, dpt; j2 < c; j2++)
        dpt = {
          x: c * (p2[j2 + 1].x - p2[j2].x),
          y: c * (p2[j2 + 1].y - p2[j2].y)
        }, _3d && (dpt.z = c * (p2[j2 + 1].z - p2[j2].z)), list2.push(dpt);
      dpoints.push(list2), p2 = list2;
    }
    return dpoints;
  },
  between: function(v2, m2, M) {
    return m2 <= v2 && v2 <= M || utils.approximately(v2, m2) || utils.approximately(v2, M);
  },
  approximately: function(a2, b2, precision) {
    return abs$1(a2 - b2) <= (precision || epsilon$2);
  },
  length: function(derivativeFn) {
    const len = utils.Tvalues.length;
    let sum = 0;
    for (let i2 = 0, t2; i2 < len; i2++)
      t2 = 0.5 * utils.Tvalues[i2] + 0.5, sum += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
    return 0.5 * sum;
  },
  map: function(v2, ds, de, ts, te) {
    const d1 = de - ds, d2 = te - ts, v22 = v2 - ds, r2 = v22 / d1;
    return ts + d2 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    return v1.z !== void 0 && v2.z !== void 0 && (ret.z = v1.z + r2 * (v2.z - v1.z)), ret;
  },
  pointToString: function(p2) {
    let s2 = p2.x + "/" + p2.y;
    return typeof p2.z < "u" && (s2 += "/" + p2.z), s2;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o, v1, v2) {
    const dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function(v2, d2) {
    const s2 = "" + v2, pos = s2.indexOf(".");
    return parseFloat(s2.substring(0, pos + 1 + d2));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow(2, 63), mpos, d2;
    return LUT.forEach(function(p2, idx) {
      d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, mpos = idx);
    }), { mdist, mpos };
  },
  abcratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const bottom = pow(t2, n2) + pow(1 - t2, n2), top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const top = pow(1 - t2, n2), bottom = pow(t2, n2) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d2 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    return d2 == 0 ? !1 : { x: nx / d2, y: ny / d2 };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    return sections.forEach(function(s2) {
      const bbox = s2.bbox();
      mx > bbox.x.min && (mx = bbox.x.min), my > bbox.y.min && (my = bbox.y.min), MX < bbox.x.max && (MX = bbox.x.max), MY < bbox.y.max && (MY = bbox.y.max);
    }), {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [], a1 = [s1.startcap, s1.forward, s1.back, s1.endcap], a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    return a1.forEach(function(l1) {
      l1.virtual || a2.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        iss.length > 0 && (iss.c1 = l1, iss.c2 = l2, iss.s1 = s1, iss.s2 = s2, intersections.push(iss));
      });
    }), intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length, fpl = forward.points.length, start2 = utils.makeline(back.points[bpl - 1], forward.points[0]), end = utils.makeline(forward.points[fpl - 1], back.points[0]), shape = {
      startcap: start2,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start2, forward, back, end])
    };
    return shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    }, shape;
  },
  getminmax: function(curve2, d2, list2) {
    if (!list2) return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c;
    list2.indexOf(0) === -1 && (list2 = [0].concat(list2)), list2.indexOf(1) === -1 && list2.push(1);
    for (let i2 = 0, len = list2.length; i2 < len; i2++)
      t2 = list2[i2], c = curve2.get(t2), c[d2] < min2 && (min2 = c[d2]), c[d2] > max2 && (max2 = c[d2]);
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line2) {
    const tx = line2.p1.x, ty = line2.p1.y, a2 = -atan2(line2.p2.y - ty, line2.p2.x - tx), d2 = function(v2) {
      return {
        x: (v2.x - tx) * cos$1(a2) - (v2.y - ty) * sin$1(a2),
        y: (v2.x - tx) * sin$1(a2) + (v2.y - ty) * cos$1(a2)
      };
    };
    return points.map(d2);
  },
  roots: function(points, line2) {
    line2 = line2 || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order = points.length - 1, aligned = utils.align(points, line2), reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order === 2) {
      const a3 = aligned[0].y, b3 = aligned[1].y, c2 = aligned[2].y, d3 = a3 - 2 * b3 + c2;
      if (d3 !== 0) {
        const m1 = -sqrt$1(b3 * b3 - a3 * c2), m2 = -a3 + b3, v12 = -(m1 + m2) / d3, v2 = -(-m1 + m2) / d3;
        return [v12, v2].filter(reduce);
      } else if (b3 !== c2 && d3 === 0)
        return [(2 * b3 - c2) / (2 * b3 - 2 * c2)].filter(reduce);
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d2 = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c = pa;
    if (utils.approximately(d2, 0)) {
      if (utils.approximately(a2, 0))
        return utils.approximately(b2, 0) ? [] : [-c / b2].filter(reduce);
      const q3 = sqrt$1(b2 * b2 - 4 * a2 * c), a22 = 2 * a2;
      return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
    }
    a2 /= d2, b2 /= d2, c /= d2;
    const p2 = (3 * b2 - a2 * a2) / 3, p3 = p2 / 3, q = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p2 / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
      return x1 = t1 * cos$1(phi / 3) - a2 / 3, x2 = t1 * cos$1((phi + tau$1) / 3) - a2 / 3, x3 = t1 * cos$1((phi + 2 * tau$1) / 3) - a2 / 3, [x1, x2, x3].filter(reduce);
    } else {
      if (discriminant === 0)
        return u1 = q2 < 0 ? crt(-q2) : -crt(q2), x1 = 2 * u1 - a2 / 3, x2 = -u1 - a2 / 3, [x1, x2].filter(reduce);
      {
        const sd = sqrt$1(discriminant);
        return u1 = crt(-q2 + sd), v1 = crt(q2 + sd), [u1 - v1 - a2 / 3].filter(reduce);
      }
    }
  },
  droots: function(p2) {
    if (p2.length === 3) {
      const a2 = p2[0], b2 = p2[1], c = p2[2], d2 = a2 - 2 * b2 + c;
      if (d2 !== 0) {
        const m1 = -sqrt$1(b2 * b2 - a2 * c), m2 = -a2 + b2, v1 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v1, v2];
      } else if (b2 !== c && d2 === 0)
        return [(2 * b2 - c) / (2 * (b2 - c))];
      return [];
    }
    if (p2.length === 2) {
      const a2 = p2[0], b2 = p2[1];
      return a2 !== b2 ? [a2 / (a2 - b2)] : [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num, dnm, adk, dk, k = 0, r2 = 0;
    const d3 = utils.compute(t2, d1), dd = utils.compute(t2, d2), qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d ? (num = sqrt$1(
      pow(d3.y * dd.z - dd.y * d3.z, 2) + pow(d3.z * dd.x - dd.z * d3.x, 2) + pow(d3.x * dd.y - dd.x * d3.y, 2)
    ), dnm = pow(qdsum + d3.z * d3.z, 3 / 2)) : (num = d3.x * dd.y - d3.y * dd.x, dnm = pow(qdsum, 3 / 2)), num === 0 || dnm === 0)
      return { k: 0, r: 0 };
    if (k = num / dnm, r2 = dnm / num, !kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, !0).k, nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, !0).k;
      dk = (nk - k + (k - pk)) / 2, adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;
    }
    return { k, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p2 = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p2[2].x * p2[1].y, b2 = p2[3].x * p2[1].y, c = p2[1].x * p2[2].y, d2 = p2[3].x * p2[2].y, v1 = 18 * (-3 * a2 + 2 * b2 + 3 * c - d2), v2 = 18 * (3 * a2 - b2 - 3 * c), v3 = 18 * (c - a2);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1) return [t2];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d22, -(v2 + sq) / d22].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len = dims.length;
    for (let i2 = 0, dim, l, t2, d2; i2 < len; i2++)
      if (dim = dims[i2], l = b1[dim].mid, t2 = b2[dim].mid, d2 = (b1[dim].size + b2[dim].size) / 2, abs$1(l - t2) >= d2) return !1;
    return !0;
  },
  expandbox: function(bbox, _bbox) {
    _bbox.x.min < bbox.x.min && (bbox.x.min = _bbox.x.min), _bbox.y.min < bbox.y.min && (bbox.y.min = _bbox.y.min), _bbox.z && _bbox.z.min < bbox.z.min && (bbox.z.min = _bbox.z.min), _bbox.x.max > bbox.x.max && (bbox.x.max = _bbox.x.max), _bbox.y.max > bbox.y.max && (bbox.y.max = _bbox.y.max), _bbox.z && _bbox.z.max > bbox.z.max && (bbox.z.max = _bbox.z.max), bbox.x.mid = (bbox.x.min + bbox.x.max) / 2, bbox.y.mid = (bbox.y.min + bbox.y.max) / 2, bbox.z && (bbox.z.mid = (bbox.z.min + bbox.z.max) / 2), bbox.x.size = bbox.x.max - bbox.x.min, bbox.y.size = bbox.y.max - bbox.y.min, bbox.z && (bbox.z.size = bbox.z.max - bbox.z.min);
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold)
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
      ];
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    return pairs.length === 0 || (pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    }), results = results.filter(function(v2, i2) {
      return results.indexOf(v2) === i2;
    })), results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s2 = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _;
    return s2 < e2 ? ((s2 > m2 || m2 > e2) && (s2 += tau$1), s2 > e2 && (_ = e2, e2 = s2, s2 = _)) : e2 < m2 && m2 < s2 ? (_ = e2, e2 = s2, s2 = _) : e2 += tau$1, arc.s = s2, arc.e = e2, arc.r = r2, arc;
  },
  numberSort: function(a2, b2) {
    return a2 - b2;
  }
};
class PolyBezier {
  constructor(curves) {
    this.curves = [], this._3d = !1, curves && (this.curves = curves, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve2) {
      return utils.pointsToString(curve2.points);
    }).join(", ") + "]";
  }
  addCurve(curve2) {
    this.curves.push(curve2), this._3d = this._3d || curve2._3d;
  }
  length() {
    return this.curves.map(function(v2) {
      return v2.length();
    }).reduce(function(a2, b2) {
      return a2 + b2;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c = this.curves;
    for (var bbox = c[0].bbox(), i2 = 1; i2 < c.length; i2++)
      utils.expandbox(bbox, c[i2].bbox());
    return bbox;
  }
  offset(d2) {
    const offset2 = [];
    return this.curves.forEach(function(v2) {
      offset2.push(...v2.offset(d2));
    }), new PolyBezier(offset2);
  }
}
const { abs, min, max, cos, sin, acos, sqrt } = Math, pi$1 = Math.PI;
class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice(), coordlen = !1;
    if (typeof args[0] == "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d2) {
          typeof point3[d2] < "u" && newargs.push(point3[d2]);
        });
      }), args = newargs;
    }
    let higher = !1;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        higher = !0;
      }
    } else if (len !== 6 && len !== 8 && len !== 9 && len !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z < "u", points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      _3d && (point2.z = args[idx + 2]), points.push(point2);
    }
    const order = this.order = points.length - 1, dims = this.dims = ["x", "y"];
    _3d && dims.push("z"), this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order] }), baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t2, p2) => t2 + abs(p2.y), 0) < baselength / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 > "u" && (t2 = 0.5), t2 === 0)
      return new Bezier(p2, p2, p3);
    if (t2 === 1)
      return new Bezier(p1, p2, p2);
    const abc = Bezier.getABC(2, p1, p2, p3, t2);
    return new Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S2, B, E2, t2, d1) {
    typeof t2 > "u" && (t2 = 0.5);
    const abc = Bezier.getABC(3, S2, B, E2, t2);
    typeof d1 > "u" && (d1 = utils.dist(B, abc.C));
    const d2 = d1 * (1 - t2) / t2, selen = utils.dist(S2, E2), lx = (E2.x - S2.x) / selen, ly = (E2.y - S2.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly, e1 = { x: B.x - bx1, y: B.y - by1 }, e2 = { x: B.x + bx2, y: B.y + by2 }, A = abc.A, v1 = { x: A.x + (e1.x - A.x) / (1 - t2), y: A.y + (e1.y - A.y) / (1 - t2) }, v2 = { x: A.x + (e2.x - A.x) / t2, y: A.y + (e2.y - A.y) / t2 }, nc1 = { x: S2.x + (v1.x - S2.x) / t2, y: S2.y + (v1.y - S2.y) / t2 }, nc2 = {
      x: E2.x + (v2.x - E2.x) / (1 - t2),
      y: E2.y + (v2.y - E2.y) / (1 - t2)
    };
    return new Bezier(S2, nc1, nc2, E2);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const p2 = this.points, x2 = p2[0].x, y2 = p2[0].y, s2 = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last = p2.length; i2 < last; i2++)
      s2.push(p2[i2].x), s2.push(p2[i2].y);
    return s2.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = ratios, this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    print !== this._print && (this._print = print, this.update());
  }
  coordDigest() {
    return this.points.map(function(c, pos) {
      return "" + pos + c.x + c.y + (c.z ? c.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = utils.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const points = this.points, angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S2, B, E2, t2 = 0.5) {
    const u = utils.projectionratio(t2, order), um = 1 - u, C2 = {
      x: u * S2.x + um * E2.x,
      y: u * S2.y + um * E2.y
    }, s2 = utils.abcratio(t2, order);
    return { A: {
      x: B.x + (B.x - C2.x) / s2,
      y: B.y + (B.y - C2.y) / s2
    }, B, C: C2, S: S2, E: E2 };
  }
  getABC(t2, B) {
    B = B || this.get(t2);
    let S2 = this.points[0], E2 = this.points[this.order];
    return Bezier.getABC(this.order, S2, B, E2, t2);
  }
  getLUT(steps) {
    if (this.verify(), steps = steps || 100, this._lut.length === steps + 1)
      return this._lut;
    this._lut = [], steps++, this._lut = [];
    for (let i2 = 0, p2, t2; i2 < steps; i2++)
      t2 = i2 / (steps - 1), p2 = this.compute(t2), p2.t = t2, this._lut.push(p2);
    return this._lut;
  }
  on(point2, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i2 = 0, c, t2 = 0; i2 < lut.length; i2++)
      c = lut[i2], utils.dist(c, point2) < error && (hits.push(c), t2 += i2 / lut.length);
    return hits.length ? t /= hits.length : !1;
  }
  project(point2) {
    const LUT = this.getLUT(), l = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t1 = (mpos - 1) / l, t2 = (mpos + 1) / l, step = 0.1 / l;
    let mdist = closest.mdist, t3 = t1, ft = t3, p2;
    mdist += 1;
    for (let d2; t3 < t2 + step; t3 += step)
      p2 = this.compute(t3), d2 = utils.dist(point2, p2), d2 < mdist && (mdist = d2, ft = t3);
    return ft = ft < 0 ? 0 : ft > 1 ? 1 : ft, p2 = this.compute(ft), p2.t = ft, p2.d = mdist, p2;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    return this.ratios ? utils.computeWithRatios(t2, this.points, this.ratios, this._3d) : utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p2 = this.points, np = [p2[0]], k = p2.length;
    for (let i2 = 1, pi2, pim; i2 < k; i2++)
      pi2 = p2[i2], pim = p2[i2 - 1], np[i2] = {
        x: (k - i2) / k * pi2.x + i2 / k * pim.x,
        y: (k - i2) / k * pi2.y + i2 / k * pim.y
      };
    return np[k] = p2[k - 1], new Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p2 = this.points;
    return new Bezier(utils.align(p2, { p1: p2[0], p2: p2[p2.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d2 = this.derivative(t2), q = sqrt(d2.x * d2.x + d2.y * d2.y);
    return { t: t2, x: -d2.y / q, y: d2.x / q };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1, r1.y /= q1, r1.z /= q1, r2.x /= q2, r2.y /= q2, r2.z /= q2;
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    }, m2 = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m2, c.y /= m2, c.z /= m2;
    const R = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z
    ];
    return {
      t: t2,
      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
    };
  }
  hull(t2) {
    let p2 = this.points, _p = [], q = [], idx = 0;
    for (q[idx++] = p2[0], q[idx++] = p2[1], q[idx++] = p2[2], this.order === 3 && (q[idx++] = p2[3]); p2.length > 1; ) {
      _p = [];
      for (let i2 = 0, pt, l = p2.length - 1; i2 < l; i2++)
        pt = utils.lerp(t2, p2[i2], p2[i2 + 1]), q[idx++] = pt, _p.push(pt);
      p2 = _p;
    }
    return q;
  }
  split(t1, t2) {
    if (t1 === 0 && t2)
      return this.split(t2).left;
    if (t2 === 1)
      return this.split(t1).right;
    const q = this.hull(t1), result = {
      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),
      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q
    };
    return result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2), result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2), t2 ? (t2 = utils.map(t2, t1, 1, 0, 1), result.right.split(t2).left) : result;
  }
  extrema() {
    const result = {};
    let roots = [];
    return this.dims.forEach(
      function(dim) {
        let mfn = function(v2) {
          return v2[dim];
        }, p2 = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p2), this.order === 3 && (p2 = this.dpoints[1].map(mfn), result[dim] = result[dim].concat(utils.droots(p2))), result[dim] = result[dim].filter(function(t2) {
          return t2 >= 0 && t2 <= 1;
        }), roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    ), result.values = roots.sort(utils.numberSort).filter(function(v2, idx) {
      return roots.indexOf(v2) === idx;
    }), result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    return this.dims.forEach(
      function(d2) {
        result[d2] = utils.getminmax(this, d2, extrema[d2]);
      }.bind(this)
    ), result;
  }
  overlaps(curve2) {
    const lbbox = this.bbox(), tbbox = curve2.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d2) {
    if (typeof d2 < "u") {
      const c = this.get(t2), n2 = this.normal(t2), ret = {
        c,
        n: n2,
        x: c.x + n2.x * d2,
        y: c.y + n2.y * d2
      };
      return this._3d && (ret.z = c.z + n2.z * d2), ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p2) {
        const ret = {
          x: p2.x + t2 * nv.x,
          y: p2.y + t2 * nv.y
        };
        return p2.z && nv.z && (ret.z = p2.z + t2 * nv.z), ret;
      });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function(s2) {
      return s2._linear ? s2.offset(t2)[0] : s2.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]), a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return !1;
    }
    const n1 = this.normal(0), n2 = this.normal(1);
    let s2 = n1.x * n2.x + n1.y * n2.y;
    return this._3d && (s2 += n1.z * n2.z), abs(acos(s2)) < pi$1 / 3;
  }
  reduce() {
    let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [], extrema = this.extrema().values;
    for (extrema.indexOf(0) === -1 && (extrema = [0].concat(extrema)), extrema.indexOf(1) === -1 && extrema.push(1), t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++)
      t2 = extrema[i2], segment = this.split(t1, t2), segment._t1 = t1, segment._t2 = t2, pass1.push(segment), t1 = t2;
    return pass1.forEach(function(p1) {
      for (t1 = 0, t2 = 0; t2 <= 1; )
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step)
          if (segment = p1.split(t1, t2), !segment.simple()) {
            if (t2 -= step, abs(t1 - t2) < step)
              return [];
            segment = p1.split(t1, t2), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2), pass2.push(segment), t1 = t2;
            break;
          }
      t1 < 1 && (segment = p1.split(t1, 1), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = p1._t2, pass2.push(segment));
    }), pass2;
  }
  translate(v2, d1, d2) {
    d2 = typeof d2 == "number" ? d2 : d1;
    const o = this.order;
    let d3 = this.points.map((_, i2) => (1 - i2 / o) * d1 + i2 / o * d2);
    return new Bezier(
      this.points.map((p2, i2) => ({
        x: p2.x + v2.x * d3[i2],
        y: p2.y + v2.y * d3[i2]
      }))
    );
  }
  scale(d2) {
    const order = this.order;
    let distanceFn = !1;
    if (typeof d2 == "function" && (distanceFn = d2), distanceFn && order === 2)
      return this.raise().scale(distanceFn);
    const clockwise = this.clockwise, points = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d2,
        distanceFn ? distanceFn(1) : d2
      );
    const r1 = distanceFn ? distanceFn(0) : d2, r2 = distanceFn ? distanceFn(1) : d2, v2 = [this.offset(0, 10), this.offset(1, 10)], np = [], o = utils.lli4(v2[0], v2[0].c, v2[1], v2[1].c);
    if (!o)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(t2) {
      const p2 = np[t2 * order] = utils.copy(points[t2 * order]);
      p2.x += (t2 ? r2 : r1) * v2[t2].n.x, p2.y += (t2 ? r2 : r1) * v2[t2].n.y;
    }), distanceFn ? ([0, 1].forEach(function(t2) {
      if (!(order === 2 && t2)) {
        var p2 = points[t2 + 1], ov = {
          x: p2.x - o.x,
          y: p2.y - o.y
        }, rc = distanceFn ? distanceFn((t2 + 1) / order) : d2;
        distanceFn && !clockwise && (rc = -rc);
        var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m2, ov.y /= m2, np[t2 + 1] = {
          x: p2.x + rc * ov.x,
          y: p2.y + rc * ov.y
        };
      }
    }), new Bezier(np)) : ([0, 1].forEach((t2) => {
      if (order === 2 && t2) return;
      const p2 = np[t2 * order], d3 = this.derivative(t2), p22 = { x: p2.x + d3.x, y: p2.y + d3.y };
      np[t2 + 1] = utils.lli4(p2, p22, o, points[t2 + 1]);
    }), new Bezier(np));
  }
  outline(d1, d2, d3, d4) {
    if (d2 = d2 === void 0 ? d1 : d2, this._linear) {
      const n2 = this.normal(0), start2 = this.points[0], end = this.points[this.points.length - 1];
      let s2, mid, e2;
      d3 === void 0 && (d3 = d1, d4 = d2), s2 = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 }, e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const fline = [s2, mid, e2];
      s2 = { x: start2.x - n2.x * d2, y: start2.y - n2.y * d2 }, e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 }, mid = { x: (s2.x + e2.x) / 2, y: (s2.y + e2.y) / 2 };
      const bline = [e2, mid, s2], ls2 = utils.makeline(bline[2], fline[0]), le2 = utils.makeline(fline[2], bline[0]), segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p2, alen = 0, tlen = this.length();
    const graduated = typeof d3 < "u" && typeof d4 < "u";
    function linearDistanceFunction(s2, e2, tlen2, alen2, slen) {
      return function(v2) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d5 = e2 - s2;
        return utils.map(v2, 0, 1, s2 + f1 * d5, s2 + f2 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      graduated ? (fcurves.push(
        segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
      ), bcurves.push(
        segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
      )) : (fcurves.push(segment.scale(d1)), bcurves.push(segment.scale(-d2))), alen += slen;
    }), bcurves = bcurves.map(function(s2) {
      return p2 = s2.points, p2[3] ? s2.points = [p2[3], p2[2], p2[1], p2[0]] : s2.points = [p2[2], p2[1], p2[0]], s2;
    }).reverse();
    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves, shapes = [];
    for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
      const shape = utils.makeshape(
        outline[i2],
        outline[len - i2],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i2 > 1, shape.endcap.virtual = i2 < len / 2 - 1, shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve2, curveIntersectionThreshold) {
    return curve2 ? curve2.p1 && curve2.p2 ? this.lineIntersects(curve2) : (curve2 instanceof Bezier && (curve2 = curve2.reduce()), this.curveintersects(
      this.reduce(),
      curve2,
      curveIntersectionThreshold
    )) : this.selfintersects(curveIntersectionThreshold);
  }
  lineIntersects(line2) {
    const mx = min(line2.p1.x, line2.p2.x), my = min(line2.p1.y, line2.p2.y), MX = max(line2.p1.x, line2.p2.x), MY = max(line2.p1.y, line2.p2.y);
    return utils.roots(this.points, line2).filter((t2) => {
      var p2 = this.get(t2);
      return utils.between(p2.x, mx, MX) && utils.between(p2.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i2 = 0, result, left, right; i2 < len; i2++)
      left = reduced.slice(i2, i2 + 1), right = reduced.slice(i2 + 2), result = this.curveintersects(left, right, curveIntersectionThreshold), results.push(...result);
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l) {
      c2.forEach(function(r2) {
        l.overlaps(r2) && pairs.push({ left: l, right: r2 });
      });
    });
    let intersections = [];
    return pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      result.length > 0 && (intersections = intersections.concat(result));
    }), intersections;
  }
  arcs(errorThreshold) {
    return errorThreshold = errorThreshold || 0.5, this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s2, e2) {
    const q = (e2 - s2) / 4, c1 = this.get(s2 + q), c2 = this.get(e2 - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0, t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc, curr_good = !1, prev_good = !1, done, t_m = t_e, prev_e = 1;
      do
        if (prev_good = curr_good, prev_arc = arc, t_m = (t_s + t_e) / 2, np2 = this.get(t_m), np3 = this.get(t_e), arc = utils.getccenter(np1, np2, np3), arc.interval = {
          start: t_s,
          end: t_e
        }, curr_good = this._error(arc, np1, t_s, t_e) <= errorThreshold, done = prev_good && !curr_good, done || (prev_e = t_e), curr_good) {
          if (t_e >= 1) {
            if (arc.interval.end = prev_e = 1, prev_arc = arc, t_e > 1) {
              let d2 = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d2, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else
          t_e = t_m;
      while (!done && safety++ < 100);
      if (safety >= 100)
        break;
      prev_arc = prev_arc || arc, circles.push(prev_arc), t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}
function isEqualRects(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
const nodeToRect = (nd) => ({
  x: Math.round(nd.internals.positionAbsolute.x),
  y: Math.round(nd.internals.positionAbsolute.y),
  width: nd.measured?.width ?? nd.width ?? nd.initialWidth ?? 0,
  height: nd.measured?.height ?? nd.height ?? nd.initialHeight ?? 0
});
function getNodeCenter(node2) {
  const { width, height } = getNodeDimensions(node2), { x: x2, y: y2 } = node2.internals.positionAbsolute;
  return {
    x: Math.round(x2 + width / 2),
    y: Math.round(y2 + height / 2)
  };
}
function getNodeIntersectionFromCenterToPoint(intersectionNode, target, nodeMargin = 0) {
  const { width, height } = intersectionNode, nodeCenter = BBox.center(intersectionNode), v2 = vector(target.x, target.y).subtract(nodeCenter), xScale = (nodeMargin + width / 2) / v2.x, yScale = (nodeMargin + height / 2) / v2.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v2).multiply(scale2).add(nodeCenter).round();
}
function bezierControlPoints(points) {
  let [start2, ...bezierPoints] = points;
  invariant$1(start2, "start should be defined");
  const handles = [
    // start
  ];
  for (; t$q(bezierPoints, 3); ) {
    const [cp1, cp2, end, ...rest] = bezierPoints, bezier = new Bezier(start2[0], start2[1], cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]), inflections = bezier.inflections();
    inflections.length === 0 && inflections.push(0.5), inflections.forEach((t2) => {
      const { x: x2, y: y2 } = bezier.get(t2);
      handles.push({
        x: Math.round(x2),
        y: Math.round(y2)
      });
    }), bezierPoints = rest, start2 = end;
  }
  return invariant$1(bezierPoints.length === 0, "all points should be consumed"), invariant$1(t$q(handles, 1), "at least one control point should be generated"), handles;
}
function isSamePoint(a2, b2) {
  const pointA = e$d(a2) ? { x: a2[0], y: a2[1] } : a2, pointB = e$d(b2) ? { x: b2[0], y: b2[1] } : b2;
  return distanceBetweenPoints(pointA, pointB) < 2.1;
}
function distanceBetweenPoints(a2, b2) {
  return Math.hypot(b2.x - a2.x, b2.y - a2.y);
}
function stopPropagation(e2) {
  return e2.stopPropagation();
}
function bezierPath(bezierSpline) {
  let [start2, ...points] = bezierSpline;
  invariant$1(start2, "start should be defined");
  let path = `M ${start2[0]},${start2[1]}`;
  for (; t$q(points, 3); ) {
    const [cp1, cp2, end, ...rest] = points;
    path = path + ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${end[0]},${end[1]}`, points = rest;
  }
  return invariant$1(points.length === 0, "all points should be consumed"), path;
}
const ElementTag = forwardRef(
  ({ tag, cursor, className, style: style2, ...props }, ref) => {
    const spec = useTagSpecification(tag);
    return /* @__PURE__ */ jsxs(
      Box,
      {
        ref,
        "data-likec4-tag": tag,
        className: cx(
          likec4tag({
            autoTextColor: isTagColorSpecified(spec)
          }),
          className
        ),
        ...props,
        style: {
          cursor,
          ...style2
        },
        children: [
          /* @__PURE__ */ jsx("span", { children: "#" }),
          /* @__PURE__ */ jsx("span", { children: tag })
        ]
      }
    );
  }
), propsAreEqual = (prev, next) => prev.data.width === next.data.width && deepEqual$1(prev.data.tags, next.data.tags) && (prev.data.hovered ?? !1) === (next.data.hovered ?? !1), ElementTags = memo$3(({ id: id2, data: { tags, width, hovered = !1 } }) => {
  const {
    hovered: isTagsBarHovered,
    ref: tagsBarRef
  } = useHover$1(), {
    hovered: isTagsToolbarHovered,
    ref: tagsToolbarRef
  } = useHover$1(), [isVisible, setVisible] = useDebouncedState(!1, hovered ? 120 : 300);
  useEffect(() => {
    setVisible((visibleNow) => visibleNow ? hovered || isTagsBarHovered || isTagsToolbarHovered : hovered && (isTagsBarHovered || isTagsToolbarHovered));
  }, [isTagsBarHovered, isTagsToolbarHovered, hovered]);
  const zoom2 = useCurrentZoom(), zoomIsLargeEnough = zoom2 > 1.2, diagram = useDiagram(), onHover = (tag) => {
    diagram.send({ type: "tag.highlight", tag });
  }, onLeave = useCallback(() => {
    diagram.send({ type: "tag.unhighlight" });
  }, []);
  if (!tags || tags.length === 0)
    return null;
  const maxWidth = Math.max(Math.round(width * zoom2) - 10, 200);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "div",
      {
        ref: tagsBarRef,
        className: cx(
          "likec4-element-tags",
          hstack({
            pointerEvents: "all",
            gap: "1",
            alignItems: "flex-end",
            justifyItems: "stretch",
            position: "absolute",
            width: "100%",
            bottom: "0",
            left: "0",
            padding: "1",
            _shapeCylinder: {
              bottom: "[5px]"
            },
            _shapeStorage: {
              bottom: "[5px]"
            },
            _shapeQueue: {
              bottom: "0",
              paddingLeft: "[14px]"
            }
          })
        ),
        onClick: stopPropagation,
        children: tags.map((tag) => /* @__PURE__ */ jsx(
          Box,
          {
            "data-likec4-tag": tag,
            className: css({
              layerStyle: "likec4.tag",
              flex: "1",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              maxWidth: 50,
              height: 5,
              _whenHovered: {
                height: 12,
                borderRadius: 4,
                transitionDelay: ".08s"
              },
              transition: "fast"
            })
          },
          id2 + "#" + tag
        ))
      }
    ),
    /* @__PURE__ */ jsx(NodeToolbar, { isVisible, align: "start", position: Position.Bottom, children: /* @__PURE__ */ jsx(
      HStack,
      {
        ref: tagsToolbarRef,
        css: {
          gap: "0.5",
          alignItems: "baseline",
          flexWrap: "wrap",
          pb: "sm",
          translate: "auto",
          x: "[-8px]",
          maxWidth
        },
        children: tags.map((tag) => /* @__PURE__ */ jsx(
          ElementTag,
          {
            tag,
            cursor: "pointer",
            className: css({
              userSelect: "none",
              ...zoomIsLargeEnough && {
                fontSize: "lg",
                borderRadius: "[4px]",
                px: "1.5"
                // 6px
              }
            }),
            onClick: (e2) => {
              e2.stopPropagation(), diagram.openSearch(`#${tag}`);
            },
            onMouseEnter: () => onHover(tag),
            onMouseLeave: onLeave
          },
          tag
        ))
      }
    ) })
  ] });
}, propsAreEqual);
ElementTags.displayName = "ElementTags";
const GithubIcon = forwardRef((props, ref) => /* @__PURE__ */ jsx(
  "svg",
  {
    height: "24",
    width: "24",
    fill: "currentColor",
    ...props,
    viewBox: "0 0 24 24",
    ref,
    children: /* @__PURE__ */ jsx("path", { d: "M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z" })
  }
));
const __iconNode$F = [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]], IconCheck = createReactComponent("outline", "check", "Check", __iconNode$F);
const __iconNode$E = [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]], IconCopy = createReactComponent("outline", "copy", "Copy", __iconNode$E), GITHUB_PREFIX = "https://github.com/", Link = forwardRef(
  ({ value, className, ...props }, ref) => {
    const url = value.url.includes("://") ? value.url : new window.URL(value.url, window.location.href).toString();
    let isGithub = url.startsWith(GITHUB_PREFIX);
    return /* @__PURE__ */ jsx(
      Badge,
      {
        ref,
        variant: "default",
        radius: "sm",
        size: "sm",
        tt: "none",
        leftSection: value.title ? /* @__PURE__ */ jsx(Fragment, { children: value.title }) : null,
        rightSection: /* @__PURE__ */ jsx(CopyButton, { value: url, timeout: 1500, children: ({ copy, copied }) => /* @__PURE__ */ jsx(
          ActionIcon,
          {
            className: css({
              opacity: copied ? 1 : 0.45,
              transition: "fast",
              _hover: {
                opacity: 1
              }
            }),
            tabIndex: -1,
            size: "20",
            variant: copied ? "light" : "transparent",
            color: copied ? "teal" : "gray",
            "data-active": copied,
            onClick: (e2) => {
              e2.stopPropagation(), e2.preventDefault(), copy();
            },
            children: copied ? /* @__PURE__ */ jsx(IconCheck, {}) : /* @__PURE__ */ jsx(IconCopy, { stroke: 2.5 })
          }
        ) }),
        ...props,
        className: cx(className, "group"),
        classNames: {
          root: css({
            flexWrap: "nowrap",
            minHeight: 24,
            maxWidth: 500,
            userSelect: "all",
            pr: "0",
            backgroundColor: {
              base: "transparent",
              _hover: {
                base: "mantine.colors.gray[1]",
                _dark: "mantine.colors.dark[5]"
              }
            }
          }),
          section: css({
            '&:is([data-position="left"])': {
              color: "mantine.colors.dimmed",
              userSelect: "none",
              pointerEvents: "none",
              _groupHover: {
                color: "[var(--badge-color)]",
                opacity: 0.7
              }
            }
          })
        },
        children: /* @__PURE__ */ jsxs(
          styled.a,
          {
            href: url,
            target: "_blank",
            style: {
              color: "var(--badge-color)",
              cursor: "pointer"
            },
            css: {
              transition: "fast",
              opacity: {
                base: 0.7,
                _hover: 1
              },
              textDecoration: {
                base: "none",
                _hover: "underline"
              }
            },
            children: [
              isGithub && /* @__PURE__ */ jsx(
                GithubIcon,
                {
                  height: "12",
                  width: "12",
                  style: { verticalAlign: "middle", marginRight: "4px" }
                }
              ),
              isGithub ? url.replace(GITHUB_PREFIX, "") : url
            ]
          }
        )
      }
    );
  }
);
function useOptionalCurrentViewModel() {
  return useContext(CurrentViewModelContext);
}
function useCurrentViewModel() {
  const vm = useContext(CurrentViewModelContext);
  if (!vm)
    throw new Error("No LikeC4ViewModel in context found");
  return vm;
}
const backdropBlur$1 = "--_blur", backdropOpacity$1 = "--_opacity", dialog$1 = css({
  boxSizing: "border-box",
  margin: "0",
  padding: "0",
  position: "fixed",
  inset: "0",
  width: "100vw",
  height: "100vh",
  maxWidth: "100vw",
  maxHeight: "100vh",
  background: "transparent",
  border: "transparent",
  _backdrop: {
    // WebkitBackdropFilter: `blur(${backdropBlur})`,
    backdropFilter: "auto",
    backdropBlur: `var(${backdropBlur$1})`,
    backgroundColor: `[rgb(36 36 36 / var(${backdropOpacity$1}, 5%))]`
  }
}), card$1 = css({
  position: "absolute",
  pointerEvents: "all",
  display: "flex",
  flexDirection: "column",
  padding: "4",
  gap: "lg",
  justifyContent: "stretch",
  color: "mantine.colors.text",
  boxShadow: "md",
  overflow: "hidden",
  border: "none",
  background: `[
    linear-gradient(180deg,
    color-mix(in oklab, var(--likec4-palette-fill) 60%, transparent),
    color-mix(in oklab, var(--likec4-palette-fill) 20%, transparent) 8px,
    color-mix(in oklab, var(--likec4-palette-fill) 14%, transparent) 20px,
    transparent 80px
    ),
    linear-gradient(180deg, var(--likec4-palette-fill), var(--likec4-palette-fill) 4px, transparent 4px),
    {colors.likec4.overlay.body}
  ]`,
  "& .react-flow__attribution": {
    display: "none"
  }
}), cardHeader = css({
  flex: 0,
  cursor: "move"
}), title$2 = css({
  display: "block",
  fontFamily: "likec4.element",
  fontOpticalSizing: "auto",
  fontStyle: "normal",
  fontWeight: 600,
  fontSize: "24px",
  // lineHeight: 1.15,
  lineHeight: "xs"
  // color: vars.element.hiContrast
}), iconSize$1 = "40px", elementIcon$1 = css({
  flex: `0 0 ${iconSize$1}`,
  height: iconSize$1,
  width: iconSize$1,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  alignSelf: "flex-start",
  cursor: "move",
  _dark: {
    mixBlendMode: "hard-light"
  },
  "& :where(svg, img)": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none",
    filter: `
    drop-shadow(0 0 3px rgb(0 0 0 / 10%))
    drop-shadow(0 1px 8px rgb(0 0 0 / 5%))
    drop-shadow(1px 1px 16px rgb(0 0 0 / 2%))
  `
  },
  "& img": {
    objectFit: "contain"
  }
}), viewTitleColor = "--view-title-color", iconColor = "--icon-color", viewButton$1 = css({
  // display: 'flex',
  width: "100%",
  background: "mantine.colors.body",
  borderRadius: "sm",
  padding: "[10px 8px]",
  // gap: 6,
  // alignItems: 'flex-start',
  transition: "fast",
  border: "1px dashed",
  borderColor: "mantine.colors.defaultBorder",
  [viewTitleColor]: "{colors.mantine.colors.dark[1]}",
  _hover: {
    background: "mantine.colors.defaultHover",
    [iconColor]: "{colors.mantine.colors.dark[1]}",
    [viewTitleColor]: "{colors.mantine.colors.defaultColor}"
  },
  _dark: {
    background: "mantine.colors.dark[6]"
  },
  _light: {
    [iconColor]: "{colors.mantine.colors.gray[6]}",
    [viewTitleColor]: "{colors.mantine.colors.gray[7]}",
    _hover: {
      [iconColor]: "{colors.mantine.colors.gray[7]}"
    }
  },
  "& .mantine-ThemeIcon-root": {
    transition: "fast",
    // color: fallbackVar(iconColor, 'mantine.colors.dark[2])',
    color: `[var(${iconColor}, {colors.mantine.colors.dark[2]})]`,
    "--ti-size": "22px",
    _hover: {
      color: "mantine.colors.defaultColor"
    }
  },
  "& > *": {
    transition: "all 130ms {easings.inOut}"
  },
  "&:hover > *": {
    transitionTimingFunction: "out",
    transform: "translateX(1.6px)"
  }
}), viewButtonTitle = css({
  transition: "fast",
  color: `[var(${viewTitleColor}, {colors.mantine.colors.gray[7]})]`,
  fontSize: "15px",
  fontWeight: 500,
  lineHeight: "1.4"
}), tabsRoot = css({
  flex: 1,
  display: "flex",
  flexDirection: "column",
  justifyContent: "stretch",
  overflow: "hidden",
  gap: "sm"
}), tabsList = css({
  // flex: '0',
  background: "mantine.colors.gray[1]",
  borderRadius: "sm",
  flexWrap: "nowrap",
  gap: "1.5",
  // 6px
  padding: "1",
  _dark: {
    background: "mantine.colors.dark[7]"
  }
}), tabsTab = css({
  fontSize: "xs",
  fontWeight: 500,
  flexGrow: 1,
  padding: "[6px 8px]",
  transition: "fast",
  borderRadius: "sm",
  color: "mantine.colors.gray[7]",
  _hover: {
    transitionTimingFunction: "out",
    color: "mantine.colors.defaultColor",
    background: "mantine.colors.gray[3]"
  },
  "&[data-active]": {
    transition: "none",
    background: "mantine.colors.white",
    shadow: "xs",
    color: "mantine.colors.defaultColor"
  },
  _dark: {
    color: "mantine.colors.dark[1]",
    _hover: {
      color: "mantine.colors.white",
      background: "mantine.colors.dark[6]"
    },
    "&:is([data-active])": {
      color: "mantine.colors.white",
      background: "mantine.colors.dark[5]"
    }
  }
}), tabsPanel = css({
  flex: 1,
  overflow: "hidden",
  position: "relative",
  "&:not(:has(.mantine-ScrollArea-root))": {
    paddingLeft: "1",
    paddingRight: "1"
  },
  "& .mantine-ScrollArea-root": {
    width: "100%",
    height: "100%",
    "& > div": {
      paddingLeft: "1",
      paddingRight: "1"
    }
  }
}), propertiesGrid = css({
  flex: 1,
  display: "grid",
  gridTemplateColumns: "min-content 1fr",
  gridAutoRows: "min-content max-content",
  gap: "[24px 20px]",
  alignItems: "baseline",
  justifyItems: "stretch"
}), propertyLabel = css({
  justifySelf: "end",
  textAlign: "right",
  userSelect: "none"
}), resizeHandle = css({
  position: "absolute",
  width: "14px",
  height: "14px",
  border: "3.5px solid",
  borderColor: "mantine.colors.dark[3]",
  borderTop: "none",
  borderLeft: "none",
  borderRadius: "2px",
  bottom: "0.5",
  right: "0.5",
  transition: "fast",
  cursor: "se-resize",
  _hover: {
    borderWidth: "4px",
    borderColor: "mantine.colors.dark[1]"
  }
});
const __iconNode$D = [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]], IconChevronDown = createReactComponent("outline", "chevron-down", "ChevronDown", __iconNode$D);
const __iconNode$C = [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]], IconChevronRight = createReactComponent("outline", "chevron-right", "ChevronRight", __iconNode$C);
function MetadataProvider({ children: children2 }) {
  return /* @__PURE__ */ jsx(Fragment, { children: children2 });
}
function TruncatedValue({ value, isExpanded }) {
  const [isTruncated, setIsTruncated] = useState(!1), textRef = useRef(null);
  return useEffect(() => {
    textRef.current && setIsTruncated(textRef.current.scrollWidth > textRef.current.clientWidth);
  }, [value]), /* @__PURE__ */ jsx(
    Tooltip$6,
    {
      label: isTruncated && !isExpanded ? value : null,
      multiline: !0,
      w: 300,
      withinPortal: !0,
      children: /* @__PURE__ */ jsx(
        Text,
        {
          ref: textRef,
          component: "div",
          className: css({
            fontSize: "sm",
            padding: "xs",
            userSelect: "all",
            color: "mantine.colors.text",
            lineHeight: 1.4,
            whiteSpace: isExpanded ? "pre-wrap" : "nowrap",
            overflow: isExpanded ? "visible" : "hidden",
            textOverflow: isExpanded ? "unset" : "ellipsis",
            wordBreak: isExpanded ? "break-word" : "normal",
            minWidth: 0,
            width: "100%"
          }),
          children: value
        }
      )
    }
  );
}
function MultiValueDisplay({
  values: values2,
  isExpanded
}) {
  return isExpanded ? /* @__PURE__ */ jsx(Stack, { gap: "xs", children: values2.map((value, index2) => /* @__PURE__ */ jsxs(Flex, { align: "center", gap: "xs", children: [
    /* @__PURE__ */ jsx(
      Text,
      {
        className: css({
          fontSize: "xs",
          color: "mantine.colors.gray[5]",
          fontWeight: 500,
          flexShrink: 0,
          _dark: {
            color: "mantine.colors.dark[3]"
          }
        }),
        children: ""
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: css({
          minHeight: "32px",
          display: "flex",
          alignItems: "center",
          flex: 1
        }),
        children: /* @__PURE__ */ jsx(TruncatedValue, { value, isExpanded: !0 })
      }
    )
  ] }, index2)) }) : /* @__PURE__ */ jsx(
    Box$1,
    {
      className: css({
        minHeight: "32px",
        display: "flex",
        alignItems: "center",
        padding: "xs",
        gap: "xs",
        flexWrap: "wrap",
        minWidth: 0,
        // Allow shrinking
        overflow: "hidden"
        // Prevent overflow
      }),
      children: values2.map((value, index2) => /* @__PURE__ */ jsxs(Flex, { align: "center", gap: "xs", style: { minWidth: 0 }, children: [
        /* @__PURE__ */ jsx(
          Text,
          {
            className: css({
              fontSize: "sm",
              padding: "[4px 8px]",
              backgroundColor: "mantine.colors.white",
              color: "mantine.colors.text",
              borderRadius: "sm",
              border: "1px solid",
              borderColor: "mantine.colors.gray[3]",
              whiteSpace: "nowrap",
              overflow: "hidden",
              textOverflow: "ellipsis",
              maxWidth: "min(200px, 100%)",
              minWidth: "60px",
              flex: "0 1 auto",
              userSelect: "all",
              _dark: {
                backgroundColor: "mantine.colors.dark[9]",
                color: "mantine.colors.text",
                borderColor: "mantine.colors.dark[4]"
              }
            }),
            title: value,
            children: value
          }
        ),
        index2 < values2.length - 1 && /* @__PURE__ */ jsx(
          Text,
          {
            className: css({
              fontSize: "xs",
              color: "mantine.colors.gray[5]",
              fontWeight: 500,
              flexShrink: 0,
              _dark: {
                color: "mantine.colors.dark[3]"
              }
            }),
            children: ""
          }
        )
      ] }, index2))
    }
  );
}
function MetadataValue({ label: label2, value }) {
  const elements = Array.isArray(value) ? value : typeof value == "string" && value.includes(`
`) ? value.split(`
`).map((s2) => s2.trim()).filter(Boolean) : [value], hasMultipleElements = elements.length > 1, [isExpanded, setIsExpanded] = useState(!1);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    hasMultipleElements ? /* @__PURE__ */ jsx(
      UnstyledButton,
      {
        onClick: () => {
          setIsExpanded(!isExpanded);
        },
        className: css({
          fontSize: "xs",
          color: "mantine.colors.dimmed",
          justifySelf: "end",
          textAlign: "right",
          userSelect: "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-end",
          gap: "xs",
          padding: "[4px 8px]",
          borderRadius: "sm",
          whiteSpace: "nowrap",
          transition: "all 150ms ease",
          _hover: {
            backgroundColor: "mantine.colors.gray[1]",
            color: "mantine.colors.primary[6]",
            _dark: {
              backgroundColor: "mantine.colors.dark[7]",
              color: "mantine.colors.primary[4]"
            }
          }
        }),
        children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: "xs", children: [
          /* @__PURE__ */ jsxs(Text, { component: "span", size: "xs", fw: 700, children: [
            label2,
            ":"
          ] }),
          /* @__PURE__ */ jsx(
            Text,
            {
              component: "span",
              className: css({
                fontSize: "xs",
                fontWeight: 500,
                color: "mantine.colors.gray[6]",
                backgroundColor: "mantine.colors.gray[1]",
                padding: "[1px 4px]",
                borderRadius: "xs",
                _dark: {
                  color: "mantine.colors.dark[2]",
                  backgroundColor: "mantine.colors.dark[6]"
                }
              }),
              children: elements.length
            }
          ),
          isExpanded ? /* @__PURE__ */ jsx(IconChevronDown, { size: 12 }) : /* @__PURE__ */ jsx(IconChevronRight, { size: 12 })
        ] })
      }
    ) : /* @__PURE__ */ jsxs(
      Text,
      {
        component: "div",
        className: css({
          fontSize: "xs",
          color: "mantine.colors.dimmed",
          justifySelf: "end",
          textAlign: "right",
          userSelect: "none",
          whiteSpace: "nowrap",
          padding: "[4px 8px]",
          fontWeight: 700
        }),
        children: [
          label2,
          ":"
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: css({
          justifySelf: "stretch",
          alignSelf: "start"
        }),
        children: hasMultipleElements ? /* @__PURE__ */ jsx(
          MultiValueDisplay,
          {
            values: elements,
            isExpanded
          }
        ) : /* @__PURE__ */ jsx(
          Box$1,
          {
            className: css({
              minHeight: "32px",
              display: "flex",
              alignItems: "center"
            }),
            children: /* @__PURE__ */ jsx(TruncatedValue, { value: elements[0] || "", isExpanded })
          }
        )
      }
    )
  ] });
}
const treeNode$1 = css({
  "&[data-level='1']": {
    marginBottom: "sm"
  }
}), treeNodeLabel$1 = css({
  cursor: "default",
  marginTop: "0",
  marginBottom: "0"
}), label$1 = css({
  transition: "fast",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.dark[1]"
  },
  "& > *": {
    transition: "fast"
  },
  _hover: {
    transitionTimingFunction: "out",
    "& > :not([data-no-transform])": {
      transitionTimingFunction: "out",
      transform: "translateX(1px)"
    }
  }
  //   '.mantine-Button-root:hover & > :not([data-no-transform])': {
  // transitionTimingFunction: 'out',
  //   transform: 'translateX(1px)',
  //   },
}), nodeLabel = cx(label$1), instanceLabel = cx(
  label$1,
  css({
    cursor: "pointer",
    width: "100%",
    justifyContent: "stretch",
    flexWrap: "nowrap",
    height: "36px",
    paddingInlineStart: "[16px]",
    paddingInlineEnd: "2.5",
    // 10px
    borderRadius: "sm",
    alignItems: "center",
    color: "mantine.colors.gray[7]",
    _dark: {
      color: "mantine.colors.gray.lightColor"
    },
    _hover: {
      background: "mantine.colors.gray.lightHover"
    },
    "& .tabler-icon": {
      transition: "fast",
      width: "90%",
      opacity: 0.65
    }
  })
);
const __iconNode$B = [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]], IconInfoCircle = createReactComponent("outline", "info-circle", "InfoCircle", __iconNode$B);
const __iconNode$A = [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M12 12m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0", key: "svg-1" }], ["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-2" }]], IconTarget = createReactComponent("outline", "target", "Target", __iconNode$A);
const __iconNode$z = [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }], ["path", { d: "M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-4" }], ["path", { d: "M16 16l-2.5 -2.5", key: "svg-5" }]], IconZoomScan = createReactComponent("outline", "zoom-scan", "ZoomScan", __iconNode$z), DeploymentNodeRenderer = ({
  node: node2
}) => /* @__PURE__ */ jsxs(Group, { className: nodeLabel, gap: 6, align: "baseline", wrap: "nowrap", children: [
  /* @__PURE__ */ jsxs(Text, { component: "div", fz: 11, c: "dimmed", children: [
    node2.kind,
    ":"
  ] }),
  /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", children: node2.title })
] }), DeployedInstanceRenderer = ({
  instance
}) => {
  const diagram = useDiagram(), currentViewId = diagram.currentView.id, views = [...instance.views()];
  return /* @__PURE__ */ jsxs(Group, { className: instanceLabel, gap: 4, children: [
    /* @__PURE__ */ jsx(ThemeIcon, { color: "gray", variant: "transparent", size: "xs", flex: 0, children: /* @__PURE__ */ jsx(IconTarget, { stroke: 1.2 }) }),
    /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", flex: "1 1 100%", children: instance.title }),
    /* @__PURE__ */ jsxs(Box$1, { onClick: stopPropagation, pos: "relative", "data-no-transform": !0, flex: 0, children: [
      views.length === 0 && /* @__PURE__ */ jsx(Button, { size: "compact-xs", variant: "transparent", color: "gray", disabled: !0, children: "no views" }),
      views.length > 0 && /* @__PURE__ */ jsxs(
        Menu,
        {
          shadow: "md",
          withinPortal: !1,
          position: "bottom-start",
          offset: 0,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          closeOnEscape: !0,
          trapFocus: !0,
          children: [
            /* @__PURE__ */ jsx(Menu.Target, { children: /* @__PURE__ */ jsxs(Button, { size: "compact-xs", variant: "subtle", color: "gray", children: [
              views.length,
              " view",
              views.length > 1 ? "s" : ""
            ] }) }),
            /* @__PURE__ */ jsx(Menu.Dropdown, { children: views.map((view) => /* @__PURE__ */ jsx(
              Menu.Item,
              {
                px: "xs",
                py: 4,
                disabled: view.id === currentViewId,
                leftSection: /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "gray", children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, opacity: 0.65 }) }),
                styles: {
                  itemSection: {
                    marginInlineEnd: rem(8)
                  }
                },
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.navigateTo(view.id);
                },
                children: view.title
              },
              view.id
            )) })
          ]
        }
      )
    ] })
  ] });
}, setHoveredNode$3 = () => {
}, TabPanelDeployments = memo$3(({ elementFqn }) => {
  const element = useLikeC4Model().element(elementFqn), deployments = [...element.deployments()], tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode$3;
  const data = useMemo(() => {
    let roots = [], treeItems = /* @__PURE__ */ new Map();
    for (const instance of element.deployments()) {
      let instanceNode = {
        label: /* @__PURE__ */ jsx(DeployedInstanceRenderer, { instance }),
        value: instance.id,
        type: "instance",
        children: []
      };
      treeItems.set(instance.id, instanceNode);
      let ancestor = instance.parent;
      for (; ancestor; ) {
        let ancestorNode = treeItems.get(ancestor.id);
        if (ancestorNode) {
          ancestorNode.children.push(instanceNode);
          break;
        }
        ancestorNode = {
          label: /* @__PURE__ */ jsx(DeploymentNodeRenderer, { node: ancestor }),
          value: ancestor.id,
          type: "node",
          children: [instanceNode]
        }, treeItems.set(ancestor.id, ancestorNode), instanceNode = ancestorNode, ancestor = ancestor.parent;
      }
      !ancestor && !roots.includes(instanceNode) && roots.push(instanceNode);
    }
    return roots;
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), deployments.length === 0 ? /* @__PURE__ */ jsx(Alert, { variant: "light", color: "gray", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: "This element does not have any deployments" }) : (
    // <Box></Box>
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "sm",
        allowRangeSelection: !1,
        classNames: {
          node: treeNode$1,
          label: treeNodeLabel$1
        },
        styles: {
          root: {
            position: "relative",
            width: "min-content",
            minWidth: 300
          }
        },
        data,
        tree,
        renderNode: ({ node: node2, selected: selected2, elementProps, hasChildren }) => /* @__PURE__ */ jsx(
          Box$1,
          {
            ...elementProps,
            style: {
              ...!hasChildren && {
                marginBottom: rem(4)
              }
            },
            children: hasChildren ? /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: !0,
                color: "gray",
                variant: selected2 ? "transparent" : "subtle",
                size: "xs",
                justify: "flex-start",
                styles: {
                  root: {
                    position: "unset",
                    paddingInlineStart: rem(16)
                  }
                },
                children: node2.label
              }
            ) : node2.label
          }
        )
      }
    )
  );
}), noop3 = () => {
}, depsShallowEqual = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (!(element === d2[i2] || shallowEqual$1(element, d2[i2])))
      return !1;
  return !0;
};
function useUpdateEffect(callback, deps, equalityFn, effectHook) {
  const isFirstMount = useFirstMountState();
  useCustomCompareEffect(
    isFirstMount ? noop3 : callback,
    deps,
    equalityFn ?? depsShallowEqual,
    effectHook
  );
}
function getDevicePixelRatio() {
  const dpr = typeof window < "u" && typeof window.devicePixelRatio == "number" ? window.devicePixelRatio : 1;
  return t$v(Math.floor(dpr), {
    min: 1,
    max: 4
  });
}
let knownDpr;
function roundDpr(v2) {
  return knownDpr ??= getDevicePixelRatio(), knownDpr < 2 ? Math.round(v2) : Math.round(v2 * knownDpr) / knownDpr;
}
function literalToEnum(value) {
  switch (value) {
    case "dots":
      return BackgroundVariant.Dots;
    case "lines":
      return BackgroundVariant.Lines;
    case "cross":
      return BackgroundVariant.Cross;
    default:
      nonexhaustive(value);
  }
}
const compareProps = (prev, next) => typeof prev.background == "string" && typeof next.background == "string" ? prev.background === next.background : deepEqual$1(prev.background, next.background), Background = memo$3(({ background }) => typeof background == "string" ? /* @__PURE__ */ jsx(Background$1, { variant: literalToEnum(background), size: 2, gap: 20 }) : /* @__PURE__ */ jsx(Background$1, { ...background }), compareProps);
Background.displayName = "Background";
const _setDimmed = (v2, dimmed) => (v2.data.dimmed ?? !1) === dimmed ? v2 : {
  ...v2,
  data: {
    ...v2.data,
    dimmed
  }
};
function setDimmed(arg1, arg2) {
  return arg2 !== void 0 ? _setDimmed(arg1, arg2) : (v2) => _setDimmed(v2, arg1);
}
const _setHovered = (v2, hovered) => (v2.data.hovered ?? !1) === hovered ? v2 : {
  ...v2,
  data: {
    ...v2.data,
    hovered
  }
};
function setHovered(arg1, arg2) {
  return arg2 !== void 0 ? _setHovered(arg1, arg2) : (v2) => _setHovered(v2, arg1);
}
function _setData(value, state) {
  return n$k(value.data, state) ? value : {
    ...value,
    data: {
      ...value.data,
      ...state
    }
  };
}
function setData(arg1, arg2) {
  return arg2 !== void 0 ? _setData(arg1, arg2) : (edge) => _setData(edge, arg1);
}
const Base = {
  setDimmed,
  setHovered,
  setData
}, ZIndexes = {
  Compound: 1,
  // XYFlow increments zIndexes of compounds
  Edge: 20,
  Element: 20,
  Max: 30
}, MinZoom = 0.05, MaxZoom = 3, FitViewPaddings = {
  default: "16px",
  withControls: {
    top: "58px",
    left: "16px",
    right: "16px",
    bottom: "16px"
  }
};
function BaseXYFlow({
  nodes,
  edges,
  onEdgesChange,
  onNodesChange,
  className,
  pannable = !0,
  zoomable = !0,
  nodesSelectable = !0,
  nodesDraggable = !1,
  background = "dots",
  children: children2,
  colorMode,
  fitViewPadding = 0,
  fitView = !0,
  zoomOnDoubleClick = !1,
  onViewportResize,
  onMoveEnd,
  onNodeMouseEnter: onNodeMouseEnter2,
  onNodeMouseLeave: onNodeMouseLeave2,
  onEdgeMouseEnter: onEdgeMouseEnter2,
  onEdgeMouseLeave: onEdgeMouseLeave2,
  ...props
}) {
  const fitViewOptions = useMemo(() => ({
    minZoom: MinZoom,
    maxZoom: 1,
    padding: fitViewPadding,
    includeHiddenNodes: !1
  }), [fitViewPadding]), isBgWithPattern = background !== "transparent" && background !== "solid", isZoomTooSmall = useIsZoomTooSmall(), xystore = useXYStoreApi(), { colorScheme } = useMantineColorScheme();
  return colorMode || (colorMode = colorScheme === "auto" ? "system" : colorScheme), /* @__PURE__ */ jsxs(
    index$3,
    {
      colorMode,
      nodes,
      edges,
      className: cx(
        background === "transparent" && "bg-transparent",
        className
      ),
      ...isZoomTooSmall && {
        "data-likec4-zoom-small": !0
      },
      zoomOnPinch: zoomable,
      zoomOnScroll: !pannable && zoomable,
      ...!zoomable && {
        zoomActivationKeyCode: null
      },
      zoomOnDoubleClick,
      maxZoom: zoomable ? MaxZoom : 1,
      minZoom: zoomable ? MinZoom : 1,
      fitView,
      fitViewOptions,
      preventScrolling: zoomable || pannable,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      noWheelClassName: "nowheel",
      panOnScroll: pannable,
      panOnDrag: pannable,
      ...!pannable && {
        panActivationKeyCode: null,
        selectionKeyCode: null
      },
      elementsSelectable: nodesSelectable,
      nodesFocusable: nodesDraggable || nodesSelectable,
      edgesFocusable: !1,
      nodesDraggable,
      nodeDragThreshold: 4,
      nodeClickDistance: 3,
      paneClickDistance: 3,
      elevateNodesOnSelect: !1,
      selectNodesOnDrag: !1,
      onNodesChange,
      onEdgesChange,
      onMoveEnd: useCallbackRef((event, { x: x2, y: y2, zoom: zoom2 }) => {
        const roundedX = roundDpr(x2), roundedY = roundDpr(y2);
        (x2 !== roundedX || y2 !== roundedY) && xystore.setState({ transform: [roundedX, roundedY, zoom2] }), onMoveEnd?.(event, { x: roundedX, y: roundedY, zoom: zoom2 });
      }),
      onNodeMouseEnter: useCallbackRef((event, node2) => {
        if (onNodeMouseEnter2) {
          onNodeMouseEnter2(event, node2);
          return;
        }
        onNodesChange([{
          id: node2.id,
          type: "replace",
          item: Base.setHovered(node2, !0)
        }]);
      }),
      onNodeMouseLeave: useCallbackRef((event, node2) => {
        if (onNodeMouseLeave2) {
          onNodeMouseLeave2(event, node2);
          return;
        }
        onNodesChange([{
          id: node2.id,
          type: "replace",
          item: Base.setHovered(node2, !1)
        }]);
      }),
      onEdgeMouseEnter: useCallbackRef((event, edge) => {
        if (onEdgeMouseEnter2) {
          onEdgeMouseEnter2(event, edge);
          return;
        }
        onEdgesChange([{
          id: edge.id,
          type: "replace",
          item: Base.setHovered(edge, !0)
        }]);
      }),
      onEdgeMouseLeave: useCallbackRef((event, edge) => {
        if (onEdgeMouseLeave2) {
          onEdgeMouseLeave2(event, edge);
          return;
        }
        onEdgesChange([{
          id: edge.id,
          type: "replace",
          item: Base.setHovered(edge, !1)
        }]);
      }),
      onNodeDoubleClick: stopPropagation,
      onEdgeDoubleClick: stopPropagation,
      ...props,
      children: [
        isBgWithPattern && /* @__PURE__ */ jsx(Background, { background }),
        onViewportResize && /* @__PURE__ */ jsx(ViewportResizeHanlder, { onViewportResize }),
        children2
      ]
    }
  );
}
const selectDimensions = ({ width, height }) => (width || 1) * (height || 1), ViewportResizeHanlder = ({
  onViewportResize
}) => {
  const square = useStore(selectDimensions);
  return useUpdateEffect(onViewportResize, [square]), null;
}, RelationshipsBrowserActorContext = createContext(null);
function useRelationshipsBrowserActor() {
  return nonNullable(useContext(RelationshipsBrowserActorContext), "No RelationshipsBrowserActorContext");
}
function useRelationshipsBrowserState(selector3, compare2 = shallowEqual$1) {
  const actor = useRelationshipsBrowserActor();
  return useSelector(actor, selector3, compare2);
}
function useRelationshipsBrowser() {
  const actor = useRelationshipsBrowserActor();
  return useMemo(() => ({
    actor,
    get rootElementId() {
      return `relationships-browser-${actor.sessionId.replaceAll(":", "_")}`;
    },
    getState: () => actor.getSnapshot().context,
    send: actor.send,
    updateView: (layouted) => {
      actor.getSnapshot().status === "active" && actor.send({
        type: "update.view",
        layouted
      });
    },
    changeScope: (scope) => {
      actor.send({
        type: "change.scope",
        scope
      });
    },
    navigateTo: (subject, fromNode) => {
      actor.send({
        type: "navigate.to",
        subject,
        fromNode
      });
    },
    fitDiagram: () => {
      actor.send({ type: "fitDiagram" });
    },
    close: () => {
      actor._parent ? actor._parent?.send({ type: "close", actorId: actor.id }) : actor.send({ type: "close" });
    }
  }), [actor]);
}
var graph, hasRequiredGraph;
function requireGraph() {
  if (hasRequiredGraph) return graph;
  hasRequiredGraph = 1;
  var DEFAULT_EDGE_NAME = "\0", GRAPH_NODE = "\0", EDGE_KEY_DELIM = "";
  class Graph {
    _isDirected = !0;
    _isMultigraph = !1;
    _isCompound = !1;
    // Label for the graph itself
    _label;
    // Defaults to be set when creating a new node
    _defaultNodeLabelFn = () => {
    };
    // Defaults to be set when creating a new edge
    _defaultEdgeLabelFn = () => {
    };
    // v -> label
    _nodes = {};
    // v -> edgeObj
    _in = {};
    // u -> v -> Number
    _preds = {};
    // v -> edgeObj
    _out = {};
    // v -> w -> Number
    _sucs = {};
    // e -> edgeObj
    _edgeObjs = {};
    // e -> label
    _edgeLabels = {};
    /* Number of nodes in the graph. Should only be changed by the implementation. */
    _nodeCount = 0;
    /* Number of edges in the graph. Should only be changed by the implementation. */
    _edgeCount = 0;
    _parent;
    _children;
    constructor(opts) {
      opts && (this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : !0, this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : !1, this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : !1), this._isCompound && (this._parent = {}, this._children = {}, this._children[GRAPH_NODE] = {});
    }
    /* === Graph functions ========= */
    /**
     * Whether graph was created with 'directed' flag set to true or not.
     */
    isDirected() {
      return this._isDirected;
    }
    /**
     * Whether graph was created with 'multigraph' flag set to true or not.
     */
    isMultigraph() {
      return this._isMultigraph;
    }
    /**
     * Whether graph was created with 'compound' flag set to true or not.
     */
    isCompound() {
      return this._isCompound;
    }
    /**
     * Sets the label of the graph.
     */
    setGraph(label2) {
      return this._label = label2, this;
    }
    /**
     * Gets the graph label.
     */
    graph() {
      return this._label;
    }
    /* === Node functions ========== */
    /**
     * Sets the default node label. If newDefault is a function, it will be
     * invoked ach time when setting a label for a node. Otherwise, this label
     * will be assigned as default label in case if no label was specified while
     * setting a node.
     * Complexity: O(1).
     */
    setDefaultNodeLabel(newDefault) {
      return this._defaultNodeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultNodeLabelFn = () => newDefault), this;
    }
    /**
     * Gets the number of nodes in the graph.
     * Complexity: O(1).
     */
    nodeCount() {
      return this._nodeCount;
    }
    /**
     * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
     * not included in list.
     * Complexity: O(1).
     */
    nodes() {
      return Object.keys(this._nodes);
    }
    /**
     * Gets list of nodes without in-edges.
     * Complexity: O(|V|).
     */
    sources() {
      var self2 = this;
      return this.nodes().filter((v2) => Object.keys(self2._in[v2]).length === 0);
    }
    /**
     * Gets list of nodes without out-edges.
     * Complexity: O(|V|).
     */
    sinks() {
      var self2 = this;
      return this.nodes().filter((v2) => Object.keys(self2._out[v2]).length === 0);
    }
    /**
     * Invokes setNode method for each node in names list.
     * Complexity: O(|names|).
     */
    setNodes(vs, value) {
      var args = arguments, self2 = this;
      return vs.forEach(function(v2) {
        args.length > 1 ? self2.setNode(v2, value) : self2.setNode(v2);
      }), this;
    }
    /**
     * Creates or updates the value for the node v in the graph. If label is supplied
     * it is set as the value for the node. If label is not supplied and the node was
     * created by this call then the default node label will be assigned.
     * Complexity: O(1).
     */
    setNode(v2, value) {
      return Object.hasOwn(this._nodes, v2) ? (arguments.length > 1 && (this._nodes[v2] = value), this) : (this._nodes[v2] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v2), this._isCompound && (this._parent[v2] = GRAPH_NODE, this._children[v2] = {}, this._children[GRAPH_NODE][v2] = !0), this._in[v2] = {}, this._preds[v2] = {}, this._out[v2] = {}, this._sucs[v2] = {}, ++this._nodeCount, this);
    }
    /**
     * Gets the label of node with specified name.
     * Complexity: O(|V|).
     */
    node(v2) {
      return this._nodes[v2];
    }
    /**
     * Detects whether graph has a node with specified name or not.
     */
    hasNode(v2) {
      return Object.hasOwn(this._nodes, v2);
    }
    /**
     * Remove the node with the name from the graph or do nothing if the node is not in
     * the graph. If the node was removed this function also removes any incident
     * edges.
     * Complexity: O(1).
     */
    removeNode(v2) {
      var self2 = this;
      if (Object.hasOwn(this._nodes, v2)) {
        var removeEdge = (e2) => self2.removeEdge(self2._edgeObjs[e2]);
        delete this._nodes[v2], this._isCompound && (this._removeFromParentsChildList(v2), delete this._parent[v2], this.children(v2).forEach(function(child) {
          self2.setParent(child);
        }), delete this._children[v2]), Object.keys(this._in[v2]).forEach(removeEdge), delete this._in[v2], delete this._preds[v2], Object.keys(this._out[v2]).forEach(removeEdge), delete this._out[v2], delete this._sucs[v2], --this._nodeCount;
      }
      return this;
    }
    /**
     * Sets node p as a parent for node v if it is defined, or removes the
     * parent for v if p is undefined. Method throws an exception in case of
     * invoking it in context of noncompound graph.
     * Average-case complexity: O(1).
     */
    setParent(v2, parent) {
      if (!this._isCompound)
        throw new Error("Cannot set parent in a non-compound graph");
      if (parent === void 0)
        parent = GRAPH_NODE;
      else {
        parent += "";
        for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor))
          if (ancestor === v2)
            throw new Error("Setting " + parent + " as parent of " + v2 + " would create a cycle");
        this.setNode(parent);
      }
      return this.setNode(v2), this._removeFromParentsChildList(v2), this._parent[v2] = parent, this._children[parent][v2] = !0, this;
    }
    _removeFromParentsChildList(v2) {
      delete this._children[this._parent[v2]][v2];
    }
    /**
     * Gets parent node for node v.
     * Complexity: O(1).
     */
    parent(v2) {
      if (this._isCompound) {
        var parent = this._parent[v2];
        if (parent !== GRAPH_NODE)
          return parent;
      }
    }
    /**
     * Gets list of direct children of node v.
     * Complexity: O(1).
     */
    children(v2 = GRAPH_NODE) {
      if (this._isCompound) {
        var children2 = this._children[v2];
        if (children2)
          return Object.keys(children2);
      } else {
        if (v2 === GRAPH_NODE)
          return this.nodes();
        if (this.hasNode(v2))
          return [];
      }
    }
    /**
     * Return all nodes that are predecessors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
    predecessors(v2) {
      var predsV = this._preds[v2];
      if (predsV)
        return Object.keys(predsV);
    }
    /**
     * Return all nodes that are successors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
    successors(v2) {
      var sucsV = this._sucs[v2];
      if (sucsV)
        return Object.keys(sucsV);
    }
    /**
     * Return all nodes that are predecessors or successors of the specified node or undefined if
     * node v is not in the graph.
     * Complexity: O(|V|).
     */
    neighbors(v2) {
      var preds = this.predecessors(v2);
      if (preds) {
        const union = new Set(preds);
        for (var succ of this.successors(v2))
          union.add(succ);
        return Array.from(union.values());
      }
    }
    isLeaf(v2) {
      var neighbors;
      return this.isDirected() ? neighbors = this.successors(v2) : neighbors = this.neighbors(v2), neighbors.length === 0;
    }
    /**
     * Creates new graph with nodes filtered via filter. Edges incident to rejected node
     * are also removed. In case of compound graph, if parent is rejected by filter,
     * than all its children are rejected too.
     * Average-case complexity: O(|E|+|V|).
     */
    filterNodes(filter2) {
      var copy = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      copy.setGraph(this.graph());
      var self2 = this;
      Object.entries(this._nodes).forEach(function([v2, value]) {
        filter2(v2) && copy.setNode(v2, value);
      }), Object.values(this._edgeObjs).forEach(function(e2) {
        copy.hasNode(e2.v) && copy.hasNode(e2.w) && copy.setEdge(e2, self2.edge(e2));
      });
      var parents = {};
      function findParent(v2) {
        var parent = self2.parent(v2);
        return parent === void 0 || copy.hasNode(parent) ? (parents[v2] = parent, parent) : parent in parents ? parents[parent] : findParent(parent);
      }
      return this._isCompound && copy.nodes().forEach((v2) => copy.setParent(v2, findParent(v2))), copy;
    }
    /* === Edge functions ========== */
    /**
     * Sets the default edge label or factory function. This label will be
     * assigned as default label in case if no label was specified while setting
     * an edge or this function will be invoked each time when setting an edge
     * with no label specified and returned value * will be used as a label for edge.
     * Complexity: O(1).
     */
    setDefaultEdgeLabel(newDefault) {
      return this._defaultEdgeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultEdgeLabelFn = () => newDefault), this;
    }
    /**
     * Gets the number of edges in the graph.
     * Complexity: O(1).
     */
    edgeCount() {
      return this._edgeCount;
    }
    /**
     * Gets edges of the graph. In case of compound graph subgraphs are not considered.
     * Complexity: O(|E|).
     */
    edges() {
      return Object.values(this._edgeObjs);
    }
    /**
     * Establish an edges path over the nodes in nodes list. If some edge is already
     * exists, it will update its label, otherwise it will create an edge between pair
     * of nodes with label provided or default label if no label provided.
     * Complexity: O(|nodes|).
     */
    setPath(vs, value) {
      var self2 = this, args = arguments;
      return vs.reduce(function(v2, w2) {
        return args.length > 1 ? self2.setEdge(v2, w2, value) : self2.setEdge(v2, w2), w2;
      }), this;
    }
    /**
     * Creates or updates the label for the edge (v, w) with the optionally supplied
     * name. If label is supplied it is set as the value for the edge. If label is not
     * supplied and the edge was created by this call then the default edge label will
     * be assigned. The name parameter is only useful with multigraphs.
     */
    setEdge() {
      var v2, w2, name, value, valueSpecified = !1, arg0 = arguments[0];
      typeof arg0 == "object" && arg0 !== null && "v" in arg0 ? (v2 = arg0.v, w2 = arg0.w, name = arg0.name, arguments.length === 2 && (value = arguments[1], valueSpecified = !0)) : (v2 = arg0, w2 = arguments[1], name = arguments[3], arguments.length > 2 && (value = arguments[2], valueSpecified = !0)), v2 = "" + v2, w2 = "" + w2, name !== void 0 && (name = "" + name);
      var e2 = edgeArgsToId(this._isDirected, v2, w2, name);
      if (Object.hasOwn(this._edgeLabels, e2))
        return valueSpecified && (this._edgeLabels[e2] = value), this;
      if (name !== void 0 && !this._isMultigraph)
        throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(v2), this.setNode(w2), this._edgeLabels[e2] = valueSpecified ? value : this._defaultEdgeLabelFn(v2, w2, name);
      var edgeObj = edgeArgsToObj(this._isDirected, v2, w2, name);
      return v2 = edgeObj.v, w2 = edgeObj.w, Object.freeze(edgeObj), this._edgeObjs[e2] = edgeObj, incrementOrInitEntry(this._preds[w2], v2), incrementOrInitEntry(this._sucs[v2], w2), this._in[w2][e2] = edgeObj, this._out[v2][e2] = edgeObj, this._edgeCount++, this;
    }
    /**
     * Gets the label for the specified edge.
     * Complexity: O(1).
     */
    edge(v2, w2, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
      return this._edgeLabels[e2];
    }
    /**
     * Gets the label for the specified edge and converts it to an object.
     * Complexity: O(1)
     */
    edgeAsObj() {
      const edge = this.edge(...arguments);
      return typeof edge != "object" ? { label: edge } : edge;
    }
    /**
     * Detects whether the graph contains specified edge or not. No subgraphs are considered.
     * Complexity: O(1).
     */
    hasEdge(v2, w2, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name);
      return Object.hasOwn(this._edgeLabels, e2);
    }
    /**
     * Removes the specified edge from the graph. No subgraphs are considered.
     * Complexity: O(1).
     */
    removeEdge(v2, w2, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v2, w2, name), edge = this._edgeObjs[e2];
      return edge && (v2 = edge.v, w2 = edge.w, delete this._edgeLabels[e2], delete this._edgeObjs[e2], decrementOrRemoveEntry(this._preds[w2], v2), decrementOrRemoveEntry(this._sucs[v2], w2), delete this._in[w2][e2], delete this._out[v2][e2], this._edgeCount--), this;
    }
    /**
     * Return all edges that point to the node v. Optionally filters those edges down to just those
     * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
    inEdges(v2, u) {
      var inV = this._in[v2];
      if (inV) {
        var edges = Object.values(inV);
        return u ? edges.filter((edge) => edge.v === u) : edges;
      }
    }
    /**
     * Return all edges that are pointed at by node v. Optionally filters those edges down to just
     * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
    outEdges(v2, w2) {
      var outV = this._out[v2];
      if (outV) {
        var edges = Object.values(outV);
        return w2 ? edges.filter((edge) => edge.w === w2) : edges;
      }
    }
    /**
     * Returns all edges to or from node v regardless of direction. Optionally filters those edges
     * down to just those between nodes v and w regardless of direction.
     * Complexity: O(|E|).
     */
    nodeEdges(v2, w2) {
      var inEdges = this.inEdges(v2, w2);
      if (inEdges)
        return inEdges.concat(this.outEdges(v2, w2));
    }
  }
  function incrementOrInitEntry(map, k) {
    map[k] ? map[k]++ : map[k] = 1;
  }
  function decrementOrRemoveEntry(map, k) {
    --map[k] || delete map[k];
  }
  function edgeArgsToId(isDirected, v_, w_, name) {
    var v2 = "" + v_, w2 = "" + w_;
    if (!isDirected && v2 > w2) {
      var tmp = v2;
      v2 = w2, w2 = tmp;
    }
    return v2 + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
  }
  function edgeArgsToObj(isDirected, v_, w_, name) {
    var v2 = "" + v_, w2 = "" + w_;
    if (!isDirected && v2 > w2) {
      var tmp = v2;
      v2 = w2, w2 = tmp;
    }
    var edgeObj = { v: v2, w: w2 };
    return name && (edgeObj.name = name), edgeObj;
  }
  function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
  }
  return graph = Graph, graph;
}
var version$1, hasRequiredVersion$1;
function requireVersion$1() {
  return hasRequiredVersion$1 || (hasRequiredVersion$1 = 1, version$1 = "2.2.4"), version$1;
}
var lib, hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, lib = {
    Graph: requireGraph(),
    version: requireVersion$1()
  }), lib;
}
var json, hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var Graph = requireGraph();
  json = {
    write,
    read
  };
  function write(g2) {
    var json2 = {
      options: {
        directed: g2.isDirected(),
        multigraph: g2.isMultigraph(),
        compound: g2.isCompound()
      },
      nodes: writeNodes(g2),
      edges: writeEdges(g2)
    };
    return g2.graph() !== void 0 && (json2.value = structuredClone(g2.graph())), json2;
  }
  function writeNodes(g2) {
    return g2.nodes().map(function(v2) {
      var nodeValue = g2.node(v2), parent = g2.parent(v2), node2 = { v: v2 };
      return nodeValue !== void 0 && (node2.value = nodeValue), parent !== void 0 && (node2.parent = parent), node2;
    });
  }
  function writeEdges(g2) {
    return g2.edges().map(function(e2) {
      var edgeValue = g2.edge(e2), edge = { v: e2.v, w: e2.w };
      return e2.name !== void 0 && (edge.name = e2.name), edgeValue !== void 0 && (edge.value = edgeValue), edge;
    });
  }
  function read(json2) {
    var g2 = new Graph(json2.options).setGraph(json2.value);
    return json2.nodes.forEach(function(entry) {
      g2.setNode(entry.v, entry.value), entry.parent && g2.setParent(entry.v, entry.parent);
    }), json2.edges.forEach(function(entry) {
      g2.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    }), g2;
  }
  return json;
}
var components_1, hasRequiredComponents;
function requireComponents() {
  if (hasRequiredComponents) return components_1;
  hasRequiredComponents = 1, components_1 = components;
  function components(g2) {
    var visited = {}, cmpts = [], cmpt;
    function dfs(v2) {
      Object.hasOwn(visited, v2) || (visited[v2] = !0, cmpt.push(v2), g2.successors(v2).forEach(dfs), g2.predecessors(v2).forEach(dfs));
    }
    return g2.nodes().forEach(function(v2) {
      cmpt = [], dfs(v2), cmpt.length && cmpts.push(cmpt);
    }), cmpts;
  }
  return components_1;
}
var priorityQueue, hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue) return priorityQueue;
  hasRequiredPriorityQueue = 1;
  class PriorityQueue {
    _arr = [];
    _keyIndices = {};
    /**
     * Returns the number of elements in the queue. Takes `O(1)` time.
     */
    size() {
      return this._arr.length;
    }
    /**
     * Returns the keys that are in the queue. Takes `O(n)` time.
     */
    keys() {
      return this._arr.map(function(x2) {
        return x2.key;
      });
    }
    /**
     * Returns `true` if **key** is in the queue and `false` if not.
     */
    has(key2) {
      return Object.hasOwn(this._keyIndices, key2);
    }
    /**
     * Returns the priority for **key**. If **key** is not present in the queue
     * then this function returns `undefined`. Takes `O(1)` time.
     *
     * @param {Object} key
     */
    priority(key2) {
      var index2 = this._keyIndices[key2];
      if (index2 !== void 0)
        return this._arr[index2].priority;
    }
    /**
     * Returns the key for the minimum element in this queue. If the queue is
     * empty this function throws an Error. Takes `O(1)` time.
     */
    min() {
      if (this.size() === 0)
        throw new Error("Queue underflow");
      return this._arr[0].key;
    }
    /**
     * Inserts a new key into the priority queue. If the key already exists in
     * the queue this function returns `false`; otherwise it will return `true`.
     * Takes `O(n)` time.
     *
     * @param {Object} key the key to add
     * @param {Number} priority the initial priority for the key
     */
    add(key2, priority) {
      var keyIndices = this._keyIndices;
      if (key2 = String(key2), !Object.hasOwn(keyIndices, key2)) {
        var arr = this._arr, index2 = arr.length;
        return keyIndices[key2] = index2, arr.push({ key: key2, priority }), this._decrease(index2), !0;
      }
      return !1;
    }
    /**
     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
     */
    removeMin() {
      this._swap(0, this._arr.length - 1);
      var min2 = this._arr.pop();
      return delete this._keyIndices[min2.key], this._heapify(0), min2.key;
    }
    /**
     * Decreases the priority for **key** to **priority**. If the new priority is
     * greater than the previous priority, this function will throw an Error.
     *
     * @param {Object} key the key for which to raise priority
     * @param {Number} priority the new priority for the key
     */
    decrease(key2, priority) {
      var index2 = this._keyIndices[key2];
      if (priority > this._arr[index2].priority)
        throw new Error("New priority is greater than current priority. Key: " + key2 + " Old: " + this._arr[index2].priority + " New: " + priority);
      this._arr[index2].priority = priority, this._decrease(index2);
    }
    _heapify(i2) {
      var arr = this._arr, l = 2 * i2, r2 = l + 1, largest = i2;
      l < arr.length && (largest = arr[l].priority < arr[largest].priority ? l : largest, r2 < arr.length && (largest = arr[r2].priority < arr[largest].priority ? r2 : largest), largest !== i2 && (this._swap(i2, largest), this._heapify(largest)));
    }
    _decrease(index2) {
      for (var arr = this._arr, priority = arr[index2].priority, parent; index2 !== 0 && (parent = index2 >> 1, !(arr[parent].priority < priority)); )
        this._swap(index2, parent), index2 = parent;
    }
    _swap(i2, j2) {
      var arr = this._arr, keyIndices = this._keyIndices, origArrI = arr[i2], origArrJ = arr[j2];
      arr[i2] = origArrJ, arr[j2] = origArrI, keyIndices[origArrJ.key] = i2, keyIndices[origArrI.key] = j2;
    }
  }
  return priorityQueue = PriorityQueue, priorityQueue;
}
var dijkstra_1, hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra_1;
  hasRequiredDijkstra = 1;
  var PriorityQueue = requirePriorityQueue();
  dijkstra_1 = dijkstra;
  var DEFAULT_WEIGHT_FUNC = () => 1;
  function dijkstra(g2, source, weightFn, edgeFn) {
    return runDijkstra(
      g2,
      String(source),
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v2) {
        return g2.outEdges(v2);
      }
    );
  }
  function runDijkstra(g2, source, weightFn, edgeFn) {
    var results = {}, pq = new PriorityQueue(), v2, vEntry, updateNeighbors = function(edge) {
      var w2 = edge.v !== v2 ? edge.v : edge.w, wEntry = results[w2], weight = weightFn(edge), distance2 = vEntry.distance + weight;
      if (weight < 0)
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
      distance2 < wEntry.distance && (wEntry.distance = distance2, wEntry.predecessor = v2, pq.decrease(w2, distance2));
    };
    for (g2.nodes().forEach(function(v3) {
      var distance2 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
      results[v3] = { distance: distance2 }, pq.add(v3, distance2);
    }); pq.size() > 0 && (v2 = pq.removeMin(), vEntry = results[v2], vEntry.distance !== Number.POSITIVE_INFINITY); )
      edgeFn(v2).forEach(updateNeighbors);
    return results;
  }
  return dijkstra_1;
}
var dijkstraAll_1, hasRequiredDijkstraAll;
function requireDijkstraAll() {
  if (hasRequiredDijkstraAll) return dijkstraAll_1;
  hasRequiredDijkstraAll = 1;
  var dijkstra = requireDijkstra();
  dijkstraAll_1 = dijkstraAll;
  function dijkstraAll(g2, weightFunc, edgeFunc) {
    return g2.nodes().reduce(function(acc, v2) {
      return acc[v2] = dijkstra(g2, v2, weightFunc, edgeFunc), acc;
    }, {});
  }
  return dijkstraAll_1;
}
var tarjan_1, hasRequiredTarjan;
function requireTarjan() {
  if (hasRequiredTarjan) return tarjan_1;
  hasRequiredTarjan = 1, tarjan_1 = tarjan;
  function tarjan(g2) {
    var index2 = 0, stack = [], visited = {}, results = [];
    function dfs(v2) {
      var entry = visited[v2] = {
        onStack: !0,
        lowlink: index2,
        index: index2++
      };
      if (stack.push(v2), g2.successors(v2).forEach(function(w3) {
        Object.hasOwn(visited, w3) ? visited[w3].onStack && (entry.lowlink = Math.min(entry.lowlink, visited[w3].index)) : (dfs(w3), entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink));
      }), entry.lowlink === entry.index) {
        var cmpt = [], w2;
        do
          w2 = stack.pop(), visited[w2].onStack = !1, cmpt.push(w2);
        while (v2 !== w2);
        results.push(cmpt);
      }
    }
    return g2.nodes().forEach(function(v2) {
      Object.hasOwn(visited, v2) || dfs(v2);
    }), results;
  }
  return tarjan_1;
}
var findCycles_1, hasRequiredFindCycles;
function requireFindCycles() {
  if (hasRequiredFindCycles) return findCycles_1;
  hasRequiredFindCycles = 1;
  var tarjan = requireTarjan();
  findCycles_1 = findCycles;
  function findCycles(g2) {
    return tarjan(g2).filter(function(cmpt) {
      return cmpt.length > 1 || cmpt.length === 1 && g2.hasEdge(cmpt[0], cmpt[0]);
    });
  }
  return findCycles_1;
}
var floydWarshall_1, hasRequiredFloydWarshall;
function requireFloydWarshall() {
  if (hasRequiredFloydWarshall) return floydWarshall_1;
  hasRequiredFloydWarshall = 1, floydWarshall_1 = floydWarshall;
  var DEFAULT_WEIGHT_FUNC = () => 1;
  function floydWarshall(g2, weightFn, edgeFn) {
    return runFloydWarshall(
      g2,
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v2) {
        return g2.outEdges(v2);
      }
    );
  }
  function runFloydWarshall(g2, weightFn, edgeFn) {
    var results = {}, nodes = g2.nodes();
    return nodes.forEach(function(v2) {
      results[v2] = {}, results[v2][v2] = { distance: 0 }, nodes.forEach(function(w2) {
        v2 !== w2 && (results[v2][w2] = { distance: Number.POSITIVE_INFINITY });
      }), edgeFn(v2).forEach(function(edge) {
        var w2 = edge.v === v2 ? edge.w : edge.v, d2 = weightFn(edge);
        results[v2][w2] = { distance: d2, predecessor: v2 };
      });
    }), nodes.forEach(function(k) {
      var rowK = results[k];
      nodes.forEach(function(i2) {
        var rowI = results[i2];
        nodes.forEach(function(j2) {
          var ik = rowI[k], kj = rowK[j2], ij = rowI[j2], altDistance = ik.distance + kj.distance;
          altDistance < ij.distance && (ij.distance = altDistance, ij.predecessor = kj.predecessor);
        });
      });
    }), results;
  }
  return floydWarshall_1;
}
var topsort_1, hasRequiredTopsort;
function requireTopsort() {
  if (hasRequiredTopsort) return topsort_1;
  hasRequiredTopsort = 1;
  function topsort(g2) {
    var visited = {}, stack = {}, results = [];
    function visit(node2) {
      if (Object.hasOwn(stack, node2))
        throw new CycleException();
      Object.hasOwn(visited, node2) || (stack[node2] = !0, visited[node2] = !0, g2.predecessors(node2).forEach(visit), delete stack[node2], results.push(node2));
    }
    if (g2.sinks().forEach(visit), Object.keys(visited).length !== g2.nodeCount())
      throw new CycleException();
    return results;
  }
  class CycleException extends Error {
    constructor() {
      super(...arguments);
    }
  }
  return topsort_1 = topsort, topsort.CycleException = CycleException, topsort_1;
}
var isAcyclic_1, hasRequiredIsAcyclic;
function requireIsAcyclic() {
  if (hasRequiredIsAcyclic) return isAcyclic_1;
  hasRequiredIsAcyclic = 1;
  var topsort = requireTopsort();
  isAcyclic_1 = isAcyclic;
  function isAcyclic(g2) {
    try {
      topsort(g2);
    } catch (e2) {
      if (e2 instanceof topsort.CycleException)
        return !1;
      throw e2;
    }
    return !0;
  }
  return isAcyclic_1;
}
var dfs_1, hasRequiredDfs;
function requireDfs() {
  if (hasRequiredDfs) return dfs_1;
  hasRequiredDfs = 1, dfs_1 = dfs;
  function dfs(g2, vs, order) {
    Array.isArray(vs) || (vs = [vs]);
    var navigation = g2.isDirected() ? (v2) => g2.successors(v2) : (v2) => g2.neighbors(v2), orderFunc = order === "post" ? postOrderDfs : preOrderDfs, acc = [], visited = {};
    return vs.forEach((v2) => {
      if (!g2.hasNode(v2))
        throw new Error("Graph does not have node: " + v2);
      orderFunc(v2, navigation, visited, acc);
    }), acc;
  }
  function postOrderDfs(v2, navigation, visited, acc) {
    for (var stack = [[v2, !1]]; stack.length > 0; ) {
      var curr = stack.pop();
      curr[1] ? acc.push(curr[0]) : Object.hasOwn(visited, curr[0]) || (visited[curr[0]] = !0, stack.push([curr[0], !0]), forEachRight(navigation(curr[0]), (w2) => stack.push([w2, !1])));
    }
  }
  function preOrderDfs(v2, navigation, visited, acc) {
    for (var stack = [v2]; stack.length > 0; ) {
      var curr = stack.pop();
      Object.hasOwn(visited, curr) || (visited[curr] = !0, acc.push(curr), forEachRight(navigation(curr), (w2) => stack.push(w2)));
    }
  }
  function forEachRight(array2, iteratee) {
    for (var length = array2.length; length--; )
      iteratee(array2[length], length, array2);
    return array2;
  }
  return dfs_1;
}
var postorder_1, hasRequiredPostorder;
function requirePostorder() {
  if (hasRequiredPostorder) return postorder_1;
  hasRequiredPostorder = 1;
  var dfs = requireDfs();
  postorder_1 = postorder;
  function postorder(g2, vs) {
    return dfs(g2, vs, "post");
  }
  return postorder_1;
}
var preorder_1, hasRequiredPreorder;
function requirePreorder() {
  if (hasRequiredPreorder) return preorder_1;
  hasRequiredPreorder = 1;
  var dfs = requireDfs();
  preorder_1 = preorder;
  function preorder(g2, vs) {
    return dfs(g2, vs, "pre");
  }
  return preorder_1;
}
var prim_1, hasRequiredPrim;
function requirePrim() {
  if (hasRequiredPrim) return prim_1;
  hasRequiredPrim = 1;
  var Graph = requireGraph(), PriorityQueue = requirePriorityQueue();
  prim_1 = prim;
  function prim(g2, weightFunc) {
    var result = new Graph(), parents = {}, pq = new PriorityQueue(), v2;
    function updateNeighbors(edge) {
      var w2 = edge.v === v2 ? edge.w : edge.v, pri = pq.priority(w2);
      if (pri !== void 0) {
        var edgeWeight = weightFunc(edge);
        edgeWeight < pri && (parents[w2] = v2, pq.decrease(w2, edgeWeight));
      }
    }
    if (g2.nodeCount() === 0)
      return result;
    g2.nodes().forEach(function(v3) {
      pq.add(v3, Number.POSITIVE_INFINITY), result.setNode(v3);
    }), pq.decrease(g2.nodes()[0], 0);
    for (var init2 = !1; pq.size() > 0; ) {
      if (v2 = pq.removeMin(), Object.hasOwn(parents, v2))
        result.setEdge(v2, parents[v2]);
      else {
        if (init2)
          throw new Error("Input graph is not connected: " + g2);
        init2 = !0;
      }
      g2.nodeEdges(v2).forEach(updateNeighbors);
    }
    return result;
  }
  return prim_1;
}
var alg, hasRequiredAlg;
function requireAlg() {
  return hasRequiredAlg || (hasRequiredAlg = 1, alg = {
    components: requireComponents(),
    dijkstra: requireDijkstra(),
    dijkstraAll: requireDijkstraAll(),
    findCycles: requireFindCycles(),
    floydWarshall: requireFloydWarshall(),
    isAcyclic: requireIsAcyclic(),
    postorder: requirePostorder(),
    preorder: requirePreorder(),
    prim: requirePrim(),
    tarjan: requireTarjan(),
    topsort: requireTopsort()
  }), alg;
}
var graphlib, hasRequiredGraphlib;
function requireGraphlib() {
  if (hasRequiredGraphlib) return graphlib;
  hasRequiredGraphlib = 1;
  var lib2 = requireLib();
  return graphlib = {
    Graph: lib2.Graph,
    json: requireJson(),
    alg: requireAlg(),
    version: lib2.version
  }, graphlib;
}
var list, hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  class List {
    constructor() {
      let sentinel = {};
      sentinel._next = sentinel._prev = sentinel, this._sentinel = sentinel;
    }
    dequeue() {
      let sentinel = this._sentinel, entry = sentinel._prev;
      if (entry !== sentinel)
        return unlink(entry), entry;
    }
    enqueue(entry) {
      let sentinel = this._sentinel;
      entry._prev && entry._next && unlink(entry), entry._next = sentinel._next, sentinel._next._prev = entry, sentinel._next = entry, entry._prev = sentinel;
    }
    toString() {
      let strs = [], sentinel = this._sentinel, curr = sentinel._prev;
      for (; curr !== sentinel; )
        strs.push(JSON.stringify(curr, filterOutLinks)), curr = curr._prev;
      return "[" + strs.join(", ") + "]";
    }
  }
  function unlink(entry) {
    entry._prev._next = entry._next, entry._next._prev = entry._prev, delete entry._next, delete entry._prev;
  }
  function filterOutLinks(k, v2) {
    if (k !== "_next" && k !== "_prev")
      return v2;
  }
  return list = List, list;
}
var greedyFas, hasRequiredGreedyFas;
function requireGreedyFas() {
  if (hasRequiredGreedyFas) return greedyFas;
  hasRequiredGreedyFas = 1;
  let Graph = requireGraphlib().Graph, List = requireList();
  greedyFas = greedyFAS;
  let DEFAULT_WEIGHT_FN = () => 1;
  function greedyFAS(g2, weightFn) {
    if (g2.nodeCount() <= 1)
      return [];
    let state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
    return doGreedyFAS(state.graph, state.buckets, state.zeroIdx).flatMap((e2) => g2.outEdges(e2.v, e2.w));
  }
  function doGreedyFAS(g2, buckets, zeroIdx) {
    let results = [], sources = buckets[buckets.length - 1], sinks = buckets[0], entry;
    for (; g2.nodeCount(); ) {
      for (; entry = sinks.dequeue(); )
        removeNode(g2, buckets, zeroIdx, entry);
      for (; entry = sources.dequeue(); )
        removeNode(g2, buckets, zeroIdx, entry);
      if (g2.nodeCount()) {
        for (let i2 = buckets.length - 2; i2 > 0; --i2)
          if (entry = buckets[i2].dequeue(), entry) {
            results = results.concat(removeNode(g2, buckets, zeroIdx, entry, !0));
            break;
          }
      }
    }
    return results;
  }
  function removeNode(g2, buckets, zeroIdx, entry, collectPredecessors) {
    let results = collectPredecessors ? [] : void 0;
    return g2.inEdges(entry.v).forEach((edge) => {
      let weight = g2.edge(edge), uEntry = g2.node(edge.v);
      collectPredecessors && results.push({ v: edge.v, w: edge.w }), uEntry.out -= weight, assignBucket(buckets, zeroIdx, uEntry);
    }), g2.outEdges(entry.v).forEach((edge) => {
      let weight = g2.edge(edge), w2 = edge.w, wEntry = g2.node(w2);
      wEntry.in -= weight, assignBucket(buckets, zeroIdx, wEntry);
    }), g2.removeNode(entry.v), results;
  }
  function buildState(g2, weightFn) {
    let fasGraph = new Graph(), maxIn = 0, maxOut = 0;
    g2.nodes().forEach((v2) => {
      fasGraph.setNode(v2, { v: v2, in: 0, out: 0 });
    }), g2.edges().forEach((e2) => {
      let prevWeight = fasGraph.edge(e2.v, e2.w) || 0, weight = weightFn(e2), edgeWeight = prevWeight + weight;
      fasGraph.setEdge(e2.v, e2.w, edgeWeight), maxOut = Math.max(maxOut, fasGraph.node(e2.v).out += weight), maxIn = Math.max(maxIn, fasGraph.node(e2.w).in += weight);
    });
    let buckets = range(maxOut + maxIn + 3).map(() => new List()), zeroIdx = maxIn + 1;
    return fasGraph.nodes().forEach((v2) => {
      assignBucket(buckets, zeroIdx, fasGraph.node(v2));
    }), { graph: fasGraph, buckets, zeroIdx };
  }
  function assignBucket(buckets, zeroIdx, entry) {
    entry.out ? entry.in ? buckets[entry.out - entry.in + zeroIdx].enqueue(entry) : buckets[buckets.length - 1].enqueue(entry) : buckets[0].enqueue(entry);
  }
  function range(limit) {
    const range2 = [];
    for (let i2 = 0; i2 < limit; i2++)
      range2.push(i2);
    return range2;
  }
  return greedyFas;
}
var util$1, hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  let Graph = requireGraphlib().Graph;
  util$1 = {
    addBorderNode,
    addDummyNode,
    applyWithChunking,
    asNonCompoundGraph,
    buildLayerMatrix,
    intersectRect,
    mapValues: mapValues2,
    maxRank,
    normalizeRanks,
    notime,
    partition,
    pick,
    predecessorWeights,
    range,
    removeEmptyRanks,
    simplify,
    successorWeights,
    time: time2,
    uniqueId,
    zipObject
  };
  function addDummyNode(g2, type, attrs, name) {
    for (var v2 = name; g2.hasNode(v2); )
      v2 = uniqueId(name);
    return attrs.dummy = type, g2.setNode(v2, attrs), v2;
  }
  function simplify(g2) {
    let simplified = new Graph().setGraph(g2.graph());
    return g2.nodes().forEach((v2) => simplified.setNode(v2, g2.node(v2))), g2.edges().forEach((e2) => {
      let simpleLabel = simplified.edge(e2.v, e2.w) || { weight: 0, minlen: 1 }, label2 = g2.edge(e2);
      simplified.setEdge(e2.v, e2.w, {
        weight: simpleLabel.weight + label2.weight,
        minlen: Math.max(simpleLabel.minlen, label2.minlen)
      });
    }), simplified;
  }
  function asNonCompoundGraph(g2) {
    let simplified = new Graph({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
    return g2.nodes().forEach((v2) => {
      g2.children(v2).length || simplified.setNode(v2, g2.node(v2));
    }), g2.edges().forEach((e2) => {
      simplified.setEdge(e2, g2.edge(e2));
    }), simplified;
  }
  function successorWeights(g2) {
    let weightMap = g2.nodes().map((v2) => {
      let sucs = {};
      return g2.outEdges(v2).forEach((e2) => {
        sucs[e2.w] = (sucs[e2.w] || 0) + g2.edge(e2).weight;
      }), sucs;
    });
    return zipObject(g2.nodes(), weightMap);
  }
  function predecessorWeights(g2) {
    let weightMap = g2.nodes().map((v2) => {
      let preds = {};
      return g2.inEdges(v2).forEach((e2) => {
        preds[e2.v] = (preds[e2.v] || 0) + g2.edge(e2).weight;
      }), preds;
    });
    return zipObject(g2.nodes(), weightMap);
  }
  function intersectRect(rect, point2) {
    let x2 = rect.x, y2 = rect.y, dx = point2.x - x2, dy = point2.y - y2, w2 = rect.width / 2, h2 = rect.height / 2;
    if (!dx && !dy)
      throw new Error("Not possible to find intersection inside of the rectangle");
    let sx, sy;
    return Math.abs(dy) * w2 > Math.abs(dx) * h2 ? (dy < 0 && (h2 = -h2), sx = h2 * dx / dy, sy = h2) : (dx < 0 && (w2 = -w2), sx = w2, sy = w2 * dy / dx), { x: x2 + sx, y: y2 + sy };
  }
  function buildLayerMatrix(g2) {
    let layering = range(maxRank(g2) + 1).map(() => []);
    return g2.nodes().forEach((v2) => {
      let node2 = g2.node(v2), rank = node2.rank;
      rank !== void 0 && (layering[rank][node2.order] = v2);
    }), layering;
  }
  function normalizeRanks(g2) {
    let nodeRanks = g2.nodes().map((v2) => {
      let rank = g2.node(v2).rank;
      return rank === void 0 ? Number.MAX_VALUE : rank;
    }), min2 = applyWithChunking(Math.min, nodeRanks);
    g2.nodes().forEach((v2) => {
      let node2 = g2.node(v2);
      Object.hasOwn(node2, "rank") && (node2.rank -= min2);
    });
  }
  function removeEmptyRanks(g2) {
    let nodeRanks = g2.nodes().map((v2) => g2.node(v2).rank), offset2 = applyWithChunking(Math.min, nodeRanks), layers = [];
    g2.nodes().forEach((v2) => {
      let rank = g2.node(v2).rank - offset2;
      layers[rank] || (layers[rank] = []), layers[rank].push(v2);
    });
    let delta = 0, nodeRankFactor = g2.graph().nodeRankFactor;
    Array.from(layers).forEach((vs, i2) => {
      vs === void 0 && i2 % nodeRankFactor !== 0 ? --delta : vs !== void 0 && delta && vs.forEach((v2) => g2.node(v2).rank += delta);
    });
  }
  function addBorderNode(g2, prefix, rank, order) {
    let node2 = {
      width: 0,
      height: 0
    };
    return arguments.length >= 4 && (node2.rank = rank, node2.order = order), addDummyNode(g2, "border", node2, prefix);
  }
  function splitToChunks(array2, chunkSize = CHUNKING_THRESHOLD) {
    const chunks = [];
    for (let i2 = 0; i2 < array2.length; i2 += chunkSize) {
      const chunk = array2.slice(i2, i2 + chunkSize);
      chunks.push(chunk);
    }
    return chunks;
  }
  const CHUNKING_THRESHOLD = 65535;
  function applyWithChunking(fn, argsArray) {
    if (argsArray.length > CHUNKING_THRESHOLD) {
      const chunks = splitToChunks(argsArray);
      return fn.apply(null, chunks.map((chunk) => fn.apply(null, chunk)));
    } else
      return fn.apply(null, argsArray);
  }
  function maxRank(g2) {
    const nodeRanks = g2.nodes().map((v2) => {
      let rank = g2.node(v2).rank;
      return rank === void 0 ? Number.MIN_VALUE : rank;
    });
    return applyWithChunking(Math.max, nodeRanks);
  }
  function partition(collection, fn) {
    let result = { lhs: [], rhs: [] };
    return collection.forEach((value) => {
      fn(value) ? result.lhs.push(value) : result.rhs.push(value);
    }), result;
  }
  function time2(name, fn) {
    let start2 = Date.now();
    try {
      return fn();
    } finally {
      console.log(name + " time: " + (Date.now() - start2) + "ms");
    }
  }
  function notime(name, fn) {
    return fn();
  }
  let idCounter2 = 0;
  function uniqueId(prefix) {
    var id2 = ++idCounter2;
    return prefix + ("" + id2);
  }
  function range(start2, limit, step = 1) {
    limit == null && (limit = start2, start2 = 0);
    let endCon = (i2) => i2 < limit;
    step < 0 && (endCon = (i2) => limit < i2);
    const range2 = [];
    for (let i2 = start2; endCon(i2); i2 += step)
      range2.push(i2);
    return range2;
  }
  function pick(source, keys2) {
    const dest = {};
    for (const key2 of keys2)
      source[key2] !== void 0 && (dest[key2] = source[key2]);
    return dest;
  }
  function mapValues2(obj, funcOrProp) {
    let func = funcOrProp;
    return typeof funcOrProp == "string" && (func = (val) => val[funcOrProp]), Object.entries(obj).reduce((acc, [k, v2]) => (acc[k] = func(v2, k), acc), {});
  }
  function zipObject(props, values2) {
    return props.reduce((acc, key2, i2) => (acc[key2] = values2[i2], acc), {});
  }
  return util$1;
}
var acyclic, hasRequiredAcyclic;
function requireAcyclic() {
  if (hasRequiredAcyclic) return acyclic;
  hasRequiredAcyclic = 1;
  let greedyFAS = requireGreedyFas(), uniqueId = requireUtil$1().uniqueId;
  acyclic = {
    run,
    undo: undo2
  };
  function run(g2) {
    (g2.graph().acyclicer === "greedy" ? greedyFAS(g2, weightFn(g2)) : dfsFAS(g2)).forEach((e2) => {
      let label2 = g2.edge(e2);
      g2.removeEdge(e2), label2.forwardName = e2.name, label2.reversed = !0, g2.setEdge(e2.w, e2.v, label2, uniqueId("rev"));
    });
    function weightFn(g3) {
      return (e2) => g3.edge(e2).weight;
    }
  }
  function dfsFAS(g2) {
    let fas = [], stack = {}, visited = {};
    function dfs(v2) {
      Object.hasOwn(visited, v2) || (visited[v2] = !0, stack[v2] = !0, g2.outEdges(v2).forEach((e2) => {
        Object.hasOwn(stack, e2.w) ? fas.push(e2) : dfs(e2.w);
      }), delete stack[v2]);
    }
    return g2.nodes().forEach(dfs), fas;
  }
  function undo2(g2) {
    g2.edges().forEach((e2) => {
      let label2 = g2.edge(e2);
      if (label2.reversed) {
        g2.removeEdge(e2);
        let forwardName = label2.forwardName;
        delete label2.reversed, delete label2.forwardName, g2.setEdge(e2.w, e2.v, label2, forwardName);
      }
    });
  }
  return acyclic;
}
var normalize, hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize) return normalize;
  hasRequiredNormalize = 1;
  let util2 = requireUtil$1();
  normalize = {
    run,
    undo: undo2
  };
  function run(g2) {
    g2.graph().dummyChains = [], g2.edges().forEach((edge) => normalizeEdge(g2, edge));
  }
  function normalizeEdge(g2, e2) {
    let v2 = e2.v, vRank = g2.node(v2).rank, w2 = e2.w, wRank = g2.node(w2).rank, name = e2.name, edgeLabel2 = g2.edge(e2), labelRank = edgeLabel2.labelRank;
    if (wRank === vRank + 1) return;
    g2.removeEdge(e2);
    let dummy, attrs, i2;
    for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank)
      edgeLabel2.points = [], attrs = {
        width: 0,
        height: 0,
        edgeLabel: edgeLabel2,
        edgeObj: e2,
        rank: vRank
      }, dummy = util2.addDummyNode(g2, "edge", attrs, "_d"), vRank === labelRank && (attrs.width = edgeLabel2.width, attrs.height = edgeLabel2.height, attrs.dummy = "edge-label", attrs.labelpos = edgeLabel2.labelpos), g2.setEdge(v2, dummy, { weight: edgeLabel2.weight }, name), i2 === 0 && g2.graph().dummyChains.push(dummy), v2 = dummy;
    g2.setEdge(v2, w2, { weight: edgeLabel2.weight }, name);
  }
  function undo2(g2) {
    g2.graph().dummyChains.forEach((v2) => {
      let node2 = g2.node(v2), origLabel = node2.edgeLabel, w2;
      for (g2.setEdge(node2.edgeObj, origLabel); node2.dummy; )
        w2 = g2.successors(v2)[0], g2.removeNode(v2), origLabel.points.push({ x: node2.x, y: node2.y }), node2.dummy === "edge-label" && (origLabel.x = node2.x, origLabel.y = node2.y, origLabel.width = node2.width, origLabel.height = node2.height), v2 = w2, node2 = g2.node(v2);
    });
  }
  return normalize;
}
var util, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  const { applyWithChunking } = requireUtil$1();
  util = {
    longestPath,
    slack
  };
  function longestPath(g2) {
    var visited = {};
    function dfs(v2) {
      var label2 = g2.node(v2);
      if (Object.hasOwn(visited, v2))
        return label2.rank;
      visited[v2] = !0;
      let outEdgesMinLens = g2.outEdges(v2).map((e2) => e2 == null ? Number.POSITIVE_INFINITY : dfs(e2.w) - g2.edge(e2).minlen);
      var rank = applyWithChunking(Math.min, outEdgesMinLens);
      return rank === Number.POSITIVE_INFINITY && (rank = 0), label2.rank = rank;
    }
    g2.sources().forEach(dfs);
  }
  function slack(g2, e2) {
    return g2.node(e2.w).rank - g2.node(e2.v).rank - g2.edge(e2).minlen;
  }
  return util;
}
var feasibleTree_1, hasRequiredFeasibleTree;
function requireFeasibleTree() {
  if (hasRequiredFeasibleTree) return feasibleTree_1;
  hasRequiredFeasibleTree = 1;
  var Graph = requireGraphlib().Graph, slack = requireUtil().slack;
  feasibleTree_1 = feasibleTree;
  function feasibleTree(g2) {
    var t2 = new Graph({ directed: !1 }), start2 = g2.nodes()[0], size2 = g2.nodeCount();
    t2.setNode(start2, {});
    for (var edge, delta; tightTree(t2, g2) < size2; )
      edge = findMinSlackEdge(t2, g2), delta = t2.hasNode(edge.v) ? slack(g2, edge) : -slack(g2, edge), shiftRanks(t2, g2, delta);
    return t2;
  }
  function tightTree(t2, g2) {
    function dfs(v2) {
      g2.nodeEdges(v2).forEach((e2) => {
        var edgeV = e2.v, w2 = v2 === edgeV ? e2.w : edgeV;
        !t2.hasNode(w2) && !slack(g2, e2) && (t2.setNode(w2, {}), t2.setEdge(v2, w2, {}), dfs(w2));
      });
    }
    return t2.nodes().forEach(dfs), t2.nodeCount();
  }
  function findMinSlackEdge(t2, g2) {
    return g2.edges().reduce((acc, edge) => {
      let edgeSlack = Number.POSITIVE_INFINITY;
      return t2.hasNode(edge.v) !== t2.hasNode(edge.w) && (edgeSlack = slack(g2, edge)), edgeSlack < acc[0] ? [edgeSlack, edge] : acc;
    }, [Number.POSITIVE_INFINITY, null])[1];
  }
  function shiftRanks(t2, g2, delta) {
    t2.nodes().forEach((v2) => g2.node(v2).rank += delta);
  }
  return feasibleTree_1;
}
var networkSimplex_1, hasRequiredNetworkSimplex;
function requireNetworkSimplex() {
  if (hasRequiredNetworkSimplex) return networkSimplex_1;
  hasRequiredNetworkSimplex = 1;
  var feasibleTree = requireFeasibleTree(), slack = requireUtil().slack, initRank = requireUtil().longestPath, preorder = requireGraphlib().alg.preorder, postorder = requireGraphlib().alg.postorder, simplify = requireUtil$1().simplify;
  networkSimplex_1 = networkSimplex, networkSimplex.initLowLimValues = initLowLimValues, networkSimplex.initCutValues = initCutValues, networkSimplex.calcCutValue = calcCutValue, networkSimplex.leaveEdge = leaveEdge, networkSimplex.enterEdge = enterEdge, networkSimplex.exchangeEdges = exchangeEdges;
  function networkSimplex(g2) {
    g2 = simplify(g2), initRank(g2);
    var t2 = feasibleTree(g2);
    initLowLimValues(t2), initCutValues(t2, g2);
    for (var e2, f2; e2 = leaveEdge(t2); )
      f2 = enterEdge(t2, g2, e2), exchangeEdges(t2, g2, e2, f2);
  }
  function initCutValues(t2, g2) {
    var vs = postorder(t2, t2.nodes());
    vs = vs.slice(0, vs.length - 1), vs.forEach((v2) => assignCutValue(t2, g2, v2));
  }
  function assignCutValue(t2, g2, child) {
    var childLab = t2.node(child), parent = childLab.parent;
    t2.edge(child, parent).cutvalue = calcCutValue(t2, g2, child);
  }
  function calcCutValue(t2, g2, child) {
    var childLab = t2.node(child), parent = childLab.parent, childIsTail = !0, graphEdge = g2.edge(child, parent), cutValue = 0;
    return graphEdge || (childIsTail = !1, graphEdge = g2.edge(parent, child)), cutValue = graphEdge.weight, g2.nodeEdges(child).forEach((e2) => {
      var isOutEdge = e2.v === child, other = isOutEdge ? e2.w : e2.v;
      if (other !== parent) {
        var pointsToHead = isOutEdge === childIsTail, otherWeight = g2.edge(e2).weight;
        if (cutValue += pointsToHead ? otherWeight : -otherWeight, isTreeEdge(t2, child, other)) {
          var otherCutValue = t2.edge(child, other).cutvalue;
          cutValue += pointsToHead ? -otherCutValue : otherCutValue;
        }
      }
    }), cutValue;
  }
  function initLowLimValues(tree, root2) {
    arguments.length < 2 && (root2 = tree.nodes()[0]), dfsAssignLowLim(tree, {}, 1, root2);
  }
  function dfsAssignLowLim(tree, visited, nextLim, v2, parent) {
    var low = nextLim, label2 = tree.node(v2);
    return visited[v2] = !0, tree.neighbors(v2).forEach((w2) => {
      Object.hasOwn(visited, w2) || (nextLim = dfsAssignLowLim(tree, visited, nextLim, w2, v2));
    }), label2.low = low, label2.lim = nextLim++, parent ? label2.parent = parent : delete label2.parent, nextLim;
  }
  function leaveEdge(tree) {
    return tree.edges().find((e2) => tree.edge(e2).cutvalue < 0);
  }
  function enterEdge(t2, g2, edge) {
    var v2 = edge.v, w2 = edge.w;
    g2.hasEdge(v2, w2) || (v2 = edge.w, w2 = edge.v);
    var vLabel = t2.node(v2), wLabel = t2.node(w2), tailLabel = vLabel, flip2 = !1;
    vLabel.lim > wLabel.lim && (tailLabel = wLabel, flip2 = !0);
    var candidates = g2.edges().filter((edge2) => flip2 === isDescendant2(t2, t2.node(edge2.v), tailLabel) && flip2 !== isDescendant2(t2, t2.node(edge2.w), tailLabel));
    return candidates.reduce((acc, edge2) => slack(g2, edge2) < slack(g2, acc) ? edge2 : acc);
  }
  function exchangeEdges(t2, g2, e2, f2) {
    var v2 = e2.v, w2 = e2.w;
    t2.removeEdge(v2, w2), t2.setEdge(f2.v, f2.w, {}), initLowLimValues(t2), initCutValues(t2, g2), updateRanks(t2, g2);
  }
  function updateRanks(t2, g2) {
    var root2 = t2.nodes().find((v2) => !g2.node(v2).parent), vs = preorder(t2, root2);
    vs = vs.slice(1), vs.forEach((v2) => {
      var parent = t2.node(v2).parent, edge = g2.edge(v2, parent), flipped = !1;
      edge || (edge = g2.edge(parent, v2), flipped = !0), g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
    });
  }
  function isTreeEdge(tree, u, v2) {
    return tree.hasEdge(u, v2);
  }
  function isDescendant2(tree, vLabel, rootLabel) {
    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
  }
  return networkSimplex_1;
}
var rank_1, hasRequiredRank;
function requireRank() {
  if (hasRequiredRank) return rank_1;
  hasRequiredRank = 1;
  var rankUtil = requireUtil(), longestPath = rankUtil.longestPath, feasibleTree = requireFeasibleTree(), networkSimplex = requireNetworkSimplex();
  rank_1 = rank;
  function rank(g2) {
    var ranker = g2.graph().ranker;
    if (ranker instanceof Function)
      return ranker(g2);
    switch (g2.graph().ranker) {
      case "network-simplex":
        networkSimplexRanker(g2);
        break;
      case "tight-tree":
        tightTreeRanker(g2);
        break;
      case "longest-path":
        longestPathRanker(g2);
        break;
      case "none":
        break;
      default:
        networkSimplexRanker(g2);
    }
  }
  var longestPathRanker = longestPath;
  function tightTreeRanker(g2) {
    longestPath(g2), feasibleTree(g2);
  }
  function networkSimplexRanker(g2) {
    networkSimplex(g2);
  }
  return rank_1;
}
var parentDummyChains_1, hasRequiredParentDummyChains;
function requireParentDummyChains() {
  if (hasRequiredParentDummyChains) return parentDummyChains_1;
  hasRequiredParentDummyChains = 1, parentDummyChains_1 = parentDummyChains;
  function parentDummyChains(g2) {
    let postorderNums = postorder(g2);
    g2.graph().dummyChains.forEach((v2) => {
      let node2 = g2.node(v2), edgeObj = node2.edgeObj, pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w), path = pathData.path, lca = pathData.lca, pathIdx = 0, pathV = path[pathIdx], ascending2 = !0;
      for (; v2 !== edgeObj.w; ) {
        if (node2 = g2.node(v2), ascending2) {
          for (; (pathV = path[pathIdx]) !== lca && g2.node(pathV).maxRank < node2.rank; )
            pathIdx++;
          pathV === lca && (ascending2 = !1);
        }
        if (!ascending2) {
          for (; pathIdx < path.length - 1 && g2.node(pathV = path[pathIdx + 1]).minRank <= node2.rank; )
            pathIdx++;
          pathV = path[pathIdx];
        }
        g2.setParent(v2, pathV), v2 = g2.successors(v2)[0];
      }
    });
  }
  function findPath(g2, postorderNums, v2, w2) {
    let vPath = [], wPath = [], low = Math.min(postorderNums[v2].low, postorderNums[w2].low), lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim), parent, lca;
    parent = v2;
    do
      parent = g2.parent(parent), vPath.push(parent);
    while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    for (lca = parent, parent = w2; (parent = g2.parent(parent)) !== lca; )
      wPath.push(parent);
    return { path: vPath.concat(wPath.reverse()), lca };
  }
  function postorder(g2) {
    let result = {}, lim = 0;
    function dfs(v2) {
      let low = lim;
      g2.children(v2).forEach(dfs), result[v2] = { low, lim: lim++ };
    }
    return g2.children().forEach(dfs), result;
  }
  return parentDummyChains_1;
}
var nestingGraph, hasRequiredNestingGraph;
function requireNestingGraph() {
  if (hasRequiredNestingGraph) return nestingGraph;
  hasRequiredNestingGraph = 1;
  let util2 = requireUtil$1();
  nestingGraph = {
    run,
    cleanup
  };
  function run(g2) {
    let root2 = util2.addDummyNode(g2, "root", {}, "_root"), depths = treeDepths(g2), depthsArr = Object.values(depths), height = util2.applyWithChunking(Math.max, depthsArr) - 1, nodeSep = 2 * height + 1;
    g2.graph().nestingRoot = root2, g2.edges().forEach((e2) => g2.edge(e2).minlen *= nodeSep);
    let weight = sumWeights(g2) + 1;
    g2.children().forEach((child) => dfs(g2, root2, nodeSep, weight, height, depths, child)), g2.graph().nodeRankFactor = nodeSep;
  }
  function dfs(g2, root2, nodeSep, weight, height, depths, v2) {
    let children2 = g2.children(v2);
    if (!children2.length) {
      v2 !== root2 && g2.setEdge(root2, v2, { weight: 0, minlen: nodeSep });
      return;
    }
    let top = util2.addBorderNode(g2, "_bt"), bottom = util2.addBorderNode(g2, "_bb"), label2 = g2.node(v2);
    g2.setParent(top, v2), label2.borderTop = top, g2.setParent(bottom, v2), label2.borderBottom = bottom, children2.forEach((child) => {
      dfs(g2, root2, nodeSep, weight, height, depths, child);
      let childNode = g2.node(child), childTop = childNode.borderTop ? childNode.borderTop : child, childBottom = childNode.borderBottom ? childNode.borderBottom : child, thisWeight = childNode.borderTop ? weight : 2 * weight, minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
      g2.setEdge(top, childTop, {
        weight: thisWeight,
        minlen,
        nestingEdge: !0
      }), g2.setEdge(childBottom, bottom, {
        weight: thisWeight,
        minlen,
        nestingEdge: !0
      });
    }), g2.parent(v2) || g2.setEdge(root2, top, { weight: 0, minlen: height + depths[v2] });
  }
  function treeDepths(g2) {
    var depths = {};
    function dfs2(v2, depth) {
      var children2 = g2.children(v2);
      children2 && children2.length && children2.forEach((child) => dfs2(child, depth + 1)), depths[v2] = depth;
    }
    return g2.children().forEach((v2) => dfs2(v2, 1)), depths;
  }
  function sumWeights(g2) {
    return g2.edges().reduce((acc, e2) => acc + g2.edge(e2).weight, 0);
  }
  function cleanup(g2) {
    var graphLabel = g2.graph();
    g2.removeNode(graphLabel.nestingRoot), delete graphLabel.nestingRoot, g2.edges().forEach((e2) => {
      var edge = g2.edge(e2);
      edge.nestingEdge && g2.removeEdge(e2);
    });
  }
  return nestingGraph;
}
var addBorderSegments_1, hasRequiredAddBorderSegments;
function requireAddBorderSegments() {
  if (hasRequiredAddBorderSegments) return addBorderSegments_1;
  hasRequiredAddBorderSegments = 1;
  let util2 = requireUtil$1();
  addBorderSegments_1 = addBorderSegments;
  function addBorderSegments(g2) {
    function dfs(v2) {
      let children2 = g2.children(v2), node2 = g2.node(v2);
      if (children2.length && children2.forEach(dfs), Object.hasOwn(node2, "minRank")) {
        node2.borderLeft = [], node2.borderRight = [];
        for (let rank = node2.minRank, maxRank = node2.maxRank + 1; rank < maxRank; ++rank)
          addBorderNode(g2, "borderLeft", "_bl", v2, node2, rank), addBorderNode(g2, "borderRight", "_br", v2, node2, rank);
      }
    }
    g2.children().forEach(dfs);
  }
  function addBorderNode(g2, prop, prefix, sg, sgNode, rank) {
    let label2 = { width: 0, height: 0, rank, borderType: prop }, prev = sgNode[prop][rank - 1], curr = util2.addDummyNode(g2, "border", label2, prefix);
    sgNode[prop][rank] = curr, g2.setParent(curr, sg), prev && g2.setEdge(prev, curr, { weight: 1 });
  }
  return addBorderSegments_1;
}
var coordinateSystem, hasRequiredCoordinateSystem;
function requireCoordinateSystem() {
  if (hasRequiredCoordinateSystem) return coordinateSystem;
  hasRequiredCoordinateSystem = 1, coordinateSystem = {
    adjust: adjust2,
    undo: undo2
  };
  function adjust2(g2) {
    let rankDir = g2.graph().rankdir.toLowerCase();
    (rankDir === "lr" || rankDir === "rl") && swapWidthHeight(g2);
  }
  function undo2(g2) {
    let rankDir = g2.graph().rankdir.toLowerCase();
    (rankDir === "bt" || rankDir === "rl") && reverseY(g2), (rankDir === "lr" || rankDir === "rl") && (swapXY(g2), swapWidthHeight(g2));
  }
  function swapWidthHeight(g2) {
    g2.nodes().forEach((v2) => swapWidthHeightOne(g2.node(v2))), g2.edges().forEach((e2) => swapWidthHeightOne(g2.edge(e2)));
  }
  function swapWidthHeightOne(attrs) {
    let w2 = attrs.width;
    attrs.width = attrs.height, attrs.height = w2;
  }
  function reverseY(g2) {
    g2.nodes().forEach((v2) => reverseYOne(g2.node(v2))), g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      edge.points.forEach(reverseYOne), Object.hasOwn(edge, "y") && reverseYOne(edge);
    });
  }
  function reverseYOne(attrs) {
    attrs.y = -attrs.y;
  }
  function swapXY(g2) {
    g2.nodes().forEach((v2) => swapXYOne(g2.node(v2))), g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      edge.points.forEach(swapXYOne), Object.hasOwn(edge, "x") && swapXYOne(edge);
    });
  }
  function swapXYOne(attrs) {
    let x2 = attrs.x;
    attrs.x = attrs.y, attrs.y = x2;
  }
  return coordinateSystem;
}
var initOrder_1, hasRequiredInitOrder;
function requireInitOrder() {
  if (hasRequiredInitOrder) return initOrder_1;
  hasRequiredInitOrder = 1;
  let util2 = requireUtil$1();
  initOrder_1 = initOrder;
  function initOrder(g2) {
    let visited = {}, simpleNodes = g2.nodes().filter((v2) => !g2.children(v2).length), simpleNodesRanks = simpleNodes.map((v2) => g2.node(v2).rank), maxRank = util2.applyWithChunking(Math.max, simpleNodesRanks), layers = util2.range(maxRank + 1).map(() => []);
    function dfs(v2) {
      if (visited[v2]) return;
      visited[v2] = !0;
      let node2 = g2.node(v2);
      layers[node2.rank].push(v2), g2.successors(v2).forEach(dfs);
    }
    return simpleNodes.sort((a2, b2) => g2.node(a2).rank - g2.node(b2).rank).forEach(dfs), layers;
  }
  return initOrder_1;
}
var crossCount_1, hasRequiredCrossCount;
function requireCrossCount() {
  if (hasRequiredCrossCount) return crossCount_1;
  hasRequiredCrossCount = 1;
  let zipObject = requireUtil$1().zipObject;
  crossCount_1 = crossCount;
  function crossCount(g2, layering) {
    let cc2 = 0;
    for (let i2 = 1; i2 < layering.length; ++i2)
      cc2 += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
    return cc2;
  }
  function twoLayerCrossCount(g2, northLayer, southLayer) {
    let southPos = zipObject(southLayer, southLayer.map((v2, i2) => i2)), southEntries = northLayer.flatMap((v2) => g2.outEdges(v2).map((e2) => ({ pos: southPos[e2.w], weight: g2.edge(e2).weight })).sort((a2, b2) => a2.pos - b2.pos)), firstIndex = 1;
    for (; firstIndex < southLayer.length; ) firstIndex <<= 1;
    let treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    let tree = new Array(treeSize).fill(0), cc2 = 0;
    return southEntries.forEach((entry) => {
      let index2 = entry.pos + firstIndex;
      tree[index2] += entry.weight;
      let weightSum = 0;
      for (; index2 > 0; )
        index2 % 2 && (weightSum += tree[index2 + 1]), index2 = index2 - 1 >> 1, tree[index2] += entry.weight;
      cc2 += entry.weight * weightSum;
    }), cc2;
  }
  return crossCount_1;
}
var barycenter_1, hasRequiredBarycenter;
function requireBarycenter() {
  if (hasRequiredBarycenter) return barycenter_1;
  hasRequiredBarycenter = 1, barycenter_1 = barycenter;
  function barycenter(g2, movable = []) {
    return movable.map((v2) => {
      let inV = g2.inEdges(v2);
      if (inV.length) {
        let result = inV.reduce((acc, e2) => {
          let edge = g2.edge(e2), nodeU = g2.node(e2.v);
          return {
            sum: acc.sum + edge.weight * nodeU.order,
            weight: acc.weight + edge.weight
          };
        }, { sum: 0, weight: 0 });
        return {
          v: v2,
          barycenter: result.sum / result.weight,
          weight: result.weight
        };
      } else
        return { v: v2 };
    });
  }
  return barycenter_1;
}
var resolveConflicts_1, hasRequiredResolveConflicts;
function requireResolveConflicts() {
  if (hasRequiredResolveConflicts) return resolveConflicts_1;
  hasRequiredResolveConflicts = 1;
  let util2 = requireUtil$1();
  resolveConflicts_1 = resolveConflicts;
  function resolveConflicts(entries, cg) {
    let mappedEntries = {};
    entries.forEach((entry, i2) => {
      let tmp = mappedEntries[entry.v] = {
        indegree: 0,
        in: [],
        out: [],
        vs: [entry.v],
        i: i2
      };
      entry.barycenter !== void 0 && (tmp.barycenter = entry.barycenter, tmp.weight = entry.weight);
    }), cg.edges().forEach((e2) => {
      let entryV = mappedEntries[e2.v], entryW = mappedEntries[e2.w];
      entryV !== void 0 && entryW !== void 0 && (entryW.indegree++, entryV.out.push(mappedEntries[e2.w]));
    });
    let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
    return doResolveConflicts(sourceSet);
  }
  function doResolveConflicts(sourceSet) {
    let entries = [];
    function handleIn(vEntry) {
      return (uEntry) => {
        uEntry.merged || (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) && mergeEntries(vEntry, uEntry);
      };
    }
    function handleOut(vEntry) {
      return (wEntry) => {
        wEntry.in.push(vEntry), --wEntry.indegree === 0 && sourceSet.push(wEntry);
      };
    }
    for (; sourceSet.length; ) {
      let entry = sourceSet.pop();
      entries.push(entry), entry.in.reverse().forEach(handleIn(entry)), entry.out.forEach(handleOut(entry));
    }
    return entries.filter((entry) => !entry.merged).map((entry) => util2.pick(entry, ["vs", "i", "barycenter", "weight"]));
  }
  function mergeEntries(target, source) {
    let sum = 0, weight = 0;
    target.weight && (sum += target.barycenter * target.weight, weight += target.weight), source.weight && (sum += source.barycenter * source.weight, weight += source.weight), target.vs = source.vs.concat(target.vs), target.barycenter = sum / weight, target.weight = weight, target.i = Math.min(source.i, target.i), source.merged = !0;
  }
  return resolveConflicts_1;
}
var sort_1, hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  let util2 = requireUtil$1();
  sort_1 = sort;
  function sort(entries, biasRight) {
    let parts = util2.partition(entries, (entry) => Object.hasOwn(entry, "barycenter")), sortable = parts.lhs, unsortable = parts.rhs.sort((a2, b2) => b2.i - a2.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
    sortable.sort(compareWithBias(!!biasRight)), vsIndex = consumeUnsortable(vs, unsortable, vsIndex), sortable.forEach((entry) => {
      vsIndex += entry.vs.length, vs.push(entry.vs), sum += entry.barycenter * entry.weight, weight += entry.weight, vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    let result = { vs: vs.flat(!0) };
    return weight && (result.barycenter = sum / weight, result.weight = weight), result;
  }
  function consumeUnsortable(vs, unsortable, index2) {
    let last;
    for (; unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index2; )
      unsortable.pop(), vs.push(last.vs), index2++;
    return index2;
  }
  function compareWithBias(bias) {
    return (entryV, entryW) => entryV.barycenter < entryW.barycenter ? -1 : entryV.barycenter > entryW.barycenter ? 1 : bias ? entryW.i - entryV.i : entryV.i - entryW.i;
  }
  return sort_1;
}
var sortSubgraph_1, hasRequiredSortSubgraph;
function requireSortSubgraph() {
  if (hasRequiredSortSubgraph) return sortSubgraph_1;
  hasRequiredSortSubgraph = 1;
  let barycenter = requireBarycenter(), resolveConflicts = requireResolveConflicts(), sort = requireSort();
  sortSubgraph_1 = sortSubgraph;
  function sortSubgraph(g2, v2, cg, biasRight) {
    let movable = g2.children(v2), node2 = g2.node(v2), bl = node2 ? node2.borderLeft : void 0, br = node2 ? node2.borderRight : void 0, subgraphs = {};
    bl && (movable = movable.filter((w2) => w2 !== bl && w2 !== br));
    let barycenters = barycenter(g2, movable);
    barycenters.forEach((entry) => {
      if (g2.children(entry.v).length) {
        let subgraphResult = sortSubgraph(g2, entry.v, cg, biasRight);
        subgraphs[entry.v] = subgraphResult, Object.hasOwn(subgraphResult, "barycenter") && mergeBarycenters(entry, subgraphResult);
      }
    });
    let entries = resolveConflicts(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    let result = sort(entries, biasRight);
    if (bl && (result.vs = [bl, result.vs, br].flat(!0), g2.predecessors(bl).length)) {
      let blPred = g2.node(g2.predecessors(bl)[0]), brPred = g2.node(g2.predecessors(br)[0]);
      Object.hasOwn(result, "barycenter") || (result.barycenter = 0, result.weight = 0), result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2), result.weight += 2;
    }
    return result;
  }
  function expandSubgraphs(entries, subgraphs) {
    entries.forEach((entry) => {
      entry.vs = entry.vs.flatMap((v2) => subgraphs[v2] ? subgraphs[v2].vs : v2);
    });
  }
  function mergeBarycenters(target, other) {
    target.barycenter !== void 0 ? (target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight), target.weight += other.weight) : (target.barycenter = other.barycenter, target.weight = other.weight);
  }
  return sortSubgraph_1;
}
var buildLayerGraph_1, hasRequiredBuildLayerGraph;
function requireBuildLayerGraph() {
  if (hasRequiredBuildLayerGraph) return buildLayerGraph_1;
  hasRequiredBuildLayerGraph = 1;
  let Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  buildLayerGraph_1 = buildLayerGraph;
  function buildLayerGraph(g2, rank, relationship, nodesWithRank) {
    nodesWithRank || (nodesWithRank = g2.nodes());
    let root2 = createRootNode(g2), result = new Graph({ compound: !0 }).setGraph({ root: root2 }).setDefaultNodeLabel((v2) => g2.node(v2));
    return nodesWithRank.forEach((v2) => {
      let node2 = g2.node(v2), parent = g2.parent(v2);
      (node2.rank === rank || node2.minRank <= rank && rank <= node2.maxRank) && (result.setNode(v2), result.setParent(v2, parent || root2), g2[relationship](v2).forEach((e2) => {
        let u = e2.v === v2 ? e2.w : e2.v, edge = result.edge(u, v2), weight = edge !== void 0 ? edge.weight : 0;
        result.setEdge(u, v2, { weight: g2.edge(e2).weight + weight });
      }), Object.hasOwn(node2, "minRank") && result.setNode(v2, {
        borderLeft: node2.borderLeft[rank],
        borderRight: node2.borderRight[rank]
      }));
    }), result;
  }
  function createRootNode(g2) {
    for (var v2; g2.hasNode(v2 = util2.uniqueId("_root")); ) ;
    return v2;
  }
  return buildLayerGraph_1;
}
var addSubgraphConstraints_1, hasRequiredAddSubgraphConstraints;
function requireAddSubgraphConstraints() {
  if (hasRequiredAddSubgraphConstraints) return addSubgraphConstraints_1;
  hasRequiredAddSubgraphConstraints = 1, addSubgraphConstraints_1 = addSubgraphConstraints;
  function addSubgraphConstraints(g2, cg, vs) {
    let prev = {}, rootPrev;
    vs.forEach((v2) => {
      let child = g2.parent(v2), parent, prevChild;
      for (; child; ) {
        if (parent = g2.parent(child), parent ? (prevChild = prev[parent], prev[parent] = child) : (prevChild = rootPrev, rootPrev = child), prevChild && prevChild !== child) {
          cg.setEdge(prevChild, child);
          return;
        }
        child = parent;
      }
    });
  }
  return addSubgraphConstraints_1;
}
var order_1, hasRequiredOrder;
function requireOrder() {
  if (hasRequiredOrder) return order_1;
  hasRequiredOrder = 1;
  let initOrder = requireInitOrder(), crossCount = requireCrossCount(), sortSubgraph = requireSortSubgraph(), buildLayerGraph = requireBuildLayerGraph(), addSubgraphConstraints = requireAddSubgraphConstraints(), Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  order_1 = order;
  function order(g2, opts) {
    if (opts && typeof opts.customOrder == "function") {
      opts.customOrder(g2, order);
      return;
    }
    let maxRank = util2.maxRank(g2), downLayerGraphs = buildLayerGraphs(g2, util2.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g2, util2.range(maxRank - 1, -1, -1), "outEdges"), layering = initOrder(g2);
    if (assignOrder(g2, layering), opts && opts.disableOptimalOrderHeuristic)
      return;
    let bestCC = Number.POSITIVE_INFINITY, best;
    for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
      sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2), layering = util2.buildLayerMatrix(g2);
      let cc2 = crossCount(g2, layering);
      cc2 < bestCC && (lastBest = 0, best = Object.assign({}, layering), bestCC = cc2);
    }
    assignOrder(g2, best);
  }
  function buildLayerGraphs(g2, ranks, relationship) {
    const nodesByRank = /* @__PURE__ */ new Map(), addNodeToRank = (rank, node2) => {
      nodesByRank.has(rank) || nodesByRank.set(rank, []), nodesByRank.get(rank).push(node2);
    };
    for (const v2 of g2.nodes()) {
      const node2 = g2.node(v2);
      if (typeof node2.rank == "number" && addNodeToRank(node2.rank, v2), typeof node2.minRank == "number" && typeof node2.maxRank == "number")
        for (let r2 = node2.minRank; r2 <= node2.maxRank; r2++)
          r2 !== node2.rank && addNodeToRank(r2, v2);
    }
    return ranks.map(function(rank) {
      return buildLayerGraph(g2, rank, relationship, nodesByRank.get(rank) || []);
    });
  }
  function sweepLayerGraphs(layerGraphs, biasRight) {
    let cg = new Graph();
    layerGraphs.forEach(function(lg) {
      let root2 = lg.graph().root, sorted = sortSubgraph(lg, root2, cg, biasRight);
      sorted.vs.forEach((v2, i2) => lg.node(v2).order = i2), addSubgraphConstraints(lg, cg, sorted.vs);
    });
  }
  function assignOrder(g2, layering) {
    Object.values(layering).forEach((layer) => layer.forEach((v2, i2) => g2.node(v2).order = i2));
  }
  return order_1;
}
var bk, hasRequiredBk;
function requireBk() {
  if (hasRequiredBk) return bk;
  hasRequiredBk = 1;
  let Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  bk = {
    positionX,
    findType1Conflicts,
    findType2Conflicts,
    addConflict,
    hasConflict,
    verticalAlignment,
    horizontalCompaction,
    alignCoordinates,
    findSmallestWidthAlignment,
    balance
  };
  function findType1Conflicts(g2, layering) {
    let conflicts = {};
    function visitLayer(prevLayer, layer) {
      let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
      return layer.forEach((v2, i2) => {
        let w2 = findOtherInnerSegmentNode(g2, v2), k1 = w2 ? g2.node(w2).order : prevLayerLength;
        (w2 || v2 === lastNode) && (layer.slice(scanPos, i2 + 1).forEach((scanNode) => {
          g2.predecessors(scanNode).forEach((u) => {
            let uLabel = g2.node(u), uPos = uLabel.order;
            (uPos < k0 || k1 < uPos) && !(uLabel.dummy && g2.node(scanNode).dummy) && addConflict(conflicts, u, scanNode);
          });
        }), scanPos = i2 + 1, k0 = k1);
      }), layer;
    }
    return layering.length && layering.reduce(visitLayer), conflicts;
  }
  function findType2Conflicts(g2, layering) {
    let conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
      let v2;
      util2.range(southPos, southEnd).forEach((i2) => {
        v2 = south[i2], g2.node(v2).dummy && g2.predecessors(v2).forEach((u) => {
          let uNode = g2.node(u);
          uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder) && addConflict(conflicts, u, v2);
        });
      });
    }
    function visitLayer(north, south) {
      let prevNorthPos = -1, nextNorthPos, southPos = 0;
      return south.forEach((v2, southLookahead) => {
        if (g2.node(v2).dummy === "border") {
          let predecessors = g2.predecessors(v2);
          predecessors.length && (nextNorthPos = g2.node(predecessors[0]).order, scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos), southPos = southLookahead, prevNorthPos = nextNorthPos);
        }
        scan(south, southPos, south.length, nextNorthPos, north.length);
      }), south;
    }
    return layering.length && layering.reduce(visitLayer), conflicts;
  }
  function findOtherInnerSegmentNode(g2, v2) {
    if (g2.node(v2).dummy)
      return g2.predecessors(v2).find((u) => g2.node(u).dummy);
  }
  function addConflict(conflicts, v2, w2) {
    if (v2 > w2) {
      let tmp = v2;
      v2 = w2, w2 = tmp;
    }
    let conflictsV = conflicts[v2];
    conflictsV || (conflicts[v2] = conflictsV = {}), conflictsV[w2] = !0;
  }
  function hasConflict(conflicts, v2, w2) {
    if (v2 > w2) {
      let tmp = v2;
      v2 = w2, w2 = tmp;
    }
    return !!conflicts[v2] && Object.hasOwn(conflicts[v2], w2);
  }
  function verticalAlignment(g2, layering, conflicts, neighborFn) {
    let root2 = {}, align = {}, pos = {};
    return layering.forEach((layer) => {
      layer.forEach((v2, order) => {
        root2[v2] = v2, align[v2] = v2, pos[v2] = order;
      });
    }), layering.forEach((layer) => {
      let prevIdx = -1;
      layer.forEach((v2) => {
        let ws = neighborFn(v2);
        if (ws.length) {
          ws = ws.sort((a2, b2) => pos[a2] - pos[b2]);
          let mp = (ws.length - 1) / 2;
          for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
            let w2 = ws[i2];
            align[v2] === v2 && prevIdx < pos[w2] && !hasConflict(conflicts, v2, w2) && (align[w2] = v2, align[v2] = root2[v2] = root2[w2], prevIdx = pos[w2]);
          }
        }
      });
    }), { root: root2, align };
  }
  function horizontalCompaction(g2, layering, root2, align, reverseSep) {
    let xs = {}, blockG = buildBlockGraph(g2, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
    function iterate(setXsFunc, nextNodesFunc) {
      let stack = blockG.nodes(), elem = stack.pop(), visited = {};
      for (; elem; )
        visited[elem] ? setXsFunc(elem) : (visited[elem] = !0, stack.push(elem), stack = stack.concat(nextNodesFunc(elem))), elem = stack.pop();
    }
    function pass1(elem) {
      xs[elem] = blockG.inEdges(elem).reduce((acc, e2) => Math.max(acc, xs[e2.v] + blockG.edge(e2)), 0);
    }
    function pass2(elem) {
      let min2 = blockG.outEdges(elem).reduce((acc, e2) => Math.min(acc, xs[e2.w] - blockG.edge(e2)), Number.POSITIVE_INFINITY), node2 = g2.node(elem);
      min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType && (xs[elem] = Math.max(xs[elem], min2));
    }
    return iterate(pass1, blockG.predecessors.bind(blockG)), iterate(pass2, blockG.successors.bind(blockG)), Object.keys(align).forEach((v2) => xs[v2] = xs[root2[v2]]), xs;
  }
  function buildBlockGraph(g2, layering, root2, reverseSep) {
    let blockGraph = new Graph(), graphLabel = g2.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
    return layering.forEach((layer) => {
      let u;
      layer.forEach((v2) => {
        let vRoot = root2[v2];
        if (blockGraph.setNode(vRoot), u) {
          var uRoot = root2[u], prevMax = blockGraph.edge(uRoot, vRoot);
          blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u), prevMax || 0));
        }
        u = v2;
      });
    }), blockGraph;
  }
  function findSmallestWidthAlignment(g2, xss) {
    return Object.values(xss).reduce((currentMinAndXs, xs) => {
      let max2 = Number.NEGATIVE_INFINITY, min2 = Number.POSITIVE_INFINITY;
      Object.entries(xs).forEach(([v2, x2]) => {
        let halfWidth = width(g2, v2) / 2;
        max2 = Math.max(x2 + halfWidth, max2), min2 = Math.min(x2 - halfWidth, min2);
      });
      const newMin = max2 - min2;
      return newMin < currentMinAndXs[0] && (currentMinAndXs = [newMin, xs]), currentMinAndXs;
    }, [Number.POSITIVE_INFINITY, null])[1];
  }
  function alignCoordinates(xss, alignTo) {
    let alignToVals = Object.values(alignTo), alignToMin = util2.applyWithChunking(Math.min, alignToVals), alignToMax = util2.applyWithChunking(Math.max, alignToVals);
    ["u", "d"].forEach((vert) => {
      ["l", "r"].forEach((horiz) => {
        let alignment = vert + horiz, xs = xss[alignment];
        if (xs === alignTo) return;
        let xsVals = Object.values(xs), delta = alignToMin - util2.applyWithChunking(Math.min, xsVals);
        horiz !== "l" && (delta = alignToMax - util2.applyWithChunking(Math.max, xsVals)), delta && (xss[alignment] = util2.mapValues(xs, (x2) => x2 + delta));
      });
    });
  }
  function balance(xss, align) {
    return util2.mapValues(xss.ul, (num, v2) => {
      if (align)
        return xss[align.toLowerCase()][v2];
      {
        let xs = Object.values(xss).map((xs2) => xs2[v2]).sort((a2, b2) => a2 - b2);
        return (xs[1] + xs[2]) / 2;
      }
    });
  }
  function positionX(g2) {
    let layering = util2.buildLayerMatrix(g2), conflicts = Object.assign(
      findType1Conflicts(g2, layering),
      findType2Conflicts(g2, layering)
    ), xss = {}, adjustedLayering;
    ["u", "d"].forEach((vert) => {
      adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse(), ["l", "r"].forEach((horiz) => {
        horiz === "r" && (adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse()));
        let neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2), align = verticalAlignment(g2, adjustedLayering, conflicts, neighborFn), xs = horizontalCompaction(
          g2,
          adjustedLayering,
          align.root,
          align.align,
          horiz === "r"
        );
        horiz === "r" && (xs = util2.mapValues(xs, (x2) => -x2)), xss[vert + horiz] = xs;
      });
    });
    let smallestWidth = findSmallestWidthAlignment(g2, xss);
    return alignCoordinates(xss, smallestWidth), balance(xss, g2.graph().align);
  }
  function sep(nodeSep, edgeSep, reverseSep) {
    return (g2, v2, w2) => {
      let vLabel = g2.node(v2), wLabel = g2.node(w2), sum = 0, delta;
      if (sum += vLabel.width / 2, Object.hasOwn(vLabel, "labelpos"))
        switch (vLabel.labelpos.toLowerCase()) {
          case "l":
            delta = -vLabel.width / 2;
            break;
          case "r":
            delta = vLabel.width / 2;
            break;
        }
      if (delta && (sum += reverseSep ? delta : -delta), delta = 0, sum += (vLabel.dummy ? edgeSep : nodeSep) / 2, sum += (wLabel.dummy ? edgeSep : nodeSep) / 2, sum += wLabel.width / 2, Object.hasOwn(wLabel, "labelpos"))
        switch (wLabel.labelpos.toLowerCase()) {
          case "l":
            delta = wLabel.width / 2;
            break;
          case "r":
            delta = -wLabel.width / 2;
            break;
        }
      return delta && (sum += reverseSep ? delta : -delta), delta = 0, sum;
    };
  }
  function width(g2, v2) {
    return g2.node(v2).width;
  }
  return bk;
}
var position_1, hasRequiredPosition;
function requirePosition() {
  if (hasRequiredPosition) return position_1;
  hasRequiredPosition = 1;
  let util2 = requireUtil$1(), positionX = requireBk().positionX;
  position_1 = position;
  function position(g2) {
    g2 = util2.asNonCompoundGraph(g2), positionY(g2), Object.entries(positionX(g2)).forEach(([v2, x2]) => g2.node(v2).x = x2);
  }
  function positionY(g2) {
    let layering = util2.buildLayerMatrix(g2), rankSep = g2.graph().ranksep, prevY = 0;
    layering.forEach((layer) => {
      const maxHeight = layer.reduce((acc, v2) => {
        const height = g2.node(v2).height;
        return acc > height ? acc : height;
      }, 0);
      layer.forEach((v2) => g2.node(v2).y = prevY + maxHeight / 2), prevY += maxHeight + rankSep;
    });
  }
  return position_1;
}
var layout_1, hasRequiredLayout;
function requireLayout() {
  if (hasRequiredLayout) return layout_1;
  hasRequiredLayout = 1;
  let acyclic2 = requireAcyclic(), normalize2 = requireNormalize(), rank = requireRank(), normalizeRanks = requireUtil$1().normalizeRanks, parentDummyChains = requireParentDummyChains(), removeEmptyRanks = requireUtil$1().removeEmptyRanks, nestingGraph2 = requireNestingGraph(), addBorderSegments = requireAddBorderSegments(), coordinateSystem2 = requireCoordinateSystem(), order = requireOrder(), position = requirePosition(), util2 = requireUtil$1(), Graph = requireGraphlib().Graph;
  layout_1 = layout2;
  function layout2(g2, opts) {
    let time2 = opts && opts.debugTiming ? util2.time : util2.notime;
    time2("layout", () => {
      let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g2));
      time2("  runLayout", () => runLayout(layoutGraph, time2, opts)), time2("  updateInputGraph", () => updateInputGraph(g2, layoutGraph));
    });
  }
  function runLayout(g2, time2, opts) {
    time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g2)), time2("    removeSelfEdges", () => removeSelfEdges(g2)), time2("    acyclic", () => acyclic2.run(g2)), time2("    nestingGraph.run", () => nestingGraph2.run(g2)), time2("    rank", () => rank(util2.asNonCompoundGraph(g2))), time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g2)), time2("    removeEmptyRanks", () => removeEmptyRanks(g2)), time2("    nestingGraph.cleanup", () => nestingGraph2.cleanup(g2)), time2("    normalizeRanks", () => normalizeRanks(g2)), time2("    assignRankMinMax", () => assignRankMinMax(g2)), time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g2)), time2("    normalize.run", () => normalize2.run(g2)), time2("    parentDummyChains", () => parentDummyChains(g2)), time2("    addBorderSegments", () => addBorderSegments(g2)), time2("    order", () => order(g2, opts)), time2("    insertSelfEdges", () => insertSelfEdges(g2)), time2("    adjustCoordinateSystem", () => coordinateSystem2.adjust(g2)), time2("    position", () => position(g2)), time2("    positionSelfEdges", () => positionSelfEdges(g2)), time2("    removeBorderNodes", () => removeBorderNodes(g2)), time2("    normalize.undo", () => normalize2.undo(g2)), time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g2)), time2("    undoCoordinateSystem", () => coordinateSystem2.undo(g2)), time2("    translateGraph", () => translateGraph(g2)), time2("    assignNodeIntersects", () => assignNodeIntersects(g2)), time2("    reversePoints", () => reversePointsForReversedEdges(g2)), time2("    acyclic.undo", () => acyclic2.undo(g2));
  }
  function updateInputGraph(inputGraph, layoutGraph) {
    inputGraph.nodes().forEach((v2) => {
      let inputLabel = inputGraph.node(v2), layoutLabel = layoutGraph.node(v2);
      inputLabel && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y, inputLabel.rank = layoutLabel.rank, layoutGraph.children(v2).length && (inputLabel.width = layoutLabel.width, inputLabel.height = layoutLabel.height));
    }), inputGraph.edges().forEach((e2) => {
      let inputLabel = inputGraph.edge(e2), layoutLabel = layoutGraph.edge(e2);
      inputLabel.points = layoutLabel.points, Object.hasOwn(layoutLabel, "x") && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y);
    }), inputGraph.graph().width = layoutGraph.graph().width, inputGraph.graph().height = layoutGraph.graph().height;
  }
  let graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, graphAttrs = ["acyclicer", "ranker", "rankdir", "align"], nodeNumAttrs = ["width", "height", "rank"], nodeDefaults = { width: 0, height: 0 }, edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"], edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r"
  }, edgeAttrs = ["labelpos"];
  function buildLayoutGraph(inputGraph) {
    let g2 = new Graph({ multigraph: !0, compound: !0 }), graph2 = canonicalize(inputGraph.graph());
    return g2.setGraph(Object.assign(
      {},
      graphDefaults,
      selectNumberAttrs(graph2, graphNumAttrs),
      util2.pick(graph2, graphAttrs)
    )), inputGraph.nodes().forEach((v2) => {
      let node2 = canonicalize(inputGraph.node(v2));
      const newNode = selectNumberAttrs(node2, nodeNumAttrs);
      Object.keys(nodeDefaults).forEach((k) => {
        newNode[k] === void 0 && (newNode[k] = nodeDefaults[k]);
      }), g2.setNode(v2, newNode), g2.setParent(v2, inputGraph.parent(v2));
    }), inputGraph.edges().forEach((e2) => {
      let edge = canonicalize(inputGraph.edge(e2));
      g2.setEdge(e2, Object.assign(
        {},
        edgeDefaults,
        selectNumberAttrs(edge, edgeNumAttrs),
        util2.pick(edge, edgeAttrs)
      ));
    }), g2;
  }
  function makeSpaceForEdgeLabels(g2) {
    let graph2 = g2.graph();
    graph2.ranksep /= 2, g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      edge.minlen *= 2, edge.labelpos.toLowerCase() !== "c" && (graph2.rankdir === "TB" || graph2.rankdir === "BT" ? edge.width += edge.labeloffset : edge.height += edge.labeloffset);
    });
  }
  function injectEdgeLabelProxies(g2) {
    g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      if (edge.width && edge.height) {
        let v2 = g2.node(e2.v), label2 = { rank: (g2.node(e2.w).rank - v2.rank) / 2 + v2.rank, e: e2 };
        util2.addDummyNode(g2, "edge-proxy", label2, "_ep");
      }
    });
  }
  function assignRankMinMax(g2) {
    let maxRank = 0;
    g2.nodes().forEach((v2) => {
      let node2 = g2.node(v2);
      node2.borderTop && (node2.minRank = g2.node(node2.borderTop).rank, node2.maxRank = g2.node(node2.borderBottom).rank, maxRank = Math.max(maxRank, node2.maxRank));
    }), g2.graph().maxRank = maxRank;
  }
  function removeEdgeLabelProxies(g2) {
    g2.nodes().forEach((v2) => {
      let node2 = g2.node(v2);
      node2.dummy === "edge-proxy" && (g2.edge(node2.e).labelRank = node2.rank, g2.removeNode(v2));
    });
  }
  function translateGraph(g2) {
    let minX = Number.POSITIVE_INFINITY, maxX = 0, minY = Number.POSITIVE_INFINITY, maxY = 0, graphLabel = g2.graph(), marginX = graphLabel.marginx || 0, marginY = graphLabel.marginy || 0;
    function getExtremes(attrs) {
      let x2 = attrs.x, y2 = attrs.y, w2 = attrs.width, h2 = attrs.height;
      minX = Math.min(minX, x2 - w2 / 2), maxX = Math.max(maxX, x2 + w2 / 2), minY = Math.min(minY, y2 - h2 / 2), maxY = Math.max(maxY, y2 + h2 / 2);
    }
    g2.nodes().forEach((v2) => getExtremes(g2.node(v2))), g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      Object.hasOwn(edge, "x") && getExtremes(edge);
    }), minX -= marginX, minY -= marginY, g2.nodes().forEach((v2) => {
      let node2 = g2.node(v2);
      node2.x -= minX, node2.y -= minY;
    }), g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      edge.points.forEach((p2) => {
        p2.x -= minX, p2.y -= minY;
      }), Object.hasOwn(edge, "x") && (edge.x -= minX), Object.hasOwn(edge, "y") && (edge.y -= minY);
    }), graphLabel.width = maxX - minX + marginX, graphLabel.height = maxY - minY + marginY;
  }
  function assignNodeIntersects(g2) {
    g2.edges().forEach((e2) => {
      let edge = g2.edge(e2), nodeV = g2.node(e2.v), nodeW = g2.node(e2.w), p1, p2;
      edge.points ? (p1 = edge.points[0], p2 = edge.points[edge.points.length - 1]) : (edge.points = [], p1 = nodeW, p2 = nodeV), edge.points.unshift(util2.intersectRect(nodeV, p1)), edge.points.push(util2.intersectRect(nodeW, p2));
    });
  }
  function fixupEdgeLabelCoords(g2) {
    g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      if (Object.hasOwn(edge, "x"))
        switch ((edge.labelpos === "l" || edge.labelpos === "r") && (edge.width -= edge.labeloffset), edge.labelpos) {
          case "l":
            edge.x -= edge.width / 2 + edge.labeloffset;
            break;
          case "r":
            edge.x += edge.width / 2 + edge.labeloffset;
            break;
        }
    });
  }
  function reversePointsForReversedEdges(g2) {
    g2.edges().forEach((e2) => {
      let edge = g2.edge(e2);
      edge.reversed && edge.points.reverse();
    });
  }
  function removeBorderNodes(g2) {
    g2.nodes().forEach((v2) => {
      if (g2.children(v2).length) {
        let node2 = g2.node(v2), t2 = g2.node(node2.borderTop), b2 = g2.node(node2.borderBottom), l = g2.node(node2.borderLeft[node2.borderLeft.length - 1]), r2 = g2.node(node2.borderRight[node2.borderRight.length - 1]);
        node2.width = Math.abs(r2.x - l.x), node2.height = Math.abs(b2.y - t2.y), node2.x = l.x + node2.width / 2, node2.y = t2.y + node2.height / 2;
      }
    }), g2.nodes().forEach((v2) => {
      g2.node(v2).dummy === "border" && g2.removeNode(v2);
    });
  }
  function removeSelfEdges(g2) {
    g2.edges().forEach((e2) => {
      if (e2.v === e2.w) {
        var node2 = g2.node(e2.v);
        node2.selfEdges || (node2.selfEdges = []), node2.selfEdges.push({ e: e2, label: g2.edge(e2) }), g2.removeEdge(e2);
      }
    });
  }
  function insertSelfEdges(g2) {
    var layers = util2.buildLayerMatrix(g2);
    layers.forEach((layer) => {
      var orderShift = 0;
      layer.forEach((v2, i2) => {
        var node2 = g2.node(v2);
        node2.order = i2 + orderShift, (node2.selfEdges || []).forEach((selfEdge) => {
          util2.addDummyNode(g2, "selfedge", {
            width: selfEdge.label.width,
            height: selfEdge.label.height,
            rank: node2.rank,
            order: i2 + ++orderShift,
            e: selfEdge.e,
            label: selfEdge.label
          }, "_se");
        }), delete node2.selfEdges;
      });
    });
  }
  function positionSelfEdges(g2) {
    g2.nodes().forEach((v2) => {
      var node2 = g2.node(v2);
      if (node2.dummy === "selfedge") {
        var selfNode = g2.node(node2.e.v), x2 = selfNode.x + selfNode.width / 2, y2 = selfNode.y, dx = node2.x - x2, dy = selfNode.height / 2;
        g2.setEdge(node2.e, node2.label), g2.removeNode(v2), node2.label.points = [
          { x: x2 + 2 * dx / 3, y: y2 - dy },
          { x: x2 + 5 * dx / 6, y: y2 - dy },
          { x: x2 + dx, y: y2 },
          { x: x2 + 5 * dx / 6, y: y2 + dy },
          { x: x2 + 2 * dx / 3, y: y2 + dy }
        ], node2.label.x = node2.x, node2.label.y = node2.y;
      }
    });
  }
  function selectNumberAttrs(obj, attrs) {
    return util2.mapValues(util2.pick(obj, attrs), Number);
  }
  function canonicalize(attrs) {
    var newAttrs = {};
    return attrs && Object.entries(attrs).forEach(([k, v2]) => {
      typeof k == "string" && (k = k.toLowerCase()), newAttrs[k] = v2;
    }), newAttrs;
  }
  return layout_1;
}
var debug, hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  let util2 = requireUtil$1(), Graph = requireGraphlib().Graph;
  debug = {
    debugOrdering
  };
  function debugOrdering(g2) {
    let layerMatrix = util2.buildLayerMatrix(g2), h2 = new Graph({ compound: !0, multigraph: !0 }).setGraph({});
    return g2.nodes().forEach((v2) => {
      h2.setNode(v2, { label: v2 }), h2.setParent(v2, "layer" + g2.node(v2).rank);
    }), g2.edges().forEach((e2) => h2.setEdge(e2.v, e2.w, {}, e2.name)), layerMatrix.forEach((layer, i2) => {
      let layerV = "layer" + i2;
      h2.setNode(layerV, { rank: "same" }), layer.reduce((u, v2) => (h2.setEdge(u, v2, { style: "invis" }), v2));
    }), h2;
  }
  return debug;
}
var version, hasRequiredVersion;
function requireVersion() {
  return hasRequiredVersion || (hasRequiredVersion = 1, version = "1.1.8"), version;
}
var dagre$1, hasRequiredDagre;
function requireDagre() {
  return hasRequiredDagre || (hasRequiredDagre = 1, dagre$1 = {
    graphlib: requireGraphlib(),
    layout: requireLayout(),
    debug: requireDebug(),
    util: {
      time: requireUtil$1().time,
      notime: requireUtil$1().notime
    },
    version: requireVersion()
  }), dagre$1;
}
var dagreExports = requireDagre();
const dagre = /* @__PURE__ */ getDefaultExportFromCjs(dagreExports), Sizes$1 = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 140,
    height: 10,
    minlen: 1,
    weight: 1
  },
  emptyNodeOffset: 120,
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph$1() {
  const g2 = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g2.setGraph({
    ...Sizes$1.dagre,
    rankdir: "LR"
  }), g2.setDefaultEdgeLabel(() => ({ ...Sizes$1.edgeLabel })), g2.setDefaultNodeLabel(() => ({})), g2;
}
const PortSuffix$1 = "-port";
function createNodes$1(column, elements, g2) {
  const graphNodes = new DefaultMap((key2) => ({
    id: `${column}-${key2}`,
    portId: `${column}-${key2}`
  })), tree = treeFromElements(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id2 = `${column}-${fqn2}`, portId = isCompound ? `${id2}${PortSuffix$1}` : id2;
    graphNodes.set(fqn2, {
      id: id2,
      portId
    }), g2.setNode(id2, {
      column,
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    }), isCompound && (g2.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth - Sizes$1.dagre.ranksep,
      height: Sizes$1.compound.labelHeight
    }), g2.setParent(portId, id2));
    const parent = tree.parent(element);
    parent && g2.setParent(id2, `${column}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id2) => {
      const element = tree.byId(id2), graph2 = graphNodes.get(element.id);
      return {
        element,
        graph: graph2
      };
    },
    graphNodes
  };
}
function applyDagreLayout$1(g2) {
  return dagre.layout(g2, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g2.node(nodeId), { x: x2, y: y2, width, height } = node2;
    return {
      position: {
        x: x2 - Math.round(width / 2),
        y: y2 - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
var LayoutRelationshipsViewResult;
((LayoutRelationshipsViewResult2) => {
  LayoutRelationshipsViewResult2.Empty = "@empty";
})(LayoutRelationshipsViewResult || (LayoutRelationshipsViewResult = {}));
function layoutRelationshipsView(data, scope) {
  const g2 = createGraph$1(), incomers = createNodes$1("incomers", data.incomers, g2), subjects = createNodes$1("subjects", data.subjects, g2), outgoers = createNodes$1("outgoers", data.outgoers, g2), edges = [];
  t$s(
    t$u(
      t$s(
        toArray$1(data.incoming),
        t$f((r2) => ({
          id: r2.source.id,
          sourceFqn: r2.source.id,
          targetFqn: r2.target.id,
          source: incomers.byId(r2.source.id).graph,
          target: subjects.byId(r2.target.id).graph,
          relation: r2
        }))
      ),
      t$s(
        toArray$1(data.outgoing),
        t$f((r2) => ({
          id: r2.target.id,
          sourceFqn: r2.source.id,
          targetFqn: r2.target.id,
          source: subjects.byId(r2.source.id).graph,
          target: outgoers.byId(r2.target.id).graph,
          relation: r2
        }))
      )
    ),
    t$f((r2) => ({
      ...r2,
      expr: `${r2.source.id}->${r2.target.id}`
    })),
    // Group if same source and target
    t$l(e("expr")),
    t$m((grouped) => {
      const source = grouped[0].source, target = grouped[0].target, name = grouped[0].expr;
      g2.node(source.id).outPorts.push(target.id), g2.node(target.id).inPorts.push(source.id), g2.setEdge(source.portId, target.portId, {
        ...Sizes$1.edgeLabel
      }, name), edges.push({
        name,
        sourceFqn: grouped[0].sourceFqn,
        targetFqn: grouped[0].targetFqn,
        source: source.id,
        sourceHandle: source.id + "_out" + (g2.node(source.id).outPorts.length - 1),
        target: target.id,
        targetHandle: target.id + "_in" + (g2.node(target.id).inPorts.length - 1),
        relations: t$f(grouped, e("relation"))
      });
    })
  );
  for (const subjectNode of subjects.graphNodes.values()) {
    const nodeId = subjectNode.id, node2 = g2.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount2 = Math.max(g2.inEdges(nodeId)?.length ?? 0, g2.outEdges(nodeId)?.length ?? 0);
    edgeCount2 > 2 && (node2.height = node2.height + (edgeCount2 - 3) * 14);
  }
  const nodeIds = [
    ...incomers.graphNodes.values(),
    ...subjects.graphNodes.values(),
    ...outgoers.graphNodes.values()
  ];
  if (incomers.graphNodes.size == 0) {
    const id2 = "incomers-empty";
    g2.setNode(id2, {
      column: "incomers",
      element: null,
      isCompound: !1,
      portId: id2,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    });
    for (const subjectNode of subjects.graphNodes.values())
      g2.setEdge(id2, subjectNode.portId);
    nodeIds.push({
      id: id2,
      portId: id2
    });
  }
  if (outgoers.graphNodes.size == 0) {
    const id2 = "outgoers-empty";
    g2.setNode(id2, {
      column: "outgoers",
      element: null,
      isCompound: !1,
      portId: id2,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    });
    for (const subjectNode of subjects.graphNodes.values())
      g2.setEdge(subjectNode.portId, id2);
    nodeIds.push({
      id: id2,
      portId: id2
    });
  }
  const edgeCount = g2.edgeCount();
  if (edgeCount > 10)
    for (const edge of g2.edges())
      g2.setEdge(edge, {
        ...Sizes$1.edgeLabel,
        width: edgeCount > 25 ? 800 : 400
      });
  const dagreBounds = applyDagreLayout$1(g2), _calculatedNodeBounds = t$s(
    nodeIds,
    // Compound nodes have different portId
    n$q((n2) => n2.id === n2.portId),
    t$e((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= t$s(
      g2.children(nodeId) ?? [],
      n$q((id2) => !id2.endsWith(PortSuffix$1)),
      t$f((id2) => nodeBounds(id2)),
      t$1((bounds) => {
        invariant$1(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      t$5((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x: x2 },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes$1.compound.paddingTop, maxY = maxY + Sizes$1.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g2.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children2 = g2.children(nodeId) ?? [];
    return children2.length === 0 ? 0 : 1 + Math.max(...children2.map(nodeDepth));
  }
  const sortedPorts = (nodeId, type, ports) => t$s(
    ports,
    t$f((port, index2) => ({
      port: nodeId + "_" + type + index2,
      topY: nodeBounds(port).position.y
    })),
    t$2(e("topY")),
    t$f(e("port"))
  );
  let minX = 0, minY = 0;
  const [subject] = [...subjects.root];
  invariant$1(subject, "Subjects should not be empty");
  let subjectBounds = nodeBounds(subjects.graphNodes.get(subject.id).id);
  const nodes = nodeIds.map(({ id: id2 }) => {
    const { element, inPorts, outPorts, column } = g2.node(id2);
    let { position, width, height } = nodeBounds(id2);
    if (!element) {
      if (height = Math.min(subjectBounds.height, 300), position.y = subjectBounds.position.y + subjectBounds.height / 2 - height / 2, column === "incomers")
        width = subjectBounds.position.x - Sizes$1.emptyNodeOffset - position.x;
      else {
        const rightX = position.x + width;
        position.x = subjectBounds.position.x + subjectBounds.width + Sizes$1.emptyNodeOffset, width = rightX - position.x;
      }
      return {
        id: id2,
        parent: null,
        x: position.x,
        y: position.y,
        title: "empty node",
        description: null,
        technology: null,
        tags: [],
        links: [],
        color: "muted",
        shape: "rectangle",
        style: {
          border: "dashed",
          opacity: 50
        },
        kind: LayoutRelationshipsViewResult.Empty,
        level: 0,
        labelBBox: {
          x: position.x,
          y: position.y,
          width,
          height
        },
        children: [],
        width,
        height,
        column,
        ports: {
          in: [],
          out: []
        },
        existsInCurrentView: !1
      };
    }
    const parentId = g2.parent(id2), children2 = (g2.children(id2) ?? []).filter((c) => !c.endsWith(PortSuffix$1));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = scope ? ifind(element.scopedViews(), (v2) => v2.id !== scope.id)?.id ?? null : null, inheritFromNode = scope?.findNodeWithElement(element.id), scopedAncestor = scope && !inheritFromNode ? ifind(element.ancestors(), (a2) => !!scope.findNodeWithElement(a2.id))?.id : null, inheritFromNodeOrAncestor = inheritFromNode ?? (scopedAncestor && scope?.findNodeWithElement(scopedAncestor));
    return {
      id: id2,
      parent: parentId ?? null,
      x: position.x,
      y: position.y,
      title: element.title,
      description: preferSummary(element.$element) ?? null,
      technology: element.technology,
      tags: [...element.tags],
      links: null,
      color: inheritFromNodeOrAncestor?.color ?? element.color,
      shape: inheritFromNode?.shape ?? element.shape,
      icon: inheritFromNode?.icon ?? element.icon ?? "none",
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id2),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: n$c({
        ...(inheritFromNode ?? inheritFromNodeOrAncestor)?.style,
        ...element.$element.style
      }, ["color", "shape", "icon"]),
      navigateTo,
      ...children2.length > 0 && { depth: nodeDepth(id2) },
      children: children2,
      width,
      height,
      column,
      ports: {
        in: sortedPorts(id2, "in", inPorts),
        out: sortedPorts(id2, "out", outPorts)
      },
      existsInCurrentView: !!inheritFromNode
    };
  });
  return {
    subjectExistsInScope: !scope || scope.includesElement(subject.id),
    bounds: {
      x: Math.min(minX, 0),
      y: Math.min(minY, 0),
      width: g2.graph().width ?? 100,
      height: g2.graph().height ?? 100
    },
    nodes,
    edges: g2.edges().reduce((acc, e2) => {
      const edge = g2.edge(e2), ename = e2.name;
      if (!ename)
        return acc;
      const {
        name,
        source,
        sourceFqn,
        target,
        targetFqn,
        relations,
        sourceHandle,
        targetHandle
      } = nonNullable$1(r$a(edges, (e22) => e22.name === ename)), onlyRelation = t$b(relations), label2 = onlyRelation?.title ?? "untitled", isMultiple = relations.length > 1, navigateTo = t$b(n(relations.flatMap((r2) => r2.navigateTo?.id ? r2.navigateTo.id : [])));
      return acc.push(exact({
        id: name,
        sourceFqn,
        source,
        sourceHandle,
        targetFqn,
        target,
        targetHandle,
        label: isMultiple ? `${relations.length} relationships` : label2,
        navigateTo,
        color: onlyRelation?.color ?? "gray",
        existsInCurrentView: !scope || relations.every((r2) => scope.includesRelation(r2.id)),
        points: edge.points.map((p2) => [p2.x, p2.y]),
        line: onlyRelation?.line ?? "dashed",
        head: onlyRelation?.head,
        tail: onlyRelation?.tail,
        relations: relations.map((r2) => r2.id),
        parent: null
      })), acc;
    }, [])
  };
}
function useRelationshipsView(subject, viewId, scope) {
  const model = useLikeC4Model();
  return useMemo(() => {
    const view = viewId ? model.findView(viewId) : null, data = layoutRelationshipsView(
      computeRelationshipsView(subject, model, viewId, scope),
      scope === "view" ? view : null
    );
    return view && (scope === "global" || !data.subjectExistsInScope) && (data.edges = data.edges.map((edge) => (edge.existsInCurrentView = edge.relations.every((r2) => view.includesRelation(r2)), edge))), Object.assign(data, { subject });
  }, [model, subject, viewId, scope, computeRelationshipsView]);
}
const sortByLabel = (a2, b2) => compareNatural(a2.label, b2.label);
function buildNode(element) {
  return {
    label: element.title,
    value: element.id,
    children: [...element.children()].map(buildNode).sort(sortByLabel)
  };
}
function useLikeC4ElementsTree(viewId) {
  const model = useLikeC4Model();
  return useMemo(() => viewId ? [...model.view(viewId).roots()].map(buildNode).sort(sortByLabel) : [...model.roots()].map(buildNode).sort(sortByLabel), [model, viewId ?? null]);
}
const node = css({
  margin: "0"
}), label = css({
  _hover: {
    backgroundColor: "mantine.colors.gray[0]",
    _dark: {
      backgroundColor: "mantine.colors.defaultHover",
      color: "mantine.colors.white"
    }
  }
}), scrollArea$2 = css({
  maxHeight: [
    "70vh",
    "calc(100cqh - 70px)"
  ]
}), SelectElement_css = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label,
  node,
  scrollArea: scrollArea$2
}, Symbol.toStringTag, { value: "Module" }));
const __iconNode$y = [["path", { d: "M8 9l4 -4l4 4", key: "svg-0" }], ["path", { d: "M16 15l-4 4l-4 -4", key: "svg-1" }]], IconSelector = createReactComponent("outline", "selector", "Selector", __iconNode$y), selector2$1 = (state) => {
  const subjectExistsInScope = state.context.layouted?.subjectExistsInScope ?? !1;
  return {
    subjectId: state.context.subject,
    viewId: state.context.viewId,
    scope: state.context.scope,
    subjectExistsInScope,
    enableSelectSubject: state.context.enableSelectSubject,
    enableChangeScope: state.context.enableChangeScope
  };
}, setHoveredNode$2 = () => {
}, SelectElement = memo$3(() => {
  const browser = useRelationshipsBrowser(), {
    subjectId,
    viewId,
    scope,
    subjectExistsInScope,
    enableSelectSubject,
    enableChangeScope
  } = useRelationshipsBrowserState(selector2$1), root2 = useRef(null), viewport = useRef(null), subject = useLikeC4Model().findElement(subjectId), data = useLikeC4ElementsTree(scope === "view" && viewId ? viewId : void 0), tree = useTree({
    multiple: !1
  });
  return tree.setHoveredNode = setHoveredNode$2, useEffect(() => {
    ancestorsFqn(subjectId).reverse().forEach((id2) => {
      tree.expand(id2);
    }), tree.select(subjectId);
  }, [subjectId]), /* @__PURE__ */ jsxs(Group, { ref: root2, gap: "xs", pos: "relative", children: [
    enableSelectSubject && /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
      /* @__PURE__ */ jsx(
        Box$1,
        {
          fz: "xs",
          fw: "500",
          style: { whiteSpace: "nowrap", userSelect: "none" },
          children: "Relationships of"
        }
      ),
      /* @__PURE__ */ jsx(Box$1, { pos: "relative", children: /* @__PURE__ */ jsxs(
        Popover,
        {
          position: "bottom-start",
          shadow: "md",
          keepMounted: !1,
          withinPortal: !1,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          offset: 4,
          onOpen: () => {
            setTimeout(() => {
              viewport.current?.querySelector(`[data-value="${subjectId}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
            }, 100);
          },
          children: [
            /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
              Button,
              {
                size: "xs",
                variant: "default",
                maw: 250,
                rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
                children: /* @__PURE__ */ jsx(Text, { fz: "xs", fw: "500", truncate: !0, children: subject?.title ?? "???" })
              }
            ) }),
            /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { scrollbars: "y", type: "never", viewportRef: viewport, className: scrollArea$2, children: /* @__PURE__ */ jsx(
              Tree,
              {
                allowRangeSelection: !1,
                selectOnClick: !1,
                tree,
                data,
                classNames: SelectElement_css,
                levelOffset: 8,
                styles: {
                  root: {
                    maxWidth: 400,
                    overflow: "hidden"
                  },
                  label: {
                    paddingTop: 5,
                    paddingBottom: 6
                  }
                },
                renderNode: ({ node: node2, selected: selected2, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsxs(Group, { gap: 2, wrap: "nowrap", ...elementProps, py: "3", children: [
                  /* @__PURE__ */ jsx(
                    ActionIcon,
                    {
                      variant: "subtle",
                      size: 18,
                      c: "dimmed",
                      style: {
                        visibility: hasChildren ? "visible" : "hidden"
                      },
                      children: /* @__PURE__ */ jsx(
                        IconChevronRight,
                        {
                          stroke: 3.5,
                          style: {
                            transition: "transform 150ms ease",
                            transform: `rotate(${expanded ? "90deg" : "0"})`,
                            width: "80%"
                          }
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    Box$1,
                    {
                      flex: "1 1 100%",
                      w: "100%",
                      onClick: (e2) => {
                        e2.stopPropagation(), tree.select(node2.value), tree.expand(node2.value), browser.navigateTo(node2.value);
                      },
                      children: /* @__PURE__ */ jsx(
                        Text,
                        {
                          fz: "sm",
                          fw: selected2 ? "600" : "400",
                          truncate: "end",
                          children: node2.label
                        }
                      )
                    }
                  )
                ] })
              }
            ) }) })
          ]
        }
      ) })
    ] }),
    enableChangeScope && /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
      enableSelectSubject && /* @__PURE__ */ jsx(
        Box$1,
        {
          fz: "xs",
          fw: "500",
          ...!subjectExistsInScope && {
            c: "dimmed"
          },
          style: { whiteSpace: "nowrap", userSelect: "none" },
          children: "Scope"
        }
      ),
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
        Tooltip$6,
        {
          color: "orange",
          label: /* @__PURE__ */ jsxs(Fragment, { children: [
            "This element does not exist in the current view",
            scope === "view" && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx("br", {}),
              "Scope is set to global"
            ] })
          ] }),
          position: "bottom-start",
          disabled: subjectExistsInScope,
          portalProps: {
            target: root2.current
          },
          children: /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              flex: "1 0 auto",
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              styles: {
                label: {
                  paddingLeft: 8,
                  paddingRight: 8
                }
              },
              onChange: (value) => {
                browser.changeScope(value);
              },
              data: [
                { label: "Global", value: "global" },
                {
                  label: /* @__PURE__ */ jsx("span", { children: "Current view" }),
                  value: "view",
                  disabled: !subjectExistsInScope
                }
              ]
            }
          )
        }
      ) })
    ] })
  ] });
}), isSame = (a2, b2) => Math.abs(a2 - b2) < 2.5, edgePropsEqual = (prev, next) => prev.id === next.id && deepEqual$1(prev.selected ?? !1, next.selected ?? !1) && deepEqual$1(prev.animated ?? !1, next.animated ?? !1) && deepEqual$1(prev.source, next.source) && isSame(prev.sourceX, next.sourceX) && isSame(prev.sourceY, next.sourceY) && deepEqual$1(prev.sourceHandleId ?? null, next.sourceHandleId ?? null) && deepEqual$1(prev.sourcePosition, next.sourcePosition) && deepEqual$1(prev.target, next.target) && isSame(prev.targetY, next.targetY) && isSame(prev.targetX, next.targetX) && deepEqual$1(prev.targetHandleId ?? null, next.targetHandleId ?? null) && deepEqual$1(prev.targetPosition, next.targetPosition) && deepEqual$1(prev.data, next.data);
function memoEdge(Edge) {
  const Memo = memo$3(Edge, edgePropsEqual);
  return Memo.displayName = `MemoEdge(${Edge.displayName || Edge.name})`, Memo;
}
function createMinimalMotionComponent(Component2, options) {
  return createMotionComponent(Component2, options);
}
const MotionButton = /* @__PURE__ */ createMinimalMotionComponent("button"), MotionDiv = /* @__PURE__ */ createMinimalMotionComponent("div"), EdgeLabel = forwardRef(({
  edgeProps: {
    id: id2,
    data: {
      label: label2,
      technology,
      hovered: isHovered = !1
    },
    selected: selected2 = !1,
    selectable = !1
  },
  pointerEvents = "all",
  className,
  style: _style,
  // omit
  children: children2,
  ...rest
}, ref) => {
  const stepNum = isStepEdgeId(id2) ? extractStep(id2) : null, hasLabel = e$1(label2) || e$1(technology);
  return /* @__PURE__ */ jsxs(
    MotionDiv,
    {
      ref,
      className: cx(
        // This class is queried by RelationshipPopover to position near the edge label
        "likec4-edge-label",
        edgeLabel$1({
          pointerEvents,
          isStepEdge: stepNum !== null,
          cursor: selectable || stepNum !== null ? "pointer" : "default"
        }),
        className
      ),
      "data-edge-id": id2,
      animate: {
        scale: isHovered && !selected2 ? 1.06 : 1
      },
      ...rest,
      children: [
        stepNum !== null && /* @__PURE__ */ jsx(Box, { className: "likec4-edge-label__step-number", children: stepNum }),
        hasLabel && /* @__PURE__ */ jsxs(Box, { className: "likec4-edge-label__contents", children: [
          e$1(label2) && /* @__PURE__ */ jsx(
            Box,
            {
              lineClamp: 5,
              className: "likec4-edge-label__text",
              children: label2
            }
          ),
          e$1(technology) && /* @__PURE__ */ jsx(Box, { className: "likec4-edge-label__technology", children: "[ " + technology + " ]" }),
          children2
        ] })
      ]
    }
  );
});
EdgeLabel.displayName = "EdgeLabel";
function EdgeActionButton({ icon: icon2, onClick }) {
  return /* @__PURE__ */ jsx(
    ActionIcon,
    {
      className: cx("nodrag nopan", edgeActionBtn()),
      onPointerDownCapture: stopPropagation,
      onClick,
      role: "button",
      onDoubleClick: stopPropagation,
      children: icon2 ?? /* @__PURE__ */ jsx(IconZoomScan, {})
    }
  );
}
function EdgeContainer({
  className,
  component = "g",
  selectable = !1,
  selected: selected2 = !1,
  data: {
    color: color2 = "gray",
    hovered: isHovered = !1,
    active: isActive = !1,
    dimmed: isDimmed = !1,
    ...data
  },
  animated,
  children: children2,
  style: style2
}) {
  const props = {
    className: cx(
      className,
      "likec4-edge-container",
      selected2 && "selected",
      selectable && "selectable"
    ),
    "data-likec4-color": color2,
    "data-edge-dir": data.dir ?? "forward",
    "data-edge-active": isActive,
    "data-edge-animated": animated || isActive,
    "data-likec4-hovered": isHovered,
    ...selected2 && {
      "data-likec4-selected": selected2
    },
    ...isDimmed !== !1 && {
      "data-likec4-dimmed": isDimmed
    }
  };
  return component === "svg" ? /* @__PURE__ */ jsx("svg", { style: style2, ...props, children: children2 }) : (invariant$2(component === "g", 'EdgeContainer: component must be "g" or "svg"'), /* @__PURE__ */ jsx("g", { style: style2, ...props, children: children2 }));
}
const Open = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 14 16",
    refX: 5,
    refY: 4,
    markerWidth: "7",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M0,0 L7,4 L0,8 L4,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeDasharray: 0,
        strokeWidth: 1,
        strokeLinecap: "round"
      }
    )
  }
), Arrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        fill: "context-stroke",
        strokeWidth: 0
      }
    )
  }
), Crow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 12",
    refX: 8,
    refY: 4,
    markerWidth: "8",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 8 0 L 0 4 L 8 8 M 8 4 L 0 4",
        fill: "none",
        strokeWidth: 1
      }
    )
  }
), OArrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeWidth: 1.25,
        strokeLinejoin: "miter",
        strokeLinecap: "square"
      }
    )
  }
), Diamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 5,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        fill: "context-stroke",
        strokeWidth: 0,
        strokeLinecap: "round"
      }
    )
  }
), ODiamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 6,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeWidth: 1.25,
        strokeLinecap: "round"
      }
    )
  }
), Dot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 0,
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), ODot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 1.25,
        stroke: "context-stroke",
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), EdgeMarkers = {
  Arrow,
  Crow,
  OArrow,
  Open,
  Diamond,
  ODiamond,
  Dot,
  ODot
};
function arrowTypeToMarker(arrowType) {
  if (!(!arrowType || arrowType === "none"))
    switch (arrowType) {
      case "normal":
        return "Arrow";
      case "crow":
        return "Crow";
      case "onormal":
        return "OArrow";
      case "diamond":
        return "Diamond";
      case "odiamond":
        return "ODiamond";
      case "open":
      case "vee":
        return "Open";
      case "dot":
        return "Dot";
      case "odot":
        return "ODot";
      default:
        nonexhaustive(arrowType);
    }
}
const EdgePath = forwardRef(({
  edgeProps: {
    id: id2,
    data: {
      line: line2,
      dir,
      tail,
      head
    },
    selectable = !0,
    style: style2,
    interactionWidth
  },
  isDragging: isDragging2 = !1,
  // omit
  onEdgePointerDown,
  strokeWidth,
  svgPath
}, svgPathRef) => {
  let markerStartName = arrowTypeToMarker(tail), markerEndName = arrowTypeToMarker(head ?? "normal");
  dir === "back" && ([markerStartName, markerEndName] = [markerEndName, markerStartName]);
  const MarkerStart = markerStartName ? EdgeMarkers[markerStartName] : null, MarkerEnd = markerEndName ? EdgeMarkers[markerEndName] : null, isDotted = line2 === "dotted", isDashed = isDotted || line2 === "dashed";
  let strokeDasharray;
  isDotted ? strokeDasharray = "1,8" : isDashed && (strokeDasharray = "8,10");
  const classes2 = edgePath();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    selectable && /* @__PURE__ */ jsx(
      "path",
      {
        className: cx(
          "react-flow__edge-interaction",
          css({
            fill: "none"
          })
        ),
        onPointerDown: onEdgePointerDown,
        d: svgPath,
        style: {
          strokeWidth: interactionWidth ?? 10,
          stroke: "currentcolor",
          strokeOpacity: 0,
          ...isDragging2 ? { display: "none" } : {}
        }
      }
    ),
    /* @__PURE__ */ jsx(
      "circle",
      {
        className: cx(
          // This class is queried by RelationshipPopover to position in the middle of the edge
          "likec4-edge-middle-point",
          classes2.middlePoint
        ),
        "data-edge-id": id2,
        style: {
          offsetPath: `path("${svgPath}")`
        }
      }
    ),
    /* @__PURE__ */ jsxs("g", { className: classes2.markersCtx, onPointerDown: onEdgePointerDown, children: [
      /* @__PURE__ */ jsxs("defs", { children: [
        MarkerStart && /* @__PURE__ */ jsx(MarkerStart, { id: "start" + id2 }),
        MarkerEnd && /* @__PURE__ */ jsx(MarkerEnd, { id: "end" + id2 })
      ] }),
      /* @__PURE__ */ jsx(
        "path",
        {
          className: cx(
            "react-flow__edge-path",
            "hide-on-reduced-graphics",
            classes2.pathBg,
            isDragging2 && css({ display: "none" })
          ),
          d: svgPath,
          style: style2,
          strokeLinecap: "round"
        }
      ),
      /* @__PURE__ */ jsx(
        "path",
        {
          ref: svgPathRef,
          className: cx(
            "react-flow__edge-path",
            classes2.path,
            selectable && "react-flow__edge-interaction"
          ),
          d: svgPath,
          style: style2,
          strokeWidth,
          strokeLinecap: "round",
          strokeDasharray,
          markerStart: MarkerStart ? `url(#start${id2})` : void 0,
          markerEnd: MarkerEnd ? `url(#end${id2})` : void 0
        }
      )
    ] })
  ] });
});
EdgePath.displayName = "EdgePath";
const toCssVarValue = (value) => {
  if (value !== void 0)
    return e$4(value) ? `${Math.round(value)}px` : value;
};
function EdgeLabelContainer({
  edgeProps: {
    id: id2,
    selected: selected2 = !1,
    data: {
      hovered: isHovered = !1,
      active: isActive = !1,
      dimmed: isDimmed = !1,
      labelBBox,
      color: color2 = "gray"
    },
    animated
  },
  labelPosition: labelXY,
  className,
  style: style2,
  children: children2,
  ...rest
}) {
  let zIndex = useXYStore(
    useCallback((state) => state.edgeLookup.get(id2)?.zIndex ?? ZIndexes.Edge, [id2])
  );
  (isHovered || isActive) && (zIndex += 100);
  let labelX = labelXY?.x ?? labelBBox?.x, labelY = labelXY?.y ?? labelBBox?.y;
  if (labelX === void 0 || labelY === void 0)
    return null;
  const translate = labelXY?.translate ?? "";
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsx(
    "div",
    {
      ...rest,
      className: cx(
        "nodrag nopan",
        "likec4-edge-label-container",
        className
      ),
      "data-likec4-hovered": isHovered,
      "data-likec4-color": color2,
      "data-edge-active": isActive,
      "data-edge-animated": animated || isActive,
      ...selected2 !== !1 && {
        "data-likec4-selected": selected2
      },
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...labelBBox && {
          maxWidth: labelBBox.width + 18
        },
        zIndex,
        ...style2,
        transform: `translate(${toCssVarValue(labelX)}, ${toCssVarValue(labelY)}) ${translate}`
      },
      children: children2
    },
    id2
  ) });
}
const RelationshipEdge$3 = memoEdge((props) => {
  const browser = useRelationshipsBrowser(), { enableNavigateTo } = useEnabledFeatures(), {
    data: {
      navigateTo,
      relations,
      existsInCurrentView
    }
  } = props, [svgPath, labelX, labelY] = getBezierPath(props), diagram = useDiagram(), markOrange = relations.length > 1 || !existsInCurrentView, edgeProps = markOrange ? {
    ...props,
    data: {
      ...props.data,
      color: "amber"
    }
  } : props;
  let label2 = /* @__PURE__ */ jsx(
    EdgeLabel,
    {
      edgeProps,
      className: css({
        transition: "fast"
      }),
      children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
        EdgeActionButton,
        {
          ...props,
          onClick: (e2) => {
            e2.stopPropagation(), diagram.navigateTo(navigateTo);
          }
        }
      )
    }
  );
  return existsInCurrentView || (label2 = /* @__PURE__ */ jsx(
    Tooltip$6,
    {
      color: "orange",
      c: "black",
      label: "This relationship is not included in the current view",
      portalProps: {
        target: `#${browser.rootElementId}`
      },
      openDelay: 800,
      children: label2
    }
  )), /* @__PURE__ */ jsxs(EdgeContainer, { ...edgeProps, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps,
        svgPath,
        ...markOrange && {
          strokeWidth: 5
        }
      }
    ),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps,
        labelPosition: {
          x: labelX,
          y: labelY,
          translate: "translate(-50%, 0)"
        },
        style: {
          maxWidth: Math.min(Math.abs(props.targetX - props.sourceX - 70), 250)
        },
        children: label2
      }
    )
  ] });
}), emptyNode = css({
  width: "100%",
  height: "100%",
  border: "3px dashed",
  borderColor: "mantine.colors.defaultBorder",
  borderRadius: "md",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
function EmptyNode({
  data: {
    column
  }
}) {
  return /* @__PURE__ */ jsx(Box$1, { className: emptyNode, children: /* @__PURE__ */ jsxs(Text, { c: "dimmed", fz: "lg", fw: 500, children: [
    "No ",
    column === "incomers" ? "incoming" : "outgoing"
  ] }) });
}
const selectViewId = (s2) => s2.context.view.id;
function useCurrentViewId() {
  const actorRef = useDiagramActorRef();
  return useSelector(actorRef, selectViewId);
}
const selectView = (s2) => s2.context.view;
function useCurrentView() {
  const actorRef = useDiagramActorRef();
  return useSelector(actorRef, selectView, shallowEqual$1);
}
const __iconNode$x = [["path", { d: "M3 6a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-0" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-1" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-2" }], ["path", { d: "M15 18a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]], IconTransform = createReactComponent("outline", "transform", "Transform", __iconNode$x);
const __iconNode$w = [["path", { d: "M4 21v-4a3 3 0 0 1 3 -3h5", key: "svg-0" }], ["path", { d: "M9 17l3 -3l-3 -3", key: "svg-1" }], ["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-2" }], ["path", { d: "M5 11v-6a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-9.5", key: "svg-3" }]], IconFileSymlink = createReactComponent("outline", "file-symlink", "FileSymlink", __iconNode$w);
const __iconNode$v = [["path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11", key: "svg-0" }]], IconBolt = createReactComponent("outline", "bolt", "Bolt", __iconNode$v), container$2 = hstack({
  position: "absolute",
  zIndex: 1,
  justifyContent: "center",
  alignItems: "center",
  _smallZoom: {
    display: "none"
  }
}), actionButtons = hstack({
  gap: "1.5",
  justifyContent: "center",
  alignItems: "center"
});
function ElementActionButtons({
  selected: selected2 = !1,
  data: {
    hovered: isHovered = !1
  },
  buttons
}) {
  const id2 = useId$2();
  return buttons.length ? /* @__PURE__ */ jsx(
    Box,
    {
      className: container$2,
      style: {
        top: "calc(100% - 30px)",
        transform: "translateX(-50%)",
        left: "50%",
        width: "auto",
        minHeight: 30
      },
      children: /* @__PURE__ */ jsx(
        MotionDiv,
        {
          layoutRoot: !0,
          initial: !1,
          style: {
            originY: 0
          },
          animate: {
            opacity: isHovered || selected2 ? 1 : 0.75,
            scale: isHovered ? 1.1 : selected2 ? 0.9 : 0.8,
            y: isHovered || selected2 ? 6 : 0
          },
          layoutDependency: `${isHovered}-${selected2}`,
          "data-likec4-hovered": isHovered,
          className: cx("nodrag nopan", actionButtons),
          children: buttons.map((button2, index2) => /* @__PURE__ */ jsx(
            ActionIcon,
            {
              component: MotionButton,
              className: actionBtn({}),
              initial: !1,
              whileTap: { scale: 1 },
              whileHover: {
                scale: 1.3
              },
              onClick: button2.onClick,
              onDoubleClick: stopPropagation,
              children: button2.icon || /* @__PURE__ */ jsx(IconBolt, {})
            },
            `${id2}-${button2.key ?? index2}`
          ))
        }
      )
    }
  ) : null;
}
const selectSubject$1 = (state) => state.context.subject, ElementActions$2 = (props) => {
  const { enableNavigateTo, enableVscode } = useEnabledFeatures(), diagram = useDiagram(), currentViewId = useCurrentViewId(), browser = useRelationshipsBrowser(), subject = useRelationshipsBrowserState(selectSubject$1), { navigateTo, fqn: fqn2 } = props.data, buttons = useMemo(() => {
    const buttons2 = [];
    return navigateTo && enableNavigateTo && currentViewId !== navigateTo && buttons2.push({
      key: "navigate",
      icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo);
      }
    }), fqn2 !== subject && buttons2.push({
      key: "relationships",
      icon: /* @__PURE__ */ jsx(IconTransform, {}),
      onClick: (e2) => {
        e2.stopPropagation(), browser.navigateTo(fqn2, props.id);
      }
    }), enableVscode && buttons2.push({
      key: "goToSource",
      icon: /* @__PURE__ */ jsx(IconFileSymlink, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openSource({ element: fqn2 });
      }
    }), buttons2;
  }, [navigateTo, enableNavigateTo, currentViewId, fqn2, subject, enableVscode, diagram, browser, props.id]);
  return /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons,
      ...props
    }
  );
};
function CompoundNodeContainer({
  nodeProps: {
    data: {
      hovered: isHovered = !1,
      dimmed: isDimmed = !1,
      ...data
    }
  },
  className,
  children: children2,
  style: style2,
  ...rest
}) {
  let opacity = t$v(data.style.opacity ?? 100, {
    min: 0,
    max: 100
  });
  const isTransparent = opacity < 99, MIN_OPACITY = 65, borderOpacity = MIN_OPACITY + t$v((100 - MIN_OPACITY) * (opacity / 100), {
    min: 0,
    max: 100 - MIN_OPACITY
  }), compoundClass = compoundNode({
    isTransparent,
    inverseColor: opacity < 60,
    borderStyle: data.style.border ?? (isTransparent ? "dashed" : "none")
  }), depth = t$v(data.depth ?? 1, {
    min: 1,
    max: 5
  });
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      className: cx(
        compoundClass,
        className
      ),
      initial: !1,
      "data-likec4-hovered": isHovered,
      "data-likec4-color": data.color,
      "data-compound-depth": depth,
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...style2,
        // @ts-expect-error
        "--_border-transparency": `${borderOpacity}%`,
        "--_compound-transparency": `${opacity}%`
      },
      ...rest,
      children: children2
    }
  );
}
function CompoundTitle({ data }) {
  const elementIcon2 = IconRenderer({
    element: data,
    className: "likec4-compound-icon"
  });
  return /* @__PURE__ */ jsxs("div", { className: "likec4-compound-title-container", children: [
    elementIcon2,
    /* @__PURE__ */ jsx(Text, { component: "h3", className: "likec4-compound-title", truncate: "end", children: data.title })
  ] });
}
const compoundActionBtn = cva({
  base: {
    transitionDuration: "normal"
  },
  variants: {
    delay: {
      true: {
        // Debounce CSS transition
        transitionDelay: {
          base: "0.2s",
          _hover: "0s"
        }
      }
    }
  }
});
const __iconNode$u = [["path", { d: "M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v10a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3z", key: "svg-0" }], ["path", { d: "M9 10m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M15 8l2 0", key: "svg-2" }], ["path", { d: "M15 12l2 0", key: "svg-3" }], ["path", { d: "M7 16l10 0", key: "svg-4" }]], IconId = createReactComponent("outline", "id", "Id", __iconNode$u);
function CompoundDetailsButton({
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const isHoverDebounced = useDebouncedValue(isHovered, isHovered ? 130 : 0)[0] && isHovered;
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      initial: !1,
      animate: {
        scale: isHoverDebounced ? 1.2 : 1
        // opacity: isHoverDebounced ? 1 : 0.6,
      },
      whileHover: {
        scale: 1.4
      },
      whileTap: { scale: 1 },
      className: "likec4-compound-details details-button",
      children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          className: cx(
            "nodrag nopan",
            compoundActionBtn({
              delay: isHovered && !isHoverDebounced
            }),
            actionBtn({ variant: "transparent" })
          ),
          onClick,
          onDoubleClick: stopPropagation,
          children: icon2 ?? /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
        }
      )
    }
  );
}
const ElementNodeContainer = forwardRef(({
  nodeProps: {
    selected: selected2 = !1,
    selectable = !1,
    data: {
      hovered: isHovered = !1,
      dimmed: isDimmed = !1,
      ...data
    }
  },
  className,
  style: style2,
  children: children2,
  ...rest
}, ref) => {
  let scale2 = 1;
  switch (!0) {
    case isHovered:
      scale2 = 1.05;
      break;
    case selected2:
      scale2 = 1.02;
      break;
  }
  const {
    size: size2,
    padding,
    textSize
  } = ensureSizes(data.style ?? {});
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      ref,
      className: cx(
        elementNode$1(),
        "group",
        className
      ),
      initial: !1,
      ...selectable && {
        animate: {
          scale: scale2
        },
        whileTap: { scale: 0.98 }
      },
      "data-likec4-hovered": isHovered,
      "data-likec4-color": data.color,
      "data-likec4-shape": data.shape,
      "data-likec4-shape-size": size2,
      "data-likec4-spacing": padding,
      "data-likec4-text-size": textSize,
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...style2
      },
      ...rest,
      children: children2
    }
  );
});
ElementNodeContainer.displayName = "ElementNodeContainer";
function cylinderSVGPath(diameter, height, tilt = 0.07) {
  const radius = Math.round(diameter / 2), rx = radius, ry = roundDpr(tilt * radius), tiltAdjustedHeight = height - 2 * ry;
  return {
    path: `  M ${diameter},${ry}
        a ${rx},${ry} 0,0,0 ${-diameter} 0
        l 0,${tiltAdjustedHeight}
        a ${rx},${ry} 0,0,0 ${diameter} 0
        l 0,${-tiltAdjustedHeight}
        z
        `.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
function docSVGPath(width, height) {
  const waveHeight = height / 8, baseY = roundDpr(height - waveHeight / 2), amplitude = roundDpr(height / 6), radius = 6;
  return {
    path: `
    M 0 ${baseY}
    V ${radius}
    Q 0 0 ${radius} 0
    H ${width - radius}
    Q ${width} 0 ${width} ${radius}
    V ${baseY}
    C ${roundDpr(width * 0.75)} ${baseY + amplitude}, ${roundDpr(width * 0.5)} ${baseY - amplitude}, 0 ${baseY}
  `.replace(/\s+/g, " ").trim()
  };
}
function bucketSVGPath(width, height) {
  const cx2 = width / 2, topRx = roundDpr(cx2), topRy = roundDpr(Math.min(height / 8, topRx * 0.08)), bottomRx = roundDpr(topRx * 0.8), bottomRy = roundDpr(topRy * 1.05), topY = topRy, bottomY = height - bottomRy, leftBottomX = cx2 - bottomRx;
  return {
    path: `
    M ${width},${topY}
    a ${topRx},${topRy} 0,0,0 ${-width} 0
    L ${leftBottomX},${bottomY}
    a ${bottomRx},${bottomRy} 0,0,0 ${bottomRx * 2} 0
    Z
  `.replace(/\s+/g, " ").trim(),
    topRx,
    topRy,
    bottomRx,
    bottomRy
  };
}
function queueSVGPath(width, height, tilt = 0.185) {
  const diameter = height, ry = Math.round(diameter / 2), rx = roundDpr(diameter / 2 * tilt), tiltAdjustedWidth = width - 2 * rx;
  return {
    path: `
    M ${rx},0
    a ${rx},${ry} 0,0,0 0 ${diameter}
    l ${tiltAdjustedWidth},0
    a ${rx},${ry} 0,0,0 0 ${-diameter}
    z`.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
const PersonIcon = {
  width: 115,
  height: 120,
  path: "M57.9197 0C10.9124 0 33.5766 54.75 33.5766 54.75C38.6131 62.25 45.3285 60.75 45.3285 66C45.3285 70.5 39.4526 72 33.5766 72.75C24.3431 72.75 15.9489 71.25 7.55474 84.75C2.51825 93 0 120 0 120H115C115 120 112.482 93 108.285 84.75C99.8905 70.5 91.4963 72.75 82.2628 72C76.3869 71.25 70.5109 69.75 70.5109 65.25C70.5109 60.75 77.2263 62.25 82.2628 54C82.2628 54.75 104.927 0 57.9197 0V0Z"
};
function ShapeSvg({ shape, w: w2, h: h2 }) {
  switch (shape) {
    case "mobile":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w2,
            height: h2,
            rx: 6,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { "data-likec4-fill": "fill", strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 17, cy: h2 / 2, r: 12 }),
          /* @__PURE__ */ jsx("rect", { x: 33, y: 12, width: w2 - 44, height: h2 - 24, rx: 5 })
        ] })
      ] });
    case "document": {
      const { path } = docSVGPath(w2, h2);
      return /* @__PURE__ */ jsx(
        "path",
        {
          d: path,
          "data-likec4-fill": "fill",
          strokeWidth: 2
        }
      );
    }
    case "browser":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w2,
            height: h2,
            rx: 6,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { "data-likec4-fill": "fill", strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 16, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 36, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 56, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("rect", { x: 70, y: 8, width: w2 - 80, height: 17, rx: 4 }),
          /* @__PURE__ */ jsx("rect", { x: 10, y: 32, width: w2 - 20, height: h2 - 42, rx: 4 })
        ] })
      ] });
    case "person":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w2,
            height: h2,
            rx: 6,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            x: w2 - PersonIcon.width - 6,
            y: h2 - PersonIcon.height,
            width: PersonIcon.width,
            height: PersonIcon.height,
            viewBox: `0 0 ${PersonIcon.width} ${PersonIcon.height}`,
            "data-likec4-fill": "mix-stroke",
            children: /* @__PURE__ */ jsx(
              "path",
              {
                strokeWidth: 0,
                d: PersonIcon.path
              }
            )
          }
        )
      ] });
    case "queue": {
      const { path, rx, ry } = queueSVGPath(w2, h2);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry: ry - 0.75, rx, "data-likec4-fill": "mix-stroke", strokeWidth: 2 })
      ] });
    }
    case "bucket": {
      const { path, topRx, topRy } = bucketSVGPath(w2, h2);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx(
          "ellipse",
          {
            cx: w2 / 2,
            cy: topRy,
            rx: topRx,
            ry: topRy,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 2
          }
        )
      ] });
    }
    case "storage":
    case "cylinder": {
      const { path, rx, ry } = cylinderSVGPath(w2, h2);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx(
          "ellipse",
          {
            cx: rx,
            cy: ry,
            ry,
            rx: rx - 0.75,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 2
          }
        )
      ] });
    }
    default:
      return nonexhaustive(shape);
  }
}
function ShapeSvgOutline({ shape, w: w2, h: h2 }) {
  let svg;
  switch (shape) {
    case "bucket":
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: bucketSVGPath(w2 + 6, h2 + 6).path }) });
      break;
    case "queue":
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: queueSVGPath(w2 + 6, h2 + 6).path }) });
      break;
    case "document":
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: docSVGPath(w2 + 6, h2 + 6).path }) });
      break;
    case "storage":
    case "cylinder": {
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: cylinderSVGPath(w2 + 6, h2 + 6).path }) });
      break;
    }
    default: {
      svg = /* @__PURE__ */ jsx(
        "rect",
        {
          x: -3,
          y: -3,
          width: w2 + 6,
          height: h2 + 6,
          rx: 8
        }
      );
      break;
    }
  }
  return /* @__PURE__ */ jsx("g", { className: "likec4-shape-outline", children: svg });
}
function ElementShape({ data, width, height, showSeletionOutline = !0 }) {
  let w2 = width && width > 10 ? width : data.width, h2 = height && height > 10 ? height : data.height;
  const isMultiple = data.style?.multiple ?? !1, borderStyle = data.style?.border ?? "none", withBorder = borderStyle !== "none";
  if (data.shape === "rectangle")
    return /* @__PURE__ */ jsxs(
      "div",
      {
        style: {
          borderStyle
        },
        className: elementShapeRecipe({
          shapetype: "html",
          withBorder
        }),
        children: [
          isMultiple && /* @__PURE__ */ jsx("div", { className: "likec4-shape-multiple" }),
          showSeletionOutline && /* @__PURE__ */ jsx("div", { className: "likec4-shape-outline" })
        ]
      }
    );
  const className = elementShapeRecipe({
    shapetype: "svg"
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    isMultiple && /* @__PURE__ */ jsx("svg", { className, "data-likec4-shape-multiple": "true", viewBox: `0 0 ${w2} ${h2}`, children: /* @__PURE__ */ jsx(ShapeSvg, { shape: data.shape, w: w2, h: h2 }) }),
    /* @__PURE__ */ jsxs("svg", { className, viewBox: `0 0 ${w2} ${h2}`, children: [
      showSeletionOutline && /* @__PURE__ */ jsx(ShapeSvgOutline, { shape: data.shape, w: w2, h: h2 }),
      /* @__PURE__ */ jsx(ShapeSvg, { shape: data.shape, w: w2, h: h2 })
    ] })
  ] });
}
const Markdown = forwardRef(({
  value,
  textScale = 1,
  uselikec4palette = !1,
  hideIfEmpty = !1,
  emptyText = "no content",
  className,
  style: style2,
  fontSize,
  ...props
}, ref) => {
  if (value.isEmpty && hideIfEmpty)
    return null;
  const content = value.nonEmpty ? value.isMarkdown ? { dangerouslySetInnerHTML: { __html: value.html } } : { children: /* @__PURE__ */ jsx("p", { children: value.text }) } : { children: /* @__PURE__ */ jsx(Text, { component: "span", fz: "xs", c: "dimmed", style: { userSelect: "none" }, children: emptyText }) };
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...props,
      className: cx(
        markdownBlock({
          uselikec4palette,
          value: value.isMarkdown ? "markdown" : "plaintext"
        }),
        className
      ),
      style: {
        ...style2,
        ...fontSize && {
          "--text-fz": `var(--font-sizes-${fontSize}, var(--font-sizes-md))`
        },
        ...textScale !== 1 && {
          "--mantine-scale": textScale
        }
      },
      ...content
    }
  );
});
Markdown.displayName = "Markdown";
const Root$2 = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx(
  "div",
  {
    ...props,
    ref,
    className: cx(
      className,
      elementNodeData(),
      "likec4-element"
    )
  }
)), Icon = ({ data, ...props }) => /* @__PURE__ */ jsx(IconRenderer, { element: data, ...props }), Content = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx(
  "div",
  {
    ...props,
    className: cx(
      className,
      "likec4-element-node-content"
    ),
    ref
  }
)), Title = forwardRef(({ data: { title: title2, style: style2 }, className, ...props }, ref) => {
  const { size: size2 } = ensureSizes(style2), isSm = size2 === "sm" || size2 === "xs";
  return /* @__PURE__ */ jsx(
    Text,
    {
      component: "div",
      ...props,
      className: cx(
        className,
        "likec4-element-title"
      ),
      "data-likec4-node-title": "",
      lineClamp: isSm ? 2 : 3,
      ref,
      children: title2
    }
  );
}), Technology = forwardRef(({ data, children: children2, className, ...props }, ref) => {
  const text = data?.technology ?? children2;
  return e$1(text) ? /* @__PURE__ */ jsx(
    Text,
    {
      component: "div",
      ...props,
      className: cx(
        className,
        "likec4-element-technology"
      ),
      "data-likec4-node-technology": "",
      ref,
      children: text
    }
  ) : null;
}), Description = forwardRef(({ data: { description: description2, style: style2 }, className, ...props }, ref) => {
  if (!description2)
    return null;
  const desc = RichText.from(description2), { size: size2 } = ensureSizes(style2);
  return /* @__PURE__ */ jsx(
    Markdown,
    {
      ...props,
      className: cx(
        className,
        "likec4-element-description",
        css({
          lineClamp: size2 === "sm" || size2 === "xs" ? 3 : 5
        })
      ),
      "data-likec4-node-description": "",
      value: desc,
      uselikec4palette: !0,
      hideIfEmpty: !0,
      style: {
        // Workaround for lineClamp not working with nested TABLE elements (if markdown has tables)
        maxHeight: desc.isMarkdown ? "8rem" : void 0
      },
      ref
    }
  );
});
function ElementData({ iconSize: iconSize2, data }) {
  return /* @__PURE__ */ jsxs(
    Root$2,
    {
      style: e$4(iconSize2) ? {
        // @ts-ignore
        "--likec4-icon-size": `${iconSize2}px`
      } : void 0,
      children: [
        /* @__PURE__ */ jsx(Icon, { data }),
        /* @__PURE__ */ jsxs(Content, { children: [
          /* @__PURE__ */ jsx(Title, { data }),
          /* @__PURE__ */ jsx(Technology, { data }),
          /* @__PURE__ */ jsx(Description, { data })
        ] })
      ]
    }
  );
}
ElementData.Root = Root$2;
ElementData.Icon = Icon;
ElementData.Content = Content;
ElementData.Title = Title;
ElementData.Technology = Technology;
ElementData.Description = Description;
const container$1 = css({
  position: "absolute",
  top: "0.5",
  right: "0.5",
  _shapeBrowser: {
    right: "[5px]"
  },
  _shapeCylinder: {
    top: "[14px]"
  },
  _shapeStorage: {
    top: "[14px]"
  },
  _shapeQueue: {
    top: "[1px]",
    right: "3"
    // 12px
  },
  _smallZoom: {
    display: "none"
  },
  _print: {
    display: "none"
  }
});
function ElementDetailsButton({
  selected: selected2 = !1,
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  return /* @__PURE__ */ jsx(Box, { className: cx(container$1, "details-button"), children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      className: cx("nodrag nopan", actionBtn({ variant: "transparent" })),
      component: MotionButton,
      initial: !1,
      style: {
        originX: 0.45,
        originY: 0.55
      },
      animate: isHovered || selected2 ? {
        scale: 1.2,
        opacity: 0.8
      } : {
        scale: 1,
        opacity: 0.5
      },
      whileHover: {
        scale: 1.4,
        opacity: 1
      },
      whileTap: { scale: 1.15 },
      onClick,
      onDoubleClick: stopPropagation,
      children: icon2 ?? /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
    }
  ) });
}
const ElementDetailsButtonWithHandler$2 = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
      }
    }
  );
};
function ElementNode$2(props) {
  const { enableElementTags } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { layoutId: props.id, nodeProps: props, children: [
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$2, { ...props }),
    /* @__PURE__ */ jsx(ElementActions$2, { ...props }),
    /* @__PURE__ */ jsx(ElementPorts$1, { ...props })
  ] }, props.id);
}
function CompoundNode$1(props) {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsxs(CompoundNodeContainer, { layoutId: props.id, nodeProps: props, children: [
    /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
    /* @__PURE__ */ jsx(
      CompoundDetailsButton,
      {
        ...props,
        onClick: (e2) => {
          e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
        }
      }
    ),
    /* @__PURE__ */ jsx(CompoundPorts$1, { ...props })
  ] }, props.id);
}
const ElementPorts$1 = ({ data: { ports, height: h2 } }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.in.length + 1))}px`
      }
    },
    id2
  )),
  ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.out.length + 1))}px`
      }
    },
    id2
  ))
] }), CompoundPorts$1 = ({ data }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  data.ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  )),
  data.ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  ))
] });
const __iconNode$t = [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]], IconChevronLeft = createReactComponent("outline", "chevron-left", "ChevronLeft", __iconNode$t), nodeTypes$2 = {
  element: ElementNode$2,
  compound: CompoundNode$1,
  empty: EmptyNode
}, edgeTypes$3 = {
  relationship: RelationshipEdge$3
};
function RelationshipsBrowser({ actorRef }) {
  const initialRef = useRef(null);
  return initialRef.current == null && (initialRef.current = {
    initialNodes: [],
    initialEdges: []
  }), /* @__PURE__ */ jsx(RelationshipsBrowserActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(ReactFlowProvider, { ...initialRef.current, children: /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(RelationshipsBrowserXYFlow, {}) }) }) }) });
}
const selector$7 = (state) => ({
  isActive: state.hasTag("active"),
  nodes: state.context.xynodes,
  edges: state.context.xyedges
}), selectorEq$1 = (a2, b2) => a2.isActive === b2.isActive && shallowEqual$1(a2.nodes, b2.nodes) && shallowEqual$1(a2.edges, b2.edges), RelationshipsBrowserXYFlow = memo$3(() => {
  const browser = useRelationshipsBrowser(), {
    isActive,
    nodes,
    edges
  } = useRelationshipsBrowserState(
    selector$7,
    selectorEq$1
  );
  return /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      id: browser.rootElementId,
      nodes,
      edges,
      className: cx(
        isActive ? "initialized" : "not-initialized",
        "relationships-browser"
      ),
      nodeTypes: nodeTypes$2,
      edgeTypes: edgeTypes$3,
      fitView: !1,
      onNodeClick: useCallbackRef((_e, node2) => {
        _e.stopPropagation(), browser.send({ type: "xyflow.nodeClick", node: node2 });
      }),
      onEdgeClick: useCallbackRef((_e, edge) => {
        _e.stopPropagation(), browser.send({ type: "xyflow.edgeClick", edge });
      }),
      onPaneClick: useCallbackRef((_e) => {
        _e.stopPropagation(), browser.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: useCallbackRef((_e) => {
        browser.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: useCallbackRef(() => {
        browser.send({ type: "xyflow.resized" });
      }),
      onNodesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      onEdgeMouseEnter: useCallbackRef((_event, edge) => {
        edge.data.hovered || browser.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef((_event, edge) => {
        edge.data.hovered && browser.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      onSelectionChange: useCallbackRef((params) => {
        browser.send({ type: "xyflow.selectionChange", ...params });
      }),
      nodesDraggable: !1,
      nodesSelectable: !0,
      pannable: !0,
      zoomable: !0,
      children: /* @__PURE__ */ jsx(RelationshipsBrowserInner, {})
    }
  );
}), selector2 = (state) => ({
  subjectId: state.context.subject,
  viewId: state.context.viewId,
  scope: state.context.scope,
  closeable: state.context.closeable
}), RelationshipsBrowserInner = memo$3(() => {
  const browser = useRelationshipsBrowser(), {
    subjectId,
    viewId,
    scope,
    closeable
  } = useRelationshipsBrowserState(selector2), store = useStoreApi(), instance = useReactFlow();
  useEffect(() => {
    instance.viewportInitialized && browser.send({ type: "xyflow.init", instance, store });
  }, [store, instance.viewportInitialized, browser]);
  const layouted = useRelationshipsView(subjectId, viewId, scope), [historySubjectId, historyOps, { history, current: current2 }] = useStateHistory(subjectId);
  useEffect(() => {
    historySubjectId !== subjectId && historyOps.set(subjectId);
  }, [subjectId]), useEffect(() => {
    historySubjectId !== subjectId && browser.navigateTo(historySubjectId);
  }, [historySubjectId, browser]), useRafEffect(() => {
    browser.updateView(layouted);
  }, [layouted, browser]);
  const hasStepBack = current2 > 0, hasStepForward = current2 + 1 < history.length;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      TopLeftPanel$1,
      {
        hasStepBack,
        hasStepForward,
        onStepBack: () => historyOps.back(),
        onStepForward: () => historyOps.forward()
      }
    ),
    closeable && /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
      ActionIcon,
      {
        variant: "default",
        color: "gray",
        onClick: (e2) => {
          e2.stopPropagation(), browser.close();
        },
        children: /* @__PURE__ */ jsx(IconX, {})
      }
    ) })
  ] });
}), TopLeftPanel$1 = ({
  hasStepBack,
  hasStepForward,
  onStepBack,
  onStepForward
}) => /* @__PURE__ */ jsx(Panel, { position: "top-left", children: /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
  /* @__PURE__ */ jsxs(AnimatePresence, { mode: "popLayout", children: [
    hasStepBack && /* @__PURE__ */ jsx(
      m$1.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), onStepBack();
            },
            children: /* @__PURE__ */ jsx(IconChevronLeft, {})
          }
        )
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      m$1.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), onStepForward();
            },
            children: /* @__PURE__ */ jsx(IconChevronRight, {})
          }
        )
      },
      "forward"
    )
  ] }),
  /* @__PURE__ */ jsx(SelectElement, {})
] }) }), fqn = css({
  display: "inline-block",
  fontSize: "sm",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "[3px 6px]",
  borderRadius: 3,
  background: "var(--likec4-palette-fill)/75",
  lineHeight: 1.2,
  color: "var(--likec4-palette-hiContrast)"
  // selectors: {
  //   [`${whereDark} &`]: {
  //   }
  // }
}), relationshipStat = css({
  _light: {
    background: "mantine.colors.gray[1]",
    "&[data-missing": {}
  },
  // [`&[data-zero]`]: {
  //   color: mantine.colors.dimmed
  // },
  // [`${whereLight} &[data-zero]`]: {
  //   background: mantine.colors.gray[3]
  // },
  "&[data-missing]": {
    color: "mantine.colors.orange[4]",
    background: "mantine.colors.orange[8]/15",
    borderColor: "mantine.colors.orange[5]/20",
    _light: {
      color: "mantine.colors.orange[8]"
    }
  }
}), xyflow$1 = css({
  flex: "1 1 100%",
  position: "relative",
  width: "100%",
  height: "100%",
  background: "mantine.colors.body",
  border: "1px solid {colors.mantine.colors.defaultBorder}",
  borderRadius: "sm",
  _light: {
    borderColor: "mantine.colors.gray[3]",
    background: "mantine.colors.gray[1]"
  }
});
css({
  _before: {
    content: '"scope:"',
    position: "absolute",
    top: "0",
    left: "2",
    fontSize: "xxs",
    fontWeight: 500,
    lineHeight: "1",
    color: "mantine.colors.dimmed",
    opacity: 0.85,
    transform: "translateY(-100%) translateY(-2px)"
  },
  _light: {
    "& .mantine-SegmentedControl-root": {
      background: "mantine.colors.gray[3]"
    }
  }
});
css({
  display: "inline-block",
  fontSize: "xl",
  fontWeight: 600,
  padding: "[1px 5px]",
  minWidth: 24,
  textAlign: "center",
  borderRadius: "sm",
  background: "mantine.colors.dark[7]",
  color: "mantine.colors.defaultColor",
  "&[data-zero]": {
    color: "mantine.colors.dimmed"
  },
  "&[data-missing]": {
    color: "mantine.colors.orange[4]",
    background: "mantine.colors.orange[8]/20"
  }
  // _light: {
  //   background: 'mantine.colors.gray[4]',
  //   color: 'mantine.colors.dark[6]',
  //   [`&[data-zero]`]: {
  //     background: 'mantine.colors.gray[3]',
  //   },
  //   [`&[data-missing]`]: {
  //     color: 'mantine.colors.orange[8]',
  //   },
  // },
});
const __iconNode$s = [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M13 18l6 -6", key: "svg-1" }], ["path", { d: "M13 6l6 6", key: "svg-2" }]], IconArrowRight = createReactComponent("outline", "arrow-right", "ArrowRight", __iconNode$s);
const __iconNode$r = [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]], IconExternalLink = createReactComponent("outline", "external-link", "ExternalLink", __iconNode$r), Tooltip$5 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function TabPanelRelationships({
  node: node2,
  element
}) {
  const diagram = useDiagram(), delailsActor = useElementDetailsActorRef(), relationshipsBrowserActor = useSelector(
    delailsActor,
    useCallback((s2) => s2.children[`${delailsActor.id}-relationships`], [delailsActor.id])
  ), incoming = [...element.incoming()].map((r2) => r2.id), outgoing = [...element.outgoing()].map((r2) => r2.id), incomingInView = node2 ? n([...node2.incoming()].flatMap((e2) => e2.$edge.relations)) : [], outgoingInView = node2 ? n([...node2.outgoing()].flatMap((e2) => e2.$edge.relations)) : [], notIncludedRelations = [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length;
  return /* @__PURE__ */ jsxs(Stack, { gap: "xs", pos: "relative", w: "100%", h: "100%", children: [
    incoming.length + outgoing.length > 0 && /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
      /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsxs(Group, { gap: 8, mb: 4, wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "incoming",
            total: incoming.length,
            included: incomingInView.length
          }
        ),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(Text, { className: fqn, children: nameFromFqn(element.id) }),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "outgoing",
            total: outgoing.length,
            included: outgoingInView.length
          }
        )
      ] }) }),
      notIncludedRelations > 0 && /* @__PURE__ */ jsx(Tooltip$5, { label: "Current view does not include some relationships", children: /* @__PURE__ */ jsxs(
        Group,
        {
          mt: "xs",
          gap: 6,
          c: "orange",
          style: { cursor: "pointer" },
          children: [
            /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: 14 } }),
            /* @__PURE__ */ jsxs(Text, { fz: "sm", children: [
              notIncludedRelations,
              " relationship",
              notIncludedRelations > 1 ? "s are" : " is",
              " hidden"
            ] })
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx(Box$1, { className: xyflow$1, children: relationshipsBrowserActor && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(RelationshipsBrowser, { actorRef: relationshipsBrowserActor }),
      /* @__PURE__ */ jsx(Box$1, { pos: "absolute", top: 12, right: 12, children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          size: "md",
          variant: "default",
          radius: "sm",
          onClick: (e2) => {
            e2.stopPropagation();
            const {
              subject,
              scope,
              viewId
            } = relationshipsBrowserActor.getSnapshot().context;
            diagram.overlays().send({
              type: "open.relationshipsBrowser",
              subject,
              scope,
              viewId
            });
          },
          children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "70%" } })
        }
      ) })
    ] }) })
  ] });
}
function RelationshipsStat({
  title: title2,
  total,
  included
}) {
  return /* @__PURE__ */ jsx(
    Paper,
    {
      withBorder: !0,
      shadow: "none",
      className: relationshipStat,
      px: "md",
      py: "xs",
      radius: "md",
      mod: {
        zero: total === 0,
        missing: total !== included
      },
      children: /* @__PURE__ */ jsxs(Stack, { gap: 4, align: "flex-end", children: [
        /* @__PURE__ */ jsx(Text, { component: "div", c: total !== included ? "orange" : "dimmed", tt: "uppercase", fw: 600, fz: 10, lh: 1, children: title2 }),
        /* @__PURE__ */ jsx(Text, { fw: 600, fz: "xl", component: "div", lh: 1, children: total !== included ? /* @__PURE__ */ jsxs(Fragment, { children: [
          included,
          " / ",
          total
        ] }) : /* @__PURE__ */ jsx(Fragment, { children: total }) })
      ] })
    }
  );
}
const treeNodeLabel = css({
  marginTop: "sm",
  marginBottom: "sm"
}), elementLabel = css({
  display: "inline-flex",
  transition: "fast",
  border: "1px dashed",
  borderColor: "mantine.colors.defaultBorder",
  borderRadius: "sm",
  px: "md",
  py: "xs",
  alignItems: "center",
  cursor: "pointer",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.dark[1]"
  },
  "& > *": {
    transition: "fast"
  },
  _hover: {
    transitionTimingFunction: "out",
    borderStyle: "solid",
    color: "mantine.colors.defaultColor",
    background: "mantine.colors.defaultHover",
    "& > *": {
      transitionTimingFunction: "out",
      transform: "translateX(1px)"
    }
  }
}), ElementLabel = ({
  element
}) => /* @__PURE__ */ jsx(Box$1, { className: elementLabel, children: /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", children: element.title }) }), setHoveredNode$1 = () => {
};
function TabPanelStructure({
  element
}) {
  const tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode$1;
  const data = useMemo(() => {
    let seq = 1;
    const messageNode = (label2) => ({
      label: label2,
      value: `msg${seq++}`,
      type: "message",
      children: []
    }), current2 = {
      label: /* @__PURE__ */ jsx(ElementLabel, { type: "current", element }),
      value: element.id,
      element,
      type: "current",
      children: [...element.children()].map((child) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "descedant", element: child }),
        value: child.id,
        element: child,
        type: "descedant",
        children: []
      }))
    };
    return current2.children.length === 0 && current2.children.push(
      messageNode(/* @__PURE__ */ jsx(Pill, { radius: "sm", children: "no nested" }))
    ), [
      [...element.ancestors()].reduce((acc, parent) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "ancestor", element: parent }),
        value: parent.id,
        element: parent,
        type: "ancestor",
        children: [acc]
      }), current2)
    ];
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", title: "In development", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: [
      "We need your feedback. Share your thoughts and ideas -",
      " ",
      /* @__PURE__ */ jsx(
        Anchor,
        {
          fz: "sm",
          fw: 500,
          underline: "hover",
          c: "orange",
          href: "https://github.com/likec4/likec4/discussions/",
          target: "_blank",
          children: "GitHub discussions"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "xl",
        allowRangeSelection: !1,
        expandOnClick: !1,
        expandOnSpace: !1,
        classNames: {
          label: treeNodeLabel
        },
        data,
        tree
      }
    )
  ] });
}
const __iconNode$q = [["path", { d: "M12 4l-8 4l8 4l8 -4l-8 -4", key: "svg-0" }], ["path", { d: "M4 12l8 4l8 -4", key: "svg-1" }], ["path", { d: "M4 16l8 4l8 -4", key: "svg-2" }]], IconStack2 = createReactComponent("outline", "stack-2", "Stack2", __iconNode$q), Divider$1 = Divider$2.withProps({
  mb: 8,
  labelPosition: "left",
  variant: "dashed"
}), Tooltip$4 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
}), SmallLabel = Text.withProps({
  component: "div",
  fz: 11,
  fw: 500,
  c: "dimmed",
  lh: 1
}), PropertyLabel = Text.withProps({
  component: "div",
  fz: "xs",
  c: "dimmed",
  className: propertyLabel
}), MIN_PADDING = 24, TABS = ["Properties", "Relationships", "Views", "Structure", "Deployments"];
function ElementDetailsCard({
  viewId,
  fromNode,
  rectFromNode,
  fqn: fqn2,
  onClose
}) {
  const [opened, setOpened] = useState(!1), windowSize = useViewportSize(), windowWidth = windowSize.width || window.innerWidth || 1200, windowHeight = windowSize.height || window.innerHeight || 800, [activeTab, setActiveTab] = useSessionStorage({
    key: "likec4:element-details:active-tab",
    defaultValue: "Properties"
  }), diagram = useDiagram(), viewModel = useCurrentViewModel(), nodeModel = fromNode ? viewModel.findNode(fromNode) : viewModel.findNodeWithElement(fqn2), elementModel = viewModel.$model.element(fqn2), [viewsOf, otherViews] = t$s(
    [...elementModel.views()],
    t$f((v2) => v2.$view),
    t$a((v2) => v2._type === "element" && v2.viewOf === fqn2)
  );
  let defaultView2 = nodeModel?.navigateTo?.$view ?? elementModel.defaultView?.$view ?? null;
  defaultView2?.id === viewId && (defaultView2 = null);
  const defaultLink = t$b(elementModel.links), controls = useDragControls(), isCompound = (nodeModel?.$node.children?.length ?? 0) > 0, _width = Math.min(700, windowWidth - MIN_PADDING * 2), _height = Math.min(650, windowHeight - MIN_PADDING * 2), fromPositon = rectFromNode ? {
    x: rectFromNode.x + (isCompound ? rectFromNode.width - _width / 2 : rectFromNode.width / 2),
    y: rectFromNode.y + (isCompound ? 0 : rectFromNode.height / 2)
  } : {
    x: windowWidth / 2,
    y: windowHeight / 2
  }, fromScale = rectFromNode ? Math.min(rectFromNode.width / _width, rectFromNode.height / _height, 0.9) : 1, left = Math.round(
    t$v(fromPositon.x - _width / 2, {
      min: MIN_PADDING,
      max: windowWidth - _width - MIN_PADDING
    })
  ), top = Math.round(
    t$v(fromPositon.y - (isCompound ? 0 : 60), {
      min: MIN_PADDING,
      max: windowHeight - _height - MIN_PADDING
    })
  ), originX = t$v((fromPositon.x - left) / _width, {
    min: 0.1,
    max: 0.9
  }), originY = t$v((fromPositon.y - top) / _height, {
    min: 0.1,
    max: 0.9
  }), width = useMotionValue(_width), height = useMotionValue(_height);
  useUpdateEffect(() => {
    width.set(_width), height.set(_height);
  }, [_width, _height]);
  const handleDrag = useCallback((_, info) => {
    width.set(Math.max(width.get() + info.delta.x, 320)), height.set(Math.max(height.get() + info.delta.y, 300));
  }, []), ref = useRef(null), onCloseRef = useSyncedRef(onClose), close = useDebouncedCallback$1(
    () => {
      onCloseRef.current();
    },
    [],
    50
  ), notation = nodeModel?.$node.notation ?? null, elementIcon$1$1 = IconRenderer({
    element: {
      id: fqn2,
      title: elementModel.title,
      icon: nodeModel?.icon ?? elementModel.icon
    },
    className: elementIcon$1
  });
  return useTimeoutEffect(() => {
    ref.current?.open || ref.current?.showModal();
  }, 20), useTimeoutEffect(() => {
    setOpened(!0);
  }, 220), /* @__PURE__ */ jsx(
    m$1.dialog,
    {
      ref,
      className: cx(dialog$1, ReactRemoveScroll.classNames.fullWidth),
      layout: !0,
      initial: {
        [backdropBlur$1]: "0px",
        [backdropOpacity$1]: "5%"
      },
      animate: {
        [backdropBlur$1]: "3px",
        [backdropOpacity$1]: "60%"
      },
      exit: {
        [backdropBlur$1]: "0px",
        [backdropOpacity$1]: "0%",
        transition: {
          duration: 0.1
        }
      },
      onClick: (e2) => {
        e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG" && ref.current?.close();
      },
      onDoubleClick: stopPropagation,
      onPointerDown: stopPropagation,
      onClose: (e2) => {
        e2.stopPropagation(), close();
      },
      children: /* @__PURE__ */ jsx(ReactRemoveScroll, { forwardProps: !0, removeScrollBar: !1, children: /* @__PURE__ */ jsxs(
        m$1.div,
        {
          layout: !0,
          layoutRoot: !0,
          drag: !0,
          dragControls: controls,
          dragElastic: 0,
          dragMomentum: !1,
          dragListener: !1,
          "data-likec4-color": nodeModel?.color ?? elementModel.color,
          className: card$1,
          initial: {
            top,
            left,
            width: _width,
            height: _height,
            opacity: 0,
            originX,
            originY,
            scale: Math.max(fromScale, 0.65)
          },
          animate: {
            opacity: 1,
            scale: 1
          },
          exit: {
            opacity: 0,
            scale: 0.9,
            translateY: -10,
            transition: {
              duration: 0.1
            }
          },
          style: {
            width,
            height
          },
          children: [
            /* @__PURE__ */ jsxs("div", { className: cardHeader, onPointerDown: (e2) => controls.start(e2), children: [
              /* @__PURE__ */ jsxs(HStack, { alignItems: "start", justify: "space-between", gap: "sm", mb: "sm", flexWrap: "nowrap", children: [
                /* @__PURE__ */ jsxs(HStack, { alignItems: "start", gap: "sm", style: { cursor: "default" }, flexWrap: "nowrap", children: [
                  elementIcon$1$1,
                  /* @__PURE__ */ jsxs("div", { children: [
                    /* @__PURE__ */ jsx(
                      Text,
                      {
                        component: "div",
                        className: title$2,
                        children: elementModel.title
                      }
                    ),
                    notation && /* @__PURE__ */ jsx(Text, { component: "div", c: "dimmed", fz: "sm", fw: 500, lh: 1.3, lineClamp: 1, children: notation })
                  ] })
                ] }),
                /* @__PURE__ */ jsx(
                  CloseButton,
                  {
                    size: "lg",
                    onClick: (e2) => {
                      e2.stopPropagation(), close();
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs(HStack, { alignItems: "baseline", gap: "sm", flexWrap: "nowrap", children: [
                /* @__PURE__ */ jsxs("div", { children: [
                  /* @__PURE__ */ jsx(SmallLabel, { children: "kind" }),
                  /* @__PURE__ */ jsx(
                    Badge,
                    {
                      radius: "sm",
                      size: "sm",
                      fw: 600,
                      color: "gray",
                      style: {
                        cursor: "pointer"
                      },
                      onClick: (e2) => {
                        e2.stopPropagation(), diagram.openSearch(`kind:${elementModel.kind}`);
                      },
                      children: elementModel.kind
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxs("div", { style: { flex: 1 }, children: [
                  /* @__PURE__ */ jsx(SmallLabel, { children: "tags" }),
                  /* @__PURE__ */ jsxs(Flex, { gap: 4, flex: 1, mt: 6, wrap: "wrap", children: [
                    elementModel.tags.map((tag) => /* @__PURE__ */ jsx(
                      ElementTag,
                      {
                        tag,
                        cursor: "pointer",
                        onClick: (e2) => {
                          e2.stopPropagation(), diagram.openSearch(`#${tag}`);
                        }
                      },
                      tag
                    )),
                    elementModel.tags.length === 0 && /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: "" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxs(
                  ActionIconGroup,
                  {
                    style: {
                      alignSelf: "flex-start"
                    },
                    children: [
                      defaultLink && /* @__PURE__ */ jsx(
                        ActionIcon,
                        {
                          component: "a",
                          href: defaultLink.url,
                          target: "_blank",
                          size: "lg",
                          variant: "default",
                          radius: "sm",
                          children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "65%" } })
                        }
                      ),
                      /* @__PURE__ */ jsx(IfEnabled, { feature: "Vscode", children: /* @__PURE__ */ jsx(Tooltip$4, { label: "Open source", children: /* @__PURE__ */ jsx(
                        ActionIcon,
                        {
                          size: "lg",
                          variant: "default",
                          radius: "sm",
                          onClick: (e2) => {
                            e2.stopPropagation(), diagram.openSource({
                              element: elementModel.id
                            });
                          },
                          children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "62%" } })
                        }
                      ) }) }),
                      defaultView2 && /* @__PURE__ */ jsx(Tooltip$4, { label: "Open default view", children: /* @__PURE__ */ jsx(
                        ActionIcon,
                        {
                          size: "lg",
                          variant: "default",
                          radius: "sm",
                          onClick: (e2) => {
                            e2.stopPropagation(), diagram.navigateTo(defaultView2.id, fromNode ?? void 0);
                          },
                          children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "70%" } })
                        }
                      ) })
                    ]
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsx(MetadataProvider, { children: /* @__PURE__ */ jsxs(
              Tabs,
              {
                value: activeTab,
                onChange: (v2) => setActiveTab(v2),
                variant: "none",
                classNames: {
                  root: tabsRoot,
                  list: tabsList,
                  tab: tabsTab,
                  panel: tabsPanel
                },
                children: [
                  /* @__PURE__ */ jsx(TabsList, { children: TABS.map((tab) => /* @__PURE__ */ jsx(TabsTab, { value: tab, children: tab }, tab)) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Properties", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "scroll", offsetScrollbars: !0, children: /* @__PURE__ */ jsxs(Box$1, { className: propertiesGrid, pt: "xs", children: [
                    elementModel.hasSummary && /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "summary" }),
                      /* @__PURE__ */ jsx(Markdown, { value: elementModel.summary })
                    ] }),
                    /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "description" }),
                      /* @__PURE__ */ jsx(
                        Markdown,
                        {
                          value: elementModel.description,
                          emptyText: "no description"
                        }
                      )
                    ] }),
                    elementModel.technology && /* @__PURE__ */ jsx(ElementProperty, { title: "technology", children: elementModel.technology }),
                    elementModel.links.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "links" }),
                      /* @__PURE__ */ jsx(HStack, { gap: "xs", flexWrap: "wrap", children: elementModel.links.map((link, i2) => /* @__PURE__ */ jsx(Link, { value: link }, i2)) })
                    ] }),
                    elementModel.$element.metadata && /* @__PURE__ */ jsx(ElementMetata, { value: elementModel.$element.metadata })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Relationships", children: /* @__PURE__ */ jsx(
                    DiagramFeatures,
                    {
                      overrides: {
                        enableRelationshipBrowser: !1,
                        enableNavigateTo: !1
                      },
                      children: opened && activeTab === "Relationships" && /* @__PURE__ */ jsx(
                        TabPanelRelationships,
                        {
                          element: elementModel,
                          node: nodeModel ?? null
                        }
                      )
                    }
                  ) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Views", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Stack, { gap: "lg", children: [
                    viewsOf.length > 0 && /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(Divider$1, { label: "views of the element (scoped)" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "sm", children: viewsOf.map((view) => /* @__PURE__ */ jsx(
                        ViewButton$1,
                        {
                          view,
                          onNavigateTo: (to2) => diagram.navigateTo(to2, fromNode ?? void 0)
                        },
                        view.id
                      )) })
                    ] }),
                    otherViews.length > 0 && /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(Divider$1, { label: "views including this element" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "sm", children: otherViews.map((view) => /* @__PURE__ */ jsx(
                        ViewButton$1,
                        {
                          view,
                          onNavigateTo: (to2) => diagram.navigateTo(to2, fromNode ?? void 0)
                        },
                        view.id
                      )) })
                    ] })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Structure", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabPanelStructure, { element: elementModel }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Deployments", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabPanelDeployments, { elementFqn: elementModel.id }) }) })
                ]
              }
            ) }),
            /* @__PURE__ */ jsx(
              m$1.div,
              {
                className: resizeHandle,
                drag: !0,
                dragElastic: 0,
                dragMomentum: !1,
                onDrag: handleDrag,
                dragConstraints: { top: 0, left: 0, right: 0, bottom: 0 }
              }
            )
          ]
        }
      ) })
    }
  );
}
const ViewButton$1 = ({
  view,
  onNavigateTo
}) => /* @__PURE__ */ jsx(UnstyledButton, { className: viewButton$1, onClick: (e2) => onNavigateTo(view.id, e2), children: /* @__PURE__ */ jsxs(Group, { gap: 6, align: "start", wrap: "nowrap", children: [
  /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", children: view._type === "deployment" ? /* @__PURE__ */ jsx(IconStack2, { stroke: 1.8 }) : /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
  /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { component: "div", className: viewButtonTitle, lineClamp: 1, children: view.title || "untitled" }) })
] }) });
function ElementProperty({
  title: title2,
  emptyValue = "undefined",
  children: children2,
  style: style2,
  ...props
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: title2 }),
    /* @__PURE__ */ jsx(
      Text,
      {
        component: "div",
        ...e$5(children2) && { c: "dimmed" },
        fz: "md",
        style: {
          whiteSpace: "preserve-breaks",
          userSelect: "all",
          ...style2
        },
        ...props,
        children: children2 || emptyValue
      }
    )
  ] });
}
function ElementMetata({
  value: metadata
}) {
  const metadataEntries = t$o(metadata).sort(([a2], [b2]) => a2.localeCompare(b2));
  return /* @__PURE__ */ jsx(MetadataProvider, { children: /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { style: { justifySelf: "end", textAlign: "right" }, children: "metadata" }),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: css({
          display: "grid",
          gridTemplateColumns: "min-content 1fr",
          gridAutoRows: "min-content",
          gap: "[12px 16px]",
          alignItems: "baseline",
          justifyItems: "stretch"
        }),
        children: metadataEntries.map(([key2, value]) => /* @__PURE__ */ jsx(MetadataValue, { label: key2, value }, key2))
      }
    )
  ] }) });
}
const selector$6 = (s2) => ({
  viewId: s2.context.currentView.id,
  fromNode: s2.context.initiatedFrom.node,
  rectFromNode: s2.context.initiatedFrom.clientRect,
  fqn: s2.context.subject
});
function ElementDetails({
  actorRef,
  onClose
}) {
  const props = useSelector(
    actorRef,
    selector$6,
    shallowEqual$1
  );
  return /* @__PURE__ */ jsx(ElementDetailsActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(
    ElementDetailsCard,
    {
      onClose,
      ...props
    }
  ) });
}
const backdropBlur = "--_blur", backdropOpacity = "--_opacity", cssVarLevel = "--_level", Overlay = forwardRef(({
  onClose,
  className,
  classes: classes2,
  overlayLevel = 0,
  children: children2,
  fullscreen = !1,
  withBackdrop = !0,
  backdrop,
  openDelay = 130,
  ...rest
}, ref) => {
  const [opened, setOpened] = useState(openDelay === 0), focusTrapRef = useFocusTrap(opened), dialogRef = useRef(null), isClosingRef = useRef(!1), motionNotReduced = useReducedMotionConfig() !== !0, onCloseRef = useRef(onClose);
  onCloseRef.current = onClose;
  const close = useDebouncedCallback$1(
    () => {
      isClosingRef.current || (isClosingRef.current = !0, onCloseRef.current());
    },
    [],
    50
  );
  useLayoutEffect(() => {
    dialogRef.current?.open || dialogRef.current?.showModal();
  }, []), useTimeoutEffect(() => {
    setOpened(!0);
  }, openDelay > 0 ? openDelay : void 0);
  const overlayRecipe = overlay({
    fullscreen,
    withBackdrop
  });
  let targetBackdropOpacity = overlayLevel > 0 ? "50%" : "60%";
  return backdrop?.opacity !== void 0 && (targetBackdropOpacity = `${backdrop.opacity * 100}%`), /* @__PURE__ */ jsx(
    m$1.dialog,
    {
      ref: useMergedRef(
        dialogRef,
        focusTrapRef,
        ref
      ),
      className: cx(
        classes2?.dialog,
        className,
        overlayRecipe,
        // styles.dialog,
        fullscreen && ReactRemoveScroll.classNames.fullWidth
      ),
      layout: !0,
      style: {
        // @ts-ignore
        [cssVarLevel]: overlayLevel
      },
      ...motionNotReduced ? {
        initial: {
          [backdropBlur]: "0px",
          [backdropOpacity]: "0%",
          scale: 0.85,
          // originY: 0.4,
          // translateY: -10,
          opacity: 0
        },
        animate: {
          [backdropBlur]: overlayLevel > 0 ? "4px" : "8px",
          [backdropOpacity]: targetBackdropOpacity,
          scale: 1,
          opacity: 1,
          translateY: 0
          // transition: {
          //   delay: 0.075,
          // },
        },
        exit: {
          opacity: 0,
          scale: 0.98,
          translateY: -20,
          // transition: {
          //   duration: 0.1,
          // },
          [backdropBlur]: "0px",
          [backdropOpacity]: "0%"
        }
      } : {
        initial: {
          [backdropBlur]: "8px",
          [backdropOpacity]: targetBackdropOpacity
        }
      },
      onClick: (e2) => {
        if (e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG") {
          dialogRef.current?.close();
          return;
        }
      },
      onCancel: (e2) => {
        e2.preventDefault(), e2.stopPropagation(), close();
      },
      onDoubleClick: stopPropagation,
      onPointerDown: stopPropagation,
      onClose: (e2) => {
        e2.stopPropagation(), close();
      },
      ...rest,
      children: /* @__PURE__ */ jsx(ReactRemoveScroll, { forwardProps: !0, children: /* @__PURE__ */ jsx(
        "div",
        {
          className: cx(
            classes2?.body,
            "likec4-overlay-body"
          ),
          children: opened && /* @__PURE__ */ jsx(Fragment, { children: children2 })
        }
      ) })
    }
  );
});
Overlay.displayName = "Overlay";
const finalize$1 = (elements, explicits) => elements.size > 2 && explicits.size !== elements.size ? new Set(sortParentsFirst([
  ...treeFromElements(elements).flatten(),
  ...explicits
])) : elements.size > 1 ? new Set(sortParentsFirst([...elements])) : elements;
function computeEdgeDetailsViewData(edges, view) {
  const sources = /* @__PURE__ */ new Set(), relationships = /* @__PURE__ */ new Set(), targets = /* @__PURE__ */ new Set(), explicit = {
    sources: /* @__PURE__ */ new Set(),
    targets: /* @__PURE__ */ new Set()
  }, addExplicit = (el, type) => {
    type === "source" ? (sources.add(el), explicit.sources.add(el)) : (targets.add(el), explicit.targets.add(el));
  };
  for (const edgeId of edges) {
    const edge = view.findEdge(edgeId), _relationships = edge ? [...edge.relationships("model")] : [];
    if (!edge || !t$q(_relationships, 1) || !edge.source.hasElement() || !edge.target.hasElement())
      continue;
    const source = edge.source.element, target = edge.target.element;
    addExplicit(source, "source"), addExplicit(target, "target");
    for (const relationship of _relationships) {
      if (relationships.add(relationship), relationship.source !== source) {
        addExplicit(relationship.source, "source");
        for (const parent of relationship.source.ancestors()) {
          if (parent === source)
            break;
          sources.add(parent);
        }
      }
      if (relationship.target !== target) {
        addExplicit(relationship.target, "target");
        for (const parent of relationship.target.ancestors()) {
          if (parent === target)
            break;
          targets.add(parent);
        }
      }
    }
  }
  return {
    sources: finalize$1(sources, explicit.sources),
    targets: finalize$1(targets, explicit.targets),
    relationships
  };
}
function computeRelationshipDetailsViewData({
  // relationships: _relationships,
  source,
  target
}) {
  const sources = /* @__PURE__ */ new Set(), relationships = /* @__PURE__ */ new Set(), targets = /* @__PURE__ */ new Set(), explicit = {
    sources: /* @__PURE__ */ new Set(),
    targets: /* @__PURE__ */ new Set()
  }, addExplicit = (el, type) => {
    type === "source" ? (sources.add(el), explicit.sources.add(el)) : (targets.add(el), explicit.targets.add(el));
  };
  source && addExplicit(source, "source"), target && addExplicit(target, "target");
  const [connection] = modelConnection.findConnection(source, target, "directed");
  if (!connection)
    return {
      sources,
      targets,
      relationships
    };
  for (const relationship of connection.relations) {
    const relationSource = relationship.source, relationTarget = relationship.target;
    if (addExplicit(relationSource, "source"), addExplicit(relationTarget, "target"), relationships.add(relationship), source !== relationSource) {
      invariant$1(isAncestor(source, relationSource), `${source.id} is not an ancestor of ${relationSource.id}`);
      for (const parent of relationSource.ancestors()) {
        if (parent === source)
          break;
        sources.add(parent);
      }
    }
    if (target !== relationTarget) {
      invariant$1(isAncestor(target, relationTarget), `${target.id} is not an ancestor of ${relationTarget.id}`);
      for (const parent of relationTarget.ancestors()) {
        if (parent === target)
          break;
        targets.add(parent);
      }
    }
  }
  return {
    sources: finalize$1(sources, explicit.sources),
    targets: finalize$1(targets, explicit.targets),
    relationships
  };
}
const RelationshipDetailsActorContext = createContext(null);
function useRelationshipDetailsActor() {
  return nonNullable(useContext(RelationshipDetailsActorContext), "No RelationshipDetailsActorContext");
}
function useRelationshipDetailsState(selector3, compare2 = shallowEqual$1) {
  const select2 = useCallbackRef(selector3), actor = useRelationshipDetailsActor();
  return useSelector(actor, select2, compare2);
}
function useRelationshipDetails() {
  const actor = useRelationshipDetailsActor();
  return useMemo(() => ({
    actor,
    get rootElementId() {
      return `relationship-details-${actor.sessionId.replaceAll(":", "_")}`;
    },
    getState: () => actor.getSnapshot().context,
    send: actor.send,
    navigateTo: (...params) => {
      params.length === 1 ? actor.send({ type: "navigate.to", params: { edgeId: params[0] } }) : actor.send({ type: "navigate.to", params: { source: params[0], target: params[1] } });
    },
    fitDiagram: () => {
      actor.send({ type: "fitDiagram" });
    },
    close: () => {
      actor._parent ? actor._parent?.send({ type: "close", actorId: actor.id }) : actor.send({ type: "close" });
    }
  }), [actor]);
}
const Sizes = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 220,
    height: 14
    // minlen: 1,
  },
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph() {
  const g2 = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g2.setGraph({
    ...Sizes.dagre,
    rankdir: "LR"
  }), g2.setDefaultEdgeLabel(() => ({ ...Sizes.edgeLabel })), g2.setDefaultNodeLabel(() => ({})), g2;
}
const PortSuffix = "-port";
function createNodes(column, elements, g2) {
  const graphNodes = new DefaultMap((key2) => ({
    id: `${column}-${key2}`,
    portId: `${column}-${key2}`
  })), tree = treeFromElements(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id2 = `${column}-${fqn2}`, portId = isCompound ? `${id2}${PortSuffix}` : id2;
    graphNodes.set(fqn2, {
      id: id2,
      portId
    }), g2.setNode(id2, {
      column,
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes.nodeWidth,
      height: Sizes.nodeHeight
    }), isCompound && (g2.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes.nodeWidth - Sizes.dagre.ranksep,
      height: Sizes.compound.labelHeight
    }), g2.setParent(portId, id2));
    const parent = tree.parent(element);
    parent && g2.setParent(id2, `${column}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id2) => {
      const element = tree.byId(id2), graph2 = graphNodes.get(element.id);
      return {
        element,
        graph: graph2
      };
    },
    graphNodes
  };
}
function applyDagreLayout(g2) {
  return dagre.layout(g2, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g2.node(nodeId), { x: x2, y: y2, width, height } = node2;
    return {
      position: {
        x: x2 - Math.round(width / 2),
        y: y2 - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
function layoutRelationshipDetails(data, scope) {
  const g2 = createGraph(), sources = createNodes("sources", data.sources, g2), targets = createNodes("targets", data.targets, g2), edges = Array.from(data.relationships).map((r2) => {
    const source = sources.byId(r2.source.id).graph, target = targets.byId(r2.target.id).graph, name = r2.id;
    return g2.node(source.id).outPorts.push(target.id), g2.node(target.id).inPorts.push(source.id), g2.setEdge(source.portId, target.portId, {
      ...Sizes.edgeLabel
    }, name), {
      name,
      source: source.id,
      sourceHandle: source.id + "_out" + (g2.node(source.id).outPorts.length - 1),
      target: target.id,
      targetHandle: target.id + "_in" + (g2.node(target.id).inPorts.length - 1),
      relationship: r2
    };
  }), nodeIds = [
    ...sources.graphNodes.values(),
    ...targets.graphNodes.values()
  ];
  for (const { id: nodeId } of nodeIds) {
    const node2 = g2.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount2 = Math.max(g2.inEdges(nodeId)?.length ?? 0, g2.outEdges(nodeId)?.length ?? 0);
    edgeCount2 > 3 && (node2.height = node2.height + (edgeCount2 - 4) * 14);
  }
  const edgeCount = g2.edgeCount();
  if (edgeCount > 5)
    for (const edge of g2.edges())
      g2.setEdge(edge, {
        ...Sizes.edgeLabel,
        width: edgeCount > 10 ? 800 : 400
      });
  const dagreBounds = applyDagreLayout(g2), _calculatedNodeBounds = t$s(
    nodeIds,
    // Compound nodes have different portId
    n$q((n2) => n2.id === n2.portId),
    t$e((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= t$s(
      g2.children(nodeId) ?? [],
      n$q((id2) => !id2.endsWith(PortSuffix)),
      t$f((id2) => nodeBounds(id2)),
      t$1((bounds) => {
        invariant$1(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      t$5((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x: x2 },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes.compound.paddingTop, maxY = maxY + Sizes.compound.paddingBottom, {
          position: {
            x: x2,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g2.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children2 = g2.children(nodeId) ?? [];
    return children2.length === 0 ? 0 : 1 + Math.max(...children2.map(nodeDepth));
  }
  const sortedPorts = (nodeId, type, ports) => t$s(
    ports,
    t$f((port, index2) => ({
      port: nodeId + "_" + type + index2,
      topY: nodeBounds(port).position.y
    })),
    t$2(e("topY")),
    t$f(e("port"))
  );
  let minX = 0, minY = 0;
  const nodes = nodeIds.map(({ id: id2 }) => {
    const { element, inPorts, outPorts, column } = g2.node(id2);
    let { position, width, height } = nodeBounds(id2);
    const parentId = g2.parent(id2), children2 = (g2.children(id2) ?? []).filter((c) => !c.endsWith(PortSuffix));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = scope ? ifind(element.scopedViews(), (v2) => v2.id !== scope.id)?.id ?? null : null, inheritFromNode = scope?.findNodeWithElement(element.id), scopedAncestor = scope && !inheritFromNode ? ifind(element.ancestors(), (a2) => !!scope.findNodeWithElement(a2.id))?.id : null, inheritFromNodeOrAncestor = inheritFromNode ?? (scopedAncestor && scope?.findNodeWithElement(scopedAncestor));
    return exact({
      id: id2,
      parent: parentId ?? null,
      x: position.x,
      y: position.y,
      title: element.title,
      description: preferSummary(element.$element) ?? null,
      technology: element.technology,
      tags: [...element.tags],
      links: null,
      color: inheritFromNodeOrAncestor?.color ?? element.color,
      shape: inheritFromNode?.shape ?? element.shape,
      icon: inheritFromNode?.icon ?? element.icon ?? "none",
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id2),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: n$c({
        ...(inheritFromNode ?? inheritFromNodeOrAncestor)?.style,
        ...element.$element.style
      }, ["shape", "color", "icon"]),
      navigateTo,
      ...children2.length > 0 && { depth: nodeDepth(id2) },
      children: children2,
      width,
      height,
      column,
      ports: {
        in: sortedPorts(id2, "in", inPorts),
        out: sortedPorts(id2, "out", outPorts)
      }
    });
  });
  return {
    bounds: {
      x: Math.min(minX, 0),
      y: Math.min(minY, 0),
      width: g2.graph().width ?? 100,
      height: g2.graph().height ?? 100
    },
    nodes,
    edges: g2.edges().reduce((acc, e2) => {
      const edge = g2.edge(e2), ename = e2.name;
      if (!ename)
        return acc;
      const { name, source, target, relationship, sourceHandle, targetHandle } = r$a(edges, (e22) => e22.name === ename), label2 = relationship.title ?? "untitled", navigateTo = relationship.navigateTo?.id ?? null, description2 = preferSummary(relationship.$relationship) ?? null, technology = relationship.technology ?? null;
      return acc.push({
        id: name,
        source,
        sourceHandle,
        target,
        targetHandle,
        label: label2,
        color: relationship.color,
        description: description2,
        ...navigateTo && { navigateTo },
        ...technology && { technology },
        points: edge.points.map((p2) => [p2.x, p2.y]),
        line: relationship.line,
        relationId: relationship.id,
        parent: null
      }), acc;
    }, [])
  };
}
const edgeEnpoint = css.raw({
  display: "inline-flex",
  alignItems: "center",
  padding: "[6px 2px 0 2px]",
  "& .mantine-Text-root": {
    color: "mantine.colors.text/90",
    fontSize: "xs",
    fontWeight: 500,
    lineHeight: "1.2"
  }
}), edgeSource = css({
  paddingLeft: "1",
  gridColumn: 1
}, edgeEnpoint), edgeArrow = css({
  gridColumn: 2
}, edgeEnpoint), edgeTarget = css({
  gridColumn: 3,
  paddingRight: "1"
}, edgeEnpoint), edgeLabelclass = "likec4-edge-label", edgeLabel = cx(
  edgeLabelclass,
  css({
    display: "grid",
    gridColumnStart: 1,
    gridColumnEnd: 4,
    borderBottom: "1px solid",
    borderBottomColor: "mantine.colors.defaultBorder",
    marginBottom: "0",
    padding: "[0 4px 5px 4px]",
    width: "100%",
    "& .mantine-Text-root": {
      fontSize: "xxs",
      fontWeight: 400,
      lineHeight: "xs",
      color: "mantine.colors.dimmed"
    }
  })
), edgeRow = css({
  display: "contents",
  [`&:last-child .${edgeLabelclass}`]: {
    borderBottom: "none",
    marginBottom: "0"
  },
  "& > *": {
    transition: "all 0.15s ease-in"
  },
  "&:is(:hover, [data-selected=true]) > *": {
    transition: "all 0.15s ease-out",
    cursor: "pointer",
    backgroundColor: "mantine.colors.defaultHover"
  }
}), edgeGrid = css({
  display: "grid",
  gridTemplateColumns: "1fr 30px 1fr",
  gridAutoRows: "min-content max-content",
  gap: "0",
  alignItems: "stretch"
});
css({
  display: "grid",
  gridTemplateColumns: "min-content 1fr",
  gridAutoRows: "min-content max-content",
  gap: "[10px 12px]",
  alignItems: "baseline",
  justifyItems: "start"
});
const scrollArea$1 = css({
  maxHeight: [
    "70vh",
    "calc(100cqh - 70px)"
  ]
}), SelectEdge = ({
  edge,
  view
}) => {
  const browser = useRelationshipDetails(), viewport = useRef(null), edgeSource$1 = view.nodes.find((n2) => n2.id === edge.source), edgeTarget$1 = view.nodes.find((n2) => n2.id === edge.target), edges = view.edges.flatMap((edge2) => {
    const source = view.nodes.find((n2) => n2.id === edge2.source), target = view.nodes.find((n2) => n2.id === edge2.target);
    return source && target ? {
      id: edge2.id,
      source,
      target,
      label: edge2.label
    } : [];
  });
  return !edgeSource$1 || !edgeTarget$1 || edges.length === 0 ? null : /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom-start",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          viewport.current?.querySelector(`[data-edge-id="${edge.id}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsxs(
          Button,
          {
            size: "xs",
            variant: "default",
            fw: "500",
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: [
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeSource,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeSource$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: edgeSource$1.title })
                }
              ),
              /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }),
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeTarget,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeTarget$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: edgeTarget$1.title })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { className: scrollArea$1, scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(Box$1, { className: edgeGrid, p: "xs", maw: 400, children: edges.map((e2) => /* @__PURE__ */ jsxs(
          "div",
          {
            className: edgeRow,
            "data-selected": e2.id === edge.id,
            onClick: (event) => {
              event.stopPropagation(), browser.navigateTo(e2.id);
            },
            children: [
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeSource,
                  mod: {
                    "edge-id": e2.id,
                    "likec4-color": e2.source.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.source.title })
                }
              ),
              /* @__PURE__ */ jsx(Box$1, { className: edgeArrow, children: /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }) }),
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeTarget,
                  mod: {
                    "likec4-color": e2.target.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.target.title })
                }
              ),
              /* @__PURE__ */ jsx(Box$1, { className: edgeLabel, children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.label || "untitled" }) })
            ]
          },
          e2.id
        )) }) }) })
      ]
    }
  );
}, RelationshipEdge$2 = memoEdge((props) => {
  const { enableNavigateTo } = useEnabledFeatures(), {
    data: { navigateTo }
  } = props, [svgPath, labelX, labelY] = getBezierPath(props), diagram = useDiagram();
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...props, children: [
    /* @__PURE__ */ jsx(EdgePath, { edgeProps: props, svgPath }),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps: props,
        labelPosition: {
          x: labelX,
          y: labelY,
          translate: "translate(-50%, 0)"
        },
        style: {
          maxWidth: Math.abs(props.targetX - props.sourceX - 100)
        },
        children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps: props, children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
          EdgeActionButton,
          {
            ...props,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigateTo(navigateTo);
            }
          }
        ) })
      }
    )
  ] });
}), ElementActions$1 = (props) => {
  const { enableNavigateTo, enableVscode } = useEnabledFeatures(), diagram = useDiagram(), currentViewId = useCurrentViewId(), buttons = [], { navigateTo, fqn: fqn2 } = props.data;
  return navigateTo && enableNavigateTo && currentViewId !== navigateTo && buttons.push({
    key: "navigate",
    icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.navigateTo(navigateTo);
    }
  }), fqn2 && buttons.push({
    key: "relationships",
    icon: /* @__PURE__ */ jsx(IconTransform, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openRelationshipsBrowser(fqn2);
    }
  }), fqn2 && enableVscode && buttons.push({
    key: "goToSource",
    icon: /* @__PURE__ */ jsx(IconFileSymlink, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openSource({ element: fqn2 });
    }
  }), /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons,
      ...props
    }
  );
};
function nodePropsEqual(prev, next) {
  return prev.id === next.id && deepEqual$1(prev.type, next.type) && deepEqual$1(prev.selected ?? !1, next.selected ?? !1) && deepEqual$1(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual$1(prev.width ?? 0, next.width ?? 0) && deepEqual$1(prev.height ?? 0, next.height ?? 0) && deepEqual$1(prev.zIndex ?? 0, next.zIndex ?? 0) && deepEqual$1(prev.data, next.data);
}
const isMemoized = /* @__PURE__ */ Symbol.for("isMemoized");
function memoNode(Node2, displayName = "Node") {
  if (Node2.hasOwnProperty(isMemoized))
    return Node2;
  const NodeComponent = memo$3(
    Node2,
    nodePropsEqual
  );
  return NodeComponent.displayName = displayName, Object.defineProperty(NodeComponent, isMemoized, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), NodeComponent;
}
const ElementDetailsButtonWithHandler$1 = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
      }
    }
  );
}, ElementNode$1 = memoNode((props) => {
  const { enableElementTags } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$1, { ...props }),
    /* @__PURE__ */ jsx(ElementActions$1, { ...props }),
    /* @__PURE__ */ jsx(ElementPorts, { ...props })
  ] });
}), CompoundNode = memoNode(
  (props) => /* @__PURE__ */ jsxs(CompoundNodeContainer, { nodeProps: props, children: [
    /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$1, { ...props }),
    /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
    /* @__PURE__ */ jsx(CompoundPorts, { ...props })
  ] })
), ElementPorts = ({ data: { ports, height: h2 } }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.in.length + 1))}px`
      }
    },
    id2
  )),
  ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (i2 + 1) * ((h2 - 30) / (ports.out.length + 1))}px`
      }
    },
    id2
  ))
] }), CompoundPorts = ({ data }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  data.ports.in.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  )),
  data.ports.out.map((id2, i2) => /* @__PURE__ */ jsx(
    Handle,
    {
      id: id2,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i2 + 1)}px`
      }
    },
    id2
  ))
] }), nodeTypes$1 = {
  element: ElementNode$1,
  compound: CompoundNode
}, edgeTypes$2 = {
  relationship: RelationshipEdge$2
};
function RelationshipDetails({ actorRef }) {
  const initialRef = useRef(null);
  return initialRef.current == null && (initialRef.current = {
    defaultNodes: [],
    defaultEdges: []
  }), /* @__PURE__ */ jsx(RelationshipDetailsActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(ReactFlowProvider, { ...initialRef.current, children: /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    /* @__PURE__ */ jsx(RelationshipDetailsInner, {}, "xyflow"),
    /* @__PURE__ */ jsx(SyncRelationshipDetailsXYFlow, {}, "sync")
  ] }) }) }) });
}
const selectSubject = (state) => ({
  ...state.context.subject,
  viewId: state.context.viewId
}), SyncRelationshipDetailsXYFlow = memo$3(() => {
  const actor = useRelationshipDetailsActor(), subject = useSelector(actor, selectSubject, deepEqual$1), likec4model = useLikeC4Model(), view = likec4model.findView(subject.viewId) ?? null, data = useMemo(() => {
    let data2;
    if ("edgeId" in subject && e$1(subject.edgeId)) {
      invariant$2(view, `view ${subject.viewId} not found`);
      const edge = nonNullable(view.findEdge(subject.edgeId), `edge ${subject.edgeId} not found in ${subject.viewId}`);
      data2 = computeEdgeDetailsViewData([edge.id], view);
    } else if (subject.source && subject.target)
      data2 = computeRelationshipDetailsViewData({
        source: likec4model.element(subject.source),
        target: likec4model.element(subject.target)
      });
    else
      return null;
    return layoutRelationshipDetails(data2, view);
  }, [
    subject,
    view,
    likec4model
  ]), store = useStoreApi(), instance = useReactFlow();
  return useEffect(() => {
    instance.viewportInitialized && actor.send({ type: "xyflow.init", instance, store });
  }, [store, instance.viewportInitialized, actor]), useEffect(() => {
    data !== null && actor.send({ type: "update.layoutData", data });
  }, [data, actor]), null;
}), selector$5 = ({ context: context2 }) => ({
  // subject: context.subject,
  // view: state.context.view,
  initialized: context2.initialized.xydata && context2.initialized.xyflow,
  nodes: context2.xynodes,
  edges: context2.xyedges
}), RelationshipDetailsInner = memo$3(() => {
  const browser = useRelationshipDetails(), {
    initialized,
    nodes,
    edges
  } = useRelationshipDetailsState(selector$5, deepEqual$1);
  return /* @__PURE__ */ jsxs(
    BaseXYFlow,
    {
      id: browser.rootElementId,
      nodes,
      edges,
      className: cx(
        initialized ? "initialized" : "not-initialized",
        "likec4-relationship-details"
      ),
      nodeTypes: nodeTypes$1,
      edgeTypes: edgeTypes$2,
      onNodesChange: useCallbackRef$1((changes) => {
        browser.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef$1((changes) => {
        browser.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      fitViewPadding: 0.05,
      onNodeClick: useCallbackRef$1((e2, node2) => {
        e2.stopPropagation(), browser.send({ type: "xyflow.nodeClick", node: node2 });
      }),
      onEdgeClick: useCallbackRef$1((e2, edge) => {
        e2.stopPropagation(), browser.send({ type: "xyflow.edgeClick", edge });
      }),
      onPaneClick: useCallbackRef$1(() => {
        browser.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: useCallbackRef$1(() => {
        browser.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: useCallbackRef$1(() => {
        browser.send({ type: "xyflow.resized" });
      }),
      onEdgeMouseEnter: useCallbackRef$1((_event, edge) => {
        edge.data.hovered || browser.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef$1((_event, edge) => {
        edge.data.hovered && browser.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      onSelectionChange: useCallbackRef$1((params) => {
        browser.send({ type: "xyflow.selectionChange", ...params });
      }),
      nodesDraggable: !1,
      nodesSelectable: !0,
      fitView: !1,
      pannable: !0,
      zoomable: !0,
      children: [
        /* @__PURE__ */ jsx(TopLeftPanel, {}),
        /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), browser.close();
            },
            children: /* @__PURE__ */ jsx(IconX, {})
          }
        ) })
      ]
    }
  );
}), topLeftPanelselector = ({ context: context2 }) => ({
  subject: context2.subject,
  viewId: context2.viewId
}), TopLeftPanel = memo$3(() => {
  const { subject, viewId } = useRelationshipDetailsState(topLeftPanelselector, deepEqual$1), view = useLikeC4Model().findView(viewId);
  if (!view || !view.isDiagram())
    return null;
  const edges = [...view.edges()];
  let edge = "edgeId" in subject && e$1(subject.edgeId) ? edges.find((e2) => e2.id === subject.edgeId) : r$a(edges, (e2) => e2.source.element?.id === subject.source && e2.target.element?.id === subject.target) || r$a(edges, (e2) => (e2.source.element?.id === subject.source || isAncestor$1(e2.source.element?.id ?? "__", subject.source ?? "__")) && (e2.target.element?.id === subject.target || isAncestor$1(e2.target.element?.id ?? "__", subject.target ?? "__")));
  return edge ? /* @__PURE__ */ jsx(TopLeftPanelInner, { edge: edge.$edge, view: view.$view }) : null;
}), TopLeftPanelInner = ({ edge, view }) => {
  const browser = useRelationshipDetails(), edgeId = edge.id, [historyEdgeId, historyOps, { history, current: current2 }] = useStateHistory(edge.id);
  useEffect(() => {
    historyEdgeId !== edgeId && historyOps.set(edgeId);
  }, [edgeId]), useEffect(() => {
    historyEdgeId !== edgeId && browser.navigateTo(historyEdgeId);
  }, [historyEdgeId]);
  const hasStepBack = current2 > 0, hasStepForward = current2 + 1 < history.length;
  return /* @__PURE__ */ jsx(Panel, { position: "top-left", children: /* @__PURE__ */ jsx(Group, { gap: 4, wrap: "nowrap", children: /* @__PURE__ */ jsxs(AnimatePresence, { mode: "popLayout", children: [
    hasStepBack && /* @__PURE__ */ jsx(
      m$1.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.back();
            },
            children: /* @__PURE__ */ jsx(IconChevronLeft, {})
          }
        )
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      m$1.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.forward();
            },
            children: /* @__PURE__ */ jsx(IconChevronRight, {})
          }
        )
      },
      "forward"
    ),
    /* @__PURE__ */ jsx(Group, { gap: "xs", wrap: "nowrap", ml: "sm", children: /* @__PURE__ */ jsx(SelectEdge, { edge, view }) })
  ] }) }) });
}, selectOverlays = (s2) => s2.context.overlays.map((overlay2) => {
  switch (overlay2.type) {
    case "relationshipsBrowser":
      return s2.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s2.children[overlay2.id]
      } : null;
    case "relationshipDetails":
      return s2.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s2.children[overlay2.id]
      } : null;
    case "elementDetails":
      return s2.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s2.children[overlay2.id]
      } : null;
    default:
      nonexhaustive(overlay2);
  }
}).filter(e$7), compareSelectOverlays = (a2, b2) => a2.length === b2.length && a2.every((overlay2, i2) => overlay2.actorRef === b2[i2].actorRef);
function Overlays({ overlaysActorRef }) {
  const diagram = useDiagram(), overlays = useSelector(overlaysActorRef, selectOverlays, compareSelectOverlays), isMotionReduced = useReducedMotionConfig() ?? !1, isActiveOverlay = overlays.some((overlay2) => overlay2.type === "elementDetails");
  useEffect(() => {
    const xyflowRendererDom = diagram.getContext().xystore.getState().domNode?.querySelector(".react-flow__renderer");
    if (!xyflowRendererDom || isMotionReduced) return;
    const current2 = animate(xyflowRendererDom, {
      opacity: isActiveOverlay ? 0.7 : 1,
      filter: isActiveOverlay ? "grayscale(1)" : "grayscale(0)",
      transform: isActiveOverlay ? "perspective(400px) translateZ(-12px) translateY(3px)" : "translateY(0)"
    }, {
      duration: isActiveOverlay ? 0.35 : 0.17
    });
    let cleanupTm = null;
    return isActiveOverlay || (cleanupTm = setTimeout(() => {
      xyflowRendererDom.style.transform = "", xyflowRendererDom.style.filter = "", cleanupTm = null;
    }, 450)), () => {
      cleanupTm && clearTimeout(cleanupTm), current2.stop();
    };
  }, [isActiveOverlay]);
  const close = (actorRef) => {
    overlaysActorRef.send({ type: "close", actorId: actorRef.id });
  }, overlaysReact = overlays.map((overlay2, index2) => {
    switch (overlay2.type) {
      case "relationshipsBrowser":
        return /* @__PURE__ */ jsx(
          Overlay,
          {
            overlayLevel: index2,
            onClose: () => close(overlay2.actorRef),
            children: /* @__PURE__ */ jsx(RelationshipsBrowser, { actorRef: overlay2.actorRef })
          },
          overlay2.actorRef.sessionId
        );
      case "relationshipDetails":
        return /* @__PURE__ */ jsx(
          Overlay,
          {
            overlayLevel: index2,
            onClose: () => close(overlay2.actorRef),
            children: /* @__PURE__ */ jsx(RelationshipDetails, { actorRef: overlay2.actorRef })
          },
          overlay2.actorRef.sessionId
        );
      case "elementDetails":
        return /* @__PURE__ */ jsx(
          ElementDetails,
          {
            actorRef: overlay2.actorRef,
            onClose: () => close(overlay2.actorRef)
          },
          overlay2.actorRef.sessionId
        );
      default:
        nonexhaustive(overlay2);
    }
  });
  return /* @__PURE__ */ jsx(DiagramFeatures.Overlays, { children: /* @__PURE__ */ jsx(ErrorBoundary2, { onReset: () => overlaysActorRef.send({ type: "close.all" }), children: /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsx(AnimatePresence, { mode: "popLayout", children: overlaysReact }) }) }) });
}
const [SearchActorContext, useSearchActor] = createSafeContext$1("SearchActorContext"), selectSearchValue = (s2) => s2.context.searchValue;
function useSearch() {
  const searchActorRef = useSearchActor(), searchValue = useSelector(searchActorRef, selectSearchValue), updateSearch = useCallback((search) => {
    searchActorRef.send({ type: "change.search", search });
  }, [searchActorRef]);
  return [searchValue, updateSearch];
}
const selectNormalizedSearchValue = (s2) => {
  const v2 = s2.context.searchValue.trim().toLowerCase();
  return v2.length > 1 ? v2 : "";
};
function useNormalizedSearch() {
  const searchActorRef = useSearchActor();
  return useDeferredValue(useSelector(searchActorRef, selectNormalizedSearchValue));
}
function useUpdateSearch() {
  const searchActorRef = useSearchActor();
  return useCallback((search) => {
    searchActorRef.send({ type: "change.search", search });
  }, [searchActorRef]);
}
const selectPickViewFor = (s2) => s2.context.pickViewFor;
function usePickViewFor() {
  const searchActorRef = useSearchActor();
  return useSelector(searchActorRef, selectPickViewFor);
}
const buttonFocused = css.raw({
  outline: "none",
  background: "mantine.colors.primary[8]",
  borderColor: "mantine.colors.primary[9]"
}), _treenodefocus = ".mantine-Tree-node:focus > .mantine-Tree-label &", button = css.raw({
  display: "flex",
  width: "100%",
  background: "mantine.colors.body",
  rounded: "sm",
  padding: "[12px 8px 12px 14px]",
  minHeight: "60px",
  gap: "2",
  // alignItems: 'flex-start',
  // transition: `all 50ms ${easings.inOut}`,
  border: "1px solid",
  borderColor: "mantine.colors.defaultBorder",
  // [titleColor]: '{colors.mantine.colors.dark[1]}',
  // [iconColor]: '{colors.mantine.colors.dimmed}',
  // [descriptionColor]: '{colors.mantine.colors.dimmed}',
  _hover: {
    ...buttonFocused,
    borderColor: "mantine.colors.primary[9]",
    background: "mantine.colors.primary[8]/60"
  },
  _focus: buttonFocused,
  [_treenodefocus]: buttonFocused,
  _dark: {
    borderColor: "transparent",
    background: "mantine.colors.dark[6]/80"
    // background: 'mantine.colors.dark[6]',
  },
  _light: {
    background: "mantine.colors.white/80",
    // [iconColor]: '{colors.mantine.colors.gray[6]}',
    // [titleColor]: '{colors.mantine.colors.gray[7]}',
    _hover: {
      borderColor: "mantine.colors.primary[6]",
      backgroundColor: "mantine.colors.primary[5]"
      // [iconColor]: '{colors.mantine.colors.primary[3])',
      // [titleColor]: '{colors.mantine.colors.primary[0])',
      // [descriptionColor]: '{colors.mantine.colors.primary[1]}',
    }
  }
}), focusable = "likec4-focusable", iconSize = {
  ref: "var(--likec4-icon-size, 24px)"
}, icon$1 = css.raw({
  color: {
    base: "mantine.colors.dimmed",
    _light: "mantine.colors.gray[5]",
    _groupHover: "mantine.colors.primary[0]",
    _groupFocus: "mantine.colors.primary[0]"
  },
  [_treenodefocus]: {
    color: "mantine.colors.primary[0]"
  },
  flex: `0 0 ${iconSize.ref}`,
  height: iconSize.ref,
  width: iconSize.ref,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  alignSelf: "flex-start",
  "--ti-size": iconSize.ref,
  "& svg, & img": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none"
  },
  "& img": {
    objectFit: "contain"
  },
  "&.likec4-shape-icon svg": {
    // color: `[var(${iconColor})]`,
    strokeWidth: 1.5
  }
  // [iconSize]: '24px',
  // [whenContainerIsNarrow]: {
  //   [iconSize]: '18px',
  // },
}), title$1 = css.raw({
  fontSize: "16px",
  fontWeight: 500,
  lineHeight: "1.1",
  ":where([data-disabled]) &": {
    opacity: 0.4
  },
  color: {
    base: "mantine.colors.dark[1]",
    _light: "mantine.colors.gray[7]",
    _groupHover: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.white"
    },
    _groupFocus: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.white"
    }
  },
  [_treenodefocus]: {
    color: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.white"
    }
  }
}), descriptionColor = css.raw({
  color: {
    base: "mantine.colors.dimmed",
    _groupHover: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.primary[0]"
    },
    _groupFocus: "mantine.colors.primary[0]"
  },
  [_treenodefocus]: {
    color: "mantine.colors.primary[0]"
  }
}), description = css.raw(descriptionColor, {
  marginTop: "1",
  fontSize: "12px",
  lineHeight: "1.4",
  ":where([data-disabled]) &": {
    opacity: 0.85
  }
}), emptyBoX = css({
  width: "100%",
  height: "100%",
  border: "2px dashed",
  borderColor: "mantine.colors.defaultBorder",
  rounded: "md",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  fontSize: "md",
  color: "mantine.colors.dimmed",
  padding: "md",
  paddingBlock: "xl"
}), buttonsva = sva({
  slots: ["root", "icon", "title", "description", "descriptionColor"],
  className: "search-button",
  base: {
    root: button,
    icon: icon$1,
    title: title$1,
    description,
    descriptionColor
  }
}), whenContainerIsNarrow = "@container likec4-tree (max-width: 450px)", treeNode = css({
  outline: "none",
  marginBottom: "2"
}), treeRoot = css(
  container$3.raw({
    containerName: "likec4-tree"
  }),
  {
    containerType: "inline-size",
    height: "100%"
  }
), treeLabel = css({
  display: "flex",
  alignItems: "baseline",
  outline: "none !important",
  gap: "1"
}), treeSubtree = css({
  marginTop: "2"
}), elementExpandIcon = css({
  color: "mantine.colors.dimmed"
}), elementTitleAndId = css({
  [whenContainerIsNarrow]: {
    flexDirection: "column-reverse",
    alignItems: "flex-start",
    gap: "0.5"
  }
}), elementId = css({
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "10px",
  lineHeight: "1.3",
  display: "block",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "[1px 5px]",
  borderRadius: "4px",
  background: "mantine.colors.dark[9]/30",
  _light: {
    background: "mantine.colors.gray[3]/20"
  }
}), elementIcon = css({
  "--likec4-icon-size": "24px",
  [whenContainerIsNarrow]: {
    "--likec4-icon-size": "18px"
  }
}), elementViewsCount = css({
  flex: 0,
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "10px",
  fontWeight: 500,
  whiteSpace: "nowrap",
  lineHeight: "1.1",
  [whenContainerIsNarrow]: {
    display: "none"
  }
});
function stopAndPrevent$1(e2) {
  e2.stopPropagation(), e2.preventDefault();
}
function centerY(element) {
  const rect = element.getBoundingClientRect();
  return rect.y + Math.floor(rect.height / 2);
}
function moveFocusToSearchInput(from) {
  if (!from) {
    console.error("moveFocusToSearchInput: from is null or undefined");
    return;
  }
  const root2 = from.getRootNode();
  if (!e$9(root2.querySelector)) {
    console.error("moveFocusToSearchInput: root.querySelector is not a function");
    return;
  }
  let input2 = root2.querySelector("[data-likec4-search-input]");
  if (input2) {
    const length = input2.value.length;
    input2.focus(), input2.setSelectionRange(length, length);
  }
}
function focusToFirstFoundElement(from) {
  if (!from) {
    console.error("focusToFirstFoundElement: from is null or undefined");
    return;
  }
  const root2 = from.getRootNode();
  if (!e$9(root2.querySelector)) {
    console.error("focusToFirstFoundElement: root.querySelector is not a function");
    return;
  }
  root2.querySelector(`[data-likec4-search] .${focusable}`)?.focus();
}
function queryAllFocusable(from, where, selector3 = `.${focusable}`) {
  if (!from)
    return console.error("queryAllFocusable: from is null or undefined"), [];
  const root2 = from.getRootNode();
  return e$9(root2.querySelectorAll) ? [...root2.querySelectorAll(`[data-likec4-search-${where}] ${selector3}`)] : (console.error("queryAllFocusable: root.querySelectorAll is not a function"), []);
}
function whenSearchAnimationEnds(callback) {
  setTimeout(callback, 300);
}
const _viewBtn = "likec4-view-btn", viewButton = cx(
  css({
    flexWrap: "nowrap",
    display: "flex",
    // '& .mantine-ThemeIcon-root': {
    //   color: `[var(${iconColor}, {colors.mantine.colors.dark[2]})]`,
    //   '--ti-size': '24px',
    // },
    "&[data-disabled] .mantine-ThemeIcon-root": {
      opacity: 0.45
    }
  }),
  _viewBtn
);
css({
  marginTop: "1",
  // transition: transitions.fast,
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "13px",
  lineHeight: "1.4",
  ":where(.likec4-view-btn[data-disabled]) &": {
    opacity: 0.85
  }
});
const NothingFound = () => /* @__PURE__ */ jsx(Box, { className: emptyBoX, children: "Nothing found" }), ViewsColumn = memo$3(() => {
  const ref = useRef(null);
  let views = [...useLikeC4Model().views()], search = useNormalizedSearch();
  return search && (search.startsWith("kind:") ? views = [] : views = views.filter((view) => search.startsWith("#") ? view.tags.some((tag) => tag.toLocaleLowerCase().includes(search.slice(1))) : `${view.id} ${view.title} ${view.description.text}`.toLocaleLowerCase().includes(search))), /* @__PURE__ */ jsxs(
    Stack,
    {
      ref,
      renderRoot: (props) => /* @__PURE__ */ jsx(MotionDiv, { layout: !0, ...props }),
      gap: 8,
      "data-likec4-search-views": !0,
      onKeyDown: (e2) => {
        if (e2.key === "ArrowLeft" || e2.key === "ArrowRight") {
          const maxY = e2.target.getBoundingClientRect().y, elementButtons = queryAllFocusable(ref.current, "elements", ".likec4-element-button");
          let elementButton = elementButtons.length > 1 ? elementButtons.find((el, i2, all) => centerY(el) > maxY || i2 === all.length - 1) : null;
          elementButton ??= n$p(elementButtons), elementButton && (e2.stopPropagation(), elementButton.focus());
          return;
        }
      },
      children: [
        views.length === 0 && /* @__PURE__ */ jsx(NothingFound, {}),
        views.length > 0 && /* @__PURE__ */ jsx(VisuallyHidden, { children: /* @__PURE__ */ jsx(
          UnstyledButton,
          {
            "data-likec4-view": !0,
            tabIndex: -1,
            onFocus: (e2) => {
              e2.stopPropagation(), moveFocusToSearchInput(ref.current);
            }
          }
        ) }),
        views.map((view, i2) => /* @__PURE__ */ jsx(MotionDiv, { layoutId: `@view${view.id}`, children: /* @__PURE__ */ jsx(
          ViewButton,
          {
            view,
            search,
            tabIndex: i2 === 0 ? 0 : -1
          }
        ) }, view.id))
      ]
    }
  );
}), btn$1 = buttonsva();
function ViewButton({ className, view, loop = !1, search, focusOnElement, ...props }) {
  const searchActorRef = useSearchActor(), diagram = useDiagram(), nextViewId = view.id, currentViewId = useCurrentViewId(), isCurrentView = nextViewId === currentViewId, navigate = () => {
    searchActorRef.send({ type: "close" }), whenSearchAnimationEnds(() => {
      if (isCurrentView && focusOnElement) {
        diagram.focusOnElement(focusOnElement);
        return;
      }
      diagram.navigateTo(nextViewId, void 0, focusOnElement);
    });
  };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...props,
      className: cx(btn$1.root, "group", focusable, viewButton, className),
      "data-likec4-view": view.id,
      ...isCurrentView && !focusOnElement && { "data-disabled": !0 },
      onClick: (e2) => {
        e2.stopPropagation(), navigate();
      },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-likec4-view]",
        parentSelector: "[data-likec4-search-views]",
        activateOnFocus: !1,
        loop,
        orientation: "vertical",
        onKeyDown: (e2) => {
          e2.nativeEvent.code === "Space" && (e2.stopPropagation(), navigate());
        }
      }),
      children: [
        /* @__PURE__ */ jsx(ThemeIcon, { variant: "transparent", className: btn$1.icon, children: view.isDeploymentView() ? /* @__PURE__ */ jsx(IconStack2, { stroke: 1.8 }) : /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
        /* @__PURE__ */ jsxs(Box, { style: { flexGrow: 1 }, children: [
          /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
            /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: search, className: btn$1.title, children: view.title || "untitled" }),
            isCurrentView && /* @__PURE__ */ jsx(Badge, { size: "xs", fz: 9, radius: "sm", children: "current" })
          ] }),
          /* @__PURE__ */ jsx(
            Highlight,
            {
              highlight: view.description.nonEmpty ? search : "",
              component: "div",
              className: btn$1.description,
              lineClamp: 1,
              children: view.description.text || "No description"
            }
          )
        ] })
      ]
    }
  );
}
const btn = buttonsva(), ElementsColumn = memo$3(() => {
  const model = useLikeC4Model(), search = useNormalizedSearch(), data = useMemo(() => {
    const searchTerms = search.split(".");
    let elements;
    e$a(searchTerms) || searchTerms[0] === "kind:" ? elements = model.elements() : elements = ifilter(model.elements(), (element) => search.startsWith("kind:") ? element.kind.toLocaleLowerCase().startsWith(search.slice(5)) : search.startsWith("#") ? element.tags.some((tag) => tag.toLocaleLowerCase().includes(search.slice(1))) : (element.title + " " + element.id + " " + element.summary.text).toLocaleLowerCase().includes(search));
    const byid = {}, { all, roots } = t$s(
      [...elements],
      sortParentsFirst,
      t$5((acc, element) => {
        const treeItem = {
          label: element.title,
          value: element.id,
          element,
          searchTerms,
          children: []
        };
        byid[treeItem.value] = treeItem;
        const parent = acc.all.findLast((root2) => isAncestor(root2.value, treeItem.value));
        return parent ? (parent.children.push(treeItem), parent.children.length > 1 && parent.children.sort(sortByLabel)) : acc.roots.push(treeItem), acc.all.push(treeItem), acc;
      }, {
        all: [],
        roots: []
      })
    );
    return {
      all,
      byid,
      roots: roots.sort(sortByLabel)
    };
  }, [model, search]), handleClick2 = useHandleElementSelection();
  return data.all.length === 0 ? /* @__PURE__ */ jsx(NothingFound, {}) : /* @__PURE__ */ jsx(ElementsTree, { data, handleClick: handleClick2 });
}), setHoveredNode = () => {
};
function ElementsTree({
  data: {
    all,
    byid,
    roots
  },
  handleClick: handleClick2
}) {
  const tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode, useEffect(() => {
    tree.collapseAllNodes();
    for (const nd of all)
      nd.children.length > 0 && tree.expand(nd.value);
  }, [all]);
  const onKeyDownCapture = useCallbackRef((e2) => {
    const target = e2.target, id2 = target.getAttribute("data-value"), node2 = !!id2 && byid[id2];
    if (node2) {
      if (e2.key === "ArrowUp") {
        id2 === roots[0]?.value && (stopAndPrevent$1(e2), moveFocusToSearchInput(target));
        return;
      }
      if (e2.key === "ArrowRight") {
        if (node2.children.length > 0 && tree.expandedState[id2] === !1)
          return;
        const maxY = (e2.target.querySelector(".mantine-Tree-label") ?? target).getBoundingClientRect().y, viewButtons = queryAllFocusable(target, "views");
        let view = viewButtons.length > 1 ? viewButtons.find((el, i2, all2) => centerY(el) > maxY || i2 === all2.length - 1) : null;
        view ??= n$p(viewButtons), view && (stopAndPrevent$1(e2), view.focus());
        return;
      }
      if (e2.key === " " || e2.key === "Enter") {
        stopAndPrevent$1(e2), handleClick2(node2.element);
        return;
      }
    }
  });
  return /* @__PURE__ */ jsx(
    Tree,
    {
      "data-likec4-search-elements": !0,
      allowRangeSelection: !1,
      clearSelectionOnOutsideClick: !0,
      selectOnClick: !1,
      tree,
      data: roots,
      levelOffset: "lg",
      classNames: {
        root: treeRoot,
        node: cx(focusable, treeNode),
        label: treeLabel,
        subtree: treeSubtree
      },
      onKeyDownCapture,
      renderNode: ElementTreeNode
    }
  );
}
function ElementTreeNode({ node: node2, elementProps, hasChildren, expanded }) {
  const { element, searchTerms } = node2, elementIcon$12 = IconOrShapeRenderer({
    element: {
      id: element.id,
      title: element.title,
      shape: element.shape,
      icon: element.icon
    },
    className: cx(btn.icon, elementIcon)
  }), views = [...element.views()], handleClick2 = useHandleElementSelection(), key2 = `@tree.${node2.value}`;
  return /* @__PURE__ */ jsxs(MotionDiv, { layoutId: key2, ...elementProps, children: [
    /* @__PURE__ */ jsx(
      ActionIcon,
      {
        variant: "transparent",
        size: 16,
        tabIndex: -1,
        className: cx(elementExpandIcon),
        style: {
          visibility: hasChildren ? "visible" : "hidden"
        },
        children: /* @__PURE__ */ jsx(
          IconChevronRight,
          {
            stroke: 3.5,
            style: {
              transition: "transform 150ms ease",
              transform: `rotate(${expanded ? "90deg" : "0"})`,
              width: "100%"
            }
          }
        )
      }
    ),
    /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        component: MotionButton,
        layout: !0,
        tabIndex: -1,
        "data-value": element.id,
        className: cx(btn.root, "group", "likec4-element-button"),
        ...views.length > 0 && {
          onClick: (e2) => {
            (!hasChildren || expanded) && (e2.stopPropagation(), handleClick2(element));
          }
        },
        children: [
          elementIcon$12,
          /* @__PURE__ */ jsxs(Box$1, { style: { flexGrow: 1 }, children: [
            /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", className: elementTitleAndId, children: [
              /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: searchTerms, className: btn.title, children: node2.label }),
              /* @__PURE__ */ jsx(Tooltip$6, { label: element.id, withinPortal: !1, fz: "xs", disabled: !element.id.includes("."), children: /* @__PURE__ */ jsx(
                Highlight,
                {
                  component: "div",
                  highlight: searchTerms,
                  className: cx(elementId, btn.descriptionColor),
                  children: nameFromFqn$1(element.id)
                }
              ) })
            ] }),
            /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: searchTerms, className: btn.description, lineClamp: 1, children: element.summary.text || "No description" })
          ] }),
          /* @__PURE__ */ jsx(Text, { component: "div", className: cx(elementViewsCount, btn.descriptionColor), fz: "xs", children: views.length === 0 ? "No views" : /* @__PURE__ */ jsxs(Fragment, { children: [
            views.length,
            " view",
            views.length > 1 ? "s" : ""
          ] }) })
        ]
      }
    )
  ] });
}
function useHandleElementSelection() {
  const diagram = useDiagram(), searchActorRef = useSearchActor();
  return useCallbackRef((element) => {
    const views = [...element.views()];
    if (views.length === 0)
      return;
    const elementFqn = element.id, onlyOneViewId = t$b(views)?.id;
    if (!onlyOneViewId) {
      searchActorRef.send({ type: "pickview.open", elementFqn });
      return;
    }
    const isSameView = onlyOneViewId === diagram.currentView.id;
    searchActorRef.send({ type: "close" }), whenSearchAnimationEnds(() => {
      if (isSameView) {
        diagram.focusOnElement(elementFqn);
        return;
      }
      diagram.navigateTo(onlyOneViewId, void 0, elementFqn);
    });
  });
}
const input = css({
  border: "transparent",
  background: {
    base: "transparent",
    _focusWithin: {
      base: "mantine.colors.gray[4]/55 !important",
      _dark: "mantine.colors.dark[5]/55 !important"
    },
    _groupHover: {
      base: "mantine.colors.gray[3]/35",
      _dark: "mantine.colors.dark[5]/35"
    }
  }
}), pickviewBackdrop = css({
  position: "absolute",
  inset: "0",
  width: "100%",
  height: "100%",
  backgroundColor: "[rgb(34 34 34 / 0.7)]",
  zIndex: 902,
  backdropFilter: "auto",
  backdropBlur: "10px",
  _light: {
    backgroundColor: "[rgb(255 255 255 / 0.6)]"
  }
}), pickview = css({
  position: "absolute",
  top: "[2rem]",
  left: "[50%]",
  width: "100%",
  maxWidth: "600px",
  minWidth: "200px",
  transform: "translateX(-50%)",
  zIndex: 903
}), pickviewGroup = css({
  marginTop: "2",
  "& + &": {
    marginTop: "[32px]"
  }
});
css({
  height: [
    "100%",
    "100cqh"
  ],
  "& .mantine-ScrollArea-viewport": {
    minHeight: "100%",
    "& > div": {
      minHeight: "100%",
      height: "100%"
    }
  }
});
function PickView({ elementFqn }) {
  const searchActorRef = useSearchActor(), element = useLikeC4Model().element(elementFqn), scoped = [], others = [];
  for (const view of element.views())
    view.viewOf === element ? scoped.push(view) : others.push(view);
  const closePickView = () => {
    searchActorRef.send({ type: "pickview.close" });
  };
  return useWindowEvent(
    "keydown",
    (event) => {
      try {
        event.key === "Escape" && (event.stopPropagation(), event.preventDefault(), closePickView());
      } catch (e2) {
        console.warn(e2);
      }
    },
    {
      capture: !0
    }
  ), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      MotionDiv,
      {
        className: pickviewBackdrop,
        onClick: (e2) => {
          e2.stopPropagation(), closePickView();
        }
      },
      "pickview-backdrop"
    ),
    /* @__PURE__ */ jsx(FocusTrap, { children: /* @__PURE__ */ jsxs(
      MotionDiv,
      {
        initial: {
          opacity: 0,
          scale: 0.95,
          originY: 0,
          translateX: "-50%",
          translateY: -20
        },
        animate: {
          opacity: 1,
          scale: 1,
          translateY: 0
        },
        exit: {
          opacity: 0,
          scale: 0.98,
          translateY: -20,
          transition: {
            duration: 0.1
          }
        },
        className: pickview,
        "data-likec4-search-views": !0,
        children: [
          /* @__PURE__ */ jsxs(Group, { px: "sm", py: "md", justify: "space-between", children: [
            /* @__PURE__ */ jsx(Title$1, { order: 2, lh: 1, children: "Select view" }),
            /* @__PURE__ */ jsx(
              ActionIcon,
              {
                size: "md",
                variant: "default",
                onClick: (e2) => {
                  e2.stopPropagation(), closePickView();
                },
                children: /* @__PURE__ */ jsx(IconX, {})
              }
            )
          ] }),
          /* @__PURE__ */ jsxs(ScrollAreaAutosize, { mah: "calc(100vh - 110px)", type: "never", children: [
            scoped.length > 0 && /* @__PURE__ */ jsxs(Stack, { gap: "sm", px: "sm", className: pickviewGroup, children: [
              /* @__PURE__ */ jsx(Title$1, { order: 6, c: "dimmed", children: "scoped views of the element" }),
              scoped.map((view, i2) => /* @__PURE__ */ jsx(
                ViewButton,
                {
                  view,
                  search: "",
                  loop: !0,
                  focusOnElement: elementFqn,
                  mod: {
                    autofocus: i2 === 0
                  }
                },
                view.id
              ))
            ] }),
            others.length > 0 && /* @__PURE__ */ jsxs(Stack, { gap: "sm", px: "sm", className: pickviewGroup, children: [
              /* @__PURE__ */ jsx(Title$1, { order: 6, c: "dimmed", children: "views including this element" }),
              others.map((view, i2) => /* @__PURE__ */ jsx(
                ViewButton,
                {
                  view,
                  search: "",
                  loop: !0,
                  focusOnElement: elementFqn,
                  mod: {
                    autofocus: i2 === 0 && scoped.length === 0
                  }
                },
                view.id
              ))
            ] })
          ] })
        ]
      },
      "pickview"
    ) })
  ] });
}
function SearchByTags() {
  const ref = useRef(null);
  let tags = useLikeC4Model().tagsSortedByUsage, setSearch = useUpdateSearch(), search = useNormalizedSearch(), countBefore = tags.length, isFiltered = !1;
  if (search.startsWith("#")) {
    const searchTag = search.slice(1);
    tags = tags.filter(({ tag }) => tag.toLocaleLowerCase().includes(searchTag)), isFiltered = tags.length !== countBefore;
  }
  return tags.length === 0 ? null : (tags = tags.slice(0, 15), /* @__PURE__ */ jsxs(
    HStack,
    {
      ref,
      css: {
        gap: "md",
        paddingLeft: "[48px]",
        flexWrap: "nowrap"
      },
      children: [
        /* @__PURE__ */ jsx(
          HStack,
          {
            css: {
              gap: "1.5",
              // 6px
              flexWrap: "wrap",
              opacity: isFiltered ? 1 : 0.3,
              grayscale: isFiltered ? 0 : 0.9,
              filter: "auto",
              transition: "fast",
              _groupHover: {
                opacity: 1,
                grayscale: 0
              },
              _groupFocusWithin: {
                opacity: 1,
                grayscale: 0
              }
            },
            children: tags.map(({ tag }) => /* @__PURE__ */ jsx(
              ElementTag,
              {
                tag,
                className: css({
                  userSelect: "none",
                  cursor: "pointer"
                }),
                onClick: (e2) => {
                  e2.stopPropagation(), setSearch(`#${tag}`), setTimeout(() => {
                    focusToFirstFoundElement(ref.current);
                  }, 350);
                }
              },
              tag
            ))
          }
        ),
        isFiltered && /* @__PURE__ */ jsx(
          Button,
          {
            size: "compact-xs",
            variant: "light",
            onClick: (e2) => {
              e2.stopPropagation(), setSearch(""), moveFocusToSearchInput(ref.current);
            },
            rightSection: /* @__PURE__ */ jsx(IconX, { size: 14 }),
            children: "Clear"
          }
        )
      ]
    }
  ));
}
const __iconNode$p = [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]], IconSearch = createReactComponent("outline", "search", "Search", __iconNode$p);
function startingWithKind(search) {
  return search.match(/^(k|ki|kin|kind|kind:)$/) != null;
}
const SEARCH_PREFIXES = ["#", "kind:"], LikeC4SearchInput = memo$3(() => {
  const searchActorRef = useSearchActor(), likec4model = useLikeC4Model(), inputRef = useRef(null), { ref, focused: focused2 } = useFocusWithin(), [search, setSearch] = useSearch(), combobox = useCombobox({
    scrollBehavior: "smooth",
    loop: !1
  });
  useWindowEvent(
    "keydown",
    (event) => {
      try {
        !focused2 && (event.key === "Backspace" || event.key.startsWith("Arrow") || event.key.match(/^\p{L}$/u)) && moveFocusToSearchInput(inputRef.current);
      } catch (e2) {
        console.warn(e2);
      }
    }
  );
  let options = [], isExactMatch = !1;
  switch (!0) {
    // case search === '' && isEmptyForSomeTime === '': {
    //   options = SEARCH_PREFIXES.map((prefix) => (
    //     <ComboboxOption value={prefix} key={prefix}>
    //       <Text component="span" opacity={.5} mr={4} fz={'sm'}>Search by</Text>
    //       {prefix}
    //     </ComboboxOption>
    //   ))
    //   break
    // }
    case search.startsWith("#"): {
      const searchTag = search.toLocaleLowerCase().slice(1), alloptions = likec4model.tags.filter((tag) => tag.toLocaleLowerCase().includes(searchTag));
      alloptions.length === 0 ? (isExactMatch = !1, options = [
        /* @__PURE__ */ jsx(ComboboxEmpty, { children: "No tags found" }, "empty-tags")
      ]) : (isExactMatch = likec4model.tags.some((tag) => tag.toLocaleLowerCase() === searchTag), options = alloptions.map((tag) => /* @__PURE__ */ jsxs(ComboboxOption, { value: `#${tag}`, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "#" }),
        tag
      ] }, tag)));
      break;
    }
    case search.startsWith("kind:"):
    case startingWithKind(search): {
      const term = search.length > 5 ? search.slice(5).toLocaleLowerCase() : "";
      let alloptions = t$h(likec4model.specification.elements);
      term && (alloptions = alloptions.filter((kind) => kind.toLocaleLowerCase().includes(term))), alloptions.length === 0 ? (isExactMatch = !1, options = [
        /* @__PURE__ */ jsx(ComboboxEmpty, { children: "No kinds found" }, "empty-kinds")
      ]) : (isExactMatch = alloptions.some((kind) => kind.toLocaleLowerCase() === term), options = alloptions.map((kind) => /* @__PURE__ */ jsxs(ComboboxOption, { value: `kind:${kind}`, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "kind:" }),
        kind
      ] }, kind)));
      break;
    }
  }
  return /* @__PURE__ */ jsxs(
    Combobox,
    {
      onOptionSubmit: (optionValue) => {
        setSearch(optionValue), combobox.resetSelectedOption(), SEARCH_PREFIXES.includes(optionValue) || (combobox.closeDropdown(), setTimeout(() => {
          focusToFirstFoundElement(inputRef.current);
        }, 350));
      },
      width: "max-content",
      position: "bottom-start",
      shadow: "md",
      offset: {
        mainAxis: 4,
        crossAxis: 50
      },
      store: combobox,
      withinPortal: !1,
      children: [
        /* @__PURE__ */ jsx(ComboboxTarget, { children: /* @__PURE__ */ jsx(
          Input,
          {
            ref: useMergedRef(inputRef, ref),
            placeholder: "Search by title, description or start with # or kind:",
            autoFocus: !0,
            "data-autofocus": !0,
            "data-likec4-search-input": !0,
            tabIndex: 0,
            classNames: {
              input
            },
            size: "lg",
            value: search,
            leftSection: /* @__PURE__ */ jsx(IconSearch, { style: { width: rem(20) }, stroke: 2 }),
            rightSection: /* @__PURE__ */ jsx(
              Input.ClearButton,
              {
                onClick: (e2) => {
                  e2.stopPropagation();
                  const openedWithSearch = searchActorRef.getSnapshot().context.openedWithSearch;
                  search === "" || search === openedWithSearch ? searchActorRef.send({ type: "close" }) : setSearch("");
                }
              }
            ),
            rightSectionPointerEvents: "auto",
            onChange: (event) => {
              setSearch(event.currentTarget.value), combobox.openDropdown(), combobox.updateSelectedOptionIndex();
            },
            onClick: () => combobox.openDropdown(),
            onFocus: () => combobox.openDropdown(),
            onBlur: () => combobox.closeDropdown(),
            onKeyDownCapture: (e2) => {
              if (e2.key === "Tab") {
                switch (!0) {
                  case combobox.getSelectedOptionIndex() >= 0:
                    return combobox.clickSelectedOption(), stopAndPrevent$1(e2);
                  case options.length === 1:
                    return combobox.selectFirstOption() && combobox.clickSelectedOption(), stopAndPrevent$1(e2);
                  case startingWithKind(search):
                    return setSearch("kind:"), stopAndPrevent$1(e2);
                }
                return;
              }
              if (e2.key === "Backspace" && combobox.dropdownOpened) {
                if (search === "kind:")
                  return setSearch(""), combobox.resetSelectedOption(), stopAndPrevent$1(e2);
                if (search.startsWith("kind:") && isExactMatch)
                  return setSearch("kind:"), combobox.resetSelectedOption(), stopAndPrevent$1(e2);
                if (search.startsWith("#") && isExactMatch)
                  return setSearch("#"), combobox.resetSelectedOption(), stopAndPrevent$1(e2);
              }
              if (e2.key === "Escape" && combobox.dropdownOpened && options.length > 0) {
                stopAndPrevent$1(e2), combobox.closeDropdown();
                return;
              }
              if (e2.key === "ArrowUp" && combobox.dropdownOpened && search === "" && combobox.getSelectedOptionIndex() === 0) {
                combobox.closeDropdown(), stopAndPrevent$1(e2);
                return;
              }
              if (e2.key === "ArrowDown" && (!combobox.dropdownOpened || options.length === 0 || isExactMatch || // reached the last option and the search is empty
              search === "" && combobox.getSelectedOptionIndex() === options.length - 1)) {
                combobox.closeDropdown(), stopAndPrevent$1(e2), focusToFirstFoundElement(inputRef.current);
                return;
              }
            }
          }
        ) }),
        /* @__PURE__ */ jsx(ComboboxDropdown, { hidden: options.length === 0, style: { minWidth: 300 }, children: /* @__PURE__ */ jsx(ComboboxOptions, { children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "min(322px, calc(100cqh - 50px))", type: "scroll", children: options }) }) })
      ]
    }
  );
}), dialog = css({
  backgroundColor: "[rgb(34 34 34 / var(--_opacity, 95%))]",
  _light: {
    backgroundColor: "[rgb(250 250 250 / var(--_opacity, 95%))]"
  },
  backdropFilter: "auto",
  backdropBlur: "var(--_blur, 10px)"
  //   base: `[rgb(34 34 34 / var(${backdropOpacity}))]`,
  //   _light: `[rgb(255 255 255/ var(${backdropOpacity}))]`,
  // },
}), body = css({
  // containerName: 'likec4-search',
  // containerType: 'size',
  // position: 'fixed',
  // zIndex: 901,
  // top: '0',
  // left: '0',
  width: "100%",
  height: "100%",
  maxHeight: "100vh",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
  justifyContent: "stretch",
  gap: "sm",
  paddingTop: "[20px]",
  paddingLeft: "md",
  paddingRight: "md",
  paddingBottom: "sm",
  background: "[transparent]"
  // backgroundColor: {
  //   _dark: `[rgb(34 34 34 / 0.95)]`,
  //   _light: `[rgb(255 255 255/ 0.95)]`,
  // },
}), selectIsOpened = (s2) => !s2.matches("inactive");
function Search({ searchActorRef }) {
  const isOpened = useSelector(searchActorRef, selectIsOpened), openSearch = () => {
    searchActorRef.send({ type: "open" });
  }, close = useCallbackRef(() => {
    searchActorRef.send({ type: "close" });
  });
  return useHotkeys([
    ["mod+k", openSearch, {
      preventDefault: !0
    }],
    ["mod+f", openSearch, {
      preventDefault: !0
    }]
  ]), /* @__PURE__ */ jsx(SearchActorContext, { value: searchActorRef, children: /* @__PURE__ */ jsx(DiagramFeatures.Overlays, { children: /* @__PURE__ */ jsx(ErrorBoundary$1, { FallbackComponent: ErrorFallback, onReset: close, children: /* @__PURE__ */ jsx(AnimatePresence, { children: isOpened && /* @__PURE__ */ jsx(
    Overlay,
    {
      fullscreen: !0,
      withBackdrop: !1,
      backdrop: {
        opacity: 0.9
      },
      classes: {
        dialog,
        body
      },
      openDelay: 0,
      onClose: close,
      "data-likec4-search": "true",
      children: /* @__PURE__ */ jsx(SearchOverlay, { searchActorRef })
    }
  ) }) }) }) });
}
const scrollArea = css({
  height: [
    "100%",
    "100cqh"
  ],
  "& .mantine-ScrollArea-viewport": {
    minHeight: "100%",
    "& > div": {
      minHeight: "100%",
      height: "100%"
    }
  }
}), SearchOverlay = ({ searchActorRef }) => {
  const ref = useRef(null), pickViewFor = usePickViewFor();
  return useTimeoutEffect(() => {
    e$1(searchActorRef.getSnapshot().context.openedWithSearch) && focusToFirstFoundElement(ref.current);
  }, 150), /* @__PURE__ */ jsxs(Box, { ref, display: "contents", children: [
    /* @__PURE__ */ jsx(
      Group,
      {
        className: "group",
        wrap: "nowrap",
        onClick: (e2) => {
          e2.stopPropagation(), moveFocusToSearchInput(ref.current);
        },
        children: /* @__PURE__ */ jsxs(VStack, { flex: 1, px: "sm", children: [
          /* @__PURE__ */ jsx(LikeC4SearchInput, {}),
          /* @__PURE__ */ jsx(SearchByTags, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxs(Grid, { children: [
      /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(Title$1, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Elements" }) }),
      /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(Title$1, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Views" }) })
    ] }),
    /* @__PURE__ */ jsxs(
      Grid,
      {
        className: css({
          containerName: "likec4-search-elements",
          containerType: "size",
          overflow: "hidden",
          flexGrow: 1
        }),
        children: [
          /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(
            ScrollArea,
            {
              type: "scroll",
              className: scrollArea,
              pr: "xs",
              scrollbars: "y",
              children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-elements", children: /* @__PURE__ */ jsx(ElementsColumn, {}) }) })
            }
          ) }),
          /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(
            ScrollArea,
            {
              type: "scroll",
              className: scrollArea,
              pr: "xs",
              scrollbars: "y",
              children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-views", children: /* @__PURE__ */ jsx(ViewsColumn, {}) }) })
            }
          ) })
        ]
      }
    ),
    pickViewFor && /* @__PURE__ */ jsx(PickView, { elementFqn: pickViewFor })
  ] });
};
function PortalToContainer({ children: children2 }) {
  const ctx = useContext(RootContainerContext);
  if (!ctx)
    throw new Error("PortalToContainer must be used within RootContainer");
  return /* @__PURE__ */ jsx(Portal, { target: ctx.ref.current ?? `#${ctx.id}`, children: children2 });
}
const defaultHandlers = {
  onNavigateTo: null,
  onNodeClick: null,
  onNodeContextMenu: null,
  onCanvasContextMenu: null,
  onEdgeClick: null,
  onEdgeContextMenu: null,
  onCanvasClick: null,
  onCanvasDblClick: null,
  onLogoClick: null,
  onOpenSource: null,
  onInitialized: null,
  onLayoutTypeChange: null
}, HandlerNames = t$h(defaultHandlers), DiagramEventHandlersReactContext = createContext({
  ...t$e(HandlerNames, (name) => [name, null]),
  handlersRef: {
    current: defaultHandlers
  }
});
function DiagramEventHandlers({
  handlers,
  children: children2
}) {
  const handlersRef = useSyncedRef(
    handlers
  ), deps = HandlerNames.map((name) => e$9(handlers[name])), value = useMemo(() => ({
    ...t$e(HandlerNames, (name) => handlersRef.current[name] ? [name, (...args) => handlersRef.current[name]?.(...args)] : [name, null]),
    handlersRef
  }), [handlersRef, ...deps]);
  return /* @__PURE__ */ jsx(DiagramEventHandlersReactContext.Provider, { value, children: children2 });
}
function useDiagramEventHandlers() {
  return useContext(DiagramEventHandlersReactContext);
}
const findNodeByModelFqn = (xynodes, elementFqn) => {
  const node2 = xynodes.find((n2) => "modelFqn" in n2.data && n2.data.modelFqn === elementFqn);
  return node2 || null;
};
function typedSystem(system) {
  return {
    get overlaysActorRef() {
      return system.get("overlays") ?? null;
    },
    get diagramActorRef() {
      return nonNullable$1(system.get("diagram"), "Diagram actor not found");
    },
    get searchActorRef() {
      return system.get("search") ?? null;
    },
    get editorActorRef() {
      return system.get("editor") ?? null;
    }
  };
}
typedSystem.editorActor = ({ system }) => system.get("editor");
typedSystem.overlaysActor = ({ system }) => system.get("overlays");
typedSystem.diagramActor = ({ system }) => system.get("diagram");
typedSystem.searchActor = ({ system }) => system.get("search");
function findDiagramNode(ctx, xynodeId) {
  return ctx.view.nodes.find((n2) => n2.id === xynodeId) ?? null;
}
function findDiagramEdge(ctx, xyedgeId) {
  return ctx.view.edges.find((e2) => e2.id === xyedgeId) ?? null;
}
function focusedBounds(params) {
  const knownAbsolutes = /* @__PURE__ */ new Map(), b2 = params.context.xynodes.reduce((acc, node2) => {
    let position = node2.position;
    if (node2.parentId) {
      const parent = knownAbsolutes.get(node2.parentId) ?? { x: 0, y: 0 };
      position = {
        x: position.x + parent.x,
        y: position.y + parent.y
      };
    }
    if (knownAbsolutes.set(node2.id, position), node2.hidden || node2.data.dimmed)
      return acc;
    const width = node2.measured?.width ?? node2.width ?? node2.initialWidth, height = node2.measured?.height ?? node2.height ?? node2.initialHeight;
    return acc.minX = Math.min(acc.minX, position.x), acc.minY = Math.min(acc.minY, position.y), acc.maxX = Math.max(acc.maxX, position.x + width), acc.maxY = Math.max(acc.maxY, position.y + height), acc;
  }, {
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  });
  return b2.minX === 1 / 0 ? {
    bounds: params.context.view.bounds
  } : {
    duration: 350,
    bounds: {
      x: b2.minX - 10,
      y: b2.minY - 10,
      width: b2.maxX - b2.minX + 20,
      height: b2.maxY - b2.minY + 20
    }
  };
}
const MARGIN = 32;
function activeSequenceBounds(params) {
  const activeWalkthrough = nonNullable$1(params.context.activeWalkthrough), stepEdge = nonNullable$1(params.context.xyedges.find((e2) => e2.id === activeWalkthrough.stepId)), xystate = params.context.xystore.getState(), sourceNode = nonNullable$1(xystate.nodeLookup.get(stepEdge.source)), targetNode = nonNullable$1(xystate.nodeLookup.get(stepEdge.target)), actorsBounds = getNodesBounds([sourceNode, targetNode], xystate);
  let stepBounds;
  if (activeWalkthrough.parallelPrefix) {
    const parallelArea = params.context.xynodes.find(
      (n2) => n2.type === "seq-parallel" && n2.data.parallelPrefix === activeWalkthrough.parallelPrefix
    );
    parallelArea && (stepBounds = {
      x: parallelArea.position.x,
      y: parallelArea.position.y,
      ...getNodeDimensions(parallelArea)
    });
  }
  return stepBounds ??= getEdgeBounds(stepEdge, xystate), stepBounds ? stepBounds = BBox$1.merge(stepBounds, actorsBounds) : stepBounds = actorsBounds, {
    duration: 350,
    bounds: BBox$1.expand(
      stepBounds,
      MARGIN
    )
  };
}
function getEdgeBounds(edge, store) {
  const sourceNode = store.nodeLookup.get(edge.source), targetNode = store.nodeLookup.get(edge.target);
  if (!sourceNode || !targetNode)
    return null;
  const edgePosition = getEdgePosition({
    id: edge.id,
    sourceNode,
    targetNode,
    sourceHandle: edge.sourceHandle || null,
    targetHandle: edge.targetHandle || null,
    connectionMode: store.connectionMode
  });
  return edgePosition ? BBox$1.fromPoints([
    [edgePosition.sourceX, edgePosition.sourceY],
    [edgePosition.targetX, edgePosition.targetY]
  ]) : null;
}
function nodeRef(node2) {
  switch (node2.type) {
    case "element":
    case "compound-element":
    case "seq-actor":
      return node2.data.modelFqn;
    case "deployment":
    case "compound-deployment":
      return node2.data.modelFqn ?? node2.data.deploymentFqn;
    case "seq-parallel":
    case "view-group":
      return null;
    default:
      nonexhaustive$1(node2);
  }
}
function findCorrespondingNode(context2, event) {
  const fromNodeId = context2.lastOnNavigate?.fromNode, fromNode = fromNodeId && context2.xynodes.find((n2) => n2.id === fromNodeId), fromRef = fromNode && nodeRef(fromNode), toNode = fromRef && event.xynodes.find((n2) => nodeRef(n2) === fromRef);
  return { fromNode, toNode };
}
function calcViewportForBounds(context2, bounds) {
  let {
    width,
    height,
    transform: transform2
  } = context2.xystore.getState();
  const maxZoom = Math.max(transform2[2], 1);
  return getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
}
const _actorLogic$1 = setup({
  delays: {
    "open timeout": ({ context: context2 }) => context2.openTimeout,
    "close timeout": 600,
    "long idle": 1500
  },
  actions: {
    "update edgeId": assign(({ context: context2, event }) => (assertEvent(event, ["xyedge.select", "xyedge.mouseEnter"]), {
      edgeId: event.edgeId,
      edgeSelected: context2.edgeSelected || event.type === "xyedge.select"
    })),
    "increase open timeout": assign(() => ({
      openTimeout: 800
    })),
    "decrease open timeout": assign(() => ({
      openTimeout: 300
    })),
    "reset edgeId": assign({
      edgeId: null,
      edgeSelected: !1
    })
  },
  guards: {
    "edge was selected": ({ context: context2 }) => context2.edgeSelected,
    "edge was hovered": ({ context: context2 }) => !context2.edgeSelected
  }
}).createMachine({
  id: "breadcrumbs",
  context: () => ({
    edgeId: null,
    edgeSelected: !1,
    openTimeout: 800
  }),
  initial: "idle",
  on: {
    close: {
      target: "#idle",
      actions: [
        "reset edgeId",
        "increase open timeout"
      ]
    }
  },
  states: {
    idle: {
      id: "idle",
      on: {
        "xyedge.mouseEnter": {
          target: "opening",
          actions: "update edgeId"
        },
        "xyedge.select": {
          target: "active",
          actions: "update edgeId"
        }
      },
      after: {
        "long idle": {
          actions: "increase open timeout"
        }
      }
    },
    opening: {
      on: {
        "xyedge.mouseLeave": {
          target: "idle"
        },
        "xyedge.select": {
          target: "active",
          actions: "update edgeId"
        }
      },
      after: {
        "open timeout": {
          actions: "decrease open timeout",
          target: "active"
        }
      }
    },
    active: {
      tags: ["opened"],
      initial: "opened",
      exit: "reset edgeId",
      on: {
        "xyedge.unselect": {
          target: "idle",
          actions: "increase open timeout"
        },
        "xyedge.select": {
          actions: "update edgeId"
        }
      },
      states: {
        opened: {
          on: {
            "dropdown.mouseEnter": {
              target: "hovered"
            },
            "xyedge.mouseLeave": {
              guard: "edge was hovered",
              target: "closing"
            }
          }
        },
        hovered: {
          on: {
            "dropdown.mouseLeave": [
              {
                guard: "edge was selected",
                target: "opened"
              },
              {
                target: "closing"
              }
            ]
          }
        },
        closing: {
          on: {
            "xyedge.mouseEnter": {
              guard: "edge was hovered",
              target: "opened",
              actions: "update edgeId"
            },
            "xyedge.select": {
              target: "opened",
              actions: "update edgeId"
            },
            "dropdown.mouseEnter": {
              target: "hovered"
            }
          },
          after: {
            "close timeout": {
              target: "#idle"
            }
          }
        }
      }
    }
  }
}), RelationshipPopoverActorLogic = _actorLogic$1, endpoint = css({
  display: "block",
  fontSize: "xxs",
  fontWeight: 500,
  whiteSpace: "nowrap",
  paddingX: "1",
  paddingY: "0.5",
  borderRadius: "[2px]",
  background: {
    _light: "var(--likec4-palette-fill)/90",
    _dark: "var(--likec4-palette-fill)/60"
  },
  lineHeight: "1",
  color: {
    _light: "var(--likec4-palette-hiContrast)",
    _dark: "var(--likec4-palette-loContrast)"
  }
}), title = css({
  whiteSpaceCollapse: "preserve-breaks",
  fontSize: "sm",
  lineHeight: "sm",
  userSelect: "all"
});
function selectDiagramContext(c) {
  let selected2 = null;
  for (const edge of c.xyedges)
    if (edge.selected) {
      if (selected2) {
        selected2 = null;
        break;
      }
      selected2 = edge.data.id;
    }
  return {
    viewId: c.view.id,
    selected: selected2
  };
}
const RelationshipPopover = memo$3(() => {
  const likec4model = useLikeC4Model(), actorRef = useActorRef(RelationshipPopoverActorLogic), diagram = useDiagram(), { viewId, selected: selected2 } = useDiagramContext(selectDiagramContext), openedEdgeId = useSelector(actorRef, (s2) => s2.hasTag("opened") ? s2.context.edgeId : null);
  useOnDiagramEvent("navigateTo", () => {
    actorRef.send({ type: "close" });
  }), useOnDiagramEvent("edgeMouseEnter", ({ edge }) => {
    actorRef.send({ type: "xyedge.mouseEnter", edgeId: edge.data.id });
  }), useOnDiagramEvent("edgeMouseLeave", () => {
    actorRef.send({ type: "xyedge.mouseLeave" });
  }), useOnDiagramEvent("walkthroughStarted", () => {
    actorRef.send({ type: "close" });
  }), useEffect(() => {
    selected2 ? actorRef.send({ type: "xyedge.select", edgeId: selected2 }) : actorRef.send({ type: "xyedge.unselect" });
  }, [selected2]);
  const onMouseEnter = useCallback((event) => {
    if (!openedEdgeId)
      return;
    actorRef.send({ type: "dropdown.mouseEnter" });
    const edge = diagram.findEdge(openedEdgeId);
    edge && !edge.data.hovered && diagram.send({ type: "xyflow.edgeMouseEnter", edge, event });
  }, [actorRef, diagram, openedEdgeId]), onMouseLeave = useCallback((event) => {
    if (!openedEdgeId)
      return;
    actorRef.send({ type: "dropdown.mouseLeave" });
    const edge = diagram.findEdge(openedEdgeId);
    edge?.data.hovered && diagram.send({ type: "xyflow.edgeMouseLeave", edge, event });
  }, [actorRef, diagram, openedEdgeId]), { diagramEdge, sourceNode, targetNode } = useDiagramContext(
    (ctx) => {
      const diagramEdge2 = openedEdgeId ? findDiagramEdge(ctx, openedEdgeId) : null, sourceNode2 = diagramEdge2 ? findDiagramNode(ctx, diagramEdge2.source) : null, targetNode2 = diagramEdge2 ? findDiagramNode(ctx, diagramEdge2.target) : null;
      return {
        diagramEdge: diagramEdge2,
        sourceNode: sourceNode2,
        targetNode: targetNode2
      };
    },
    shallowEqual$1,
    [openedEdgeId]
  );
  if (!diagramEdge || !sourceNode || !targetNode || e$a(diagramEdge.relations))
    return null;
  const [direct, nested] = t$s(
    diagramEdge.relations,
    t$f((id2) => {
      try {
        return likec4model.relationship(id2);
      } catch (e2) {
        return console.error(
          `View is cached and likec4model missing relationship ${id2} from ${sourceNode.id} -> ${targetNode.id}`,
          e2
        ), null;
      }
    }),
    n$q(e$1),
    t$a((r2) => r2.source.id === sourceNode.id && r2.target.id === targetNode.id)
  );
  return direct.length === 0 && nested.length === 0 ? (console.warn("No relationships found  diagram edge", {
    diagramEdge,
    sourceNode,
    targetNode
  }), null) : /* @__PURE__ */ jsx(PortalToContainer, { children: /* @__PURE__ */ jsx(
    RelationshipPopoverInternal,
    {
      viewId,
      direct,
      nested,
      diagramEdge,
      sourceNode,
      targetNode,
      onMouseEnter,
      onMouseLeave
    }
  ) });
}), getEdgeLabelElement = (edgeId, container2) => container2?.querySelector(`.likec4-edge-label[data-edge-id="${edgeId}"]`) ?? container2?.querySelector(`.likec4-edge-middle-point[data-edge-id="${edgeId}"]`) ?? null, POPOVER_PADDING = 8, RelationshipPopoverInternal = ({
  viewId,
  diagramEdge,
  direct,
  nested,
  sourceNode,
  targetNode,
  onMouseEnter,
  onMouseLeave
}) => {
  const ref = useRef(null), { enableNavigateTo, enableVscode, enableCompareWithLatest } = useEnabledFeatures(), { onOpenSource } = useDiagramEventHandlers(), containerRef = useRootContainerRef(), [referenceEl, setReferenceEl] = useState(null);
  useLayoutEffect(() => {
    setReferenceEl(getEdgeLabelElement(diagramEdge.id, containerRef.current));
  }, [diagramEdge]), useEffect(() => {
    const reference = referenceEl, popper = ref.current;
    if (!reference || !popper)
      return;
    let wasCanceled = !1;
    const cleanup = autoUpdate(reference, popper, () => {
      computePosition(reference, popper, {
        placement: "bottom-start",
        middleware: [
          offset$1(4),
          autoPlacement({
            crossAxis: !0,
            // padding: POPOVER_PADDING,
            allowedPlacements: [
              "bottom-start",
              "bottom-end",
              "left-start",
              "top-start",
              "top-end",
              "right-start",
              "right-end",
              "left-end"
            ]
          }),
          size$1({
            apply({ availableHeight, availableWidth, elements }) {
              wasCanceled || Object.assign(elements.floating.style, {
                maxWidth: `${t$v(roundDpr(availableWidth), { min: 220, max: 400 })}px`,
                maxHeight: `${t$v(roundDpr(availableHeight), { min: 100, max: 500 })}px`
              });
            }
          }),
          hide$1({
            padding: POPOVER_PADDING * 2
          })
        ]
      }).then(({ x: x2, y: y2, middlewareData }) => {
        wasCanceled || (popper.style.transform = `translate(${roundDpr(x2)}px, ${roundDpr(y2)}px)`, popper.style.visibility = middlewareData.hide?.referenceHidden ? "hidden" : "visible");
      });
    }, {
      ancestorResize: !1,
      animationFrame: !0
    });
    return () => {
      wasCanceled = !0, cleanup();
    };
  }, [referenceEl]);
  const diagram = useDiagram(), renderRelationship = useCallback(
    (relationship, index2) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
      index2 > 0 && /* @__PURE__ */ jsx(Divider$2, {}),
      /* @__PURE__ */ jsx(
        Relationship,
        {
          viewId,
          relationship,
          sourceNode,
          targetNode,
          onNavigateTo: enableNavigateTo ? (viewId2) => {
            diagram.navigateTo(viewId2);
          } : void 0,
          ...onOpenSource && enableVscode && {
            onOpenSource: () => onOpenSource({ relation: relationship.id })
          }
        }
      )
    ] }, relationship.id),
    [viewId, sourceNode, targetNode, diagram, enableNavigateTo, onOpenSource, enableVscode]
  );
  return /* @__PURE__ */ jsx(
    ScrollAreaAutosize,
    {
      ref,
      onMouseEnter,
      onMouseLeave,
      type: "auto",
      scrollbars: "y",
      scrollbarSize: 6,
      styles: {
        viewport: {
          overscrollBehavior: "contain",
          minWidth: 200,
          minHeight: 40
        }
      },
      className: cx(
        css({
          layerStyle: "likec4.dropdown",
          p: "0",
          pointerEvents: {
            base: "all",
            _whenPanning: "none"
          },
          position: "absolute",
          top: "0",
          left: "0",
          width: "max-content",
          cursor: "default"
        })
      ),
      children: /* @__PURE__ */ jsxs(
        VStack,
        {
          css: {
            gap: "3",
            padding: "4",
            paddingTop: "2"
          },
          children: [
            enableCompareWithLatest && /* @__PURE__ */ jsx(EdgeDrifts$1, { diagramEdge }),
            /* @__PURE__ */ jsx(
              Button,
              {
                variant: "default",
                color: "gray",
                size: "compact-xs",
                style: {
                  alignSelf: "flex-start",
                  fontWeight: 500,
                  "--button-fz": "var(--font-sizes-xxs)"
                },
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.openRelationshipDetails(diagramEdge.id);
                },
                children: "browse relationships"
              }
            ),
            direct.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(Label$1, { children: "DIRECT RELATIONSHIPS" }),
              direct.map(renderRelationship)
            ] }),
            nested.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(
                Label$1,
                {
                  css: {
                    mt: direct.length > 0 ? "2" : "0"
                  },
                  children: "RESOLVED FROM NESTED"
                }
              ),
              nested.map(renderRelationship)
            ] })
          ]
        }
      )
    }
  );
}, EdgeDrifts$1 = ({ diagramEdge }) => {
  const drifts = diagramEdge.drifts;
  return !drifts || drifts.length === 0 ? null : /* @__PURE__ */ jsx(
    Notification,
    {
      color: "orange",
      withBorder: !1,
      withCloseButton: !1,
      title: "Changes:",
      children: drifts.map((drift) => /* @__PURE__ */ jsxs(Text, { mt: 2, size: "sm", lh: "xs", children: [
        "- ",
        drift
      ] }, drift))
    }
  );
}, Relationship = forwardRef(({
  viewId,
  relationship: r2,
  sourceNode,
  targetNode,
  onNavigateTo,
  onOpenSource
}, ref) => {
  const sourceId = getEndpointId(r2, "source", sourceNode), targetId = getEndpointId(r2, "target", targetNode), navigateTo = onNavigateTo && r2.navigateTo?.id !== viewId ? r2.navigateTo?.id : void 0, links = r2.links, metadataEntries = r2.hasMetadata() ? t$o(r2.getMetadata()).sort(([a2], [b2]) => a2.localeCompare(b2)) : null, metadataTooltipLabel = metadataEntries && /* @__PURE__ */ jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "6px" }, children: [
    /* @__PURE__ */ jsx(
      "div",
      {
        style: {
          fontWeight: 600,
          fontSize: "10px",
          color: "#868e96",
          marginBottom: "2px",
          letterSpacing: "0.5px",
          textTransform: "uppercase"
        },
        children: "Metadata"
      }
    ),
    /* @__PURE__ */ jsx(
      "div",
      {
        style: {
          borderTop: "1px solid rgba(0, 0, 0, 0.1)",
          paddingTop: "6px",
          display: "flex",
          flexDirection: "column",
          gap: "6px"
        },
        children: metadataEntries.map(([key2, value]) => {
          const displayValue = Array.isArray(value) ? value.join(", ") : value;
          return /* @__PURE__ */ jsxs("div", { style: { display: "flex", gap: "12px", fontSize: "12px", lineHeight: "1.4" }, children: [
            /* @__PURE__ */ jsxs(
              "span",
              {
                style: {
                  fontWeight: 600,
                  minWidth: "110px",
                  color: "#495057"
                },
                children: [
                  key2,
                  ":"
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              "span",
              {
                style: {
                  color: "#212529",
                  wordBreak: "break-word",
                  flex: 1
                },
                children: displayValue
              }
            )
          ] }, key2);
        })
      }
    )
  ] });
  return /* @__PURE__ */ jsxs(
    VStack,
    {
      ref,
      className: bleed({
        block: "2",
        inline: "2",
        paddingY: "2.5",
        paddingX: "2",
        gap: "1",
        rounded: "sm",
        backgroundColor: {
          _hover: {
            base: "mantine.colors.gray[1]",
            _dark: "mantine.colors.dark[5]/70"
          }
        }
      }),
      children: [
        /* @__PURE__ */ jsx(HStack, { gap: "0.5", children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 200, children: [
          /* @__PURE__ */ jsx(Tooltip$3, { label: sourceId.full, offset: 2, position: "top-start", children: /* @__PURE__ */ jsx(Text, { component: "div", "data-likec4-color": sourceNode.color, className: endpoint, children: sourceId.short }) }),
          /* @__PURE__ */ jsx(IconArrowRight, { stroke: 2.5, size: "11px", opacity: 0.65 }),
          /* @__PURE__ */ jsx(Tooltip$3, { label: targetId.full, offset: 2, position: "top-start", children: /* @__PURE__ */ jsx(Text, { component: "div", "data-likec4-color": targetNode.color, className: endpoint, children: targetId.short }) }),
          navigateTo && /* @__PURE__ */ jsx(Tooltip$3, { label: "Open dynamic view", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              size: "sm",
              radius: "sm",
              variant: "default",
              onClick: (event) => {
                event.stopPropagation(), onNavigateTo?.(navigateTo);
              },
              style: {
                alignSelf: "flex-end"
              },
              role: "button",
              children: /* @__PURE__ */ jsx(IconZoomScan, { size: "80%", stroke: 2 })
            }
          ) }),
          onOpenSource && /* @__PURE__ */ jsx(Tooltip$3, { label: "Open source", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              size: "sm",
              radius: "sm",
              variant: "default",
              onClick: (event) => {
                event.stopPropagation(), onOpenSource();
              },
              role: "button",
              children: /* @__PURE__ */ jsx(IconFileSymlink, { size: "80%", stroke: 2 })
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsxs(HStack, { gap: "xs", alignItems: "center", children: [
          /* @__PURE__ */ jsx(Box, { className: title, children: r2.title || "untitled" }),
          metadataTooltipLabel && /* @__PURE__ */ jsx(
            Tooltip$3,
            {
              label: metadataTooltipLabel,
              w: 350,
              position: "right",
              offset: 10,
              openDelay: 300,
              withArrow: !0,
              bg: "white",
              c: "dark",
              withinPortal: !0,
              styles: {
                tooltip: {
                  boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                  border: "1px solid #dee2e6"
                }
              },
              children: /* @__PURE__ */ jsx(Box, { display: "inline-flex", children: /* @__PURE__ */ jsx(
                IconInfoCircle,
                {
                  size: 14,
                  opacity: 0.5,
                  style: { flexShrink: 0, cursor: "help" }
                }
              ) })
            }
          )
        ] }),
        r2.kind && /* @__PURE__ */ jsxs(HStack, { gap: "2", children: [
          /* @__PURE__ */ jsx(Label$1, { children: "kind" }),
          /* @__PURE__ */ jsx(Text, { size: "xs", className: css({ userSelect: "all" }), children: r2.kind })
        ] }),
        r2.technology && /* @__PURE__ */ jsxs(HStack, { gap: "2", children: [
          /* @__PURE__ */ jsx(Label$1, { children: "technology" }),
          /* @__PURE__ */ jsx(Text, { size: "xs", className: css({ userSelect: "all" }), children: r2.technology })
        ] }),
        r2.summary.nonEmpty && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Label$1, { children: "description" }),
          /* @__PURE__ */ jsx(
            Box,
            {
              css: {
                paddingLeft: "2.5",
                py: "1.5",
                borderLeft: "2px dotted",
                borderLeftColor: {
                  base: "mantine.colors.gray[3]",
                  _dark: "mantine.colors.dark[4]"
                }
              },
              children: /* @__PURE__ */ jsx(Markdown, { value: r2.summary, fontSize: "sm", textScale: 0.875 })
            }
          )
        ] }),
        links.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Label$1, { children: "links" }),
          /* @__PURE__ */ jsx(HStack, { gap: "1", flexWrap: "wrap", children: links.map((link) => /* @__PURE__ */ jsx(Link, { size: "sm", value: link }, link.url)) })
        ] })
      ]
    }
  );
}), Label$1 = styled("div", {
  base: {
    display: "block",
    fontSize: "xxs",
    fontWeight: 500,
    userSelect: "none",
    lineHeight: "sm",
    color: "mantine.colors.dimmed"
  }
}), Tooltip$3 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function getEndpointId(r2, endpoint2, diagramNode) {
  const diagramNodeId = r2.isDeploymentRelation() ? diagramNode.id : diagramNode.modelRef || "", full = r2[endpoint2].id, short = nameFromFqn(diagramNodeId) + full.slice(diagramNodeId.length);
  return { full, short };
}
function useMantinePortalProps() {
  const target = useRootContainerElement();
  return useMemo(() => target ? { portalProps: { target }, withinPortal: !0 } : { withinPortal: !1 }, [target]);
}
const _actorLogic = setup({
  delays: {
    "open timeout": 500,
    "close timeout": 350
  },
  actions: {
    "update activatedBy": assign({
      activatedBy: ({ context: context2, event }) => {
        switch (!0) {
          case event.type.includes("click"):
            return "click";
          case event.type.includes("mouseEnter"):
            return "hover";
          default:
            return context2.activatedBy;
        }
      }
    }),
    "keep dropdown open": assign({
      activatedBy: "click"
    }),
    "update selected folder": assign(({ event }) => event.type === "breadcrumbs.click.root" ? { selectedFolder: "" } : (assertEvent(event, ["breadcrumbs.click.folder", "select.folder"]), { selectedFolder: event.folderPath })),
    "reset selected folder": assign({
      selectedFolder: ({ context: context2 }) => context2.viewModel?.folder.path ?? ""
    }),
    "update inputs": assign(({ context: context2, event }) => {
      assertEvent(event, "update.inputs");
      const viewChanged = event.inputs.viewModel?.id !== context2.viewModel?.id;
      let selectedFolder = context2.selectedFolder;
      return event.inputs.viewModel?.folder.path.startsWith(selectedFolder) || (selectedFolder = event.inputs.viewModel?.folder.path ?? ""), {
        view: event.inputs.view,
        viewModel: event.inputs.viewModel,
        selectedFolder,
        // allow dropdown to close on mouse leave if view changed
        activatedBy: viewChanged ? "hover" : context2.activatedBy
      };
    }),
    "reset search query": assign({
      searchQuery: ""
    }),
    "update search query": assign(({ event }) => (assertEvent(event, "searchQuery.change"), { searchQuery: event.value ?? "" })),
    "emit navigateTo": emit(({ event }) => (assertEvent(event, "select.view"), {
      type: "navigateTo",
      viewId: event.viewId
    }))
  },
  guards: {
    "was opened on hover": ({ context: context2 }) => context2.activatedBy === "hover",
    "has search query": ({ context: context2 }) => !e$a(context2.searchQuery),
    "search query is empty": ({ context: context2 }) => e$a(context2.searchQuery)
  }
}).createMachine({
  id: "breadcrumbs",
  context: ({ input: input2 }) => ({
    ...input2,
    breadcrumbs: [],
    activatedBy: "hover",
    selectedFolder: "",
    searchQuery: "",
    folderColumns: []
  }),
  initial: "idle",
  entry: [
    "update activatedBy",
    "reset selected folder"
  ],
  on: {
    "update.inputs": {
      actions: "update inputs"
    },
    "searchQuery.change": {
      actions: [
        "update search query",
        raise({ type: "searchQuery.changed" })
      ]
    }
  },
  states: {
    idle: {
      id: "idle",
      on: {
        "breadcrumbs.mouseEnter.*": {
          target: "pending",
          actions: "update activatedBy"
        },
        "breadcrumbs.click.*": {
          target: "active",
          actions: "update activatedBy"
        }
      }
    },
    // Breadcrumbs are hovered, but dropdown is not opened yet
    pending: {
      on: {
        "breadcrumbs.mouseEnter.*": {
          actions: "update activatedBy"
        },
        "breadcrumbs.mouseLeave.*": {
          target: "idle"
        },
        "breadcrumbs.click.*": {
          target: "active",
          actions: "update activatedBy"
        }
      },
      after: {
        "open timeout": {
          target: "active"
        }
      }
    },
    active: {
      tags: ["active"],
      initial: "decide",
      on: {
        "dropdown.dismiss": {
          target: "#idle"
        },
        "breadcrumbs.mouseLeave": {
          guard: "was opened on hover",
          target: ".closing"
        },
        "dropdown.mouseLeave": {
          guard: "was opened on hover",
          target: ".closing"
        },
        "searchQuery.changed": {
          target: ".decide"
        }
      },
      states: {
        // Decide next state based on the search query
        decide: {
          always: [
            {
              guard: "has search query",
              target: "search"
            },
            {
              target: "opened"
            }
          ]
        },
        opened: {
          on: {
            "searchQuery.changed": {
              guard: "has search query",
              actions: "keep dropdown open",
              target: "search"
            },
            "breadcrumbs.click.viewtitle": {
              actions: "reset selected folder"
            },
            "breadcrumbs.click.*": {
              actions: "update selected folder"
            },
            "select.folder": {
              actions: [
                "keep dropdown open",
                "update selected folder"
              ]
            },
            "select.view": {
              actions: [
                "emit navigateTo"
              ]
            }
          }
        },
        search: {
          on: {
            "breadcrumbs.click.viewtitle": {
              actions: [
                "reset search query",
                "reset selected folder"
              ],
              target: "opened"
            },
            "breadcrumbs.click.*": {
              actions: [
                "reset search query",
                "update selected folder"
              ],
              target: "opened"
            },
            "select.view": {
              actions: [
                "emit navigateTo"
              ]
            }
          }
        },
        closing: {
          on: {
            "breadcrumbs.mouseEnter.*": {
              target: "decide"
            },
            "dropdown.mouseEnter": {
              target: "decide"
            }
          },
          after: {
            "close timeout": {
              target: "#idle"
            }
          }
        }
      }
    }
  }
}), navigationPanelActorLogic = _actorLogic, NavigationPanelActorSafeContext = createContext(null);
NavigationPanelActorSafeContext.displayName = "NavigationPanelActorSafeContext";
const NavigationPanelActorContextProvider = NavigationPanelActorSafeContext.Provider, useNavigationActorRef = () => {
  const ctx = useContext(NavigationPanelActorSafeContext);
  if (ctx === null)
    throw new Error("NavigationPanelActorRef is not found in the context");
  return ctx;
};
function useNavigationActorSnapshot(selector3, compare2 = shallowEqual$1) {
  const actorRef = useNavigationActorRef();
  return useSelector(actorRef, selector3, compare2);
}
function useNavigationActorContext(selector3, compare2 = shallowEqual$1) {
  return useNavigationActorSnapshot((snapshot) => selector3(snapshot.context), compare2);
}
function useNavigationActor() {
  const actorRef = useNavigationActorRef();
  return useMemo(() => ({
    actorRef,
    send: (event) => actorRef.send(event),
    selectFolder: (folderPath) => actorRef.send({ type: "select.folder", folderPath }),
    selectView: (viewId) => actorRef.send({ type: "select.view", viewId }),
    isOpened: () => actorRef.getSnapshot().hasTag("active"),
    clearSearch: () => actorRef.send({ type: "searchQuery.change", value: "" }),
    closeDropdown: () => actorRef.send({ type: "dropdown.dismiss" })
  }), [actorRef]);
}
const Tooltip$2 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
}), BreadcrumbsSeparator = () => /* @__PURE__ */ jsx(
  ThemeIcon,
  {
    component: MotionDiv,
    variant: "transparent",
    size: 16,
    className: css({
      display: {
        base: "none",
        "@/md": "flex"
      },
      color: {
        base: "mantine.colors.gray[5]",
        _dark: "mantine.colors.dark[3]"
      }
    }),
    children: /* @__PURE__ */ jsx(IconChevronRight, {})
  }
);
Breadcrumbs.withProps({
  separator: /* @__PURE__ */ jsx(BreadcrumbsSeparator, {}),
  separatorMargin: 4
});
const PanelActionIcon = forwardRef(({
  variant = "default",
  className,
  disabled = !1,
  type,
  ...others
}, ref) => /* @__PURE__ */ jsx(
  ActionIcon,
  {
    size: "md",
    variant: "transparent",
    radius: "sm",
    component: MotionButton,
    ...!disabled && {
      whileHover: {
        scale: 1.085
      },
      whileTap: {
        scale: 1,
        translateY: 1
      }
    },
    disabled,
    ...others,
    className: cx(
      className,
      navigationPanelActionIcon({ variant, type })
    ),
    ref
  }
)), breadcrumbTitle = cva({
  base: {
    fontSize: "sm",
    fontWeight: "500",
    transition: "fast",
    color: {
      base: "likec4.panel.action",
      _hover: "likec4.panel.action.hover"
    }
  },
  variants: {
    truncate: {
      true: {
        truncate: !0
      }
    },
    dimmed: {
      true: {
        color: {
          base: "likec4.panel.text.dimmed",
          _hover: "likec4.panel.action"
        }
      }
    }
  }
}), Logo$1 = forwardRef(
  (props, ref) => /* @__PURE__ */ jsxs("svg", { ref, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 222 56", ...props, children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        fill: "#5E98AF",
        d: "M33.95 33.78V0H2.37A2.37 2.37 0 0 0 0 2.35V33.9h33.95v-.12ZM38.57 33.78H55.6v-14.6c0-1.3-1.06-2.35-2.36-2.35H38.57v16.95ZM33.95 38.37H17.04v14.6c0 1.29 1.06 2.35 2.36 2.35h14.67V38.37h-.12ZM38.57 38.37v16.95h14.67c1.3 0 2.36-1.06 2.36-2.36v-14.6H38.57Z"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        className: css({
          fill: "[#FCFBF7]",
          _light: {
            fill: "[#222221]"
          }
        }),
        d: "M71.61 12.08c-.06 3.61.3 29.95.23 31.87 0 1.8 0 3.6.06 5.41 0 .3.18.58.47.58 4.1.18 8.13-.17 12.22-.11 1.34.05 2.69 0 3.97 0 1.29-.06 1.4-.59 1.35-1.63-.06-1.63-.06-3.08-.06-4.65-.06-.82-.53-1.11-1.23-1.11-2.4.06-4.8-.06-7.19.06-.4.06-.82.06-1.23.06-.7-.06-.87-.24-.93-1v-.86c-.18-4.83.17-9.83.17-14.66-.06-4.07 0-7.73-.06-11.34 0-1.57 0-3.14-.05-4.65-.06-.93 0-1.92-.24-2.85-.11-.35-.29-.81-.7-.81h-5.5c-.93 0-1.22.64-1.28 1.57v4.12ZM103.81 35c-.17-6.63-.1-13.67-.05-20.24 0-2.04-.12-4.25-.12-6.28 0-2.21-.87-2.1-2.04-2.15-1.7-.06-2.46-.06-4.15-.06-1.11-.06-1.58.23-1.58 1.34 0 5.7-.18 21.8-.12 24.13.06 2.33.3 12.91.18 15.24-.06.81 0 1.62.06 2.44.05.29.23.58.7.58 1.93-.12 3.74-.12 5.67-.17.7-.06 1.28-.24 1.58-1 .05-.4-.12-11.04-.12-13.83Zm13.92 4.47c0-2.03-.3-7.56-.23-8.72 0-.17.11-.4.17-.4.12 0 .35.11.41.17 1.87 2.44 10.64 19.36 11.7 19.42.28.06.58.06.87.06 1.99-.12 3.74 0 5.73 0 2.04 0 .7-1.98.35-2.5-.53-.76-7.48-13.14-7.9-13.9-1.16-1.98-2.16-4.13-3.32-6.05-.12-.23-.24-.58-.18-.81.12-.7.3-1.34.59-1.98a93.18 93.18 0 0 1 4.55-8.14c1.88-2.97 2.93-4.83 4.45-7.5.35-.64.58-1.34.82-2.1.05-.29-.18-.58-.53-.58-1.11-.05-5.15 0-6.43 0-.59 0-1.17.12-1.46.64-.76 1.46-8.6 15.7-9.35 16.98-.06.12-.24.18-.41.18 0 0-.12-.18-.12-.3-.06-3.25.53-13.9.4-16.04-.05-1.28-.28-1.4-1.57-1.46-1.4-.05-3.33-.05-4.73-.05-1.3 0-1.4.7-1.58 1.62-.06.18-.06 5.64-.06 8.09 0 3.54-.3 25.76.11 32.8 0 .7.18 1.1.77 1.1 1.57-.12 3.91 0 5.49 0 1.11 0 1.29-.12 1.29-1.98 0-2.5.23-4.77.23-7.85 0-.23-.06-.46-.06-.7Zm25.66-1.4h-.06c0 1.46-.05 2.97 0 4.49.06 1.86.18 3.72.3 5.58 0 .64.17.81.76.93 1.22.29 2.4.35 3.62.35 3.16-.12 6.31.11 9.47 0 1.29-.06 1.87.06 3.16-.18 1.17-.23 1.58-.87 1.58-2.61-.12-1.1-.06-1.57-.06-2.91 0-1.92-1.35-2.56-2.52-2.5-.81.06-4.73-.06-6.31-.06-2.63.06-2.22.4-2.22-2.33 0-2.2.06-5.05.06-7.32 0-1.22.11-1.63 1.28-1.63h7.31c1.17.17 1.99-.64 1.99-1.86 0-1.22.12-1.28.12-2.5l-.18-1.75c-.12-.99-.47-1.33-1.46-1.33-.64 0-1.29.05-1.93.11-2.52.18-3.68-.17-6.14 0-.82 0-.93-.11-1-.87-.23-2.27 0-4.77.24-7.04.06-.93.3-1.1 1.17-1.16l8.24-.06c1.11-.11 1.46-.06 1.4-1.16-.11-1.69.06-3.43-.11-5.12-.12-.93-.41-1.1-1.46-1.1-1.76.05-2.17.05-3.92.17-1.75.06-8.77.06-10.46.06-2.46 0-2.63-.18-2.7 2.8-.1 2.32-.05 4.7-.05 7.09 0 4.07-.23 18.66-.12 21.92Zm47.76-24.82c.06-1.92 0-3.5 0-5.35 0-2.15-3.92-1.92-5.32-1.86a18.95 18.95 0 0 0-15.08 9.77c-.82 1.57-1.4 3.2-1.81 4.88a34 34 0 0 0-.59 12.15c.41 3.78 1.4 7.56 3.74 10.59 4.04 5.3 11.46 7.15 17.83 6.16.3-.06.59-.11.82-.29.18-.11.35-.35.35-.58l.18-3.31c.06-1.05 0-1 0-2.04 0-1.4-2.93-.35-4.74-.35-1.75 0-3.62-.06-5.2-.87-2.8-1.57-4.38-4.71-5.26-7.68-1-3.2-1.23-6.63-.64-9.88.7-4.25 2.74-9.13 7.25-10.59 2.57-.87 5.31-.58 7.89-.29.35.06.58-.17.58-.46Zm26.77 15.3c.06-2.5 0-14.84 0-18.38.06-.82 0-1.63-.11-2.45-.06-.99-.24-1.28-1.29-1.33h-4.44c-.82 0-1.35.4-1.82 1.27-1.34 3.2-10.75 24.02-12.15 26.58-.53.99-1 1.63-1 2.68v4.24c0 .76-.06 1.28 1.23 1.28l11.1-.06c1.47 0 1.47.3 1.47 1.1 0 .88-.12 4.9-.12 5.3 0 .58.12 1.16 1.23 1.16h5.08c1.23 0 1.23-.7 1.23-2.03.06-1.17-.06-3.5-.06-4.66 0-.93.18-.98 1.76-.98 1.22 0 1.75-.12 1.75-.88.06-1.57 0-2.67 0-4.42 0-1.04-.93-.98-2.92-.98-.65 0-.7-.18-.7-1.05-.12-1.8-.24-4.6-.24-6.4Zm-7.25-5.94c-.05.7-.11 10.82-.11 12.27-.06.81-.24 1.05-1 1.1-1.93.06-3.85.06-5.78.06-.47 0-.65-.4-.41-.87.23-.4 4.85-11.57 6.13-14.48.18-.17.24-.35.41-.52.18-.12.41-.18.59-.23.06 0 .23.29.23.46 0 .76-.06 1.51-.06 2.21Z"
      }
    )
  ] })
), LogoIcon = forwardRef(
  (props, ref) => /* @__PURE__ */ jsx("svg", { ref, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 56 56", ...props, children: /* @__PURE__ */ jsx(
    "path",
    {
      fill: "#5E98AF",
      d: "M33.95 33.78V0H2.37A2.37 2.37 0 0 0 0 2.35V33.9h33.95v-.12ZM38.57 33.78H55.6v-14.6c0-1.3-1.06-2.35-2.36-2.35H38.57v16.95ZM33.95 38.37H17.04v14.6c0 1.29 1.06 2.35 2.36 2.35h14.67V38.37h-.12ZM38.57 38.37v16.95h14.67c1.3 0 2.36-1.06 2.36-2.36v-14.6H38.57Z"
    }
  ) })
), LogoButton$1 = () => {
  const actor = useNavigationActor(), { onLogoClick } = useDiagramEventHandlers();
  return /* @__PURE__ */ jsx(MotionDiv, { layout: "position", children: /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      onMouseEnter: () => {
        actor.send({ type: "breadcrumbs.mouseEnter.root" });
      },
      onMouseLeave: () => {
        actor.send({ type: "breadcrumbs.mouseLeave.root" });
      },
      onClick: (e2) => {
        e2.stopPropagation(), onLogoClick && actor.isOpened() && setTimeout(() => {
          onLogoClick();
        }, 100), actor.send({ type: "breadcrumbs.click.root" });
      },
      className: cx(
        "mantine-active",
        hstack({
          padding: "0.5",
          // _active: {
          //   transform: 'translateY(1px)',
          // },
          width: {
            base: "[20px]",
            "@/md": "[64px]"
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsx(
          Logo$1,
          {
            className: css({
              display: {
                base: "none",
                "@/md": "block"
              }
            })
          }
        ),
        /* @__PURE__ */ jsx(
          LogoIcon,
          {
            className: css({
              display: {
                base: "block",
                "@/md": "none"
              }
            })
          }
        )
      ]
    }
  ) });
};
const __iconNode$o = [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M5 12l6 6", key: "svg-1" }], ["path", { d: "M5 12l6 -6", key: "svg-2" }]], IconArrowLeft = createReactComponent("outline", "arrow-left", "ArrowLeft", __iconNode$o), NavigationButtons = () => {
  const diagram = useDiagram(), {
    hasStepBack,
    hasStepForward
  } = useDiagramContext((s2) => ({
    hasStepBack: s2.navigationHistory.currentIndex > 0,
    hasStepForward: s2.navigationHistory.currentIndex < s2.navigationHistory.history.length - 1
  }));
  return /* @__PURE__ */ jsxs(
    MotionDiv,
    {
      layout: "position",
      className: hstack({
        gap: "0.5"
      }),
      children: [
        /* @__PURE__ */ jsx(
          PanelActionIcon,
          {
            disabled: !hasStepBack,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigate("back");
            },
            children: /* @__PURE__ */ jsx(IconArrowLeft, { size: 14 })
          }
        ),
        /* @__PURE__ */ jsx(
          PanelActionIcon,
          {
            disabled: !hasStepForward,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigate("forward");
            },
            children: /* @__PURE__ */ jsx(IconArrowRight, { size: 14 })
          }
        )
      ]
    }
  );
};
const __iconNode$n = [["path", { d: "M9 15l6 -6", key: "svg-0" }], ["path", { d: "M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464", key: "svg-1" }], ["path", { d: "M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463", key: "svg-2" }]], IconLink = createReactComponent("outline", "link", "Link", __iconNode$n), selector$4 = ({ context: context2 }) => {
  const view = context2.view;
  return {
    id: view.id,
    title: context2.viewModel?.title ?? (view.title && extractViewTitleFromPath(view.title)) ?? "Untitled View",
    description: context2.viewModel?.description ?? RichText.from(view.description),
    tags: view.tags ?? [],
    links: view.links ?? []
  };
}, DetailsControls = (props) => {
  const [opened, setOpened] = useState(!1), data = useNavigationActorSnapshot(selector$4, deepEqual$1), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom-end",
      shadow: "xl",
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      offset: {
        mainAxis: 4
      },
      opened,
      onChange: setOpened,
      ...portalProps,
      ...props,
      children: [
        /* @__PURE__ */ jsx(ViewDetailsCardTrigger, { linksCount: data.links.length, onOpen: () => setOpened(!0) }),
        opened && /* @__PURE__ */ jsx(ViewDetailsCardDropdown, { data, onClose: () => setOpened(!1) })
      ]
    }
  );
}, ViewDetailsCardTrigger = ({ linksCount, onOpen }) => /* @__PURE__ */ jsx(Popover.Target, { children: /* @__PURE__ */ jsxs(
  UnstyledButton,
  {
    component: MotionButton,
    layout: "position",
    whileTap: {
      scale: 0.95,
      translateY: 1
    },
    onClick: (e2) => {
      e2.stopPropagation(), onOpen();
    },
    className: cx(
      "group",
      hstack({
        gap: "2",
        paddingInline: "2",
        paddingBlock: "1",
        rounded: "sm",
        userSelect: "none",
        cursor: "pointer",
        color: {
          base: "likec4.panel.action",
          _hover: "likec4.panel.action.hover"
        },
        backgroundColor: {
          _hover: "likec4.panel.action.bg.hover"
        },
        display: {
          base: "none",
          "@/xs": "flex"
        }
      }),
      ""
    ),
    children: [
      /* @__PURE__ */ jsx(IconId, { size: 16, stroke: 1.8 }),
      linksCount > 0 && /* @__PURE__ */ jsxs(HStack, { gap: "[1px]", children: [
        /* @__PURE__ */ jsx(IconLink, { size: 14, stroke: 2 }),
        /* @__PURE__ */ jsx(
          Box,
          {
            css: {
              fontSize: "11px",
              fontWeight: 600,
              lineHeight: 1,
              opacity: 0.8
            },
            children: linksCount
          }
        )
      ] })
    ]
  }
) }), SectionHeader$1 = styled("div", {
  base: {
    fontSize: "xs",
    color: "mantine.colors.dimmed",
    fontWeight: 500,
    userSelect: "none",
    mb: "xxs"
  }
}), ViewDetailsCardDropdown = ({
  data: {
    id: id2,
    title: title2,
    description: description2,
    tags,
    links
  },
  onClose
}) => {
  const diagram = useDiagram();
  return useOnDiagramEvent("paneClick", onClose), useOnDiagramEvent("nodeClick", onClose), /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      className: cx(
        "nowheel nopan nodrag",
        vstack({
          margin: "xs",
          layerStyle: "likec4.dropdown",
          gap: "md",
          padding: "md",
          paddingBottom: "lg",
          pointerEvents: "all",
          maxWidth: "calc(100cqw - 52px)",
          minWidth: "200px",
          maxHeight: "calc(100cqh - 100px)",
          width: "max-content",
          cursor: "default",
          overflow: "auto",
          overscrollBehavior: "contain",
          "@/sm": {
            minWidth: 400,
            maxWidth: 550
          },
          "@/lg": {
            maxWidth: 700
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsxs("section", { children: [
          /* @__PURE__ */ jsx(Text, { component: "div", fw: 500, size: "xl", lh: "sm", children: title2 }),
          /* @__PURE__ */ jsxs(HStack, { alignItems: "flex-start", mt: "1", children: [
            /* @__PURE__ */ jsx(ViewBadge, { label: "id", value: id2 }),
            /* @__PURE__ */ jsx(HStack, { gap: "xs", flexWrap: "wrap", children: tags.map((tag) => /* @__PURE__ */ jsx(
              ElementTag,
              {
                tag,
                cursor: "pointer",
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.openSearch(`#${tag}`);
                }
              },
              tag
            )) })
          ] })
        ] }),
        links.length > 0 && /* @__PURE__ */ jsxs("section", { className: hstack({ alignItems: "baseline" }), children: [
          /* @__PURE__ */ jsx(SectionHeader$1, { children: "Links" }),
          /* @__PURE__ */ jsx(HStack, { gap: "xs", flexWrap: "wrap", children: links.map((link, i2) => /* @__PURE__ */ jsx(Link, { value: link }, `${i2}-${link.url}`)) })
        ] }),
        description2.isEmpty && /* @__PURE__ */ jsx(Text, { component: "div", fw: 500, size: "xs", c: "dimmed", style: { userSelect: "none" }, children: "No description" }),
        description2.nonEmpty && /* @__PURE__ */ jsxs("section", { children: [
          /* @__PURE__ */ jsx(SectionHeader$1, { children: "Description" }),
          /* @__PURE__ */ jsx(
            Markdown,
            {
              value: description2,
              fontSize: "sm",
              emptyText: "No description",
              className: css({
                userSelect: "all"
              })
            }
          )
        ] })
      ]
    }
  );
}, ViewBadge = ({
  label: label2,
  value
}) => /* @__PURE__ */ jsxs(HStack, { gap: "0.5", children: [
  /* @__PURE__ */ jsx(ViewBadgeLabel, { children: label2 }),
  /* @__PURE__ */ jsx(
    Badge,
    {
      size: "sm",
      radius: "sm",
      variant: "light",
      color: "gray",
      tt: "none",
      fw: 500,
      classNames: {
        root: css({
          width: "max-content",
          overflow: "visible",
          px: "1",
          color: {
            _dark: "mantine.colors.gray[4]",
            _light: "mantine.colors.gray[8]"
          }
        }),
        label: css({
          overflow: "visible"
        }),
        section: css({
          opacity: 0.5,
          userSelect: "none",
          marginInlineEnd: "0.5"
        })
      },
      children: value
    }
  )
] }), ViewBadgeLabel = styled("div", {
  base: {
    color: "mantine.colors.dimmed",
    fontWeight: 500,
    fontSize: "xxs",
    userSelect: "none"
  }
}), OpenSource = () => {
  const viewId = useCurrentViewId(), { enableVscode } = useEnabledFeatures(), { onOpenSource } = useDiagramEventHandlers();
  return enableVscode ? /* @__PURE__ */ jsx(Tooltip$2, { label: "Open View Source", children: /* @__PURE__ */ jsx(
    PanelActionIcon,
    {
      onClick: (e2) => {
        e2.stopPropagation(), onOpenSource?.({ view: viewId });
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { style: { width: "60%", height: "60%" } })
    }
  ) }) : null;
};
function pickViewBounds(view, dynamicVariant) {
  if (view._type === "dynamic")
    try {
      if (dynamicVariant ??= view.variant, dynamicVariant === "sequence")
        return view.sequenceLayout.bounds;
    } catch {
    }
  return view.bounds;
}
function calcEdgeBounds({ points, controlPoints, labelBBox }) {
  let minX = 1 / 0, minY = 1 / 0, maxX = -1 / 0, maxY = -1 / 0;
  if (controlPoints)
    for (const p2 of controlPoints)
      minX = Math.min(minX, p2.x), minY = Math.min(minY, p2.y), maxX = Math.max(maxX, p2.x), maxY = Math.max(maxY, p2.y);
  else
    for (const [x2, y2] of points)
      minX = Math.min(minX, x2), minY = Math.min(minY, y2), maxX = Math.max(maxX, x2), maxY = Math.max(maxY, y2);
  return labelBBox && (minX = Math.min(minX, labelBBox.x), minY = Math.min(minY, labelBBox.y), maxX = Math.max(maxX, labelBBox.x + labelBBox.width), maxY = Math.max(maxY, labelBBox.y + labelBBox.height)), {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function calcViewBounds({ nodes, edges }) {
  return BBox$1.expand(
    BBox$1.merge(
      ...nodes,
      ...edges.map(calcEdgeBounds)
    ),
    10
  );
}
function createViewChange(parentContext) {
  const {
    view: {
      drifts: _1,
      // Ignore drifts from view
      _layout: _2,
      // Ignore layout type from view
      ...view
    },
    xynodes,
    xystore
  } = parentContext, { nodeLookup, edgeLookup } = xystore.getState(), movedNodes = /* @__PURE__ */ new Set(), nodes = t$f(view.nodes, (node2) => {
    const internal = nodeLookup.get(node2.id);
    if (!internal)
      return console.error(`Internal node not found for ${node2.id}`), node2;
    const xynodedata = xynodes.find((n2) => n2.id === node2.id)?.data ?? internal.data, position = internal.internals.positionAbsolute, { width, height } = getNodeDimensions(internal);
    return (!isSamePoint(position, node2) || node2.width !== width || node2.height !== height) && movedNodes.add(node2.id), {
      ...node2,
      shape: xynodedata.shape,
      color: xynodedata.color,
      style: {
        ...xynodedata.style
      },
      x: Math.floor(position.x),
      y: Math.floor(position.y),
      width: Math.ceil(width),
      height: Math.ceil(height)
    };
  }), edges = t$f(view.edges, (edge) => {
    const xyedge = edgeLookup.get(edge.id);
    if (!xyedge)
      return console.error(`Internal edge not found for ${edge.id}`), edge;
    const data = xyedge.data;
    let controlPoints = data.controlPoints ?? [];
    const sourceOrTargetMoved = movedNodes.has(xyedge.source) || movedNodes.has(xyedge.target);
    controlPoints.length === 0 && sourceOrTargetMoved && (controlPoints = bezierControlPoints(data.points));
    const _updated = {
      ...n$c(edge, ["controlPoints", "labelBBox"]),
      points: data.points
    };
    return data.labelBBox && (_updated.labelBBox = data.labelBBox), t$q(controlPoints, 1) && (_updated.controlPoints = controlPoints), _updated;
  });
  return {
    op: "save-view-snapshot",
    layout: {
      ...view,
      _layout: "manual",
      bounds: calcViewBounds({ nodes, edges }),
      nodes,
      edges
    }
  };
}
const diagramActorRef$1 = function(system) {
  return system.get("diagram");
}, getDiagramContext = function(system) {
  return system.get("diagram").getSnapshot().context;
}, raiseSync = () => machine$4.raise({ type: "sync" }, { delay: 200, id: "sync" }), cancelSync = () => machine$4.cancel("sync"), reschedule = (delay2 = 50) => machine$4.raise(({ event }) => event, { delay: delay2 }), isLayoutChange = (change2) => change2.op === "reset-manual-layout" || change2.op === "save-view-snapshot", withoutSnapshotChanges = n$q(e$6(isLayoutChange)), saveStateBeforeEdit = () => machine$4.assign(({ system }) => {
  const parentContext = getDiagramContext(system);
  return {
    beforeEditing: {
      xynodes: parentContext.xynodes.map(
        ({ measured, ...n2 }) => ({
          ...n$c(n2, ["selected", "dragging", "resizing"]),
          data: n$c(n2.data, ["dimmed", "hovered"]),
          measured,
          initialWidth: measured?.width ?? n2.width ?? n2.initialWidth,
          initialHeight: measured?.height ?? n2.height ?? n2.initialHeight
        })
      ),
      xyedges: parentContext.xyedges.map(
        (e2) => ({
          ...n$c(e2, ["selected"]),
          data: n$c(e2.data, ["active", "dimmed", "hovered"])
        })
      ),
      change: createViewChange(parentContext),
      view: parentContext.view,
      synched: !1
    }
  };
}), startEditing$1 = () => machine$4.enqueueActions(({ enqueue, event }) => {
  enqueue(saveStateBeforeEdit()), event.type === "edit.start" && enqueue.assign({
    editing: event.subject
  });
}), stopHotkey = () => machine$4.stopChild("hotkey"), ensureHotKey = () => machine$4.enqueueActions(({ check, enqueue, self: self2 }) => {
  const hasUndo = check("can undo"), hotkey = self2.getSnapshot().children.hotkey;
  if (!hasUndo && hotkey) {
    enqueue.stopChild(hotkey);
    return;
  }
  hasUndo && !hotkey && enqueue.spawnChild("hotkey", {
    id: "hotkey"
  });
}), pushHistory = () => machine$4.assign(({ context: context2 }) => {
  const snapshot = context2.beforeEditing;
  return snapshot ? {
    beforeEditing: null,
    editing: null,
    history: [
      ...context2.history,
      snapshot
    ]
  } : {
    editing: null
  };
}), stopEditing$1 = () => machine$4.enqueueActions(({ event, enqueue }) => {
  if (event.type === "edit.finish" && event.wasChanged) {
    enqueue(pushHistory()), enqueue(raiseSync());
    return;
  }
  enqueue.assign({
    beforeEditing: null,
    editing: null
  });
}), markHistoryAsSynched = () => machine$4.assign(({ context: context2 }) => ({
  beforeEditing: context2.beforeEditing && context2.beforeEditing.synched === !1 ? {
    ...context2.beforeEditing,
    synched: !0
  } : context2.beforeEditing,
  history: context2.history.map((i2) => ({
    ...i2,
    synched: !0
  }))
})), popHistory = () => machine$4.assign(({ context: context2 }) => context2.history.length <= 1 ? {
  history: []
} : {
  history: context2.history.slice(0, context2.history.length - 1)
}), undo = () => machine$4.enqueueActions(({ context: context2, enqueue, system }) => {
  const lastHistoryItem = t$g(context2.history);
  if (!lastHistoryItem)
    return;
  enqueue(cancelSync()), enqueue(popHistory()), enqueue(ensureHotKey());
  const diagramActor = diagramActorRef$1(system);
  enqueue.sendTo(diagramActor, {
    type: "update.view",
    view: lastHistoryItem.view,
    xyedges: lastHistoryItem.xyedges,
    xynodes: lastHistoryItem.xynodes,
    source: "editor"
  }), enqueue.assign({
    pendingChanges: []
  }), lastHistoryItem.synched ? enqueue.raise({ type: "change", change: lastHistoryItem.change }, { delay: 50 }) : enqueue(raiseSync());
}), addSnapshotToPendingChanges = () => machine$4.assign(({ context: context2, system }) => {
  const parentContext = getDiagramContext(system), change2 = createViewChange(parentContext);
  return {
    pendingChanges: [
      // Remove all save-view-snapshot and reset-manual-layout changes
      ...withoutSnapshotChanges(context2.pendingChanges),
      change2
    ]
  };
}), hotkeyActorLogic$1 = fromCallback(({ sendBack }) => {
  const ctrlZHandler = getHotkeyHandler([
    ["mod + z", (event) => {
      event.stopPropagation(), sendBack({ type: "undo" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", ctrlZHandler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", ctrlZHandler, { capture: !0 });
  };
}), applyLatest = fromPromise(
  () => {
    throw new Error("Not implemented");
  }
), executeChange = fromPromise(
  () => {
    throw new Error("Not implemented");
  }
), diagramActorRef = function(params) {
  return params.system.get("diagram");
}, machine$4 = setup({
  delays: {
    "350ms": 350,
    waitBeforeSync: 2e3
  },
  actors: {
    applyLatest,
    executeChange,
    hotkey: hotkeyActorLogic$1
  },
  guards: {
    "has pending": ({ context: context2 }) => context2.pendingChanges.length > 0,
    "can undo": ({ context: context2 }) => context2.history.length > 0
  }
}), to = {
  idle: { target: "#idle" },
  editing: { target: "#editing" },
  afterEdit: { target: "#afterEdit" },
  pending: { target: "#pending" },
  applyLatestToManual: { target: "#applyLatestToManual" },
  executeChanges: { target: "#executeChanges" }
}, idle$1 = machine$4.createStateConfig({
  id: "idle",
  on: {
    sync: {
      ...to.pending
    },
    "edit.start": {
      ...to.editing
    }
  }
}), editing = machine$4.createStateConfig({
  id: "editing",
  tags: "pending",
  entry: [
    startEditing$1(),
    cancelSync()
  ],
  on: {
    change: {
      actions: stopEditing$1(),
      ...to.executeChanges
    },
    "edit.finish": {
      actions: stopEditing$1(),
      ...to.afterEdit
    },
    undo: {
      actions: stopEditing$1(),
      ...to.idle
    }
  }
}), pending = machine$4.createStateConfig({
  id: "pending",
  tags: ["pending"],
  entry: ensureHotKey(),
  on: {
    sync: {
      reenter: !0,
      ...to.pending
    },
    "edit.start": {
      // this allows to return back from editing in afterEdit state
      actions: [
        addSnapshotToPendingChanges()
      ],
      ...to.editing
    }
  },
  after: {
    waitBeforeSync: {
      actions: [
        addSnapshotToPendingChanges()
      ],
      ...to.executeChanges
    }
  }
}), afterEdit = machine$4.createStateConfig({
  id: "afterEdit",
  always: [
    { guard: "has pending", ...to.pending },
    { ...to.idle }
  ]
}), applyLatestToManual = machine$4.createStateConfig({
  id: "applyLatestToManual",
  entry: [
    cancelSync(),
    saveStateBeforeEdit()
  ],
  initial: "call",
  on: {
    // catch all events
    "*": {
      actions: [
        log(({ event }) => `applyLatestToManual received unexpected event: ${event.type}`),
        reschedule(350)
      ]
    }
  },
  states: {
    // Fetch latest and manual layouts
    // Apply changes, send update to diagram
    call: {
      invoke: {
        src: "applyLatest",
        input: ({ context: context2 }) => {
          const current2 = context2.beforeEditing?.change.layout;
          return {
            current: current2 && current2._layout === "manual" ? current2 : void 0,
            viewId: context2.viewId
          };
        },
        onDone: {
          actions: sendTo(
            diagramActorRef,
            ({ event }) => ({
              type: "update.view",
              view: event.output.updated
            }),
            { delay: 10 }
          ),
          target: "wait"
        },
        onError: {
          actions: [
            assign({
              beforeEditing: null,
              pendingChanges: []
            }),
            ({ event }) => {
              console.error(event.error);
            }
          ],
          ...to.idle
        }
      }
    },
    // Now we wait 350ms, take new snapshot and send save-view-snapshot
    wait: {
      entry: pushHistory(),
      after: {
        "350ms": {
          actions: [
            addSnapshotToPendingChanges(),
            ensureHotKey()
          ],
          ...to.executeChanges
        }
      }
    }
  }
}), executeChanges = machine$4.createStateConfig({
  id: "executeChanges",
  entry: [
    assign(({ event, context: context2 }) => {
      if (event.type === "change") {
        if (isLayoutChange(event.change))
          return {
            pendingChanges: [
              ...withoutSnapshotChanges(context2.pendingChanges),
              event.change
            ]
          };
        if (!context2.pendingChanges.includes(event.change))
          return {
            pendingChanges: [
              ...context2.pendingChanges,
              event.change
            ]
          };
      }
      return {};
    }),
    cancelSync()
  ],
  invoke: {
    src: "executeChange",
    input: ({ context: context2 }) => ({
      changes: context2.pendingChanges,
      viewId: context2.viewId
    }),
    onDone: {
      actions: enqueueActions(({ context: context2, enqueue }) => {
        const snapshot = r$a(context2.pendingChanges, (c) => c.op === "save-view-snapshot");
        snapshot && enqueue.sendTo(
          diagramActorRef,
          {
            type: "update.view-bounds",
            bounds: snapshot.layout.bounds
          }
        ), enqueue.assign({
          pendingChanges: []
        });
      }),
      ...to.idle
    },
    onError: {
      actions: ({ event }) => {
        console.error(event.error);
      },
      ...to.afterEdit
    }
  },
  on: {
    "*": {
      actions: reschedule()
    }
  }
}), _editorActorLogic = machine$4.createMachine({
  id: "editor",
  context: ({ input: input2 }) => ({
    viewId: input2.viewId,
    beforeEditing: null,
    editing: null,
    pendingChanges: [],
    history: []
  }),
  initial: "idle",
  // TODO: listen to diagram actor, if switches to "sequence" dynamic view, cancel editing
  // entry: ({ self, system }) => {
  //   // let previous = ''
  //   // const a = (self._parent as DiagramMachineRef).subscribe({
  //   //   next({ context }) {
  //   //     const current = context.view._type === 'dynamic' ? context.dynamicViewVariant
  //   //   },
  //   // })
  //   const s = self.subscribe({
  //     complete: () => {
  //       console.log('editor actor completed')
  //       s.unsubscribe()
  //     },
  //   })
  // },
  states: {
    idle: idle$1,
    editing,
    pending,
    afterEdit,
    applyLatestToManual,
    executeChanges
  },
  on: {
    cancel: {
      actions: [
        cancelSync(),
        assign({
          editing: null,
          beforeEditing: null,
          pendingChanges: []
        })
      ],
      ...to.idle
    },
    synced: {
      actions: markHistoryAsSynched()
    },
    undo: {
      guard: "can undo",
      actions: undo(),
      ...to.idle
    },
    change: {
      ...to.executeChanges
    },
    applyLatestToManual: {
      ...to.applyLatestToManual
    },
    reset: {
      actions: [
        cancelSync(),
        assign({
          history: [],
          editing: null,
          beforeEditing: null,
          pendingChanges: []
        }),
        stopHotkey()
      ],
      ...to.idle
    }
  }
}), editorActorLogic = _editorActorLogic, EMPTY_OBJ$1 = {};
function _update$1(current2, updated) {
  return current2 === updated ? current2 : (updated = updated.map((update) => {
    const existing = current2.find(
      (n2) => n2.id === update.id && n2.type === update.type && n2.source === update.source && n2.target === update.target
    );
    if (!existing)
      return update;
    const isSameData = deepEqual$1(existing.data, update.data), data = isSameData ? existing.data : update.data;
    return isSameData && deepEqual$1(existing.hidden, update.hidden ?? existing.hidden) && deepEqual$1(existing.selected, update.selected ?? existing.selected) && deepEqual$1(existing.selectable, update.selectable ?? existing.selectable) && deepEqual$1(existing.focusable, update.focusable ?? existing.focusable) && deepEqual$1(existing.animated, update.animated ?? existing.animated) && deepEqual$1(existing.className, update.className) && deepEqual$1(existing.zIndex, update.zIndex ?? existing.zIndex) && deepEqual$1(existing.label, update.label) && deepEqual$1(existing.sourceHandle, update.sourceHandle) && deepEqual$1(existing.targetHandle, update.targetHandle) && deepEqual$1(existing.style ?? EMPTY_OBJ$1, update.style ?? EMPTY_OBJ$1) ? existing : {
      // Retain existing properties that are defined, except parentId
      ...t$8(existing, e$b),
      // Apply updates, omitting undefined values
      ...t$8(update, e$b),
      data
    };
  }), t$j(current2, updated) ? current2 : updated);
}
function updateEdges(current2, update) {
  return e$b(update) ? _update$1(current2, update) : (update = current2, (current22) => _update$1(current22, update));
}
const EMPTY_OBJ = {};
function _update(current2, updated) {
  return current2 === updated ? current2 : (updated = updated.map((update) => {
    const existing = current2.find((n2) => n2.id === update.id && n2.type === update.type);
    if (!existing)
      return update;
    const isSameData = n$k(existing.data, update.data);
    let data = isSameData ? existing.data : update.data;
    isSameData || (e$b(existing.data.hovered) && !e$b(update.data.hovered) && (data = {
      ...data,
      hovered: existing.data.hovered
    }), e$b(existing.data.dimmed) && !e$b(update.data.dimmed) && (data = {
      ...data,
      dimmed: existing.data.dimmed
    }));
    const { width: existingWidth, height: existingHeight } = getNodeDimensions(existing), haveHandles = Object.hasOwn(existing, "handles") || Object.hasOwn(update, "handles"), isSameHandles = !haveHandles || deepEqual$1(existing.handles ?? [], update.handles ?? []);
    if (isSameData && isSameHandles && deepEqual$1(existingWidth, update.width ?? update.initialWidth) && deepEqual$1(existingHeight, update.height ?? update.initialHeight) && deepEqual$1(existing.parentId ?? null, update.parentId ?? null) && deepEqual$1(existing.hidden, update.hidden ?? existing.hidden) && deepEqual$1(existing.selected, update.selected ?? existing.selected) && deepEqual$1(existing.selectable, update.selectable ?? existing.selectable) && deepEqual$1(existing.focusable, update.focusable ?? existing.focusable) && deepEqual$1(existing.draggable, update.draggable ?? existing.draggable) && deepEqual$1(existing.dragHandle, update.dragHandle) && deepEqual$1(existing.className, update.className) && deepEqual$1(existing.zIndex, update.zIndex ?? existing.zIndex) && deepEqual$1(existing.position, update.position) && deepEqual$1(existing.domAttributes ?? EMPTY_OBJ, update.domAttributes ?? EMPTY_OBJ) && deepEqual$1(existing.style ?? EMPTY_OBJ, update.style ?? EMPTY_OBJ))
      return existing;
    const handles = haveHandles && isSameHandles ? existing.handles : update.handles;
    return {
      // Retain existing properties that are defined, except parentId
      ...t$8(existing, (v2, k) => e$b(v2) && k !== "parentId"),
      // Retain measured dimensions from existing if present
      ..."measured" in existing && {
        measured: {
          width: update.width ?? update.initialWidth,
          height: update.height ?? update.initialHeight
        }
      },
      // Apply updates, omitting undefined values
      ...t$8(update, e$b),
      // Force dimensions
      width: update.width ?? update.initialWidth,
      height: update.height ?? update.initialHeight,
      ...handles && { handles },
      data
    };
  }), t$j(current2, updated) ? current2 : updated);
}
function updateNodes(current2, update) {
  return e$b(update) ? _update(current2, update) : (update = current2, (existing) => _update(existing, update));
}
const ViewPadding$1 = {
  top: "40px",
  bottom: "22px",
  left: "22px",
  right: "22px"
};
function viewToNodesEdge(view) {
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  )), nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = t$q(node2.children, 1) || node2.kind == GroupElementKind;
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.x,
      y: node2.y
    };
    parent && (position.x -= parent.x, position.y -= parent.y);
    const id2 = node2.id, base = {
      id: id2,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      ...parent && {
        parentId: parent.id
      }
    }, fqn2 = node2.modelRef ?? null, navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case node2.kind === LayoutRelationshipsViewResult.Empty: {
        xynodes.push(
          {
            ...base,
            type: "empty",
            data: {
              column: node2.column
            }
          }
        );
        break;
      }
      case (isCompound && !!fqn2): {
        xynodes.push(
          {
            ...base,
            type: "compound",
            data: {
              id: id2,
              column: node2.column,
              title: node2.title,
              color: node2.color,
              shape: node2.shape,
              style: node2.style,
              depth: node2.depth ?? 0,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              existsInCurrentView: node2.existsInCurrentView,
              fqn: fqn2,
              ...navigateTo
            }
          }
        );
        break;
      }
      default:
        invariant$2(fqn2, "Element should have either modelRef or deploymentRef"), xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              id: id2,
              column: node2.column,
              fqn: fqn2,
              title: node2.title,
              technology: node2.technology,
              description: node2.description,
              height: node2.height,
              width: node2.width,
              color: node2.color,
              shape: node2.shape,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              style: node2.style,
              existsInCurrentView: node2.existsInCurrentView,
              tags: node2.tags,
              ...navigateTo
            }
          }
        );
    }
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id2 = edge.id;
    if (!t$q(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    if (!t$q(edge.relations, 1)) {
      console.error("edge should have at least 1 relation", edge);
      continue;
    }
    xyedges.push({
      id: id2,
      type: "relationship",
      source,
      target,
      sourceHandle: edge.sourceHandle,
      targetHandle: edge.targetHandle,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      // deletable: false,
      data: {
        sourceFqn: edge.sourceFqn,
        targetFqn: edge.targetFqn,
        relations: edge.relations,
        color: edge.color ?? "gray",
        label: edge.label,
        navigateTo: edge.navigateTo ?? null,
        line: edge.line ?? "dashed",
        existsInCurrentView: edge.existsInCurrentView
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes,
    xyedges
  };
}
const findRootSubject = (nodes) => nodes.find(
  (n2) => n2.data.column === "subjects" && e$5(n2.parentId)
), layouter = fromPromise(async ({ input: input2, self: self2, signal }) => {
  const {
    subjectId,
    navigateFromNode,
    xyflow: xyflow2,
    xystore,
    update
  } = input2;
  let {
    nodes: currentNodes,
    width,
    height
  } = xystore.getState();
  const next = viewToNodesEdge(update), updateXYData = () => {
    const { nodes, edges } = xystore.getState();
    return {
      xynodes: updateNodes(nodes, next.xynodes),
      xyedges: updateEdges(edges, next.xyedges)
    };
  }, parent = nonNullable$1(self2._parent);
  let zoom2 = xyflow2.getZoom();
  const maxZoom = Math.max(zoom2, 1), nextviewport = getViewportForBounds(update.bounds, width, height, MinZoom, maxZoom, ViewPadding$1), nextSubjectNode = next.xynodes.find(
    (n2) => n2.type !== "empty" && n2.data.column === "subjects" && n2.data.fqn === subjectId
  ) ?? findRootSubject(next.xynodes), currentSubjectNode = findRootSubject(currentNodes), existingNode = navigateFromNode ? currentNodes.find((n2) => n2.id === navigateFromNode) : currentNodes.find((n2) => n2.type !== "empty" && n2.data.column !== "subjects" && n2.data.fqn === subjectId);
  if (!nextSubjectNode || !existingNode || nextSubjectNode.type === "empty" || !currentSubjectNode || nextSubjectNode.data.fqn === currentSubjectNode.data.fqn)
    return await xyflow2.setViewport(nextviewport), updateXYData();
  const nextSubjectCenter = {
    x: nextSubjectNode.position.x + (nextSubjectNode.initialWidth ?? 0) / 2,
    y: nextSubjectNode.position.y + (nextSubjectNode.initialHeight ?? 0) / 2
  }, currentSubjectInternalNode = xyflow2.getInternalNode(currentSubjectNode.id), currentSubjectCenter = getNodeCenter(currentSubjectInternalNode), nested = /* @__PURE__ */ new Set();
  if (currentNodes.forEach((n2) => {
    if (n2.id !== existingNode.id) {
      if (n2.data.column === "subjects") {
        nested.add(n2.id);
        return;
      }
      n2.parentId && (n2.parentId === existingNode.id || nested.has(n2.parentId)) && nested.add(n2.id);
    }
  }), currentNodes = updateNodes(
    currentNodes,
    currentNodes.flatMap((n2) => nested.has(n2.id) ? [] : n2.id !== existingNode.id ? {
      ...n2,
      data: {
        ...n2.data,
        dimmed: n2.data.column === "subjects" ? "immediate" : !0
      }
    } : {
      ...n$c(n2, ["parentId"]),
      position: {
        x: currentSubjectCenter.x - n2.initialWidth / 2,
        y: currentSubjectCenter.y - n2.initialHeight / 2
      },
      zIndex: ZIndexes.Max,
      hidden: !1,
      data: {
        ...n2.data,
        dimmed: !1
      }
    })
  ), parent.send({
    type: "update.xydata",
    xynodes: currentNodes,
    xyedges: []
  }), await delay$1(120), next.xynodes = next.xynodes.map(Base.setDimmed(!1)), signal.aborted)
    return updateXYData();
  const duration = 300;
  return xyflow2.setCenter(currentSubjectCenter.x, currentSubjectCenter.y, { zoom: zoom2, duration, interpolate: "smooth" }), await delay$1(duration), await xyflow2.setCenter(nextSubjectCenter.x, nextSubjectCenter.y, { zoom: zoom2 }), updateXYData();
}), machine$3 = setup({
  actors: {
    layouter
  },
  guards: {
    hasViewId: ({ context: context2 }) => context2.viewId !== null,
    isReady: ({ context: context2 }) => context2.xyflow !== null && context2.xystore !== null && context2.layouted !== null,
    anotherSubject: ({ context: context2, event }) => event.type === "update.view" ? context2.layouted?.subject !== event.layouted.subject : !1
  }
}), xyflowInit = () => machine$3.assign(({ event }) => (assertEvent(event, "xyflow.init"), {
  xyflow: event.instance,
  xystore: event.store
})), updateView$2 = () => machine$3.assign(({ event }) => (assertEvent(event, "update.view"), {
  layouted: event.layouted,
  ...viewToNodesEdge(event.layouted)
})), xyflowUpdateNodeInternals = () => machine$3.createAction(({ context: context2 }) => {
  invariant$1(context2.xystore, "xystore is not initialized");
  const { domNode, updateNodeInternals: updateNodeInternals2 } = context2.xystore.getState(), nodeIds = new Set(context2.xyedges.flatMap((e2) => [e2.source, e2.target]));
  if (nodeIds.size === 0 || !domNode)
    return;
  const updates = /* @__PURE__ */ new Map(), domNodes = domNode.querySelectorAll(".react-flow__node");
  for (const nodeElement of domNodes) {
    const nodeId = nodeElement.getAttribute("data-id");
    nodeId && nodeIds.has(nodeId) && updates.set(nodeId, { id: nodeId, nodeElement, force: !0 });
  }
  updateNodeInternals2(updates, { triggerFitView: !1 });
}), xyflowFitDiagram = (params) => machine$3.createAction(({ context: context2, event }) => {
  params ??= event.type === "fitDiagram" ? event : {};
  let { duration, bounds } = params ?? {};
  duration ??= 450;
  const { xyflow: xyflow2, xystore } = context2;
  invariant$1(xyflow2, "xyflow is not initialized"), invariant$1(xystore, "xystore is not initialized"), bounds ??= context2.layouted?.bounds;
  const maxZoom = Math.max(xyflow2.getZoom(), 1);
  if (bounds) {
    const { width, height } = xystore.getState(), viewport = getViewportForBounds(bounds, width, height, MinZoom, maxZoom, ViewPadding$1);
    xyflow2.setViewport(viewport, duration > 0 ? { duration, interpolate: "smooth" } : void 0).catch(
      console.error
    );
  } else
    xyflow2.fitView({
      minZoom: MinZoom,
      maxZoom,
      padding: ViewPadding$1,
      ...duration > 0 && { duration, interpolate: "smooth" }
    }).catch(console.error);
}), xyflowApplyNodeChanges$1 = () => machine$3.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyNodeChanges"), {
  xynodes: applyNodeChanges(event.changes, context2.xynodes)
})), xyflowApplyEdgeChanges$1 = () => machine$3.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyEdgeChanges"), {
  xyedges: applyEdgeChanges(event.changes, context2.xyedges)
})), openRelationshipSource = () => machine$3.enqueueActions(({ system, event }) => {
  if (event.type !== "xyflow.edgeClick")
    return;
  const diagramActor = typedSystem(system).diagramActorRef, relations = event.edge.data.relations;
  t$q(relations, 1) && diagramActor.send({ type: "open.source", relation: relations[0] });
}), dispose$1 = () => machine$3.assign({
  xyflow: null,
  layouted: null,
  xystore: null,
  xyedges: [],
  xynodes: []
}), _relationshipsBrowserLogic = machine$3.createMachine({
  id: "relationships-browser",
  context: ({ input: input2 }) => ({
    subject: input2.subject,
    viewId: input2.viewId,
    scope: input2.viewId ? input2.scope : "global",
    closeable: input2.closeable ?? !0,
    enableSelectSubject: input2.enableSelectSubject ?? !0,
    enableChangeScope: input2.enableChangeScope ?? !0,
    xyflow: null,
    xystore: null,
    layouted: null,
    navigateFromNode: null,
    xynodes: [],
    xyedges: []
  }),
  initial: "initializing",
  on: {
    "xyflow.applyNodeChanges": {
      actions: xyflowApplyNodeChanges$1()
    },
    "xyflow.applyEdgeChanges": {
      actions: xyflowApplyEdgeChanges$1()
    }
  },
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: xyflowInit(),
          target: "isReady"
        },
        "update.view": {
          actions: updateView$2(),
          target: "isReady"
        },
        stop: "closed",
        close: "closed"
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          xyflowFitDiagram({ duration: 0 }),
          raise({ type: "xyflow.updateNodeInternals" }, { delay: 150 })
        ],
        target: "active"
      }, {
        target: "initializing"
      }]
    },
    active: {
      initial: "idle",
      tags: ["active"],
      on: {
        "xyflow.nodeClick": {
          actions: enqueueActions(({ event, enqueue }) => {
            if ("fqn" in event.node.data) {
              const fqn2 = event.node.data.fqn;
              enqueue.raise({
                type: "navigate.to",
                subject: fqn2,
                fromNode: event.node.id
              });
            }
          })
        },
        "xyflow.edgeClick": [
          {
            guard: "hasViewId",
            actions: enqueueActions(({ event, context: context2, system, enqueue }) => {
              event.edge.selected || event.edge.data.relations.length > 1 ? enqueue.sendTo(typedSystem(system).overlaysActorRef, {
                type: "open.relationshipDetails",
                viewId: context2.viewId,
                source: event.edge.data.sourceFqn,
                target: event.edge.data.targetFqn
              }) : enqueue(openRelationshipSource());
            })
          },
          {
            actions: openRelationshipSource()
          }
        ],
        "navigate.to": {
          actions: [
            assign({
              subject: ({ event }) => event.subject,
              viewId: ({ event, context: context2 }) => event.viewId ?? context2.viewId ?? null,
              navigateFromNode: ({ event }) => event.fromNode ?? null
            })
          ]
        },
        "xyflow.paneDblClick": {
          actions: xyflowFitDiagram()
        },
        "update.view": {
          actions: updateView$2(),
          target: ".layouting"
        },
        "change.scope": {
          actions: assign({
            scope: ({ event }) => event.scope
          })
        },
        "xyflow.updateNodeInternals": {
          actions: xyflowUpdateNodeInternals()
        },
        fitDiagram: {
          actions: xyflowFitDiagram()
        },
        "xyflow.resized": {
          actions: [
            cancel("fitDiagram"),
            raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 300 })
          ]
        },
        "xyflow.init": {
          actions: xyflowInit()
        },
        "xyflow.unmount": {
          target: "initializing"
        },
        close: "closed"
      },
      states: {
        idle: {
          on: {
            "xyflow.edgeMouseEnter": {
              actions: [
                assign({
                  xyedges: ({ context: context2, event }) => {
                    const hasDimmed = context2.xyedges.some((edge) => edge.data.dimmed !== !1 || edge.selected);
                    return context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setData(edge, {
                      hovered: !0,
                      dimmed: !1
                    }) : hasDimmed && !edge.selected ? Base.setDimmed(edge, "immediate") : edge);
                  }
                }),
                cancel("undim.edges"),
                cancel("dim.nonhovered.edges"),
                raise({ type: "dim.nonhovered.edges" }, { id: "dim.nonhovered.edges", delay: 200 })
              ]
            },
            "xyflow.edgeMouseLeave": {
              actions: [
                assign({
                  xyedges: ({ context: context2, event }) => context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setHovered(edge, !1) : edge)
                }),
                cancel("dim.nonhovered.edges"),
                raise({ type: "undim.edges" }, { id: "undim.edges", delay: 400 })
              ]
            },
            "dim.nonhovered.edges": {
              actions: assign({
                xyedges: ({ context: context2 }) => context2.xyedges.map(
                  (edge) => edge.data.hovered ? edge : Base.setDimmed(edge, edge.data.dimmed === "immediate" ? "immediate" : !0)
                )
              })
            },
            "undim.edges": {
              actions: assign({
                xyedges: ({ context: context2 }) => context2.xyedges.map(Base.setDimmed(!1))
              })
            },
            "xyflow.selectionChange": {
              actions: enqueueActions(({ event, context: context2, enqueue }) => {
                event.edges.length === 0 && context2.xyedges.some((e2) => e2.data.dimmed) && !context2.xyedges.some((e2) => e2.data.hovered) && enqueue.raise({ type: "undim.edges" });
              })
            }
          }
        },
        layouting: {
          invoke: {
            id: "layouter",
            src: "layouter",
            input: ({ context: context2 }) => ({
              subjectId: context2.subject,
              navigateFromNode: context2.navigateFromNode,
              xyflow: nonNullable$1(context2.xyflow),
              xystore: nonNullable$1(context2.xystore),
              update: nonNullable$1(context2.layouted)
            }),
            onDone: {
              target: "idle",
              actions: enqueueActions(({ enqueue, event }) => {
                enqueue.assign({
                  xynodes: event.output.xynodes,
                  xyedges: event.output.xyedges,
                  navigateFromNode: null
                }), enqueue.raise({ type: "fitDiagram", duration: 200 }, { id: "fitDiagram", delay: 50 });
                for (let i2 = 1; i2 < 8; i2++)
                  enqueue.raise({ type: "xyflow.updateNodeInternals" }, { delay: 120 + i2 * 75 });
              })
            }
          },
          on: {
            "update.xydata": {
              actions: assign({
                xynodes: ({ event }) => event.xynodes,
                xyedges: ({ event }) => event.xyedges
              })
            },
            "xyflow.applyEdgeChanges": {
              // actions: log('layouting: ignore xyflow.applyEdgeChanges'),
            },
            "xyflow.applyNodeChanges": {
              // actions: log('layouting: ignore xyflow.applyNodeChanges'),
            }
          }
        }
      }
    },
    closed: {
      id: "closed",
      type: "final",
      entry: dispose$1()
    }
  },
  exit: dispose$1()
}), relationshipsBrowserLogic = _relationshipsBrowserLogic, _elementDetailsLogic = setup({
  actors: {
    relationshipsBrowserLogic
  }
}).createMachine({
  id: "element-details",
  context: ({ input: input2 }) => ({
    ...input2,
    initiatedFrom: {
      node: input2.initiatedFrom?.node ?? null,
      clientRect: input2.initiatedFrom?.clientRect ?? null
    }
  }),
  initial: "active",
  states: {
    active: {
      entry: spawnChild("relationshipsBrowserLogic", {
        id: ({ self: self2 }) => `${self2.id}-relationships`,
        input: ({ context: context2 }) => ({
          subject: context2.subject,
          viewId: context2.currentView.id,
          scope: "view",
          enableSelectSubject: !1,
          enableChangeScope: !0,
          closeable: !1
        })
      }),
      exit: [
        sendTo(({ self: self2 }) => `${self2.id}-relationships`, { type: "close" }),
        stopChild(({ self: self2 }) => `${self2.id}-relationships`)
      ],
      on: {
        "change.subject": {
          actions: assign({
            subject: ({ event }) => event.subject
          })
        },
        close: "closed"
      }
    },
    closed: {
      id: "closed",
      type: "final"
    }
  }
}), elementDetailsLogic = _elementDetailsLogic;
function layoutResultToXYFlow(layout2) {
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(layout2.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  )), nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = t$q(node2.children, 1);
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.x,
      y: node2.y
    };
    parent && (position.x -= parent.x, position.y -= parent.y);
    const id2 = node2.id, base = {
      id: id2,
      draggable: !1,
      deletable: !1,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      ...parent && {
        parentId: parent.id
      }
    }, fqn2 = node2.modelRef, navigateTo = { navigateTo: node2.navigateTo ?? null };
    !0 === isCompound ? xynodes.push(
      {
        ...base,
        type: "compound",
        data: {
          id: id2,
          column: node2.column,
          title: node2.title,
          color: node2.color,
          style: node2.style,
          depth: node2.depth ?? 0,
          icon: node2.icon ?? "none",
          ports: node2.ports,
          fqn: fqn2,
          ...navigateTo
        }
      }
    ) : xynodes.push(
      {
        ...base,
        type: "element",
        data: {
          id: id2,
          column: node2.column,
          fqn: fqn2,
          title: node2.title,
          technology: node2.technology,
          description: node2.description ?? null,
          height: node2.height,
          width: node2.width,
          color: node2.color,
          shape: node2.shape,
          icon: node2.icon ?? "none",
          ports: node2.ports,
          style: node2.style,
          tags: node2.tags,
          ...navigateTo
        }
      }
    );
  }
  for (const {
    source,
    target,
    relationId,
    label: label2,
    technology,
    description: description2,
    navigateTo = null,
    color: color2 = "gray",
    line: line2 = "dashed",
    ...edge
  } of layout2.edges) {
    const id2 = edge.id;
    xyedges.push({
      id: id2,
      type: "relationship",
      source,
      target,
      sourceHandle: edge.sourceHandle,
      targetHandle: edge.targetHandle,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        relationId,
        label: label2,
        color: color2,
        navigateTo,
        line: line2,
        description: description2 ?? null,
        ...technology && { technology }
      }
    });
  }
  return {
    xynodes,
    xyedges,
    bounds: layout2.bounds
  };
}
function inputToSubject(input2) {
  return "edgeId" in input2 ? (invariant$2(e$2(input2.edgeId), "edgeId is required"), {
    edgeId: input2.edgeId
  }) : {
    source: input2.source,
    target: input2.target
  };
}
const ViewPadding = {
  x: "22px",
  y: "22px"
}, _relationshipDetailsLogic = setup({
  actions: {
    "xyflow:fitDiagram": ({ context: context2 }, params) => {
      let { duration, bounds } = params ?? {};
      duration ??= 450;
      const { xyflow: xyflow2, xystore } = context2;
      invariant$2(xyflow2, "xyflow is not initialized"), invariant$2(xystore, "xystore is not initialized"), bounds ??= context2.bounds;
      const maxZoom = Math.max(xyflow2.getZoom(), 1);
      if (bounds) {
        const { width, height } = xystore.getState(), viewport = getViewportForBounds(bounds, width, height, MinZoom, maxZoom, ViewPadding);
        xyflow2.setViewport(viewport, duration > 0 ? { duration } : void 0).catch(console.error);
      } else
        xyflow2.fitView({
          minZoom: MinZoom,
          maxZoom,
          padding: ViewPadding,
          ...duration > 0 && { duration, interpolate: "smooth" }
        }).catch(console.error);
    },
    "xyflow:updateNodeInternals": ({ context: context2 }) => {
      invariant$2(context2.xystore, "xystore is not initialized");
      const { domNode, updateNodeInternals: updateNodeInternals2 } = context2.xystore.getState(), nodeIds = new Set(context2.xyedges.flatMap((e2) => [e2.source, e2.target]));
      if (nodeIds.size === 0 || !domNode)
        return;
      const updates = /* @__PURE__ */ new Map();
      for (const updateId of nodeIds) {
        const nodeElement = domNode.querySelector(`.react-flow__node[data-id="${updateId}"]`);
        nodeElement && updates.set(updateId, { id: updateId, nodeElement, force: !0 });
      }
      updateNodeInternals2(updates, { triggerFitView: !1 });
    },
    updateXYFlow: assign(({ context: context2, event }) => {
      assertEvent(event, "xyflow.init");
      let initialized = context2.initialized;
      return initialized.xyflow || (initialized = {
        ...initialized,
        xyflow: !0
      }), {
        initialized,
        xyflow: event.instance,
        xystore: event.store
      };
    }),
    updateLayoutData: assign(({ context: context2, event }) => {
      assertEvent(event, "update.layoutData");
      const { xynodes, xyedges, bounds } = layoutResultToXYFlow(event.data);
      let initialized = context2.initialized;
      return initialized.xydata || (initialized = {
        ...initialized,
        xydata: !0
      }), {
        initialized,
        xynodes: updateNodes(context2.xynodes, xynodes),
        xyedges: updateEdges(context2.xyedges, xyedges),
        bounds: shallowEqual$1(context2.bounds, bounds) ? context2.bounds : bounds
      };
    }),
    "open relationship source": enqueueActions(({ system, event }) => {
      if (event.type !== "xyflow.edgeClick")
        return;
      const diagramActor = typedSystem(system).diagramActorRef, relationId = event.edge.data.relationId;
      relationId && diagramActor.send({ type: "open.source", relation: relationId });
    })
  },
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow,
    "enable: navigate.to": () => !0
  }
}).createMachine({
  initial: "initializing",
  context: ({ input: input2 }) => ({
    subject: inputToSubject(input2),
    viewId: input2.viewId,
    bounds: {
      x: 0,
      y: 0,
      width: 200,
      height: 200
    },
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    xyflow: null,
    xystore: null,
    xynodes: [],
    xyedges: []
  }),
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: "updateXYFlow",
          target: "isReady"
        },
        "update.layoutData": {
          actions: "updateLayoutData",
          target: "isReady"
        },
        close: {
          target: "closed"
        }
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          { type: "xyflow:fitDiagram", params: { duration: 0 } },
          raise({ type: "xyflow.updateNodeInternals" }, { delay: 50 })
        ],
        target: "ready"
      }, {
        target: "initializing"
      }]
    },
    ready: {
      on: {
        "xyflow.edgeMouseEnter": {
          actions: [
            assign({
              xyedges: ({ context: context2, event }) => {
                const hasDimmed = context2.xyedges.some(
                  (edge) => edge.data.dimmed === !0 || edge.data.dimmed === "immediate"
                );
                return context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setData(edge, {
                  hovered: !0,
                  dimmed: !1
                }) : hasDimmed && !edge.selected ? Base.setDimmed(edge, "immediate") : edge);
              }
            }),
            cancel("undim.edges"),
            cancel("dim.nonhovered.edges"),
            raise({ type: "dim.nonhovered.edges" }, { id: "dim.nonhovered.edges", delay: 100 })
          ]
        },
        "xyflow.edgeMouseLeave": {
          actions: [
            assign({
              xyedges: ({ context: context2, event }) => context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setHovered(edge, !1) : edge)
            }),
            cancel("dim.nonhovered.edges"),
            raise({ type: "undim.edges" }, { id: "undim.edges", delay: 400 })
          ]
        },
        "dim.nonhovered.edges": {
          actions: assign({
            xyedges: ({ context: context2 }) => context2.xyedges.map((edge) => Base.setDimmed(edge, edge.data.hovered !== !0))
          })
        },
        "undim.edges": {
          actions: assign({
            xyedges: ({ context: context2 }) => context2.xyedges.some((edge) => edge.selected === !0) ? context2.xyedges.map(
              (edge) => Base.setDimmed(edge, edge.selected !== !0 ? edge.data.dimmed || "immediate" : !1)
            ) : context2.xyedges.map(Base.setDimmed(!1))
          })
        },
        "xyflow.selectionChange": {
          actions: enqueueActions(({ event, context: context2, enqueue }) => {
            event.edges.length === 0 && context2.xyedges.some((e2) => e2.data.dimmed) && !context2.xyedges.some((e2) => e2.data.hovered) && enqueue.raise({ type: "undim.edges" });
          })
        },
        "update.layoutData": {
          actions: [
            "updateLayoutData",
            cancel("fitDiagram"),
            raise({ type: "fitDiagram", duration: 0 }, { id: "fitDiagram", delay: 50 }),
            raise({ type: "xyflow.updateNodeInternals" }, { delay: 75 })
          ]
        },
        "xyflow.init": {
          actions: "updateXYFlow"
        },
        "xyflow.applyNodeChanges": {
          actions: assign({
            xynodes: ({ context: context2, event }) => applyNodeChanges(event.changes, context2.xynodes)
          })
        },
        "xyflow.applyEdgeChanges": {
          actions: assign({
            xyedges: ({ context: context2, event }) => applyEdgeChanges(event.changes, context2.xyedges)
          })
        },
        "xyflow.paneDblClick": {
          actions: "xyflow:fitDiagram"
        },
        "xyflow.edgeClick": {
          actions: "open relationship source"
        },
        "navigate.to": {
          actions: assign({
            subject: ({ event }) => inputToSubject(event.params),
            viewId: ({ context: context2, event }) => event.params.viewId ?? context2.viewId
          })
        },
        close: {
          target: "closed"
        }
      },
      exit: assign({
        xyedges: [],
        xynodes: [],
        initialized: {
          xydata: !1,
          xyflow: !1
        },
        xyflow: null,
        xystore: null
      })
    },
    closed: {
      type: "final"
    }
  },
  on: {
    fitDiagram: {
      actions: {
        type: "xyflow:fitDiagram",
        params: e("event")
      }
    },
    "xyflow.resized": {
      actions: [
        cancel("fitDiagram"),
        raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 200 })
      ]
    },
    "xyflow.updateNodeInternals": {
      actions: "xyflow:updateNodeInternals"
    }
  }
}), relationshipDetailsLogic = _relationshipDetailsLogic;
var xstateGuards_cjs = {}, raiseDa5b247f_cjs = {}, commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, xstateDev_cjs = {}, hasRequiredXstateDev_cjs;
function requireXstateDev_cjs() {
  if (hasRequiredXstateDev_cjs) return xstateDev_cjs;
  hasRequiredXstateDev_cjs = 1, Object.defineProperty(xstateDev_cjs, "__esModule", { value: !0 });
  function getGlobal2() {
    if (typeof globalThis < "u")
      return globalThis;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal < "u")
      return commonjsGlobal;
  }
  function getDevTools2() {
    const w2 = getGlobal2();
    if (w2.__xstate__)
      return w2.__xstate__;
  }
  function registerService(service) {
    if (typeof window > "u")
      return;
    const devTools = getDevTools2();
    devTools && devTools.register(service);
  }
  const devToolsAdapter2 = (service) => {
    if (typeof window > "u")
      return;
    const devTools = getDevTools2();
    devTools && devTools.register(service);
  };
  return xstateDev_cjs.devToolsAdapter = devToolsAdapter2, xstateDev_cjs.getGlobal = getGlobal2, xstateDev_cjs.registerService = registerService, xstateDev_cjs;
}
var hasRequiredRaiseDa5b247f_cjs;
function requireRaiseDa5b247f_cjs() {
  if (hasRequiredRaiseDa5b247f_cjs) return raiseDa5b247f_cjs;
  hasRequiredRaiseDa5b247f_cjs = 1;
  var dev_dist_xstateDev = requireXstateDev_cjs();
  class Mailbox2 {
    constructor(_process) {
      this._process = _process, this._active = !1, this._current = null, this._last = null;
    }
    start() {
      this._active = !0, this.flush();
    }
    clear() {
      this._current && (this._current.next = null, this._last = this._current);
    }
    enqueue(event) {
      const enqueued = {
        value: event,
        next: null
      };
      if (this._current) {
        this._last.next = enqueued, this._last = enqueued;
        return;
      }
      this._current = enqueued, this._last = enqueued, this._active && this.flush();
    }
    flush() {
      for (; this._current; ) {
        const consumed = this._current;
        this._process(consumed.value), this._current = consumed.next;
      }
      this._last = null;
    }
  }
  const STATE_DELIMITER2 = ".", TARGETLESS_KEY2 = "", NULL_EVENT2 = "", STATE_IDENTIFIER2 = "#", WILDCARD2 = "*", XSTATE_INIT2 = "xstate.init", XSTATE_ERROR2 = "xstate.error", XSTATE_STOP2 = "xstate.stop";
  function createAfterEvent2(delayRef, id2) {
    return {
      type: `xstate.after.${delayRef}.${id2}`
    };
  }
  function createDoneStateEvent2(id2, output) {
    return {
      type: `xstate.done.state.${id2}`,
      output
    };
  }
  function createDoneActorEvent2(invokeId, output) {
    return {
      type: `xstate.done.actor.${invokeId}`,
      output,
      actorId: invokeId
    };
  }
  function createErrorActorEvent2(id2, error) {
    return {
      type: `xstate.error.actor.${id2}`,
      error,
      actorId: id2
    };
  }
  function createInitEvent2(input2) {
    return {
      type: XSTATE_INIT2,
      input: input2
    };
  }
  function reportUnhandledError2(err) {
    setTimeout(() => {
      throw err;
    });
  }
  const symbolObservable2 = typeof Symbol == "function" && Symbol.observable || "@@observable";
  function matchesState2(parentStateId, childStateId) {
    const parentStateValue = toStateValue2(parentStateId), childStateValue = toStateValue2(childStateId);
    return typeof childStateValue == "string" ? typeof parentStateValue == "string" ? childStateValue === parentStateValue : !1 : typeof parentStateValue == "string" ? parentStateValue in childStateValue : Object.keys(parentStateValue).every((key2) => key2 in childStateValue ? matchesState2(parentStateValue[key2], childStateValue[key2]) : !1);
  }
  function toStatePath2(stateId) {
    if (isArray2(stateId))
      return stateId;
    const result = [];
    let segment = "";
    for (let i2 = 0; i2 < stateId.length; i2++) {
      switch (stateId.charCodeAt(i2)) {
        // \
        case 92:
          segment += stateId[i2 + 1], i2++;
          continue;
        // .
        case 46:
          result.push(segment), segment = "";
          continue;
      }
      segment += stateId[i2];
    }
    return result.push(segment), result;
  }
  function toStateValue2(stateValue) {
    if (isMachineSnapshot2(stateValue))
      return stateValue.value;
    if (typeof stateValue != "string")
      return stateValue;
    const statePath = toStatePath2(stateValue);
    return pathToStateValue2(statePath);
  }
  function pathToStateValue2(statePath) {
    if (statePath.length === 1)
      return statePath[0];
    const value = {};
    let marker = value;
    for (let i2 = 0; i2 < statePath.length - 1; i2++)
      if (i2 === statePath.length - 2)
        marker[statePath[i2]] = statePath[i2 + 1];
      else {
        const previous = marker;
        marker = {}, previous[statePath[i2]] = marker;
      }
    return value;
  }
  function mapValues2(collection, iteratee) {
    const result = {}, collectionKeys = Object.keys(collection);
    for (let i2 = 0; i2 < collectionKeys.length; i2++) {
      const key2 = collectionKeys[i2];
      result[key2] = iteratee(collection[key2], key2, collection, i2);
    }
    return result;
  }
  function toArrayStrict2(value) {
    return isArray2(value) ? value : [value];
  }
  function toArray2(value) {
    return value === void 0 ? [] : toArrayStrict2(value);
  }
  function resolveOutput2(mapper, context2, event, self2) {
    return typeof mapper == "function" ? mapper({
      context: context2,
      event,
      self: self2
    }) : mapper;
  }
  function isArray2(value) {
    return Array.isArray(value);
  }
  function isErrorActorEvent2(event) {
    return event.type.startsWith("xstate.error.actor");
  }
  function toTransitionConfigArray2(configLike) {
    return toArrayStrict2(configLike).map((transitionLike) => typeof transitionLike > "u" || typeof transitionLike == "string" ? {
      target: transitionLike
    } : transitionLike);
  }
  function normalizeTarget2(target) {
    if (!(target === void 0 || target === TARGETLESS_KEY2))
      return toArray2(target);
  }
  function toObserver2(nextHandler, errorHandler, completionHandler) {
    const isObserver = typeof nextHandler == "object", self2 = isObserver ? nextHandler : void 0;
    return {
      next: (isObserver ? nextHandler.next : nextHandler)?.bind(self2),
      error: (isObserver ? nextHandler.error : errorHandler)?.bind(self2),
      complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self2)
    };
  }
  function createInvokeId2(stateNodeId, index2) {
    return `${index2}.${stateNodeId}`;
  }
  function resolveReferencedActor2(machine2, src) {
    const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
    if (!match)
      return machine2.implementations.actors[src];
    const [, indexStr, nodeId] = match, invokeConfig = machine2.getStateNodeById(nodeId).config.invoke;
    return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
  }
  function getAllOwnEventDescriptors(snapshot) {
    return [.../* @__PURE__ */ new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];
  }
  function createScheduledEventId2(actorRef, id2) {
    return `${actorRef.sessionId}.${id2}`;
  }
  let idCounter2 = 0;
  function createSystem2(rootActor, options) {
    const children2 = /* @__PURE__ */ new Map(), keyedActors = /* @__PURE__ */ new Map(), reverseKeyedActors = /* @__PURE__ */ new WeakMap(), inspectionObservers = /* @__PURE__ */ new Set(), timerMap = {}, {
      clock: clock2,
      logger
    } = options, scheduler = {
      schedule: (source, target, event, delay2, id2 = Math.random().toString(36).slice(2)) => {
        const scheduledEvent = {
          source,
          target,
          event,
          delay: delay2,
          id: id2,
          startedAt: Date.now()
        }, scheduledEventId = createScheduledEventId2(source, id2);
        system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
        const timeout2 = clock2.setTimeout(() => {
          delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], system._relay(source, target, event);
        }, delay2);
        timerMap[scheduledEventId] = timeout2;
      },
      cancel: (source, id2) => {
        const scheduledEventId = createScheduledEventId2(source, id2), timeout2 = timerMap[scheduledEventId];
        delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], timeout2 !== void 0 && clock2.clearTimeout(timeout2);
      },
      cancelAll: (actorRef) => {
        for (const scheduledEventId in system._snapshot._scheduledEvents) {
          const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
          scheduledEvent.source === actorRef && scheduler.cancel(actorRef, scheduledEvent.id);
        }
      }
    }, sendInspectionEvent = (event) => {
      if (!inspectionObservers.size)
        return;
      const resolvedInspectionEvent = {
        ...event,
        rootId: rootActor.sessionId
      };
      inspectionObservers.forEach((observer) => observer.next?.(resolvedInspectionEvent));
    }, system = {
      _snapshot: {
        _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}
      },
      _bookId: () => `x:${idCounter2++}`,
      _register: (sessionId, actorRef) => (children2.set(sessionId, actorRef), sessionId),
      _unregister: (actorRef) => {
        children2.delete(actorRef.sessionId);
        const systemId = reverseKeyedActors.get(actorRef);
        systemId !== void 0 && (keyedActors.delete(systemId), reverseKeyedActors.delete(actorRef));
      },
      get: (systemId) => keyedActors.get(systemId),
      getAll: () => Object.fromEntries(keyedActors.entries()),
      _set: (systemId, actorRef) => {
        const existing = keyedActors.get(systemId);
        if (existing && existing !== actorRef)
          throw new Error(`Actor with system ID '${systemId}' already exists.`);
        keyedActors.set(systemId, actorRef), reverseKeyedActors.set(actorRef, systemId);
      },
      inspect: (observerOrFn) => {
        const observer = toObserver2(observerOrFn);
        return inspectionObservers.add(observer), {
          unsubscribe() {
            inspectionObservers.delete(observer);
          }
        };
      },
      _sendInspectionEvent: sendInspectionEvent,
      _relay: (source, target, event) => {
        system._sendInspectionEvent({
          type: "@xstate.event",
          sourceRef: source,
          actorRef: target,
          event
        }), target._send(event);
      },
      scheduler,
      getSnapshot: () => ({
        _scheduledEvents: {
          ...system._snapshot._scheduledEvents
        }
      }),
      start: () => {
        const scheduledEvents = system._snapshot._scheduledEvents;
        system._snapshot._scheduledEvents = {};
        for (const scheduledId in scheduledEvents) {
          const {
            source,
            target,
            event,
            delay: delay2,
            id: id2
          } = scheduledEvents[scheduledId];
          scheduler.schedule(source, target, event, delay2, id2);
        }
      },
      _clock: clock2,
      _logger: logger
    };
    return system;
  }
  let executingCustomAction2 = !1;
  const $$ACTOR_TYPE2 = 1;
  let ProcessingStatus2 = /* @__PURE__ */ (function(ProcessingStatus3) {
    return ProcessingStatus3[ProcessingStatus3.NotStarted = 0] = "NotStarted", ProcessingStatus3[ProcessingStatus3.Running = 1] = "Running", ProcessingStatus3[ProcessingStatus3.Stopped = 2] = "Stopped", ProcessingStatus3;
  })({});
  const defaultOptions2 = {
    clock: {
      setTimeout: (fn, ms) => setTimeout(fn, ms),
      clearTimeout: (id2) => clearTimeout(id2)
    },
    logger: console.log.bind(console),
    devTools: !1
  };
  class Actor2 {
    /**
     * Creates a new actor instance for the given logic with the provided options,
     * if any.
     *
     * @param logic The logic to create an actor from
     * @param options Actor options
     */
    constructor(logic, options) {
      this.logic = logic, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new Mailbox2(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = ProcessingStatus2.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this.systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
      const resolvedOptions = {
        ...defaultOptions2,
        ...options
      }, {
        clock: clock2,
        logger,
        parent,
        syncSnapshot,
        id: id2,
        systemId,
        inspect
      } = resolvedOptions;
      this.system = parent ? parent.system : createSystem2(this, {
        clock: clock2,
        logger
      }), inspect && !parent && this.system.inspect(toObserver2(inspect)), this.sessionId = this.system._bookId(), this.id = id2 ?? this.sessionId, this.logger = options?.logger ?? this.system._logger, this.clock = options?.clock ?? this.system._clock, this._parent = parent, this._syncSnapshot = syncSnapshot, this.options = resolvedOptions, this.src = resolvedOptions.src ?? logic, this.ref = this, this._actorScope = {
        self: this,
        id: this.id,
        sessionId: this.sessionId,
        logger: this.logger,
        defer: (fn) => {
          this._deferred.push(fn);
        },
        system: this.system,
        stopChild: (child) => {
          if (child._parent !== this)
            throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
          child._stop();
        },
        emit: (emittedEvent) => {
          const listeners = this.eventListeners.get(emittedEvent.type), wildcardListener = this.eventListeners.get("*");
          if (!listeners && !wildcardListener)
            return;
          const allListeners = [...listeners ? listeners.values() : [], ...wildcardListener ? wildcardListener.values() : []];
          for (const handler of allListeners)
            try {
              handler(emittedEvent);
            } catch (err) {
              reportUnhandledError2(err);
            }
        },
        actionExecutor: (action) => {
          const exec = () => {
            if (this._actorScope.system._sendInspectionEvent({
              type: "@xstate.action",
              actorRef: this,
              action: {
                type: action.type,
                params: action.params
              }
            }), !action.exec)
              return;
            const saveExecutingCustomAction = executingCustomAction2;
            try {
              executingCustomAction2 = !0, action.exec(action.info, action.params);
            } finally {
              executingCustomAction2 = saveExecutingCustomAction;
            }
          };
          this._processingStatus === ProcessingStatus2.Running ? exec() : this._deferred.push(exec);
        }
      }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
        type: "@xstate.actor",
        actorRef: this
      }), systemId && (this.systemId = systemId, this.system._set(systemId, this)), this._initState(options?.snapshot ?? options?.state), systemId && this._snapshot.status !== "active" && this.system._unregister(this);
    }
    _initState(persistedState) {
      try {
        this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
      } catch (err) {
        this._snapshot = {
          status: "error",
          output: void 0,
          error: err
        };
      }
    }
    update(snapshot, event) {
      this._snapshot = snapshot;
      let deferredFn;
      for (; deferredFn = this._deferred.shift(); )
        try {
          deferredFn();
        } catch (err) {
          this._deferred.length = 0, this._snapshot = {
            ...snapshot,
            status: "error",
            error: err
          };
        }
      switch (this._snapshot.status) {
        case "active":
          for (const observer of this.observers)
            try {
              observer.next?.(snapshot);
            } catch (err) {
              reportUnhandledError2(err);
            }
          break;
        case "done":
          for (const observer of this.observers)
            try {
              observer.next?.(snapshot);
            } catch (err) {
              reportUnhandledError2(err);
            }
          this._stopProcedure(), this._complete(), this._doneEvent = createDoneActorEvent2(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
          break;
        case "error":
          this._error(this._snapshot.error);
          break;
      }
      this.system._sendInspectionEvent({
        type: "@xstate.snapshot",
        actorRef: this,
        event,
        snapshot
      });
    }
    /**
     * Subscribe an observer to an actors snapshot values.
     *
     * @remarks
     * The observer will receive the actors snapshot value when it is emitted.
     * The observer can be:
     *
     * - A plain function that receives the latest snapshot, or
     * - An observer object whose `.next(snapshot)` method receives the latest
     *   snapshot
     *
     * @example
     *
     * ```ts
     * // Observer as a plain function
     * const subscription = actor.subscribe((snapshot) => {
     *   console.log(snapshot);
     * });
     * ```
     *
     * @example
     *
     * ```ts
     * // Observer as an object
     * const subscription = actor.subscribe({
     *   next(snapshot) {
     *     console.log(snapshot);
     *   },
     *   error(err) {
     *     // ...
     *   },
     *   complete() {
     *     // ...
     *   }
     * });
     * ```
     *
     * The return value of `actor.subscribe(observer)` is a subscription object
     * that has an `.unsubscribe()` method. You can call
     * `subscription.unsubscribe()` to unsubscribe the observer:
     *
     * @example
     *
     * ```ts
     * const subscription = actor.subscribe((snapshot) => {
     *   // ...
     * });
     *
     * // Unsubscribe the observer
     * subscription.unsubscribe();
     * ```
     *
     * When the actor is stopped, all of its observers will automatically be
     * unsubscribed.
     *
     * @param observer - Either a plain function that receives the latest
     *   snapshot, or an observer object whose `.next(snapshot)` method receives
     *   the latest snapshot
     */
    subscribe(nextListenerOrObserver, errorListener, completeListener) {
      const observer = toObserver2(nextListenerOrObserver, errorListener, completeListener);
      if (this._processingStatus !== ProcessingStatus2.Stopped)
        this.observers.add(observer);
      else
        switch (this._snapshot.status) {
          case "done":
            try {
              observer.complete?.();
            } catch (err) {
              reportUnhandledError2(err);
            }
            break;
          case "error": {
            const err = this._snapshot.error;
            if (!observer.error)
              reportUnhandledError2(err);
            else
              try {
                observer.error(err);
              } catch (err2) {
                reportUnhandledError2(err2);
              }
            break;
          }
        }
      return {
        unsubscribe: () => {
          this.observers.delete(observer);
        }
      };
    }
    on(type, handler) {
      let listeners = this.eventListeners.get(type);
      listeners || (listeners = /* @__PURE__ */ new Set(), this.eventListeners.set(type, listeners));
      const wrappedHandler = handler.bind(void 0);
      return listeners.add(wrappedHandler), {
        unsubscribe: () => {
          listeners.delete(wrappedHandler);
        }
      };
    }
    /** Starts the Actor from the initial state */
    start() {
      if (this._processingStatus === ProcessingStatus2.Running)
        return this;
      this._syncSnapshot && this.subscribe({
        next: (snapshot) => {
          snapshot.status === "active" && this.system._relay(this, this._parent, {
            type: `xstate.snapshot.${this.id}`,
            snapshot
          });
        },
        error: () => {
        }
      }), this.system._register(this.sessionId, this), this.systemId && this.system._set(this.systemId, this), this._processingStatus = ProcessingStatus2.Running;
      const initEvent = createInitEvent2(this.options.input);
      switch (this.system._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: this._parent,
        actorRef: this,
        event: initEvent
      }), this._snapshot.status) {
        case "done":
          return this.update(this._snapshot, initEvent), this;
        case "error":
          return this._error(this._snapshot.error), this;
      }
      if (this._parent || this.system.start(), this.logic.start)
        try {
          this.logic.start(this._snapshot, this._actorScope);
        } catch (err) {
          return this._snapshot = {
            ...this._snapshot,
            status: "error",
            error: err
          }, this._error(err), this;
        }
      return this.update(this._snapshot, initEvent), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
    }
    _process(event) {
      let nextState, caughtError;
      try {
        nextState = this.logic.transition(this._snapshot, event, this._actorScope);
      } catch (err) {
        caughtError = {
          err
        };
      }
      if (caughtError) {
        const {
          err
        } = caughtError;
        this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: err
        }, this._error(err);
        return;
      }
      this.update(nextState, event), event.type === XSTATE_STOP2 && (this._stopProcedure(), this._complete());
    }
    _stop() {
      return this._processingStatus === ProcessingStatus2.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ProcessingStatus2.NotStarted ? (this._processingStatus = ProcessingStatus2.Stopped, this) : (this.mailbox.enqueue({
        type: XSTATE_STOP2
      }), this));
    }
    /** Stops the Actor and unsubscribe all listeners. */
    stop() {
      if (this._parent)
        throw new Error("A non-root actor cannot be stopped directly.");
      return this._stop();
    }
    _complete() {
      for (const observer of this.observers)
        try {
          observer.complete?.();
        } catch (err) {
          reportUnhandledError2(err);
        }
      this.observers.clear();
    }
    _reportError(err) {
      if (!this.observers.size) {
        this._parent || reportUnhandledError2(err);
        return;
      }
      let reportError = !1;
      for (const observer of this.observers) {
        const errorListener = observer.error;
        reportError ||= !errorListener;
        try {
          errorListener?.(err);
        } catch (err2) {
          reportUnhandledError2(err2);
        }
      }
      this.observers.clear(), reportError && reportUnhandledError2(err);
    }
    _error(err) {
      this._stopProcedure(), this._reportError(err), this._parent && this.system._relay(this, this._parent, createErrorActorEvent2(this.id, err));
    }
    // TODO: atm children don't belong entirely to the actor so
    // in a way - it's not even super aware of them
    // so we can't stop them from here but we really should!
    // right now, they are being stopped within the machine's transition
    // but that could throw and leave us with "orphaned" active actors
    _stopProcedure() {
      return this._processingStatus !== ProcessingStatus2.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new Mailbox2(this._process.bind(this)), this._processingStatus = ProcessingStatus2.Stopped, this.system._unregister(this), this);
    }
    /** @internal */
    _send(event) {
      this._processingStatus !== ProcessingStatus2.Stopped && this.mailbox.enqueue(event);
    }
    /**
     * Sends an event to the running Actor to trigger a transition.
     *
     * @param event The event to send
     */
    send(event) {
      this.system._relay(void 0, this, event);
    }
    attachDevTools() {
      const {
        devTools
      } = this.options;
      devTools && (typeof devTools == "function" ? devTools : dev_dist_xstateDev.devToolsAdapter)(this);
    }
    toJSON() {
      return {
        xstate$$type: $$ACTOR_TYPE2,
        id: this.id
      };
    }
    /**
     * Obtain the internal state of the actor, which can be persisted.
     *
     * @remarks
     * The internal state can be persisted from any actor, not only machines.
     *
     * Note that the persisted state is not the same as the snapshot from
     * {@link Actor.getSnapshot}. Persisted state represents the internal state of
     * the actor, while snapshots represent the actor's last emitted value.
     *
     * Can be restored with {@link ActorOptions.state}
     * @see https://stately.ai/docs/persistence
     */
    getPersistedSnapshot(options) {
      return this.logic.getPersistedSnapshot(this._snapshot, options);
    }
    [symbolObservable2]() {
      return this;
    }
    /**
     * Read an actors snapshot synchronously.
     *
     * @remarks
     * The snapshot represent an actor's last emitted value.
     *
     * When an actor receives an event, its internal state may change. An actor
     * may emit a snapshot when a state transition occurs.
     *
     * Note that some actors, such as callback actors generated with
     * `fromCallback`, will not emit snapshots.
     * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
     * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
     */
    getSnapshot() {
      return this._snapshot;
    }
  }
  function createActor2(logic, ...[options]) {
    return new Actor2(logic, options);
  }
  const interpret = createActor2;
  function resolveCancel2(_, snapshot, actionArgs, actionParams, {
    sendId
  }) {
    const resolvedSendId = typeof sendId == "function" ? sendId(actionArgs, actionParams) : sendId;
    return [snapshot, {
      sendId: resolvedSendId
    }, void 0];
  }
  function executeCancel2(actorScope, params) {
    actorScope.defer(() => {
      actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
    });
  }
  function cancel2(sendId) {
    function cancel3(_args, _params) {
    }
    return cancel3.type = "xstate.cancel", cancel3.sendId = sendId, cancel3.resolve = resolveCancel2, cancel3.execute = executeCancel2, cancel3;
  }
  function resolveSpawn2(actorScope, snapshot, actionArgs, _actionParams, {
    id: id2,
    systemId,
    src,
    input: input2,
    syncSnapshot
  }) {
    const logic = typeof src == "string" ? resolveReferencedActor2(snapshot.machine, src) : src, resolvedId = typeof id2 == "function" ? id2(actionArgs) : id2;
    let actorRef, resolvedInput;
    return logic && (resolvedInput = typeof input2 == "function" ? input2({
      context: snapshot.context,
      event: actionArgs.event,
      self: actorScope.self
    }) : input2, actorRef = createActor2(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: resolvedInput
    })), [cloneMachineSnapshot2(snapshot, {
      children: {
        ...snapshot.children,
        [resolvedId]: actorRef
      }
    }), {
      id: id2,
      systemId,
      actorRef,
      src,
      input: resolvedInput
    }, void 0];
  }
  function executeSpawn2(actorScope, {
    actorRef
  }) {
    actorRef && actorScope.defer(() => {
      actorRef._processingStatus !== ProcessingStatus2.Stopped && actorRef.start();
    });
  }
  function spawnChild2(...[src, {
    id: id2,
    systemId,
    input: input2,
    syncSnapshot = !1
  } = {}]) {
    function spawnChild3(_args, _params) {
    }
    return spawnChild3.type = "xstate.spawnChild", spawnChild3.id = id2, spawnChild3.systemId = systemId, spawnChild3.src = src, spawnChild3.input = input2, spawnChild3.syncSnapshot = syncSnapshot, spawnChild3.resolve = resolveSpawn2, spawnChild3.execute = executeSpawn2, spawnChild3;
  }
  function resolveStop2(_, snapshot, args, actionParams, {
    actorRef
  }) {
    const actorRefOrString = typeof actorRef == "function" ? actorRef(args, actionParams) : actorRef, resolvedActorRef = typeof actorRefOrString == "string" ? snapshot.children[actorRefOrString] : actorRefOrString;
    let children2 = snapshot.children;
    return resolvedActorRef && (children2 = {
      ...children2
    }, delete children2[resolvedActorRef.id]), [cloneMachineSnapshot2(snapshot, {
      children: children2
    }), resolvedActorRef, void 0];
  }
  function executeStop2(actorScope, actorRef) {
    if (actorRef) {
      if (actorScope.system._unregister(actorRef), actorRef._processingStatus !== ProcessingStatus2.Running) {
        actorScope.stopChild(actorRef);
        return;
      }
      actorScope.defer(() => {
        actorScope.stopChild(actorRef);
      });
    }
  }
  function stopChild2(actorRef) {
    function stop2(_args, _params) {
    }
    return stop2.type = "xstate.stopChild", stop2.actorRef = actorRef, stop2.resolve = resolveStop2, stop2.execute = executeStop2, stop2;
  }
  const stop = stopChild2;
  function checkStateIn(snapshot, _, {
    stateValue
  }) {
    if (typeof stateValue == "string" && isStateId2(stateValue)) {
      const target = snapshot.machine.getStateNodeById(stateValue);
      return snapshot._nodes.some((sn) => sn === target);
    }
    return snapshot.matches(stateValue);
  }
  function stateIn(stateValue) {
    function stateIn2() {
      return !1;
    }
    return stateIn2.check = checkStateIn, stateIn2.stateValue = stateValue, stateIn2;
  }
  function checkNot(snapshot, {
    context: context2,
    event
  }, {
    guards
  }) {
    return !evaluateGuard2(guards[0], context2, event, snapshot);
  }
  function not(guard) {
    function not2(_args, _params) {
      return !1;
    }
    return not2.check = checkNot, not2.guards = [guard], not2;
  }
  function checkAnd(snapshot, {
    context: context2,
    event
  }, {
    guards
  }) {
    return guards.every((guard) => evaluateGuard2(guard, context2, event, snapshot));
  }
  function and(guards) {
    function and2(_args, _params) {
      return !1;
    }
    return and2.check = checkAnd, and2.guards = guards, and2;
  }
  function checkOr(snapshot, {
    context: context2,
    event
  }, {
    guards
  }) {
    return guards.some((guard) => evaluateGuard2(guard, context2, event, snapshot));
  }
  function or(guards) {
    function or2(_args, _params) {
      return !1;
    }
    return or2.check = checkOr, or2.guards = guards, or2;
  }
  function evaluateGuard2(guard, context2, event, snapshot) {
    const {
      machine: machine2
    } = snapshot, isInline = typeof guard == "function", resolved = isInline ? guard : machine2.implementations.guards[typeof guard == "string" ? guard : guard.type];
    if (!isInline && !resolved)
      throw new Error(`Guard '${typeof guard == "string" ? guard : guard.type}' is not implemented.'.`);
    if (typeof resolved != "function")
      return evaluateGuard2(resolved, context2, event, snapshot);
    const guardArgs = {
      context: context2,
      event
    }, guardParams = isInline || typeof guard == "string" ? void 0 : "params" in guard ? typeof guard.params == "function" ? guard.params({
      context: context2,
      event
    }) : guard.params : void 0;
    return "check" in resolved ? resolved.check(
      snapshot,
      guardArgs,
      resolved
      // this holds all params
    ) : resolved(guardArgs, guardParams);
  }
  const isAtomicStateNode2 = (stateNode) => stateNode.type === "atomic" || stateNode.type === "final";
  function getChildren2(stateNode) {
    return Object.values(stateNode.states).filter((sn) => sn.type !== "history");
  }
  function getProperAncestors2(stateNode, toStateNode) {
    const ancestors = [];
    if (toStateNode === stateNode)
      return ancestors;
    let m2 = stateNode.parent;
    for (; m2 && m2 !== toStateNode; )
      ancestors.push(m2), m2 = m2.parent;
    return ancestors;
  }
  function getAllStateNodes2(stateNodes) {
    const nodeSet = new Set(stateNodes), adjList = getAdjList2(nodeSet);
    for (const s2 of nodeSet)
      if (s2.type === "compound" && (!adjList.get(s2) || !adjList.get(s2).length))
        getInitialStateNodesWithTheirAncestors2(s2).forEach((sn) => nodeSet.add(sn));
      else if (s2.type === "parallel") {
        for (const child of getChildren2(s2))
          if (child.type !== "history" && !nodeSet.has(child)) {
            const initialStates = getInitialStateNodesWithTheirAncestors2(child);
            for (const initialStateNode of initialStates)
              nodeSet.add(initialStateNode);
          }
      }
    for (const s2 of nodeSet) {
      let m2 = s2.parent;
      for (; m2; )
        nodeSet.add(m2), m2 = m2.parent;
    }
    return nodeSet;
  }
  function getValueFromAdj2(baseNode, adjList) {
    const childStateNodes = adjList.get(baseNode);
    if (!childStateNodes)
      return {};
    if (baseNode.type === "compound") {
      const childStateNode = childStateNodes[0];
      if (childStateNode) {
        if (isAtomicStateNode2(childStateNode))
          return childStateNode.key;
      } else
        return {};
    }
    const stateValue = {};
    for (const childStateNode of childStateNodes)
      stateValue[childStateNode.key] = getValueFromAdj2(childStateNode, adjList);
    return stateValue;
  }
  function getAdjList2(stateNodes) {
    const adjList = /* @__PURE__ */ new Map();
    for (const s2 of stateNodes)
      adjList.has(s2) || adjList.set(s2, []), s2.parent && (adjList.has(s2.parent) || adjList.set(s2.parent, []), adjList.get(s2.parent).push(s2));
    return adjList;
  }
  function getStateValue2(rootNode, stateNodes) {
    const config = getAllStateNodes2(stateNodes);
    return getValueFromAdj2(rootNode, getAdjList2(config));
  }
  function isInFinalState2(stateNodeSet, stateNode) {
    return stateNode.type === "compound" ? getChildren2(stateNode).some((s2) => s2.type === "final" && stateNodeSet.has(s2)) : stateNode.type === "parallel" ? getChildren2(stateNode).every((sn) => isInFinalState2(stateNodeSet, sn)) : stateNode.type === "final";
  }
  const isStateId2 = (str) => str[0] === STATE_IDENTIFIER2;
  function getCandidates2(stateNode, receivedEventType) {
    return stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter((eventDescriptor) => {
      if (eventDescriptor === WILDCARD2)
        return !0;
      if (!eventDescriptor.endsWith(".*"))
        return !1;
      const partialEventTokens = eventDescriptor.split("."), eventTokens = receivedEventType.split(".");
      for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
        const partialEventToken = partialEventTokens[tokenIndex], eventToken = eventTokens[tokenIndex];
        if (partialEventToken === "*")
          return tokenIndex === partialEventTokens.length - 1;
        if (partialEventToken !== eventToken)
          return !1;
      }
      return !0;
    }).sort((a2, b2) => b2.length - a2.length).flatMap((key2) => stateNode.transitions.get(key2));
  }
  function getDelayedTransitions2(stateNode) {
    const afterConfig = stateNode.config.after;
    if (!afterConfig)
      return [];
    const mutateEntryExit = (delay2) => {
      const afterEvent = createAfterEvent2(delay2, stateNode.id), eventType = afterEvent.type;
      return stateNode.entry.push(raise2(afterEvent, {
        id: eventType,
        delay: delay2
      })), stateNode.exit.push(cancel2(eventType)), eventType;
    };
    return Object.keys(afterConfig).flatMap((delay2) => {
      const configTransition = afterConfig[delay2], resolvedTransition = typeof configTransition == "string" ? {
        target: configTransition
      } : configTransition, resolvedDelay = Number.isNaN(+delay2) ? delay2 : +delay2, eventType = mutateEntryExit(resolvedDelay);
      return toArray2(resolvedTransition).map((transition) => ({
        ...transition,
        event: eventType,
        delay: resolvedDelay
      }));
    }).map((delayedTransition) => {
      const {
        delay: delay2
      } = delayedTransition;
      return {
        ...formatTransition2(stateNode, delayedTransition.event, delayedTransition),
        delay: delay2
      };
    });
  }
  function formatTransition2(stateNode, descriptor, transitionConfig) {
    const normalizedTarget = normalizeTarget2(transitionConfig.target), reenter = transitionConfig.reenter ?? !1, target = resolveTarget2(stateNode, normalizedTarget), transition = {
      ...transitionConfig,
      actions: toArray2(transitionConfig.actions),
      guard: transitionConfig.guard,
      target,
      source: stateNode,
      reenter,
      eventType: descriptor,
      toJSON: () => ({
        ...transition,
        source: `#${stateNode.id}`,
        target: target ? target.map((t2) => `#${t2.id}`) : void 0
      })
    };
    return transition;
  }
  function formatTransitions2(stateNode) {
    const transitions2 = /* @__PURE__ */ new Map();
    if (stateNode.config.on)
      for (const descriptor of Object.keys(stateNode.config.on)) {
        if (descriptor === NULL_EVENT2)
          throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
        const transitionsConfig = stateNode.config.on[descriptor];
        transitions2.set(descriptor, toTransitionConfigArray2(transitionsConfig).map((t2) => formatTransition2(stateNode, descriptor, t2)));
      }
    if (stateNode.config.onDone) {
      const descriptor = `xstate.done.state.${stateNode.id}`;
      transitions2.set(descriptor, toTransitionConfigArray2(stateNode.config.onDone).map((t2) => formatTransition2(stateNode, descriptor, t2)));
    }
    for (const invokeDef of stateNode.invoke) {
      if (invokeDef.onDone) {
        const descriptor = `xstate.done.actor.${invokeDef.id}`;
        transitions2.set(descriptor, toTransitionConfigArray2(invokeDef.onDone).map((t2) => formatTransition2(stateNode, descriptor, t2)));
      }
      if (invokeDef.onError) {
        const descriptor = `xstate.error.actor.${invokeDef.id}`;
        transitions2.set(descriptor, toTransitionConfigArray2(invokeDef.onError).map((t2) => formatTransition2(stateNode, descriptor, t2)));
      }
      if (invokeDef.onSnapshot) {
        const descriptor = `xstate.snapshot.${invokeDef.id}`;
        transitions2.set(descriptor, toTransitionConfigArray2(invokeDef.onSnapshot).map((t2) => formatTransition2(stateNode, descriptor, t2)));
      }
    }
    for (const delayedTransition of stateNode.after) {
      let existing = transitions2.get(delayedTransition.eventType);
      existing || (existing = [], transitions2.set(delayedTransition.eventType, existing)), existing.push(delayedTransition);
    }
    return transitions2;
  }
  function formatInitialTransition2(stateNode, _target) {
    const resolvedTarget = typeof _target == "string" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : void 0;
    if (!resolvedTarget && _target)
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
        `Initial state node "${_target}" not found on parent state node #${stateNode.id}`
      );
    const transition = {
      source: stateNode,
      actions: !_target || typeof _target == "string" ? [] : toArray2(_target.actions),
      eventType: null,
      reenter: !1,
      target: resolvedTarget ? [resolvedTarget] : [],
      toJSON: () => ({
        ...transition,
        source: `#${stateNode.id}`,
        target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
      })
    };
    return transition;
  }
  function resolveTarget2(stateNode, targets) {
    if (targets !== void 0)
      return targets.map((target) => {
        if (typeof target != "string")
          return target;
        if (isStateId2(target))
          return stateNode.machine.getStateNodeById(target);
        const isInternalTarget = target[0] === STATE_DELIMITER2;
        if (isInternalTarget && !stateNode.parent)
          return getStateNodeByPath2(stateNode, target.slice(1));
        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
        if (stateNode.parent)
          try {
            return getStateNodeByPath2(stateNode.parent, resolvedTarget);
          } catch (err) {
            throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
          }
        else
          throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
      });
  }
  function resolveHistoryDefaultTransition2(stateNode) {
    const normalizedTarget = normalizeTarget2(stateNode.config.target);
    return normalizedTarget ? {
      target: normalizedTarget.map((t2) => typeof t2 == "string" ? getStateNodeByPath2(stateNode.parent, t2) : t2)
    } : stateNode.parent.initial;
  }
  function isHistoryNode2(stateNode) {
    return stateNode.type === "history";
  }
  function getInitialStateNodesWithTheirAncestors2(stateNode) {
    const states = getInitialStateNodes2(stateNode);
    for (const initialState2 of states)
      for (const ancestor of getProperAncestors2(initialState2, stateNode))
        states.add(ancestor);
    return states;
  }
  function getInitialStateNodes2(stateNode) {
    const set2 = /* @__PURE__ */ new Set();
    function iter(descStateNode) {
      if (!set2.has(descStateNode)) {
        if (set2.add(descStateNode), descStateNode.type === "compound")
          iter(descStateNode.initial.target[0]);
        else if (descStateNode.type === "parallel")
          for (const child of getChildren2(descStateNode))
            iter(child);
      }
    }
    return iter(stateNode), set2;
  }
  function getStateNode2(stateNode, stateKey) {
    if (isStateId2(stateKey))
      return stateNode.machine.getStateNodeById(stateKey);
    if (!stateNode.states)
      throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
    const result = stateNode.states[stateKey];
    if (!result)
      throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
    return result;
  }
  function getStateNodeByPath2(stateNode, statePath) {
    if (typeof statePath == "string" && isStateId2(statePath))
      try {
        return stateNode.machine.getStateNodeById(statePath);
      } catch {
      }
    const arrayStatePath = toStatePath2(statePath).slice();
    let currentStateNode = stateNode;
    for (; arrayStatePath.length; ) {
      const key2 = arrayStatePath.shift();
      if (!key2.length)
        break;
      currentStateNode = getStateNode2(currentStateNode, key2);
    }
    return currentStateNode;
  }
  function getStateNodes2(stateNode, stateValue) {
    if (typeof stateValue == "string") {
      const childStateNode = stateNode.states[stateValue];
      if (!childStateNode)
        throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
      return [stateNode, childStateNode];
    }
    const childStateKeys = Object.keys(stateValue), childStateNodes = childStateKeys.map((subStateKey) => getStateNode2(stateNode, subStateKey)).filter(Boolean);
    return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
      const subStateNode = getStateNode2(stateNode, subStateKey);
      if (!subStateNode)
        return allSubStateNodes;
      const subStateNodes = getStateNodes2(subStateNode, stateValue[subStateKey]);
      return allSubStateNodes.concat(subStateNodes);
    }, []));
  }
  function transitionAtomicNode2(stateNode, stateValue, snapshot, event) {
    const next = getStateNode2(stateNode, stateValue).next(snapshot, event);
    return !next || !next.length ? stateNode.next(snapshot, event) : next;
  }
  function transitionCompoundNode2(stateNode, stateValue, snapshot, event) {
    const subStateKeys = Object.keys(stateValue), childStateNode = getStateNode2(stateNode, subStateKeys[0]), next = transitionNode2(childStateNode, stateValue[subStateKeys[0]], snapshot, event);
    return !next || !next.length ? stateNode.next(snapshot, event) : next;
  }
  function transitionParallelNode2(stateNode, stateValue, snapshot, event) {
    const allInnerTransitions = [];
    for (const subStateKey of Object.keys(stateValue)) {
      const subStateValue = stateValue[subStateKey];
      if (!subStateValue)
        continue;
      const subStateNode = getStateNode2(stateNode, subStateKey), innerTransitions = transitionNode2(subStateNode, subStateValue, snapshot, event);
      innerTransitions && allInnerTransitions.push(...innerTransitions);
    }
    return allInnerTransitions.length ? allInnerTransitions : stateNode.next(snapshot, event);
  }
  function transitionNode2(stateNode, stateValue, snapshot, event) {
    return typeof stateValue == "string" ? transitionAtomicNode2(stateNode, stateValue, snapshot, event) : Object.keys(stateValue).length === 1 ? transitionCompoundNode2(stateNode, stateValue, snapshot, event) : transitionParallelNode2(stateNode, stateValue, snapshot, event);
  }
  function getHistoryNodes2(stateNode) {
    return Object.keys(stateNode.states).map((key2) => stateNode.states[key2]).filter((sn) => sn.type === "history");
  }
  function isDescendant2(childStateNode, parentStateNode) {
    let marker = childStateNode;
    for (; marker.parent && marker.parent !== parentStateNode; )
      marker = marker.parent;
    return marker.parent === parentStateNode;
  }
  function hasIntersection2(s1, s2) {
    const set1 = new Set(s1), set2 = new Set(s2);
    for (const item of set1)
      if (set2.has(item))
        return !0;
    for (const item of set2)
      if (set1.has(item))
        return !0;
    return !1;
  }
  function removeConflictingTransitions2(enabledTransitions, stateNodeSet, historyValue) {
    const filteredTransitions = /* @__PURE__ */ new Set();
    for (const t1 of enabledTransitions) {
      let t1Preempted = !1;
      const transitionsToRemove = /* @__PURE__ */ new Set();
      for (const t2 of filteredTransitions)
        if (hasIntersection2(computeExitSet2([t1], stateNodeSet, historyValue), computeExitSet2([t2], stateNodeSet, historyValue)))
          if (isDescendant2(t1.source, t2.source))
            transitionsToRemove.add(t2);
          else {
            t1Preempted = !0;
            break;
          }
      if (!t1Preempted) {
        for (const t3 of transitionsToRemove)
          filteredTransitions.delete(t3);
        filteredTransitions.add(t1);
      }
    }
    return Array.from(filteredTransitions);
  }
  function findLeastCommonAncestor2(stateNodes) {
    const [head, ...tail] = stateNodes;
    for (const ancestor of getProperAncestors2(head, void 0))
      if (tail.every((sn) => isDescendant2(sn, ancestor)))
        return ancestor;
  }
  function getEffectiveTargetStates2(transition, historyValue) {
    if (!transition.target)
      return [];
    const targets = /* @__PURE__ */ new Set();
    for (const targetNode of transition.target)
      if (isHistoryNode2(targetNode))
        if (historyValue[targetNode.id])
          for (const node2 of historyValue[targetNode.id])
            targets.add(node2);
        else
          for (const node2 of getEffectiveTargetStates2(resolveHistoryDefaultTransition2(targetNode), historyValue))
            targets.add(node2);
      else
        targets.add(targetNode);
    return [...targets];
  }
  function getTransitionDomain2(transition, historyValue) {
    const targetStates = getEffectiveTargetStates2(transition, historyValue);
    if (!targetStates)
      return;
    if (!transition.reenter && targetStates.every((target) => target === transition.source || isDescendant2(target, transition.source)))
      return transition.source;
    const lca = findLeastCommonAncestor2(targetStates.concat(transition.source));
    if (lca)
      return lca;
    if (!transition.reenter)
      return transition.source.machine.root;
  }
  function computeExitSet2(transitions2, stateNodeSet, historyValue) {
    const statesToExit = /* @__PURE__ */ new Set();
    for (const t2 of transitions2)
      if (t2.target?.length) {
        const domain = getTransitionDomain2(t2, historyValue);
        t2.reenter && t2.source === domain && statesToExit.add(domain);
        for (const stateNode of stateNodeSet)
          isDescendant2(stateNode, domain) && statesToExit.add(stateNode);
      }
    return [...statesToExit];
  }
  function areStateNodeCollectionsEqual2(prevStateNodes, nextStateNodeSet) {
    if (prevStateNodes.length !== nextStateNodeSet.size)
      return !1;
    for (const node2 of prevStateNodes)
      if (!nextStateNodeSet.has(node2))
        return !1;
    return !0;
  }
  function microstep2(transitions2, currentSnapshot, actorScope, event, isInitial, internalQueue) {
    if (!transitions2.length)
      return currentSnapshot;
    const mutStateNodeSet = new Set(currentSnapshot._nodes);
    let historyValue = currentSnapshot.historyValue;
    const filteredTransitions = removeConflictingTransitions2(transitions2, mutStateNodeSet, historyValue);
    let nextState = currentSnapshot;
    isInitial || ([nextState, historyValue] = exitStates2(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor)), nextState = resolveActionsAndContext2(nextState, event, actorScope, filteredTransitions.flatMap((t2) => t2.actions), internalQueue, void 0), nextState = enterStates2(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
    const nextStateNodes = [...mutStateNodeSet];
    nextState.status === "done" && (nextState = resolveActionsAndContext2(nextState, event, actorScope, nextStateNodes.sort((a2, b2) => b2.order - a2.order).flatMap((state) => state.exit), internalQueue, void 0));
    try {
      return historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual2(currentSnapshot._nodes, mutStateNodeSet) ? nextState : cloneMachineSnapshot2(nextState, {
        _nodes: nextStateNodes,
        historyValue
      });
    } catch (e2) {
      throw e2;
    }
  }
  function getMachineOutput2(snapshot, event, actorScope, rootNode, rootCompletionNode) {
    if (rootNode.output === void 0)
      return;
    const doneStateEvent = createDoneStateEvent2(rootCompletionNode.id, rootCompletionNode.output !== void 0 && rootCompletionNode.parent ? resolveOutput2(rootCompletionNode.output, snapshot.context, event, actorScope.self) : void 0);
    return resolveOutput2(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
  }
  function enterStates2(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
    let nextSnapshot = currentSnapshot;
    const statesToEnter = /* @__PURE__ */ new Set(), statesForDefaultEntry = /* @__PURE__ */ new Set();
    computeEntrySet2(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter), isInitial && statesForDefaultEntry.add(currentSnapshot.machine.root);
    const completedNodes = /* @__PURE__ */ new Set();
    for (const stateNodeToEnter of [...statesToEnter].sort((a2, b2) => a2.order - b2.order)) {
      mutStateNodeSet.add(stateNodeToEnter);
      const actions = [];
      actions.push(...stateNodeToEnter.entry);
      for (const invokeDef of stateNodeToEnter.invoke)
        actions.push(spawnChild2(invokeDef.src, {
          ...invokeDef,
          syncSnapshot: !!invokeDef.onSnapshot
        }));
      if (statesForDefaultEntry.has(stateNodeToEnter)) {
        const initialActions = stateNodeToEnter.initial.actions;
        actions.push(...initialActions);
      }
      if (nextSnapshot = resolveActionsAndContext2(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)), stateNodeToEnter.type === "final") {
        const parent = stateNodeToEnter.parent;
        let ancestorMarker = parent?.type === "parallel" ? parent : parent?.parent, rootCompletionNode = ancestorMarker || stateNodeToEnter;
        for (parent?.type === "compound" && internalQueue.push(createDoneStateEvent2(parent.id, stateNodeToEnter.output !== void 0 ? resolveOutput2(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : void 0)); ancestorMarker?.type === "parallel" && !completedNodes.has(ancestorMarker) && isInFinalState2(mutStateNodeSet, ancestorMarker); )
          completedNodes.add(ancestorMarker), internalQueue.push(createDoneStateEvent2(ancestorMarker.id)), rootCompletionNode = ancestorMarker, ancestorMarker = ancestorMarker.parent;
        if (ancestorMarker)
          continue;
        nextSnapshot = cloneMachineSnapshot2(nextSnapshot, {
          status: "done",
          output: getMachineOutput2(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)
        });
      }
    }
    return nextSnapshot;
  }
  function computeEntrySet2(transitions2, historyValue, statesForDefaultEntry, statesToEnter) {
    for (const t2 of transitions2) {
      const domain = getTransitionDomain2(t2, historyValue);
      for (const s2 of t2.target || [])
        !isHistoryNode2(s2) && // if the target is different than the source then it will *definitely* be entered
        (t2.source !== s2 || // we know that the domain can't lie within the source
        // if it's different than the source then it's outside of it and it means that the target has to be entered as well
        t2.source !== domain || // reentering transitions always enter the target, even if it's the source itself
        t2.reenter) && (statesToEnter.add(s2), statesForDefaultEntry.add(s2)), addDescendantStatesToEnter2(s2, historyValue, statesForDefaultEntry, statesToEnter);
      const targetStates = getEffectiveTargetStates2(t2, historyValue);
      for (const s2 of targetStates) {
        const ancestors = getProperAncestors2(s2, domain);
        domain?.type === "parallel" && ancestors.push(domain), addAncestorStatesToEnter2(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t2.source.parent && t2.reenter ? void 0 : domain);
      }
    }
  }
  function addDescendantStatesToEnter2(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
    if (isHistoryNode2(stateNode))
      if (historyValue[stateNode.id]) {
        const historyStateNodes = historyValue[stateNode.id];
        for (const s2 of historyStateNodes)
          statesToEnter.add(s2), addDescendantStatesToEnter2(s2, historyValue, statesForDefaultEntry, statesToEnter);
        for (const s2 of historyStateNodes)
          addProperAncestorStatesToEnter2(s2, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      } else {
        const historyDefaultTransition = resolveHistoryDefaultTransition2(stateNode);
        for (const s2 of historyDefaultTransition.target)
          statesToEnter.add(s2), historyDefaultTransition === stateNode.parent?.initial && statesForDefaultEntry.add(stateNode.parent), addDescendantStatesToEnter2(s2, historyValue, statesForDefaultEntry, statesToEnter);
        for (const s2 of historyDefaultTransition.target)
          addProperAncestorStatesToEnter2(s2, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    else if (stateNode.type === "compound") {
      const [initialState2] = stateNode.initial.target;
      isHistoryNode2(initialState2) || (statesToEnter.add(initialState2), statesForDefaultEntry.add(initialState2)), addDescendantStatesToEnter2(initialState2, historyValue, statesForDefaultEntry, statesToEnter), addProperAncestorStatesToEnter2(initialState2, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
    } else if (stateNode.type === "parallel")
      for (const child of getChildren2(stateNode).filter((sn) => !isHistoryNode2(sn)))
        [...statesToEnter].some((s2) => isDescendant2(s2, child)) || (isHistoryNode2(child) || (statesToEnter.add(child), statesForDefaultEntry.add(child)), addDescendantStatesToEnter2(child, historyValue, statesForDefaultEntry, statesToEnter));
  }
  function addAncestorStatesToEnter2(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
    for (const anc of ancestors)
      if ((!reentrancyDomain || isDescendant2(anc, reentrancyDomain)) && statesToEnter.add(anc), anc.type === "parallel")
        for (const child of getChildren2(anc).filter((sn) => !isHistoryNode2(sn)))
          [...statesToEnter].some((s2) => isDescendant2(s2, child)) || (statesToEnter.add(child), addDescendantStatesToEnter2(child, historyValue, statesForDefaultEntry, statesToEnter));
  }
  function addProperAncestorStatesToEnter2(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
    addAncestorStatesToEnter2(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors2(stateNode, toStateNode));
  }
  function exitStates2(currentSnapshot, event, actorScope, transitions2, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {
    let nextSnapshot = currentSnapshot;
    const statesToExit = computeExitSet2(transitions2, mutStateNodeSet, historyValue);
    statesToExit.sort((a2, b2) => b2.order - a2.order);
    let changedHistory;
    for (const exitStateNode of statesToExit)
      for (const historyNode of getHistoryNodes2(exitStateNode)) {
        let predicate;
        historyNode.history === "deep" ? predicate = (sn) => isAtomicStateNode2(sn) && isDescendant2(sn, exitStateNode) : predicate = (sn) => sn.parent === exitStateNode, changedHistory ??= {
          ...historyValue
        }, changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
      }
    for (const s2 of statesToExit)
      nextSnapshot = resolveActionsAndContext2(nextSnapshot, event, actorScope, [...s2.exit, ...s2.invoke.map((def) => stopChild2(def.id))], internalQueue, void 0), mutStateNodeSet.delete(s2);
    return [nextSnapshot, changedHistory || historyValue];
  }
  function getAction2(machine2, actionType) {
    return machine2.implementations.actions[actionType];
  }
  function resolveAndExecuteActionsWithContext2(currentSnapshot, event, actorScope, actions, extra, retries) {
    const {
      machine: machine2
    } = currentSnapshot;
    let intermediateSnapshot = currentSnapshot;
    for (const action of actions) {
      const isInline = typeof action == "function", resolvedAction = isInline ? action : (
        // the existing type of `.actions` assumes non-nullable `TExpressionAction`
        // it's fine to cast this here to get a common type and lack of errors in the rest of the code
        // our logic below makes sure that we call those 2 "variants" correctly
        getAction2(machine2, typeof action == "string" ? action : action.type)
      ), actionArgs = {
        context: intermediateSnapshot.context,
        event,
        self: actorScope.self,
        system: actorScope.system
      }, actionParams = isInline || typeof action == "string" ? void 0 : "params" in action ? typeof action.params == "function" ? action.params({
        context: intermediateSnapshot.context,
        event
      }) : action.params : void 0;
      if (!resolvedAction || !("resolve" in resolvedAction)) {
        actorScope.actionExecutor({
          type: typeof action == "string" ? action : typeof action == "object" ? action.type : action.name || "(anonymous)",
          info: actionArgs,
          params: actionParams,
          exec: resolvedAction
        });
        continue;
      }
      const builtinAction = resolvedAction, [nextState, params, actions2] = builtinAction.resolve(
        actorScope,
        intermediateSnapshot,
        actionArgs,
        actionParams,
        resolvedAction,
        // this holds all params
        extra
      );
      intermediateSnapshot = nextState, "retryResolve" in builtinAction && retries?.push([builtinAction, params]), "execute" in builtinAction && actorScope.actionExecutor({
        type: builtinAction.type,
        info: actionArgs,
        params,
        exec: builtinAction.execute.bind(null, actorScope, params)
      }), actions2 && (intermediateSnapshot = resolveAndExecuteActionsWithContext2(intermediateSnapshot, event, actorScope, actions2, extra, retries));
    }
    return intermediateSnapshot;
  }
  function resolveActionsAndContext2(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {
    const retries = deferredActorIds ? [] : void 0, nextState = resolveAndExecuteActionsWithContext2(currentSnapshot, event, actorScope, actions, {
      internalQueue,
      deferredActorIds
    }, retries);
    return retries?.forEach(([builtinAction, params]) => {
      builtinAction.retryResolve(actorScope, nextState, params);
    }), nextState;
  }
  function macrostep2(snapshot, event, actorScope, internalQueue) {
    let nextSnapshot = snapshot;
    const microstates = [];
    function addMicrostate(microstate, event2, transitions2) {
      actorScope.system._sendInspectionEvent({
        type: "@xstate.microstep",
        actorRef: actorScope.self,
        event: event2,
        snapshot: microstate,
        _transitions: transitions2
      }), microstates.push(microstate);
    }
    if (event.type === XSTATE_STOP2)
      return nextSnapshot = cloneMachineSnapshot2(stopChildren2(nextSnapshot, event, actorScope), {
        status: "stopped"
      }), addMicrostate(nextSnapshot, event, []), {
        snapshot: nextSnapshot,
        microstates
      };
    let nextEvent = event;
    if (nextEvent.type !== XSTATE_INIT2) {
      const currentEvent = nextEvent, isErr = isErrorActorEvent2(currentEvent), transitions2 = selectTransitions2(currentEvent, nextSnapshot);
      if (isErr && !transitions2.length)
        return nextSnapshot = cloneMachineSnapshot2(snapshot, {
          status: "error",
          error: currentEvent.error
        }), addMicrostate(nextSnapshot, currentEvent, []), {
          snapshot: nextSnapshot,
          microstates
        };
      nextSnapshot = microstep2(
        transitions2,
        snapshot,
        actorScope,
        nextEvent,
        !1,
        // isInitial
        internalQueue
      ), addMicrostate(nextSnapshot, currentEvent, transitions2);
    }
    let shouldSelectEventlessTransitions = !0;
    for (; nextSnapshot.status === "active"; ) {
      let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions2(nextSnapshot, nextEvent) : [];
      const previousState = enabledTransitions.length ? nextSnapshot : void 0;
      if (!enabledTransitions.length) {
        if (!internalQueue.length)
          break;
        nextEvent = internalQueue.shift(), enabledTransitions = selectTransitions2(nextEvent, nextSnapshot);
      }
      nextSnapshot = microstep2(enabledTransitions, nextSnapshot, actorScope, nextEvent, !1, internalQueue), shouldSelectEventlessTransitions = nextSnapshot !== previousState, addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
    }
    return nextSnapshot.status !== "active" && stopChildren2(nextSnapshot, nextEvent, actorScope), {
      snapshot: nextSnapshot,
      microstates
    };
  }
  function stopChildren2(nextState, event, actorScope) {
    return resolveActionsAndContext2(nextState, event, actorScope, Object.values(nextState.children).map((child) => stopChild2(child)), [], void 0);
  }
  function selectTransitions2(event, nextState) {
    return nextState.machine.getTransitionData(nextState, event);
  }
  function selectEventlessTransitions2(nextState, event) {
    const enabledTransitionSet = /* @__PURE__ */ new Set(), atomicStates = nextState._nodes.filter(isAtomicStateNode2);
    for (const stateNode of atomicStates)
      loop: for (const s2 of [stateNode].concat(getProperAncestors2(stateNode, void 0)))
        if (s2.always) {
          for (const transition of s2.always)
            if (transition.guard === void 0 || evaluateGuard2(transition.guard, nextState.context, event, nextState)) {
              enabledTransitionSet.add(transition);
              break loop;
            }
        }
    return removeConflictingTransitions2(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
  }
  function resolveStateValue2(rootNode, stateValue) {
    const allStateNodes = getAllStateNodes2(getStateNodes2(rootNode, stateValue));
    return getStateValue2(rootNode, [...allStateNodes]);
  }
  function isMachineSnapshot2(value) {
    return !!value && typeof value == "object" && "machine" in value && "value" in value;
  }
  const machineSnapshotMatches2 = function(testValue) {
    return matchesState2(testValue, this.value);
  }, machineSnapshotHasTag2 = function(tag) {
    return this.tags.has(tag);
  }, machineSnapshotCan2 = function(event) {
    const transitionData = this.machine.getTransitionData(this, event);
    return !!transitionData?.length && // Check that at least one transition is not forbidden
    transitionData.some((t2) => t2.target !== void 0 || t2.actions.length);
  }, machineSnapshotToJSON2 = function() {
    const {
      _nodes: nodes,
      tags,
      machine: machine2,
      getMeta: getMeta2,
      toJSON: toJSON3,
      can: can2,
      hasTag: hasTag2,
      matches: matches2,
      ...jsonValues
    } = this;
    return {
      ...jsonValues,
      tags: Array.from(tags)
    };
  }, machineSnapshotGetMeta2 = function() {
    return this._nodes.reduce((acc, stateNode) => (stateNode.meta !== void 0 && (acc[stateNode.id] = stateNode.meta), acc), {});
  };
  function createMachineSnapshot2(config, machine2) {
    return {
      status: config.status,
      output: config.output,
      error: config.error,
      machine: machine2,
      context: config.context,
      _nodes: config._nodes,
      value: getStateValue2(machine2.root, config._nodes),
      tags: new Set(config._nodes.flatMap((sn) => sn.tags)),
      children: config.children,
      historyValue: config.historyValue || {},
      matches: machineSnapshotMatches2,
      hasTag: machineSnapshotHasTag2,
      can: machineSnapshotCan2,
      getMeta: machineSnapshotGetMeta2,
      toJSON: machineSnapshotToJSON2
    };
  }
  function cloneMachineSnapshot2(snapshot, config = {}) {
    return createMachineSnapshot2({
      ...snapshot,
      ...config
    }, snapshot.machine);
  }
  function serializeHistoryValue2(historyValue) {
    if (typeof historyValue != "object" || historyValue === null)
      return {};
    const result = {};
    for (const key2 in historyValue) {
      const value = historyValue[key2];
      Array.isArray(value) && (result[key2] = value.map((item) => ({
        id: item.id
      })));
    }
    return result;
  }
  function getPersistedSnapshot2(snapshot, options) {
    const {
      _nodes: nodes,
      tags,
      machine: machine2,
      children: children2,
      context: context2,
      can: can2,
      hasTag: hasTag2,
      matches: matches2,
      getMeta: getMeta2,
      toJSON: toJSON2,
      ...jsonValues
    } = snapshot, childrenJson = {};
    for (const id2 in children2) {
      const child = children2[id2];
      childrenJson[id2] = {
        snapshot: child.getPersistedSnapshot(options),
        src: child.src,
        systemId: child.systemId,
        syncSnapshot: child._syncSnapshot
      };
    }
    return {
      ...jsonValues,
      context: persistContext2(context2),
      children: childrenJson,
      historyValue: serializeHistoryValue2(jsonValues.historyValue)
    };
  }
  function persistContext2(contextPart) {
    let copy;
    for (const key2 in contextPart) {
      const value = contextPart[key2];
      if (value && typeof value == "object")
        if ("sessionId" in value && "send" in value && "ref" in value)
          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
            ...contextPart
          }, copy[key2] = {
            xstate$$type: $$ACTOR_TYPE2,
            id: value.id
          };
        else {
          const result = persistContext2(value);
          result !== value && (copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
            ...contextPart
          }, copy[key2] = result);
        }
    }
    return copy ?? contextPart;
  }
  function resolveRaise2(_, snapshot, args, actionParams, {
    event: eventOrExpr,
    id: id2,
    delay: delay2
  }, {
    internalQueue
  }) {
    const delaysMap = snapshot.machine.implementations.delays;
    if (typeof eventOrExpr == "string")
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`
      );
    const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay2 == "string") {
      const configDelay = delaysMap && delaysMap[delay2];
      resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
    } else
      resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
    return typeof resolvedDelay != "number" && internalQueue.push(resolvedEvent), [snapshot, {
      event: resolvedEvent,
      id: id2,
      delay: resolvedDelay
    }, void 0];
  }
  function executeRaise2(actorScope, params) {
    const {
      event,
      delay: delay2,
      id: id2
    } = params;
    if (typeof delay2 == "number") {
      actorScope.defer(() => {
        const self2 = actorScope.self;
        actorScope.system.scheduler.schedule(self2, self2, event, delay2, id2);
      });
      return;
    }
  }
  function raise2(eventOrExpr, options) {
    function raise3(_args, _params) {
    }
    return raise3.type = "xstate.raise", raise3.event = eventOrExpr, raise3.id = options?.id, raise3.delay = options?.delay, raise3.resolve = resolveRaise2, raise3.execute = executeRaise2, raise3;
  }
  return raiseDa5b247f_cjs.$$ACTOR_TYPE = $$ACTOR_TYPE2, raiseDa5b247f_cjs.Actor = Actor2, raiseDa5b247f_cjs.NULL_EVENT = NULL_EVENT2, raiseDa5b247f_cjs.ProcessingStatus = ProcessingStatus2, raiseDa5b247f_cjs.STATE_DELIMITER = STATE_DELIMITER2, raiseDa5b247f_cjs.XSTATE_ERROR = XSTATE_ERROR2, raiseDa5b247f_cjs.XSTATE_STOP = XSTATE_STOP2, raiseDa5b247f_cjs.and = and, raiseDa5b247f_cjs.cancel = cancel2, raiseDa5b247f_cjs.cloneMachineSnapshot = cloneMachineSnapshot2, raiseDa5b247f_cjs.createActor = createActor2, raiseDa5b247f_cjs.createErrorActorEvent = createErrorActorEvent2, raiseDa5b247f_cjs.createInitEvent = createInitEvent2, raiseDa5b247f_cjs.createInvokeId = createInvokeId2, raiseDa5b247f_cjs.createMachineSnapshot = createMachineSnapshot2, raiseDa5b247f_cjs.evaluateGuard = evaluateGuard2, raiseDa5b247f_cjs.formatInitialTransition = formatInitialTransition2, raiseDa5b247f_cjs.formatTransition = formatTransition2, raiseDa5b247f_cjs.formatTransitions = formatTransitions2, raiseDa5b247f_cjs.getAllOwnEventDescriptors = getAllOwnEventDescriptors, raiseDa5b247f_cjs.getAllStateNodes = getAllStateNodes2, raiseDa5b247f_cjs.getCandidates = getCandidates2, raiseDa5b247f_cjs.getDelayedTransitions = getDelayedTransitions2, raiseDa5b247f_cjs.getInitialStateNodes = getInitialStateNodes2, raiseDa5b247f_cjs.getPersistedSnapshot = getPersistedSnapshot2, raiseDa5b247f_cjs.getStateNodeByPath = getStateNodeByPath2, raiseDa5b247f_cjs.getStateNodes = getStateNodes2, raiseDa5b247f_cjs.interpret = interpret, raiseDa5b247f_cjs.isInFinalState = isInFinalState2, raiseDa5b247f_cjs.isMachineSnapshot = isMachineSnapshot2, raiseDa5b247f_cjs.isStateId = isStateId2, raiseDa5b247f_cjs.macrostep = macrostep2, raiseDa5b247f_cjs.mapValues = mapValues2, raiseDa5b247f_cjs.matchesState = matchesState2, raiseDa5b247f_cjs.microstep = microstep2, raiseDa5b247f_cjs.not = not, raiseDa5b247f_cjs.or = or, raiseDa5b247f_cjs.pathToStateValue = pathToStateValue2, raiseDa5b247f_cjs.raise = raise2, raiseDa5b247f_cjs.resolveActionsAndContext = resolveActionsAndContext2, raiseDa5b247f_cjs.resolveReferencedActor = resolveReferencedActor2, raiseDa5b247f_cjs.resolveStateValue = resolveStateValue2, raiseDa5b247f_cjs.spawnChild = spawnChild2, raiseDa5b247f_cjs.stateIn = stateIn, raiseDa5b247f_cjs.stop = stop, raiseDa5b247f_cjs.stopChild = stopChild2, raiseDa5b247f_cjs.toArray = toArray2, raiseDa5b247f_cjs.toObserver = toObserver2, raiseDa5b247f_cjs.toStatePath = toStatePath2, raiseDa5b247f_cjs.toTransitionConfigArray = toTransitionConfigArray2, raiseDa5b247f_cjs.transitionNode = transitionNode2, raiseDa5b247f_cjs;
}
var hasRequiredXstateGuards_cjs;
function requireXstateGuards_cjs() {
  if (hasRequiredXstateGuards_cjs) return xstateGuards_cjs;
  hasRequiredXstateGuards_cjs = 1, Object.defineProperty(xstateGuards_cjs, "__esModule", { value: !0 });
  var guards_dist_xstateGuards = /* @__PURE__ */ requireRaiseDa5b247f_cjs();
  return requireXstateDev_cjs(), xstateGuards_cjs.and = guards_dist_xstateGuards.and, xstateGuards_cjs.evaluateGuard = guards_dist_xstateGuards.evaluateGuard, xstateGuards_cjs.not = guards_dist_xstateGuards.not, xstateGuards_cjs.or = guards_dist_xstateGuards.or, xstateGuards_cjs.stateIn = guards_dist_xstateGuards.stateIn, xstateGuards_cjs;
}
var xstateGuards_cjsExports = requireXstateGuards_cjs();
const hotkeyLogic = fromCallback(({ sendBack }) => {
  const handler = getHotkeyHandler([
    ["Escape", (event) => {
      event.stopPropagation(), sendBack({ type: "close" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", handler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", handler, { capture: !0 });
  };
}), machine$2 = setup({
  actors: {
    relationshipDetails: relationshipDetailsLogic,
    elementDetails: elementDetailsLogic,
    relationshipsBrowser: relationshipsBrowserLogic,
    hotkey: hotkeyLogic
  },
  guards: {
    "has overlays?": ({ context: context2 }) => context2.overlays.length > 0,
    "close specific overlay?": ({ context: context2, event }) => (assertEvent(event, "close"), e$2(event.actorId) && context2.overlays.some((o) => o.id === event.actorId)),
    "last: is relationshipDetails?": ({ context: context2 }) => t$g(context2.overlays)?.type === "relationshipDetails",
    "last: is relationshipsBrowser?": ({ context: context2 }) => t$g(context2.overlays)?.type === "relationshipsBrowser"
  }
}), closeLastOverlay = () => machine$2.enqueueActions(({ context: context2, enqueue }) => {
  if (context2.overlays.length === 0)
    return;
  const lastOverlay = t$g(context2.overlays)?.id;
  lastOverlay && (enqueue.sendTo(lastOverlay, { type: "close" }), enqueue.stopChild(lastOverlay), enqueue.assign({
    overlays: context2.overlays.filter((o) => o.id !== lastOverlay)
  }));
}), closeSpecificOverlay = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  assertEvent(event, "close");
  const actorId = event.actorId;
  if (!e$2(actorId))
    return;
  const toClose = context2.overlays.find((o) => o.id === actorId)?.id;
  toClose && (enqueue.sendTo(toClose, { type: "close" }), enqueue.stopChild(toClose), enqueue.assign({
    overlays: context2.overlays.filter((o) => o.id !== toClose)
  }));
}), closeAllOverlays$1 = () => machine$2.enqueueActions(({ context: context2, enqueue }) => {
  for (const { id: id2 } of t$4(context2.overlays))
    enqueue.sendTo(id2, { type: "close" }), enqueue.stopChild(id2);
  enqueue.assign({ overlays: [] });
}), openElementDetails$1 = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  if (assertEvent(event, "open.elementDetails"), context2.overlays.some((o) => o.type === "elementDetails" && o.subject === event.subject))
    return;
  const id2 = `elementDetails-${context2.seq}`;
  enqueue.spawnChild("elementDetails", {
    id: id2,
    input: event,
    syncSnapshot: !0
  }), enqueue.assign({
    seq: context2.seq + 1,
    overlays: [
      ...context2.overlays,
      {
        id: id2,
        type: "elementDetails",
        subject: event.subject
      }
    ]
  });
}), openRelationshipDetails = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  assertEvent(event, "open.relationshipDetails");
  const currentOverlay = t$g(context2.overlays);
  if (currentOverlay?.type === "relationshipDetails") {
    enqueue.sendTo(currentOverlay.id, {
      ...event,
      type: "navigate.to"
    });
    return;
  }
  const id2 = `relationshipDetails-${context2.seq}`;
  enqueue.spawnChild("relationshipDetails", {
    id: id2,
    input: event,
    syncSnapshot: !0
  }), enqueue.assign({
    seq: context2.seq + 1,
    overlays: [
      ...context2.overlays,
      {
        id: id2,
        type: "relationshipDetails"
      }
    ]
  });
}), openRelationshipsBrowser = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  assertEvent(event, "open.relationshipsBrowser");
  const currentOverlay = t$g(context2.overlays);
  if (currentOverlay?.type === "relationshipsBrowser") {
    enqueue.sendTo(currentOverlay.id, {
      type: "navigate.to",
      subject: event.subject,
      viewId: event.viewId
    });
    return;
  }
  const id2 = `relationshipsBrowser-${context2.seq}`;
  enqueue.spawnChild("relationshipsBrowser", {
    id: id2,
    input: event,
    syncSnapshot: !0
  }), enqueue.assign({
    seq: context2.seq + 1,
    overlays: [
      ...context2.overlays,
      {
        id: id2,
        type: "relationshipsBrowser",
        subject: event.subject
      }
    ]
  });
}), openOverlay$1 = () => machine$2.enqueueActions(({ enqueue, event }) => {
  switch (assertEvent(event, [
    "open.elementDetails",
    "open.relationshipDetails",
    "open.relationshipsBrowser"
  ]), event.type) {
    case "open.elementDetails":
      enqueue(openElementDetails$1());
      break;
    case "open.relationshipDetails":
      enqueue(openRelationshipDetails());
      break;
    case "open.relationshipsBrowser":
      enqueue(openRelationshipsBrowser());
      break;
  }
}), listenToEsc = () => machine$2.spawnChild("hotkey", {
  id: "hotkey"
}), stopListeningToEsc = () => machine$2.stopChild("hotkey"), checkState = () => machine$2.enqueueActions(({ enqueue, context: context2 }) => {
  context2.overlays.length === 0 && enqueue.raise({ type: "close" });
}), _overlaysActorLogic = machine$2.createMachine({
  id: "overlays",
  context: () => ({
    seq: 1,
    overlays: []
  }),
  initial: "idle",
  states: {
    idle: {
      on: {
        "open.*": {
          actions: openOverlay$1(),
          target: "active"
        }
      }
    },
    active: {
      entry: [
        listenToEsc()
      ],
      exit: [
        stopListeningToEsc()
      ],
      on: {
        "open.*": {
          actions: openOverlay$1()
        },
        close: [
          {
            guard: xstateGuards_cjsExports.not("has overlays?"),
            target: "idle"
          },
          {
            guard: "close specific overlay?",
            actions: [
              closeSpecificOverlay(),
              checkState()
            ]
          },
          {
            actions: [
              closeLastOverlay(),
              checkState()
            ]
          }
        ],
        "close.all": {
          actions: [
            closeAllOverlays$1()
          ],
          target: "idle"
        }
      }
    },
    final: {
      entry: [
        closeAllOverlays$1(),
        stopListeningToEsc()
      ],
      type: "final"
    }
  }
}), overlaysActorLogic = _overlaysActorLogic, _searchActorLogic = setup({
  actions: {
    "change searchValue": assign({
      searchValue: ({ event, context: context2 }) => (assertEvent(event, ["change.search", "open"]), event.search ?? context2.searchValue)
    }),
    "reset pickViewFor": assign({
      pickViewFor: () => null
    })
  }
}).createMachine({
  id: "search",
  context: {
    openedWithSearch: null,
    searchValue: "",
    pickViewFor: null
  },
  initial: "inactive",
  on: {
    close: {
      target: ".inactive",
      actions: "reset pickViewFor"
    }
  },
  states: {
    inactive: {
      on: {
        open: {
          target: "opened",
          actions: [
            assign({
              openedWithSearch: ({ event }) => event.search ?? null,
              searchValue: ({ event, context: context2 }) => event.search ?? context2.searchValue
            })
          ]
        }
      }
    },
    opened: {
      on: {
        open: {
          actions: "change searchValue"
        },
        "change.search": {
          actions: "change searchValue"
        },
        "pickview.open": {
          target: "pickView",
          actions: assign({
            pickViewFor: ({ event }) => event.elementFqn
          })
        }
      }
    },
    pickView: {
      on: {
        "pickview.close": {
          target: "opened",
          actions: "reset pickViewFor"
        }
      }
    }
  }
}), searchActorLogic = _searchActorLogic, hotkeyActorLogic = fromCallback(({ sendBack }) => {
  const escHandler = getHotkeyHandler([
    ["Escape", (event) => {
      event.stopPropagation(), sendBack({ type: "key.esc" });
    }, {
      preventDefault: !0
    }]
  ]), arrowshandler = getHotkeyHandler([
    ["ArrowLeft", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.left" });
    }, {
      preventDefault: !0
    }],
    ["ArrowUp", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.up" });
    }, {
      preventDefault: !0
    }],
    ["ArrowRight", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.right" });
    }, {
      preventDefault: !0
    }],
    ["ArrowDown", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.down" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", escHandler), document.body.addEventListener("keydown", arrowshandler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", escHandler), document.body.removeEventListener("keydown", arrowshandler, { capture: !0 });
  };
}), mediaPrintActorLogic = fromCallback(({ sendBack }) => {
  const beforePrint = () => {
    sendBack({ type: "media.print.on" });
  }, afterPrint = () => {
    sendBack({ type: "media.print.off" });
  };
  return window.addEventListener("beforeprint", beforePrint), window.addEventListener("afterprint", afterPrint), () => {
    window.removeEventListener("beforeprint", beforePrint), window.removeEventListener("afterprint", afterPrint);
  };
}), deriveToggledFeatures = (context2) => {
  let toggledFeatures = context2.toggledFeatures;
  const hasActiveWalkthrough = e$1(context2.activeWalkthrough), enableCompareWithLatest = context2.features.enableCompareWithLatest && (toggledFeatures.enableCompareWithLatest ?? !1) && e$1(context2.view._layout) && !hasActiveWalkthrough, enableReadOnly = context2.features.enableReadOnly || (toggledFeatures.enableReadOnly ?? !1) || hasActiveWalkthrough || context2.dynamicViewVariant === "sequence" && context2.view._type === "dynamic" || enableCompareWithLatest && context2.view._layout === "auto";
  return {
    enableCompareWithLatest,
    enableReadOnly
  };
}, isReadOnly = (context2) => deriveToggledFeatures(context2).enableReadOnly, machine$1 = setup({
  actors: {
    hotkeyActorLogic,
    overlaysActorLogic,
    searchActorLogic,
    mediaPrintActorLogic,
    editorActor: editorActorLogic
  },
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow,
    "enabled: Editor": ({ context: context2 }) => context2.features.enableEditor,
    "enabled: FitView": ({ context: context2 }) => context2.features.enableFitView,
    "enabled: FocusMode": ({ context: context2 }) => context2.features.enableFocusMode && isReadOnly(context2),
    "enabled: Readonly": ({ context: context2 }) => isReadOnly(context2),
    "enabled: RelationshipDetails": ({ context: context2 }) => context2.features.enableRelationshipDetails,
    "enabled: Search": ({ context: context2 }) => context2.features.enableSearch,
    "enabled: ElementDetails": ({ context: context2 }) => context2.features.enableElementDetails,
    "enabled: OpenSource": ({ context: context2 }) => context2.features.enableVscode,
    "enabled: DynamicViewWalkthrough": ({ context: context2 }) => context2.features.enableDynamicViewWalkthrough,
    "focus.node: autoUnfocus": ({ event }) => (assertEvent(event, "focus.node"), event.autoUnfocus === !0),
    "enabled: Overlays": ({ context: context2 }) => context2.features.enableElementDetails || context2.features.enableRelationshipBrowser || context2.features.enableRelationshipDetails,
    "not readonly": ({ context: context2 }) => !isReadOnly(context2),
    "is dynamic view": ({ context: context2 }) => context2.view._type === "dynamic",
    "is same view": ({ context: context2, event }) => {
      if (assertEvent(event, ["update.view", "navigate.to"]), event.type === "update.view")
        return context2.view.id === event.view.id;
      if (event.type === "navigate.to")
        return context2.view.id === event.viewId;
      nonexhaustive(event.type);
    },
    "is another view": ({ context: context2, event }) => {
      if (assertEvent(event, ["update.view", "navigate.to"]), event.type === "update.view")
        return context2.view.id !== event.view.id;
      if (event.type === "navigate.to")
        return context2.view.id !== event.viewId;
      nonexhaustive(event.type);
    },
    "click: node has modelFqn": ({ event }) => (assertEvent(event, "xyflow.nodeClick"), "modelFqn" in event.node.data),
    "click: selected node": ({ event }) => (assertEvent(event, "xyflow.nodeClick"), event.node.selected === !0),
    "click: same node": ({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), context2.lastClickedNode?.id === event.node.id),
    "click: focused node": ({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), context2.focusedNode === event.node.id),
    "click: node has connections": ({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), context2.xyedges.some((e2) => e2.source === event.node.id || e2.target === event.node.id)),
    "click: selected edge": ({ event }) => (assertEvent(event, ["xyflow.edgeClick", "xyflow.edgeDoubleClick"]), event.edge.selected === !0 || event.edge.data.active === !0)
  }
}), targetState = {
  idle: "#idle",
  focused: "#focused",
  walkthrough: "#walkthrough",
  printing: "#printing",
  navigating: "#navigating"
};
const __iconNode$m = [["path", { d: "M3 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M9 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M13 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]], IconLockOpen2 = createReactComponent("outline", "lock-open-2", "LockOpen2", __iconNode$m);
const __iconNode$l = [["path", { d: "M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z", key: "svg-0" }], ["path", { d: "M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M8 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]], IconLock = createReactComponent("outline", "lock", "Lock", __iconNode$l), selector$3 = (ctx) => {
  const comparingLatest = deriveToggledFeatures(ctx).enableCompareWithLatest && !!ctx.view.drifts && ctx.view._layout === "auto", sequenceLayoutActive = ctx.view._type === "dynamic" && ctx.dynamicViewVariant === "sequence", noActiveWalkthrough = !e$1(ctx.activeWalkthrough);
  return {
    visible: ctx.features.enableEditor && noActiveWalkthrough,
    disabled: comparingLatest || sequenceLayoutActive,
    isReadOnly: ctx.toggledFeatures.enableReadOnly ?? !1
  };
}, ToggleReadonly$1 = () => {
  const { visible: visible2, disabled, isReadOnly: isReadOnly2 } = useDiagramContext(selector$3), diagram = useDiagram();
  return /* @__PURE__ */ jsx(AnimatePresence, { mode: "popLayout", children: visible2 && /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      component: MotionButton,
      layout: "position",
      layoutDependency: isReadOnly2,
      disabled,
      onClick: (e2) => {
        e2.stopPropagation(), !disabled && diagram.toggleFeature("ReadOnly");
      },
      initial: { opacity: 0, scale: 0.6 },
      animate: { opacity: 1, scale: disabled ? 0.95 : 1 },
      exit: { opacity: 0, scale: 0.6 },
      whileTap: {
        translateY: 1
      },
      className: cx(
        "group",
        hstack({
          gap: "0.5",
          paddingInline: "xxs",
          paddingBlock: "xxs",
          userSelect: "none",
          layerStyle: "likec4.panel.action",
          backgroundColor: {
            base: "none",
            _notDisabled: {
              _hover: "likec4.panel.action.bg.hover"
            }
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsx(IconLockOpen2, { size: 14, stroke: 2, style: { display: isReadOnly2 ? "none" : void 0 } }),
        /* @__PURE__ */ jsx(IconLock, { size: 14, stroke: 2, style: { display: isReadOnly2 ? void 0 : "none" } }),
        /* @__PURE__ */ jsx(
          MotionDiv,
          {
            className: css({
              fontSize: "11px",
              fontWeight: 600,
              lineHeight: 1,
              opacity: 0.8
            }),
            style: {
              display: isReadOnly2 ? "block" : "none"
            },
            children: "Edit"
          }
        )
      ]
    }
  ) });
};
const __iconNode$k = [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]], IconPlayerPlayFilled = createReactComponent("filled", "player-play-filled", "PlayerPlayFilled", __iconNode$k), TriggerWalkthroughButton = forwardRef((props, ref) => /* @__PURE__ */ jsx(
  Button,
  {
    variant: "filled",
    size: "xs",
    fw: "500",
    ...props,
    ref,
    component: MotionButton,
    whileTap: {
      scale: 0.95
    },
    layout: "position",
    layoutId: "trigger-dynamic-walkthrough",
    className: css({
      flexShrink: 0
    })
  }
));
function StartWalkthroughButton() {
  const { enableReadOnly, enableCompareWithLatest } = useEnabledFeatures(), diagram = useDiagram(), actor = useNavigationActor();
  let tooltipLabel = "Start Dynamic View Walkthrough";
  switch (!0) {
    case !enableReadOnly:
      tooltipLabel = "Walkthrough not available in Edit mode";
      break;
    case enableCompareWithLatest:
      tooltipLabel = "Walkthrough not available when Compare is active";
      break;
  }
  return /* @__PURE__ */ jsx(Tooltip$2, { label: tooltipLabel, children: /* @__PURE__ */ jsx(
    TriggerWalkthroughButton,
    {
      onClick: (e2) => {
        e2.stopPropagation(), actor.closeDropdown(), diagram.startWalkthrough();
      },
      initial: { opacity: 0, scale: 0.6, translateX: -10 },
      animate: { opacity: 1, scale: 1, translateX: 0 },
      exit: { opacity: 0, translateX: -20 },
      size: "compact-xs",
      h: 26,
      disabled: !enableReadOnly || enableCompareWithLatest,
      classNames: {
        label: css({
          display: {
            base: "none",
            "@/md": "inherit"
          }
        }),
        section: css({
          marginInlineStart: {
            base: "0",
            "@/md": "2"
          }
        })
      },
      rightSection: /* @__PURE__ */ jsx(IconPlayerPlayFilled, { size: 10 }),
      children: "Start"
    }
  ) });
}
const DynamicViewModeSwitcher = forwardRef(({ value, onChange }, ref) => /* @__PURE__ */ jsx(MotionDiv, { ref, layout: "position", children: /* @__PURE__ */ jsx(
  SegmentedControl,
  {
    size: "xs",
    value,
    component: MotionDiv,
    onChange: (variant) => {
      invariant$2(variant === "diagram" || variant === "sequence", "Invalid dynamic view variant"), onChange(variant);
    },
    classNames: {
      label: css({
        fontSize: "xxs"
      })
    },
    data: [
      {
        value: "diagram",
        label: "Diagram"
      },
      {
        value: "sequence",
        label: "Sequence"
      }
    ]
  }
) }));
function DynamicViewControls() {
  const dynamicViewVariant = useDiagramContext((c) => c.dynamicViewVariant), diagram = useDiagram();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    /* @__PURE__ */ jsx(
      DynamicViewModeSwitcher,
      {
        value: dynamicViewVariant,
        onChange: (mode) => {
          diagram.switchDynamicViewVariant(mode);
        }
      }
    ),
    /* @__PURE__ */ jsx(StartWalkthroughButton, {}, "trigger-dynamic-walkthrough")
  ] });
}
const SearchControl = memo$3(() => {
  const { enableSearch, enableCompareWithLatest } = useEnabledFeatures(), diagram = useDiagram(), isMac2 = isMacOs();
  return /* @__PURE__ */ jsx(AnimatePresence, { children: enableSearch && !enableCompareWithLatest && /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      component: MotionButton,
      layout: "position",
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openSearch();
      },
      whileTap: {
        scale: 0.95,
        translateY: 1
      },
      className: cx(
        "group",
        hstack({
          gap: "xxs",
          paddingInline: "sm",
          paddingBlock: "xxs",
          userSelect: "none",
          layerStyle: "likec4.panel.action.filled",
          display: {
            base: "none",
            "@/md": "flex"
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsx(IconSearch, { size: 14, stroke: 2.5 }),
        /* @__PURE__ */ jsx(
          Box,
          {
            css: {
              fontSize: "11px",
              fontWeight: 600,
              lineHeight: 1,
              opacity: 0.8,
              whiteSpace: "nowrap"
            },
            children: isMac2 ? " + K" : "Ctrl + K"
          }
        )
      ]
    }
  ) });
});
SearchControl.displayName = "SearchControl";
const selectCompareLayoutState = ({ context: context2 }) => {
  const drifts = context2.view.drifts ?? null;
  if (!context2.features.enableCompareWithLatest || !drifts || drifts.length === 0)
    return {
      hasEditor: !1,
      isEnabled: !1,
      isEditable: !1,
      isActive: !1,
      drifts: [],
      canApplyLatest: !1,
      layout: context2.view._layout ?? "auto"
    };
  const {
    enableCompareWithLatest,
    enableReadOnly
  } = deriveToggledFeatures(context2);
  return {
    hasEditor: context2.features.enableEditor,
    isEnabled: !0,
    isEditable: !enableReadOnly,
    isActive: enableCompareWithLatest === !0,
    drifts,
    canApplyLatest: !drifts.includes("type-changed"),
    layout: context2.view._layout ?? "auto"
  };
};
function useDiagramCompareLayout() {
  const actorRef = useDiagramActorRef(), state = useSelector(actorRef, selectCompareLayoutState, shallowEqual$1), switchLayout = useCallbackRef((layoutType) => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    actorRef.send({ type: "emit.onLayoutTypeChange", layoutType });
  }), toggleCompare = useCallbackRef((force) => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    const nextIsActive = force ? force === "on" : !state.isActive;
    state.isActive && !nextIsActive && state.layout === "auto" && switchLayout("manual"), actorRef.send({
      type: "toggle.feature",
      feature: "CompareWithLatest",
      forceValue: nextIsActive
    });
  }), resetManualLayout = useCallbackRef(() => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    actorRef.send({ type: "layout.resetManualLayout" });
  }), applyLatestToManual2 = useCallbackRef(() => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    nonNullable(actorRef.system?.get("editor"), "editor actor not found").send({ type: "applyLatestToManual" }), state.isActive && actorRef.send({
      type: "toggle.feature",
      feature: "CompareWithLatest",
      forceValue: !1
    });
  });
  return [state, { toggleCompare, switchLayout, resetManualLayout, applyLatestToManual: applyLatestToManual2 }];
}
const __iconNode$j = [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]], IconAlertTriangle = createReactComponent("outline", "alert-triangle", "AlertTriangle", __iconNode$j), LayoutWarning = memo$3(() => {
  const [ctx, { toggleCompare }] = useDiagramCompareLayout(), portalProps = useMantinePortalProps(), { drifts, isActive, isEnabled } = ctx;
  return /* @__PURE__ */ jsx(AnimatePresence, { propagate: !0, children: isEnabled && !isActive && /* @__PURE__ */ jsxs(
    HoverCard,
    {
      position: "bottom-start",
      openDelay: 600,
      closeDelay: 200,
      floatingStrategy: "absolute",
      offset: {
        mainAxis: 4,
        crossAxis: -22
      },
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(HoverCardTarget, { children: /* @__PURE__ */ jsx(
          UnstyledButton,
          {
            component: MotionButton,
            layout: "position",
            onClick: (e2) => {
              e2.stopPropagation(), toggleCompare();
            },
            whileTap: {
              scale: 0.95,
              translateY: 1
            },
            className: cx(
              "group",
              navigationPanelActionIcon({
                variant: "filled",
                type: "warning"
              }),
              hstack({
                gap: "xxs",
                padding: "1.5",
                rounded: "sm",
                userSelect: "none",
                cursor: "pointer",
                fontSize: "xs",
                fontWeight: 600
              })
            ),
            children: isActive ? /* @__PURE__ */ jsx(Fragment, { children: "Stop Compare" }) : /* @__PURE__ */ jsx(IconAlertTriangle, { size: 18 })
          }
        ) }),
        /* @__PURE__ */ jsx(HoverCardDropdown, { p: "0", children: /* @__PURE__ */ jsxs(
          Notification,
          {
            color: "orange",
            withBorder: !1,
            withCloseButton: !1,
            title: "View is out of sync",
            children: [
              /* @__PURE__ */ jsx(Text, { mt: 2, size: "sm", lh: "xs", children: "Model has changed since this view was last updated." }),
              /* @__PURE__ */ jsxs(Text, { mt: 4, size: "sm", lh: "xs", children: [
                "Detected changes:",
                drifts.map((drift) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
                  /* @__PURE__ */ jsx("br", {}),
                  /* @__PURE__ */ jsxs("span", { children: [
                    "- ",
                    drift
                  ] })
                ] }, drift))
              ] }),
              /* @__PURE__ */ jsx(
                Button,
                {
                  mt: "xs",
                  size: "compact-sm",
                  variant: "default",
                  onClick: (e2) => {
                    e2.stopPropagation(), toggleCompare();
                  },
                  children: "Compare with current state"
                }
              )
            ]
          }
        ) })
      ]
    }
  ) });
});
LayoutWarning.displayName = "ManualLayoutWarning";
const selectBreadcrumbs = ({ context: context2 }) => {
  const view = context2.view, folder = context2.viewModel?.folder;
  return {
    folders: !folder || folder.isRoot ? [] : folder.breadcrumbs.map((s2) => ({
      folderPath: s2.path,
      title: s2.title
    })),
    viewId: view.id,
    viewTitle: context2.viewModel?.title ?? (view.title && extractViewTitleFromPath(view.title)) ?? "Untitled View",
    isDynamicView: (context2.viewModel?._type ?? view._type) === "dynamic"
  };
}, NavigationPanelControls = memo$3(() => {
  const actor = useNavigationActor(), {
    enableNavigationButtons,
    enableDynamicViewWalkthrough
  } = useEnabledFeatures(), {
    folders,
    viewTitle,
    isDynamicView
  } = useSelector(actor.actorRef, selectBreadcrumbs, deepEqual$1), folderBreadcrumbs = folders.flatMap(({ folderPath, title: title2 }, i2) => [
    /* @__PURE__ */ jsx(
      UnstyledButton,
      {
        component: MotionButton,
        className: cx(
          breadcrumbTitle({ dimmed: !0, truncate: !0 }),
          "mantine-active",
          css({
            userSelect: "none",
            maxWidth: "200px",
            display: {
              base: "none",
              "@/md": "block"
            }
          })
        ),
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        title: title2,
        onMouseEnter: () => actor.send({ type: "breadcrumbs.mouseEnter.folder", folderPath }),
        onMouseLeave: () => actor.send({ type: "breadcrumbs.mouseLeave.folder", folderPath }),
        onClick: (e2) => {
          e2.stopPropagation(), actor.send({ type: "breadcrumbs.click.folder", folderPath });
        },
        children: title2
      },
      folderPath
    ),
    /* @__PURE__ */ jsx(BreadcrumbsSeparator, {}, `separator-${i2}`)
  ]), viewBreadcrumb = /* @__PURE__ */ jsx(
    UnstyledButton,
    {
      component: MotionButton,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      className: cx(
        "mantine-active",
        breadcrumbTitle({ truncate: !0 }),
        css({
          userSelect: "none"
        })
      ),
      title: viewTitle,
      onMouseEnter: () => actor.send({ type: "breadcrumbs.mouseEnter.viewtitle" }),
      onMouseLeave: () => actor.send({ type: "breadcrumbs.mouseLeave.viewtitle" }),
      onClick: (e2) => {
        e2.stopPropagation(), actor.send({ type: "breadcrumbs.click.viewtitle" });
      },
      children: viewTitle
    },
    "view-title"
  );
  return /* @__PURE__ */ jsxs(AnimatePresence, { propagate: !0, mode: "popLayout", children: [
    /* @__PURE__ */ jsx(LogoButton$1, {}, "logo-button"),
    enableNavigationButtons && /* @__PURE__ */ jsx(NavigationButtons, {}, "nav-buttons"),
    /* @__PURE__ */ jsxs(
      MotionDiv,
      {
        layout: "position",
        className: hstack({
          gap: "1",
          flexShrink: 1,
          flexGrow: 1,
          overflow: "hidden"
        }),
        children: [
          folderBreadcrumbs,
          viewBreadcrumb
        ]
      },
      "breadcrumbs"
    ),
    /* @__PURE__ */ jsxs(
      MotionDiv,
      {
        layout: "position",
        className: hstack({
          gap: "0.5",
          flexGrow: 0,
          _empty: {
            display: "none"
          }
        }),
        children: [
          /* @__PURE__ */ jsx(DetailsControls, { onOpen: () => actor.closeDropdown() }),
          /* @__PURE__ */ jsx(OpenSource, {}),
          /* @__PURE__ */ jsx(ToggleReadonly$1, {})
        ]
      },
      "actions"
    ),
    enableDynamicViewWalkthrough && isDynamicView && /* @__PURE__ */ jsx(DynamicViewControls, {}, "dynamic-view-controls"),
    /* @__PURE__ */ jsx(SearchControl, {}, "search-control"),
    /* @__PURE__ */ jsx(LayoutWarning, {}, "outdated-manual-layout-warning")
  ] });
});
NavigationPanelControls.displayName = "NavigationPanelControls";
const NavigationLink = forwardRef(({ className, truncateLabel = !0, ...others }, ref) => /* @__PURE__ */ jsx(
  NavLink,
  {
    ...others,
    component: "button",
    classNames: navigationLink({
      truncateLabel
    }),
    className: cx(
      "group",
      "mantine-active",
      className
    ),
    ref
  }
));
NavigationLink.displayName = "NavigationLink";
const LikeC4ProjectsContext = createContext(null), emptyProjects = [];
function useLikeC4Projects() {
  const ctx = useContext(LikeC4ProjectsContext);
  return ctx ? ctx.projects : emptyProjects;
}
const emptyOnProjectChange = (id2) => {
  console.warn(`Triggered callback to change project to ${id2}, but no <LikeC4ProjectsProvider/> found`);
};
function useChangeLikeC4Project() {
  const ctx = useContext(LikeC4ProjectsContext);
  return ctx ? ctx.onProjectChange : emptyOnProjectChange;
}
const emptyContext = {
  projects: emptyProjects,
  onProjectChange: emptyOnProjectChange
};
function useLikeC4ProjectsContext() {
  return useContext(LikeC4ProjectsContext) ?? emptyContext;
}
function useHasProjects() {
  const ctx = useContext(LikeC4ProjectsContext);
  return ctx ? ctx.projects.length > 1 : !1;
}
function useLikeC4ProjectId() {
  const ctx = useContext(LikeC4ModelContext);
  if (!ctx)
    throw new Error("No LikeC4ModelProvider found");
  return ctx.projectId;
}
function useLikeC4Project() {
  const projectId = useLikeC4ProjectId(), projectsCtx = useContext(LikeC4ProjectsContext);
  if (!projectsCtx)
    throw new Error("No LikeC4ProjectsProvider found");
  const project = projectsCtx.projects.find((p2) => p2.id === projectId);
  if (!project)
    throw new Error(`Project with id '${projectId}' not found in LikeC4ProjectsProvider`);
  return project;
}
const ProjectsMenu = memo$3((_) => {
  const { projects, onProjectChange } = useLikeC4ProjectsContext(), projectId = useLikeC4ProjectId();
  return projects.length <= 1 ? null : /* @__PURE__ */ jsxs(HStack, { gap: "0.5", alignItems: "baseline", children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        css: {
          fontWeight: "400",
          fontSize: "xxs",
          color: "likec4.panel.text.dimmed",
          userSelect: "none"
        },
        children: "Project"
      }
    ),
    /* @__PURE__ */ jsxs(
      Menu,
      {
        withinPortal: !1,
        shadow: "md",
        position: "bottom-start",
        offset: { mainAxis: 2 },
        children: [
          /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
            Button,
            {
              tabIndex: -1,
              autoFocus: !1,
              variant: "subtle",
              size: "compact-xs",
              color: "gray",
              classNames: {
                root: css({
                  fontWeight: "400",
                  fontSize: "xxs",
                  height: "auto",
                  lineHeight: 1.1,
                  color: {
                    _light: "mantine.colors.gray[9]"
                  }
                }),
                section: css({
                  '&:is([data-position="right"])': {
                    marginInlineStart: "1"
                  }
                })
              },
              rightSection: /* @__PURE__ */ jsx(IconChevronDown, { opacity: 0.5, size: 12, stroke: 1.5 }),
              children: projectId
            }
          ) }),
          /* @__PURE__ */ jsx(MenuDropdown, { children: projects.map(({ id: id2, title: title2 }) => /* @__PURE__ */ jsx(
            MenuItem,
            {
              onClick: (e2) => {
                if (projectId === id2) {
                  e2.stopPropagation();
                  return;
                }
                onProjectChange(id2);
              },
              children: title2 ?? id2
            },
            id2
          )) })
        ]
      }
    )
  ] });
});
const __iconNode$i = [["path", { d: "M10.52 2.614a2.095 2.095 0 0 1 2.835 -.117l.126 .117l7.905 7.905c.777 .777 .816 2.013 .117 2.836l-.117 .126l-7.905 7.905a2.094 2.094 0 0 1 -2.836 .117l-.126 -.117l-7.907 -7.906a2.096 2.096 0 0 1 -.115 -2.835l.117 -.126l7.905 -7.905zm5.969 9.535l.01 -.116l-.003 -.12l-.016 -.114l-.03 -.11l-.044 -.112l-.052 -.098l-.076 -.105l-.07 -.081l-3.5 -3.5l-.095 -.083a1 1 0 0 0 -1.226 0l-.094 .083l-.083 .094a1 1 0 0 0 0 1.226l.083 .094l1.792 1.793h-5.085l-.117 .007a1 1 0 0 0 0 1.986l.117 .007h5.085l-1.792 1.793l-.083 .094a1 1 0 0 0 1.403 1.403l.094 -.083l3.5 -3.5l.097 -.112l.05 -.074l.037 -.067l.05 -.112l.023 -.076l.025 -.117z", key: "svg-0" }]], IconDirectionSignFilled = createReactComponent("filled", "direction-sign-filled", "DirectionSignFilled", __iconNode$i);
const __iconNode$h = [["path", { d: "M8.243 7.34l-6.38 .925l-.113 .023a1 1 0 0 0 -.44 1.684l4.622 4.499l-1.09 6.355l-.013 .11a1 1 0 0 0 1.464 .944l5.706 -3l5.693 3l.1 .046a1 1 0 0 0 1.352 -1.1l-1.091 -6.355l4.624 -4.5l.078 -.085a1 1 0 0 0 -.633 -1.62l-6.38 -.926l-2.852 -5.78a1 1 0 0 0 -1.794 0l-2.853 5.78z", key: "svg-0" }]], IconStarFilled = createReactComponent("filled", "star-filled", "StarFilled", __iconNode$h);
const __iconNode$g = [["path", { d: "M9 3a1 1 0 0 1 .608 .206l.1 .087l2.706 2.707h6.586a3 3 0 0 1 2.995 2.824l.005 .176v8a3 3 0 0 1 -2.824 2.995l-.176 .005h-14a3 3 0 0 1 -2.995 -2.824l-.005 -.176v-11a3 3 0 0 1 2.824 -2.995l.176 -.005h4z", key: "svg-0" }]], IconFolderFilled = createReactComponent("filled", "folder-filled", "FolderFilled", __iconNode$g), scopedKeydownHandler = createScopedKeydownHandler({
  siblingSelector: "[data-likec4-focusable]",
  parentSelector: "[data-likec4-breadcrumbs-dropdown]",
  activateOnFocus: !1,
  loop: !0,
  orientation: "vertical"
});
function hasSearchQuerySelector(s2) {
  return s2.context.searchQuery.trim().length >= 2;
}
const NavigationPanelDropdown = memo$3(() => {
  const actor = useNavigationActor(), hasSearchQuery = useNavigationActorSnapshot(hasSearchQuerySelector);
  useOnDiagramEvent("paneClick", () => {
    actor.closeDropdown();
  }), useOnDiagramEvent("nodeClick", () => {
    actor.closeDropdown();
  }), useOnDiagramEvent("edgeClick", () => {
    actor.closeDropdown();
  });
  const setSearchQuery = useThrottledCallback((value) => {
    actor.send({ type: "searchQuery.change", value });
  }, 250);
  return /* @__PURE__ */ jsxs(
    PopoverDropdown,
    {
      className: cx(
        "nowheel",
        vstack({
          layerStyle: "likec4.dropdown",
          gap: "xs",
          pointerEvents: "all"
        })
      ),
      "data-likec4-breadcrumbs-dropdown": !0,
      onMouseLeave: () => actor.send({ type: "dropdown.mouseLeave" }),
      onMouseEnter: () => actor.send({ type: "dropdown.mouseEnter" }),
      children: [
        /* @__PURE__ */ jsx(ProjectsMenu, {}),
        /* @__PURE__ */ jsx(HStack, { gap: "xs", children: /* @__PURE__ */ jsx(
          SearchInput,
          {
            defaultValue: actor.actorRef.getSnapshot().context.searchQuery,
            onChange: setSearchQuery
          }
        ) }),
        /* @__PURE__ */ jsx(
          ScrollAreaAutosize,
          {
            scrollbars: "x",
            type: "auto",
            offsetScrollbars: "present",
            classNames: {
              root: css({
                maxWidth: [
                  "calc(100vw - 50px)",
                  "calc(100cqw - 50px)"
                ]
              })
            },
            styles: {
              viewport: {
                overscrollBehavior: "none"
              }
            },
            children: hasSearchQuery ? /* @__PURE__ */ jsx(SearchResults, {}) : /* @__PURE__ */ jsx(FolderColumns, {})
          }
        )
      ]
    }
  );
});
NavigationPanelDropdown.displayName = "NavigationPanelDropdown";
function selectSearchQuery(s2) {
  return normalizeViewPath(s2.context.searchQuery);
}
const compare = compareNaturalHierarchically(VIEW_FOLDERS_SEPARATOR), SearchResults = memo$3(() => {
  const likec4model = useLikeC4Model(), actor = useNavigationActor(), searchQuery = useSelector(actor.actorRef, selectSearchQuery), deferredSearchQuery = useDeferredValue(searchQuery), isSearchByPath = deferredSearchQuery.includes(VIEW_FOLDERS_SEPARATOR), highlight = isSearchByPath ? deferredSearchQuery.split(VIEW_FOLDERS_SEPARATOR) : deferredSearchQuery, [found, setFound] = useState([]);
  return useEffect(() => {
    setFound((current2) => {
      const results = t$s(
        likec4model.views(),
        ifilter((v2) => isSearchByPath && v2.$view.title ? normalizeViewPath(v2.$view.title).toLowerCase().includes(deferredSearchQuery) : v2.id.toLowerCase().includes(deferredSearchQuery) || !!v2.title?.toLowerCase().includes(deferredSearchQuery)),
        ifirst(20),
        toArray$1(),
        t$3((a2, b2) => compare(a2.folder.path, b2.folder.path))
      );
      return shallowEqual$1(results, current2) ? current2 : results;
    });
  }, [likec4model, deferredSearchQuery, isSearchByPath]), found.length === 0 ? /* @__PURE__ */ jsx("div", { children: "no results" }) : /* @__PURE__ */ jsx(
    ScrollAreaAutosize,
    {
      scrollbars: "xy",
      offsetScrollbars: !1,
      className: css({
        width: "100%",
        maxWidth: [
          "calc(100vw - 250px)",
          "calc(100cqw - 250px)"
        ],
        maxHeight: [
          "calc(100vh - 200px)",
          "calc(100cqh - 200px)"
        ]
      }),
      children: /* @__PURE__ */ jsx(VStack, { gap: "0.5", children: found.map((v2) => /* @__PURE__ */ jsx(
        FoundedView,
        {
          view: v2,
          highlight,
          onClick: (e2) => {
            e2.stopPropagation(), actor.selectView(v2.id);
          },
          "data-likec4-focusable": !0,
          onKeyDown: scopedKeydownHandler
        },
        v2.id
      )) })
    }
  );
}), foundedViewClass = hstack({
  gap: "xxs",
  rounded: "sm",
  px: "xs",
  py: "xxs",
  _hover: {
    backgroundColor: {
      base: "mantine.colors.gray[1]",
      _dark: "mantine.colors.dark[5]"
    }
  },
  _focus: {
    outline: "none",
    color: "mantine.colors.primary.lightColor!",
    backgroundColor: "mantine.colors.primary.lightHover!"
  }
}), inheritColor = css({
  _groupFocus: {
    color: "[inherit!]",
    transition: "none"
  }
});
function FoundedView({ view, highlight, ...props }) {
  const folder = view.folder, viewIcon = ViewTypeIcon[view.id === "index" ? "index" : view._type], viewLabel = /* @__PURE__ */ jsx(
    Highlight,
    {
      component: "div",
      className: cx(
        inheritColor,
        breadcrumbTitle({ truncate: !0 }),
        css({
          "& > mark": {
            backgroundColor: {
              base: "mantine.colors.yellow[2]/90",
              _dark: "mantine.colors.yellow[5]/80",
              _groupFocus: "[transparent]"
            },
            color: {
              _groupFocus: "[inherit!]"
            }
          }
        })
      ),
      maw: 350,
      highlight,
      children: view.title ?? view.id
    },
    view.id
  ), className = cx(
    props.className,
    "group",
    foundedViewClass
  );
  if (folder.isRoot)
    return /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        ...props,
        className,
        children: [
          viewIcon,
          viewLabel
        ]
      }
    );
  const breadcrumbs = folder.breadcrumbs.map((b2) => /* @__PURE__ */ jsx(
    Highlight,
    {
      component: "div",
      className: cx(
        css({
          _groupHover: {
            color: "mantine.colors.dimmed"
          }
        }),
        inheritColor,
        breadcrumbTitle({ dimmed: !0, truncate: !0 })
      ),
      maw: 170,
      highlight: e$d(highlight) ? highlight : [],
      children: b2.title
    },
    b2.path
  ));
  return breadcrumbs.push(
    /* @__PURE__ */ jsxs(HStack, { gap: "[4px]", children: [
      viewIcon,
      viewLabel
    ] })
  ), /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...props,
      className,
      children: [
        folderIcon,
        /* @__PURE__ */ jsx(Breadcrumbs, { separator: /* @__PURE__ */ jsx(IconChevronRight, { size: 12, stroke: 1.5 }), separatorMargin: 3, children: breadcrumbs })
      ]
    }
  );
}
const btnRightSection = /* @__PURE__ */ jsx(IconChevronRight, { size: 12, stroke: 1.5, className: "mantine-rotate-rtl" }), folderIcon = /* @__PURE__ */ jsx(
  IconFolderFilled,
  {
    size: 16,
    className: css({
      opacity: {
        base: 0.3,
        _groupHover: 0.5,
        _groupActive: 0.5,
        _groupFocus: 0.5
      }
    })
  }
), viewTypeIconCss = css({
  opacity: {
    base: 0.3,
    _dark: 0.5,
    _groupHover: 0.8,
    _groupActive: 0.8,
    _groupFocus: 0.8
  }
}), ViewTypeIcon = {
  index: /* @__PURE__ */ jsx(IconStarFilled, { size: 16, className: viewTypeIconCss }),
  element: /* @__PURE__ */ jsx(
    IconZoomScan,
    {
      size: 18,
      stroke: 2,
      className: viewTypeIconCss
    }
  ),
  deployment: /* @__PURE__ */ jsx(IconStack2, { size: 16, stroke: 1.5, className: viewTypeIconCss }),
  dynamic: /* @__PURE__ */ jsx(IconDirectionSignFilled, { size: 18, className: viewTypeIconCss })
}, ColumnScrollArea = ScrollAreaAutosize.withProps({
  scrollbars: "y",
  className: css({
    maxHeight: [
      "calc(100vh - 160px)",
      "calc(100cqh - 160px)"
    ]
  })
});
function folderColumn(folder, context2) {
  return {
    folderPath: folder.path,
    items: [
      ...folder.folders.map((s2) => ({
        type: "folder",
        folderPath: s2.path,
        title: s2.title,
        selected: context2.selectedFolder.startsWith(s2.path)
      })),
      ...folder.views.map((s2) => ({
        type: "view",
        viewType: s2.id === "index" ? "index" : s2._type,
        viewId: s2.id,
        title: s2.title ?? s2.id,
        description: s2.description.nonEmpty && s2.description.text || null,
        selected: s2.id === context2.viewModel?.id
      }))
    ]
  };
}
const selectColumns = (context2) => {
  const viewModel = context2.viewModel;
  if (!viewModel)
    return [];
  const likec4model = viewModel.$model, columns = [
    folderColumn(likec4model.rootViewFolder, context2)
  ], folder = likec4model.viewFolder(context2.selectedFolder);
  if (!folder.isRoot)
    for (const b2 of folder.breadcrumbs)
      columns.push(folderColumn(b2, context2));
  return columns;
}, FolderColumns = memo$3(() => {
  const columns = useNavigationActorContext(selectColumns, deepEqual$1);
  return /* @__PURE__ */ jsx(HStack, { gap: "xs", alignItems: "stretch", children: columns.flatMap((column, i2) => [
    i2 > 0 && /* @__PURE__ */ jsx(Divider$2, { orientation: "vertical" }, "divider" + i2),
    /* @__PURE__ */ jsx(
      FolderColumn,
      {
        data: column,
        isLast: i2 > 0 && i2 == columns.length - 1
      },
      column.folderPath
    )
  ]) });
});
function FolderColumn({ data, isLast }) {
  const ref = useRef(null), actor = useNavigationActorRef(), onItemClicked = (item) => (e2) => {
    e2.stopPropagation(), item.type === "folder" ? actor.send({ type: "select.folder", folderPath: item.folderPath }) : actor.send({ type: "select.view", viewId: item.viewId });
  };
  return useMountEffect(() => {
    isLast && ref.current && ref.current.scrollIntoView({
      block: "nearest",
      inline: "nearest",
      behavior: "smooth"
    });
  }), /* @__PURE__ */ jsx(Box, { mb: "1", ref, children: /* @__PURE__ */ jsx(ColumnScrollArea, { children: /* @__PURE__ */ jsx(VStack, { gap: "0.5", children: data.items.map((item, i2) => /* @__PURE__ */ jsx(
    FolderColumnItem,
    {
      columnItem: item,
      onClick: onItemClicked(item)
    },
    `${data.folderPath}/${item.type}/${i2}`
  )) }) }) });
}
function FolderColumnItem({ columnItem, ...props }) {
  switch (columnItem.type) {
    case "folder":
      return /* @__PURE__ */ jsx(
        NavigationLink,
        {
          variant: "light",
          active: columnItem.selected,
          label: columnItem.title,
          leftSection: folderIcon,
          rightSection: btnRightSection,
          maw: "300px",
          miw: "200px",
          ...props
        },
        columnItem.folderPath
      );
    case "view":
      return /* @__PURE__ */ jsx(
        NavigationLink,
        {
          variant: "filled",
          active: columnItem.selected,
          label: columnItem.title,
          description: columnItem.description,
          leftSection: ViewTypeIcon[columnItem.viewType],
          maw: "300px",
          miw: "200px",
          ...props
        },
        columnItem.viewId
      );
    default:
      nonexhaustive$1(columnItem);
  }
}
function SearchInput(props) {
  const [_value, handleChange] = useUncontrolled({
    ...props,
    finalValue: ""
  });
  return /* @__PURE__ */ jsx(
    Input,
    {
      size: "xs",
      placeholder: "Search by title or id",
      variant: "unstyled",
      height: rem(26),
      value: _value,
      onKeyDown: scopedKeydownHandler,
      onChange: (e2) => handleChange(e2.currentTarget.value),
      "data-likec4-focusable": !0,
      classNames: {
        wrapper: css({
          flexGrow: 1,
          backgroundColor: {
            base: "mantine.colors.gray[1]",
            _dark: "mantine.colors.dark[5]/80",
            _hover: {
              base: "mantine.colors.gray[2]",
              _dark: "mantine.colors.dark[4]"
            },
            _focus: {
              base: "mantine.colors.gray[2]",
              _dark: "mantine.colors.dark[4]"
            }
          },
          rounded: "sm"
        }),
        input: css({
          _placeholder: {
            color: "mantine.colors.dimmed"
          },
          _focus: {
            outline: "none"
          }
        })
      },
      style: {
        "--input-fz": "var(--mantine-font-size-sm)"
      },
      leftSection: /* @__PURE__ */ jsx(IconSearch, { size: 14 }),
      rightSectionPointerEvents: "all",
      rightSectionWidth: "min-content",
      rightSection: !props.value || e$a(props.value) ? null : /* @__PURE__ */ jsx(
        Button,
        {
          variant: "subtle",
          h: "100%",
          size: "compact-xs",
          color: "gray",
          onClick: (e2) => {
            e2.stopPropagation(), handleChange("");
          },
          children: "clear"
        }
      )
    }
  );
}
const SectionHeader = styled("div", {
  base: {
    fontSize: "xs",
    color: "mantine.colors.dimmed",
    fontWeight: 500,
    userSelect: "none",
    mb: "xxs"
  }
});
function selectWalkthroughNotes(s2) {
  const isActive = e$8(s2.activeWalkthrough), activeStepIndex = isActive ? s2.xyedges.findIndex((e2) => e2.id === s2.activeWalkthrough?.stepId) : -1;
  return {
    isActive,
    isParallel: isActive && e$1(s2.activeWalkthrough?.parallelPrefix),
    hasNext: isActive && activeStepIndex < s2.xyedges.length - 1,
    hasPrevious: isActive && activeStepIndex > 0,
    notes: isActive ? s2.xyedges[activeStepIndex]?.data?.notes ?? null : null
  };
}
const WalkthroughPanel = memo$3(() => {
  const { isActive, notes: _notes } = useDiagramContext(selectWalkthroughNotes), notes = _notes ? RichText$1.from(_notes) : RichText$1.EMPTY;
  return /* @__PURE__ */ jsx(AnimatePresence, { children: isActive && !notes.isEmpty && /* @__PURE__ */ jsx(
    m$1.div,
    {
      layout: "position",
      className: css({
        position: "relative"
      }),
      initial: {
        opacity: 0,
        translateX: -20
      },
      animate: {
        opacity: 1,
        translateX: 0
      },
      exit: {
        opacity: 0,
        translateX: -20
      },
      children: /* @__PURE__ */ jsxs(
        ScrollAreaAutosize,
        {
          className: vstack({
            position: "absolute",
            layerStyle: "likec4.dropdown",
            gap: "sm",
            padding: "md",
            paddingTop: "xxs",
            pointerEvents: "all",
            maxWidth: "calc(100cqw - 32px)",
            minWidth: "calc(100cqw - 50px)",
            maxHeight: "calc(100cqh - 100px)",
            width: "max-content",
            cursor: "default",
            overflow: "auto",
            overscrollBehavior: "contain",
            "@/sm": {
              minWidth: 400,
              maxWidth: 550
            },
            "@/lg": {
              maxWidth: 700
            }
          }),
          type: "scroll",
          children: [
            /* @__PURE__ */ jsx(SectionHeader, { children: "Notes" }),
            /* @__PURE__ */ jsx(
              Markdown,
              {
                value: notes,
                fontSize: "sm",
                emptyText: "No description",
                className: css({
                  userSelect: "all"
                })
              }
            )
          ]
        }
      )
    }
  ) });
});
function CompareActionsMenu({
  disabled = !1,
  onApplyLatestToManual,
  onResetManualLayout
}) {
  return /* @__PURE__ */ jsxs(
    Menu,
    {
      withinPortal: !1,
      floatingStrategy: "absolute",
      shadow: "lg",
      position: "bottom-start",
      offset: { mainAxis: 4 },
      disabled,
      children: [
        /* @__PURE__ */ jsx(Menu.Target, { children: /* @__PURE__ */ jsxs(
          UnstyledButton,
          {
            disabled,
            className: cx(
              "mantine-active",
              hstack({
                gap: "2",
                py: "1.5",
                px: "2",
                lineHeight: "1",
                textStyle: "xs",
                fontWeight: "medium",
                layerStyle: "likec4.panel.action",
                userSelect: "none"
              })
            ),
            children: [
              /* @__PURE__ */ jsx(Box, { children: "Actions" }),
              /* @__PURE__ */ jsx(IconChevronDown, { size: 12, stroke: 2, opacity: 0.7 })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxs(Menu.Dropdown, { children: [
          /* @__PURE__ */ jsxs(
            Menu.Item,
            {
              disabled: !onApplyLatestToManual,
              onClick: onApplyLatestToManual,
              rightSection: onApplyLatestToManual && /* @__PURE__ */ jsx(
                Tooltip$6,
                {
                  onClick: stopPropagation,
                  position: "right-start",
                  label: /* @__PURE__ */ jsxs(Fragment, { children: [
                    "Applies changes from the latest auto-layouted",
                    /* @__PURE__ */ jsx("br", {}),
                    "to saved snapshot, preserving (as possible)",
                    /* @__PURE__ */ jsx("br", {}),
                    "manual adjustments.",
                    /* @__PURE__ */ jsx("br", {}),
                    /* @__PURE__ */ jsx("br", {}),
                    "You can undo this action."
                  ] }),
                  children: /* @__PURE__ */ jsx(IconInfoCircle, { size: 14, stroke: 1.7, opacity: 0.5 })
                }
              ),
              children: [
                "Sync with latest",
                !onApplyLatestToManual && /* @__PURE__ */ jsx(Box, { textStyle: "xs", children: "view type is changed" })
              ]
            }
          ),
          /* @__PURE__ */ jsx(Menu.Item, { onClick: onResetManualLayout, children: "Remove manual layout" })
        ] })
      ]
    }
  );
}
function LayoutTypeSwitcher({
  value,
  onChange
}) {
  const data = useMemo(() => [
    { value: "manual", label: "Saved manual" },
    { value: "auto", label: "Latest auto" }
  ], []);
  return /* @__PURE__ */ jsx(MotionDiv, { layout: "position", children: /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      color: value === "manual" ? "orange" : "green",
      value,
      component: MotionDiv,
      onChange: (layout2) => {
        invariant$2(layout2 === "manual" || layout2 === "auto", "Invalid layout type"), onChange(layout2);
      },
      classNames: {
        label: css({
          fontSize: "xxs",
          fontWeight: "medium"
        })
      },
      data
    }
  ) });
}
const Divider = Divider$2.withProps({
  mx: 2,
  size: "xs",
  orientation: "vertical"
});
function ComparePanelControls() {
  const [ctx, { toggleCompare, switchLayout, resetManualLayout, applyLatestToManual: applyLatestToManual2 }] = useDiagramCompareLayout();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        css: {
          textStyle: "xs",
          color: "likec4.panel.text",
          userSelect: "none"
        },
        children: "Compare"
      }
    ),
    /* @__PURE__ */ jsx(
      LayoutTypeSwitcher,
      {
        value: ctx.layout,
        onChange: switchLayout
      }
    ),
    ctx.hasEditor && /* @__PURE__ */ jsxs(HStack, { gap: "1", children: [
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsx(
        CompareActionsMenu,
        {
          disabled: ctx.layout === "auto",
          onResetManualLayout: resetManualLayout,
          onApplyLatestToManual: ctx.canApplyLatest ? applyLatestToManual2 : void 0
        }
      ),
      /* @__PURE__ */ jsx(Divider, {})
    ] }),
    /* @__PURE__ */ jsx(
      PanelActionIcon,
      {
        size: "sm",
        onClick: (e2) => {
          e2.stopPropagation(), toggleCompare();
        },
        children: /* @__PURE__ */ jsx(IconX, {})
      }
    )
  ] });
}
const ComparePanel = memo$3(() => {
  const { enableCompareWithLatest } = useEnabledFeatures();
  return /* @__PURE__ */ jsx(AnimatePresence, { children: enableCompareWithLatest && /* @__PURE__ */ jsx(
    MotionDiv,
    {
      layout: "position",
      className: hstack({
        gap: "2",
        layerStyle: "likec4.panel",
        position: "relative",
        px: "2",
        py: "1",
        pl: "3",
        pointerEvents: "all"
      }),
      initial: {
        opacity: 0,
        translateX: -20
      },
      animate: {
        opacity: 1,
        translateX: 0
      },
      exit: {
        opacity: 0,
        translateX: -20
      },
      children: /* @__PURE__ */ jsx(ComparePanelControls, {})
    }
  ) });
});
ComparePanel.displayName = "ComparePanel";
const Tooltip$1 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  position: "right"
});
const __iconNode$f = [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-1" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-2" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-3" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-4" }]], IconFocusCentered = createReactComponent("outline", "focus-centered", "FocusCentered", __iconNode$f), CenterCamera = () => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip$1, { label: "Center camera", children: /* @__PURE__ */ jsx(PanelActionIcon, { onClick: () => diagram.fitDiagram(), children: /* @__PURE__ */ jsx(IconFocusCentered, {}) }) });
};
css({
  gap: "xxs",
  _empty: {
    display: "none"
  }
});
css({
  top: "md",
  left: "md",
  margin: "0",
  pointerEvents: "none",
  "& :where(button, .action-icon, [role='dialog'])": {
    pointerEvents: "all"
  },
  "& .action-icon": {
    "--ai-size": "2rem"
  },
  "& .tabler-icon": {
    width: "65%",
    height: "65%"
  },
  _reduceGraphics: {
    "& .action-icon": {
      "--ai-radius": "0px"
    }
  }
});
css({
  shadow: {
    base: "md",
    _whenPanning: "none"
  }
});
css({
  "& .tabler-icon": {
    width: "65%",
    height: "65%"
  }
});
const autolayoutButton = css({
  flex: "1 1 40%",
  textAlign: "center",
  fontWeight: 500,
  padding: "[4px 6px]",
  fontSize: "11px",
  zIndex: 1
}), autolayoutIndicator = css({
  background: "mantine.colors.gray[2]",
  borderRadius: "sm",
  border: "1px solid",
  borderColor: "mantine.colors.gray[4]",
  _dark: {
    background: "mantine.colors.dark[5]",
    borderColor: "mantine.colors.dark[4]"
  }
}), spacingSliderBody = css({
  position: "relative",
  borderRadius: "sm",
  background: "mantine.colors.gray[3]",
  boxShadow: "inset 1px 1px 3px 0px #00000024",
  _dark: {
    background: "mantine.colors.dark[7]"
  }
}), spacingSliderThumb = css({
  position: "absolute",
  width: 8,
  height: 8,
  border: "2px solid",
  borderColor: "mantine.colors.gray[5]",
  borderRadius: 3,
  transform: "translate(-50%, -50%)"
});
const __iconNode$e = [["path", { d: "M5 4h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-0" }], ["path", { d: "M5 16h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-1" }], ["path", { d: "M15 12h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-2" }], ["path", { d: "M15 4h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-3" }]], IconLayoutDashboard = createReactComponent("outline", "layout-dashboard", "LayoutDashboard", __iconNode$e), selector$2 = (state) => ({
  viewId: state.view.id,
  isManualLayout: state.view._layout === "manual",
  autoLayout: state.view.autoLayout
}), ChangeAutoLayoutButton = () => {
  const diagram = useDiagram(), [rootRef, setRootRef] = useState(null), [controlsRefs, setControlsRefs] = useState({}), {
    autoLayout,
    viewId,
    isManualLayout
  } = useDiagramContext(selector$2), { ref, hovered: isSpacingHovered } = useHover$1(), setControlRef = (name) => (node2) => {
    controlsRefs[name] = node2, setControlsRefs(controlsRefs);
  }, setAutoLayout = (direction) => (event) => {
    event.stopPropagation(), diagram.fitDiagram(), diagram.triggerChange({
      op: "change-autolayout",
      layout: {
        ...autoLayout,
        direction
      }
    });
  }, setSpacing = (nodeSep, rankSep) => {
    diagram.fitDiagram(), diagram.triggerChange({
      op: "change-autolayout",
      layout: {
        ...autoLayout,
        nodeSep,
        rankSep
      }
    });
  };
  return isManualLayout ? null : /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip$1, { label: "Change Auto Layout", children: /* @__PURE__ */ jsx(PanelActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutDashboard, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { className: "likec4-top-left-panel", p: 8, pt: 6, opacity: isSpacingHovered ? 0.6 : 1, children: /* @__PURE__ */ jsxs(Box$1, { pos: "relative", ref: setRootRef, children: [
          /* @__PURE__ */ jsx(
            FloatingIndicator,
            {
              target: controlsRefs[autoLayout.direction],
              parent: rootRef,
              className: autolayoutIndicator
            }
          ),
          /* @__PURE__ */ jsx(Box$1, { mb: 10, children: /* @__PURE__ */ jsx(Text, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Auto layout:" }) }),
          /* @__PURE__ */ jsxs(Flex, { gap: 2, wrap: "wrap", justify: "stretch", maw: 160, children: [
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("TB"), onClick: setAutoLayout("TB"), children: "Top-Bottom" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("BT"), onClick: setAutoLayout("BT"), children: "Bottom-Top" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("LR"), onClick: setAutoLayout("LR"), children: "Left-Right" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("RL"), onClick: setAutoLayout("RL"), children: "Right-Left" })
          ] }),
          /* @__PURE__ */ jsx(Box$1, { my: 10, children: /* @__PURE__ */ jsx(Text, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Spacing:" }) }),
          /* @__PURE__ */ jsx(
            SpacingSliders,
            {
              ref,
              isVertical: autoLayout.direction === "TB" || autoLayout.direction === "BT",
              nodeSep: autoLayout.nodeSep,
              rankSep: autoLayout.rankSep,
              onChange: setSpacing
            },
            viewId
          )
        ] }) })
      ]
    }
  );
}, MAX_SPACING = 400, SpacingSliders = forwardRef(({
  isVertical,
  nodeSep,
  rankSep,
  onChange
}, _ref) => {
  isVertical || ([nodeSep, rankSep] = [rankSep, nodeSep]);
  const propagateChange = useDebouncedCallback$1(
    ({ x: x2, y: y2 }) => {
      isVertical || ([x2, y2] = [y2, x2]), onChange(Math.round(x2 * MAX_SPACING), Math.round(y2 * MAX_SPACING));
    },
    [onChange, isVertical],
    250,
    2e3
  ), [value, setValue] = useUncontrolled({
    defaultValue: clampUseMovePosition({
      x: (nodeSep ?? 100) / MAX_SPACING,
      y: (rankSep ?? 120) / MAX_SPACING
    }),
    onChange: propagateChange
  }), { ref } = useMove(setValue);
  let nodeSepValue = Math.round(value.x * MAX_SPACING), rankSepValue = Math.round(value.y * MAX_SPACING);
  isVertical || ([nodeSepValue, rankSepValue] = [rankSepValue, nodeSepValue]);
  const mergedRef = useMergedRef(ref, _ref);
  return /* @__PURE__ */ jsxs(Box$1, { ref: mergedRef, className: spacingSliderBody, pt: "100%", children: [
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: spacingSliderThumb,
        style: {
          left: `${value.x * 100}%`,
          top: `${value.y * 100}%`
        }
      }
    ),
    /* @__PURE__ */ jsx(Box$1, { pos: "absolute", left: 2, bottom: 2, children: /* @__PURE__ */ jsxs(Text, { component: "div", fz: 8, c: "dimmed", fw: 500, children: [
      rankSepValue,
      ", ",
      nodeSepValue
    ] }) })
  ] });
});
const __iconNode$d = [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M10 4l4 16", key: "svg-1" }], ["path", { d: "M12 12l-8 2", key: "svg-2" }]], IconLayoutCollage = createReactComponent("outline", "layout-collage", "LayoutCollage", __iconNode$d);
const __iconNode$c = [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M4 12h8", key: "svg-1" }], ["path", { d: "M12 15h8", key: "svg-2" }], ["path", { d: "M12 9h8", key: "svg-3" }], ["path", { d: "M12 4v16", key: "svg-4" }]], IconLayoutBoardSplit = createReactComponent("outline", "layout-board-split", "LayoutBoardSplit", __iconNode$c);
const __iconNode$b = [["path", { d: "M4 4l0 16", key: "svg-0" }], ["path", { d: "M8 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignLeft = createReactComponent("outline", "layout-align-left", "LayoutAlignLeft", __iconNode$b);
const __iconNode$a = [["path", { d: "M12 4l0 5", key: "svg-0" }], ["path", { d: "M12 15l0 5", key: "svg-1" }], ["path", { d: "M6 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-2" }]], IconLayoutAlignCenter = createReactComponent("outline", "layout-align-center", "LayoutAlignCenter", __iconNode$a);
const __iconNode$9 = [["path", { d: "M20 4l0 16", key: "svg-0" }], ["path", { d: "M4 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignRight = createReactComponent("outline", "layout-align-right", "LayoutAlignRight", __iconNode$9);
const __iconNode$8 = [["path", { d: "M4 4l16 0", key: "svg-0" }], ["path", { d: "M9 8m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignTop = createReactComponent("outline", "layout-align-top", "LayoutAlignTop", __iconNode$8);
const __iconNode$7 = [["path", { d: "M4 12l5 0", key: "svg-0" }], ["path", { d: "M15 12l5 0", key: "svg-1" }], ["path", { d: "M9 6m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }]], IconLayoutAlignMiddle = createReactComponent("outline", "layout-align-middle", "LayoutAlignMiddle", __iconNode$7);
const __iconNode$6 = [["path", { d: "M4 20l16 0", key: "svg-0" }], ["path", { d: "M9 4m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignBottom = createReactComponent("outline", "layout-align-bottom", "LayoutAlignBottom", __iconNode$6);
const __iconNode$5 = [["path", { d: "M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M18 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M12 19h4.5c.71 0 1.372 -.212 1.924 -.576m1.545 -2.459a3.5 3.5 0 0 0 -3.469 -3.965h-.499m-4 0h-3.501a3.5 3.5 0 0 1 -2.477 -5.972m2.477 -1.028h3.5", key: "svg-2" }], ["path", { d: "M3 3l18 18", key: "svg-3" }]], IconRouteOff = createReactComponent("outline", "route-off", "RouteOff", __iconNode$5), Action = ({
  label: label2,
  icon: icon2,
  onClick
}) => /* @__PURE__ */ jsx(Tooltip$1, { label: label2, withinPortal: !1, position: "top", children: /* @__PURE__ */ jsx(
  PanelActionIcon,
  {
    classNames: {
      root: "action-icon",
      icon: css({
        "& > svg": {
          width: "70%",
          height: "70%"
        }
      })
    },
    onClick,
    children: icon2
  }
) }), ManualLayoutToolsButton = memo$3(() => {
  const diagram = useDiagram(), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right",
      offset: {
        mainAxis: 12
      },
      clickOutsideEvents: [
        "pointerdown"
      ],
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip$1, { label: "Manual layouting tools", children: /* @__PURE__ */ jsx(PanelActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutCollage, {}) }) }) }),
        /* @__PURE__ */ jsx(
          PopoverDropdown,
          {
            className: hstack({
              gap: "0.5",
              layerStyle: "likec4.panel",
              padding: "1",
              pointerEvents: "all"
            }),
            children: /* @__PURE__ */ jsxs(TooltipGroup, { children: [
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align in columns",
                  icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Column");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align left",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignLeft, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Left");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align center",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignCenter, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Center");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align right",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignRight, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Right");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align in rows",
                  icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, { style: { transform: "rotate(90deg)" } }),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Row");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align top",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignTop, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Top");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align middle",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignMiddle, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Middle");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align bottom",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignBottom, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Bottom");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Reset all control points",
                  icon: /* @__PURE__ */ jsx(IconRouteOff, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.resetEdgeControlPoints();
                  }
                }
              )
            ] })
          }
        )
      ]
    }
  );
});
ManualLayoutToolsButton.displayName = "ManualLayoutToolsButton";
const ToggleReadonly = () => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip$1, { label: "Switch to Read-only", children: /* @__PURE__ */ jsx(PanelActionIcon, { onClick: () => diagram.toggleFeature("ReadOnly"), children: /* @__PURE__ */ jsx(IconLockOpen2, { size: 14, stroke: 2 }) }) });
};
function EditorPanel() {
  const { enableReadOnly } = useEnabledFeatures();
  return /* @__PURE__ */ jsx(AnimatePresence, { children: !enableReadOnly && /* @__PURE__ */ jsx(
    MotionDiv,
    {
      layout: "position",
      className: vstack({
        gap: "xs",
        layerStyle: "likec4.panel",
        position: "relative",
        cursor: "pointer",
        padding: "xxs",
        pointerEvents: "all"
      }),
      initial: {
        opacity: 0,
        translateX: -20
      },
      animate: {
        opacity: 1,
        translateX: 0
      },
      exit: {
        opacity: 0,
        translateX: -20
      },
      children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 600, closeDelay: 120, children: [
        /* @__PURE__ */ jsx(ChangeAutoLayoutButton, {}),
        /* @__PURE__ */ jsx(ManualLayoutToolsButton, {}),
        /* @__PURE__ */ jsx(CenterCamera, {}),
        /* @__PURE__ */ jsx(ToggleReadonly, {})
      ] })
    }
  ) });
}
const __iconNode$4 = [["path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", key: "svg-0" }]], IconPlayerStopFilled = createReactComponent("filled", "player-stop-filled", "PlayerStopFilled", __iconNode$4);
const __iconNode$3 = [["path", { d: "M19.496 4.136l-12 7a1 1 0 0 0 0 1.728l12 7a1 1 0 0 0 1.504 -.864v-14a1 1 0 0 0 -1.504 -.864z", key: "svg-0" }], ["path", { d: "M4 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]], IconPlayerSkipBackFilled = createReactComponent("filled", "player-skip-back-filled", "PlayerSkipBackFilled", __iconNode$3);
const __iconNode$2 = [["path", { d: "M3 5v14a1 1 0 0 0 1.504 .864l12 -7a1 1 0 0 0 0 -1.728l-12 -7a1 1 0 0 0 -1.504 .864z", key: "svg-0" }], ["path", { d: "M20 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]], IconPlayerSkipForwardFilled = createReactComponent("filled", "player-skip-forward-filled", "PlayerSkipForwardFilled", __iconNode$2), PrevNextButton = Button.withProps({
  // Button is polymorphic, but we dont want it to inherit the motion props
  component: MotionButton,
  layout: "position",
  whileTap: {
    scale: 0.95
  },
  variant: "light",
  size: "xs",
  fw: "500"
}), ParallelFrame = () => {
  const { portalProps } = useMantinePortalProps();
  return /* @__PURE__ */ jsx(Portal, { ...portalProps, children: /* @__PURE__ */ jsx(
    Box,
    {
      css: {
        position: "absolute",
        margin: "0",
        padding: "0",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        border: "2px solid",
        borderColor: "mantine.colors.orange[6]",
        pointerEvents: "none",
        md: {
          borderWidth: 4
        }
      }
    }
  ) });
};
function ActiveWalkthroughControls() {
  const diagram = useDiagram(), {
    isParallel,
    hasNext,
    hasPrevious,
    currentStep,
    totalSteps
  } = useDiagramContext((s2) => {
    const currentStepIndex = s2.xyedges.findIndex((e2) => e2.id === s2.activeWalkthrough?.stepId);
    return {
      isParallel: e$1(s2.activeWalkthrough?.parallelPrefix),
      hasNext: currentStepIndex < s2.xyedges.length - 1,
      hasPrevious: currentStepIndex > 0,
      currentStep: currentStepIndex + 1,
      totalSteps: s2.xyedges.length
    };
  });
  return /* @__PURE__ */ jsxs(AnimatePresence, { propagate: !0, mode: "popLayout", children: [
    /* @__PURE__ */ jsx(
      TriggerWalkthroughButton,
      {
        variant: "light",
        size: "xs",
        color: "orange",
        mr: "sm",
        onClick: (e2) => {
          e2.stopPropagation(), diagram.stopWalkthrough();
        },
        rightSection: /* @__PURE__ */ jsx(IconPlayerStopFilled, { size: 10 }),
        children: "Stop"
      },
      "stop-walkthrough"
    ),
    /* @__PURE__ */ jsx(
      PrevNextButton,
      {
        disabled: !hasPrevious,
        onClick: () => diagram.walkthroughStep("previous"),
        leftSection: /* @__PURE__ */ jsx(IconPlayerSkipBackFilled, { size: 10 }),
        children: "Previous"
      },
      "prev"
    ),
    /* @__PURE__ */ jsxs(
      Badge,
      {
        component: MotionDiv,
        layout: "position",
        size: "md",
        radius: "sm",
        variant: isParallel ? "gradient" : "transparent",
        gradient: { from: "red", to: "orange", deg: 90 },
        rightSection: /* @__PURE__ */ jsx(
          MotionDiv,
          {
            className: css({
              fontSize: "xxs",
              display: isParallel ? "block" : "none"
            }),
            children: "parallel"
          }
        ),
        className: css({
          alignItems: "baseline"
        }),
        children: [
          currentStep,
          " / ",
          totalSteps
        ]
      },
      "step-badge"
    ),
    /* @__PURE__ */ jsx(
      PrevNextButton,
      {
        disabled: !hasNext,
        onClick: () => diagram.walkthroughStep("next"),
        rightSection: /* @__PURE__ */ jsx(IconPlayerSkipForwardFilled, { size: 10 }),
        children: "Next"
      },
      "next"
    ),
    isParallel && /* @__PURE__ */ jsx(ParallelFrame, {}, "parallel-frame")
  ] });
}
const NavigationPanel$1 = memo$3(() => {
  const diagram = useDiagram(), view = useCurrentView(), viewModel = useOptionalCurrentViewModel(), actorRef = useActorRef(
    navigationPanelActorLogic,
    {
      input: {
        view,
        viewModel
      }
    }
  );
  return useEffect(() => {
    const subscription = actorRef.on("navigateTo", (event) => {
      diagram.navigateTo(event.viewId);
    });
    return () => subscription.unsubscribe();
  }, [actorRef, diagram]), useEffect(() => {
    actorRef.send({ type: "update.inputs", inputs: { viewModel, view } });
  }, [viewModel, view]), /* @__PURE__ */ jsx(
    VStack,
    {
      css: {
        alignItems: "flex-start",
        pointerEvents: "none",
        position: "absolute",
        top: "0",
        left: "0",
        margin: "0",
        width: "100%",
        gap: "xxs",
        maxWidth: [
          "calc(100vw)",
          "calc(100cqw)"
        ],
        "@/sm": {
          margin: "xs",
          gap: "xs",
          width: "max-content",
          maxWidth: [
            "calc(100vw - 2 * {spacing.md})",
            "calc(100cqw - 2 * {spacing.md})"
          ]
        },
        _print: {
          display: "none"
        }
      },
      children: /* @__PURE__ */ jsxs(NavigationPanelActorContextProvider, { value: actorRef, children: [
        /* @__PURE__ */ jsx(NavigationPanelImpl, { actor: actorRef }),
        /* @__PURE__ */ jsx(ComparePanel, {}),
        /* @__PURE__ */ jsx(WalkthroughPanel, {}),
        /* @__PURE__ */ jsx(EditorPanel, {})
      ] })
    }
  );
});
NavigationPanel$1.displayName = "NavigationPanel";
const NavigationPanelImpl = ({ actor }) => {
  const opened = useSelector(actor, (s2) => s2.hasTag("active")), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      offset: {
        mainAxis: 4
      },
      opened,
      position: "bottom-start",
      trapFocus: opened,
      ...portalProps,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onDismiss: () => actor.send({ type: "dropdown.dismiss" }),
      children: [
        /* @__PURE__ */ jsx(NavigationPanelPopoverTarget, { actor }),
        opened && /* @__PURE__ */ jsx(NavigationPanelDropdown, {})
      ]
    }
  );
}, NavigationPanelPopoverTarget = ({ actor }) => {
  const isActiveWalkthrough = useDiagramContext((c) => c.activeWalkthrough !== null);
  return /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
    MotionDiv,
    {
      layout: !0,
      layoutDependency: isActiveWalkthrough,
      className: hstack({
        layerStyle: "likec4.panel",
        position: "relative",
        gap: "xs",
        cursor: "pointer",
        pointerEvents: "all",
        width: "100%"
      }),
      onMouseLeave: () => actor.send({ type: "breadcrumbs.mouseLeave" }),
      children: /* @__PURE__ */ jsx(AnimatePresence, { children: isActiveWalkthrough ? /* @__PURE__ */ jsx(ActiveWalkthroughControls, {}) : /* @__PURE__ */ jsx(NavigationPanelControls, {}) })
    }
  ) }) });
}, container = css({
  position: "absolute",
  bottom: "0",
  right: "0",
  padding: "2",
  margin: "0",
  width: "min-content",
  height: "min-content",
  _print: {
    display: "none"
  }
}), icon = css({
  "--ai-radius": "0px",
  _noReduceGraphics: {
    "--ai-radius": "{radii.md}"
  }
}), card = css({
  cursor: "default",
  userSelect: "none",
  minWidth: 200,
  maxWidth: "calc(100vw - 20px)",
  backgroundColor: "mantine.colors.body/80",
  // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  sm: {
    minWidth: 300,
    maxWidth: "65vw"
  },
  md: {
    maxWidth: "40vw"
  },
  _dark: {
    backgroundColor: "mantine.colors.dark[6]/80"
  }
}), tabPanel = css({
  padding: "xxs"
}), elementNotation = css({
  backgroundColor: "transparent",
  transition: "all 100ms ease-in",
  // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // vars: {
  //   // [stokeFillMix]: `color-mix(in oklab, ${vars.element.stroke} 90%, ${vars.element.fill})`
  // },
  _hover: {
    transition: "all 120ms ease-out",
    // backgroundColor:
    backgroundColor: "mantine.colors.primary[2]/50"
  },
  _dark: {
    _hover: {
      backgroundColor: "mantine.colors.dark[3]/40"
    }
  }
});
css({
  fill: "var(--likec4-palette-fill)",
  stroke: "var(--likec4-palette-stroke)",
  strokeWidth: 1,
  overflow: "visible",
  width: "100%",
  height: "auto",
  filter: `
    drop-shadow(0 2px 3px rgb(0 0 0 / 22%))
    drop-shadow(0 1px 8px rgb(0 0 0 / 10%))
  `
});
const shapeBadge = css({
  fontWeight: 500,
  letterSpacing: "0.2px",
  paddingTop: "0",
  paddingBottom: "0",
  textTransform: "lowercase",
  transition: "all 150ms ease-in-out",
  cursor: "pointer",
  "--badge-radius": "2px",
  "--badge-fz": "9.5px",
  "--badge-padding-x": "3px",
  "--badge-height": "13.5px",
  "--badge-lh": "1",
  "--badge-bg": "var(--likec4-palette-fill)",
  "--badge-color": "var(--likec4-palette-hiContrast)"
});
const __iconNode$1 = [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 16v.01", key: "svg-1" }], ["path", { d: "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483", key: "svg-2" }]], IconHelpCircle = createReactComponent("outline", "help-circle", "HelpCircle", __iconNode$1);
const __iconNode = [["path", { d: "M7 7l10 10", key: "svg-0" }], ["path", { d: "M17 8l0 9l-9 0", key: "svg-1" }]], IconArrowDownRight = createReactComponent("outline", "arrow-down-right", "ArrowDownRight", __iconNode), ElementNotation = ({ value }) => {
  const {
    title: title2,
    color: color2 = "primary",
    shape = "rectangle"
  } = value, [onlyKind, setOnlyKind] = useState(null), diagram = useDiagram(), w2 = 300, h2 = 200;
  return /* @__PURE__ */ jsx(
    Card,
    {
      shadow: "none",
      px: "xs",
      py: "sm",
      className: cx(
        elementNotation
      ),
      "data-likec4-color": color2,
      onMouseEnter: () => {
        setOnlyKind(null), diagram.highlightNotation(value);
      },
      onMouseLeave: () => {
        setOnlyKind(null), diagram.unhighlightNotation();
      },
      children: /* @__PURE__ */ jsxs(
        Group,
        {
          gap: "sm",
          align: "stretch",
          wrap: "nowrap",
          children: [
            /* @__PURE__ */ jsx(
              Box$1,
              {
                flex: "0 0 70px",
                style: {
                  position: "relative",
                  width: 70,
                  height: n$v(70 * (h2 / w2), 0)
                },
                children: /* @__PURE__ */ jsx(
                  ElementShape,
                  {
                    data: {
                      shape,
                      width: w2,
                      height: h2
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxs(Stack, { gap: 4, flex: 1, children: [
              /* @__PURE__ */ jsx(Group, { gap: 4, flex: "0 0 auto", children: value.kinds.map((kind) => /* @__PURE__ */ jsx(
                Badge,
                {
                  className: cx(
                    shapeBadge
                  ),
                  onMouseEnter: () => {
                    setOnlyKind(kind), diagram.highlightNotation(value, kind);
                  },
                  onMouseLeave: () => {
                    setOnlyKind(null), diagram.highlightNotation(value);
                  },
                  opacity: e$7(onlyKind) && onlyKind !== kind ? 0.25 : 1,
                  children: kind
                },
                kind
              )) }),
              /* @__PURE__ */ jsx(
                Text,
                {
                  component: "div",
                  fz: "sm",
                  fw: 500,
                  lh: "1.25",
                  style: {
                    textWrap: "pretty"
                  },
                  children: title2
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, selector$1 = (s2) => ({
  id: s2.view.id,
  notations: s2.view.notation?.nodes ?? []
}), NotationPanel = memo$3(() => {
  const height = useXYStore((s2) => s2.height), {
    id: id2,
    notations
  } = useDiagramContext(selector$1), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "notation-webview-collapsed",
    defaultValue: !0
  }), hasNotations = notations.length > 0, portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    !hasNotations && /* @__PURE__ */ jsx(
      m$1.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: container,
        children: /* @__PURE__ */ jsx(Tooltip$6, { label: "View has no notations", color: "orange", ...portalProps, children: /* @__PURE__ */ jsx(
          ThemeIcon,
          {
            size: "lg",
            variant: "light",
            color: "orange",
            radius: "md",
            children: /* @__PURE__ */ jsx(IconAlertTriangle, {})
          }
        ) })
      },
      "empty"
    ),
    hasNotations && isCollapsed && /* @__PURE__ */ jsx(
      m$1.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: container,
        children: /* @__PURE__ */ jsx(Tooltip$6, { label: "Show notation", color: "dark", fz: "xs", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            size: "lg",
            variant: "default",
            color: "gray",
            className: icon,
            onClick: () => setCollapsed(!1),
            children: /* @__PURE__ */ jsx(IconHelpCircle, { stroke: 1.5 })
          }
        ) })
      },
      "collapsed"
    ),
    hasNotations && !isCollapsed && /* @__PURE__ */ jsx(
      m$1.div,
      {
        initial: {
          opacity: 0.75,
          // translateX: '50%',
          scale: 0.2
        },
        animate: { opacity: 1, scale: 1 },
        exit: {
          opacity: 0,
          scale: 0.25
        },
        className: cx("react-flow__panel", container),
        style: {
          transformOrigin: "bottom right"
        },
        children: /* @__PURE__ */ jsx(
          Paper,
          {
            radius: "sm",
            withBorder: !0,
            shadow: "lg",
            className: card,
            children: /* @__PURE__ */ jsxs(Tabs, { defaultValue: "first", radius: "xs", children: [
              /* @__PURE__ */ jsxs(TabsList, { children: [
                /* @__PURE__ */ jsx(
                  ActionIcon,
                  {
                    size: "md",
                    variant: "subtle",
                    color: "gray",
                    ml: 2,
                    style: {
                      alignSelf: "center"
                    },
                    onClick: () => setCollapsed(!0),
                    children: /* @__PURE__ */ jsx(IconArrowDownRight, { stroke: 2 })
                  }
                ),
                /* @__PURE__ */ jsx(TabsTab, { value: "first", fz: "xs", children: "Elements" }),
                /* @__PURE__ */ jsx(TabsTab, { value: "second", fz: "xs", disabled: !0, children: "Relationships" })
              ] }),
              /* @__PURE__ */ jsx(TabsPanel, { value: "first", className: tabPanel, hidden: isCollapsed, children: /* @__PURE__ */ jsx(
                ScrollAreaAutosize,
                {
                  viewportProps: {
                    style: {
                      maxHeight: `min(40vh, ${Math.max(height - 60, 50)}px)`
                    }
                  },
                  children: /* @__PURE__ */ jsx(Stack, { gap: 0, children: notations.map((n2, i2) => /* @__PURE__ */ jsx(ElementNotation, { value: n2 }, i2)) })
                }
              ) })
            ] })
          }
        )
      },
      id2
    )
  ] });
}), LayoutDriftFrame = memo$3(() => {
  const [{ layout: layout2, isActive }, { toggleCompare }] = useDiagramCompareLayout(), bgColor = layout2 === "manual" ? "var(--mantine-color-orange-6)" : "var(--mantine-color-green-6)";
  return /* @__PURE__ */ jsx(
    Box,
    {
      className: hstack({
        position: "absolute",
        top: "0",
        left: "0",
        width: "full",
        height: "full",
        border: "default",
        borderWidth: 4,
        pointerEvents: "none",
        alignItems: "flex-start",
        justifyContent: "center"
      }),
      style: {
        zIndex: "9999",
        display: isActive ? void 0 : "none",
        borderColor: bgColor
      },
      children: /* @__PURE__ */ jsx(
        Btn,
        {
          style: {
            backgroundColor: bgColor
          },
          onClick: (e2) => {
            e2.stopPropagation(), toggleCompare();
          },
          children: "Close compare"
        }
      )
    }
  );
}), Btn = UnstyledButton.withProps({
  className: css({
    fontSize: "xs",
    fontWeight: "medium",
    py: "1.5",
    lineHeight: "1",
    borderBottomLeftRadius: "sm",
    borderBottomRightRadius: "sm",
    transform: "translateY(-4px)",
    px: "4",
    color: "mantine.colors.gray[9]",
    pointerEvents: "all",
    _active: {
      transform: "translateY(-3px)"
    }
  })
}), LikeC4DiagramUI = memo$3(() => {
  const {
    enableControls,
    enableNotations,
    enableSearch,
    enableRelationshipDetails,
    enableReadOnly,
    enableCompareWithLatest
  } = useEnabledFeatures(), rerender = useRerender(), overlaysActorRef = useOverlaysActorRef(), searchActorRef = useSearchActorRef(), handleReset = useCallback(() => {
    console.warn("DiagramUI: resetting error boundary and rerendering..."), rerender();
  }, []);
  return /* @__PURE__ */ jsxs(ErrorBoundary2, { onReset: handleReset, children: [
    enableControls && /* @__PURE__ */ jsx(NavigationPanel$1, {}),
    overlaysActorRef && /* @__PURE__ */ jsx(Overlays, { overlaysActorRef }),
    enableNotations && /* @__PURE__ */ jsx(NotationPanel, {}),
    enableSearch && searchActorRef && /* @__PURE__ */ jsx(Search, { searchActorRef }),
    enableRelationshipDetails && enableReadOnly && /* @__PURE__ */ jsx(RelationshipPopover, {}),
    enableCompareWithLatest && /* @__PURE__ */ jsx(LayoutDriftFrame, {})
  ] });
});
LikeC4DiagramUI.displayName = "DiagramUI";
function EdgeDrifts({
  edgeProps: { data },
  svgPath
}) {
  const drifts = data.drifts;
  return !drifts || drifts.length === 0 ? null : /* @__PURE__ */ jsx(
    "path",
    {
      className: cx(
        "react-flow__edge-path",
        css({
          pointerEvents: "none",
          stroke: "likec4.compare.manual.outline",
          fill: "none",
          strokeWidth: {
            base: "8px",
            _whenHovered: "12px"
          },
          strokeOpacity: 0.5
        })
      ),
      d: svgPath,
      strokeLinecap: "round"
    }
  );
}
const controlPointsContainer = css({
  overflow: "visible",
  position: "absolute",
  pointerEvents: "none",
  top: "0",
  left: "0",
  mixBlendMode: {
    _dark: "screen",
    _light: "multiply"
  }
}), controlPoint = css({
  fill: "[var(--xy-edge-stroke)]",
  stroke: "transparent",
  fillOpacity: 0.5,
  strokeWidth: 10,
  r: 4,
  cursor: "grab",
  pointerEvents: "all",
  visibility: "hidden",
  transitionDuration: "120ms",
  transitionProperty: "visibility, fill, fill-opacity, r",
  transitionTimingFunction: "inOut",
  transitionDelay: "20ms",
  ":where([data-likec4-selected='true'], [data-likec4-hovered='true']) &": {
    visibility: "visible",
    fillOpacity: 1,
    transitionTimingFunction: "out",
    transitionDelay: "0ms"
  },
  ":where([data-likec4-selected='true']) &": {
    r: 6
  },
  ":is([data-likec4-hovered='true']) &": {
    r: 8
  },
  _hover: {
    fill: "mantine.colors.primary.filledHover",
    r: 10,
    transitionDuration: "100ms"
  },
  _groupActive: {
    cursor: "grabbing"
  }
});
function useControlPoints({
  sourceX,
  sourceY,
  targetX,
  targetY,
  data
}) {
  const [controlPoints, setControlPoints] = useState(
    () => data.controlPoints ?? bezierControlPoints(data.points)
  );
  useUpdateEffect(() => {
    const next = data.controlPoints ?? bezierControlPoints(data.points);
    setControlPoints((prev) => deepEqual$1(prev, next) ? prev : next);
  }, [
    data.controlPoints?.map((p2) => `${Math.round(p2.x)},${Math.round(p2.y)}`).join("|") ?? "",
    data.points.map((p2) => `${Math.round(p2[0])},${Math.round(p2[1])}`).join("|")
  ]);
  const insertControlPoint = useCallbackRef(({ x: x2, y: y2 }) => {
    const sourceV = vector(sourceX, sourceY), targetV = vector(targetX, targetY), points = [
      data.dir === "back" ? targetV : sourceV,
      ...controlPoints.map(vector) || [],
      data.dir === "back" ? sourceV : targetV
    ], newPointV = vector(x2, y2).round();
    let insertionIndex = 0, minDistance = 1 / 0;
    for (let i2 = 0; i2 < points.length - 1; i2++) {
      const a2 = points[i2], b2 = points[i2 + 1], fromCurrentToNext = b2.subtract(a2), fromCurrentToNew = newPointV.subtract(a2), fromNextToNew = newPointV.subtract(b2);
      if (fromCurrentToNext.dot(fromCurrentToNew) * fromCurrentToNext.dot(fromNextToNew) < 0) {
        const distanceToEdge = Math.abs(fromCurrentToNext.cross(fromCurrentToNew)) / fromCurrentToNext.length();
        distanceToEdge < minDistance && (minDistance = distanceToEdge, insertionIndex = i2);
      }
    }
    const newControlPoints = controlPoints.slice();
    return newControlPoints.splice(insertionIndex, 0, { x: newPointV.x, y: newPointV.y }), setControlPoints(newControlPoints), newControlPoints;
  });
  return {
    controlPoints,
    setControlPoints,
    insertControlPoint
  };
}
function constant(x2) {
  return function() {
    return x2;
  };
}
const epsilon$1 = 1e-12, pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
    this._ += arguments[i2] + strings[i2];
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15) return append;
  const k = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
      this._ += Math.round(arguments[i2] * k) / k + strings[i2];
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    if (x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null)
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    else if (l01_2 > epsilon) if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2)
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      Math.abs(t01 - 1) > epsilon && this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`, this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    if (x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    this._x1 === null ? this._append`M${x0},${y0}` : (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) && this._append`L${x0},${y0}`, r2 && (da < 0 && (da = da % tau + tau), da > tauEpsilon ? this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}` : da > epsilon && this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`);
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  return shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null)
      digits = null;
    else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    return shape;
  }, () => new Path(digits);
}
function array(x2) {
  return typeof x2 == "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context2) {
  this._context = context2;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context2) {
  return new Linear(context2);
}
function x$1(p2) {
  return p2[0];
}
function y$1(p2) {
  return p2[1];
}
function line(x2, y2) {
  var defined = constant(!0), context2 = null, curve2 = curveLinear, output = null, path = withPath(line2);
  x2 = typeof x2 == "function" ? x2 : x2 === void 0 ? x$1 : constant(x2), y2 = typeof y2 == "function" ? y2 : y2 === void 0 ? y$1 : constant(y2);
  function line2(data) {
    var i2, n2 = (data = array(data)).length, d2, defined0 = !1, buffer;
    for (context2 == null && (output = curve2(buffer = path())), i2 = 0; i2 <= n2; ++i2)
      !(i2 < n2 && defined(d2 = data[i2], i2, data)) === defined0 && ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()), defined0 && output.point(+x2(d2, i2, data), +y2(d2, i2, data));
    if (buffer) return output = null, buffer + "" || null;
  }
  return line2.x = function(_) {
    return arguments.length ? (x2 = typeof _ == "function" ? _ : constant(+_), line2) : x2;
  }, line2.y = function(_) {
    return arguments.length ? (y2 = typeof _ == "function" ? _ : constant(+_), line2) : y2;
  }, line2.defined = function(_) {
    return arguments.length ? (defined = typeof _ == "function" ? _ : constant(!!_), line2) : defined;
  }, line2.curve = function(_) {
    return arguments.length ? (curve2 = _, context2 != null && (output = curve2(context2)), line2) : curve2;
  }, line2.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output = null : output = curve2(context2 = _), line2) : context2;
  }, line2;
}
function point$1(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context2, tension) {
  this._context = context2, this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$1(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2, this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom(tension) {
  function cardinal(context2) {
    return new Cardinal(context2, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom(+tension2);
  }, cardinal;
})(0);
function CardinalOpen(context2, tension) {
  this._context = context2, this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom2(tension) {
  function cardinal(context2) {
    return new CardinalOpen(context2, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom2(+tension2);
  }, cardinal;
})(0);
function point(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2, y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon$1) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2, y22 = (y22 * b2 + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context2, alpha2) {
  this._context = context2, this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom3(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRom(context2, alpha2) : new Cardinal(context2, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom3(+alpha3);
  }, catmullRom;
})(0.5);
function CatmullRomOpen(context2, alpha2) {
  this._context = context2, this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomOpen = (function custom4(alpha2) {
  function catmullRom(context2) {
    return alpha2 ? new CatmullRomOpen(context2, alpha2) : new CardinalOpen(context2, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom4(+alpha3);
  }, catmullRom;
})(0.5), curve = line().curve(curveCatmullRomOpen.alpha(0.7)).x((d2) => Math.round(d2.x)).y((d2) => Math.round(d2.y)), isSameRects = (a2, b2) => isEqualRects(a2.sourceNode, b2.sourceNode) && isEqualRects(a2.targetNode, b2.targetNode);
function useRelationshipEdgePath({
  props: {
    sourceX,
    sourceY,
    source,
    target,
    targetX,
    targetY,
    data
  },
  controlPoints,
  isControlPointDragging
}) {
  const {
    sourceNode,
    targetNode
  } = useXYStore(
    useCallback(({ nodeLookup }) => {
      const sourceNode2 = nonNullable(nodeLookup.get(source), `source node ${source} not found`), targetNode2 = nonNullable(nodeLookup.get(target), `target node ${target} not found`);
      return {
        sourceNode: nodeToRect(sourceNode2),
        targetNode: nodeToRect(targetNode2)
      };
    }, [source, target]),
    isSameRects
  );
  if (e$1(data.controlPoints) || isControlPointDragging) {
    const sourceCenterPos = { x: sourceX, y: sourceY }, targetCenterPos = { x: targetX, y: targetY }, nodeMargin = 6, points = data.dir === "back" ? [
      targetCenterPos,
      getNodeIntersectionFromCenterToPoint(targetNode, n$p(controlPoints) ?? sourceCenterPos, nodeMargin),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(sourceNode, t$g(controlPoints) ?? targetCenterPos, nodeMargin),
      sourceCenterPos
    ] : [
      sourceCenterPos,
      getNodeIntersectionFromCenterToPoint(sourceNode, n$p(controlPoints) ?? targetCenterPos, nodeMargin),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(targetNode, t$g(controlPoints) ?? sourceCenterPos, nodeMargin),
      targetCenterPos
    ];
    return nonNullable(curve(points));
  }
  return bezierPath(data.points);
}
const getEdgeCenter = (path) => {
  const dompoint = path.getPointAtLength(path.getTotalLength() * 0.5);
  return {
    x: Math.round(dompoint.x),
    y: Math.round(dompoint.y)
  };
}, RelationshipEdge$1 = memoEdge((props) => {
  const [isControlPointDragging, setIsControlPointDragging] = useState(!1), isControlPointDraggingRef = useRef(isControlPointDragging);
  isControlPointDraggingRef.current = isControlPointDragging;
  const xyflow2 = useXYFlow(), diagram = useDiagram(), {
    enableNavigateTo,
    enableReadOnly,
    enableCompareWithLatest
  } = useEnabledFeatures(), enabledEditing = !enableReadOnly, {
    id: id2,
    selected: selected2 = !1,
    data: {
      labelBBox,
      labelXY,
      ...data
    }
  } = props, navigateTo = enableNavigateTo && !isControlPointDragging ? data.navigateTo : void 0, {
    controlPoints,
    setControlPoints,
    insertControlPoint
  } = useControlPoints(props);
  let edgePath2 = useRelationshipEdgePath({
    props,
    controlPoints,
    isControlPointDragging
  }), labelX = labelBBox?.x ?? 0, labelY = labelBBox?.y ?? 0;
  const [labelPos, setLabelPos] = useState({
    x: labelXY?.x ?? labelX,
    y: labelXY?.y ?? labelY
  });
  useUpdateEffect(() => {
    if (isControlPointDraggingRef.current)
      return;
    const next = {
      x: labelX,
      y: labelY
    };
    setLabelPos((current2) => isSamePoint(current2, next) ? current2 : next);
  }, [labelX, labelY]);
  const svgPathRef = useRef(null);
  useEffect(() => {
    const path = svgPathRef.current;
    if (!path || !isControlPointDragging) return;
    const next = getEdgeCenter(path);
    setLabelPos((current2) => isSamePoint(current2, next) ? current2 : next);
  }, [edgePath2, isControlPointDragging]);
  const updateEdgeData2 = useCallbackRef((controlPoints2) => {
    const point2 = svgPathRef.current ? getEdgeCenter(svgPathRef.current) : null;
    labelBBox && point2 ? diagram.updateEdgeData(id2, {
      controlPoints: controlPoints2,
      labelBBox: {
        ...labelBBox,
        ...point2
      }
    }) : diagram.updateEdgeData(id2, { controlPoints: controlPoints2 }), diagram.stopEditing(!0), setIsControlPointDragging(!1);
  }), onControlPointerStartMove = useCallbackRef(() => {
    diagram.startEditing("edge"), setIsControlPointDragging(!0);
  }), onControlPointerCancelMove = useCallbackRef(() => {
    diagram.stopEditing(), setIsControlPointDragging(!1);
  }), onControlPointerFinishMove = useCallbackRef((points) => {
    setControlPoints(points), requestAnimationFrame(() => {
      updateEdgeData2(points);
    });
  }), onControlPointerDelete = useCallbackRef((points) => {
    diagram.startEditing("edge"), setIsControlPointDragging(!0), setControlPoints(points), requestAnimationFrame(() => {
      updateEdgeData2(points);
    });
  }), onEdgePointerDown = useCallbackRef((e2) => {
    if (e2.pointerType !== "mouse" || e2.button !== 2 && !selected2)
      return;
    e2.stopPropagation(), e2.preventDefault(), diagram.startEditing("edge");
    const newControlPoints = insertControlPoint(
      xyflow2.screenToFlowPosition(
        {
          x: e2.clientX,
          y: e2.clientY
        },
        { snapToGrid: !1 }
      )
    );
    diagram.updateEdgeData(id2, { controlPoints: newControlPoints }), diagram.stopEditing(!0);
  });
  return isControlPointDragging && !props.data.hovered && (props = {
    ...props,
    data: {
      ...props.data,
      hovered: !0
    }
  }), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      EdgeContainer,
      {
        ...props,
        className: css({
          "& .react-flow__edge-interaction": {
            cursor: enabledEditing && selected2 ? "copy" : void 0
          }
        }),
        children: [
          /* @__PURE__ */ jsx(
            EdgePath,
            {
              edgeProps: props,
              svgPath: edgePath2,
              ref: svgPathRef,
              isDragging: isControlPointDragging,
              ...enabledEditing && {
                onEdgePointerDown
              }
            }
          ),
          enableCompareWithLatest && /* @__PURE__ */ jsx(
            EdgeDrifts,
            {
              edgeProps: props,
              svgPath: edgePath2
            }
          ),
          labelBBox && /* @__PURE__ */ jsx(
            EdgeLabelContainer,
            {
              edgeProps: props,
              labelPosition: isControlPointDragging ? labelPos : { x: labelX, y: labelY },
              children: /* @__PURE__ */ jsx(
                EdgeLabel,
                {
                  pointerEvents: enabledEditing ? "none" : "all",
                  edgeProps: props,
                  children: navigateTo && /* @__PURE__ */ jsx(
                    EdgeActionButton,
                    {
                      onClick: (e2) => {
                        e2.stopPropagation(), diagram.navigateTo(navigateTo);
                      }
                    }
                  )
                }
              )
            }
          )
        ]
      }
    ),
    enabledEditing && controlPoints.length > 0 && /* @__PURE__ */ jsx(
      ControlPoints,
      {
        isControlPointDragging,
        edgeProps: props,
        controlPoints,
        onMove: setControlPoints,
        onStartMove: onControlPointerStartMove,
        onCancelMove: onControlPointerCancelMove,
        onFinishMove: onControlPointerFinishMove,
        onDelete: onControlPointerDelete,
        zIndex: 9999
      }
    )
  ] });
});
RelationshipEdge$1.displayName = "RelationshipEdge";
function ControlPoints({
  isControlPointDragging,
  edgeProps,
  controlPoints,
  onMove,
  onStartMove,
  onCancelMove,
  onFinishMove,
  onDelete,
  zIndex
}) {
  const xyflowStore = useXYStoreApi(), xyflow2 = useXYFlow(), edgeId = edgeProps.data.id, onLmbControlPointerDown = (index2, e2, domNode) => {
    let hasMoved = !1, pointer2 = { x: e2.clientX, y: e2.clientY }, animationFrameId = null, cp = controlPoints;
    const onPointerMove = (e22) => {
      const clientPoint = {
        x: e22.clientX,
        y: e22.clientY
      };
      isSamePoint(pointer2, clientPoint) || (hasMoved || (hasMoved = !0, onStartMove()), pointer2 = clientPoint, animationFrameId ??= requestAnimationFrame(() => {
        animationFrameId = null, cp = cp.slice();
        const { x: x2, y: y2 } = xyflow2.screenToFlowPosition(pointer2, { snapToGrid: !1 });
        cp[index2] = {
          x: Math.round(x2),
          y: Math.round(y2)
        }, onMove(cp);
      })), e22.stopPropagation();
    }, onPointerUp = (e22) => {
      e22.stopPropagation(), domNode.removeEventListener("pointermove", onPointerMove, {
        capture: !0
      }), domNode.removeEventListener("click", stopAndPrevent, {
        capture: !0
      }), hasMoved ? onFinishMove(cp) : onCancelMove();
    };
    domNode.addEventListener("pointermove", onPointerMove, {
      capture: !0
    }), domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    }), domNode.addEventListener("click", stopAndPrevent, {
      capture: !0,
      once: !0
    });
  }, onRmbControlPointerDown = (index2, e2) => {
    if (controlPoints.length <= 1)
      return;
    e2.stopPropagation(), e2.preventDefault();
    const newControlPoints = controlPoints.slice();
    newControlPoints.splice(index2, 1), setTimeout(() => {
      onDelete(newControlPoints);
    }, 10);
  }, onControlPointerDown = useCallbackRef((e2) => {
    const { domNode, addSelectedEdges, edges, unselectNodesAndEdges } = xyflowStore.getState();
    if (!domNode || e2.pointerType !== "mouse")
      return;
    const index2 = parseFloat(e2.currentTarget.getAttribute("data-control-point-index") || "");
    if (isNaN(index2))
      throw new Error("data-control-point-index is not a number");
    switch (e2.button) {
      case 0: {
        e2.stopPropagation(), unselectNodesAndEdges({
          edges: edges.filter((ed) => ed.selected && ed.id !== edgeId)
        }), addSelectedEdges([edgeId]), onLmbControlPointerDown(index2, e2, domNode);
        break;
      }
      case 2:
        onRmbControlPointerDown(index2, e2);
        break;
    }
  }), onControlPointerDblClick = useCallbackRef((e2) => {
    const { domNode } = xyflowStore.getState();
    if (!domNode || e2.pointerType !== "mouse")
      return;
    const index2 = parseFloat(e2.currentTarget.getAttribute("data-control-point-index") || "");
    if (isNaN(index2))
      throw new Error("data-control-point-index is not a number");
    onRmbControlPointerDown(index2, e2);
  });
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsx(
    EdgeContainer,
    {
      component: "svg",
      className: controlPointsContainer,
      ...edgeProps,
      style: {
        ...edgeProps.style,
        zIndex
      },
      children: /* @__PURE__ */ jsx(
        "g",
        {
          "data-active": isControlPointDragging ? !0 : void 0,
          className: "group",
          onContextMenu: stopAndPrevent,
          children: controlPoints.map((p2, i2) => /* @__PURE__ */ jsx(
            "circle",
            {
              "data-control-point-index": i2,
              onPointerDownCapture: onControlPointerDown,
              onDoubleClick: onControlPointerDblClick,
              className: cx("nodrag nopan", controlPoint),
              cx: p2.x,
              cy: p2.y
            },
            "controlPoints" + edgeId + "#" + i2
          ))
        }
      )
    }
  ) });
}
const stopAndPrevent = (e2) => {
  e2.stopPropagation(), e2.preventDefault();
}, LABEL_OFFSET = 16;
function SequenceStepEdge(props) {
  const { enableNavigateTo, enableCompareWithLatest } = useEnabledFeatures(), diagram = useDiagram(), { navigateTo } = props.data, isSelfLoop = props.source === props.target, isBack = props.sourceX > props.targetX, [path] = getSmoothStepPath({
    sourceX: props.sourceX,
    sourceY: props.sourceY,
    sourcePosition: props.sourcePosition,
    targetX: props.targetX,
    targetY: props.targetY,
    targetPosition: props.targetPosition,
    ...isSelfLoop && {
      offset: 30,
      borderRadius: 16
    }
  });
  let labelX = props.sourceX;
  switch (!0) {
    case isSelfLoop:
      labelX = props.sourceX + 24 + LABEL_OFFSET;
      break;
    case isBack:
      labelX = props.sourceX - LABEL_OFFSET;
      break;
    default:
      labelX = props.sourceX + LABEL_OFFSET;
      break;
  }
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...props, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps: props,
        svgPath: path
      }
    ),
    enableCompareWithLatest && /* @__PURE__ */ jsx(EdgeDrifts, { edgeProps: props, svgPath: path }),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps: props,
        labelPosition: {
          x: labelX,
          y: props.sourceY + (isSelfLoop ? 0 : LABEL_OFFSET),
          translate: isBack ? "translate(-100%, 0)" : void 0
        },
        children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps: props, children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
          EdgeActionButton,
          {
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigateTo(navigateTo);
            }
          }
        ) })
      }
    )
  ] });
}
const compareElementActionsProps = (a2, b2) => deepEqual$1(a2.data.id, b2.data.id) && deepEqual$1(a2.selected ?? !1, b2.selected ?? !1) && deepEqual$1(a2.data.modelFqn ?? null, b2.data.modelFqn ?? null) && deepEqual$1(a2.data.navigateTo ?? null, b2.data.navigateTo ?? null) && deepEqual$1(a2.data.hovered ?? !1, b2.data.hovered ?? !1) && (!a2.extraButtons && !b2.extraButtons || shallowEqual$1(a2.extraButtons, b2.extraButtons)), ElementActions = memo$3(({
  extraButtons,
  ...props
}) => {
  const { enableNavigateTo, enableRelationshipBrowser } = useEnabledFeatures(), diagram = useDiagram(), { id: id2, navigateTo, modelFqn } = props.data;
  let buttons = useMemo(() => {
    const buttons2 = [];
    return navigateTo && enableNavigateTo && buttons2.push({
      key: "navigate",
      icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, id2);
      }
    }), enableRelationshipBrowser && buttons2.push({
      key: "relationships",
      icon: /* @__PURE__ */ jsx(IconTransform, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(modelFqn);
      }
    }), buttons2;
  }, [enableNavigateTo, enableRelationshipBrowser, modelFqn, navigateTo, id2, diagram]);
  return extraButtons && t$q(extraButtons, 1) && (buttons = [...buttons, ...extraButtons]), /* @__PURE__ */ jsx(ElementActionButtons, { ...props, buttons });
}, compareElementActionsProps), DeploymentElementActions = ({
  extraButtons,
  ...props
}) => {
  const { enableNavigateTo, enableRelationshipBrowser } = useEnabledFeatures(), diagram = useDiagram(), { id: id2, navigateTo, modelFqn } = props.data;
  let buttons = useMemo(() => {
    const buttons2 = [];
    return navigateTo && enableNavigateTo && buttons2.push({
      key: "navigate",
      icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, id2);
      }
    }), enableRelationshipBrowser && modelFqn && buttons2.push({
      key: "relationships",
      icon: /* @__PURE__ */ jsx(IconTransform, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(modelFqn);
      }
    }), buttons2;
  }, [enableNavigateTo, enableRelationshipBrowser, modelFqn, navigateTo, id2]);
  return extraButtons && t$q(extraButtons, 1) && (buttons = [...buttons, ...extraButtons]), /* @__PURE__ */ jsx(ElementActionButtons, { ...props, buttons });
};
function NodeDrifts({
  nodeProps: { data },
  position = "bottom"
}) {
  const drifts = data.drifts;
  if (!drifts || drifts.length === 0)
    return null;
  const toolbarPosition = position === "top" ? Position.Top : Position.Bottom;
  return /* @__PURE__ */ jsx(
    Box,
    {
      className: "likec4-node-drifts",
      css: {
        display: "contents",
        "& + .likec4-element-shape": {
          outlineColor: "likec4.compare.manual.outline",
          outlineWidth: "4px",
          outlineStyle: "dashed",
          outlineOffset: "1.5"
        }
      },
      children: /* @__PURE__ */ jsx(NodeToolbar, { isVisible: data.hovered === !0, align: "start", position: toolbarPosition, children: /* @__PURE__ */ jsx(
        Notification,
        {
          color: "orange",
          withBorder: !1,
          withCloseButton: !1,
          title: "Changes:",
          children: drifts.map((drift) => /* @__PURE__ */ jsxs(Text, { mt: 2, size: "sm", lh: "xs", children: [
            "- ",
            drift
          ] }, drift))
        }
      ) })
    }
  );
}
function CompoundActionButton({
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const isHoverDebounced = useDebouncedValue(isHovered, isHovered ? 130 : 0)[0] && isHovered;
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      initial: !1,
      animate: {
        scale: isHoverDebounced ? 1.2 : 1,
        x: isHoverDebounced ? -1 : 0,
        y: isHoverDebounced ? -1 : 0
      },
      whileHover: {
        scale: 1.4,
        x: -3,
        y: -1
      },
      className: "likec4-compound-navigation compound-action",
      whileTap: { scale: 1 },
      onClick: stopPropagation,
      children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          className: cx(
            "nodrag nopan",
            compoundActionBtn({
              delay: isHovered && !isHoverDebounced
            }),
            actionBtn({ variant: "transparent" })
          ),
          onClick,
          onDoubleClick: stopPropagation,
          children: icon2 ?? /* @__PURE__ */ jsx(IconZoomScan, { stroke: 2 })
        }
      )
    }
  );
}
const CompoundActions = (props) => {
  const { enableNavigateTo } = useEnabledFeatures(), diagram = useDiagram(), { navigateTo } = props.data;
  return navigateTo && enableNavigateTo ? /* @__PURE__ */ jsx(
    CompoundActionButton,
    {
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, props.id);
      },
      ...props
    }
  ) : null;
}, Tooltip = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4,
  withinPortal: !1
});
function BrowseRelationshipsButton({ fqn: fqn2 }) {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip, { label: "Browse relationships", children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(fqn2);
      },
      children: /* @__PURE__ */ jsx(
        IconTransform,
        {
          stroke: 2,
          style: {
            width: "65%",
            height: "65%"
          }
        }
      )
    }
  ) });
}
function GoToSourceButton(props) {
  const { onOpenSource } = useDiagramEventHandlers();
  return onOpenSource ? /* @__PURE__ */ jsx(Tooltip, { label: "Open source", children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), props.elementId ? onOpenSource?.({
          element: props.elementId
        }) : props.deploymentId && onOpenSource?.({
          deployment: props.deploymentId
        });
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "65%" } })
    }
  ) }) : null;
}
function BorderStyleOption({
  elementBorderStyle = "none",
  onChange
}) {
  const [value, setValue] = useState(elementBorderStyle);
  return useEffect(() => {
    setValue(elementBorderStyle);
  }, [elementBorderStyle]), /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      fz: 9,
      fullWidth: !0,
      withItemsBorders: !1,
      value,
      onChange: (v2) => {
        const border = v2;
        setValue(border), onChange({ border });
      },
      styles: {
        label: {
          paddingTop: 2,
          paddingBottom: 2
        }
      },
      data: [
        { label: "Solid", value: "solid" },
        { label: "Dashed", value: "dashed" },
        { label: "Dotted", value: "dotted" },
        { label: "None", value: "none" }
      ]
    }
  );
}
function useLikeC4Styles() {
  const $styles = useContext(LikeC4ModelContext)?.$styles ?? LikeC4Styles$1.DEFAULT, [styles, setStyles] = useState($styles);
  return useEffect(() => {
    setStyles((current2) => current2.equals($styles) ? current2 : $styles);
  }, [$styles]), styles;
}
const SemanticColors = [
  "primary",
  "secondary",
  "muted"
];
function ColorButton({
  elementColor,
  elementOpacity,
  onColorPreview,
  isOpacityEditable = !1,
  onChange,
  ...props
}) {
  const { theme } = useLikeC4Styles();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      position: "top-start",
      offset: 2,
      withinPortal: !1,
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Button, { variant: "subtle", color: "gray", size: "xs", px: 6, children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: theme.colors[elementColor].elements.fill,
            size: 16,
            withShadow: !0,
            style: { color: "#fff", cursor: "pointer" }
          }
        ) }) }),
        /* @__PURE__ */ jsxs(PopoverDropdown, { p: "xs", children: [
          /* @__PURE__ */ jsx(
            ColorSwatches,
            {
              theme,
              elementColor,
              onColorPreview,
              onChange: (color2) => onChange({ color: color2 })
            }
          ),
          isOpacityEditable && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(Divider$2, { label: "opacity", labelPosition: "left" }),
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(
              OpacityOption,
              {
                elementOpacity,
                onOpacityChange: (opacity) => {
                  onChange({ opacity });
                }
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function ColorSwatches({
  theme,
  elementColor,
  onColorPreview,
  onChange
}) {
  const changeColor = (color2) => (e2) => {
    e2.stopPropagation(), onColorPreview(null), elementColor !== color2 && onChange(color2);
  }, otherColors = t$h(theme.colors).filter((color2) => !SemanticColors.includes(color2));
  return /* @__PURE__ */ jsx(Stack, { gap: 2, onMouseLeave: () => onColorPreview(null), children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 1e3, closeDelay: 300, children: [
    /* @__PURE__ */ jsx(Flex, { maw: 120, gap: "6", justify: "flex-start", align: "flex-start", direction: "row", wrap: "wrap", children: SemanticColors.map((color2) => /* @__PURE__ */ jsx(
      Tooltip$6,
      {
        label: color2,
        fz: "xs",
        color: "dark",
        offset: 2,
        withinPortal: !1,
        transitionProps: { duration: 140, transition: "slide-up" },
        children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: theme.colors[color2].elements.fill,
            size: 18,
            withShadow: !0,
            onMouseEnter: () => onColorPreview(color2),
            onClick: changeColor(color2),
            style: { color: "#fff", cursor: "pointer" },
            children: elementColor === color2 && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
          }
        )
      },
      color2
    )) }),
    /* @__PURE__ */ jsx(
      Flex,
      {
        mt: "sm",
        maw: 110,
        gap: "6",
        justify: "flex-start",
        align: "flex-start",
        direction: "row",
        wrap: "wrap",
        children: otherColors.map((key2) => /* @__PURE__ */ jsx(
          Tooltip$6,
          {
            label: key2,
            fz: "xs",
            color: "dark",
            offset: 2,
            transitionProps: { duration: 140, transition: "slide-up" },
            children: /* @__PURE__ */ jsx(
              ColorSwatch,
              {
                color: theme.colors[key2].elements.fill,
                size: 18,
                onMouseEnter: () => onColorPreview(key2),
                onClick: changeColor(key2),
                style: { color: "#fff", cursor: "pointer" },
                children: elementColor === key2 && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
              }
            )
          },
          key2
        ))
      }
    )
  ] }) });
}
function OpacityOption({
  elementOpacity = 100,
  onOpacityChange
}) {
  const [value, setValue] = useState(elementOpacity);
  return useUpdateEffect$1(() => {
    setValue(elementOpacity);
  }, [elementOpacity]), /* @__PURE__ */ jsx(
    Slider,
    {
      size: "sm",
      color: "dark",
      value,
      onChange: setValue,
      onChangeEnd: onOpacityChange
    }
  );
}
const toolbarTitle = css({
  color: "mantine.colors.dimmed",
  fontSize: "10px",
  fontWeight: 600,
  maxWidth: "220px",
  cursor: "default",
  userSelect: "all",
  textOverflow: "ellipsis",
  overflow: "hidden",
  whiteSpace: "nowrap"
}), selectSelectedNodesCount = (context2) => context2.xynodes.filter((x2) => x2.selected).length, useSelectedNodesCount = () => useDiagramContext(selectSelectedNodesCount);
function Toolbar({ title: title2, children: children2, nodeProps, ...props }) {
  const selectedNodesCount = useSelectedNodesCount(), {
    selected: selected2 = !1,
    dragging = !1,
    data: {
      hovered = !1
    }
  } = nodeProps, _isToolbarVisible = hovered && selectedNodesCount === 0 || selected2 && selectedNodesCount === 1;
  let delay2 = 150;
  _isToolbarVisible ? selected2 ? delay2 = 100 : delay2 = 1e3 : selectedNodesCount > 0 && (delay2 = 50);
  const [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, delay2);
  return isToolbarVisible ? /* @__PURE__ */ jsx(
    NodeToolbar,
    {
      isVisible: !dragging,
      offset: 4,
      ...props,
      children: /* @__PURE__ */ jsx(
        Paper,
        {
          className: cx("nodrag", "nopan"),
          px: 5,
          pb: 8,
          pt: 4,
          radius: "sm",
          shadow: "xl",
          onDoubleClickCapture: stopPropagation,
          onPointerDown: stopPropagation,
          onClick: stopPropagation,
          onDoubleClick: stopPropagation,
          withBorder: !0,
          children: /* @__PURE__ */ jsxs(VStack, { gap: "2", children: [
            /* @__PURE__ */ jsx(Box, { px: "1", children: /* @__PURE__ */ jsx(Text, { className: toolbarTitle, children: title2 }) }),
            /* @__PURE__ */ jsx(HStack, { gap: "1", children: children2 })
          ] })
        }
      )
    }
  ) : null;
}
function useHandlers(target, props) {
  const diagram = useDiagram(), [originalColor, setOriginalColor] = useState(null), onColorPreview = useCallbackRef((color2) => {
    if (color2 === null) {
      if (!originalColor) return;
      setOriginalColor(null), diagram.updateNodeData(props.data.id, {
        color: originalColor
      });
      return;
    }
    setOriginalColor((value) => value ?? props.data.color), diagram.updateNodeData(props.data.id, {
      color: color2
    });
  }), onChange = useCallbackRef((change2) => {
    const { shape, color: color2, ...style2 } = change2;
    diagram.updateNodeData(props.data.id, {
      ...shape && { shape },
      ...color2 && { color: color2 },
      style: style2
    }), diagram.triggerChange({
      op: "change-element-style",
      style: change2,
      targets: [target]
    });
  });
  return {
    elementColor: originalColor ?? props.data.color,
    onColorPreview,
    onChange
  };
}
function CompoundElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      style: style2,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(modelFqn, props), opacity = style2?.opacity ?? 100;
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: modelFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            isOpacityEditable: !0,
            elementOpacity: opacity,
            onChange,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style2?.border ?? (opacity < 99 ? "dashed" : "none"),
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: modelFqn }),
        enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function CompoundDeploymentToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      deploymentFqn,
      style: style2,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(deploymentFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: deploymentFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            isOpacityEditable: !0,
            elementOpacity: style2?.opacity,
            onChange,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style2?.border,
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { deploymentId: deploymentFqn }),
        enableRelationshipBrowser && modelFqn && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function ElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      shape,
      modelFqn,
      style: style2
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(modelFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: modelFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          ElementShapeButton,
          {
            elementShape: shape,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style2?.border ?? "none",
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: modelFqn }),
        enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function DeploymentElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      shape,
      deploymentFqn,
      modelFqn,
      style: style2
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(deploymentFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: deploymentFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          ElementShapeButton,
          {
            elementShape: shape,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style2?.border ?? "none",
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { deploymentId: deploymentFqn }),
        enableRelationshipBrowser && modelFqn && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function ElementShapeButton({
  elementShape,
  onChange
}) {
  return /* @__PURE__ */ jsxs(
    Menu,
    {
      openDelay: 300,
      closeDelay: 450,
      floatingStrategy: "fixed",
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      closeOnItemClick: !1,
      position: "top-start",
      offset: 2,
      styles: {
        item: {
          padding: "calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-xs)"
        }
      },
      withinPortal: !1,
      children: [
        /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
          Button,
          {
            variant: "light",
            color: "gray",
            size: "xs",
            px: 8,
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 12 }),
            children: elementShape
          }
        ) }),
        /* @__PURE__ */ jsx(
          MenuDropdown,
          {
            onDoubleClick: stopPropagation,
            onClick: stopPropagation,
            children: ElementShapes.map((shape) => /* @__PURE__ */ jsx(
              MenuItem,
              {
                fz: 12,
                fw: 500,
                value: shape,
                rightSection: elementShape === shape ? /* @__PURE__ */ jsx(IconCheck, { size: 12 }) : void 0,
                onClick: (e2) => {
                  e2.stopPropagation(), onChange({ shape });
                },
                children: shape
              },
              shape
            ))
          }
        )
      ]
    }
  );
}
const positions = [Position.Top, Position.Right, Position.Bottom, Position.Left], DefaultHandles = memo$3(() => /* @__PURE__ */ jsx(Fragment, { children: positions.map((position) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  /* @__PURE__ */ jsx(
    Handle,
    {
      type: "source",
      position,
      className: "likec4-node-handle-center"
    }
  ),
  /* @__PURE__ */ jsx(
    Handle,
    {
      type: "target",
      position,
      className: "likec4-node-handle-center"
    }
  )
] }, position)) }));
function ElementDetailsButtonWithHandler(props) {
  const diagram = useDiagram(), fqn2 = props.data.modelFqn;
  return fqn2 ? /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(fqn2, props.id);
      }
    }
  ) : null;
}
function CompoundDetailsButtonWithHandler(props) {
  const diagram = useDiagram(), fqn2 = props.data.modelFqn;
  return fqn2 ? /* @__PURE__ */ jsx(
    CompoundDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(fqn2, props.id);
      }
    }
  ) : null;
}
function ElementNode(props) {
  const { enableElementTags, enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
    enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(ElementActions, { ...props }),
    enableElementDetails && /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { ...props }),
    !enableReadOnly && /* @__PURE__ */ jsx(ElementToolbar, { ...props }),
    /* @__PURE__ */ jsx(DefaultHandles, {})
  ] });
}
function DeploymentNode(props) {
  const { enableElementTags, enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
    enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(DeploymentElementActions, { ...props }),
    enableElementDetails && /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { ...props }),
    !enableReadOnly && /* @__PURE__ */ jsx(DeploymentElementToolbar, { ...props }),
    /* @__PURE__ */ jsx(DefaultHandles, {})
  ] });
}
const compoundHasDrifts = css({
  outlineColor: "likec4.compare.manual.outline",
  outlineWidth: "4px",
  outlineStyle: "dashed",
  outlineOffset: "1.5"
}), hasDrifts = (props) => props.data.drifts && props.data.drifts.length > 0;
function CompoundElementNode(props) {
  const { enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures(), showDrifts = enableCompareWithLatest && hasDrifts(props);
  return /* @__PURE__ */ jsxs(
    CompoundNodeContainer,
    {
      className: showDrifts ? compoundHasDrifts : void 0,
      nodeProps: props,
      children: [
        enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
        /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
        /* @__PURE__ */ jsx(CompoundActions, { ...props }),
        enableElementDetails && /* @__PURE__ */ jsx(CompoundDetailsButtonWithHandler, { ...props }),
        !enableReadOnly && /* @__PURE__ */ jsx(CompoundElementToolbar, { ...props }),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    }
  );
}
function CompoundDeploymentNode(props) {
  const { enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures(), showDrifts = enableCompareWithLatest && hasDrifts(props);
  return /* @__PURE__ */ jsxs(
    CompoundNodeContainer,
    {
      className: showDrifts ? compoundHasDrifts : void 0,
      nodeProps: props,
      children: [
        enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
        /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
        /* @__PURE__ */ jsx(CompoundActions, { ...props }),
        enableElementDetails && /* @__PURE__ */ jsx(CompoundDetailsButtonWithHandler, { ...props }),
        !enableReadOnly && /* @__PURE__ */ jsx(CompoundDeploymentToolbar, { ...props }),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    }
  );
}
function ViewGroupNode(props) {
  const { enableCompareWithLatest } = useEnabledFeatures(), showDrifts = enableCompareWithLatest && hasDrifts(props);
  return /* @__PURE__ */ jsxs(
    CompoundNodeContainer,
    {
      className: showDrifts ? compoundHasDrifts : void 0,
      nodeProps: props,
      children: [
        enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
        /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    }
  );
}
const positionMap = {
  left: Position.Left,
  right: Position.Right,
  top: Position.Top,
  bottom: Position.Bottom
}, ActorStepPort = ({
  data,
  port: p2
}) => /* @__PURE__ */ jsxs(Fragment, { children: [
  /* @__PURE__ */ jsx(
    Box,
    {
      "data-likec4-color": data.color,
      className: css({
        position: "absolute",
        backgroundColor: "var(--likec4-palette-fill)",
        rounded: "xs",
        width: {
          base: "5px",
          _whenHovered: "7px",
          _whenSelected: "7px"
        },
        transition: "fast",
        translateX: "-1/2",
        translateY: "-1/2",
        translate: "auto"
      }),
      style: {
        top: p2.cy,
        left: p2.cx,
        height: p2.height
      }
    }
  ),
  /* @__PURE__ */ jsx(
    Handle,
    {
      id: p2.id,
      type: p2.type,
      position: positionMap[p2.position],
      style: {
        top: p2.cy - 3,
        left: p2.cx - 3,
        width: 6,
        height: 6,
        right: "unset",
        bottom: "unset",
        visibility: "hidden",
        transform: p2.position === "left" ? "translate(-150%, 0)" : "translate(100%, 0)"
      }
    }
  )
] }), hasModelFqn$1 = (data) => e$1(data.modelFqn);
function SequenceActorNode(props) {
  const { enableElementDetails, enableCompareWithLatest } = useEnabledFeatures(), data = props.data, {
    id: id2,
    positionAbsoluteY,
    data: {
      viewHeight,
      hovered: isHovered = !1,
      ports
    }
  } = props;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        "data-likec4-color": "gray",
        className: css({
          position: "absolute",
          rounded: "xs",
          top: "1",
          pointerEvents: "none",
          transition: "fast",
          translateX: "-1/2",
          translate: "auto"
        }),
        style: {
          backgroundColor: "var(--likec4-palette-stroke)",
          opacity: isHovered ? 0.6 : 0.4,
          left: "50%",
          width: isHovered ? 3 : 2,
          height: viewHeight - positionAbsoluteY,
          zIndex: -1,
          pointerEvents: "none"
        }
      }
    ),
    /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
      enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
      /* @__PURE__ */ jsx(ElementShape, { ...props }),
      /* @__PURE__ */ jsx(ElementData, { ...props }),
      hasModelFqn$1(data) && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(ElementActions, { ...props, data }),
        enableElementDetails && /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { id: id2, data })
      ] })
    ] }),
    ports.map((p2) => /* @__PURE__ */ jsx(ActorStepPort, { port: p2, data: props.data }, p2.id))
  ] });
}
function SequenceParallelArea(props) {
  return /* @__PURE__ */ jsx(
    Box,
    {
      "data-likec4-color": props.data.color,
      css: {
        width: "100%",
        height: "100%",
        border: "default",
        rounded: "sm",
        borderWidth: 1,
        "--_color": {
          base: "var(--likec4-palette-stroke)",
          _dark: "[color-mix(in oklab, var(--likec4-palette-hiContrast) 40%, var(--likec4-palette-fill))]"
        },
        borderColor: "[var(--_color)/30]",
        backgroundColor: "var(--likec4-palette-fill)/15",
        pointerEvents: "none",
        paddingLeft: "2",
        paddingTop: "0.5",
        fontSize: "xs",
        fontWeight: "bold",
        letterSpacing: ".75px",
        color: "[var(--_color)/75]"
      },
      children: "PARALLEL"
    }
  );
}
const BuiltinNodes = {
  ElementNode,
  DeploymentNode,
  CompoundElementNode,
  CompoundDeploymentNode,
  ViewGroupNode,
  SequenceActorNode,
  SequenceParallelArea
}, BuiltinEdges = {
  RelationshipEdge: RelationshipEdge$1,
  SequenceStepEdge
};
var NOTHING = /* @__PURE__ */ Symbol.for("immer-nothing"), DRAFTABLE = /* @__PURE__ */ Symbol.for("immer-draftable"), DRAFT_STATE = /* @__PURE__ */ Symbol.for("immer-state");
function die(error, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var O$1 = Object, getPrototypeOf = O$1.getPrototypeOf, CONSTRUCTOR = "constructor", PROTOTYPE = "prototype", CONFIGURABLE = "configurable", ENUMERABLE = "enumerable", WRITABLE = "writable", VALUE = "value", isDraft = (value) => !!value && !!value[DRAFT_STATE];
function isDraftable(value) {
  return value ? isPlainObject(value) || isArray(value) || !!value[DRAFTABLE] || !!value[CONSTRUCTOR]?.[DRAFTABLE] || isMap(value) || isSet(value) : !1;
}
var objectCtorString = O$1[PROTOTYPE][CONSTRUCTOR].toString(), cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject(value) {
  if (!value || !isObjectish(value))
    return !1;
  const proto = getPrototypeOf(value);
  if (proto === null || proto === O$1[PROTOTYPE])
    return !0;
  const Ctor = O$1.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];
  if (Ctor === Object)
    return !0;
  if (!isFunction(Ctor))
    return !1;
  let ctorString = cachedCtorStrings.get(Ctor);
  return ctorString === void 0 && (ctorString = Function.toString.call(Ctor), cachedCtorStrings.set(Ctor, ctorString)), ctorString === objectCtorString;
}
function each(obj, iter, strict = !0) {
  getArchtype(obj) === 0 ? (strict ? Reflect.ownKeys(obj) : O$1.keys(obj)).forEach((key2) => {
    iter(key2, obj[key2], obj);
  }) : obj.forEach((entry, index2) => iter(index2, entry, obj));
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
var has = (thing, prop, type = getArchtype(thing)) => type === 2 ? thing.has(prop) : O$1[PROTOTYPE].hasOwnProperty.call(thing, prop), get = (thing, prop, type = getArchtype(thing)) => (
  // @ts-ignore
  type === 2 ? thing.get(prop) : thing[prop]
), set = (thing, propOrOldValue, value, type = getArchtype(thing)) => {
  type === 2 ? thing.set(propOrOldValue, value) : type === 3 ? thing.add(value) : thing[propOrOldValue] = value;
};
function is(x2, y2) {
  return x2 === y2 ? x2 !== 0 || 1 / x2 === 1 / y2 : x2 !== x2 && y2 !== y2;
}
var isArray = Array.isArray, isMap = (target) => target instanceof Map, isSet = (target) => target instanceof Set, isObjectish = (target) => typeof target == "object", isFunction = (target) => typeof target == "function", isBoolean = (target) => typeof target == "boolean";
function isArrayIndex(value) {
  const n2 = +value;
  return Number.isInteger(n2) && String(n2) === value;
}
var latest = (state) => state.copy_ || state.base_, getFinalValue = (state) => state.modified_ ? state.copy_ : state.base_;
function shallowCopy(base, strict) {
  if (isMap(base))
    return new Map(base);
  if (isSet(base))
    return new Set(base);
  if (isArray(base))
    return Array[PROTOTYPE].slice.call(base);
  const isPlain = isPlainObject(base);
  if (strict === !0 || strict === "class_only" && !isPlain) {
    const descriptors = O$1.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key2 = keys2[i2], desc = descriptors[key2];
      desc[WRITABLE] === !1 && (desc[WRITABLE] = !0, desc[CONFIGURABLE] = !0), (desc.get || desc.set) && (descriptors[key2] = {
        [CONFIGURABLE]: !0,
        [WRITABLE]: !0,
        // could live with !!desc.set as well here...
        [ENUMERABLE]: desc[ENUMERABLE],
        [VALUE]: base[key2]
      });
    }
    return O$1.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain)
      return { ...base };
    const obj = O$1.create(proto);
    return O$1.assign(obj, base);
  }
}
function freeze(obj, deep = !1) {
  return isFrozen(obj) || isDraft(obj) || !isDraftable(obj) || (getArchtype(obj) > 1 && O$1.defineProperties(obj, {
    set: dontMutateMethodOverride,
    add: dontMutateMethodOverride,
    clear: dontMutateMethodOverride,
    delete: dontMutateMethodOverride
  }), O$1.freeze(obj), deep && each(
    obj,
    (_key, value) => {
      freeze(value, !0);
    },
    !1
  )), obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  [VALUE]: dontMutateFrozenCollections
};
function isFrozen(obj) {
  return obj === null || !isObjectish(obj) ? !0 : O$1.isFrozen(obj);
}
var PluginMapSet = "MapSet", PluginPatches = "Patches", PluginArrayMethods = "ArrayMethods", plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  return plugin || die(0, pluginKey), plugin;
}
var isPluginLoaded = (pluginKey) => !!plugins[pluginKey], currentScope, getCurrentScope = () => currentScope, createScope = (parent_, immer_) => ({
  drafts_: [],
  parent_,
  immer_,
  // Whenever the modified draft contains a draft from another scope, we
  // need to prevent auto-freezing so the unowned draft can be finalized.
  canAutoFreeze_: !0,
  unfinalizedDrafts_: 0,
  handledSet_: /* @__PURE__ */ new Set(),
  processedForPatches_: /* @__PURE__ */ new Set(),
  mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0,
  arrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods) ? getPlugin(PluginArrayMethods) : void 0
});
function usePatchesInScope(scope, patchListener) {
  patchListener && (scope.patchPlugin_ = getPlugin(PluginPatches), scope.patches_ = [], scope.inversePatches_ = [], scope.patchListener_ = patchListener);
}
function revokeScope(scope) {
  leaveScope(scope), scope.drafts_.forEach(revokeDraft), scope.drafts_ = null;
}
function leaveScope(scope) {
  scope === currentScope && (currentScope = scope.parent_);
}
var enterScope = (immer2) => currentScope = createScope(currentScope, immer2);
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  state.type_ === 0 || state.type_ === 1 ? state.revoke_() : state.revoked_ = !0;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  if (result !== void 0 && result !== baseDraft) {
    baseDraft[DRAFT_STATE].modified_ && (revokeScope(scope), die(4)), isDraftable(result) && (result = finalize(scope, result));
    const { patchPlugin_ } = scope;
    patchPlugin_ && patchPlugin_.generateReplacementPatches_(
      baseDraft[DRAFT_STATE].base_,
      result,
      scope
    );
  } else
    result = finalize(scope, baseDraft);
  return maybeFreeze(scope, result, !0), revokeScope(scope), scope.patches_ && scope.patchListener_(scope.patches_, scope.inversePatches_), result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state)
    return handleValue(value, rootScope.handledSet_, rootScope);
  if (!isSameScope(state, rootScope))
    return value;
  if (!state.modified_)
    return state.base_;
  if (!state.finalized_) {
    const { callbacks_ } = state;
    if (callbacks_)
      for (; callbacks_.length > 0; )
        callbacks_.pop()(rootScope);
    generatePatchesAndFinalize(state, rootScope);
  }
  return state.copy_;
}
function maybeFreeze(scope, value, deep = !1) {
  !scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_ && freeze(value, deep);
}
function markStateFinalized(state) {
  state.finalized_ = !0, state.scope_.unfinalizedDrafts_--;
}
var isSameScope = (state, rootScope) => state.scope_ === rootScope, EMPTY_LOCATIONS_RESULT = [];
function updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {
  const parentCopy = latest(parent), parentType = parent.type_;
  if (originalKey !== void 0 && get(parentCopy, originalKey, parentType) === draftValue) {
    set(parentCopy, originalKey, finalizedValue, parentType);
    return;
  }
  if (!parent.draftLocations_) {
    const draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();
    each(parentCopy, (key2, value) => {
      if (isDraft(value)) {
        const keys2 = draftLocations.get(value) || [];
        keys2.push(key2), draftLocations.set(value, keys2);
      }
    });
  }
  const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;
  for (const location of locations)
    set(parentCopy, location, finalizedValue, parentType);
}
function registerChildFinalizationCallback(parent, child, key2) {
  parent.callbacks_.push(function(rootScope) {
    const state = child;
    if (!state || !isSameScope(state, rootScope))
      return;
    rootScope.mapSetPlugin_?.fixSetContents(state);
    const finalizedValue = getFinalValue(state);
    updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key2), generatePatchesAndFinalize(state, rootScope);
  });
}
function generatePatchesAndFinalize(state, rootScope) {
  if (state.modified_ && !state.finalized_ && (state.type_ === 3 || state.type_ === 1 && state.allIndicesReassigned_ || (state.assigned_?.size ?? 0) > 0)) {
    const { patchPlugin_ } = rootScope;
    if (patchPlugin_) {
      const basePath = patchPlugin_.getPath(state);
      basePath && patchPlugin_.generatePatches_(state, basePath, rootScope);
    }
    markStateFinalized(state);
  }
}
function handleCrossReference(target, key2, value) {
  const { scope_ } = target;
  if (isDraft(value)) {
    const state = value[DRAFT_STATE];
    isSameScope(state, scope_) && state.callbacks_.push(function() {
      prepareCopy(target);
      const finalizedValue = getFinalValue(state);
      updateDraftInParent(target, value, finalizedValue, key2);
    });
  } else isDraftable(value) && target.callbacks_.push(function() {
    const targetCopy = latest(target);
    get(targetCopy, key2, target.type_) === value && scope_.drafts_.length > 1 && (target.assigned_.get(key2) ?? !1) === !0 && target.copy_ && handleValue(
      get(target.copy_, key2, target.type_),
      scope_.handledSet_,
      scope_
    );
  });
}
function handleValue(target, handledSet, rootScope) {
  return !rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1 || isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target) || (handledSet.add(target), each(target, (key2, value) => {
    if (isDraft(value)) {
      const state = value[DRAFT_STATE];
      if (isSameScope(state, rootScope)) {
        const updatedValue = getFinalValue(state);
        set(target, key2, updatedValue, target.type_), markStateFinalized(state);
      }
    } else isDraftable(value) && handleValue(value, handledSet, rootScope);
  })), target;
}
function createProxyProxy(base, parent) {
  const baseIsArray = isArray(base), state = {
    type_: baseIsArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    // actually instantiated in `prepareCopy()`
    assigned_: void 0,
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1,
    // `callbacks` actually gets assigned in `createProxy`
    callbacks_: void 0
  };
  let target = state, traps = objectTraps;
  baseIsArray && (target = [state], traps = arrayTraps);
  const { revoke, proxy } = Proxy.revocable(target, traps);
  return state.draft_ = proxy, state.revoke_ = revoke, [proxy, state];
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    let arrayPlugin = state.scope_.arrayMethodsPlugin_;
    const isArrayWithStringProp = state.type_ === 1 && typeof prop == "string";
    if (isArrayWithStringProp && arrayPlugin?.isArrayOperationMethod(prop))
      return arrayPlugin.createMethodInterceptor(state, prop);
    const source = latest(state);
    if (!has(source, prop, state.type_))
      return readPropFromProto(state, source, prop);
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value) || isArrayWithStringProp && state.operationMethod && arrayPlugin?.isMutatingArrayMethod(
      state.operationMethod
    ) && isArrayIndex(prop))
      return value;
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      const childKey = state.type_ === 1 ? +prop : prop, childDraft = createProxy(state.scope_, value, state, childKey);
      return state.copy_[childKey] = childDraft;
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set)
      return desc.set.call(state.draft_, value), !0;
    if (!state.modified_) {
      const current2 = peek(latest(state), prop), currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value)
        return state.copy_[prop] = value, state.assigned_.set(prop, !1), !0;
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_)))
        return !0;
      prepareCopy(state), markChanged(state);
    }
    return state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]) || (state.copy_[prop] = value, state.assigned_.set(prop, !0), handleCrossReference(state, prop, value)), !0;
  },
  deleteProperty(state, prop) {
    return prepareCopy(state), peek(state.base_, prop) !== void 0 || prop in state.base_ ? (state.assigned_.set(prop, !1), markChanged(state)) : state.assigned_.delete(prop), state.copy_ && delete state.copy_[prop], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state), desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    return desc && {
      [WRITABLE]: !0,
      [CONFIGURABLE]: state.type_ !== 1 || prop !== "length",
      [ENUMERABLE]: desc[ENUMERABLE],
      [VALUE]: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
}, arrayTraps = {};
each(objectTraps, (key2, fn) => {
  arrayTraps[key2] = function() {
    const args = arguments;
    return args[0] = args[0][0], fn.apply(this, args);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  return (state ? latest(state) : draft)[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? VALUE in desc ? desc[VALUE] : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return;
  let proto = getPrototypeOf(source);
  for (; proto; ) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
}
function markChanged(state) {
  state.modified_ || (state.modified_ = !0, state.parent_ && markChanged(state.parent_));
}
function prepareCopy(state) {
  state.copy_ || (state.assigned_ = /* @__PURE__ */ new Map(), state.copy_ = shallowCopy(
    state.base_,
    state.scope_.immer_.useStrictShallowCopy_
  ));
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.useStrictIteration_ = !1, this.produce = (base, recipe, patchListener) => {
      if (isFunction(base) && !isFunction(recipe)) {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      isFunction(recipe) || die(6), patchListener !== void 0 && !isFunction(patchListener) && die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this), proxy = createProxy(scope, base, void 0);
        let hasError = !0;
        try {
          result = recipe(proxy), hasError = !1;
        } finally {
          hasError ? revokeScope(scope) : leaveScope(scope);
        }
        return usePatchesInScope(scope, patchListener), processResult(result, scope);
      } else if (!base || !isObjectish(base)) {
        if (result = recipe(base), result === void 0 && (result = base), result === NOTHING && (result = void 0), this.autoFreeze_ && freeze(result, !0), patchListener) {
          const p2 = [], ip = [];
          getPlugin(PluginPatches).generateReplacementPatches_(base, result, {
            patches_: p2,
            inversePatches_: ip
          }), patchListener(p2, ip);
        }
        return result;
      } else
        die(1, base);
    }, this.produceWithPatches = (base, recipe) => {
      if (isFunction(base))
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      let patches, inversePatches;
      return [this.produce(base, recipe, (p2, ip) => {
        patches = p2, inversePatches = ip;
      }), patches, inversePatches];
    }, isBoolean(config?.autoFreeze) && this.setAutoFreeze(config.autoFreeze), isBoolean(config?.useStrictShallowCopy) && this.setUseStrictShallowCopy(config.useStrictShallowCopy), isBoolean(config?.useStrictIteration) && this.setUseStrictIteration(config.useStrictIteration);
  }
  createDraft(base) {
    isDraftable(base) || die(8), isDraft(base) && (base = current(base));
    const scope = enterScope(this), proxy = createProxy(scope, base, void 0);
    return proxy[DRAFT_STATE].isManual_ = !0, leaveScope(scope), proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    (!state || !state.isManual_) && die(9);
    const { scope_: scope } = state;
    return usePatchesInScope(scope, patchListener), processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    i2 > -1 && (patches = patches.slice(i2 + 1));
    const applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;
    return isDraft(base) ? applyPatchesImpl(base, patches) : this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(rootScope, value, parent, key2) {
  const [draft, state] = isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent);
  return (parent?.scope_ ?? getCurrentScope()).drafts_.push(draft), state.callbacks_ = parent?.callbacks_ ?? [], state.key_ = key2, parent && key2 !== void 0 ? registerChildFinalizationCallback(parent, state, key2) : state.callbacks_.push(function(rootScope2) {
    rootScope2.mapSetPlugin_?.fixSetContents(state);
    const { patchPlugin_ } = rootScope2;
    state.modified_ && patchPlugin_ && patchPlugin_.generatePatches_(state, [], rootScope2);
  }), draft;
}
function current(value) {
  return isDraft(value) || die(10, value), currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy, strict = !0;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = !0, copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_), strict = state.scope_.immer_.shouldUseStrictIteration();
  } else
    copy = shallowCopy(value, !0);
  return each(
    copy,
    (key2, childValue) => {
      set(copy, key2, currentImpl(childValue));
    },
    strict
  ), state && (state.finalized_ = !1), copy;
}
var immer = new Immer2(), produce = immer.produce, setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer), castDraft = (value) => value;
class Rect {
  static LeftPadding = 42;
  static RightPadding = 42;
  static TopPadding = 60;
  static BottomPadding = 42;
  id;
  minX = 1 / 0;
  minY = 1 / 0;
  maxX = -1 / 0;
  maxY = -1 / 0;
  initialX;
  initialY;
  get positionAbsolute() {
    return {
      x: this.minX,
      y: this.minY
    };
  }
  get initialPositionAbsolute() {
    return {
      x: this.initialX,
      y: this.initialY
    };
  }
  set positionAbsolute(pos) {
    const x2 = Math.round(pos.x), y2 = Math.round(pos.y);
    this.maxX += x2 - this.minX, this.maxY += y2 - this.minY, this.minX = x2, this.minY = y2;
  }
  get dimensions() {
    return {
      width: Math.round(this.maxX - this.minX),
      height: Math.round(this.maxY - this.minY)
    };
  }
  get diff() {
    return {
      x: Math.round(this.positionAbsolute.x - this.initialX),
      y: Math.round(this.positionAbsolute.y - this.initialY)
    };
  }
  get isMoved() {
    return this.diff.x !== 0 || this.diff.y !== 0;
  }
  // Position relative to parent
  get position() {
    const positionAbsolute = this.positionAbsolute;
    if (!this.parent)
      return positionAbsolute;
    const parentPosition = this.parent.positionAbsolute;
    return {
      x: positionAbsolute.x - parentPosition.x,
      y: positionAbsolute.y - parentPosition.y
    };
  }
  constructor(xynode, parent = null) {
    this.id = xynode.id, this.positionAbsolute = parent ? {
      x: xynode.position.x + parent.minX,
      y: xynode.position.y + parent.minY
    } : xynode.position;
    const { width, height } = getNodeDimensions(xynode);
    this.maxX = this.minX + Math.ceil(width), this.maxY = this.minY + Math.ceil(height), this.initialX = this.positionAbsolute.x, this.initialY = this.positionAbsolute.y, parent && parent.children.push(this);
  }
}
class CompoundRect extends Rect {
  constructor(xynode, parent = null) {
    super(xynode, parent), this.parent = parent;
  }
  children = [];
}
class Leaf extends Rect {
  constructor(xynode, parent = null) {
    super(xynode, parent), this.parent = parent;
  }
}
function makeEdgeModifier(edge, anchor) {
  const controlPoints = edge.data.controlPoints ?? null;
  return (edgeLookup) => {
    const current2 = nonNullable(edgeLookup.get(edge.id), `Edge ${edge.id} not found`), { x: dx, y: dy } = anchor.diff;
    return dx === 0 && dy === 0 ? {
      id: edge.id,
      type: "replace",
      item: produce(current2, (draft) => {
        draft.data.points = edge.data.points, draft.data.controlPoints = controlPoints, draft.data.labelBBox = edge.data.labelBBox;
      })
    } : {
      id: edge.id,
      type: "replace",
      item: produce(current2, (draft) => {
        draft.data.points = t$f(edge.data.points, (pt) => [pt[0] + dx, pt[1] + dy]), controlPoints && (draft.data.controlPoints = controlPoints.map((pt) => ({
          x: pt.x + dx,
          y: pt.y + dy
        }))), edge.data.labelBBox && (draft.data.labelBBox = {
          x: edge.data.labelBBox.x + dx,
          y: edge.data.labelBBox.y + dy,
          width: edge.data.labelBBox.width,
          height: edge.data.labelBBox.height
        });
      })
    };
  };
}
function makeRelativeEdgeModifier(edge, movingRect, anchorNode, staticNode) {
  const controlPoints = edge.data.controlPoints ?? bezierControlPoints(edge.data.points), anchorV = vector(BBox.center(anchorNode)), staticV = vector(BBox.center(staticNode)), staticToAnchor = anchorV.subtract(staticV), staticToAnchorLength = staticToAnchor.length();
  return (edgeLookup) => {
    const current2 = nonNullable(edgeLookup.get(edge.id), `Edge ${edge.id} not found`), { x: dx, y: dy } = movingRect.diff;
    if (dx === 0 && dy === 0)
      return {
        id: edge.id,
        type: "replace",
        item: produce(current2, (draft) => {
          draft.data.points = edge.data.points, draft.data.controlPoints = edge.data.controlPoints, draft.data.labelBBox = edge.data.labelBBox;
        })
      };
    const d2 = vector(dx, dy), relativePoint = (pt) => {
      const p2 = vector(pt), projLength = p2.subtract(staticV).dot(staticToAnchor), coeff = t$v(projLength / staticToAnchorLength ** 2, {
        min: -1,
        max: 1
      });
      return p2.add(d2.multiply(coeff)).round().toObject();
    };
    return {
      id: edge.id,
      type: "replace",
      item: produce(current2, (draft) => {
        if (draft.data.controlPoints = controlPoints.map(relativePoint), edge.data.labelBBox) {
          draft.data.labelBBox ??= edge.data.labelBBox;
          const { x: x2, y: y2 } = relativePoint(edge.data.labelBBox);
          draft.data.labelBBox.x = x2, draft.data.labelBBox.y = y2;
        }
      })
    };
  };
}
function createLayoutConstraints(xyflowApi, editingNodeIds) {
  const { parentLookup, nodeLookup, edges } = xyflowApi.getState(), rects = /* @__PURE__ */ new Map(), ancestorsOf = new DefaultMap$1((nodeId) => {
    let parent = nodeLookup.get(nodeId)?.parentId;
    return parent ? [parent, ...ancestorsOf.get(parent)] : [];
  }), nestedOf = new DefaultMap$1((nodeId) => {
    const children2 = parentLookup.get(nodeId);
    if (!children2 || children2.size === 0)
      return /* @__PURE__ */ new Set();
    const nested = /* @__PURE__ */ new Set();
    for (const child of children2.values()) {
      nested.add(child.id);
      for (const desc of nestedOf.get(child.id))
        nested.add(desc);
    }
    return nested;
  });
  if (t$q(editingNodeIds, 2)) {
    const leafsOnly = t$s(
      editingNodeIds,
      t$n((id2) => [...nestedOf.get(id2)]),
      n(),
      (exclude) => r$d(editingNodeIds, exclude)
    );
    invariant$1(t$q(leafsOnly, 1), "All editing nodes are nested within each other"), editingNodeIds = leafsOnly;
  }
  const ancestorsOfDraggingNodes = new Set(
    editingNodeIds.flatMap((i2) => ancestorsOf.get(i2))
  ), traverse = [...nodeLookup.values()].flatMap(
    (x2) => x2.parentId ? [] : { xynode: x2, parent: null }
  );
  for (; traverse.length > 0; ) {
    const { xynode, parent } = traverse.shift();
    if (!editingNodeIds.includes(xynode.id) && ancestorsOfDraggingNodes.has(xynode.id)) {
      const rect = new CompoundRect(xynode, parent);
      rects.set(xynode.id, rect), parentLookup.get(xynode.id)?.forEach((child) => {
        traverse.push({
          xynode: child,
          parent: rect
        });
      });
      continue;
    }
    rects.set(xynode.id, new Leaf(xynode, parent));
  }
  const rectsToUpdate = [...rects.values()], edgeModifiers = /* @__PURE__ */ new Map(), findMovingAncestor = (nodeId) => rects.get(nodeId) ?? ancestorsOf.get(nodeId).map((id2) => rects.get(id2)).find((s2) => !!s2) ?? null, movingNodes = new Set(editingNodeIds.flatMap((id2) => [id2, ...nestedOf.get(id2)]));
  for (const edge of edges) {
    const isSourceMoving = movingNodes.has(edge.source), isTargetMoving = movingNodes.has(edge.target);
    if (isSourceMoving && isTargetMoving) {
      let r2 = rects.get(edge.source) ?? rects.get(edge.target) ?? findMovingAncestor(edge.source) ?? findMovingAncestor(edge.target);
      r2 && edgeModifiers.set(edge, makeEdgeModifier(edge, r2));
      continue;
    }
    if (isSourceMoving !== isTargetMoving) {
      const movingRect = findMovingAncestor(isSourceMoving ? edge.source : edge.target);
      if (!movingRect)
        continue;
      const [sourceNode, targetNode] = t$s(
        [edge.source, edge.target],
        t$f((id2) => nonNullable(nodeLookup.get(id2), `Node ${id2} not found`)),
        t$f(nodeToRect)
      ), [anchorNode, staticNode] = isSourceMoving ? [sourceNode, targetNode] : [targetNode, sourceNode];
      edgeModifiers.set(
        edge,
        makeRelativeEdgeModifier(
          edge,
          movingRect,
          anchorNode,
          staticNode
        )
      );
      continue;
    }
  }
  function applyConstraints2(targets) {
    for (const r2 of targets) {
      if (!(r2 instanceof CompoundRect))
        continue;
      applyConstraints2(r2.children);
      const childrenBB = {
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      };
      for (const child of r2.children)
        childrenBB.minX = Math.min(childrenBB.minX, child.minX), childrenBB.minY = Math.min(childrenBB.minY, child.minY), childrenBB.maxX = Math.max(childrenBB.maxX, child.maxX), childrenBB.maxY = Math.max(childrenBB.maxY, child.maxY);
      r2.minX = childrenBB.minX - Rect.LeftPadding, r2.minY = childrenBB.minY - Rect.TopPadding, r2.maxX = childrenBB.maxX + Rect.RightPadding, r2.maxY = childrenBB.maxY + Rect.BottomPadding;
    }
  }
  const _edgeModifiers = [...edgeModifiers.values()];
  function updateXYFlow() {
    applyConstraints2(rectsToUpdate);
    const nodeUpdates = rectsToUpdate.reduce((acc, r2) => (acc.push({
      id: r2.id,
      type: "position",
      dragging: !1,
      position: r2.position,
      positionAbsolute: r2.positionAbsolute
    }), r2 instanceof CompoundRect && acc.push({
      id: r2.id,
      type: "dimensions",
      setAttributes: !0,
      dimensions: r2.dimensions
    }), acc), []), { edgeLookup, triggerNodeChanges, triggerEdgeChanges } = xyflowApi.getState();
    triggerNodeChanges(nodeUpdates);
    const changes = _edgeModifiers.map((fm) => fm(edgeLookup));
    changes.length > 0 && triggerEdgeChanges(changes);
  }
  let animationFrameId = null;
  function onMove() {
    rectsToUpdate.length !== 0 && (animationFrameId ??= requestAnimationFrame(() => {
      animationFrameId = null;
      for (const id2 of editingNodeIds) {
        const rect = rects.get(id2);
        if (!rect) {
          console.warn(`Rect not found for id ${id2}`);
          continue;
        }
        const node2 = nodeLookup.get(id2);
        if (!node2) {
          console.warn(`Node not found for id ${id2}`);
          continue;
        }
        rect.positionAbsolute = node2.internals.positionAbsolute;
      }
      updateXYFlow();
    }));
  }
  return {
    rects,
    onMove,
    updateXYFlow
  };
}
function useLayoutConstraints() {
  const xystore = useXYStoreApi(), diagram = useDiagram(), solverRef = useRef(void 0);
  return useMemo(() => ({
    onNodeDragStart: (_event, xynode) => {
      diagram.startEditing("node");
      const { nodeLookup } = xystore.getState(), draggingNodes = t$s(
        Array.from(nodeLookup.values()),
        n$q((n2) => n2.dragging === !0 || n2.id === xynode.id || n2.selected === !0),
        t$f((n2) => n2.id)
      );
      t$q(draggingNodes, 1) && (solverRef.current = createLayoutConstraints(xystore, draggingNodes));
    },
    onNodeDrag: (_event) => {
      solverRef.current?.onMove();
    },
    onNodeDragStop: (_event) => {
      const moved = solverRef.current ? isome(solverRef.current.rects.values(), (r2) => r2.isMoved) : !1;
      diagram.stopEditing(moved), solverRef.current = void 0;
    }
  }), [xystore, diagram]);
}
const edgeTypes$1 = {
  relationship: BuiltinEdges.RelationshipEdge,
  "seq-step": BuiltinEdges.SequenceStepEdge
}, builtinNodes = {
  element: memoNode(BuiltinNodes.ElementNode),
  deployment: memoNode(BuiltinNodes.DeploymentNode),
  "compound-element": memoNode(BuiltinNodes.CompoundElementNode),
  "compound-deployment": memoNode(BuiltinNodes.CompoundDeploymentNode),
  "view-group": memoNode(BuiltinNodes.ViewGroupNode),
  "seq-actor": memoNode(BuiltinNodes.SequenceActorNode),
  "seq-parallel": memoNode(BuiltinNodes.SequenceParallelArea)
};
function prepareNodeTypes(nodeTypes2) {
  return !nodeTypes2 || e$a(nodeTypes2) ? builtinNodes : {
    element: nodeTypes2.element ?? builtinNodes.element,
    deployment: nodeTypes2.deployment ?? builtinNodes.deployment,
    "compound-element": nodeTypes2.compoundElement ?? builtinNodes["compound-element"],
    "compound-deployment": nodeTypes2.compoundDeployment ?? builtinNodes["compound-deployment"],
    "view-group": nodeTypes2.viewGroup ?? builtinNodes["view-group"],
    "seq-actor": nodeTypes2.seqActor ?? builtinNodes["seq-actor"],
    "seq-parallel": nodeTypes2.seqParallel ?? builtinNodes["seq-parallel"]
  };
}
const selectXYProps = ({ context: ctx, children: children2 }) => {
  const { enableReadOnly } = deriveToggledFeatures(ctx), isNotEditingEdge = enableReadOnly || children2.editor?.getSnapshot().context.editing !== "edge";
  return {
    enableReadOnly,
    initialized: ctx.initialized.xydata && ctx.initialized.xyflow,
    nodes: ctx.xynodes,
    edges: ctx.xyedges,
    pannable: ctx.pannable,
    zoomable: ctx.zoomable,
    nodesDraggable: !enableReadOnly && ctx.nodesDraggable,
    nodesSelectable: ctx.nodesSelectable && isNotEditingEdge,
    fitViewPadding: ctx.fitViewPadding,
    enableFitView: ctx.features.enableFitView,
    ...!ctx.features.enableFitView && {
      viewport: {
        x: -ctx.view.bounds.x,
        y: -ctx.view.bounds.y,
        zoom: 1
      }
    }
  };
}, equalsXYProps = (a2, b2) => a2.enableReadOnly === b2.enableReadOnly && a2.initialized === b2.initialized && a2.pannable === b2.pannable && a2.zoomable === b2.zoomable && a2.nodesDraggable === b2.nodesDraggable && a2.nodesSelectable === b2.nodesSelectable && a2.enableFitView === b2.enableFitView && shallowEqual$1(a2.fitViewPadding, b2.fitViewPadding) && shallowEqual$1(a2.nodes, b2.nodes) && shallowEqual$1(a2.edges, b2.edges) && shallowEqual$1(a2.viewport ?? null, b2.viewport ?? null);
function LikeC4DiagramXYFlow({
  background = "dots",
  reactFlowProps = {},
  children: children2,
  renderNodes
}) {
  const diagram = useDiagram();
  let {
    enableReadOnly,
    initialized,
    nodes,
    edges,
    enableFitView,
    nodesDraggable,
    nodesSelectable,
    ...props
  } = useDiagramActorSnapshot(selectXYProps, equalsXYProps);
  const {
    onNodeContextMenu,
    onCanvasContextMenu,
    onEdgeContextMenu,
    onNodeClick,
    onEdgeClick,
    onCanvasClick,
    onCanvasDblClick
  } = useDiagramEventHandlers(), isReducedGraphics = useIsReducedGraphics(), layoutConstraints = useLayoutConstraints(), $isPanning = usePanningAtom(), isPanning = useTimeout(() => {
    $isPanning.set(!0);
  }, isReducedGraphics ? 120 : 400), notPanning = useDebouncedCallback(() => {
    isPanning.clear(), $isPanning.set(!1);
  }, isReducedGraphics ? 350 : 200), onMove = useCallbackRef((event) => {
    event && ($isPanning.get() || isPanning.start(), notPanning());
  }), onMoveEnd = useCallbackRef((event, viewport) => {
    isPanning.clear(), diagram.send({
      type: "xyflow.viewportMoved",
      viewport,
      manually: !!event
    });
  }), onViewportResize = useCallbackRef(() => {
    diagram.send({ type: "xyflow.resized" });
  }), nodeTypes2 = useCustomCompareMemo(
    () => prepareNodeTypes(renderNodes),
    [renderNodes],
    depsShallowEqual
  );
  return useUpdateEffect(() => {
    console.warn("renderNodes changed - this might degrade performance");
  }, [nodeTypes2]), /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      nodes,
      edges,
      className: cx(initialized ? "initialized" : "not-initialized"),
      nodeTypes: nodeTypes2,
      edgeTypes: edgeTypes$1,
      onNodesChange: useCallbackRef((changes) => {
        diagram.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        diagram.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      background: initialized ? background : "transparent",
      fitView: !1,
      onNodeClick: useCallbackRef((e2, node2) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.nodeClick", node: node2 }), onNodeClick?.(diagram.findDiagramNode(node2.id), e2);
      }),
      onEdgeClick: useCallbackRef((e2, edge) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.edgeClick", edge }), onEdgeClick?.(diagram.findDiagramEdge(edge.id), e2);
      }),
      onEdgeDoubleClick: useCallbackRef((e2, edge) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.edgeDoubleClick", edge });
      }),
      onPaneClick: useCallbackRef((e2) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.paneClick" }), onCanvasClick?.(e2);
      }),
      onDoubleClick: useCallbackRef((e2) => {
        e2.stopPropagation(), e2.preventDefault(), diagram.send({ type: "xyflow.paneDblClick" }), onCanvasDblClick?.(e2);
      }),
      onNodeMouseEnter: useCallbackRef((event, node2) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.nodeMouseEnter", node: node2 });
      }),
      onNodeMouseLeave: useCallbackRef((event, node2) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.nodeMouseLeave", node: node2 });
      }),
      onEdgeMouseEnter: useCallbackRef((event, edge) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.edgeMouseEnter", edge, event });
      }),
      onEdgeMouseLeave: useCallbackRef((event, edge) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.edgeMouseLeave", edge, event });
      }),
      onMove,
      onMoveEnd,
      onInit: useCallbackRef((instance) => {
        diagram.send({ type: "xyflow.init", instance });
      }),
      onNodeContextMenu: useCallbackRef((event, node2) => {
        const diagramNode = nonNullable(
          diagram.findDiagramNode(node2.id),
          `diagramNode ${node2.id} not found`
        );
        onNodeContextMenu?.(diagramNode, event);
      }),
      onEdgeContextMenu: useCallbackRef((event, edge) => {
        const diagramEdge = nonNullable(
          diagram.findDiagramEdge(edge.id),
          `diagramEdge ${edge.id} not found`
        );
        onEdgeContextMenu?.(diagramEdge, event);
      }),
      ...onCanvasContextMenu && {
        onPaneContextMenu: onCanvasContextMenu
      },
      ...enableFitView && {
        onViewportResize
      },
      nodesDraggable,
      nodesSelectable,
      elevateEdgesOnSelect: !enableReadOnly,
      zIndexMode: "manual",
      ...nodesDraggable && layoutConstraints,
      ...props,
      ...reactFlowProps,
      children: children2
    }
  );
}
function applyChangesToManualLayout(manualView, latestView) {
  try {
    return setAutoFreeze(!1), _applyChangesToManualLayout(manualView, latestView);
  } finally {
    setAutoFreeze(!0);
  }
}
const isRootNode = (node2) => e$5(node2.parent);
function _applyChangesToManualLayout(manualView, latestView) {
  invariant$2(manualView.id === latestView.id, "View IDs do not match"), invariant$2(manualView._type === latestView._type, "View types do not match"), invariant$2(manualView._layout === "manual" && latestView._layout === "auto", "Views must be manual and auto");
  const compounds = /* @__PURE__ */ new Set(), newnodes = /* @__PURE__ */ new Set(), isNotCompound = (node2) => !compounds.has(typeof node2 == "string" ? node2 : node2.id), isBetweenNewLeafNodes = (edge) => newnodes.has(edge.source) && newnodes.has(edge.target) && isNotCompound(edge.source) && isNotCompound(edge.target), nodesMap = new Map(
    latestView.nodes.map((latest2) => {
      latest2.children && latest2.children.length > 0 && compounds.add(latest2.id);
      const manual = manualView.nodes.find((n2) => n2.id === latest2.id);
      return manual ? [latest2.id, applyFromManualNode({ latest: latest2, manual })] : (newnodes.add(latest2.id), [latest2.id, removeDrift(latest2)]);
    })
  );
  if (newnodes.size === nodesMap.size)
    return produce(latestView, (draft) => {
      draft._layout = "manual", draft.nodes = castDraft([...nodesMap.values()]), draft.edges = castDraft(latestView.edges.map(removeDrift)), delete draft.drifts;
    });
  compounds.size > 0 && expandCompoundNodes(nodesMap);
  const nodes = [...nodesMap.values()], edges = latestView.edges.map((latest2) => {
    const dir = latest2.dir ?? "forward", hasSameEndpoints = (candidate) => candidate.source === latest2.source && candidate.target === latest2.target && (candidate.dir === dir || !candidate.dir && !latest2.dir);
    let manual = manualView.edges.find((e2) => e2.id === latest2.id && hasSameEndpoints(e2));
    if (manual || (manual = manualView.edges.find((e2) => hasSameEndpoints(e2))), manual)
      return applyFromManualEdge({
        latest: latest2,
        manual
      });
    if (isBetweenNewLeafNodes(latest2))
      return removeDrift(latest2);
    const sourceNode = nodesMap.get(latest2.source), targetNode = nodesMap.get(latest2.target);
    return makeAsStraightLine(latest2, sourceNode, targetNode);
  }), bounds = BBox$2.merge(...nodes.filter(isRootNode));
  return produce(latestView, (draft) => {
    draft._layout = "manual", draft.nodes = castDraft(nodes), draft.edges = castDraft(edges), draft.bounds = bounds, delete draft.drifts;
  });
}
const COMPOUND_PADDING = {
  Left: 42,
  Right: 42,
  Top: 60,
  Bottom: 42
};
function expandCompoundNodes(nodes) {
  function expand(nodeId) {
    const node2 = nonNullable(nodes.get(nodeId), `Node ${nodeId} not found`);
    if (node2.children.length === 0)
      return node2;
    const childBBoxes = [];
    for (const childId of node2.children)
      childBBoxes.push(
        expand(childId)
      );
    const childrenBBox = BBox$2.merge(...childBBoxes);
    return node2.x = childrenBBox.x - COMPOUND_PADDING.Left, node2.y = childrenBBox.y - COMPOUND_PADDING.Top, node2.width = childrenBBox.width + COMPOUND_PADDING.Left + COMPOUND_PADDING.Right, node2.height = childrenBBox.height + COMPOUND_PADDING.Top + COMPOUND_PADDING.Bottom, node2;
  }
  for (const node2 of nodes.values())
    !isRootNode(node2) || node2.children.length === 0 || expand(node2.id);
}
function applyFromManualNode({ latest: latest2, manual }) {
  return invariant$2(manual.id === latest2.id, "Node IDs do not match"), produce(latest2, (next) => {
    next.x = manual.x, next.y = manual.y, next.drifts = null;
  });
}
function applyFromManualEdge(edges) {
  const { manual, latest: latest2 } = edges;
  return produce(latest2, (draft) => {
    manual.controlPoints ? draft.controlPoints = manual.controlPoints : delete draft.controlPoints, draft.points = castDraft(manual.points), manual.labelBBox && (draft.labelBBox = latest2.labelBBox ?? manual.labelBBox, draft.labelBBox.x = manual.labelBBox.x, draft.labelBBox.y = manual.labelBBox.y), draft.drifts = null;
  });
}
function removeDrift(object2) {
  if ("drifts" in object2 && object2.drifts !== null) {
    const result = { ...object2 };
    return result.drifts = null, result;
  }
  return object2;
}
function makeAsStraightLine(edge, sourceNode, targetNode) {
  const controlPoints = edgeControlPoints(sourceNode, targetNode), labelPos = controlPoints[0];
  return produce(edge, (draft) => {
    draft.controlPoints = controlPoints, edge.labelBBox && (draft.labelBBox.x = labelPos.x, draft.labelBBox.y = labelPos.y), delete draft.drifts;
  });
}
function getBorderPointOnVector$1(node2, nodeCenter, v2) {
  const xScale = node2.width / 2 / v2.x, yScale = node2.height / 2 / v2.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v2).multiply(scale2).add(nodeCenter);
}
function edgeControlPoints(source, target) {
  const sourceCenter = vector(BBox$2.center(source)), targetCenter = vector(BBox$2.center(target));
  if (source === target) {
    const centerOfTopBoundary = vector(0, source.height || 0).multiply(-0.5).add(sourceCenter);
    return [
      centerOfTopBoundary.add(vector(-80 / 2.5, -80)).round().toObject(),
      centerOfTopBoundary.add(vector(80 / 2.5, -80)).round().toObject()
    ];
  }
  const sourceToTargetVector = targetCenter.subtract(sourceCenter), sourceBorderPoint = getBorderPointOnVector$1(source, sourceCenter, sourceToTargetVector), sourceToTarget = getBorderPointOnVector$1(target, targetCenter, sourceToTargetVector.multiply(-1)).subtract(sourceBorderPoint);
  return [
    sourceBorderPoint.add(sourceToTarget.multiply(0.4)).round().toObject(),
    sourceBorderPoint.add(sourceToTarget.multiply(0.6)).round().toObject()
  ];
}
const LikeC4EditorReactContext = createContext(null);
function LikeC4EditorProvider({ children: children2, editor }) {
  return /* @__PURE__ */ jsx(LikeC4EditorReactContext.Provider, { value: editor, children: children2 });
}
function useOptionalLikeC4EditorPort() {
  return useContext(LikeC4EditorReactContext);
}
function useEditorActorLogic(viewId) {
  const port = useOptionalLikeC4EditorPort(), applyLatest2 = useCallbackRef(
    async ({ input: { viewId: viewId2, current: current2 } }) => {
      if (!port)
        return console.error("No editor port available for applying latest to manual layout"), Promise.reject(new Error("No editor port"));
      const [manual, latest2] = await Promise.all([
        current2 ?? Promise.resolve().then(() => port.fetchView(viewId2, "manual")),
        Promise.resolve().then(() => port.fetchView(viewId2, "auto"))
      ]).catch((err) => (console.error("Failed to fetch views for applying latest to manual layout", err), Promise.reject(err)));
      return {
        updated: applyChangesToManualLayout(manual, latest2)
      };
    }
  ), executeChange2 = useCallbackRef(
    async ({ input: input2 }) => {
      if (!port)
        return console.error("No editor port available for executing change"), Promise.reject(new Error("No editor port"));
      for (const change2 of input2.changes)
        await Promise.resolve().then(() => port.handleChange(viewId, change2)).catch((err) => (console.error("Failed to execute change", {
          change: change2,
          err
        }), Promise.reject(err)));
      return {};
    }
  );
  return editorActorLogic.provide({
    actors: {
      applyLatest: fromPromise(applyLatest2),
      executeChange: fromPromise(executeChange2)
    }
  });
}
function makeDiagramApi(actorRef) {
  return {
    ref: actorRef,
    get actor() {
      return actorRef.current;
    },
    overlays() {
      return nonNullable$1(actorRef.current.getSnapshot().children.overlays, "Overlays actor not found");
    },
    send: (event) => actorRef.current.send(event),
    navigateTo: (viewId, fromNode, focusOnElement) => {
      actorRef.current.send({
        type: "navigate.to",
        viewId,
        ...fromNode && { fromNode },
        ...focusOnElement && { focusOnElement }
      });
    },
    navigate: (direction) => {
      actorRef.current.send({ type: `navigate.${direction}` });
    },
    fitDiagram: (duration = 350) => {
      actorRef.current.send({ type: "xyflow.fitDiagram", duration });
    },
    openRelationshipsBrowser: (fqn2) => {
      actorRef.current.send({ type: "open.relationshipsBrowser", fqn: fqn2 });
    },
    openSource: (params) => {
      actorRef.current.send({ type: "open.source", ...params });
    },
    openElementDetails: (fqn2, fromNode) => {
      actorRef.current.send({ type: "open.elementDetails", fqn: fqn2, fromNode });
    },
    openRelationshipDetails: (...params) => {
      params.length === 1 ? actorRef.current.send({ type: "open.relationshipDetails", params: { edgeId: params[0] } }) : actorRef.current.send({ type: "open.relationshipDetails", params: { source: params[0], target: params[1] } });
    },
    updateNodeData: (nodeId, data) => {
      actorRef.current.send({ type: "update.nodeData", nodeId, data });
    },
    updateEdgeData: (edgeId, data) => {
      actorRef.current.send({ type: "update.edgeData", edgeId, data });
    },
    startEditing: (subject) => {
      const editorActor = typedSystem(actorRef.current.system).editorActorRef;
      invariant$1(editorActor, "No editor actor found in diagram actor system"), editorActor.send({ type: "edit.start", subject });
    },
    stopEditing: (wasChanged = !1) => {
      const editorActor = typedSystem(actorRef.current.system).editorActorRef;
      invariant$1(editorActor, "No editor actor found in diagram actor system"), editorActor.send({ type: "edit.finish", wasChanged });
    },
    undoEditing: () => {
      const editorActor = typedSystem(actorRef.current.system).editorActorRef;
      invariant$1(editorActor, "No editor actor found in diagram actor system");
      const hasUndo = editorActor.getSnapshot().context.history.length > 0;
      return hasUndo && editorActor.send({ type: "undo" }), hasUndo;
    },
    align: (mode) => {
      actorRef.current.send({ type: "layout.align", mode });
    },
    resetEdgeControlPoints: () => {
      actorRef.current.send({ type: "layout.resetEdgeControlPoints" });
    },
    focusNode: (nodeId) => {
      actorRef.current.send({ type: "focus.node", nodeId });
    },
    focusOnElement: (elementFqn) => {
      const context2 = actorRef.current.getSnapshot().context, node2 = findNodeByModelFqn(context2.xynodes, elementFqn);
      node2 && actorRef.current.send({ type: "focus.node", nodeId: node2.id, autoUnfocus: !0 });
    },
    /**
     * @warning Do not use in render phase
     */
    get currentView() {
      return actorRef.current.getSnapshot().context.view;
    },
    /**
     * @warning Do not use in render phase
     */
    getContext: () => actorRef.current.getSnapshot().context,
    /**
     * @warning Do not use in render phase
     */
    findDiagramNode: (xynodeId) => findDiagramNode(actorRef.current.getSnapshot().context, xynodeId),
    findEdge: (xyedgeId) => actorRef.current.getSnapshot().context.xyedges.find((e2) => e2.data.id === xyedgeId) ?? null,
    /**
     * @warning Do not use in render phase
     */
    findDiagramEdge: (xyedgeId) => findDiagramEdge(actorRef.current.getSnapshot().context, xyedgeId),
    startWalkthrough: () => {
      actorRef.current.send({ type: "walkthrough.start" });
    },
    walkthroughStep: (direction = "next") => {
      actorRef.current.send({ type: "walkthrough.step", direction });
    },
    stopWalkthrough: () => {
      actorRef.current.send({ type: "walkthrough.end" });
    },
    toggleFeature: (feature, forceValue) => {
      actorRef.current.send({ type: "toggle.feature", feature, ...forceValue !== void 0 && { forceValue } });
    },
    highlightNotation: (notation, kind) => {
      actorRef.current.send({ type: "notations.highlight", notation, ...kind && { kind } });
    },
    unhighlightNotation: () => {
      actorRef.current.send({ type: "notations.unhighlight" });
    },
    openSearch: (searchValue) => {
      actorRef.current.send({ type: "open.search", ...searchValue && { search: searchValue } });
    },
    triggerChange: (change2) => {
      actorRef.current.send({ type: "trigger.change", change: change2 });
    },
    switchDynamicViewVariant: (variant) => {
      actorRef.current.send({ type: "switch.dynamicViewVariant", variant });
    }
  };
}
function mergeXYNodesEdges(context2, event) {
  const nextView = event.view, isSameView = context2.view.id === nextView.id;
  if (nextView._type === "dynamic" && nextView.variant === "sequence")
    return {
      xynodes: event.xynodes,
      xyedges: event.xyedges,
      view: nextView
    };
  const xynodes = updateNodes(context2.xynodes, event.xynodes), xyedges = isSameView ? updateEdges(context2.xyedges, event.xyedges) : event.xyedges;
  return {
    xynodes,
    xyedges,
    view: nextView
  };
}
function focusNodesEdges(context2) {
  const { xynodes: _xynodes, xyedges: _xyedges, focusedNode } = context2;
  if (!focusedNode)
    return null;
  const focused2 = /* @__PURE__ */ new Set([focusedNode]), xyedges = _xyedges.map((edge) => edge.source === focusedNode || edge.target === focusedNode ? (focused2.add(edge.source), focused2.add(edge.target), Base.setData(edge, {
    dimmed: !1,
    active: !0
  })) : Base.setData(edge, {
    dimmed: !0,
    active: !1
  }));
  return {
    xynodes: _xynodes.map((n2) => Base.setDimmed(n2, !focused2.has(n2.id))),
    xyedges
  };
}
function updateNodeData({ context: context2, event }) {
  return assertEvent(event, "update.nodeData"), { xynodes: context2.xynodes.map((node2) => {
    if (node2.id !== event.nodeId)
      return node2;
    const data = n$d(node2.data, event.data);
    return deepEqual$1(data, node2.data) ? node2 : {
      ...node2,
      data
    };
  }) };
}
function updateEdgeData({ context: context2, event }) {
  return assertEvent(event, "update.edgeData"), { xyedges: context2.xyedges.map((edge) => {
    if (edge.id !== event.edgeId)
      return edge;
    const data = n$d(edge.data, event.data);
    return deepEqual$1(data, edge.data) ? edge : {
      ...edge,
      data
    };
  }) };
}
function getBorderPointOnVector(node2, nodeCenter, v2) {
  const dimensions = getNodeDimensions(node2), xScale = dimensions.width / 2 / v2.x, yScale = dimensions.height / 2 / v2.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v2).multiply(scale2).add(nodeCenter);
}
function resetEdgeControlPoints(nodeLookup, edge) {
  const source = nonNullable(nodeLookup.get(edge.source), `Source node ${edge.source} not found`), target = nonNullable(nodeLookup.get(edge.target), `Target node ${edge.target} not found`), sourceCenter = vector(getNodeCenter(source)), targetCenter = vector(getNodeCenter(target));
  if (source === target) {
    const centerOfTopBoundary = vector(0, source.height || 0).multiply(-0.5).add(sourceCenter);
    return [
      centerOfTopBoundary.add(vector(-80 / 2.5, -80)).round().toObject(),
      centerOfTopBoundary.add(vector(80 / 2.5, -80)).round().toObject()
    ];
  }
  const sourceToTargetVector = targetCenter.subtract(sourceCenter), sourceBorderPoint = getBorderPointOnVector(source, sourceCenter, sourceToTargetVector), sourceToTarget = getBorderPointOnVector(target, targetCenter, sourceToTargetVector.multiply(-1)).subtract(sourceBorderPoint);
  return [
    sourceBorderPoint.add(sourceToTarget.multiply(0.4)).round().toObject(),
    sourceBorderPoint.add(sourceToTarget.multiply(0.6)).round().toObject()
  ];
}
function diagramToXY(opts) {
  const {
    view
  } = opts, xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  ));
  let visiblePredicate = (_nodeOrEdge) => !0;
  if (opts.where)
    try {
      const filterablePredicate = whereOperatorAsPredicate(opts.where);
      visiblePredicate = (i2) => filterablePredicate({
        ...t$9(i2, ["tags", "kind"]),
        ..."source" in i2 ? { source: nodeById(i2.source) } : i2,
        ..."target" in i2 ? { target: nodeById(i2.target) } : i2
      });
    } catch (e2) {
      console.error("Error in where filter:", e2);
    }
  const ns = "", nodeById = (id2) => nonNullable(nodeLookup.get(id2), `Node not found: ${id2}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = t$q(node2.children, 1) || node2.kind == GroupElementKind;
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.x,
      y: node2.y
    };
    parent && (position.x -= parent.x, position.y -= parent.y);
    const base = {
      id: ns + node2.id,
      deletable: !1,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      hidden: node2.kind !== GroupElementKind && !visiblePredicate(node2),
      ...parent && {
        parentId: ns + parent.id
      }
    }, compoundData = {
      viewId: view.id,
      id: node2.id,
      title: node2.title,
      color: node2.color,
      shape: node2.shape,
      style: node2.style,
      depth: node2.depth ?? 0,
      icon: node2.icon ?? "none",
      tags: node2.tags ?? null,
      x: node2.x,
      y: node2.y,
      drifts: node2.drifts ?? null
    }, leafNodeData = {
      viewId: view.id,
      id: node2.id,
      title: node2.title,
      technology: node2.technology ?? null,
      description: node2.description ?? null,
      height: node2.height,
      width: node2.width,
      level: node2.level,
      color: node2.color,
      shape: node2.shape,
      style: node2.style,
      icon: node2.icon ?? null,
      tags: node2.tags,
      x: node2.x,
      y: node2.y,
      isMultiple: node2.style?.multiple ?? !1,
      drifts: node2.drifts ?? null
    };
    if (node2.kind === GroupElementKind) {
      xynodes.push({
        ...base,
        type: "view-group",
        data: {
          isViewGroup: !0,
          ...compoundData
        },
        dragHandle: ".likec4-compound-title-container"
      });
      continue;
    }
    const modelFqn = node2.modelRef ?? null, deploymentFqn = node2.deploymentRef ?? null;
    if (!modelFqn && !deploymentFqn)
      throw console.error("Invalid node", node2), new Error("Element should have either modelRef or deploymentRef");
    const navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case (isCompound && !!deploymentFqn): {
        xynodes.push(
          {
            ...base,
            type: "compound-deployment",
            data: {
              ...compoundData,
              ...navigateTo,
              deploymentFqn,
              modelFqn
            }
          }
        );
        break;
      }
      case isCompound: {
        invariant$2(!!modelFqn, "ModelRef expected"), xynodes.push(
          {
            ...base,
            type: "compound-element",
            data: {
              ...compoundData,
              ...navigateTo,
              modelFqn
            }
          }
        );
        break;
      }
      case !!deploymentFqn: {
        xynodes.push(
          {
            ...base,
            type: "deployment",
            data: {
              ...leafNodeData,
              ...navigateTo,
              deploymentFqn,
              modelFqn
            }
          }
        );
        break;
      }
      default:
        invariant$2(!!modelFqn, "ModelRef expected"), xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              ...leafNodeData,
              ...navigateTo,
              modelFqn
            }
          }
        );
    }
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id2 = ns + edge.id;
    if (!t$q(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    xyedges.push({
      id: id2,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      zIndex: ZIndexes.Edge,
      hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        id: edge.id,
        label: edge.label,
        technology: edge.technology,
        notes: edge.notes ?? null,
        navigateTo: edge.navigateTo,
        controlPoints: edge.controlPoints ?? null,
        labelBBox: edge.labelBBox ?? null,
        labelXY: null,
        points: edge.points,
        color: edge.color ?? "gray",
        line: edge.line ?? "dashed",
        dir: edge.dir ?? "forward",
        head: edge.head ?? "normal",
        tail: edge.tail ?? "none",
        astPath: edge.astPath,
        drifts: edge.drifts ?? null
      },
      interactionWidth: 20
    });
  }
  return {
    bounds: view.bounds,
    xynodes,
    xyedges
  };
}
const SeqZIndex = {
  parallel: 1,
  actor: 10
}, SeqParallelAreaColor = {
  default: "gray",
  active: "amber"
};
function sequenceLayoutToXY(view) {
  const { actors, steps, compounds, parallelAreas, bounds } = view.sequenceLayout, xynodes = [], xyedges = [], getNode = (id2) => nonNullable(view.nodes.find((n2) => n2.id === id2));
  for (const compound of compounds)
    xynodes.push(toCompoundArea(compound, getNode(compound.origin), view));
  for (const parallelArea of parallelAreas)
    xynodes.push(toSeqParallelArea(parallelArea, view));
  for (const actor of actors)
    xynodes.push(toSeqActorNode(actor, getNode(actor.id), bounds, view));
  for (const step of steps) {
    const edge = view.edges.find((e2) => e2.id === step.id);
    if (!edge)
      throw new Error(`Edge ${step.id} not found`);
    xyedges.push(toSeqStepEdge(step, edge));
  }
  return {
    bounds,
    xynodes,
    xyedges
  };
}
function toCompoundArea({ id: id2, x: x2, y: y2, width, height, depth }, node2, view) {
  return {
    id: id2,
    type: "view-group",
    data: {
      id: node2.id,
      title: node2.title,
      color: node2.color ?? "gray",
      shape: node2.shape,
      style: node2.style,
      tags: node2.tags,
      x: x2,
      y: y2,
      viewId: view.id,
      depth,
      isViewGroup: !0,
      drifts: node2.drifts ?? null
    },
    // zIndex: SeqZIndex.compound,
    position: {
      x: x2,
      y: y2
    },
    draggable: !1,
    selectable: !1,
    focusable: !1,
    style: {
      pointerEvents: "none"
    },
    width,
    initialWidth: width,
    height,
    initialHeight: height
  };
}
function toSeqParallelArea({ parallelPrefix, x: x2, y: y2, width, height }, view) {
  return {
    id: `seq-parallel-${parallelPrefix}`,
    type: "seq-parallel",
    data: {
      id: `seq-parallel-${parallelPrefix}`,
      title: "PARALLEL",
      technology: null,
      color: SeqParallelAreaColor.default,
      shape: "rectangle",
      style: {},
      tags: [],
      x: x2,
      y: y2,
      level: 0,
      icon: null,
      width,
      height,
      description: null,
      viewId: view.id,
      parallelPrefix,
      drifts: null
    },
    zIndex: SeqZIndex.parallel,
    position: {
      x: x2,
      y: y2
    },
    draggable: !1,
    deletable: !1,
    selectable: !1,
    focusable: !1,
    style: {
      pointerEvents: "none"
    },
    width,
    initialWidth: width,
    height,
    initialHeight: height
  };
}
function toSeqActorNode({ id: id2, x: x2, y: y2, width, height, ports }, actor, bounds, view) {
  return {
    id: id2,
    type: "seq-actor",
    data: {
      id: actor.id,
      x: x2,
      y: y2,
      level: 0,
      icon: actor.icon ?? null,
      isMultiple: actor.style.multiple ?? !1,
      title: actor.title,
      width,
      height,
      color: actor.color,
      navigateTo: actor.navigateTo ?? null,
      shape: actor.shape,
      style: actor.style,
      tags: actor.tags,
      modelFqn: actor.modelRef ?? null,
      technology: actor.technology ?? null,
      description: actor.description ?? null,
      viewHeight: bounds.height,
      viewId: view.id,
      ports,
      drifts: actor.drifts ?? null
    },
    deletable: !1,
    selectable: !0,
    zIndex: SeqZIndex.actor,
    position: { x: x2, y: y2 },
    width,
    initialWidth: width,
    height,
    initialHeight: height
  };
}
function toSeqStepEdge({ id: id2, labelBBox, sourceHandle, targetHandle }, edge) {
  return {
    id: id2,
    type: "seq-step",
    data: {
      id: id2,
      label: edge.label,
      technology: edge.technology,
      notes: edge.notes ?? null,
      navigateTo: edge.navigateTo,
      controlPoints: null,
      labelBBox: {
        x: 0,
        y: 0,
        width: labelBBox?.width ?? edge.labelBBox?.width ?? 32,
        height: labelBBox?.height ?? edge.labelBBox?.height ?? 32
      },
      labelXY: null,
      points: edge.points,
      color: edge.color,
      line: edge.line,
      dir: "forward",
      head: edge.head ?? "normal",
      tail: edge.tail ?? "none",
      astPath: edge.astPath,
      drifts: edge.drifts ?? null
    },
    selectable: !0,
    focusable: !1,
    zIndex: 20,
    interactionWidth: 40,
    source: edge.source,
    sourceHandle,
    target: edge.target,
    targetHandle
  };
}
function convertToXYFlow({ dynamicViewVariant, ...params }) {
  const view = params.view, isDynamic = view._type === "dynamic", { bounds, xynodes, xyedges } = isDynamic && dynamicViewVariant === "sequence" ? sequenceLayoutToXY(view) : diagramToXY(params);
  return isDynamic && view.variant !== dynamicViewVariant ? {
    view: {
      ...view,
      bounds,
      variant: dynamicViewVariant
    },
    xynodes,
    xyedges
  } : {
    view: bounds === view.bounds ? view : {
      ...view,
      bounds
    },
    xynodes,
    xyedges
  };
}
class Aligner {
}
class LinearAligner extends Aligner {
  constructor(getEdgePosition2, computePosition2, propertyToEdit) {
    super(), this.getEdgePosition = getEdgePosition2, this.computePosition = computePosition2, this.propertyToEdit = propertyToEdit;
  }
  alignTo;
  computeLayout(nodes) {
    this.alignTo = this.getEdgePosition(nodes);
  }
  applyPosition(node2) {
    return {
      [this.propertyToEdit]: this.computePosition(this.alignTo, node2)
    };
  }
}
class GridAligner extends Aligner {
  layout = /* @__PURE__ */ new Map();
  axisPreset;
  get primaryAxisCoord() {
    return this.axisPreset.primaryAxisCoord;
  }
  get secondaryAxisCoord() {
    return this.axisPreset.secondaryAxisCoord;
  }
  get primaryAxisDimension() {
    return this.axisPreset.primaryAxisDimension;
  }
  get secondaryAxisDimension() {
    return this.axisPreset.secondaryAxisDimension;
  }
  constructor(alignmentMode) {
    super(), this.axisPreset = alignmentMode === "Column" ? {
      primaryAxisDimension: "width",
      secondaryAxisDimension: "height",
      primaryAxisCoord: "x",
      secondaryAxisCoord: "y"
    } : {
      primaryAxisDimension: "height",
      secondaryAxisDimension: "width",
      primaryAxisCoord: "y",
      secondaryAxisCoord: "x"
    };
  }
  applyPosition(node2) {
    return this.layout?.get(node2.id) ?? {};
  }
  computeLayout(nodes) {
    const sortedNodeRects = t$s(
      nodes,
      t$2((r2) => r2[this.primaryAxisCoord])
    ), layoutRect = this.getLayoutRect(sortedNodeRects), layers = this.getLayers(sortedNodeRects);
    this.layout = this.buildLayout(layers, layoutRect, sortedNodeRects);
  }
  getLayoutRect(nodeRects) {
    const x2 = Math.min(...nodeRects.map((n2) => n2.x)), y2 = Math.min(...nodeRects.map((n2) => n2.y)), right = Math.max(...nodeRects.map((n2) => n2.x + n2.width)), bottom = Math.max(...nodeRects.map((n2) => n2.y + n2.height));
    return {
      x: x2,
      y: y2,
      width: right - x2,
      height: bottom - y2
    };
  }
  getLayers(sortedNodeRects) {
    const layers = [];
    let layerEnd = 0, layer = null;
    for (let node2 of sortedNodeRects)
      if (layer && node2[this.primaryAxisCoord] < layerEnd)
        layer.nodes.push(node2), layer.primaryAxisSize = Math.max(layer.primaryAxisSize, node2[this.primaryAxisDimension]), layer.occupiedSpace += node2[this.secondaryAxisDimension], layerEnd = Math.max(
          node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension],
          layerEnd
        );
      else {
        layer = {
          primaryAxisSize: node2[this.primaryAxisDimension],
          nodes: [node2],
          occupiedSpace: node2[this.secondaryAxisDimension],
          layout: null
        }, layers.push(layer), layerEnd = node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension];
        continue;
      }
    return layers.forEach((l) => l.nodes.sort((a2, b2) => a2[this.secondaryAxisCoord] - b2[this.secondaryAxisCoord])), layers;
  }
  buildLayout(layers, layoutRect, nodeRects) {
    const nodeMap = new Map(nodeRects.map((n2) => [n2.id, n2])), layout2 = [], occupiedSpace = layers.reduce((a2, b2) => a2 + b2.primaryAxisSize, 0), rowMargin = layers.length > 1 ? (layoutRect[this.primaryAxisDimension] - occupiedSpace) / (layers.length - 1) : 0, baseLayerIndex = layers.reduce(
      (widestLayerIndex, layer, i2) => layers[widestLayerIndex].occupiedSpace < layer.occupiedSpace ? i2 : widestLayerIndex,
      0
    ), baseLayer = layers[baseLayerIndex], baseLayerPosition = layers.slice(0, baseLayerIndex).reduce(
      (a2, layer) => a2 + layer.primaryAxisSize + rowMargin,
      layoutRect[this.primaryAxisCoord]
    ), baseLayerLayout = this.buildLayerLayout(
      baseLayer,
      layoutRect,
      baseLayerPosition,
      nodeMap,
      null
    );
    baseLayer.layout = baseLayerLayout, layout2.push(...baseLayerLayout.nodePositions);
    let placeNextLayerAt = baseLayerPosition + baseLayer.primaryAxisSize + rowMargin, refLayer = baseLayer;
    for (let i2 = baseLayerIndex + 1; i2 < layers.length; i2++) {
      const layer = layers[i2];
      layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer, placeNextLayerAt += layer.primaryAxisSize + rowMargin;
    }
    placeNextLayerAt = baseLayerPosition, refLayer = baseLayer;
    for (let i2 = baseLayerIndex - 1; i2 >= 0; i2--) {
      const layer = layers[i2];
      placeNextLayerAt -= layer.primaryAxisSize + rowMargin, layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout2.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer;
    }
    return new Map(layout2);
  }
  buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer) {
    let bestLayerLayout = this.scoreLayout(
      this.spaceAround(layer, layoutRect, placeNextLayerAt),
      nodeMap
    );
    if (layer.nodes.length != 1) {
      const currentlayerLayout = this.scoreLayout(
        this.spaceBetween(layer, layoutRect, placeNextLayerAt),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length - 1 >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInGaps(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInCells(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    return bestLayerLayout[1];
  }
  spaceBetween(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length - 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord];
    const result = /* @__PURE__ */ new Map();
    for (let node2 of layer.nodes)
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  spaceAround(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length + 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord] + margin;
    const result = /* @__PURE__ */ new Map();
    for (let node2 of t$2(layer.nodes, (n2) => n2[this.secondaryAxisCoord]))
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  placeInGaps(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getGapsPositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  placeInCells(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getNodePositions(refLayer);
    let optionIndex = 0;
    for (let i2 = 0, node2 = nodes[i2]; i2 < nodes.length; i2++, node2 = nodes[i2]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i2 <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  scoreLayout(layout2, originalRects) {
    return [
      t$s(
        Array.from(layout2.nodePositions),
        t$f(([id2, position]) => {
          const originalRect = originalRects.get(id2);
          return invariant$2(originalRect, `Could not find original rect for node ${id2}`), [t$9(originalRect, ["x", "y"]), position];
        }),
        t$f(
          ([original, suggested]) => Math.abs(original[this.secondaryAxisCoord] - suggested[this.secondaryAxisCoord])
        ),
        t$5((a2, b2) => a2 + b2, 0)
      ),
      layout2
    ];
  }
  getGapsPositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$2(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 1; i2 < nodes.length; i2++) {
      const previousNode = nodes[i2 - 1], currentNode = nodes[i2], previousNodePosition = layout2.nodePositions.get(previousNode.id), currentNodePosition = layout2.nodePositions.get(currentNode.id);
      result.push(
        (currentNodePosition[this.secondaryAxisCoord] + previousNodePosition[this.secondaryAxisCoord] + previousNode[this.secondaryAxisDimension]) / 2
      );
    }
    return result;
  }
  getNodePositions(layer) {
    const result = [], { layout: layout2, nodes } = layer;
    invariant$2(layout2, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node2 = nodes[i2], nodePosition = layout2.nodePositions.get(node2.id);
      result.push(
        nodePosition[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2
      );
    }
    return result;
  }
}
function getLinearAligner(mode) {
  switch (mode) {
    case "Left":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x)),
        (alignTo, _) => Math.floor(alignTo),
        "x"
      );
    case "Top":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y)),
        (alignTo, _) => Math.floor(alignTo),
        "y"
      );
    case "Right":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.x + n2.width)),
        (alignTo, node2) => Math.floor(alignTo - node2.width),
        "x"
      );
    case "Bottom":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.y + n2.height)),
        (alignTo, node2) => Math.floor(alignTo - node2.height),
        "y"
      );
    case "Center":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x + n2.width / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.width / 2),
        "x"
      );
    case "Middle":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y + n2.height / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.height / 2),
        "y"
      );
  }
}
function toNodeRect(node2) {
  const { width, height } = getNodeDimensions(node2);
  return {
    ...node2.internals.positionAbsolute,
    id: node2.id,
    width,
    height
  };
}
function getAligner(mode) {
  switch (mode) {
    case "Left":
    case "Right":
    case "Top":
    case "Bottom":
    case "Center":
    case "Middle":
      return getLinearAligner(mode);
    case "Column":
    case "Row":
      return new GridAligner(mode);
    default:
      nonexhaustive(mode);
  }
}
const setViewport = (params) => machine$1.createAction(({ context: context2, event }) => {
  let viewport, duration;
  params ? (viewport = params.viewport, duration = params.duration) : (assertEvent(event, "xyflow.setViewport"), viewport = event.viewport, duration = event.duration), duration = duration ?? 400;
  const { panZoom } = nonNullable(context2.xystore).getState(), animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport({
    x: Math.round(viewport.x),
    y: Math.round(viewport.y),
    zoom: viewport.zoom
  }, animationProps).catch((err) => {
    console.error("Error during fitDiagram panZoom setViewport", { err });
  });
}), fitDiagram$1 = (params) => machine$1.enqueueActions(({ context: context2, event, enqueue }) => {
  let bounds = context2.view.bounds, duration;
  params ? (bounds = params.bounds ?? context2.view.bounds, duration = params.duration) : event.type === "xyflow.fitDiagram" && (bounds = event.bounds ?? context2.view.bounds, duration = event.duration, enqueue.assign({
    viewportChangedManually: !1
  })), duration ??= 450;
  const { width, height, panZoom, transform: transform2 } = nonNullable(context2.xystore).getState(), maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
  viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y);
  const animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport(viewport, animationProps).catch((err) => {
    console.error("Error during fitDiagram panZoom setViewport", { err });
  });
}), fitFocusedBounds = () => machine$1.createAction(({ context: context2 }) => {
  const isActiveSequenceWalkthrough = !!context2.activeWalkthrough && context2.dynamicViewVariant === "sequence", { bounds, duration = 450 } = isActiveSequenceWalkthrough ? activeSequenceBounds({ context: context2 }) : focusedBounds({ context: context2 }), { width, height, panZoom, transform: transform2 } = nonNullable(context2.xystore).getState(), maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
  viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y);
  const animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport(viewport, animationProps).catch((err) => {
    console.error("Error during fitFocusedBounds panZoom setViewport", { err });
  });
}), DEFAULT_DELAY = 30, raiseSetViewport = (params) => {
  const { delay: delay2 = DEFAULT_DELAY, ...rest } = params ?? {};
  return machine$1.raise(
    {
      type: "xyflow.setViewport",
      ...rest
    },
    {
      id: "fitDiagram",
      delay: delay2
    }
  );
}, cancelFitDiagram$1 = () => machine$1.cancel("fitDiagram"), raiseFitDiagram$1 = (params) => {
  const { delay: delay2 = DEFAULT_DELAY, ...rest } = params ?? {};
  return machine$1.raise(
    {
      type: "xyflow.fitDiagram",
      ...rest
    },
    {
      id: "fitDiagram",
      delay: delay2
    }
  );
}, raiseUpdateView = (view) => machine$1.raise(({ context: context2 }) => ({
  type: "update.view",
  view: context2.view
}), { delay: DEFAULT_DELAY }), assignViewportBefore = (viewport) => machine$1.assign(({ context: context2 }) => ({
  // We can assign
  viewportBefore: {
    wasChangedManually: context2.viewportChangedManually,
    value: { ...context2.viewport }
  }
})), returnViewportBefore = (params) => machine$1.enqueueActions(({ enqueue, context: { viewportBefore } }) => {
  enqueue(cancelFitDiagram$1()), viewportBefore ? (enqueue.assign({
    viewportChangedManually: viewportBefore.wasChangedManually,
    viewportBefore: null
  }), params && params.delay === 0 ? enqueue(setViewport({ viewport: viewportBefore.value, ...params })) : enqueue(raiseSetViewport({ viewport: viewportBefore.value, ...params }))) : params && params.delay === 0 ? enqueue(fitDiagram$1({ ...params })) : enqueue(raiseFitDiagram$1({ ...params }));
}), disableCompareWithLatest = () => machine$1.assign(({ context: context2 }) => ({
  toggledFeatures: {
    ...context2.toggledFeatures,
    enableCompareWithLatest: !1
  },
  viewportOnAutoLayout: null,
  viewportOnManualLayout: null
})), onEdgeDoubleClick = () => machine$1.assign(({ context: context2, event }) => {
  if (assertEvent(event, "xyflow.edgeDoubleClick"), !event.edge.data.controlPoints)
    return {};
  const { nodeLookup } = context2.xystore.getState();
  return {
    xyedges: context2.xyedges.map((e2) => {
      if (e2.id === event.edge.id) {
        const controlPoints = resetEdgeControlPoints(nodeLookup, e2), pt = controlPoints[0];
        return {
          ...e2,
          data: {
            ...e2.data,
            controlPoints,
            labelBBox: e2.data.labelBBox ? { ...e2.data.labelBBox, ...pt } : null,
            labelXY: null
          }
        };
      }
      return e2;
    })
  };
}), assignLastClickedNode = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "xyflow.nodeClick");
  const { lastClickedNode } = context2;
  return !lastClickedNode || lastClickedNode.id !== event.node.id ? {
    lastClickedNode: {
      id: event.node.id,
      clicks: 1,
      timestamp: Date.now()
    }
  } : {
    lastClickedNode: {
      id: lastClickedNode.id,
      clicks: lastClickedNode.clicks + 1,
      timestamp: Date.now()
    }
  };
}), assignFocusedNode = () => machine$1.assign(({ event }) => {
  let focusedNode, autoUnfocusTimer = !1;
  switch (event.type) {
    case "xyflow.nodeClick":
      focusedNode = event.node.data.id;
      break;
    case "focus.node":
      focusedNode = event.nodeId, autoUnfocusTimer = event.autoUnfocus === !0;
      break;
    default:
      throw new Error(`Unexpected event type: ${event.type} in action 'assign: focusedNode'`);
  }
  return {
    focusedNode,
    autoUnfocusTimer
  };
}), resetLastClickedNode = () => machine$1.assign(() => ({
  lastClickedNode: null
})), updateFeatures = () => machine$1.assign(({ event }) => (assertEvent(event, "update.features"), {
  features: { ...event.features }
})), updateInputs = () => machine$1.assign(({ event }) => (assertEvent(event, "update.inputs"), { ...event.inputs })), assignXYDataFromView = (view) => machine$1.assign(({ context: context2, event }) => {
  let xydata;
  assertEvent(event, "update.view"), xydata = "xynodes" in event ? event : convertToXYFlow({
    dynamicViewVariant: context2.dynamicViewVariant,
    view: event.view,
    where: context2.where
  });
  const update = mergeXYNodesEdges(context2, xydata);
  let { lastClickedNode, focusedNode, activeWalkthrough } = context2;
  if (lastClickedNode || focusedNode || activeWalkthrough) {
    const nodeIds = new Set(update.xynodes.map((n2) => n2.id));
    lastClickedNode && !nodeIds.has(lastClickedNode.id) && (lastClickedNode = null), focusedNode && !nodeIds.has(focusedNode) && (focusedNode = null);
    const stepId = activeWalkthrough?.stepId;
    return stepId && !update.xyedges.some((e2) => e2.id === stepId) && (activeWalkthrough = null), {
      ...update,
      lastClickedNode,
      focusedNode,
      activeWalkthrough
    };
  }
  return update;
}), focusOnNodesAndEdges = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  const next = focusNodesEdges(context2);
  next ? enqueue.assign(next) : enqueue.raise({ type: "key.esc" });
}), undimEverything = () => machine$1.assign(({ context: context2 }) => ({
  xynodes: context2.xynodes.map(Base.setDimmed(!1)),
  xyedges: context2.xyedges.map(Base.setData({
    dimmed: !1,
    active: !1
  }))
})), assignDynamicViewVariant = () => machine$1.assign(({ event }) => (assertEvent(event, "switch.dynamicViewVariant"), {
  dynamicViewVariant: event.variant
})), onNodeMouseEnter = (params) => machine$1.assign(({ context: context2, event }) => {
  let node2 = params?.node;
  return node2 || (assertEvent(event, "xyflow.nodeMouseEnter"), node2 = event.node), {
    xynodes: context2.xynodes.map((n2) => n2.id === node2.id ? Base.setHovered(n2, !0) : n2)
  };
}), onNodeMouseLeave = (params) => machine$1.assign(({ context: context2, event }) => {
  let node2 = params?.node;
  return node2 || (assertEvent(event, "xyflow.nodeMouseLeave"), node2 = event.node), {
    xynodes: context2.xynodes.map((n2) => n2.id === node2.id ? Base.setHovered(n2, !1) : n2)
  };
}), emitPaneClick = () => machine$1.emit(() => ({
  type: "paneClick"
})), emitOpenSource = (params) => machine$1.emit(({ event }) => params ? {
  type: "openSource",
  params
} : (assertEvent(event, "open.source"), {
  type: "openSource",
  params: event
})), emitInitialized = () => machine$1.emit(({ context: context2 }) => (invariant$2(context2.xyflow, "XYFlow instance not found"), {
  type: "initialized",
  instance: context2.xyflow
})), emitNodeClick = () => machine$1.emit(({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), {
  type: "nodeClick",
  node: nonNullable(findDiagramNode(context2, event.node.id), `Node ${event.node.id} not found in diagram`),
  xynode: event.node
})), emitNavigateTo = (params) => machine$1.emit(({ context: context2 }) => ({
  type: "navigateTo",
  viewId: params?.viewId ?? nonNullable(context2.lastOnNavigate, "Invalid state, lastOnNavigate is null").toView
})), emitEdgeClick = () => machine$1.emit(({ context: context2, event }) => (assertEvent(event, "xyflow.edgeClick"), {
  type: "edgeClick",
  edge: nonNullable(findDiagramEdge(context2, event.edge.id), `Edge ${event.edge.id} not found in diagram`),
  xyedge: event.edge
})), triggerChange = (viewChange) => machine$1.enqueueActions(({ event, enqueue }) => {
  let change2 = viewChange;
  change2 || (assertEvent(event, "trigger.change"), change2 = event.change), enqueue.assign({
    viewportChangedManually: !0
  }), enqueue.sendTo(
    typedSystem.editorActor,
    {
      type: "change",
      change: change2
    }
  );
}), emitOnLayoutTypeChange = () => machine$1.enqueueActions(({ event, system, context: context2, enqueue }) => {
  if (!context2.features.enableCompareWithLatest) {
    console.warn("Layout type cannot be changed while CompareWithLatest feature is disabled");
    return;
  }
  const currentLayoutType = context2.view._layout;
  let nextLayoutType = currentLayoutType === "auto" ? "manual" : "auto";
  if (event.type === "emit.onLayoutTypeChange" && (nextLayoutType = event.layoutType), currentLayoutType === nextLayoutType) {
    console.warn("Ignoring layout type change event, layout type is already", currentLayoutType);
    return;
  }
  if (context2.toggledFeatures.enableCompareWithLatest === !0) {
    currentLayoutType === "manual" && nextLayoutType === "auto" && typedSystem(system).editorActorRef?.send({
      type: "cancel"
    });
    const currentViewport = context2.viewport;
    currentLayoutType === "auto" && enqueue.assign({
      viewportOnAutoLayout: currentViewport
    }), currentLayoutType === "manual" && enqueue.assign({
      viewportOnManualLayout: currentViewport
    });
  }
  enqueue.emit({
    type: "onLayoutTypeChange",
    layoutType: nextLayoutType
  });
}), layoutAlign = (params) => machine$1.createAction(({ context: context2, event }) => {
  let mode;
  assertEvent(event, "layout.align"), mode = event.mode;
  const xystore = nonNullable(context2.xystore, "xystore is not initialized"), { nodeLookup, parentLookup } = xystore.getState(), nodesToAlign = [...new Set(nodeLookup.values().filter((n2) => n2.selected).map((n2) => n2.id)).difference(new Set(parentLookup.keys()))];
  if (!t$q(nodesToAlign, 2)) {
    console.warn("At least 2 nodes must be selected to align");
    return;
  }
  const constraints = createLayoutConstraints(xystore, nodesToAlign), aligner = getAligner(mode), nodes = nodesToAlign.map((id2) => ({
    node: nonNullable(nodeLookup.get(id2)),
    rect: nonNullable(constraints.rects.get(id2))
  }));
  aligner.computeLayout(nodes.map(({ node: node2 }) => toNodeRect(node2)));
  for (const { rect, node: node2 } of nodes)
    rect.positionAbsolute = {
      ...rect.positionAbsolute,
      ...aligner.applyPosition(toNodeRect(node2))
    };
  constraints.updateXYFlow();
}), resetEdgesControlPoints = () => machine$1.assign(({ context: context2 }) => {
  const { nodeLookup } = context2.xystore.getState();
  return {
    xyedges: context2.xyedges.map((edge) => {
      if (!edge.data.controlPoints)
        return edge;
      const controlPoints = resetEdgeControlPoints(nodeLookup, edge), pt = controlPoints[0];
      return {
        ...edge,
        data: {
          ...edge.data,
          controlPoints,
          labelBBox: edge.data.labelBBox ? { ...edge.data.labelBBox, x: pt.x, y: pt.y } : null,
          labelXY: edge.data.labelXY ? pt : null
        }
      };
    })
  };
}), notationsHighlight = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "notations.highlight");
  const { notation, kind } = event, targetKinds = kind ? [kind] : notation.kinds, shouldHighlight = (node2) => node2.notation === notation.title && node2.shape === notation.shape && node2.color === notation.color && targetKinds.includes(node2.kind), xynodes = context2.xynodes.map((n2) => {
    const node2 = findDiagramNode(context2, n2.id), highlighted = node2 && shouldHighlight(node2);
    return Base.setDimmed(n2, highlighted ? !1 : "immediate");
  }), xyedges = context2.xyedges.map((edge) => Base.setDimmed(edge, !0));
  return { xynodes, xyedges };
}), tagHighlight = () => machine$1.assign(({ context: context2, event }) => (assertEvent(event, "tag.highlight"), {
  xynodes: context2.xynodes.map((n2) => n2.data.tags?.includes(event.tag) ? Base.setDimmed(n2, !1) : Base.setDimmed(n2, !0))
})), assignToggledFeatures = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "toggle.feature");
  const currentValue = context2.toggledFeatures[`enable${event.feature}`] ?? context2.features[`enable${event.feature}`], nextValue = event.forceValue ?? !currentValue;
  return {
    toggledFeatures: {
      ...context2.toggledFeatures,
      [`enable${event.feature}`]: nextValue
    }
  };
}), closeSearch = () => machine$1.sendTo(
  typedSystem.searchActor,
  {
    type: "close"
  }
), closeAllOverlays = () => machine$1.sendTo(
  typedSystem.overlaysActor,
  {
    type: "close.all"
  }
), stopEditorActor = () => machine$1.enqueueActions(({ enqueue, system }) => {
  const actor = typedSystem(system).editorActorRef;
  actor && enqueue.stopChild(actor);
}), ensureEditorActor = () => machine$1.enqueueActions(({ enqueue, context: context2, system, check }) => {
  const hasEditor = check("enabled: Editor"), editor = typedSystem(system).editorActorRef;
  if (!hasEditor && editor) {
    enqueue.stopChild(editor);
    return;
  }
  hasEditor && !editor && enqueue.spawnChild("editorActor", {
    id: "editor",
    systemId: "editor",
    input: {
      viewId: context2.view.id
    },
    syncSnapshot: !0
  });
}), startEditing = (subject = "node") => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "edit.start",
    subject
  }
), sendSynced = () => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "synced"
  }
), stopEditing = (wasChanged = !0) => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "edit.finish",
    wasChanged
  }
), cancelEditing = () => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "cancel"
  }
), hasModelFqn = (node2) => "modelFqn" in node2.data && e$1(node2.data.modelFqn), openElementDetails = (params) => machine$1.enqueueActions(({ context: context2, event, enqueue }) => {
  let initiatedFrom = null, fromNodeId, subject;
  switch (!0) {
    case event.type === "xyflow.nodeClick": {
      if (!hasModelFqn(event.node)) {
        console.warn("No modelFqn in clicked node data");
        return;
      }
      subject = event.node.data.modelFqn, fromNodeId = event.node.data.id;
      break;
    }
    case event.type === "open.elementDetails": {
      subject = event.fqn, fromNodeId = event.fromNode;
      break;
    }
    default: {
      if (!context2.lastClickedNode) {
        console.warn("No last clicked node");
        return;
      }
      fromNodeId = context2.lastClickedNode.id;
      const node2 = context2.xynodes.find((n2) => n2.id === fromNodeId);
      if (!node2 || !hasModelFqn(node2)) {
        console.warn("No modelFqn in last clicked node");
        return;
      }
      subject = node2.data.modelFqn;
      break;
    }
  }
  const internalNode = fromNodeId ? context2.xystore.getState().nodeLookup.get(fromNodeId) : null;
  if (fromNodeId && internalNode) {
    const nodeRect = nodeToRect$1(internalNode), zoom2 = context2.xyflow.getZoom(), clientRect = {
      ...context2.xyflow.flowToScreenPosition(nodeRect),
      width: nodeRect.width * zoom2,
      height: nodeRect.height * zoom2
    };
    initiatedFrom = {
      node: fromNodeId,
      clientRect
    };
  }
  enqueue.sendTo(
    typedSystem.overlaysActor,
    {
      type: "open.elementDetails",
      subject,
      currentView: context2.view,
      ...initiatedFrom && { initiatedFrom }
    }
  );
}), openOverlay = () => machine$1.enqueueActions(({ context: context2, event, enqueue, check }) => {
  if (assertEvent(event, ["open.relationshipsBrowser", "open.relationshipDetails", "open.elementDetails"]), !check("enabled: Overlays")) {
    console.warn("Overlays feature is disabled");
    return;
  }
  switch (event.type) {
    case "open.elementDetails": {
      check("enabled: ElementDetails") ? enqueue(openElementDetails()) : console.warn("ElementDetails feature is disabled");
      break;
    }
    case "open.relationshipsBrowser": {
      enqueue.sendTo(
        typedSystem.overlaysActor,
        {
          type: "open.relationshipsBrowser",
          subject: event.fqn,
          viewId: context2.view.id,
          scope: "view",
          closeable: !0,
          enableChangeScope: !0,
          enableSelectSubject: !0
        }
      );
      break;
    }
    case "open.relationshipDetails": {
      enqueue.sendTo(
        typedSystem.overlaysActor,
        {
          type: "open.relationshipDetails",
          viewId: context2.view.id,
          ...event.params
        }
      );
      break;
    }
    default:
      nonexhaustive(event);
  }
}), openSourceOfFocusedOrLastClickedNode = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  const nodeId = context2.focusedNode ?? context2.lastClickedNode?.id;
  if (!nodeId || !context2.features.enableVscode) return;
  const diagramNode = findDiagramNode(context2, nodeId);
  diagramNode && (diagramNode.deploymentRef ? enqueue.raise({ type: "open.source", deployment: diagramNode.deploymentRef }) : diagramNode.modelRef && enqueue.raise({ type: "open.source", element: diagramNode.modelRef }));
}), ensureOverlaysActor = () => machine$1.enqueueActions(({ enqueue, check, system }) => {
  const enableOverlays = check("enabled: Overlays"), hasRunning = typedSystem(system).overlaysActorRef;
  if (enableOverlays && !hasRunning) {
    enqueue.spawnChild("overlaysActorLogic", { id: "overlays", systemId: "overlays" });
    return;
  }
  !enableOverlays && hasRunning && (enqueue.sendTo(hasRunning, {
    type: "close.all"
  }), enqueue.stopChild("overlays"));
}), ensureSearchActor = () => machine$1.enqueueActions(({ enqueue, context: { features: { enableSearch } }, system }) => {
  const hasRunning = typedSystem(system).searchActorRef;
  if (enableSearch && !hasRunning) {
    enqueue.spawnChild("searchActorLogic", { id: "search", systemId: "search" });
    return;
  }
  !enableSearch && hasRunning && (enqueue.sendTo(hasRunning, {
    type: "close"
  }), enqueue.stopChild("search"));
}), onEdgeMouseEnter = () => machine$1.enqueueActions(({ enqueue, context: context2, event }) => {
  assertEvent(event, "xyflow.edgeMouseEnter");
  let edge = event.edge;
  enqueue.assign({
    xyedges: context2.xyedges.map((e2) => e2.id === event.edge.id ? (edge = Base.setHovered(e2, !0), edge) : e2)
  }), enqueue.emit({
    type: "edgeMouseEnter",
    edge,
    event: event.event
  });
}), onEdgeMouseLeave = () => machine$1.enqueueActions(({ enqueue, context: context2, event }) => {
  assertEvent(event, "xyflow.edgeMouseLeave");
  let edge = event.edge;
  enqueue.assign({
    xyedges: context2.xyedges.map((e2) => e2.id === event.edge.id ? (edge = Base.setHovered(e2, !1), edge) : e2)
  }), enqueue.emit({
    type: "edgeMouseLeave",
    edge,
    event: event.event
  });
}), startHotKeyActor = () => machine$1.spawnChild("hotkeyActorLogic", { id: "hotkey" }), stopHotKeyActor = () => machine$1.stopChild("hotkey"), AUTO_UNFOCUS_DELAY = 3e3, startAutoUnfocusTimer = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  context2.autoUnfocusTimer && AUTO_UNFOCUS_DELAY > 0 && enqueue.raise({ type: "focus.autoUnfocus" }, { delay: AUTO_UNFOCUS_DELAY, id: "autoUnfocusTimer" });
}), cancelAutoUnfocusTimer = () => machine$1.cancel("autoUnfocusTimer"), handleNavigate = () => machine$1.enqueueActions(({ enqueue, context: context2, event }) => {
  assertEvent(event, ["navigate.to", "navigate.back", "navigate.forward"]);
  const {
    view,
    focusedNode,
    activeWalkthrough,
    dynamicViewVariant,
    viewport,
    viewportChangedManually,
    viewportBefore,
    navigationHistory: {
      currentIndex,
      history: _history
    }
  } = context2;
  let history = [..._history];
  if (currentIndex < _history.length) {
    const updatedEntry = produce(_history[currentIndex], (draft) => {
      draft.viewport = { ...viewport }, draft.viewportChangedManually = viewportChangedManually, draft.focusedNode = focusedNode, view._type === "dynamic" ? (draft.activeWalkthrough = activeWalkthrough?.stepId ?? null, draft.dynamicViewVariant = dynamicViewVariant) : (draft.activeWalkthrough = null, draft.dynamicViewVariant = null), viewportBefore ? draft.viewportBefore = viewportBefore : delete draft.viewportBefore;
    });
    history = [..._history], history[currentIndex] = updatedEntry;
  }
  switch (event.type) {
    case "navigate.to": {
      enqueue.assign({
        navigationHistory: {
          currentIndex,
          history
        },
        lastOnNavigate: {
          fromView: context2.view.id,
          toView: event.viewId,
          fromNode: event.fromNode ?? null,
          focusOnElement: event.focusOnElement ?? null
        }
      }), enqueue(emitNavigateTo());
      break;
    }
    case "navigate.back": {
      invariant$2(currentIndex > 0, "Cannot navigate back");
      const stepBack = history[currentIndex - 1];
      enqueue.assign({
        navigationHistory: {
          currentIndex: currentIndex - 1,
          history
        },
        lastOnNavigate: null
      }), enqueue(emitNavigateTo({ viewId: stepBack.viewId }));
      break;
    }
    case "navigate.forward": {
      invariant$2(currentIndex < history.length - 1, "Cannot navigate forward");
      const stepForward = history[currentIndex + 1];
      enqueue.assign({
        navigationHistory: {
          currentIndex: currentIndex + 1,
          history
        },
        lastOnNavigate: null
      }), enqueue(emitNavigateTo({ viewId: stepForward.viewId }));
      break;
    }
    default:
      nonexhaustive(event);
  }
}), updateView$1 = () => machine$1.enqueueActions(
  ({ enqueue, event, context: context2 }) => {
    if (event.type !== "update.view") {
      console.warn(`Ignoring unexpected event type: ${event.type} in action 'update.view'`);
      return;
    }
    const nextView = event.view;
    if (nextView.id !== context2.view.id) {
      console.warn("updateView called for another view - ignoring", { event });
      return;
    }
    if (enqueue(assignXYDataFromView()), event.source === "editor")
      return;
    enqueue(sendSynced());
    let recenter = !context2.viewportChangedManually && !context2.focusedNode && !context2.activeWalkthrough;
    if (context2.toggledFeatures.enableCompareWithLatest === !0 && context2.view._layout !== nextView._layout) {
      if (nextView._layout === "auto" && context2.viewportOnAutoLayout) {
        enqueue(
          setViewport({
            viewport: context2.viewportOnAutoLayout,
            duration: 0
          })
        );
        return;
      }
      if (nextView._layout === "manual" && context2.viewportOnManualLayout) {
        enqueue(
          setViewport({
            viewport: context2.viewportOnManualLayout,
            duration: 0
          })
        );
        return;
      }
    }
    recenter = recenter || nextView._type === "dynamic" && context2.view._type === "dynamic" && nextView.variant !== context2.view.variant, recenter = recenter || context2.toggledFeatures.enableCompareWithLatest === !0 && !!nextView._layout && context2.view._layout !== nextView._layout, recenter && (enqueue(cancelFitDiagram$1()), enqueue(raiseFitDiagram$1({
      bounds: event.view.bounds
    })));
  }
);
var xstateActions_cjs = {}, assignDea9f7c8_cjs = {}, hasRequiredAssignDea9f7c8_cjs;
function requireAssignDea9f7c8_cjs() {
  if (hasRequiredAssignDea9f7c8_cjs) return assignDea9f7c8_cjs;
  hasRequiredAssignDea9f7c8_cjs = 1;
  var guards_dist_xstateGuards = /* @__PURE__ */ requireRaiseDa5b247f_cjs();
  function createSpawner2(actorScope, {
    machine: machine2,
    context: context2
  }, event, spawnedChildren) {
    const spawn = (src, options) => {
      if (typeof src == "string") {
        const logic = guards_dist_xstateGuards.resolveReferencedActor(machine2, src);
        if (!logic)
          throw new Error(`Actor logic '${src}' not implemented in machine '${machine2.id}'`);
        const actorRef = guards_dist_xstateGuards.createActor(logic, {
          id: options?.id,
          parent: actorScope.self,
          syncSnapshot: options?.syncSnapshot,
          input: typeof options?.input == "function" ? options.input({
            context: context2,
            event,
            self: actorScope.self
          }) : options?.input,
          src,
          systemId: options?.systemId
        });
        return spawnedChildren[actorRef.id] = actorRef, actorRef;
      } else
        return guards_dist_xstateGuards.createActor(src, {
          id: options?.id,
          parent: actorScope.self,
          syncSnapshot: options?.syncSnapshot,
          input: options?.input,
          src,
          systemId: options?.systemId
        });
    };
    return (src, options) => {
      const actorRef = spawn(src, options);
      return spawnedChildren[actorRef.id] = actorRef, actorScope.defer(() => {
        actorRef._processingStatus !== guards_dist_xstateGuards.ProcessingStatus.Stopped && actorRef.start();
      }), actorRef;
    };
  }
  function resolveAssign2(actorScope, snapshot, actionArgs, actionParams, {
    assignment
  }) {
    if (!snapshot.context)
      throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
    const spawnedChildren = {}, assignArgs = {
      context: snapshot.context,
      event: actionArgs.event,
      spawn: createSpawner2(actorScope, snapshot, actionArgs.event, spawnedChildren),
      self: actorScope.self,
      system: actorScope.system
    };
    let partialUpdate = {};
    if (typeof assignment == "function")
      partialUpdate = assignment(assignArgs, actionParams);
    else
      for (const key2 of Object.keys(assignment)) {
        const propAssignment = assignment[key2];
        partialUpdate[key2] = typeof propAssignment == "function" ? propAssignment(assignArgs, actionParams) : propAssignment;
      }
    const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
    return [guards_dist_xstateGuards.cloneMachineSnapshot(snapshot, {
      context: updatedContext,
      children: Object.keys(spawnedChildren).length ? {
        ...snapshot.children,
        ...spawnedChildren
      } : snapshot.children
    }), void 0, void 0];
  }
  function assign2(assignment) {
    function assign3(_args, _params) {
    }
    return assign3.type = "xstate.assign", assign3.assignment = assignment, assign3.resolve = resolveAssign2, assign3;
  }
  return assignDea9f7c8_cjs.assign = assign2, assignDea9f7c8_cjs;
}
var logEc8d4df4_cjs = {}, hasRequiredLogEc8d4df4_cjs;
function requireLogEc8d4df4_cjs() {
  if (hasRequiredLogEc8d4df4_cjs) return logEc8d4df4_cjs;
  hasRequiredLogEc8d4df4_cjs = 1;
  var guards_dist_xstateGuards = /* @__PURE__ */ requireRaiseDa5b247f_cjs(), assign2 = /* @__PURE__ */ requireAssignDea9f7c8_cjs();
  function resolveEmit2(_, snapshot, args, actionParams, {
    event: eventOrExpr
  }) {
    const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
    return [snapshot, {
      event: resolvedEvent
    }, void 0];
  }
  function executeEmit2(actorScope, {
    event
  }) {
    actorScope.defer(() => actorScope.emit(event));
  }
  function emit2(eventOrExpr) {
    function emit3(_args, _params) {
    }
    return emit3.type = "xstate.emit", emit3.event = eventOrExpr, emit3.resolve = resolveEmit2, emit3.execute = executeEmit2, emit3;
  }
  let SpecialTargets2 = /* @__PURE__ */ (function(SpecialTargets3) {
    return SpecialTargets3.Parent = "#_parent", SpecialTargets3.Internal = "#_internal", SpecialTargets3;
  })({});
  function resolveSendTo2(actorScope, snapshot, args, actionParams, {
    to: to2,
    event: eventOrExpr,
    id: id2,
    delay: delay2
  }, extra) {
    const delaysMap = snapshot.machine.implementations.delays;
    if (typeof eventOrExpr == "string")
      throw new Error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`
      );
    const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
    let resolvedDelay;
    if (typeof delay2 == "string") {
      const configDelay = delaysMap && delaysMap[delay2];
      resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
    } else
      resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
    const resolvedTarget = typeof to2 == "function" ? to2(args, actionParams) : to2;
    let targetActorRef;
    if (typeof resolvedTarget == "string") {
      if (resolvedTarget === SpecialTargets2.Parent ? targetActorRef = actorScope.self._parent : resolvedTarget === SpecialTargets2.Internal ? targetActorRef = actorScope.self : resolvedTarget.startsWith("#_") ? targetActorRef = snapshot.children[resolvedTarget.slice(2)] : targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget], !targetActorRef)
        throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);
    } else
      targetActorRef = resolvedTarget || actorScope.self;
    return [snapshot, {
      to: targetActorRef,
      targetId: typeof resolvedTarget == "string" ? resolvedTarget : void 0,
      event: resolvedEvent,
      id: id2,
      delay: resolvedDelay
    }, void 0];
  }
  function retryResolveSendTo2(_, snapshot, params) {
    typeof params.to == "string" && (params.to = snapshot.children[params.to]);
  }
  function executeSendTo2(actorScope, params) {
    actorScope.defer(() => {
      const {
        to: to2,
        event,
        delay: delay2,
        id: id2
      } = params;
      if (typeof delay2 == "number") {
        actorScope.system.scheduler.schedule(actorScope.self, to2, event, delay2, id2);
        return;
      }
      actorScope.system._relay(
        actorScope.self,
        // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
        // if it initially started as a string
        to2,
        event.type === guards_dist_xstateGuards.XSTATE_ERROR ? guards_dist_xstateGuards.createErrorActorEvent(actorScope.self.id, event.data) : event
      );
    });
  }
  function sendTo2(to2, eventOrExpr, options) {
    function sendTo3(_args, _params) {
    }
    return sendTo3.type = "xstate.sendTo", sendTo3.to = to2, sendTo3.event = eventOrExpr, sendTo3.id = options?.id, sendTo3.delay = options?.delay, sendTo3.resolve = resolveSendTo2, sendTo3.retryResolve = retryResolveSendTo2, sendTo3.execute = executeSendTo2, sendTo3;
  }
  function sendParent2(event, options) {
    return sendTo2(SpecialTargets2.Parent, event, options);
  }
  function forwardTo(target, options) {
    return sendTo2(target, ({
      event
    }) => event, options);
  }
  function resolveEnqueueActions2(actorScope, snapshot, args, actionParams, {
    collect
  }) {
    const actions = [], enqueue = function(action) {
      actions.push(action);
    };
    return enqueue.assign = (...args2) => {
      actions.push(assign2.assign(...args2));
    }, enqueue.cancel = (...args2) => {
      actions.push(guards_dist_xstateGuards.cancel(...args2));
    }, enqueue.raise = (...args2) => {
      actions.push(guards_dist_xstateGuards.raise(...args2));
    }, enqueue.sendTo = (...args2) => {
      actions.push(sendTo2(...args2));
    }, enqueue.sendParent = (...args2) => {
      actions.push(sendParent2(...args2));
    }, enqueue.spawnChild = (...args2) => {
      actions.push(guards_dist_xstateGuards.spawnChild(...args2));
    }, enqueue.stopChild = (...args2) => {
      actions.push(guards_dist_xstateGuards.stopChild(...args2));
    }, enqueue.emit = (...args2) => {
      actions.push(emit2(...args2));
    }, collect({
      context: args.context,
      event: args.event,
      enqueue,
      check: (guard) => guards_dist_xstateGuards.evaluateGuard(guard, snapshot.context, args.event, snapshot),
      self: actorScope.self,
      system: actorScope.system
    }, actionParams), [snapshot, void 0, actions];
  }
  function enqueueActions2(collect) {
    function enqueueActions3(_args, _params) {
    }
    return enqueueActions3.type = "xstate.enqueueActions", enqueueActions3.collect = collect, enqueueActions3.resolve = resolveEnqueueActions2, enqueueActions3;
  }
  function resolveLog2(_, snapshot, actionArgs, actionParams, {
    value,
    label: label2
  }) {
    return [snapshot, {
      value: typeof value == "function" ? value(actionArgs, actionParams) : value,
      label: label2
    }, void 0];
  }
  function executeLog2({
    logger
  }, {
    value,
    label: label2
  }) {
    label2 ? logger(label2, value) : logger(value);
  }
  function log2(value = ({
    context: context2,
    event
  }) => ({
    context: context2,
    event
  }), label2) {
    function log3(_args, _params) {
    }
    return log3.type = "xstate.log", log3.value = value, log3.label = label2, log3.resolve = resolveLog2, log3.execute = executeLog2, log3;
  }
  return logEc8d4df4_cjs.SpecialTargets = SpecialTargets2, logEc8d4df4_cjs.emit = emit2, logEc8d4df4_cjs.enqueueActions = enqueueActions2, logEc8d4df4_cjs.forwardTo = forwardTo, logEc8d4df4_cjs.log = log2, logEc8d4df4_cjs.sendParent = sendParent2, logEc8d4df4_cjs.sendTo = sendTo2, logEc8d4df4_cjs;
}
var hasRequiredXstateActions_cjs;
function requireXstateActions_cjs() {
  if (hasRequiredXstateActions_cjs) return xstateActions_cjs;
  hasRequiredXstateActions_cjs = 1, Object.defineProperty(xstateActions_cjs, "__esModule", { value: !0 });
  var assign2 = /* @__PURE__ */ requireAssignDea9f7c8_cjs(), guards_dist_xstateGuards = /* @__PURE__ */ requireRaiseDa5b247f_cjs(), log2 = /* @__PURE__ */ requireLogEc8d4df4_cjs();
  return requireXstateDev_cjs(), xstateActions_cjs.assign = assign2.assign, xstateActions_cjs.cancel = guards_dist_xstateGuards.cancel, xstateActions_cjs.raise = guards_dist_xstateGuards.raise, xstateActions_cjs.spawnChild = guards_dist_xstateGuards.spawnChild, xstateActions_cjs.stop = guards_dist_xstateGuards.stop, xstateActions_cjs.stopChild = guards_dist_xstateGuards.stopChild, xstateActions_cjs.emit = log2.emit, xstateActions_cjs.enqueueActions = log2.enqueueActions, xstateActions_cjs.forwardTo = log2.forwardTo, xstateActions_cjs.log = log2.log, xstateActions_cjs.sendParent = log2.sendParent, xstateActions_cjs.sendTo = log2.sendTo, xstateActions_cjs;
}
var xstateActions_cjsExports = requireXstateActions_cjs();
const initializing = machine$1.createStateConfig({
  on: {
    "xyflow.init": {
      actions: xstateActions_cjsExports.assign(({ context: context2, event }) => ({
        initialized: {
          ...context2.initialized,
          xyflow: !0
        },
        xyflow: event.instance
      })),
      target: "isReady"
    },
    "update.view": {
      actions: [
        assignXYDataFromView(),
        xstateActions_cjsExports.assign(({ context: context2 }) => ({
          initialized: {
            ...context2.initialized,
            xydata: !0
          }
        }))
      ],
      target: "isReady"
    }
  }
}), isReady = machine$1.createStateConfig({
  always: [{
    guard: "isReady",
    actions: [
      fitDiagram$1({ duration: 0 }),
      xstateActions_cjsExports.assign(({ context: context2 }) => ({
        navigationHistory: {
          currentIndex: 0,
          history: [{
            viewId: context2.view.id,
            viewport: { ...context2.xyflow.getViewport() },
            viewportChangedManually: !1
          }]
        }
      })),
      emitInitialized()
    ],
    target: "ready"
  }, {
    target: "initializing"
  }]
}), handleBrowserForwardBackward = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "update.view");
  let {
    lastOnNavigate,
    navigationHistory: {
      currentIndex,
      history
    }
  } = context2;
  const stepCurrent = history[currentIndex];
  if (!stepCurrent || stepCurrent.viewId === event.view.id || lastOnNavigate)
    return {};
  const stepBack = currentIndex > 0 ? nonNullable$1(history[currentIndex - 1]) : null;
  if (stepBack && stepBack.viewId === event.view.id)
    return {
      navigationHistory: {
        currentIndex: currentIndex - 1,
        history
      },
      lastOnNavigate: null
    };
  const stepForward = currentIndex < history.length - 1 ? nonNullable$1(history[currentIndex + 1]) : null;
  if (stepForward && stepForward.viewId === event.view.id)
    return {
      navigationHistory: {
        currentIndex: currentIndex + 1,
        history
      },
      lastOnNavigate: null
    };
  if (event.view._type === "element" && event.view.viewOf) {
    const toRef = event.view.viewOf, existingNode = context2.xynodes.find((n2) => nodeRef(n2) === toRef);
    if (existingNode)
      return {
        lastOnNavigate: {
          fromView: context2.view.id,
          toView: event.view.id,
          fromNode: existingNode.id
        }
      };
  }
  return {};
}), navigating = machine$1.createStateConfig({
  id: targetState.navigating.slice(1),
  always: {
    target: targetState.idle,
    actions: [
      cancelFitDiagram$1(),
      handleBrowserForwardBackward(),
      disableCompareWithLatest(),
      enqueueActions(({ enqueue, context: context2, event }) => {
        assertEvent(event, "update.view");
        const {
          xyflow: xyflow2,
          xystore,
          navigationHistory: {
            currentIndex,
            history
          }
        } = context2, eventWithXYData = "xynodes" in event ? event : {
          ...event,
          ...convertToXYFlow({
            dynamicViewVariant: context2.dynamicViewVariant,
            view: event.view,
            where: context2.where
          })
        };
        invariant$1(xyflow2, "xyflow is not initialized");
        const calcZoomTowardsNextViewport = (nextViewport2) => {
          const zoom2 = xyflow2.getZoom(), coef = nextViewport2.zoom < zoom2 ? 0.8 : 0.4;
          return zoom2 + (nextViewport2.zoom - zoom2) * coef;
        }, fromHistory = history[currentIndex];
        if (fromHistory && fromHistory.viewId === event.view.id) {
          enqueue.assign({
            ...mergeXYNodesEdges(context2, eventWithXYData),
            dynamicViewVariant: fromHistory.dynamicViewVariant ?? context2.dynamicViewVariant,
            viewportChangedManually: fromHistory.viewportChangedManually
          });
          const wasFocused = fromHistory.focusedNode, wasActiveWalkthrough = fromHistory.activeWalkthrough, viewportBefore = fromHistory.viewportBefore;
          viewportBefore && (wasFocused || wasActiveWalkthrough) && enqueue.assign({
            viewport: viewportBefore.value,
            viewportChangedManually: viewportBefore.wasChangedManually,
            viewportBefore: null
          });
          const center = BBox$1.center(event.view.bounds), zoom2 = calcZoomTowardsNextViewport(fromHistory.viewport);
          if (xyflow2.setCenter(
            center.x,
            center.y,
            { zoom: zoom2, duration: 0 }
          ), wasFocused) {
            enqueue.raise({
              type: "focus.node",
              nodeId: wasFocused
            }, { delay: 50 });
            return;
          }
          if (wasActiveWalkthrough) {
            enqueue.raise({
              type: "walkthrough.start",
              stepId: wasActiveWalkthrough
            }, { delay: 50 });
            return;
          }
          enqueue(raiseSetViewport({
            delay: 80,
            viewport: fromHistory.viewport
          }));
          return;
        }
        const nextViewport = calcViewportForBounds(
          context2,
          event.view.bounds
        ), { fromNode, toNode } = findCorrespondingNode(context2, eventWithXYData);
        if (fromNode && toNode) {
          const elFrom = xyflow2.getInternalNode(fromNode.id), fromPoint = xyflow2.flowToScreenPosition({
            x: elFrom.internals.positionAbsolute.x,
            y: elFrom.internals.positionAbsolute.y
          }), toPoint = xyflow2.flowToScreenPosition({
            x: toNode.data.x,
            y: toNode.data.y
          });
          xystore.getState().panBy({
            x: Math.round(fromPoint.x - toPoint.x),
            y: Math.round(fromPoint.y - toPoint.y)
          });
        } else {
          const zoom2 = calcZoomTowardsNextViewport(nextViewport), center = BBox$1.center(event.view.bounds);
          xyflow2.setCenter(
            center.x,
            center.y,
            { zoom: zoom2, duration: 0 }
          );
        }
        const updatedHistory = currentIndex < history.length - 1 ? history.slice(0, currentIndex + 1) : [...history];
        updatedHistory.push({
          viewId: event.view.id,
          viewport: { ...nextViewport },
          viewportChangedManually: !1
        });
        const focusOnElement = context2.lastOnNavigate?.focusOnElement, nodeToFocus = e$1(focusOnElement) ? findNodeByModelFqn(eventWithXYData.xynodes, focusOnElement) : null;
        enqueue.assign({
          ...mergeXYNodesEdges(context2, eventWithXYData),
          viewportChangedManually: !1,
          lastOnNavigate: null,
          navigationHistory: {
            currentIndex: updatedHistory.length - 1,
            history: updatedHistory
          }
        }), nodeToFocus ? enqueue.raise({
          type: "focus.node",
          nodeId: nodeToFocus.id,
          autoUnfocus: !0
        }, { delay: 150 }) : enqueue(raiseFitDiagram$1({
          delay: 100
        }));
      })
    ]
  }
}), focused = machine$1.createStateConfig({
  id: targetState.focused.slice(1),
  entry: [
    cancelFitDiagram$1(),
    focusOnNodesAndEdges(),
    assignViewportBefore(),
    openSourceOfFocusedOrLastClickedNode(),
    startHotKeyActor(),
    fitFocusedBounds(),
    startAutoUnfocusTimer()
  ],
  exit: [
    stopHotKeyActor(),
    undimEverything(),
    returnViewportBefore(),
    cancelAutoUnfocusTimer(),
    xstateActions_cjsExports.assign({
      focusedNode: null,
      autoUnfocusTimer: !1
    })
  ],
  on: {
    "focus.autoUnfocus": {
      target: targetState.idle
    },
    "xyflow.nodeClick": [
      {
        guard: xstateGuards_cjsExports.and([
          "enabled: ElementDetails",
          "click: focused node",
          "click: node has modelFqn"
        ]),
        actions: [
          assignLastClickedNode(),
          openElementDetails(),
          emitNodeClick()
        ]
      },
      {
        guard: "click: focused node",
        actions: [
          assignLastClickedNode(),
          emitNodeClick()
        ],
        target: targetState.idle
      },
      {
        actions: [
          assignLastClickedNode(),
          xstateActions_cjsExports.raise(({ event }) => ({
            type: "focus.node",
            nodeId: event.node.id
          })),
          emitNodeClick()
        ]
      }
    ],
    "focus.node": {
      actions: [
        assignFocusedNode(),
        focusOnNodesAndEdges(),
        openSourceOfFocusedOrLastClickedNode(),
        fitFocusedBounds()
      ]
    },
    "key.esc": {
      target: targetState.idle
    },
    "xyflow.paneClick": {
      actions: [
        resetLastClickedNode(),
        emitPaneClick()
      ],
      target: targetState.idle
    },
    "notations.unhighlight": {
      actions: focusOnNodesAndEdges()
    },
    "tag.unhighlight": {
      actions: focusOnNodesAndEdges()
    },
    "update.view": {
      guard: "is same view",
      actions: [
        updateView$1(),
        focusOnNodesAndEdges()
      ]
    }
  }
}), idle = machine$1.createStateConfig({
  id: targetState.idle.slice(1),
  on: {
    "xyflow.nodeClick": [
      {
        guard: xstateGuards_cjsExports.and([
          "enabled: Readonly",
          "enabled: FocusMode",
          "click: node has connections",
          xstateGuards_cjsExports.or([
            "click: same node",
            "click: selected node"
          ])
        ]),
        actions: [
          assignLastClickedNode(),
          assignFocusedNode(),
          emitNodeClick()
        ],
        target: targetState.focused
      },
      {
        guard: xstateGuards_cjsExports.and([
          "enabled: Readonly",
          "enabled: ElementDetails",
          "click: node has modelFqn",
          xstateGuards_cjsExports.or([
            "click: same node",
            "click: selected node"
          ])
        ]),
        actions: [
          assignLastClickedNode(),
          openSourceOfFocusedOrLastClickedNode(),
          openElementDetails(),
          emitNodeClick()
        ]
      },
      {
        actions: [
          assignLastClickedNode(),
          openSourceOfFocusedOrLastClickedNode(),
          emitNodeClick()
        ]
      }
    ],
    "xyflow.paneClick": {
      actions: [
        resetLastClickedNode(),
        emitPaneClick()
      ]
    },
    "xyflow.paneDblClick": {
      actions: [
        resetLastClickedNode(),
        xstateActions_cjsExports.enqueueActions(({ context: context2, enqueue, check }) => {
          check("enabled: FitView") && enqueue(fitDiagram$1()), enqueue(
            emitOpenSource({ view: context2.view.id })
          );
        })
      ]
    },
    "focus.node": [
      // Focus was initialed by the user searching (autoUnfocus=true) - always allowed
      {
        guard: "focus.node: autoUnfocus",
        actions: assignFocusedNode(),
        target: targetState.focused
      },
      // Regular focus - requires FocusMode to be enabled
      {
        guard: "enabled: FocusMode",
        actions: assignFocusedNode(),
        target: targetState.focused
      }
    ],
    "xyflow.edgeClick": {
      guard: xstateGuards_cjsExports.and([
        "enabled: Readonly",
        "is dynamic view",
        "enabled: DynamicViewWalkthrough",
        "click: selected edge"
      ]),
      actions: [
        resetLastClickedNode(),
        xstateActions_cjsExports.raise(({ event }) => ({
          type: "walkthrough.start",
          stepId: event.edge.id
        })),
        emitEdgeClick()
      ]
    }
  }
}), printing = machine$1.createStateConfig({
  id: targetState.printing.slice(1),
  entry: [
    cancelFitDiagram$1(),
    assignViewportBefore(),
    enqueueActions(({ enqueue, context: context2 }) => {
      const bounds = context2.view.bounds, OFFSET = 16;
      enqueue(
        setViewport({
          viewport: {
            x: bounds.x + OFFSET,
            y: bounds.y + OFFSET,
            zoom: 1
          },
          duration: 0
        })
      );
    })
  ],
  exit: [
    returnViewportBefore({ delay: 0, duration: 0 })
  ],
  on: {
    "media.print.off": {
      target: targetState.idle
    },
    "*": {
      actions: [
        log(({ event }) => `Printing state - ignoring event: ${event.type}`)
      ]
    }
  }
}), updateActiveWalkthroughState = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  const { activeWalkthrough } = context2;
  if (!activeWalkthrough) {
    console.warn("Active walkthrough is null"), enqueue.raise({ type: "walkthrough.end" });
    return;
  }
  const { stepId, parallelPrefix } = activeWalkthrough, step = context2.xyedges.find((x2) => x2.id === stepId);
  if (!step) {
    console.warn("Invalid walkthrough stepId:", stepId), enqueue.raise({ type: "walkthrough.end" });
    return;
  }
  enqueue.assign({
    xyedges: context2.xyedges.map((edge) => {
      const active = stepId === edge.id || !!parallelPrefix && edge.id.startsWith(parallelPrefix);
      return Base.setData(edge, {
        active,
        dimmed: stepId !== edge.id
      });
    }),
    xynodes: context2.xynodes.map((node2) => {
      const dimmed = step.source !== node2.id && step.target !== node2.id;
      return node2.type === "seq-parallel" ? Base.setData(node2, {
        color: parallelPrefix === node2.data.parallelPrefix ? SeqParallelAreaColor.active : SeqParallelAreaColor.default,
        dimmed
      }) : Base.setDimmed(node2, dimmed);
    })
  });
}), emitWalkthroughStarted = () => machine$1.emit(({ context: context2 }) => {
  const edge = context2.xyedges.find((x2) => x2.id === context2.activeWalkthrough?.stepId);
  return invariant$2(edge, "Invalid walkthrough state"), {
    type: "walkthroughStarted",
    edge
  };
}), emitWalkthroughStopped = () => machine$1.emit(() => ({
  type: "walkthroughStopped"
})), emitWalkthroughStep = () => machine$1.emit(({ context: context2 }) => {
  const edge = context2.xyedges.find((x2) => x2.id === context2.activeWalkthrough?.stepId);
  return invariant$2(edge, "Invalid walkthrough state"), {
    type: "walkthroughStep",
    edge
  };
}), walkthrough = machine$1.createStateConfig({
  id: targetState.walkthrough.slice(1),
  entry: [
    startHotKeyActor(),
    cancelEditing(),
    cancelFitDiagram$1(),
    assignViewportBefore(),
    xstateActions_cjsExports.assign({
      activeWalkthrough: ({ context: context2, event }) => {
        assertEvent(event, "walkthrough.start");
        const stepId = event.stepId ?? n$p(context2.xyedges).id;
        return {
          stepId,
          parallelPrefix: getParallelStepsPrefix(stepId)
        };
      }
    }),
    updateActiveWalkthroughState(),
    fitFocusedBounds(),
    emitWalkthroughStarted()
  ],
  exit: [
    stopHotKeyActor(),
    xstateActions_cjsExports.enqueueActions(({ enqueue, context: context2 }) => {
      enqueue.assign({
        activeWalkthrough: null
      }), context2.dynamicViewVariant === "sequence" && context2.activeWalkthrough?.parallelPrefix && enqueue.assign({
        xynodes: context2.xynodes.map((n2) => n2.type === "seq-parallel" ? Base.setData(n2, {
          color: SeqParallelAreaColor.default
        }) : n2)
      });
    }),
    undimEverything(),
    returnViewportBefore(),
    emitWalkthroughStopped()
  ],
  on: {
    "key.esc": {
      target: targetState.idle
    },
    "key.arrow.left": {
      actions: xstateActions_cjsExports.raise({ type: "walkthrough.step", direction: "previous" })
    },
    "key.arrow.up": {
      actions: xstateActions_cjsExports.raise({ type: "walkthrough.step", direction: "previous" })
    },
    "key.arrow.right": {
      actions: xstateActions_cjsExports.raise({ type: "walkthrough.step", direction: "next" })
    },
    "key.arrow.down": {
      actions: xstateActions_cjsExports.raise({ type: "walkthrough.step", direction: "next" })
    },
    "walkthrough.step": {
      actions: [
        xstateActions_cjsExports.assign(({ context: context2, event }) => {
          const { stepId } = context2.activeWalkthrough, stepIndex = context2.xyedges.findIndex((e2) => e2.id === stepId), nextStepIndex = t$v(event.direction === "next" ? stepIndex + 1 : stepIndex - 1, {
            min: 0,
            max: context2.xyedges.length - 1
          });
          if (nextStepIndex === stepIndex)
            return {};
          const nextStepId = context2.xyedges[nextStepIndex].id;
          return {
            activeWalkthrough: {
              stepId: nextStepId,
              parallelPrefix: getParallelStepsPrefix(nextStepId)
            }
          };
        }),
        updateActiveWalkthroughState(),
        fitFocusedBounds(),
        emitWalkthroughStep()
      ]
    },
    "xyflow.edgeClick": {
      actions: [
        xstateActions_cjsExports.assign(({ event, context: context2 }) => !isStepEdgeId(event.edge.id) || event.edge.id === context2.activeWalkthrough?.stepId ? {} : {
          activeWalkthrough: {
            stepId: event.edge.id,
            parallelPrefix: getParallelStepsPrefix(event.edge.id)
          }
        }),
        updateActiveWalkthroughState(),
        fitFocusedBounds(),
        emitEdgeClick(),
        emitWalkthroughStep()
      ]
    },
    "notations.unhighlight": {
      actions: updateActiveWalkthroughState()
    },
    "tag.unhighlight": {
      actions: updateActiveWalkthroughState()
    },
    "update.view": {
      guard: "is same view",
      actions: [
        updateView$1(),
        updateActiveWalkthroughState()
      ]
    },
    "walkthrough.end": {
      target: targetState.idle
    },
    "xyflow.paneDblClick": {
      target: targetState.idle
    }
  }
}), ready = machine$1.createStateConfig({
  initial: "idle",
  entry: [
    xstateActions_cjsExports.spawnChild("mediaPrintActorLogic", { id: "mediaPrint" }),
    ensureEditorActor(),
    ensureOverlaysActor(),
    ensureSearchActor()
  ],
  exit: [
    cancelFitDiagram$1(),
    xstateActions_cjsExports.stopChild("mediaPrint"),
    closeAllOverlays(),
    closeSearch(),
    stopEditorActor()
  ],
  states: {
    idle,
    focused,
    walkthrough,
    printing
  },
  on: {
    "navigate.*": {
      actions: handleNavigate()
    },
    "layout.align": {
      guard: "not readonly",
      actions: [
        startEditing("node"),
        layoutAlign(),
        stopEditing(!0)
      ]
    },
    "layout.resetEdgeControlPoints": {
      guard: "not readonly",
      actions: [
        startEditing("edge"),
        resetEdgesControlPoints(),
        stopEditing(!0)
      ]
    },
    "layout.resetManualLayout": {
      guard: "not readonly",
      actions: [
        cancelEditing(),
        disableCompareWithLatest(),
        triggerChange({
          op: "reset-manual-layout"
        })
      ]
    },
    "xyflow.resized": {
      guard: ({ context: context2 }) => context2.features.enableFitView && !context2.viewportChangedManually,
      actions: [
        cancelFitDiagram$1(),
        raiseFitDiagram$1({ delay: 200 })
      ]
    },
    "open.elementDetails": {
      actions: openOverlay()
    },
    "open.relationshipsBrowser": {
      actions: openOverlay()
    },
    "open.relationshipDetails": {
      actions: openOverlay()
    },
    "open.source": {
      guard: "enabled: OpenSource",
      actions: emitOpenSource()
    },
    "walkthrough.start": {
      guard: "is dynamic view",
      target: targetState.walkthrough
    },
    "toggle.feature": {
      actions: [
        assignToggledFeatures(),
        ensureEditorActor()
      ]
    },
    "update.features": {
      actions: [
        updateFeatures(),
        ensureOverlaysActor(),
        ensureSearchActor(),
        ensureEditorActor()
      ]
    },
    "xyflow.nodeMouseEnter": {
      actions: onNodeMouseEnter()
    },
    "xyflow.nodeMouseLeave": {
      actions: onNodeMouseLeave()
    },
    "xyflow.edgeMouseEnter": {
      actions: onEdgeMouseEnter()
    },
    "xyflow.edgeMouseLeave": {
      actions: onEdgeMouseLeave()
    },
    "xyflow.edgeDoubleClick": {
      guard: xstateGuards_cjsExports.and([
        "not readonly",
        ({ event }) => !!event.edge.data.controlPoints && event.edge.data.controlPoints.length > 0
      ]),
      actions: [
        startEditing("edge"),
        onEdgeDoubleClick(),
        stopEditing(!0)
      ]
    },
    "notations.highlight": {
      actions: notationsHighlight()
    },
    "notations.unhighlight": {
      actions: undimEverything()
    },
    "tag.highlight": {
      actions: tagHighlight()
    },
    "tag.unhighlight": {
      actions: undimEverything()
    },
    "open.search": {
      guard: "enabled: Search",
      actions: xstateActions_cjsExports.sendTo(({ system }) => typedSystem(system).searchActorRef, ({ event }) => ({
        type: "open",
        search: event.search
      }))
    },
    "xyflow.paneClick": {
      actions: [
        resetLastClickedNode(),
        emitPaneClick()
      ]
    },
    "xyflow.nodeClick": {
      actions: [
        assignLastClickedNode(),
        emitNodeClick()
      ]
    },
    "xyflow.edgeClick": {
      actions: [
        resetLastClickedNode(),
        emitEdgeClick()
      ]
    },
    "xyflow.fitDiagram": {
      guard: "enabled: FitView",
      actions: fitDiagram$1()
    },
    "xyflow.setViewport": {
      actions: setViewport()
    },
    "update.view": [
      // Redirect to navigating state if received another view
      {
        guard: "is another view",
        target: targetState.navigating
      },
      // Otherwise, just update the view in place
      {
        actions: updateView$1()
      }
    ],
    "media.print.on": {
      target: targetState.printing
    }
  }
}), key$1 = "likec4:diagram:toggledFeatures", DiagramToggledFeaturesPersistence = {
  read() {
    try {
      let fromStorage = sessionStorage.getItem(key$1);
      return fromStorage ? JSON.parse(fromStorage) : null;
    } catch (e2) {
      return console.error(`Error reading fromStorage ${key$1}:`, e2), null;
    }
  },
  write(toggledFeatures) {
    return sessionStorage.setItem(key$1, JSON.stringify(t$8(toggledFeatures, e$c))), toggledFeatures;
  }
}, _diagramMachine = machine$1.createMachine({
  initial: "initializing",
  context: ({ input: input2 }) => ({
    ...input2,
    xyedges: [],
    xynodes: [],
    features: { ...DefaultFeatures },
    toggledFeatures: DiagramToggledFeaturesPersistence.read() ?? {
      enableReadOnly: !0,
      enableCompareWithLatest: !1
    },
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    viewportChangedManually: !1,
    lastOnNavigate: null,
    lastClickedNode: null,
    focusedNode: null,
    autoUnfocusTimer: !1,
    activeElementDetails: null,
    viewportBefore: null,
    viewportOnManualLayout: null,
    viewportOnAutoLayout: null,
    navigationHistory: {
      currentIndex: 0,
      history: []
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    xyflow: null,
    dynamicViewVariant: input2.dynamicViewVariant ?? (input2.view._type === "dynamic" ? input2.view.variant : "diagram") ?? "diagram",
    activeWalkthrough: null
  }),
  states: {
    initializing,
    isReady,
    ready,
    navigating,
    final: {
      type: "final",
      entry: [
        stopEditorActor(),
        cancelFitDiagram$1(),
        xstateActions_cjsExports.stopChild("hotkey"),
        xstateActions_cjsExports.stopChild("overlays"),
        xstateActions_cjsExports.stopChild("search"),
        xstateActions_cjsExports.stopChild("mediaPrint"),
        xstateActions_cjsExports.assign({
          xyflow: null,
          xystore: null,
          xyedges: [],
          xynodes: [],
          initialized: {
            xydata: !1,
            xyflow: !1
          }
        })
      ]
    }
  },
  on: {
    "update.nodeData": {
      actions: xstateActions_cjsExports.assign(updateNodeData)
    },
    "update.edgeData": {
      actions: xstateActions_cjsExports.assign(updateEdgeData)
    },
    "switch.dynamicViewVariant": {
      guard: ({ context: context2, event }) => context2.dynamicViewVariant !== event.variant,
      actions: [
        assignDynamicViewVariant(),
        raiseUpdateView()
      ]
    },
    "update.inputs": {
      actions: updateInputs()
    },
    "update.view-bounds": {
      actions: xstateActions_cjsExports.assign(({ context: context2, event }) => ({
        view: {
          ...context2.view,
          bounds: event.bounds
        }
      }))
    },
    "update.features": {
      actions: updateFeatures()
    },
    "trigger.change": {
      actions: triggerChange()
    },
    "emit.onLayoutTypeChange": {
      actions: emitOnLayoutTypeChange()
    },
    "xyflow.applyNodeChanges": {
      actions: xstateActions_cjsExports.assign({
        xynodes: ({ context: context2, event }) => applyNodeChanges(event.changes, context2.xynodes)
      })
    },
    "xyflow.applyEdgeChanges": {
      actions: xstateActions_cjsExports.assign({
        xyedges: ({ context: context2, event }) => applyEdgeChanges(event.changes, context2.xyedges)
      })
    },
    "xyflow.viewportMoved": {
      actions: xstateActions_cjsExports.assign(({ event, context: context2 }) => ({
        viewportChangedManually: context2.viewportChangedManually || event.manually,
        viewport: event.viewport
      }))
    },
    destroy: {
      target: ".final"
    }
  }
}), diagramMachine = _diagramMachine;
function DiagramActorProvider({
  view,
  zoomable,
  pannable,
  nodesDraggable,
  nodesSelectable,
  fitViewPadding,
  where,
  children: children2,
  dynamicViewVariant: _defaultVariant
}) {
  const xystore = useStoreApi(), editorActor = useEditorActorLogic(view.id), actor = useActorRef(
    diagramMachine.provide({
      actors: {
        editorActor
      }
    }),
    {
      id: "diagram",
      systemId: "diagram",
      // ...inspector,
      input: {
        xystore,
        view,
        zoomable,
        pannable,
        fitViewPadding,
        nodesDraggable,
        nodesSelectable,
        where,
        dynamicViewVariant: _defaultVariant
      }
    }
  ), actorRef = useRef(actor);
  actorRef.current !== actor && (console.warn("DiagramMachine actor instance changed", {
    context: {
      previous: actorRef.current.getSnapshot().context,
      current: actor.getSnapshot().context
    }
  }), actorRef.current = actor);
  const [api, setApi] = useState(() => makeDiagramApi(actorRef));
  useEffect(() => {
    setApi((api2) => api2.ref === actorRef ? api2 : (console.warn(
      "DiagramMachine actorRef changed, creating new DiagramApi instance, this should not happen during the lifetime of the actor"
    ), makeDiagramApi(actorRef)));
  }, [actorRef]);
  const features = useEnabledFeatures();
  return useEffect(
    () => actor.send({ type: "update.features", features }),
    [features, actor]
  ), useEffect(
    () => actor.send({
      type: "update.inputs",
      inputs: { zoomable, where, pannable, fitViewPadding, nodesDraggable, nodesSelectable }
    }),
    [zoomable, where, pannable, fitViewPadding, actor, nodesDraggable, nodesSelectable]
  ), useUpdateEffect(() => {
    _defaultVariant && actor.send({ type: "switch.dynamicViewVariant", variant: _defaultVariant });
  }, [_defaultVariant, actor]), useRafEffect(
    () => actor.send({ type: "update.view", view, source: "external" }),
    [actor, view]
  ), /* @__PURE__ */ jsx(DiagramActorContextProvider, { value: actor, children: /* @__PURE__ */ jsxs(DiagramApiContextProvider, { value: api, children: [
    /* @__PURE__ */ jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsx(CurrentViewModelProvider, { actorRef: actor, children: children2 }) }),
    /* @__PURE__ */ jsx(DiagramActorEventListener, {})
  ] }) });
}
const selectFromActor = ({ context: context2 }) => {
  let toggledFeatures = context2.toggledFeatures;
  const hasDrifts2 = context2.view.drifts != null && context2.view.drifts.length > 0, enableCompareWithLatest = context2.features.enableCompareWithLatest && (toggledFeatures.enableCompareWithLatest ?? !1) && e$5(context2.activeWalkthrough) && hasDrifts2, enableReadOnly = context2.features.enableReadOnly || toggledFeatures.enableReadOnly || !!context2.activeWalkthrough || context2.dynamicViewVariant === "sequence" && context2.view._type === "dynamic" || enableCompareWithLatest && context2.view._layout === "auto";
  return (toggledFeatures.enableReadOnly !== enableReadOnly || toggledFeatures.enableCompareWithLatest !== enableCompareWithLatest) && (toggledFeatures = {
    ...toggledFeatures,
    enableCompareWithLatest,
    enableReadOnly
  }), {
    toggledFeatures,
    viewId: context2.view.id
  };
}, compareSelected = (a2, b2) => a2.viewId === b2.viewId && shallowEqual$1(a2.toggledFeatures, b2.toggledFeatures);
function CurrentViewModelProvider({ children: children2, actorRef }) {
  const { viewId, toggledFeatures } = useSelector(
    actorRef,
    selectFromActor,
    compareSelected
  ), viewmodel = useLikeC4Model().findView(viewId);
  return /* @__PURE__ */ jsx(CurrentViewModelContext.Provider, { value: viewmodel, children: /* @__PURE__ */ jsx(DiagramFeatures, { overrides: toggledFeatures, children: children2 }) });
}
const DiagramActorEventListener = memo$3(() => {
  const diagram = useDiagram(), {
    onNavigateTo,
    onOpenSource,
    // onChange,
    onLayoutTypeChange,
    handlersRef
  } = useDiagramEventHandlers();
  useOnDiagramEvent("openSource", ({ params }) => onOpenSource?.(params)), useOnDiagramEvent("navigateTo", ({ viewId }) => onNavigateTo?.(viewId)), useOnDiagramEvent("onLayoutTypeChange", ({ layoutType }) => {
    onLayoutTypeChange?.(layoutType);
  }), useOnDiagramEvent(
    "initialized",
    ({ instance: xyflow2 }) => {
      try {
        handlersRef.current.onInitialized?.({ diagram, xyflow: xyflow2 });
      } catch (error) {
        console.error(error);
      }
    },
    { once: !0 }
  );
  const toggledFeatures = useDiagramContext(
    (ctx) => ctx.toggledFeatures,
    shallowEqual$1
  );
  return useUpdateEffect(() => {
    DiagramToggledFeaturesPersistence.write(t$c(toggledFeatures, e$5));
  }, [toggledFeatures]), null;
}), Channel = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (r2) => r2 >= 255 ? 255 : r2 < 0 ? 0 : r2,
    g: (g2) => g2 >= 255 ? 255 : g2 < 0 ? 0 : g2,
    b: (b2) => b2 >= 255 ? 255 : b2 < 0 ? 0 : b2,
    h: (h2) => h2 % 360,
    s: (s2) => s2 >= 100 ? 100 : s2 < 0 ? 0 : s2,
    l: (l) => l >= 100 ? 100 : l < 0 ? 0 : l,
    a: (a2) => a2 >= 1 ? 1 : a2 < 0 ? 0 : a2
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (c) => {
    const n2 = c / 255;
    return c > 0.03928 ? Math.pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (p2, q, t2) => (t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p2 + (q - p2) * 6 * t2 : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p2 + (q - p2) * (2 / 3 - t2) * 6 : p2),
  hsl2rgb: ({ h: h2, s: s2, l }, channel) => {
    if (!s2)
      return l * 2.55;
    h2 /= 360, s2 /= 100, l /= 100;
    const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2, p2 = 2 * l - q;
    switch (channel) {
      case "r":
        return Channel.hue2rgb(p2, q, h2 + 1 / 3) * 255;
      case "g":
        return Channel.hue2rgb(p2, q, h2) * 255;
      case "b":
        return Channel.hue2rgb(p2, q, h2 - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: r2, g: g2, b: b2 }, channel) => {
    r2 /= 255, g2 /= 255, b2 /= 255;
    const max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2), l = (max2 + min2) / 2;
    if (channel === "l")
      return l * 100;
    if (max2 === min2)
      return 0;
    const d2 = max2 - min2, s2 = l > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
    if (channel === "s")
      return s2 * 100;
    switch (max2) {
      case r2:
        return ((g2 - b2) / d2 + (g2 < b2 ? 6 : 0)) * 60;
      case g2:
        return ((b2 - r2) / d2 + 2) * 60;
      case b2:
        return ((r2 - g2) / d2 + 4) * 60;
      default:
        return -1;
    }
  }
}, Lang = {
  /* API */
  clamp: (number2, lower2, upper) => lower2 > upper ? Math.min(lower2, Math.max(upper, number2)) : Math.min(upper, Math.max(lower2, number2)),
  round: (number2) => Math.round(number2 * 1e10) / 1e10
}, Unit = {
  /* API */
  dec2hex: (dec) => {
    const hex2 = Math.round(dec).toString(16);
    return hex2.length > 1 ? hex2 : `0${hex2}`;
  }
}, Utils = {
  channel: Channel,
  lang: Lang,
  unit: Unit
}, DEC2HEX = {};
for (let i2 = 0; i2 <= 255; i2++)
  DEC2HEX[i2] = Utils.unit.dec2hex(i2);
const TYPE = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
class Type {
  constructor() {
    this.type = TYPE.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(type) {
    if (this.type && this.type !== type)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = type;
  }
  reset() {
    this.type = TYPE.ALL;
  }
  is(type) {
    return this.type === type;
  }
}
class Channels {
  /* CONSTRUCTOR */
  constructor(data, color2) {
    this.color = color2, this.changed = !1, this.data = data, this.type = new Type();
  }
  /* API */
  set(data, color2) {
    return this.color = color2, this.changed = !1, this.data = data, this.type.type = TYPE.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const data = this.data, { h: h2, s: s2, l } = data;
    h2 === void 0 && (data.h = Utils.channel.rgb2hsl(data, "h")), s2 === void 0 && (data.s = Utils.channel.rgb2hsl(data, "s")), l === void 0 && (data.l = Utils.channel.rgb2hsl(data, "l"));
  }
  _ensureRGB() {
    const data = this.data, { r: r2, g: g2, b: b2 } = data;
    r2 === void 0 && (data.r = Utils.channel.hsl2rgb(data, "r")), g2 === void 0 && (data.g = Utils.channel.hsl2rgb(data, "g")), b2 === void 0 && (data.b = Utils.channel.hsl2rgb(data, "b"));
  }
  /* GETTERS */
  get r() {
    const data = this.data, r2 = data.r;
    return !this.type.is(TYPE.HSL) && r2 !== void 0 ? r2 : (this._ensureHSL(), Utils.channel.hsl2rgb(data, "r"));
  }
  get g() {
    const data = this.data, g2 = data.g;
    return !this.type.is(TYPE.HSL) && g2 !== void 0 ? g2 : (this._ensureHSL(), Utils.channel.hsl2rgb(data, "g"));
  }
  get b() {
    const data = this.data, b2 = data.b;
    return !this.type.is(TYPE.HSL) && b2 !== void 0 ? b2 : (this._ensureHSL(), Utils.channel.hsl2rgb(data, "b"));
  }
  get h() {
    const data = this.data, h2 = data.h;
    return !this.type.is(TYPE.RGB) && h2 !== void 0 ? h2 : (this._ensureRGB(), Utils.channel.rgb2hsl(data, "h"));
  }
  get s() {
    const data = this.data, s2 = data.s;
    return !this.type.is(TYPE.RGB) && s2 !== void 0 ? s2 : (this._ensureRGB(), Utils.channel.rgb2hsl(data, "s"));
  }
  get l() {
    const data = this.data, l = data.l;
    return !this.type.is(TYPE.RGB) && l !== void 0 ? l : (this._ensureRGB(), Utils.channel.rgb2hsl(data, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(r2) {
    this.type.set(TYPE.RGB), this.changed = !0, this.data.r = r2;
  }
  set g(g2) {
    this.type.set(TYPE.RGB), this.changed = !0, this.data.g = g2;
  }
  set b(b2) {
    this.type.set(TYPE.RGB), this.changed = !0, this.data.b = b2;
  }
  set h(h2) {
    this.type.set(TYPE.HSL), this.changed = !0, this.data.h = h2;
  }
  set s(s2) {
    this.type.set(TYPE.HSL), this.changed = !0, this.data.s = s2;
  }
  set l(l) {
    this.type.set(TYPE.HSL), this.changed = !0, this.data.l = l;
  }
  set a(a2) {
    this.changed = !0, this.data.a = a2;
  }
}
const channels = new Channels({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), Hex = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (color2) => {
    if (color2.charCodeAt(0) !== 35)
      return;
    const match = color2.match(Hex.re);
    if (!match)
      return;
    const hex2 = match[1], dec = parseInt(hex2, 16), length = hex2.length, hasAlpha = length % 4 === 0, isFullLength = length > 4, multiplier = isFullLength ? 1 : 17, bits = isFullLength ? 8 : 4, bitsOffset = hasAlpha ? 0 : -1, mask = isFullLength ? 255 : 15;
    return channels.set({
      r: (dec >> bits * (bitsOffset + 3) & mask) * multiplier,
      g: (dec >> bits * (bitsOffset + 2) & mask) * multiplier,
      b: (dec >> bits * (bitsOffset + 1) & mask) * multiplier,
      a: hasAlpha ? (dec & mask) * multiplier / 255 : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { r: r2, g: g2, b: b2, a: a2 } = channels2;
    return a2 < 1 ? `#${DEC2HEX[Math.round(r2)]}${DEC2HEX[Math.round(g2)]}${DEC2HEX[Math.round(b2)]}${DEC2HEX[Math.round(a2 * 255)]}` : `#${DEC2HEX[Math.round(r2)]}${DEC2HEX[Math.round(g2)]}${DEC2HEX[Math.round(b2)]}`;
  }
}, HSL = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (hue) => {
    const match = hue.match(HSL.hueRe);
    if (match) {
      const [, number2, unit] = match;
      switch (unit) {
        case "grad":
          return Utils.channel.clamp.h(parseFloat(number2) * 0.9);
        case "rad":
          return Utils.channel.clamp.h(parseFloat(number2) * 180 / Math.PI);
        case "turn":
          return Utils.channel.clamp.h(parseFloat(number2) * 360);
      }
    }
    return Utils.channel.clamp.h(parseFloat(hue));
  },
  /* API */
  parse: (color2) => {
    const charCode = color2.charCodeAt(0);
    if (charCode !== 104 && charCode !== 72)
      return;
    const match = color2.match(HSL.re);
    if (!match)
      return;
    const [, h2, s2, l, a2, isAlphaPercentage] = match;
    return channels.set({
      h: HSL._hue2deg(h2),
      s: Utils.channel.clamp.s(parseFloat(s2)),
      l: Utils.channel.clamp.l(parseFloat(l)),
      a: a2 ? Utils.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { h: h2, s: s2, l, a: a2 } = channels2;
    return a2 < 1 ? `hsla(${Utils.lang.round(h2)}, ${Utils.lang.round(s2)}%, ${Utils.lang.round(l)}%, ${a2})` : `hsl(${Utils.lang.round(h2)}, ${Utils.lang.round(s2)}%, ${Utils.lang.round(l)}%)`;
  }
}, Keyword = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (color2) => {
    color2 = color2.toLowerCase();
    const hex2 = Keyword.colors[color2];
    if (hex2)
      return Hex.parse(hex2);
  },
  stringify: (channels2) => {
    const hex2 = Hex.stringify(channels2);
    for (const name in Keyword.colors)
      if (Keyword.colors[name] === hex2)
        return name;
  }
}, RGB = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (color2) => {
    const charCode = color2.charCodeAt(0);
    if (charCode !== 114 && charCode !== 82)
      return;
    const match = color2.match(RGB.re);
    if (!match)
      return;
    const [, r2, isRedPercentage, g2, isGreenPercentage, b2, isBluePercentage, a2, isAlphaPercentage] = match;
    return channels.set({
      r: Utils.channel.clamp.r(isRedPercentage ? parseFloat(r2) * 2.55 : parseFloat(r2)),
      g: Utils.channel.clamp.g(isGreenPercentage ? parseFloat(g2) * 2.55 : parseFloat(g2)),
      b: Utils.channel.clamp.b(isBluePercentage ? parseFloat(b2) * 2.55 : parseFloat(b2)),
      a: a2 ? Utils.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { r: r2, g: g2, b: b2, a: a2 } = channels2;
    return a2 < 1 ? `rgba(${Utils.lang.round(r2)}, ${Utils.lang.round(g2)}, ${Utils.lang.round(b2)}, ${Utils.lang.round(a2)})` : `rgb(${Utils.lang.round(r2)}, ${Utils.lang.round(g2)}, ${Utils.lang.round(b2)})`;
  }
}, Color = {
  /* VARIABLES */
  format: {
    keyword: Keyword,
    hex: Hex,
    rgb: RGB,
    rgba: RGB,
    hsl: HSL,
    hsla: HSL
  },
  /* API */
  parse: (color2) => {
    if (typeof color2 != "string")
      return color2;
    const channels2 = Hex.parse(color2) || RGB.parse(color2) || HSL.parse(color2) || Keyword.parse(color2);
    if (channels2)
      return channels2;
    throw new Error(`Unsupported color format: "${color2}"`);
  },
  stringify: (channels2) => !channels2.changed && channels2.color ? channels2.color : channels2.type.is(TYPE.HSL) || channels2.data.r === void 0 ? HSL.stringify(channels2) : channels2.a < 1 || !Number.isInteger(channels2.r) || !Number.isInteger(channels2.g) || !Number.isInteger(channels2.b) ? RGB.stringify(channels2) : Hex.stringify(channels2)
}, change = (color2, channels2) => {
  const ch = Color.parse(color2);
  for (const c in channels2)
    ch[c] = Utils.channel.clamp[c](channels2[c]);
  return Color.stringify(ch);
}, rgba = (r2, g2, b2 = 0, a2 = 1) => {
  if (typeof r2 != "number")
    return change(r2, { a: g2 });
  const channels$1 = channels.set({
    r: Utils.channel.clamp.r(r2),
    g: Utils.channel.clamp.g(g2),
    b: Utils.channel.clamp.b(b2),
    a: Utils.channel.clamp.a(a2)
  });
  return Color.stringify(channels$1);
}, toHex = (color2) => Color.format.hex.stringify(Color.parse(color2)), toRgba = (color2) => Color.format.rgba.stringify(Color.parse(color2)), adjust = (color2, channels2) => {
  const ch = Color.parse(color2), changes = {};
  for (const c in channels2)
    channels2[c] && (changes[c] = ch[c] + channels2[c]);
  return change(color2, changes);
}, mix = (color1, color2, weight = 50) => {
  const { r: r1, g: g1, b: b1, a: a1 } = Color.parse(color1), { r: r2, g: g2, b: b2, a: a2 } = Color.parse(color2), weightScale = weight / 100, weightNormalized = weightScale * 2 - 1, alphaDelta = a1 - a2, weight1 = ((weightNormalized * alphaDelta === -1 ? weightNormalized : (weightNormalized + alphaDelta) / (1 + weightNormalized * alphaDelta)) + 1) / 2, weight2 = 1 - weight1, r3 = r1 * weight1 + r2 * weight2, g3 = g1 * weight1 + g2 * weight2, b3 = b1 * weight1 + b2 * weight2, a3 = a1 * weightScale + a2 * (1 - weightScale);
  return rgba(r3, g3, b3, a3);
}, scale = (color2, channels2) => {
  const ch = Color.parse(color2), adjustments = {}, delta = (amount, weight, max2) => weight > 0 ? (max2 - amount) * weight / 100 : amount * weight / 100;
  for (const c in channels2)
    adjustments[c] = delta(ch[c], channels2[c], Utils.channel.max[c]);
  return adjust(color2, adjustments);
}, scheme = (scheme2) => `[data-mantine-color-scheme="${scheme2}"]`, whenDark = scheme("dark"), MAX_DEPTH = 5, generateCompoundColors = (rootSelector, name, colors, depth) => {
  const compoundDarkColor = (color2) => toHex(
    scale(color2, {
      l: -22 - 5 * depth,
      s: -10 - 6 * depth
    })
  ), compoundLightColor = (color2) => toHex(
    scale(color2, {
      l: -20 - 3 * depth,
      s: -3 - 6 * depth
    })
  ), selector3 = `:where(${rootSelector} [data-likec4-color="${name}"][data-compound-depth="${depth}"])`;
  return `
${selector3} {
  --likec4-palette-fill: ${compoundLightColor(colors.elements.fill)};
  --likec4-palette-stroke: ${compoundLightColor(colors.elements.stroke)};
}
${whenDark} ${selector3} {
  --likec4-palette-fill: ${compoundDarkColor(colors.elements.fill)};
  --likec4-palette-stroke: ${compoundDarkColor(colors.elements.stroke)};
}
  `.trim();
};
function toStyle(rootSelector, name, colors) {
  const { elements, relationships } = colors, selector3 = `:where(${rootSelector} [data-likec4-color=${name}])`;
  return [
    `
${selector3} {
  --likec4-palette-fill: ${elements.fill};
  --likec4-palette-stroke: ${elements.stroke};
  --likec4-palette-hiContrast: ${elements.hiContrast};
  --likec4-palette-loContrast: ${elements.loContrast};
  --likec4-palette-relation-stroke: ${relationships.line};
  --likec4-palette-relation-label: ${relationships.label};
  --likec4-palette-relation-label-bg: ${relationships.labelBg};
  --likec4-palette-relation-stroke-selected: ${toRgba(mix(relationships.line, "black", 85))};
}
${whenDark} ${selector3} {
  --likec4-palette-relation-stroke-selected: ${toRgba(mix(relationships.line, "white", 70))};
}

  `.trim(),
    ...t$6(1, MAX_DEPTH + 1).map((depth) => generateCompoundColors(rootSelector, name, colors, depth))
  ].join(`
`);
}
function generateBuiltInColorStyles(rootSelector, theme) {
  return t$s(
    theme.colors,
    t$o(),
    t$f(([color2, values2]) => toStyle(rootSelector, color2, values2)),
    t$i(`
`)
  );
}
const LikeC4Styles = memo$3(({ id: id2 }) => {
  const rootSelector = `#${id2}`, nonce = useMantineStyleNonce()?.(), { theme } = useLikeC4Styles(), colorsStyles = generateBuiltInColorStyles(rootSelector, theme);
  return /* @__PURE__ */ jsx(
    "style",
    {
      type: "text/css",
      "data-likec4-colors": id2,
      dangerouslySetInnerHTML: { __html: colorsStyles },
      nonce
    }
  );
}), fontsCss = '@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-400-normal.woff) format("woff");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-500-normal.woff) format("woff");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-600-normal.woff) format("woff");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-400-normal.woff) format("woff");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-500-normal.woff) format("woff");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-600-normal.woff) format("woff");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-400-normal.woff) format("woff");unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-500-normal.woff) format("woff");unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/cyrillic-ext-600-normal.woff) format("woff");unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:400;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-400-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-400-normal.woff) format("woff");unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:500;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-500-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-500-normal.woff) format("woff");unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:IBM Plex Sans;font-style:normal;font-display:swap;font-weight:600;src:url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-600-normal.woff2) format("woff2"),url(https://cdn.jsdelivr.net/fontsource/fonts/ibm-plex-sans@latest/latin-ext-600-normal.woff) format("woff");unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}', inlinedStyles = `@layer reset,base,mantine,xyflow,tokens,recipes,utilities;@layer mantine{:root,:host{color-scheme:var(--mantine-color-scheme)}*,*:before,*:after{box-sizing:border-box}input,button,textarea,select{font:inherit}button,select{text-transform:none}body,:host{margin:0;font-family:var(--mantine-font-family);font-size:var(--mantine-font-size-md);line-height:var(--mantine-line-height);background-color:var(--mantine-color-body);color:var(--mantine-color-text);-webkit-font-smoothing:var(--mantine-webkit-font-smoothing);-moz-osx-font-smoothing:var(--mantine-moz-font-smoothing)}@media screen and (max-device-width:31.25em){body,:host{-webkit-text-size-adjust:100%}}@media(prefers-reduced-motion:reduce){[data-respect-reduced-motion] [data-reduce-motion]{transition:none;animation:none}}[data-mantine-color-scheme=light] .mantine-light-hidden,[data-mantine-color-scheme=dark] .mantine-dark-hidden{display:none}.mantine-focus-auto:focus-visible{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.mantine-focus-always:focus{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.mantine-focus-never:focus{outline:none}.mantine-active:active{transform:translateY(calc(.0625rem * var(--mantine-scale)))}fieldset:disabled .mantine-active:active{transform:none}:where([dir=rtl]) .mantine-rotate-rtl{transform:rotate(180deg)}:root,:host{--mantine-z-index-app: 100;--mantine-z-index-modal: 200;--mantine-z-index-popover: 300;--mantine-z-index-overlay: 400;--mantine-z-index-max: 9999;--mantine-scale: 1;--mantine-cursor-type: default;--mantine-webkit-font-smoothing: antialiased;--mantine-moz-font-smoothing: grayscale;--mantine-color-white: #fff;--mantine-color-black: #000;--mantine-line-height: 1.55;--mantine-font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;--mantine-font-family-monospace: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;--mantine-font-family-headings: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;--mantine-heading-font-weight: 700;--mantine-heading-text-wrap: wrap;--mantine-radius-default: calc(.25rem * var(--mantine-scale));--mantine-primary-color-filled: var(--mantine-color-blue-filled);--mantine-primary-color-filled-hover: var(--mantine-color-blue-filled-hover);--mantine-primary-color-light: var(--mantine-color-blue-light);--mantine-primary-color-light-hover: var(--mantine-color-blue-light-hover);--mantine-primary-color-light-color: var(--mantine-color-blue-light-color);--mantine-breakpoint-xs: 36em;--mantine-breakpoint-sm: 48em;--mantine-breakpoint-md: 62em;--mantine-breakpoint-lg: 75em;--mantine-breakpoint-xl: 88em;--mantine-spacing-xs: calc(.625rem * var(--mantine-scale));--mantine-spacing-sm: calc(.75rem * var(--mantine-scale));--mantine-spacing-md: calc(1rem * var(--mantine-scale));--mantine-spacing-lg: calc(1.25rem * var(--mantine-scale));--mantine-spacing-xl: calc(2rem * var(--mantine-scale));--mantine-font-size-xs: calc(.75rem * var(--mantine-scale));--mantine-font-size-sm: calc(.875rem * var(--mantine-scale));--mantine-font-size-md: calc(1rem * var(--mantine-scale));--mantine-font-size-lg: calc(1.125rem * var(--mantine-scale));--mantine-font-size-xl: calc(1.25rem * var(--mantine-scale));--mantine-line-height-xs: 1.4;--mantine-line-height-sm: 1.45;--mantine-line-height-md: 1.55;--mantine-line-height-lg: 1.6;--mantine-line-height-xl: 1.65;--mantine-shadow-xs: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), 0 calc(.0625rem * var(--mantine-scale)) calc(.125rem * var(--mantine-scale)) rgba(0, 0, 0, .1);--mantine-shadow-sm: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(.625rem * var(--mantine-scale)) calc(.9375rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(.4375rem * var(--mantine-scale)) calc(.4375rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale));--mantine-shadow-md: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(1.25rem * var(--mantine-scale)) calc(1.5625rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(.625rem * var(--mantine-scale)) calc(.625rem * var(--mantine-scale)) calc(-.3125rem * var(--mantine-scale));--mantine-shadow-lg: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(1.75rem * var(--mantine-scale)) calc(1.4375rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(.75rem * var(--mantine-scale)) calc(.75rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale));--mantine-shadow-xl: 0 calc(.0625rem * var(--mantine-scale)) calc(.1875rem * var(--mantine-scale)) rgba(0, 0, 0, .05), rgba(0, 0, 0, .05) 0 calc(2.25rem * var(--mantine-scale)) calc(1.75rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale)), rgba(0, 0, 0, .04) 0 calc(1.0625rem * var(--mantine-scale)) calc(1.0625rem * var(--mantine-scale)) calc(-.4375rem * var(--mantine-scale));--mantine-radius-xs: calc(.125rem * var(--mantine-scale));--mantine-radius-sm: calc(.25rem * var(--mantine-scale));--mantine-radius-md: calc(.5rem * var(--mantine-scale));--mantine-radius-lg: calc(1rem * var(--mantine-scale));--mantine-radius-xl: calc(2rem * var(--mantine-scale));--mantine-primary-color-0: var(--mantine-color-blue-0);--mantine-primary-color-1: var(--mantine-color-blue-1);--mantine-primary-color-2: var(--mantine-color-blue-2);--mantine-primary-color-3: var(--mantine-color-blue-3);--mantine-primary-color-4: var(--mantine-color-blue-4);--mantine-primary-color-5: var(--mantine-color-blue-5);--mantine-primary-color-6: var(--mantine-color-blue-6);--mantine-primary-color-7: var(--mantine-color-blue-7);--mantine-primary-color-8: var(--mantine-color-blue-8);--mantine-primary-color-9: var(--mantine-color-blue-9);--mantine-color-dark-0: #c9c9c9;--mantine-color-dark-1: #b8b8b8;--mantine-color-dark-2: #828282;--mantine-color-dark-3: #696969;--mantine-color-dark-4: #424242;--mantine-color-dark-5: #3b3b3b;--mantine-color-dark-6: #2e2e2e;--mantine-color-dark-7: #242424;--mantine-color-dark-8: #1f1f1f;--mantine-color-dark-9: #141414;--mantine-color-gray-0: #f8f9fa;--mantine-color-gray-1: #f1f3f5;--mantine-color-gray-2: #e9ecef;--mantine-color-gray-3: #dee2e6;--mantine-color-gray-4: #ced4da;--mantine-color-gray-5: #adb5bd;--mantine-color-gray-6: #868e96;--mantine-color-gray-7: #495057;--mantine-color-gray-8: #343a40;--mantine-color-gray-9: #212529;--mantine-color-red-0: #fff5f5;--mantine-color-red-1: #ffe3e3;--mantine-color-red-2: #ffc9c9;--mantine-color-red-3: #ffa8a8;--mantine-color-red-4: #ff8787;--mantine-color-red-5: #ff6b6b;--mantine-color-red-6: #fa5252;--mantine-color-red-7: #f03e3e;--mantine-color-red-8: #e03131;--mantine-color-red-9: #c92a2a;--mantine-color-pink-0: #fff0f6;--mantine-color-pink-1: #ffdeeb;--mantine-color-pink-2: #fcc2d7;--mantine-color-pink-3: #faa2c1;--mantine-color-pink-4: #f783ac;--mantine-color-pink-5: #f06595;--mantine-color-pink-6: #e64980;--mantine-color-pink-7: #d6336c;--mantine-color-pink-8: #c2255c;--mantine-color-pink-9: #a61e4d;--mantine-color-grape-0: #f8f0fc;--mantine-color-grape-1: #f3d9fa;--mantine-color-grape-2: #eebefa;--mantine-color-grape-3: #e599f7;--mantine-color-grape-4: #da77f2;--mantine-color-grape-5: #cc5de8;--mantine-color-grape-6: #be4bdb;--mantine-color-grape-7: #ae3ec9;--mantine-color-grape-8: #9c36b5;--mantine-color-grape-9: #862e9c;--mantine-color-violet-0: #f3f0ff;--mantine-color-violet-1: #e5dbff;--mantine-color-violet-2: #d0bfff;--mantine-color-violet-3: #b197fc;--mantine-color-violet-4: #9775fa;--mantine-color-violet-5: #845ef7;--mantine-color-violet-6: #7950f2;--mantine-color-violet-7: #7048e8;--mantine-color-violet-8: #6741d9;--mantine-color-violet-9: #5f3dc4;--mantine-color-indigo-0: #edf2ff;--mantine-color-indigo-1: #dbe4ff;--mantine-color-indigo-2: #bac8ff;--mantine-color-indigo-3: #91a7ff;--mantine-color-indigo-4: #748ffc;--mantine-color-indigo-5: #5c7cfa;--mantine-color-indigo-6: #4c6ef5;--mantine-color-indigo-7: #4263eb;--mantine-color-indigo-8: #3b5bdb;--mantine-color-indigo-9: #364fc7;--mantine-color-blue-0: #e7f5ff;--mantine-color-blue-1: #d0ebff;--mantine-color-blue-2: #a5d8ff;--mantine-color-blue-3: #74c0fc;--mantine-color-blue-4: #4dabf7;--mantine-color-blue-5: #339af0;--mantine-color-blue-6: #228be6;--mantine-color-blue-7: #1c7ed6;--mantine-color-blue-8: #1971c2;--mantine-color-blue-9: #1864ab;--mantine-color-cyan-0: #e3fafc;--mantine-color-cyan-1: #c5f6fa;--mantine-color-cyan-2: #99e9f2;--mantine-color-cyan-3: #66d9e8;--mantine-color-cyan-4: #3bc9db;--mantine-color-cyan-5: #22b8cf;--mantine-color-cyan-6: #15aabf;--mantine-color-cyan-7: #1098ad;--mantine-color-cyan-8: #0c8599;--mantine-color-cyan-9: #0b7285;--mantine-color-teal-0: #e6fcf5;--mantine-color-teal-1: #c3fae8;--mantine-color-teal-2: #96f2d7;--mantine-color-teal-3: #63e6be;--mantine-color-teal-4: #38d9a9;--mantine-color-teal-5: #20c997;--mantine-color-teal-6: #12b886;--mantine-color-teal-7: #0ca678;--mantine-color-teal-8: #099268;--mantine-color-teal-9: #087f5b;--mantine-color-green-0: #ebfbee;--mantine-color-green-1: #d3f9d8;--mantine-color-green-2: #b2f2bb;--mantine-color-green-3: #8ce99a;--mantine-color-green-4: #69db7c;--mantine-color-green-5: #51cf66;--mantine-color-green-6: #40c057;--mantine-color-green-7: #37b24d;--mantine-color-green-8: #2f9e44;--mantine-color-green-9: #2b8a3e;--mantine-color-lime-0: #f4fce3;--mantine-color-lime-1: #e9fac8;--mantine-color-lime-2: #d8f5a2;--mantine-color-lime-3: #c0eb75;--mantine-color-lime-4: #a9e34b;--mantine-color-lime-5: #94d82d;--mantine-color-lime-6: #82c91e;--mantine-color-lime-7: #74b816;--mantine-color-lime-8: #66a80f;--mantine-color-lime-9: #5c940d;--mantine-color-yellow-0: #fff9db;--mantine-color-yellow-1: #fff3bf;--mantine-color-yellow-2: #ffec99;--mantine-color-yellow-3: #ffe066;--mantine-color-yellow-4: #ffd43b;--mantine-color-yellow-5: #fcc419;--mantine-color-yellow-6: #fab005;--mantine-color-yellow-7: #f59f00;--mantine-color-yellow-8: #f08c00;--mantine-color-yellow-9: #e67700;--mantine-color-orange-0: #fff4e6;--mantine-color-orange-1: #ffe8cc;--mantine-color-orange-2: #ffd8a8;--mantine-color-orange-3: #ffc078;--mantine-color-orange-4: #ffa94d;--mantine-color-orange-5: #ff922b;--mantine-color-orange-6: #fd7e14;--mantine-color-orange-7: #f76707;--mantine-color-orange-8: #e8590c;--mantine-color-orange-9: #d9480f;--mantine-h1-font-size: calc(2.125rem * var(--mantine-scale));--mantine-h1-line-height: 1.3;--mantine-h1-font-weight: 700;--mantine-h2-font-size: calc(1.625rem * var(--mantine-scale));--mantine-h2-line-height: 1.35;--mantine-h2-font-weight: 700;--mantine-h3-font-size: calc(1.375rem * var(--mantine-scale));--mantine-h3-line-height: 1.4;--mantine-h3-font-weight: 700;--mantine-h4-font-size: calc(1.125rem * var(--mantine-scale));--mantine-h4-line-height: 1.45;--mantine-h4-font-weight: 700;--mantine-h5-font-size: calc(1rem * var(--mantine-scale));--mantine-h5-line-height: 1.5;--mantine-h5-font-weight: 700;--mantine-h6-font-size: calc(.875rem * var(--mantine-scale));--mantine-h6-line-height: 1.5;--mantine-h6-font-weight: 700}:root[data-mantine-color-scheme=dark],:host([data-mantine-color-scheme="dark"]){--mantine-color-scheme: dark;--mantine-primary-color-contrast: var(--mantine-color-white);--mantine-color-bright: var(--mantine-color-white);--mantine-color-text: var(--mantine-color-dark-0);--mantine-color-body: var(--mantine-color-dark-7);--mantine-color-error: var(--mantine-color-red-8);--mantine-color-placeholder: var(--mantine-color-dark-3);--mantine-color-anchor: var(--mantine-color-blue-4);--mantine-color-default: var(--mantine-color-dark-6);--mantine-color-default-hover: var(--mantine-color-dark-5);--mantine-color-default-color: var(--mantine-color-white);--mantine-color-default-border: var(--mantine-color-dark-4);--mantine-color-dimmed: var(--mantine-color-dark-2);--mantine-color-disabled: var(--mantine-color-dark-6);--mantine-color-disabled-color: var(--mantine-color-dark-3);--mantine-color-disabled-border: var(--mantine-color-dark-4);--mantine-color-dark-text: var(--mantine-color-dark-4);--mantine-color-dark-filled: var(--mantine-color-dark-8);--mantine-color-dark-filled-hover: var(--mantine-color-dark-9);--mantine-color-dark-light: rgba(46, 46, 46, .15);--mantine-color-dark-light-hover: rgba(46, 46, 46, .2);--mantine-color-dark-light-color: var(--mantine-color-dark-3);--mantine-color-dark-outline: var(--mantine-color-dark-4);--mantine-color-dark-outline-hover: rgba(66, 66, 66, .05);--mantine-color-gray-text: var(--mantine-color-gray-4);--mantine-color-gray-filled: var(--mantine-color-gray-8);--mantine-color-gray-filled-hover: var(--mantine-color-gray-9);--mantine-color-gray-light: rgba(134, 142, 150, .15);--mantine-color-gray-light-hover: rgba(134, 142, 150, .2);--mantine-color-gray-light-color: var(--mantine-color-gray-3);--mantine-color-gray-outline: var(--mantine-color-gray-4);--mantine-color-gray-outline-hover: rgba(206, 212, 218, .05);--mantine-color-red-text: var(--mantine-color-red-4);--mantine-color-red-filled: var(--mantine-color-red-8);--mantine-color-red-filled-hover: var(--mantine-color-red-9);--mantine-color-red-light: rgba(250, 82, 82, .15);--mantine-color-red-light-hover: rgba(250, 82, 82, .2);--mantine-color-red-light-color: var(--mantine-color-red-3);--mantine-color-red-outline: var(--mantine-color-red-4);--mantine-color-red-outline-hover: rgba(255, 135, 135, .05);--mantine-color-pink-text: var(--mantine-color-pink-4);--mantine-color-pink-filled: var(--mantine-color-pink-8);--mantine-color-pink-filled-hover: var(--mantine-color-pink-9);--mantine-color-pink-light: rgba(230, 73, 128, .15);--mantine-color-pink-light-hover: rgba(230, 73, 128, .2);--mantine-color-pink-light-color: var(--mantine-color-pink-3);--mantine-color-pink-outline: var(--mantine-color-pink-4);--mantine-color-pink-outline-hover: rgba(247, 131, 172, .05);--mantine-color-grape-text: var(--mantine-color-grape-4);--mantine-color-grape-filled: var(--mantine-color-grape-8);--mantine-color-grape-filled-hover: var(--mantine-color-grape-9);--mantine-color-grape-light: rgba(190, 75, 219, .15);--mantine-color-grape-light-hover: rgba(190, 75, 219, .2);--mantine-color-grape-light-color: var(--mantine-color-grape-3);--mantine-color-grape-outline: var(--mantine-color-grape-4);--mantine-color-grape-outline-hover: rgba(218, 119, 242, .05);--mantine-color-violet-text: var(--mantine-color-violet-4);--mantine-color-violet-filled: var(--mantine-color-violet-8);--mantine-color-violet-filled-hover: var(--mantine-color-violet-9);--mantine-color-violet-light: rgba(121, 80, 242, .15);--mantine-color-violet-light-hover: rgba(121, 80, 242, .2);--mantine-color-violet-light-color: var(--mantine-color-violet-3);--mantine-color-violet-outline: var(--mantine-color-violet-4);--mantine-color-violet-outline-hover: rgba(151, 117, 250, .05);--mantine-color-indigo-text: var(--mantine-color-indigo-4);--mantine-color-indigo-filled: var(--mantine-color-indigo-8);--mantine-color-indigo-filled-hover: var(--mantine-color-indigo-9);--mantine-color-indigo-light: rgba(76, 110, 245, .15);--mantine-color-indigo-light-hover: rgba(76, 110, 245, .2);--mantine-color-indigo-light-color: var(--mantine-color-indigo-3);--mantine-color-indigo-outline: var(--mantine-color-indigo-4);--mantine-color-indigo-outline-hover: rgba(116, 143, 252, .05);--mantine-color-blue-text: var(--mantine-color-blue-4);--mantine-color-blue-filled: var(--mantine-color-blue-8);--mantine-color-blue-filled-hover: var(--mantine-color-blue-9);--mantine-color-blue-light: rgba(34, 139, 230, .15);--mantine-color-blue-light-hover: rgba(34, 139, 230, .2);--mantine-color-blue-light-color: var(--mantine-color-blue-3);--mantine-color-blue-outline: var(--mantine-color-blue-4);--mantine-color-blue-outline-hover: rgba(77, 171, 247, .05);--mantine-color-cyan-text: var(--mantine-color-cyan-4);--mantine-color-cyan-filled: var(--mantine-color-cyan-8);--mantine-color-cyan-filled-hover: var(--mantine-color-cyan-9);--mantine-color-cyan-light: rgba(21, 170, 191, .15);--mantine-color-cyan-light-hover: rgba(21, 170, 191, .2);--mantine-color-cyan-light-color: var(--mantine-color-cyan-3);--mantine-color-cyan-outline: var(--mantine-color-cyan-4);--mantine-color-cyan-outline-hover: rgba(59, 201, 219, .05);--mantine-color-teal-text: var(--mantine-color-teal-4);--mantine-color-teal-filled: var(--mantine-color-teal-8);--mantine-color-teal-filled-hover: var(--mantine-color-teal-9);--mantine-color-teal-light: rgba(18, 184, 134, .15);--mantine-color-teal-light-hover: rgba(18, 184, 134, .2);--mantine-color-teal-light-color: var(--mantine-color-teal-3);--mantine-color-teal-outline: var(--mantine-color-teal-4);--mantine-color-teal-outline-hover: rgba(56, 217, 169, .05);--mantine-color-green-text: var(--mantine-color-green-4);--mantine-color-green-filled: var(--mantine-color-green-8);--mantine-color-green-filled-hover: var(--mantine-color-green-9);--mantine-color-green-light: rgba(64, 192, 87, .15);--mantine-color-green-light-hover: rgba(64, 192, 87, .2);--mantine-color-green-light-color: var(--mantine-color-green-3);--mantine-color-green-outline: var(--mantine-color-green-4);--mantine-color-green-outline-hover: rgba(105, 219, 124, .05);--mantine-color-lime-text: var(--mantine-color-lime-4);--mantine-color-lime-filled: var(--mantine-color-lime-8);--mantine-color-lime-filled-hover: var(--mantine-color-lime-9);--mantine-color-lime-light: rgba(130, 201, 30, .15);--mantine-color-lime-light-hover: rgba(130, 201, 30, .2);--mantine-color-lime-light-color: var(--mantine-color-lime-3);--mantine-color-lime-outline: var(--mantine-color-lime-4);--mantine-color-lime-outline-hover: rgba(169, 227, 75, .05);--mantine-color-yellow-text: var(--mantine-color-yellow-4);--mantine-color-yellow-filled: var(--mantine-color-yellow-8);--mantine-color-yellow-filled-hover: var(--mantine-color-yellow-9);--mantine-color-yellow-light: rgba(250, 176, 5, .15);--mantine-color-yellow-light-hover: rgba(250, 176, 5, .2);--mantine-color-yellow-light-color: var(--mantine-color-yellow-3);--mantine-color-yellow-outline: var(--mantine-color-yellow-4);--mantine-color-yellow-outline-hover: rgba(255, 212, 59, .05);--mantine-color-orange-text: var(--mantine-color-orange-4);--mantine-color-orange-filled: var(--mantine-color-orange-8);--mantine-color-orange-filled-hover: var(--mantine-color-orange-9);--mantine-color-orange-light: rgba(253, 126, 20, .15);--mantine-color-orange-light-hover: rgba(253, 126, 20, .2);--mantine-color-orange-light-color: var(--mantine-color-orange-3);--mantine-color-orange-outline: var(--mantine-color-orange-4);--mantine-color-orange-outline-hover: rgba(255, 169, 77, .05)}:root[data-mantine-color-scheme=light],:host([data-mantine-color-scheme="light"]){--mantine-color-scheme: light;--mantine-primary-color-contrast: var(--mantine-color-white);--mantine-color-bright: var(--mantine-color-black);--mantine-color-text: #000;--mantine-color-body: #fff;--mantine-color-error: var(--mantine-color-red-6);--mantine-color-placeholder: var(--mantine-color-gray-5);--mantine-color-anchor: var(--mantine-color-blue-6);--mantine-color-default: var(--mantine-color-white);--mantine-color-default-hover: var(--mantine-color-gray-0);--mantine-color-default-color: var(--mantine-color-black);--mantine-color-default-border: var(--mantine-color-gray-4);--mantine-color-dimmed: var(--mantine-color-gray-6);--mantine-color-disabled: var(--mantine-color-gray-2);--mantine-color-disabled-color: var(--mantine-color-gray-5);--mantine-color-disabled-border: var(--mantine-color-gray-3);--mantine-color-dark-text: var(--mantine-color-dark-filled);--mantine-color-dark-filled: var(--mantine-color-dark-6);--mantine-color-dark-filled-hover: var(--mantine-color-dark-7);--mantine-color-dark-light: rgba(46, 46, 46, .1);--mantine-color-dark-light-hover: rgba(46, 46, 46, .12);--mantine-color-dark-light-color: var(--mantine-color-dark-6);--mantine-color-dark-outline: var(--mantine-color-dark-6);--mantine-color-dark-outline-hover: rgba(46, 46, 46, .05);--mantine-color-gray-text: var(--mantine-color-gray-filled);--mantine-color-gray-filled: var(--mantine-color-gray-6);--mantine-color-gray-filled-hover: var(--mantine-color-gray-7);--mantine-color-gray-light: rgba(134, 142, 150, .1);--mantine-color-gray-light-hover: rgba(134, 142, 150, .12);--mantine-color-gray-light-color: var(--mantine-color-gray-6);--mantine-color-gray-outline: var(--mantine-color-gray-6);--mantine-color-gray-outline-hover: rgba(134, 142, 150, .05);--mantine-color-red-text: var(--mantine-color-red-filled);--mantine-color-red-filled: var(--mantine-color-red-6);--mantine-color-red-filled-hover: var(--mantine-color-red-7);--mantine-color-red-light: rgba(250, 82, 82, .1);--mantine-color-red-light-hover: rgba(250, 82, 82, .12);--mantine-color-red-light-color: var(--mantine-color-red-6);--mantine-color-red-outline: var(--mantine-color-red-6);--mantine-color-red-outline-hover: rgba(250, 82, 82, .05);--mantine-color-pink-text: var(--mantine-color-pink-filled);--mantine-color-pink-filled: var(--mantine-color-pink-6);--mantine-color-pink-filled-hover: var(--mantine-color-pink-7);--mantine-color-pink-light: rgba(230, 73, 128, .1);--mantine-color-pink-light-hover: rgba(230, 73, 128, .12);--mantine-color-pink-light-color: var(--mantine-color-pink-6);--mantine-color-pink-outline: var(--mantine-color-pink-6);--mantine-color-pink-outline-hover: rgba(230, 73, 128, .05);--mantine-color-grape-text: var(--mantine-color-grape-filled);--mantine-color-grape-filled: var(--mantine-color-grape-6);--mantine-color-grape-filled-hover: var(--mantine-color-grape-7);--mantine-color-grape-light: rgba(190, 75, 219, .1);--mantine-color-grape-light-hover: rgba(190, 75, 219, .12);--mantine-color-grape-light-color: var(--mantine-color-grape-6);--mantine-color-grape-outline: var(--mantine-color-grape-6);--mantine-color-grape-outline-hover: rgba(190, 75, 219, .05);--mantine-color-violet-text: var(--mantine-color-violet-filled);--mantine-color-violet-filled: var(--mantine-color-violet-6);--mantine-color-violet-filled-hover: var(--mantine-color-violet-7);--mantine-color-violet-light: rgba(121, 80, 242, .1);--mantine-color-violet-light-hover: rgba(121, 80, 242, .12);--mantine-color-violet-light-color: var(--mantine-color-violet-6);--mantine-color-violet-outline: var(--mantine-color-violet-6);--mantine-color-violet-outline-hover: rgba(121, 80, 242, .05);--mantine-color-indigo-text: var(--mantine-color-indigo-filled);--mantine-color-indigo-filled: var(--mantine-color-indigo-6);--mantine-color-indigo-filled-hover: var(--mantine-color-indigo-7);--mantine-color-indigo-light: rgba(76, 110, 245, .1);--mantine-color-indigo-light-hover: rgba(76, 110, 245, .12);--mantine-color-indigo-light-color: var(--mantine-color-indigo-6);--mantine-color-indigo-outline: var(--mantine-color-indigo-6);--mantine-color-indigo-outline-hover: rgba(76, 110, 245, .05);--mantine-color-blue-text: var(--mantine-color-blue-filled);--mantine-color-blue-filled: var(--mantine-color-blue-6);--mantine-color-blue-filled-hover: var(--mantine-color-blue-7);--mantine-color-blue-light: rgba(34, 139, 230, .1);--mantine-color-blue-light-hover: rgba(34, 139, 230, .12);--mantine-color-blue-light-color: var(--mantine-color-blue-6);--mantine-color-blue-outline: var(--mantine-color-blue-6);--mantine-color-blue-outline-hover: rgba(34, 139, 230, .05);--mantine-color-cyan-text: var(--mantine-color-cyan-filled);--mantine-color-cyan-filled: var(--mantine-color-cyan-6);--mantine-color-cyan-filled-hover: var(--mantine-color-cyan-7);--mantine-color-cyan-light: rgba(21, 170, 191, .1);--mantine-color-cyan-light-hover: rgba(21, 170, 191, .12);--mantine-color-cyan-light-color: var(--mantine-color-cyan-6);--mantine-color-cyan-outline: var(--mantine-color-cyan-6);--mantine-color-cyan-outline-hover: rgba(21, 170, 191, .05);--mantine-color-teal-text: var(--mantine-color-teal-filled);--mantine-color-teal-filled: var(--mantine-color-teal-6);--mantine-color-teal-filled-hover: var(--mantine-color-teal-7);--mantine-color-teal-light: rgba(18, 184, 134, .1);--mantine-color-teal-light-hover: rgba(18, 184, 134, .12);--mantine-color-teal-light-color: var(--mantine-color-teal-6);--mantine-color-teal-outline: var(--mantine-color-teal-6);--mantine-color-teal-outline-hover: rgba(18, 184, 134, .05);--mantine-color-green-text: var(--mantine-color-green-filled);--mantine-color-green-filled: var(--mantine-color-green-6);--mantine-color-green-filled-hover: var(--mantine-color-green-7);--mantine-color-green-light: rgba(64, 192, 87, .1);--mantine-color-green-light-hover: rgba(64, 192, 87, .12);--mantine-color-green-light-color: var(--mantine-color-green-6);--mantine-color-green-outline: var(--mantine-color-green-6);--mantine-color-green-outline-hover: rgba(64, 192, 87, .05);--mantine-color-lime-text: var(--mantine-color-lime-filled);--mantine-color-lime-filled: var(--mantine-color-lime-6);--mantine-color-lime-filled-hover: var(--mantine-color-lime-7);--mantine-color-lime-light: rgba(130, 201, 30, .1);--mantine-color-lime-light-hover: rgba(130, 201, 30, .12);--mantine-color-lime-light-color: var(--mantine-color-lime-6);--mantine-color-lime-outline: var(--mantine-color-lime-6);--mantine-color-lime-outline-hover: rgba(130, 201, 30, .05);--mantine-color-yellow-text: var(--mantine-color-yellow-filled);--mantine-color-yellow-filled: var(--mantine-color-yellow-6);--mantine-color-yellow-filled-hover: var(--mantine-color-yellow-7);--mantine-color-yellow-light: rgba(250, 176, 5, .1);--mantine-color-yellow-light-hover: rgba(250, 176, 5, .12);--mantine-color-yellow-light-color: var(--mantine-color-yellow-6);--mantine-color-yellow-outline: var(--mantine-color-yellow-6);--mantine-color-yellow-outline-hover: rgba(250, 176, 5, .05);--mantine-color-orange-text: var(--mantine-color-orange-filled);--mantine-color-orange-filled: var(--mantine-color-orange-6);--mantine-color-orange-filled-hover: var(--mantine-color-orange-7);--mantine-color-orange-light: rgba(253, 126, 20, .1);--mantine-color-orange-light-hover: rgba(253, 126, 20, .12);--mantine-color-orange-light-color: var(--mantine-color-orange-6);--mantine-color-orange-outline: var(--mantine-color-orange-6);--mantine-color-orange-outline-hover: rgba(253, 126, 20, .05)}.m_d57069b5{--scrollarea-scrollbar-size: calc(.75rem * var(--mantine-scale));position:relative;overflow:hidden}.m_d57069b5:where([data-autosize]) .m_b1336c6{min-width:min-content}.m_c0783ff9{scrollbar-width:none;overscroll-behavior:var(--scrollarea-over-scroll-behavior);-ms-overflow-style:none;-webkit-overflow-scrolling:touch;width:100%;height:100%}.m_c0783ff9::-webkit-scrollbar{display:none}.m_c0783ff9:where([data-scrollbars=xy],[data-scrollbars=y]):where([data-offset-scrollbars=xy],[data-offset-scrollbars=y],[data-offset-scrollbars=present]):where([data-vertical-hidden]){padding-inline-end:0;padding-inline-start:0}.m_c0783ff9:where([data-scrollbars=xy],[data-scrollbars=y]):where([data-offset-scrollbars=xy],[data-offset-scrollbars=y],[data-offset-scrollbars=present]):not([data-vertical-hidden]){padding-inline-end:var(--scrollarea-scrollbar-size);padding-inline-start:unset}.m_c0783ff9:where([data-scrollbars=xy],[data-scrollbars=x]):where([data-offset-scrollbars=xy],[data-offset-scrollbars=x],[data-offset-scrollbars=present]):where([data-horizontal-hidden]){padding-bottom:0}.m_c0783ff9:where([data-scrollbars=xy],[data-scrollbars=x]):where([data-offset-scrollbars=xy],[data-offset-scrollbars=x],[data-offset-scrollbars=present]):not([data-horizontal-hidden]){padding-bottom:var(--scrollarea-scrollbar-size)}.m_f8f631dd{min-width:100%;display:table}.m_c44ba933{user-select:none;touch-action:none;box-sizing:border-box;transition:background-color .15s ease,opacity .15s ease;padding:calc(var(--scrollarea-scrollbar-size) / 5);display:flex;background-color:transparent;flex-direction:row}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_c44ba933:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=light]) .m_c44ba933:hover>.m_d8b5e363{background-color:#00000080}:where([data-mantine-color-scheme=dark]) .m_c44ba933:hover{background-color:var(--mantine-color-dark-8)}:where([data-mantine-color-scheme=dark]) .m_c44ba933:hover>.m_d8b5e363{background-color:#ffffff80}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_c44ba933:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=light]) .m_c44ba933:active>.m_d8b5e363{background-color:#00000080}:where([data-mantine-color-scheme=dark]) .m_c44ba933:active{background-color:var(--mantine-color-dark-8)}:where([data-mantine-color-scheme=dark]) .m_c44ba933:active>.m_d8b5e363{background-color:#ffffff80}}.m_c44ba933:where([data-hidden],[data-state=hidden]){display:none}.m_c44ba933:where([data-orientation=vertical]){width:var(--scrollarea-scrollbar-size);top:0;bottom:var(--sa-corner-width);inset-inline-end:0}.m_c44ba933:where([data-orientation=horizontal]){height:var(--scrollarea-scrollbar-size);flex-direction:column;bottom:0;inset-inline-start:0;inset-inline-end:var(--sa-corner-width)}.m_d8b5e363{flex:1;border-radius:var(--scrollarea-scrollbar-size);position:relative;transition:background-color .15s ease;overflow:hidden;opacity:var(--thumb-opacity)}.m_d8b5e363:before{content:"";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:100%;height:100%;min-width:calc(2.75rem * var(--mantine-scale));min-height:calc(2.75rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_d8b5e363{background-color:#0006}:where([data-mantine-color-scheme=dark]) .m_d8b5e363{background-color:#fff6}.m_21657268{position:absolute;opacity:0;transition:opacity .15s ease;display:block;inset-inline-end:0;bottom:0}:where([data-mantine-color-scheme=light]) .m_21657268{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_21657268{background-color:var(--mantine-color-dark-8)}.m_21657268:where([data-hovered]){opacity:1}.m_21657268:where([data-hidden]){display:none}.m_b1336c6{min-width:100%}.m_87cf2631{background-color:transparent;cursor:pointer;border:0;padding:0;appearance:none;font-size:var(--mantine-font-size-md);text-align:left;text-decoration:none;color:inherit;touch-action:manipulation;-webkit-tap-highlight-color:transparent}:where([dir=rtl]) .m_87cf2631{text-align:right}.m_515a97f8{border:0;clip:rect(0 0 0 0);height:calc(.0625rem * var(--mantine-scale));width:calc(.0625rem * var(--mantine-scale));margin:calc(-.0625rem * var(--mantine-scale));overflow:hidden;padding:0;position:absolute;white-space:nowrap}.m_1b7284a3{--paper-radius: var(--mantine-radius-default);outline:0;-webkit-tap-highlight-color:transparent;display:block;touch-action:manipulation;text-decoration:none;border-radius:var(--paper-radius);box-shadow:var(--paper-shadow);background-color:var(--mantine-color-body)}[data-mantine-color-scheme=light] .m_1b7284a3{--paper-border-color: var(--mantine-color-gray-3)}[data-mantine-color-scheme=dark] .m_1b7284a3{--paper-border-color: var(--mantine-color-dark-4)}.m_1b7284a3:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid var(--paper-border-color)}.m_9814e45f{inset:0;position:absolute;background:var(--overlay-bg, rgba(0, 0, 0, .6));-webkit-backdrop-filter:var(--overlay-filter);backdrop-filter:var(--overlay-filter);border-radius:var(--overlay-radius, 0);z-index:var(--overlay-z-index)}.m_9814e45f:where([data-fixed]){position:fixed}.m_9814e45f:where([data-center]){display:flex;align-items:center;justify-content:center}.m_38a85659{position:absolute;border:1px solid var(--popover-border-color);padding:var(--mantine-spacing-sm) var(--mantine-spacing-md);box-shadow:var(--popover-shadow, none);border-radius:var(--popover-radius, var(--mantine-radius-default))}.m_38a85659:where([data-fixed]){position:fixed}.m_38a85659:focus{outline:none}:where([data-mantine-color-scheme=light]) .m_38a85659{--popover-border-color: var(--mantine-color-gray-2);background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_38a85659{--popover-border-color: var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-6)}.m_a31dc6c1{background-color:inherit;border:1px solid var(--popover-border-color);z-index:1}.m_3d7bc908{position:fixed;inset:0}.m_5ae2e3c{--loader-size-xs: calc(1.125rem * var(--mantine-scale));--loader-size-sm: calc(1.375rem * var(--mantine-scale));--loader-size-md: calc(2.25rem * var(--mantine-scale));--loader-size-lg: calc(2.75rem * var(--mantine-scale));--loader-size-xl: calc(3.625rem * var(--mantine-scale));--loader-size: var(--loader-size-md);--loader-color: var(--mantine-primary-color-filled)}@keyframes m_5d2b3b9d{0%{transform:scale(.6);opacity:0}50%,to{transform:scale(1)}}.m_7a2bd4cd{position:relative;width:var(--loader-size);height:var(--loader-size);display:flex;gap:calc(var(--loader-size) / 5)}.m_870bb79{flex:1;background:var(--loader-color);animation:m_5d2b3b9d 1.2s cubic-bezier(0,.5,.5,1) infinite;border-radius:calc(.125rem * var(--mantine-scale))}.m_870bb79:nth-of-type(1){animation-delay:-.24s}.m_870bb79:nth-of-type(2){animation-delay:-.12s}.m_870bb79:nth-of-type(3){animation-delay:0}@keyframes m_aac34a1{0%,to{transform:scale(1);opacity:1}50%{transform:scale(.6);opacity:.5}}.m_4e3f22d7{display:flex;justify-content:center;align-items:center;gap:calc(var(--loader-size) / 10);position:relative;width:var(--loader-size);height:var(--loader-size)}.m_870c4af{width:calc(var(--loader-size) / 3 - var(--loader-size) / 15);height:calc(var(--loader-size) / 3 - var(--loader-size) / 15);border-radius:50%;background:var(--loader-color);animation:m_aac34a1 .8s infinite linear}.m_870c4af:nth-child(2){animation-delay:.4s}@keyframes m_f8e89c4b{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.m_b34414df{display:inline-block;width:var(--loader-size);height:var(--loader-size)}.m_b34414df:after{content:"";display:block;width:var(--loader-size);height:var(--loader-size);border-radius:calc(625rem * var(--mantine-scale));border-width:calc(var(--loader-size) / 8);border-style:solid;border-color:var(--loader-color) var(--loader-color) var(--loader-color) transparent;animation:m_f8e89c4b 1.2s linear infinite}.m_8d3f4000{--ai-size-xs: calc(1.125rem * var(--mantine-scale));--ai-size-sm: calc(1.375rem * var(--mantine-scale));--ai-size-md: calc(1.75rem * var(--mantine-scale));--ai-size-lg: calc(2.125rem * var(--mantine-scale));--ai-size-xl: calc(2.75rem * var(--mantine-scale));--ai-size-input-xs: calc(1.875rem * var(--mantine-scale));--ai-size-input-sm: calc(2.25rem * var(--mantine-scale));--ai-size-input-md: calc(2.625rem * var(--mantine-scale));--ai-size-input-lg: calc(3.125rem * var(--mantine-scale));--ai-size-input-xl: calc(3.75rem * var(--mantine-scale));--ai-size: var(--ai-size-md);--ai-color: var(--mantine-color-white);line-height:1;display:inline-flex;align-items:center;justify-content:center;position:relative;user-select:none;overflow:hidden;width:var(--ai-size);height:var(--ai-size);min-width:var(--ai-size);min-height:var(--ai-size);border-radius:var(--ai-radius, var(--mantine-radius-default));background:var(--ai-bg, var(--mantine-primary-color-filled));color:var(--ai-color, var(--mantine-color-white));border:var(--ai-bd, calc(.0625rem * var(--mantine-scale)) solid transparent);cursor:pointer}@media(hover:hover){.m_8d3f4000:hover:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--ai-hover, var(--mantine-primary-color-filled-hover));color:var(--ai-hover-color, var(--ai-color))}}@media(hover:none){.m_8d3f4000:active:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--ai-hover, var(--mantine-primary-color-filled-hover));color:var(--ai-hover-color, var(--ai-color))}}.m_8d3f4000[data-loading]{cursor:not-allowed}.m_8d3f4000[data-loading] .m_8d3afb97{opacity:0;transform:translateY(100%)}.m_8d3f4000:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){cursor:not-allowed;border:calc(.0625rem * var(--mantine-scale)) solid transparent;color:var(--mantine-color-disabled-color);background:var(--mantine-color-disabled)}.m_8d3f4000:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])):active{transform:none}.m_302b9fb1{inset:calc(-.0625rem * var(--mantine-scale));position:absolute;border-radius:var(--ai-radius, var(--mantine-radius-default));display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_302b9fb1{background-color:#ffffff26}:where([data-mantine-color-scheme=dark]) .m_302b9fb1{background-color:#00000026}.m_1a0f1b21{--ai-border-width: calc(.0625rem * var(--mantine-scale));display:flex}.m_1a0f1b21 :where(*):focus{position:relative;z-index:1}.m_1a0f1b21[data-orientation=horizontal]{flex-direction:row}.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):first-child,.m_1a0f1b21[data-orientation=horizontal] .m_437b6484:not(:only-child):first-child{border-end-end-radius:0;border-start-end-radius:0;border-inline-end-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):last-child,.m_1a0f1b21[data-orientation=horizontal] .m_437b6484:not(:only-child):last-child{border-end-start-radius:0;border-start-start-radius:0;border-inline-start-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=horizontal] .m_8d3f4000:not(:only-child):not(:first-child):not(:last-child),.m_1a0f1b21[data-orientation=horizontal] .m_437b6484:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-inline-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=vertical]{flex-direction:column}.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):first-child,.m_1a0f1b21[data-orientation=vertical] .m_437b6484:not(:only-child):first-child{border-end-start-radius:0;border-end-end-radius:0;border-bottom-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):last-child,.m_1a0f1b21[data-orientation=vertical] .m_437b6484:not(:only-child):last-child{border-start-start-radius:0;border-start-end-radius:0;border-top-width:calc(var(--ai-border-width) / 2)}.m_1a0f1b21[data-orientation=vertical] .m_8d3f4000:not(:only-child):not(:first-child):not(:last-child),.m_1a0f1b21[data-orientation=vertical] .m_437b6484:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-bottom-width:calc(var(--ai-border-width) / 2);border-top-width:calc(var(--ai-border-width) / 2)}.m_8d3afb97{display:flex;align-items:center;justify-content:center;transition:transform .15s ease,opacity .1s ease;width:100%;height:100%}.m_437b6484{--section-height-xs: calc(1.125rem * var(--mantine-scale));--section-height-sm: calc(1.375rem * var(--mantine-scale));--section-height-md: calc(1.75rem * var(--mantine-scale));--section-height-lg: calc(2.125rem * var(--mantine-scale));--section-height-xl: calc(2.75rem * var(--mantine-scale));--section-height-input-xs: calc(1.875rem * var(--mantine-scale));--section-height-input-sm: calc(2.25rem * var(--mantine-scale));--section-height-input-md: calc(2.625rem * var(--mantine-scale));--section-height-input-lg: calc(3.125rem * var(--mantine-scale));--section-height-input-xl: calc(3.75rem * var(--mantine-scale));--section-padding-x-xs: calc(.375rem * var(--mantine-scale));--section-padding-x-sm: calc(.5rem * var(--mantine-scale));--section-padding-x-md: calc(.625rem * var(--mantine-scale));--section-padding-x-lg: calc(.75rem * var(--mantine-scale));--section-padding-x-xl: calc(1rem * var(--mantine-scale));--section-height: var(--section-height-sm);--section-padding-x: var(--section-padding-x-sm);--section-color: var(--mantine-color-white);font-weight:600;width:auto;border-radius:var(--section-radius, var(--mantine-radius-default));font-size:var(--section-fz, var(--mantine-font-size-sm));background:var(--section-bg, var(--mantine-primary-color-filled));border:var(--section-bd, calc(.0625rem * var(--mantine-scale)) solid transparent);color:var(--section-color, var(--mantine-color-white));height:var(--section-height, var(--section-height-sm));padding-inline:var(--section-padding-x, var(--section-padding-x-sm));vertical-align:middle;line-height:1;display:inline-flex;align-items:center;justify-content:center}.m_86a44da5{--cb-size-xs: calc(1.125rem * var(--mantine-scale));--cb-size-sm: calc(1.375rem * var(--mantine-scale));--cb-size-md: calc(1.75rem * var(--mantine-scale));--cb-size-lg: calc(2.125rem * var(--mantine-scale));--cb-size-xl: calc(2.75rem * var(--mantine-scale));--cb-size: var(--cb-size-md);--cb-icon-size: 70%;--cb-radius: var(--mantine-radius-default);line-height:1;display:inline-flex;align-items:center;justify-content:center;position:relative;user-select:none;width:var(--cb-size);height:var(--cb-size);min-width:var(--cb-size);min-height:var(--cb-size);border-radius:var(--cb-radius)}:where([data-mantine-color-scheme=light]) .m_86a44da5{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_86a44da5{color:var(--mantine-color-dark-1)}.m_86a44da5[data-disabled],.m_86a44da5:disabled{cursor:not-allowed;opacity:.6}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_220c80f2:where(:not([data-disabled],:disabled)):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_220c80f2:where(:not([data-disabled],:disabled)):hover{background-color:var(--mantine-color-dark-6)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_220c80f2:where(:not([data-disabled],:disabled)):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_220c80f2:where(:not([data-disabled],:disabled)):active{background-color:var(--mantine-color-dark-6)}}.m_4081bf90{display:flex;flex-direction:row;flex-wrap:var(--group-wrap, wrap);justify-content:var(--group-justify, flex-start);align-items:var(--group-align, center);gap:var(--group-gap, var(--mantine-spacing-md))}.m_4081bf90:where([data-grow])>*{flex-grow:1;max-width:var(--group-child-width)}.m_615af6c9{line-height:1;padding:0;margin:0;font-weight:400;font-size:var(--mantine-font-size-md)}.m_b5489c3c{display:flex;justify-content:space-between;align-items:center;padding:var(--mb-padding, var(--mantine-spacing-md));padding-inline-end:calc(var(--mb-padding, var(--mantine-spacing-md)) - calc(.3125rem * var(--mantine-scale)));position:sticky;top:0;background-color:var(--mantine-color-body);z-index:1000;min-height:calc(3.75rem * var(--mantine-scale));transition:padding-inline-end .1s}.m_60c222c7{position:fixed;width:100%;top:0;bottom:0;z-index:var(--mb-z-index);pointer-events:none}.m_fd1ab0aa{pointer-events:all;box-shadow:var(--mb-shadow, var(--mantine-shadow-xl))}.m_fd1ab0aa [data-mantine-scrollbar]{z-index:1001}[data-offset-scrollbars] .m_fd1ab0aa:has([data-mantine-scrollbar]) .m_b5489c3c{padding-inline-end:calc(var(--mb-padding, var(--mantine-spacing-md)) + calc(.3125rem * var(--mantine-scale)))}.m_606cb269{margin-inline-start:auto}.m_5df29311{padding:var(--mb-padding, var(--mantine-spacing-md));padding-top:var(--mb-padding, var(--mantine-spacing-md))}.m_5df29311:where(:not(:only-child)){padding-top:0}.m_6c018570{position:relative;margin-top:var(--input-margin-top, 0rem);margin-bottom:var(--input-margin-bottom, 0rem);--input-height-xs: calc(1.875rem * var(--mantine-scale));--input-height-sm: calc(2.25rem * var(--mantine-scale));--input-height-md: calc(2.625rem * var(--mantine-scale));--input-height-lg: calc(3.125rem * var(--mantine-scale));--input-height-xl: calc(3.75rem * var(--mantine-scale));--input-padding-y-xs: calc(.3125rem * var(--mantine-scale));--input-padding-y-sm: calc(.375rem * var(--mantine-scale));--input-padding-y-md: calc(.5rem * var(--mantine-scale));--input-padding-y-lg: calc(.625rem * var(--mantine-scale));--input-padding-y-xl: calc(.8125rem * var(--mantine-scale));--input-height: var(--input-height-sm);--input-radius: var(--mantine-radius-default);--input-cursor: text;--input-text-align: left;--input-line-height: calc(var(--input-height) - calc(.125rem * var(--mantine-scale)));--input-padding: calc(var(--input-height) / 3);--input-padding-inline-start: var(--input-padding);--input-padding-inline-end: var(--input-padding);--input-placeholder-color: var(--mantine-color-placeholder);--input-color: var(--mantine-color-text);--input-disabled-bg: var(--mantine-color-disabled);--input-disabled-color: var(--mantine-color-disabled-color);--input-left-section-size: var(--input-left-section-width, calc(var(--input-height) - calc(.125rem * var(--mantine-scale))));--input-right-section-size: var( --input-right-section-width, calc(var(--input-height) - calc(.125rem * var(--mantine-scale))) );--input-size: var(--input-height);--section-y: calc(.0625rem * var(--mantine-scale));--left-section-start: calc(.0625rem * var(--mantine-scale));--left-section-border-radius: var(--input-radius) 0 0 var(--input-radius);--right-section-end: calc(.0625rem * var(--mantine-scale));--right-section-border-radius: 0 var(--input-radius) var(--input-radius) 0}.m_6c018570[data-variant=unstyled]{--input-padding: 0;--input-padding-y: 0;--input-padding-inline-start: 0;--input-padding-inline-end: 0}.m_6c018570[data-pointer]{--input-cursor: pointer}.m_6c018570[data-multiline]{--input-padding-y-xs: calc(.28125rem * var(--mantine-scale));--input-padding-y-sm: calc(.34375rem * var(--mantine-scale));--input-padding-y-md: calc(.4375rem * var(--mantine-scale));--input-padding-y-lg: calc(.59375rem * var(--mantine-scale));--input-padding-y-xl: calc(.8125rem * var(--mantine-scale));--input-size: auto;--input-line-height: var(--mantine-line-height)}.m_6c018570[data-with-left-section]{--input-padding-inline-start: var(--input-left-section-size)}.m_6c018570[data-with-right-section]{--input-padding-inline-end: var(--input-right-section-size)}.m_6c018570[data-size=xs] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]){--input-padding-inline-end: calc(2.5625rem * var(--mantine-scale))}.m_6c018570[data-size=sm] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]){--input-padding-inline-end: calc(3.125rem * var(--mantine-scale))}.m_6c018570[data-size=md] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]){--input-padding-inline-end: calc(3.75rem * var(--mantine-scale))}.m_6c018570[data-size=lg] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]){--input-padding-inline-end: calc(4.5rem * var(--mantine-scale))}.m_6c018570[data-size=xl] .m_6c018570[data-with-right-section]:has([data-combined-clear-section]){--input-padding-inline-end: calc(5.5625rem * var(--mantine-scale))}[data-mantine-color-scheme=light] .m_6c018570[data-variant=default]{--input-bd: var(--mantine-color-gray-4);--input-bg: var(--mantine-color-white);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=light] .m_6c018570[data-variant=filled]{--input-bd: transparent;--input-bg: var(--mantine-color-gray-1);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=light] .m_6c018570[data-variant=unstyled]{--input-bd: transparent;--input-bg: transparent;--input-bd-focus: transparent}[data-mantine-color-scheme=dark] .m_6c018570[data-variant=default]{--input-bd: var(--mantine-color-dark-4);--input-bg: var(--mantine-color-dark-6);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=dark] .m_6c018570[data-variant=filled]{--input-bd: transparent;--input-bg: var(--mantine-color-dark-5);--input-bd-focus: var(--mantine-primary-color-filled)}[data-mantine-color-scheme=dark] .m_6c018570[data-variant=unstyled]{--input-bd: transparent;--input-bg: transparent;--input-bd-focus: transparent}[data-mantine-color-scheme] .m_6c018570[data-error]:not([data-variant=unstyled]){--input-bd: var(--mantine-color-error)}[data-mantine-color-scheme] .m_6c018570[data-error]{--input-color: var(--mantine-color-error);--input-placeholder-color: var(--mantine-color-error);--input-section-color: var(--mantine-color-error)}:where([dir=rtl]) .m_6c018570{--input-text-align: right;--left-section-border-radius: 0 var(--input-radius) var(--input-radius) 0;--right-section-border-radius: var(--input-radius) 0 0 var(--input-radius)}.m_8fb7ebe7{-webkit-tap-highlight-color:transparent;appearance:none;resize:var(--input-resize, none);display:block;width:100%;transition:border-color .1s ease;text-align:var(--input-text-align);color:var(--input-color);border:calc(.0625rem * var(--mantine-scale)) solid var(--input-bd);background-color:var(--input-bg);font-family:var(--input-font-family, var(--mantine-font-family));height:var(--input-size);min-height:var(--input-height);line-height:var(--input-line-height);font-size:var(--_input-fz, var(--input-fz, var(--mantine-font-size-md)));border-radius:var(--input-radius);padding-inline-start:var(--input-padding-inline-start);padding-inline-end:var(--input-padding-inline-end);padding-top:var(--input-padding-y, 0rem);padding-bottom:var(--input-padding-y, 0rem);cursor:var(--input-cursor);overflow:var(--input-overflow)}.m_8fb7ebe7[data-no-overflow]{--input-overflow: hidden}.m_8fb7ebe7[data-monospace]{--input-font-family: var(--mantine-font-family-monospace);--_input-fz: calc(var(--input-fz) - calc(.125rem * var(--mantine-scale)))}.m_8fb7ebe7:focus,.m_8fb7ebe7:focus-within{outline:none;--input-bd: var(--input-bd-focus)}[data-error] .m_8fb7ebe7:focus,[data-error] .m_8fb7ebe7:focus-within{--input-bd: var(--mantine-color-error)}.m_8fb7ebe7::placeholder{color:var(--input-placeholder-color);opacity:1}.m_8fb7ebe7::-webkit-inner-spin-button,.m_8fb7ebe7::-webkit-outer-spin-button,.m_8fb7ebe7::-webkit-search-decoration,.m_8fb7ebe7::-webkit-search-cancel-button,.m_8fb7ebe7::-webkit-search-results-button,.m_8fb7ebe7::-webkit-search-results-decoration{appearance:none}.m_8fb7ebe7[type=number]{-moz-appearance:textfield}.m_8fb7ebe7:disabled,.m_8fb7ebe7[data-disabled]{cursor:not-allowed;opacity:.6;background-color:var(--input-disabled-bg);color:var(--input-disabled-color)}.m_8fb7ebe7:has(input:disabled){cursor:not-allowed;opacity:.6;background-color:var(--input-disabled-bg);color:var(--input-disabled-color)}.m_8fb7ebe7[readonly]{caret-color:transparent}.m_82577fc2{pointer-events:var(--section-pointer-events);position:absolute;z-index:1;inset-inline-start:var(--section-start);inset-inline-end:var(--section-end);bottom:var(--section-y);top:var(--section-y);display:flex;align-items:center;justify-content:center;width:var(--section-size);border-radius:var(--section-border-radius);color:var(--input-section-color, var(--mantine-color-dimmed))}.m_82577fc2[data-position=right]{--section-pointer-events: var(--input-right-section-pointer-events);--section-end: var(--right-section-end);--section-size: var(--input-right-section-size);--section-border-radius: var(--right-section-border-radius)}.m_6c018570[data-size=xs] .m_82577fc2[data-position=right]:has([data-combined-clear-section]){--section-size: calc(2.5625rem * var(--mantine-scale))}.m_6c018570[data-size=sm] .m_82577fc2[data-position=right]:has([data-combined-clear-section]){--section-size: calc(3.125rem * var(--mantine-scale))}.m_6c018570[data-size=md] .m_82577fc2[data-position=right]:has([data-combined-clear-section]){--section-size: calc(3.75rem * var(--mantine-scale))}.m_6c018570[data-size=lg] .m_82577fc2[data-position=right]:has([data-combined-clear-section]){--section-size: calc(4.5rem * var(--mantine-scale))}.m_6c018570[data-size=xl] .m_82577fc2[data-position=right]:has([data-combined-clear-section]){--section-size: calc(5.5625rem * var(--mantine-scale))}.m_82577fc2[data-position=left]{--section-pointer-events: var(--input-left-section-pointer-events);--section-start: var(--left-section-start);--section-size: var(--input-left-section-size);--section-border-radius: var(--left-section-border-radius)}.m_88bacfd0{color:var(--input-placeholder-color, var(--mantine-color-placeholder))}[data-error] .m_88bacfd0{--input-placeholder-color: var(--input-color, var(--mantine-color-placeholder))}.m_46b77525{line-height:var(--mantine-line-height)}.m_8fdc1311{display:inline-block;font-weight:500;overflow-wrap:break-word;cursor:default;-webkit-tap-highlight-color:transparent;font-size:var(--input-label-size, var(--mantine-font-size-sm))}.m_78a94662{color:var(--input-asterisk-color, var(--mantine-color-error))}.m_8f816625,.m_fe47ce59{word-wrap:break-word;line-height:1.2;display:block;margin:0;padding:0}.m_8f816625{color:var(--mantine-color-error);font-size:var(--input-error-size, calc(var(--mantine-font-size-sm) - calc(.125rem * var(--mantine-scale))))}.m_fe47ce59{color:var(--mantine-color-dimmed);font-size:var(--input-description-size, calc(var(--mantine-font-size-sm) - calc(.125rem * var(--mantine-scale))))}.m_8bffd616{display:flex}.m_96b553a6{--transition-duration: .15s;top:0;left:0;position:absolute;z-index:0;transition-property:transform,width,height;transition-timing-function:ease;transition-duration:0ms}.m_96b553a6:where([data-initialized]){transition-duration:var(--transition-duration)}.m_96b553a6:where([data-hidden]){background-color:red;display:none}.m_9bdbb667{--accordion-radius: var(--mantine-radius-default)}.m_df78851f{overflow-wrap:break-word}.m_4ba554d4{padding:var(--mantine-spacing-md);padding-top:calc(var(--mantine-spacing-xs) / 2)}.m_8fa820a0{margin:0;padding:0}.m_4ba585b8{width:100%;display:flex;align-items:center;flex-direction:row-reverse;padding-inline:var(--mantine-spacing-md);opacity:1;cursor:pointer;background-color:transparent;color:var(--mantine-color-bright)}.m_4ba585b8:where([data-chevron-position=left]){flex-direction:row;padding-inline-start:0}.m_4ba585b8:where(:disabled,[data-disabled]){opacity:.4;cursor:not-allowed}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):hover,:where([data-mantine-color-scheme=light]) .m_4271d21b:where(:not(:disabled,[data-disabled])):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):hover,:where([data-mantine-color-scheme=dark]) .m_4271d21b:where(:not(:disabled,[data-disabled])):hover{background-color:var(--mantine-color-dark-6)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):active,:where([data-mantine-color-scheme=light]) .m_4271d21b:where(:not(:disabled,[data-disabled])):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_6939a5e9:where(:not(:disabled,[data-disabled])):active,:where([data-mantine-color-scheme=dark]) .m_4271d21b:where(:not(:disabled,[data-disabled])):active{background-color:var(--mantine-color-dark-6)}}.m_df3ffa0f{color:inherit;font-weight:400;flex:1;overflow:hidden;text-overflow:ellipsis;padding-top:var(--mantine-spacing-sm);padding-bottom:var(--mantine-spacing-sm)}.m_3f35ae96{display:flex;align-items:center;justify-content:flex-start;transition:transform var(--accordion-transition-duration, .2s) ease;width:var(--accordion-chevron-size, calc(.9375rem * var(--mantine-scale)));min-width:var(--accordion-chevron-size, calc(.9375rem * var(--mantine-scale)));transform:rotate(0)}.m_3f35ae96:where([data-rotate]){transform:rotate(180deg)}.m_3f35ae96:where([data-position=left]){margin-inline-end:var(--mantine-spacing-md);margin-inline-start:var(--mantine-spacing-md)}.m_9bd771fe{display:flex;align-items:center;justify-content:center;margin-inline-end:var(--mantine-spacing-sm)}.m_9bd771fe:where([data-chevron-position=left]){margin-inline-end:0;margin-inline-start:var(--mantine-spacing-lg)}:where([data-mantine-color-scheme=light]) .m_9bd7b098{--item-border-color: var(--mantine-color-gray-3);--item-filled-color: var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_9bd7b098{--item-border-color: var(--mantine-color-dark-4);--item-filled-color: var(--mantine-color-dark-6)}.m_fe19b709{border-bottom:1px solid var(--item-border-color)}.m_1f921b3b{border:1px solid var(--item-border-color);transition:background-color .15s ease}.m_1f921b3b:where([data-active]){background-color:var(--item-filled-color)}.m_1f921b3b:first-of-type{border-start-start-radius:var(--accordion-radius);border-start-end-radius:var(--accordion-radius)}.m_1f921b3b:first-of-type>[data-accordion-control]{border-start-start-radius:var(--accordion-radius);border-start-end-radius:var(--accordion-radius)}.m_1f921b3b:last-of-type{border-end-start-radius:var(--accordion-radius);border-end-end-radius:var(--accordion-radius)}.m_1f921b3b:last-of-type>[data-accordion-control]{border-end-start-radius:var(--accordion-radius);border-end-end-radius:var(--accordion-radius)}.m_1f921b3b+.m_1f921b3b{border-top:0}.m_2cdf939a{border-radius:var(--accordion-radius)}.m_2cdf939a:where([data-active]){background-color:var(--item-filled-color)}.m_9f59b069{background-color:var(--item-filled-color);border-radius:var(--accordion-radius);border:calc(.0625rem * var(--mantine-scale)) solid transparent;transition:background-color .15s ease}.m_9f59b069[data-active]{border-color:var(--item-border-color)}:where([data-mantine-color-scheme=light]) .m_9f59b069[data-active]{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_9f59b069[data-active]{background-color:var(--mantine-color-dark-7)}.m_9f59b069+.m_9f59b069{margin-top:var(--mantine-spacing-md)}.m_7f854edf{position:fixed;z-index:var(--affix-z-index);inset-inline-start:var(--affix-left);inset-inline-end:var(--affix-right);top:var(--affix-top);bottom:var(--affix-bottom)}.m_66836ed3{--alert-radius: var(--mantine-radius-default);--alert-bg: var(--mantine-primary-color-light);--alert-bd: calc(.0625rem * var(--mantine-scale)) solid transparent;--alert-color: var(--mantine-primary-color-light-color);padding:var(--mantine-spacing-md) var(--mantine-spacing-md);border-radius:var(--alert-radius);position:relative;overflow:hidden;background-color:var(--alert-bg);border:var(--alert-bd);color:var(--alert-color)}.m_a5d60502{display:flex}.m_667c2793{flex:1;display:flex;flex-direction:column;gap:var(--mantine-spacing-xs)}.m_6a03f287{display:flex;align-items:center;justify-content:space-between;font-size:var(--mantine-font-size-sm);font-weight:700}.m_6a03f287:where([data-with-close-button]){padding-inline-end:var(--mantine-spacing-md)}.m_698f4f23{display:block;overflow:hidden;text-overflow:ellipsis}.m_667f2a6a{line-height:1;width:calc(1.25rem * var(--mantine-scale));height:calc(1.25rem * var(--mantine-scale));display:flex;align-items:center;justify-content:flex-start;margin-inline-end:var(--mantine-spacing-md);margin-top:calc(.0625rem * var(--mantine-scale))}.m_7fa78076{text-overflow:ellipsis;overflow:hidden;font-size:var(--mantine-font-size-sm)}:where([data-mantine-color-scheme=light]) .m_7fa78076{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_7fa78076{color:var(--mantine-color-white)}.m_7fa78076:where([data-variant=filled]){color:var(--alert-color)}.m_7fa78076:where([data-variant=white]){color:var(--mantine-color-black)}.m_87f54839{width:calc(1.25rem * var(--mantine-scale));height:calc(1.25rem * var(--mantine-scale));color:var(--alert-color)}.m_b6d8b162{-webkit-tap-highlight-color:transparent;text-decoration:none;font-size:var(--text-fz, var(--mantine-font-size-md));line-height:var(--text-lh, var(--mantine-line-height-md));font-weight:400;margin:0;padding:0;color:var(--text-color)}.m_b6d8b162:where([data-truncate]){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.m_b6d8b162:where([data-truncate=start]){direction:rtl;text-align:right}:where([dir=rtl]) .m_b6d8b162:where([data-truncate=start]){direction:ltr;text-align:left}.m_b6d8b162:where([data-variant=gradient]){background-image:var(--text-gradient);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}.m_b6d8b162:where([data-line-clamp]){overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:var(--text-line-clamp);-webkit-box-orient:vertical}.m_b6d8b162:where([data-inherit]){line-height:inherit;font-weight:inherit;font-size:inherit}.m_b6d8b162:where([data-inline]){line-height:1}.m_849cf0da{color:var(--mantine-color-anchor);text-decoration:none;appearance:none;border:none;display:inline;padding:0;margin:0;background-color:transparent;cursor:pointer}@media(hover:hover){.m_849cf0da:where([data-underline=hover]):hover{text-decoration:underline}}@media(hover:none){.m_849cf0da:where([data-underline=hover]):active{text-decoration:underline}}.m_849cf0da:where([data-underline=not-hover]){text-decoration:underline}@media(hover:hover){.m_849cf0da:where([data-underline=not-hover]):hover{text-decoration:none}}@media(hover:none){.m_849cf0da:where([data-underline=not-hover]):active{text-decoration:none}}.m_849cf0da:where([data-underline=always]){text-decoration:underline}.m_849cf0da:where([data-variant=gradient]),.m_849cf0da:where([data-variant=gradient]):hover{text-decoration:none}.m_849cf0da:where([data-line-clamp]){display:-webkit-box}.m_48204f9b{width:var(--slider-size);height:var(--slider-size);position:relative;border-radius:100%;display:flex;align-items:center;justify-content:center;user-select:none}.m_48204f9b:focus-within{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_48204f9b{--slider-size: calc(3.75rem * var(--mantine-scale));--thumb-size: calc(var(--slider-size) / 5)}:where([data-mantine-color-scheme=light]) .m_48204f9b{background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_48204f9b{background-color:var(--mantine-color-dark-5)}.m_bb9cdbad{position:absolute;inset:calc(.0625rem * var(--mantine-scale));border-radius:var(--slider-size);pointer-events:none}.m_481dd586{width:calc(.125rem * var(--mantine-scale));position:absolute;top:0;bottom:0;left:calc(50% - 1px);transform:rotate(var(--angle))}.m_481dd586:before{content:"";position:absolute;top:calc(var(--thumb-size) / 3);left:calc(.03125rem * var(--mantine-scale));width:calc(.0625rem * var(--mantine-scale));height:calc(var(--thumb-size) / 1.5);transform:translate(-50%,-50%)}:where([data-mantine-color-scheme=light]) .m_481dd586:before{background-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_481dd586:before{background-color:var(--mantine-color-dark-3)}.m_481dd586[data-label]:after{min-width:calc(1.125rem * var(--mantine-scale));text-align:center;content:attr(data-label);position:absolute;top:calc(-1.5rem * var(--mantine-scale));left:calc(-.4375rem * var(--mantine-scale));transform:rotate(calc(360deg - var(--angle)));font-size:var(--mantine-font-size-xs)}.m_bc02ba3d{position:absolute;inset-block:0;inset-inline-start:calc(50% - 1.5px);inset-inline-end:0;height:100%;width:calc(.1875rem * var(--mantine-scale));outline:none;pointer-events:none}.m_bc02ba3d:before{content:"";position:absolute;right:0;top:0;height:min(var(--thumb-size),calc(var(--slider-size) / 2));width:calc(.1875rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_bc02ba3d:before{background-color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_bc02ba3d:before{background-color:var(--mantine-color-dark-1)}.m_bb8e875b{font-size:var(--mantine-font-size-xs)}.m_89ab340[data-resizing]{--app-shell-transition-duration: 0ms !important}.m_89ab340[data-disabled]{--app-shell-header-offset: 0rem !important;--app-shell-navbar-offset: 0rem !important;--app-shell-aside-offset: 0rem !important;--app-shell-footer-offset: 0rem !important}[data-mantine-color-scheme=light] .m_89ab340{--app-shell-border-color: var(--mantine-color-gray-3)}[data-mantine-color-scheme=dark] .m_89ab340{--app-shell-border-color: var(--mantine-color-dark-4)}.m_45252eee,.m_9cdde9a,.m_3b16f56b,.m_8983817,.m_3840c879{transition-duration:var(--app-shell-transition-duration);transition-timing-function:var(--app-shell-transition-timing-function)}.m_45252eee,.m_9cdde9a{position:fixed;display:flex;flex-direction:column;top:var(--app-shell-header-offset, 0rem);height:calc(100dvh - var(--app-shell-header-offset, 0rem) - var(--app-shell-footer-offset, 0rem));background-color:var(--mantine-color-body);transition-property:transform,top,height}:where([data-layout=alt]) .m_45252eee,:where([data-layout=alt]) .m_9cdde9a{top:0rem;height:100dvh}.m_45252eee{inset-inline-start:0;width:var(--app-shell-navbar-width);transition-property:transform,top,height;transform:var(--app-shell-navbar-transform);z-index:var(--app-shell-navbar-z-index)}:where([dir=rtl]) .m_45252eee{transform:var(--app-shell-navbar-transform-rtl)}.m_45252eee:where([data-with-border]){border-inline-end:1px solid var(--app-shell-border-color)}.m_9cdde9a{inset-inline-end:0;width:var(--app-shell-aside-width);transform:var(--app-shell-aside-transform);z-index:var(--app-shell-aside-z-index)}:where([dir=rtl]) .m_9cdde9a{transform:var(--app-shell-aside-transform-rtl)}.m_9cdde9a:where([data-with-border]){border-inline-start:1px solid var(--app-shell-border-color)}:where([data-scroll-locked]) .m_9cdde9a{visibility:var(--app-shell-aside-scroll-locked-visibility)}.m_8983817{padding-inline-start:calc(var(--app-shell-navbar-offset, 0rem) + var(--app-shell-padding));padding-inline-end:calc(var(--app-shell-aside-offset, 0rem) + var(--app-shell-padding));padding-top:calc(var(--app-shell-header-offset, 0rem) + var(--app-shell-padding));padding-bottom:calc(var(--app-shell-footer-offset, 0rem) + var(--app-shell-padding));min-height:100dvh;transition-property:padding}.m_3b16f56b,.m_3840c879{position:fixed;inset-inline:0;transition-property:transform,margin-inline-start,margin-inline-end;background-color:var(--mantine-color-body)}:where([data-layout=alt]) .m_3b16f56b,:where([data-layout=alt]) .m_3840c879{margin-inline-start:var(--app-shell-navbar-offset, 0rem);margin-inline-end:var(--app-shell-aside-offset, 0rem)}.m_3b16f56b{top:0;height:var(--app-shell-header-height);background-color:var(--mantine-color-body);transform:var(--app-shell-header-transform);z-index:var(--app-shell-header-z-index)}.m_3b16f56b:where([data-with-border]){border-bottom:1px solid var(--app-shell-border-color)}.m_3840c879{bottom:0;height:calc(var(--app-shell-footer-height) + env(safe-area-inset-bottom));padding-bottom:env(safe-area-inset-bottom);transform:var(--app-shell-footer-transform);z-index:var(--app-shell-footer-z-index)}.m_3840c879:where([data-with-border]){border-top:1px solid var(--app-shell-border-color)}.m_6dcfc7c7{flex-grow:0}.m_6dcfc7c7:where([data-grow]){flex-grow:1}.m_71ac47fc{--ar-ratio: 1;max-width:100%}.m_71ac47fc>:where(*:not(style)){aspect-ratio:var(--ar-ratio);width:100%}.m_71ac47fc>:where(img,video){object-fit:cover}.m_88b62a41{--combobox-padding: calc(.25rem * var(--mantine-scale));padding:var(--combobox-padding)}.m_88b62a41:has([data-mantine-scrollbar]) .m_985517d8{max-width:calc(100% + var(--combobox-padding))}.m_88b62a41[data-composed]{padding-inline-end:0}.m_88b62a41[data-hidden]{display:none}.m_88b62a41,.m_b2821a6e{--combobox-option-padding-xs: calc(.25rem * var(--mantine-scale)) calc(.5rem * var(--mantine-scale));--combobox-option-padding-sm: calc(.375rem * var(--mantine-scale)) calc(.625rem * var(--mantine-scale));--combobox-option-padding-md: calc(.5rem * var(--mantine-scale)) calc(.75rem * var(--mantine-scale));--combobox-option-padding-lg: calc(.625rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));--combobox-option-padding-xl: calc(.875rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));--combobox-option-padding: var(--combobox-option-padding-sm)}.m_92253aa5{padding:var(--combobox-option-padding);font-size:var(--combobox-option-fz, var(--mantine-font-size-sm));border-radius:var(--mantine-radius-default);background-color:transparent;color:inherit;cursor:pointer;overflow-wrap:break-word}.m_92253aa5:where([data-combobox-selected]){background-color:var(--mantine-primary-color-filled);color:var(--mantine-color-white)}.m_92253aa5:where([data-combobox-disabled]){cursor:not-allowed;opacity:.35}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_92253aa5:hover:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_92253aa5:hover:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-dark-7)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_92253aa5:active:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_92253aa5:active:where(:not([data-combobox-selected],[data-combobox-disabled])){background-color:var(--mantine-color-dark-7)}}.m_985517d8{margin-inline:calc(var(--combobox-padding) * -1);margin-top:calc(var(--combobox-padding) * -1);width:calc(100% + var(--combobox-padding) * 2);border-top-width:0;border-inline-width:0;border-end-start-radius:0;border-end-end-radius:0;margin-bottom:var(--combobox-padding);position:relative}:where([data-mantine-color-scheme=light]) .m_985517d8,:where([data-mantine-color-scheme=light]) .m_985517d8:focus{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_985517d8,:where([data-mantine-color-scheme=dark]) .m_985517d8:focus{border-color:var(--mantine-color-dark-4)}:where([data-mantine-color-scheme=light]) .m_985517d8{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_985517d8{background-color:var(--mantine-color-dark-7)}.m_2530cd1d{font-size:var(--combobox-option-fz, var(--mantine-font-size-sm));text-align:center;padding:var(--combobox-option-padding);color:var(--mantine-color-dimmed)}.m_858f94bd,.m_82b967cb{font-size:var(--combobox-option-fz, var(--mantine-font-size-sm));border:0 solid transparent;margin-inline:calc(var(--combobox-padding) * -1);padding:var(--combobox-option-padding)}:where([data-mantine-color-scheme=light]) .m_858f94bd,:where([data-mantine-color-scheme=light]) .m_82b967cb{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_858f94bd,:where([data-mantine-color-scheme=dark]) .m_82b967cb{border-color:var(--mantine-color-dark-4)}.m_82b967cb{border-top-width:calc(.0625rem * var(--mantine-scale));margin-top:var(--combobox-padding);margin-bottom:calc(var(--combobox-padding) * -1)}.m_858f94bd{border-bottom-width:calc(.0625rem * var(--mantine-scale));margin-bottom:var(--combobox-padding);margin-top:calc(var(--combobox-padding) * -1)}.m_254f3e4f:has(.m_2bb2e9e5:only-child){display:none}.m_2bb2e9e5{color:var(--mantine-color-dimmed);font-size:calc(var(--combobox-option-fz, var(--mantine-font-size-sm)) * .85);padding:var(--combobox-option-padding);font-weight:500;position:relative;display:flex;align-items:center}.m_2bb2e9e5:after{content:"";flex:1;inset-inline:0;height:calc(.0625rem * var(--mantine-scale));margin-inline-start:var(--mantine-spacing-xs)}:where([data-mantine-color-scheme=light]) .m_2bb2e9e5:after{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_2bb2e9e5:after{background-color:var(--mantine-color-dark-4)}.m_2bb2e9e5:only-child{display:none}.m_2943220b{--combobox-chevron-size-xs: calc(.875rem * var(--mantine-scale));--combobox-chevron-size-sm: calc(1.125rem * var(--mantine-scale));--combobox-chevron-size-md: calc(1.25rem * var(--mantine-scale));--combobox-chevron-size-lg: calc(1.5rem * var(--mantine-scale));--combobox-chevron-size-xl: calc(1.75rem * var(--mantine-scale));--combobox-chevron-size: var(--combobox-chevron-size-sm)}:where([data-mantine-color-scheme=light]) .m_2943220b{--_combobox-chevron-color: var(--combobox-chevron-color, var(--mantine-color-gray-6))}:where([data-mantine-color-scheme=dark]) .m_2943220b{--_combobox-chevron-color: var(--combobox-chevron-color, var(--mantine-color-dark-3))}.m_2943220b{width:var(--combobox-chevron-size);height:var(--combobox-chevron-size);color:var(--_combobox-chevron-color)}.m_2943220b:where([data-error]){color:var(--combobox-chevron-color, var(--mantine-color-error))}.m_390b5f4{display:flex;align-items:center;gap:calc(.5rem * var(--mantine-scale))}.m_390b5f4:where([data-reverse]){justify-content:space-between}.m_8ee53fc2{opacity:.4;width:.8em;min-width:.8em;height:.8em}:where([data-combobox-selected]) .m_8ee53fc2{opacity:1}.m_a530ee0a{width:.8em;min-width:.8em;height:.8em}.m_5f75b09e{--label-lh-xs: calc(1rem * var(--mantine-scale));--label-lh-sm: calc(1.25rem * var(--mantine-scale));--label-lh-md: calc(1.5rem * var(--mantine-scale));--label-lh-lg: calc(1.875rem * var(--mantine-scale));--label-lh-xl: calc(2.25rem * var(--mantine-scale));--label-lh: var(--label-lh-sm)}.m_5f75b09e[data-label-position=left]{--label-order: 1;--label-offset-end: var(--mantine-spacing-sm);--label-offset-start: 0}.m_5f75b09e[data-label-position=right]{--label-order: 2;--label-offset-end: 0;--label-offset-start: var(--mantine-spacing-sm)}.m_5f6e695e{-webkit-tap-highlight-color:transparent;display:flex}.m_d3ea56bb{--label-cursor: var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent;display:inline-flex;flex-direction:column;font-size:var(--label-fz, var(--mantine-font-size-sm));line-height:var(--label-lh);cursor:var(--label-cursor);order:var(--label-order)}fieldset:disabled .m_d3ea56bb,.m_d3ea56bb[data-disabled]{--label-cursor: not-allowed}.m_8ee546b8{cursor:var(--label-cursor);color:inherit;padding-inline-start:var(--label-offset-start);padding-inline-end:var(--label-offset-end)}fieldset:disabled .m_8ee546b8,.m_8ee546b8:where([data-disabled]){color:var(--mantine-color-disabled-color)}.m_328f68c0{margin-top:calc(var(--mantine-spacing-xs) / 2);padding-inline-start:var(--label-offset-start);padding-inline-end:var(--label-offset-end);cursor:default}.m_8e8a99cc{margin-top:calc(var(--mantine-spacing-xs) / 2);padding-inline-start:var(--label-offset-start);padding-inline-end:var(--label-offset-end)}.m_26775b0a{--card-radius: var(--mantine-radius-default);display:block;width:100%;border-radius:var(--card-radius);cursor:pointer}.m_26775b0a :where(*){cursor:inherit}.m_26775b0a:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid transparent}:where([data-mantine-color-scheme=light]) .m_26775b0a:where([data-with-border]){border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_26775b0a:where([data-with-border]){border-color:var(--mantine-color-dark-4)}.m_5e5256ee{--checkbox-size-xs: calc(1rem * var(--mantine-scale));--checkbox-size-sm: calc(1.25rem * var(--mantine-scale));--checkbox-size-md: calc(1.5rem * var(--mantine-scale));--checkbox-size-lg: calc(1.875rem * var(--mantine-scale));--checkbox-size-xl: calc(2.25rem * var(--mantine-scale));--checkbox-size: var(--checkbox-size-sm);--checkbox-color: var(--mantine-primary-color-filled)}.m_5e5256ee:where([data-variant=filled]){--checkbox-icon-color: var(--mantine-color-white)}.m_5e5256ee:where([data-variant=outline]){--checkbox-icon-color: var(--checkbox-color)}.m_5e5256ee{position:relative;border:calc(.0625rem * var(--mantine-scale)) solid transparent;width:var(--checkbox-size);min-width:var(--checkbox-size);height:var(--checkbox-size);min-height:var(--checkbox-size);border-radius:var(--checkbox-radius, var(--mantine-radius-default));transition:border-color .1s ease,background-color .1s ease;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent;display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_5e5256ee{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_5e5256ee{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_5e5256ee[data-indeterminate],.m_5e5256ee[data-checked]{background-color:var(--checkbox-color);border-color:var(--checkbox-color)}.m_5e5256ee[data-indeterminate]>.m_1b1c543a,.m_5e5256ee[data-checked]>.m_1b1c543a{opacity:1;transform:none;color:var(--checkbox-icon-color)}.m_5e5256ee[data-disabled]{cursor:not-allowed;border-color:var(--mantine-color-disabled-border);background-color:var(--mantine-color-disabled)}[data-mantine-color-scheme=light] .m_5e5256ee[data-disabled][data-checked]>.m_1b1c543a{color:var(--mantine-color-gray-5)}[data-mantine-color-scheme=dark] .m_5e5256ee[data-disabled][data-checked]>.m_1b1c543a{color:var(--mantine-color-dark-3)}.m_76e20374[data-indeterminate]:not([data-disabled]),.m_76e20374[data-checked]:not([data-disabled]){background-color:transparent;border-color:var(--checkbox-color)}.m_76e20374[data-indeterminate]:not([data-disabled])>.m_1b1c543a,.m_76e20374[data-checked]:not([data-disabled])>.m_1b1c543a{color:var(--checkbox-icon-color);opacity:1;transform:none}.m_1b1c543a{display:block;width:60%;color:transparent;pointer-events:none;transform:translateY(calc(.3125rem * var(--mantine-scale))) scale(.5);opacity:1;transition:transform .1s ease,opacity .1s ease}.m_bf2d988c{--checkbox-size-xs: calc(1rem * var(--mantine-scale));--checkbox-size-sm: calc(1.25rem * var(--mantine-scale));--checkbox-size-md: calc(1.5rem * var(--mantine-scale));--checkbox-size-lg: calc(1.875rem * var(--mantine-scale));--checkbox-size-xl: calc(2.25rem * var(--mantine-scale));--checkbox-size: var(--checkbox-size-sm);--checkbox-color: var(--mantine-primary-color-filled)}.m_bf2d988c:where([data-variant=filled]){--checkbox-icon-color: var(--mantine-color-white)}.m_bf2d988c:where([data-variant=outline]){--checkbox-icon-color: var(--checkbox-color)}.m_26062bec{position:relative;width:var(--checkbox-size);height:var(--checkbox-size);order:1}.m_26062bec:where([data-label-position=left]){order:2}.m_26063560{appearance:none;border:calc(.0625rem * var(--mantine-scale)) solid transparent;width:var(--checkbox-size);height:var(--checkbox-size);border-radius:var(--checkbox-radius, var(--mantine-radius-default));padding:0;display:block;margin:0;transition:border-color .1s ease,background-color .1s ease;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent}:where([data-mantine-color-scheme=light]) .m_26063560{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_26063560{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_26063560:where([data-error]){border-color:var(--mantine-color-error)}.m_26063560[data-indeterminate],.m_26063560:checked{background-color:var(--checkbox-color);border-color:var(--checkbox-color)}.m_26063560[data-indeterminate]+.m_bf295423,.m_26063560:checked+.m_bf295423{opacity:1;transform:none}.m_26063560:disabled{cursor:not-allowed;border-color:var(--mantine-color-disabled-border);background-color:var(--mantine-color-disabled)}.m_26063560:disabled+.m_bf295423{color:var(--mantine-color-disabled-color)}.m_215c4542+.m_bf295423{color:var(--checkbox-color)}.m_215c4542[data-indeterminate]:not(:disabled),.m_215c4542:checked:not(:disabled){background-color:transparent;border-color:var(--checkbox-color)}.m_215c4542[data-indeterminate]:not(:disabled)+.m_bf295423,.m_215c4542:checked:not(:disabled)+.m_bf295423{color:var(--checkbox-icon-color);opacity:1;transform:none}.m_bf295423{position:absolute;inset:0;width:60%;margin:auto;color:var(--checkbox-icon-color);pointer-events:none;transform:translateY(calc(.3125rem * var(--mantine-scale))) scale(.5);opacity:0;transition:transform .1s ease,opacity .1s ease}.m_11def92b{--ag-spacing: var(--mantine-spacing-sm);--ag-offset: calc(var(--ag-spacing) * -1);display:flex;padding-inline-start:var(--ag-spacing)}.m_f85678b6{--avatar-size-xs: calc(1rem * var(--mantine-scale));--avatar-size-sm: calc(1.625rem * var(--mantine-scale));--avatar-size-md: calc(2.375rem * var(--mantine-scale));--avatar-size-lg: calc(3.5rem * var(--mantine-scale));--avatar-size-xl: calc(5.25rem * var(--mantine-scale));--avatar-size: var(--avatar-size-md);--avatar-radius: calc(62.5rem * var(--mantine-scale));--avatar-bg: var(--mantine-color-gray-light);--avatar-bd: calc(.0625rem * var(--mantine-scale)) solid transparent;--avatar-color: var(--mantine-color-gray-light-color);--avatar-placeholder-fz: calc(var(--avatar-size) / 2.5);-webkit-tap-highlight-color:transparent;position:relative;display:block;user-select:none;overflow:hidden;border-radius:var(--avatar-radius);text-decoration:none;padding:0;width:var(--avatar-size);height:var(--avatar-size);min-width:var(--avatar-size)}.m_f85678b6:where([data-within-group]){margin-inline-start:var(--ag-offset);border:2px solid var(--mantine-color-body);background:var(--mantine-color-body)}.m_11f8ac07{object-fit:cover;width:100%;height:100%;display:block}.m_104cd71f{font-weight:700;display:flex;align-items:center;justify-content:center;width:100%;height:100%;user-select:none;border-radius:var(--avatar-radius);font-size:var(--avatar-placeholder-fz);background:var(--avatar-bg);border:var(--avatar-bd);color:var(--avatar-color)}.m_104cd71f>[data-avatar-placeholder-icon]{width:70%;height:70%}.m_2ce0de02{background-size:cover;background-position:center;display:block;width:100%;border:0;text-decoration:none;border-radius:var(--bi-radius, 0)}.m_347db0ec{--badge-height-xs: calc(1rem * var(--mantine-scale));--badge-height-sm: calc(1.125rem * var(--mantine-scale));--badge-height-md: calc(1.25rem * var(--mantine-scale));--badge-height-lg: calc(1.625rem * var(--mantine-scale));--badge-height-xl: calc(2rem * var(--mantine-scale));--badge-fz-xs: calc(.5625rem * var(--mantine-scale));--badge-fz-sm: calc(.625rem * var(--mantine-scale));--badge-fz-md: calc(.6875rem * var(--mantine-scale));--badge-fz-lg: calc(.8125rem * var(--mantine-scale));--badge-fz-xl: calc(1rem * var(--mantine-scale));--badge-padding-x-xs: calc(.375rem * var(--mantine-scale));--badge-padding-x-sm: calc(.5rem * var(--mantine-scale));--badge-padding-x-md: calc(.625rem * var(--mantine-scale));--badge-padding-x-lg: calc(.75rem * var(--mantine-scale));--badge-padding-x-xl: calc(1rem * var(--mantine-scale));--badge-height: var(--badge-height-md);--badge-fz: var(--badge-fz-md);--badge-padding-x: var(--badge-padding-x-md);--badge-radius: calc(62.5rem * var(--mantine-scale));--badge-lh: calc(var(--badge-height) - calc(.125rem * var(--mantine-scale)));--badge-color: var(--mantine-color-white);--badge-bg: var(--mantine-primary-color-filled);--badge-border-width: calc(.0625rem * var(--mantine-scale));--badge-bd: var(--badge-border-width) solid transparent;-webkit-tap-highlight-color:transparent;font-size:var(--badge-fz);border-radius:var(--badge-radius);height:var(--badge-height);line-height:var(--badge-lh);text-decoration:none;padding:0 var(--badge-padding-x);display:inline-grid;align-items:center;justify-content:center;width:fit-content;text-transform:uppercase;font-weight:700;letter-spacing:calc(.015625rem * var(--mantine-scale));cursor:default;text-overflow:ellipsis;overflow:hidden;color:var(--badge-color);background:var(--badge-bg);border:var(--badge-bd)}.m_347db0ec:where([data-with-left-section],[data-variant=dot]){grid-template-columns:auto 1fr}.m_347db0ec:where([data-with-right-section]){grid-template-columns:1fr auto}.m_347db0ec:where([data-with-left-section][data-with-right-section],[data-variant=dot][data-with-right-section]){grid-template-columns:auto 1fr auto}.m_347db0ec:where([data-block]){display:flex;width:100%}.m_347db0ec:where([data-circle]){padding-inline:calc(.125rem * var(--mantine-scale));display:flex;width:var(--badge-height)}.m_fbd81e3d{--badge-dot-size: calc(var(--badge-height) / 3.4)}:where([data-mantine-color-scheme=light]) .m_fbd81e3d{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4);color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_fbd81e3d{background-color:var(--mantine-color-dark-5);border-color:var(--mantine-color-dark-5);color:var(--mantine-color-white)}.m_fbd81e3d:before{content:"";display:block;width:var(--badge-dot-size);height:var(--badge-dot-size);border-radius:var(--badge-dot-size);background-color:var(--badge-dot-color);margin-inline-end:var(--badge-dot-size)}.m_5add502a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center;cursor:inherit}.m_91fdda9b{--badge-section-margin: calc(var(--mantine-spacing-xs) / 2);display:inline-flex;justify-content:center;align-items:center;max-height:calc(var(--badge-height) - var(--badge-border-width) * 2)}.m_91fdda9b:where([data-position=left]){margin-inline-end:var(--badge-section-margin)}.m_91fdda9b:where([data-position=right]){margin-inline-start:var(--badge-section-margin)}.m_ddec01c0{--blockquote-border: 3px solid var(--bq-bd);position:relative;margin:0;border-inline-start:var(--blockquote-border);border-start-end-radius:var(--bq-radius);border-end-end-radius:var(--bq-radius);padding:var(--mantine-spacing-xl) calc(2.375rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_ddec01c0{background-color:var(--bq-bg-light)}:where([data-mantine-color-scheme=dark]) .m_ddec01c0{background-color:var(--bq-bg-dark)}.m_dde7bd57{--blockquote-icon-offset: calc(var(--bq-icon-size) / -2);position:absolute;color:var(--bq-bd);background-color:var(--mantine-color-body);display:flex;align-items:center;justify-content:center;top:var(--blockquote-icon-offset);inset-inline-start:var(--blockquote-icon-offset);width:var(--bq-icon-size);height:var(--bq-icon-size);border-radius:var(--bq-icon-size)}.m_dde51a35{display:block;margin-top:var(--mantine-spacing-md);opacity:.6;font-size:85%}.m_8b3717df{display:flex;align-items:center;flex-wrap:wrap}.m_f678d540{line-height:1;white-space:nowrap;-webkit-tap-highlight-color:transparent}.m_3b8f2208{margin-inline:var(--bc-separator-margin, var(--mantine-spacing-xs));line-height:1;display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_3b8f2208{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_3b8f2208{color:var(--mantine-color-dark-2)}.m_fea6bf1a{--burger-size-xs: calc(.75rem * var(--mantine-scale));--burger-size-sm: calc(1.125rem * var(--mantine-scale));--burger-size-md: calc(1.5rem * var(--mantine-scale));--burger-size-lg: calc(2.125rem * var(--mantine-scale));--burger-size-xl: calc(2.625rem * var(--mantine-scale));--burger-size: var(--burger-size-md);--burger-line-size: calc(var(--burger-size) / 12);width:calc(var(--burger-size) + var(--mantine-spacing-xs));height:calc(var(--burger-size) + var(--mantine-spacing-xs));padding:calc(var(--mantine-spacing-xs) / 2);cursor:pointer}:where([data-mantine-color-scheme=light]) .m_fea6bf1a{--burger-color: var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_fea6bf1a{--burger-color: var(--mantine-color-white)}.m_d4fb9cad{position:relative;user-select:none}.m_d4fb9cad,.m_d4fb9cad:before,.m_d4fb9cad:after{display:block;width:var(--burger-size);height:var(--burger-line-size);background-color:var(--burger-color);outline:calc(.0625rem * var(--mantine-scale)) solid transparent;transition-property:background-color,transform;transition-duration:var(--burger-transition-duration, .3s);transition-timing-function:var(--burger-transition-timing-function, ease)}.m_d4fb9cad:before,.m_d4fb9cad:after{position:absolute;content:"";inset-inline-start:0}.m_d4fb9cad:before{top:calc(var(--burger-size) / -3)}.m_d4fb9cad:after{top:calc(var(--burger-size) / 3)}.m_d4fb9cad[data-opened]{background-color:transparent}.m_d4fb9cad[data-opened]:before{transform:translateY(calc(var(--burger-size) / 3)) rotate(45deg)}.m_d4fb9cad[data-opened]:after{transform:translateY(calc(var(--burger-size) / -3)) rotate(-45deg)}.m_77c9d27d{--button-height-xs: calc(1.875rem * var(--mantine-scale));--button-height-sm: calc(2.25rem * var(--mantine-scale));--button-height-md: calc(2.625rem * var(--mantine-scale));--button-height-lg: calc(3.125rem * var(--mantine-scale));--button-height-xl: calc(3.75rem * var(--mantine-scale));--button-height-compact-xs: calc(1.375rem * var(--mantine-scale));--button-height-compact-sm: calc(1.625rem * var(--mantine-scale));--button-height-compact-md: calc(1.875rem * var(--mantine-scale));--button-height-compact-lg: calc(2.125rem * var(--mantine-scale));--button-height-compact-xl: calc(2.5rem * var(--mantine-scale));--button-padding-x-xs: calc(.875rem * var(--mantine-scale));--button-padding-x-sm: calc(1.125rem * var(--mantine-scale));--button-padding-x-md: calc(1.375rem * var(--mantine-scale));--button-padding-x-lg: calc(1.625rem * var(--mantine-scale));--button-padding-x-xl: calc(2rem * var(--mantine-scale));--button-padding-x-compact-xs: calc(.4375rem * var(--mantine-scale));--button-padding-x-compact-sm: calc(.5rem * var(--mantine-scale));--button-padding-x-compact-md: calc(.625rem * var(--mantine-scale));--button-padding-x-compact-lg: calc(.75rem * var(--mantine-scale));--button-padding-x-compact-xl: calc(.875rem * var(--mantine-scale));--button-height: var(--button-height-sm);--button-padding-x: var(--button-padding-x-sm);--button-color: var(--mantine-color-white);user-select:none;font-weight:600;position:relative;line-height:1;text-align:center;overflow:hidden;width:auto;cursor:pointer;display:inline-block;border-radius:var(--button-radius, var(--mantine-radius-default));font-size:var(--button-fz, var(--mantine-font-size-sm));background:var(--button-bg, var(--mantine-primary-color-filled));border:var(--button-bd, calc(.0625rem * var(--mantine-scale)) solid transparent);color:var(--button-color, var(--mantine-color-white));height:var(--button-height, var(--button-height-sm));padding-inline:var(--button-padding-x, var(--button-padding-x-sm));vertical-align:middle}.m_77c9d27d:where([data-block]){display:block;width:100%}.m_77c9d27d:where([data-with-left-section]){padding-inline-start:calc(var(--button-padding-x) / 1.5)}.m_77c9d27d:where([data-with-right-section]){padding-inline-end:calc(var(--button-padding-x) / 1.5)}.m_77c9d27d:where(:disabled:not([data-loading]),[data-disabled]:not([data-loading])){cursor:not-allowed;border:calc(.0625rem * var(--mantine-scale)) solid transparent;transform:none;color:var(--mantine-color-disabled-color);background:var(--mantine-color-disabled)}.m_77c9d27d:before{content:"";pointer-events:none;position:absolute;inset:calc(-.0625rem * var(--mantine-scale));border-radius:var(--button-radius, var(--mantine-radius-default));transform:translateY(-100%);opacity:0;filter:blur(12px);transition:transform .15s ease,opacity .1s ease}:where([data-mantine-color-scheme=light]) .m_77c9d27d:before{background-color:#ffffff26}:where([data-mantine-color-scheme=dark]) .m_77c9d27d:before{background-color:#00000026}.m_77c9d27d:where([data-loading]){cursor:not-allowed;transform:none}.m_77c9d27d:where([data-loading]):before{transform:translateY(0);opacity:1}.m_77c9d27d:where([data-loading]) .m_80f1301b{opacity:0;transform:translateY(100%)}@media(hover:hover){.m_77c9d27d:hover:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--button-hover, var(--mantine-primary-color-filled-hover));color:var(--button-hover-color, var(--button-color))}}@media(hover:none){.m_77c9d27d:active:where(:not([data-loading],:disabled,[data-disabled])){background-color:var(--button-hover, var(--mantine-primary-color-filled-hover));color:var(--button-hover-color, var(--button-color))}}.m_80f1301b{display:flex;align-items:center;justify-content:var(--button-justify, center);height:100%;overflow:visible;transition:transform .15s ease,opacity .1s ease}.m_811560b9{white-space:nowrap;height:100%;overflow:hidden;display:flex;align-items:center;opacity:1}.m_811560b9:where([data-loading]){opacity:.2}.m_a74036a{display:flex;align-items:center}.m_a74036a:where([data-position=left]){margin-inline-end:var(--mantine-spacing-xs)}.m_a74036a:where([data-position=right]){margin-inline-start:var(--mantine-spacing-xs)}.m_a25b86ee{position:absolute;left:50%;top:50%}.m_80d6d844{--button-border-width: calc(.0625rem * var(--mantine-scale));display:flex}.m_80d6d844 :where(.m_77c9d27d):focus{position:relative;z-index:1}.m_80d6d844[data-orientation=horizontal]{flex-direction:row}.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):first-child,.m_80d6d844[data-orientation=horizontal] .m_70be2a01:not(:only-child):first-child{border-end-end-radius:0;border-start-end-radius:0;border-inline-end-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):last-child,.m_80d6d844[data-orientation=horizontal] .m_70be2a01:not(:only-child):last-child{border-end-start-radius:0;border-start-start-radius:0;border-inline-start-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=horizontal] .m_77c9d27d:not(:only-child):not(:first-child):not(:last-child),.m_80d6d844[data-orientation=horizontal] .m_70be2a01:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-inline-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=vertical]{flex-direction:column}.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):first-child,.m_80d6d844[data-orientation=vertical] .m_70be2a01:not(:only-child):first-child{border-end-start-radius:0;border-end-end-radius:0;border-bottom-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):last-child,.m_80d6d844[data-orientation=vertical] .m_70be2a01:not(:only-child):last-child{border-start-start-radius:0;border-start-end-radius:0;border-top-width:calc(var(--button-border-width) / 2)}.m_80d6d844[data-orientation=vertical] .m_77c9d27d:not(:only-child):not(:first-child):not(:last-child),.m_80d6d844[data-orientation=vertical] .m_70be2a01:not(:only-child):not(:first-child):not(:last-child){border-radius:0;border-bottom-width:calc(var(--button-border-width) / 2);border-top-width:calc(var(--button-border-width) / 2)}.m_70be2a01{--section-height-xs: calc(1.875rem * var(--mantine-scale));--section-height-sm: calc(2.25rem * var(--mantine-scale));--section-height-md: calc(2.625rem * var(--mantine-scale));--section-height-lg: calc(3.125rem * var(--mantine-scale));--section-height-xl: calc(3.75rem * var(--mantine-scale));--section-height-compact-xs: calc(1.375rem * var(--mantine-scale));--section-height-compact-sm: calc(1.625rem * var(--mantine-scale));--section-height-compact-md: calc(1.875rem * var(--mantine-scale));--section-height-compact-lg: calc(2.125rem * var(--mantine-scale));--section-height-compact-xl: calc(2.5rem * var(--mantine-scale));--section-padding-x-xs: calc(.875rem * var(--mantine-scale));--section-padding-x-sm: calc(1.125rem * var(--mantine-scale));--section-padding-x-md: calc(1.375rem * var(--mantine-scale));--section-padding-x-lg: calc(1.625rem * var(--mantine-scale));--section-padding-x-xl: calc(2rem * var(--mantine-scale));--section-padding-x-compact-xs: calc(.4375rem * var(--mantine-scale));--section-padding-x-compact-sm: calc(.5rem * var(--mantine-scale));--section-padding-x-compact-md: calc(.625rem * var(--mantine-scale));--section-padding-x-compact-lg: calc(.75rem * var(--mantine-scale));--section-padding-x-compact-xl: calc(.875rem * var(--mantine-scale));--section-height: var(--section-height-sm);--section-padding-x: var(--section-padding-x-sm);--section-color: var(--mantine-color-white);font-weight:600;width:auto;border-radius:var(--section-radius, var(--mantine-radius-default));font-size:var(--section-fz, var(--mantine-font-size-sm));background:var(--section-bg, var(--mantine-primary-color-filled));border:var(--section-bd, calc(.0625rem * var(--mantine-scale)) solid transparent);color:var(--section-color, var(--mantine-color-white));height:var(--section-height, var(--section-height-sm));padding-inline:var(--section-padding-x, var(--section-padding-x-sm));vertical-align:middle;line-height:1;display:inline-flex;align-items:center;justify-content:center}.m_e615b15f{--card-padding: var(--mantine-spacing-md);position:relative;overflow:hidden;display:flex;flex-direction:column;padding:var(--card-padding);color:var(--mantine-color-text)}:where([data-mantine-color-scheme=light]) .m_e615b15f{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_e615b15f{background-color:var(--mantine-color-dark-6)}.m_599a2148{display:block;margin-inline:calc(var(--card-padding) * -1)}.m_599a2148:where(:first-child){margin-top:calc(var(--card-padding) * -1);border-top:none!important}.m_599a2148:where(:last-child){margin-bottom:calc(var(--card-padding) * -1);border-bottom:none!important}.m_599a2148:where([data-inherit-padding]){padding-inline:var(--card-padding)}.m_599a2148:where([data-with-border]){border-top:calc(.0625rem * var(--mantine-scale)) solid;border-bottom:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_599a2148{border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_599a2148{border-color:var(--mantine-color-dark-4)}.m_599a2148+.m_599a2148{border-top:none!important}.m_4451eb3a{display:flex;align-items:center;justify-content:center}.m_4451eb3a:where([data-inline]){display:inline-flex}.m_f59ffda3{--chip-size-xs: calc(1.4375rem * var(--mantine-scale));--chip-size-sm: calc(1.75rem * var(--mantine-scale));--chip-size-md: calc(2rem * var(--mantine-scale));--chip-size-lg: calc(2.25rem * var(--mantine-scale));--chip-size-xl: calc(2.5rem * var(--mantine-scale));--chip-icon-size-xs: calc(.5625rem * var(--mantine-scale));--chip-icon-size-sm: calc(.75rem * var(--mantine-scale));--chip-icon-size-md: calc(.875rem * var(--mantine-scale));--chip-icon-size-lg: calc(1rem * var(--mantine-scale));--chip-icon-size-xl: calc(1.125rem * var(--mantine-scale));--chip-padding-xs: calc(1rem * var(--mantine-scale));--chip-padding-sm: calc(1.25rem * var(--mantine-scale));--chip-padding-md: calc(1.5rem * var(--mantine-scale));--chip-padding-lg: calc(1.75rem * var(--mantine-scale));--chip-padding-xl: calc(2rem * var(--mantine-scale));--chip-checked-padding-xs: calc(.5125rem * var(--mantine-scale));--chip-checked-padding-sm: calc(.625rem * var(--mantine-scale));--chip-checked-padding-md: calc(.73125rem * var(--mantine-scale));--chip-checked-padding-lg: calc(.84375rem * var(--mantine-scale));--chip-checked-padding-xl: calc(.98125rem * var(--mantine-scale));--chip-spacing-xs: calc(.625rem * var(--mantine-scale));--chip-spacing-sm: calc(.75rem * var(--mantine-scale));--chip-spacing-md: calc(1rem * var(--mantine-scale));--chip-spacing-lg: calc(1.25rem * var(--mantine-scale));--chip-spacing-xl: calc(1.375rem * var(--mantine-scale));--chip-size: var(--chip-size-sm);--chip-icon-size: var(--chip-icon-size-sm);--chip-padding: var(--chip-padding-sm);--chip-spacing: var(--chip-spacing-sm);--chip-checked-padding: var(--chip-checked-padding-sm);--chip-bg: var(--mantine-primary-color-filled);--chip-hover: var(--mantine-primary-color-filled-hover);--chip-color: var(--mantine-color-white);--chip-bd: calc(.0625rem * var(--mantine-scale)) solid transparent}.m_be049a53{display:inline-flex;align-items:center;user-select:none;border-radius:var(--chip-radius, 1000rem);height:var(--chip-size);font-size:var(--chip-fz, var(--mantine-font-size-sm));line-height:calc(var(--chip-size) - calc(.125rem * var(--mantine-scale)));padding-inline:var(--chip-padding);cursor:pointer;white-space:nowrap;-webkit-tap-highlight-color:transparent;border:calc(.0625rem * var(--mantine-scale)) solid transparent;color:var(--mantine-color-text)}.m_be049a53:where([data-checked]){padding:var(--chip-checked-padding)}.m_be049a53:where([data-disabled]){cursor:not-allowed;background-color:var(--mantine-color-disabled);color:var(--mantine-color-disabled-color)}:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]){background-color:var(--mantine-color-white);border:1px solid var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]){background-color:var(--mantine-color-dark-6);border:1px solid var(--mantine-color-dark-4)}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]):hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]):hover{background-color:var(--mantine-color-dark-5)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_3904c1af:not([data-disabled]):active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_3904c1af:not([data-disabled]):active{background-color:var(--mantine-color-dark-5)}}.m_3904c1af:not([data-disabled]):where([data-checked]){--chip-icon-color: var(--chip-color);border:var(--chip-bd)}@media(hover:hover){.m_3904c1af:not([data-disabled]):where([data-checked]):hover{background-color:var(--chip-hover)}}@media(hover:none){.m_3904c1af:not([data-disabled]):where([data-checked]):active{background-color:var(--chip-hover)}}.m_fa109255:not([data-disabled]),.m_f7e165c3:not([data-disabled]){border:calc(.0625rem * var(--mantine-scale)) solid transparent;color:var(--mantine-color-text)}:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]),:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]){background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]),:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]){background-color:var(--mantine-color-dark-5)}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]):hover,:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]):hover{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]):hover,:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]):hover{background-color:var(--mantine-color-dark-4)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_fa109255:not([data-disabled]):active,:where([data-mantine-color-scheme=light]) .m_f7e165c3:not([data-disabled]):active{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_fa109255:not([data-disabled]):active,:where([data-mantine-color-scheme=dark]) .m_f7e165c3:not([data-disabled]):active{background-color:var(--mantine-color-dark-4)}}.m_fa109255:not([data-disabled]):where([data-checked]),.m_f7e165c3:not([data-disabled]):where([data-checked]){--chip-icon-color: var(--chip-color);color:var(--chip-color);background-color:var(--chip-bg)}@media(hover:hover){.m_fa109255:not([data-disabled]):where([data-checked]):hover,.m_f7e165c3:not([data-disabled]):where([data-checked]):hover{background-color:var(--chip-hover)}}@media(hover:none){.m_fa109255:not([data-disabled]):where([data-checked]):active,.m_f7e165c3:not([data-disabled]):where([data-checked]):active{background-color:var(--chip-hover)}}.m_9ac86df9{width:calc(var(--chip-icon-size) + (var(--chip-spacing) / 1.5));max-width:calc(var(--chip-icon-size) + (var(--chip-spacing) / 1.5));height:var(--chip-icon-size);display:flex;align-items:center;overflow:hidden}.m_d6d72580{width:var(--chip-icon-size);height:var(--chip-icon-size);display:block;color:var(--chip-icon-color, inherit)}.m_bde07329{width:0;height:0;padding:0;opacity:0;margin:0}.m_bde07329:focus-visible+.m_be049a53{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_b183c0a2{font-family:var(--mantine-font-family-monospace);line-height:var(--mantine-line-height);padding:2px calc(var(--mantine-spacing-xs) / 2);border-radius:var(--mantine-radius-sm);font-size:var(--mantine-font-size-xs);margin:0;overflow:auto}:where([data-mantine-color-scheme=light]) .m_b183c0a2{background-color:var(--code-bg, var(--mantine-color-gray-0))}:where([data-mantine-color-scheme=dark]) .m_b183c0a2{background-color:var(--code-bg, var(--mantine-color-dark-6))}.m_b183c0a2[data-block]{padding:var(--mantine-spacing-xs)}.m_de3d2490{--cs-size: calc(1.75rem * var(--mantine-scale));--cs-radius: calc(62.5rem * var(--mantine-scale));-webkit-tap-highlight-color:transparent;border:none;appearance:none;display:block;line-height:1;position:relative;width:var(--cs-size);height:var(--cs-size);min-width:var(--cs-size);min-height:var(--cs-size);border-radius:var(--cs-radius);color:inherit;text-decoration:none}[data-mantine-color-scheme=light] .m_de3d2490{--alpha-overlay-color: var(--mantine-color-gray-3);--alpha-overlay-bg: var(--mantine-color-white)}[data-mantine-color-scheme=dark] .m_de3d2490{--alpha-overlay-color: var(--mantine-color-dark-4);--alpha-overlay-bg: var(--mantine-color-dark-7)}.m_862f3d1b{position:absolute;inset:0;border-radius:var(--cs-radius)}.m_98ae7f22{position:absolute;inset:0;border-radius:var(--cs-radius);z-index:1;box-shadow:#0000001a 0 0 0 calc(.0625rem * var(--mantine-scale)) inset,#00000026 0 0 calc(.25rem * var(--mantine-scale)) inset}.m_95709ac0{position:absolute;inset:0;border-radius:var(--cs-radius);background-size:calc(.5rem * var(--mantine-scale)) calc(.5rem * var(--mantine-scale));background-position:0 0,0 calc(.25rem * var(--mantine-scale)),calc(.25rem * var(--mantine-scale)) calc(-.25rem * var(--mantine-scale)),calc(-.25rem * var(--mantine-scale)) 0;background-image:linear-gradient(45deg,var(--alpha-overlay-color) 25%,transparent 25%),linear-gradient(-45deg,var(--alpha-overlay-color) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,var(--alpha-overlay-color) 75%),linear-gradient(-45deg,var(--alpha-overlay-bg) 75%,var(--alpha-overlay-color) 75%)}.m_93e74e3{position:absolute;inset:0;border-radius:var(--cs-radius);z-index:2;display:flex;align-items:center;justify-content:center}.m_fee9c77{--cp-width-xs: calc(11.25rem * var(--mantine-scale));--cp-width-sm: calc(12.5rem * var(--mantine-scale));--cp-width-md: calc(15rem * var(--mantine-scale));--cp-width-lg: calc(17.5rem * var(--mantine-scale));--cp-width-xl: calc(20rem * var(--mantine-scale));--cp-preview-size-xs: calc(1.625rem * var(--mantine-scale));--cp-preview-size-sm: calc(2.125rem * var(--mantine-scale));--cp-preview-size-md: calc(2.625rem * var(--mantine-scale));--cp-preview-size-lg: calc(3.125rem * var(--mantine-scale));--cp-preview-size-xl: calc(3.375rem * var(--mantine-scale));--cp-thumb-size-xs: calc(.5rem * var(--mantine-scale));--cp-thumb-size-sm: calc(.75rem * var(--mantine-scale));--cp-thumb-size-md: calc(1rem * var(--mantine-scale));--cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));--cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));--cp-saturation-height-xs: calc(6.25rem * var(--mantine-scale));--cp-saturation-height-sm: calc(6.875rem * var(--mantine-scale));--cp-saturation-height-md: calc(7.5rem * var(--mantine-scale));--cp-saturation-height-lg: calc(8.75rem * var(--mantine-scale));--cp-saturation-height-xl: calc(10rem * var(--mantine-scale));--cp-preview-size: var(--cp-preview-size-sm);--cp-thumb-size: var(--cp-thumb-size-sm);--cp-saturation-height: var(--cp-saturation-height-sm);--cp-width: var(--cp-width-sm);--cp-body-spacing: var(--mantine-spacing-sm);width:var(--cp-width);padding:calc(.0625rem * var(--mantine-scale))}.m_fee9c77:where([data-full-width]){width:100%}.m_9dddfbac{width:var(--cp-preview-size);height:var(--cp-preview-size)}.m_bffecc3e{display:flex;padding-top:calc(var(--cp-body-spacing) / 2)}.m_3283bb96{flex:1}.m_3283bb96:not(:only-child){margin-inline-end:var(--mantine-spacing-xs)}.m_40d572ba{overflow:hidden;position:absolute;box-shadow:0 0 1px #0009;border:2px solid var(--mantine-color-white);width:var(--cp-thumb-size);height:var(--cp-thumb-size);border-radius:var(--cp-thumb-size);left:calc(var(--thumb-x-offset) - var(--cp-thumb-size) / 2);top:calc(var(--thumb-y-offset) - var(--cp-thumb-size) / 2)}.m_d8ee6fd8{height:unset!important;width:unset!important;min-width:0!important;min-height:0!important;margin:calc(.125rem * var(--mantine-scale));cursor:pointer;padding-bottom:calc(var(--cp-swatch-size) - calc(.25rem * var(--mantine-scale)));flex:0 0 calc(var(--cp-swatch-size) - calc(.25rem * var(--mantine-scale)))}.m_5711e686{margin-top:calc(.3125rem * var(--mantine-scale));margin-inline:calc(-.125rem * var(--mantine-scale));display:flex;flex-wrap:wrap}.m_5711e686:only-child{margin-top:0}.m_202a296e{--cp-thumb-size-xs: calc(.5rem * var(--mantine-scale));--cp-thumb-size-sm: calc(.75rem * var(--mantine-scale));--cp-thumb-size-md: calc(1rem * var(--mantine-scale));--cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));--cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));-webkit-tap-highlight-color:transparent;position:relative;height:var(--cp-saturation-height);border-radius:var(--mantine-radius-sm);margin:calc(var(--cp-thumb-size) / 2)}.m_202a296e:where([data-focus-ring=auto]):focus:focus-visible .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}.m_202a296e:where([data-focus-ring=always]):focus .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}.m_11b3db02{position:absolute;border-radius:var(--mantine-radius-sm);inset:calc(var(--cp-thumb-size) * -1 / 2 - calc(.0625rem * var(--mantine-scale)))}.m_d856d47d{--cp-thumb-size-xs: calc(.5rem * var(--mantine-scale));--cp-thumb-size-sm: calc(.75rem * var(--mantine-scale));--cp-thumb-size-md: calc(1rem * var(--mantine-scale));--cp-thumb-size-lg: calc(1.25rem * var(--mantine-scale));--cp-thumb-size-xl: calc(1.375rem * var(--mantine-scale));--cp-thumb-size: var(--cp-thumb-size, calc(.75rem * var(--mantine-scale)));position:relative;height:calc(var(--cp-thumb-size) + calc(.125rem * var(--mantine-scale)));margin-inline:calc(var(--cp-thumb-size) / 2);outline:none}.m_d856d47d+.m_d856d47d{margin-top:calc(.375rem * var(--mantine-scale))}.m_d856d47d:where([data-focus-ring=auto]):focus:focus-visible .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}.m_d856d47d:where([data-focus-ring=always]):focus .m_40d572ba{outline:2px solid var(--mantine-color-blue-filled)}:where([data-mantine-color-scheme=light]) .m_d856d47d{--slider-checkers: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_d856d47d{--slider-checkers: var(--mantine-color-dark-4)}.m_8f327113{position:absolute;top:0;bottom:0;inset-inline:calc(var(--cp-thumb-size) * -1 / 2 - calc(.0625rem * var(--mantine-scale)));border-radius:10000rem}.m_b077c2bc{--ci-eye-dropper-icon-size-xs: calc(.875rem * var(--mantine-scale));--ci-eye-dropper-icon-size-sm: calc(1rem * var(--mantine-scale));--ci-eye-dropper-icon-size-md: calc(1.125rem * var(--mantine-scale));--ci-eye-dropper-icon-size-lg: calc(1.25rem * var(--mantine-scale));--ci-eye-dropper-icon-size-xl: calc(1.375rem * var(--mantine-scale));--ci-eye-dropper-icon-size: var(--ci-eye-dropper-icon-size-sm)}.m_66a028b5{--ci-button-size-xs: calc(1.375rem * var(--mantine-scale));--ci-button-size-sm: calc(1.625rem * var(--mantine-scale));--ci-button-size-md: calc(1.75rem * var(--mantine-scale));--ci-button-size-lg: calc(2rem * var(--mantine-scale));--ci-button-size-xl: calc(2.5rem * var(--mantine-scale));--ci-button-size: var(--ci-button-size-sm);width:var(--ci-button-size);height:var(--ci-button-size);min-width:var(--ci-button-size);min-height:var(--ci-button-size)}.m_c5ccdcab{--ci-preview-size-xs: calc(1rem * var(--mantine-scale));--ci-preview-size-sm: calc(1.125rem * var(--mantine-scale));--ci-preview-size-md: calc(1.375rem * var(--mantine-scale));--ci-preview-size-lg: calc(1.75rem * var(--mantine-scale));--ci-preview-size-xl: calc(2.25rem * var(--mantine-scale));--ci-preview-size: var(--ci-preview-size-sm)}.m_5ece2cd7{padding:calc(.5rem * var(--mantine-scale))}.m_7485cace{--container-size-xs: calc(33.75rem * var(--mantine-scale));--container-size-sm: calc(45rem * var(--mantine-scale));--container-size-md: calc(60rem * var(--mantine-scale));--container-size-lg: calc(71.25rem * var(--mantine-scale));--container-size-xl: calc(82.5rem * var(--mantine-scale));--container-size: var(--container-size-md)}.m_7485cace:where([data-strategy=block]){max-width:var(--container-size);padding-inline:var(--mantine-spacing-md);margin-inline:auto}.m_7485cace:where([data-strategy=block]):where([data-fluid]){max-width:100%}.m_7485cace:where([data-strategy=grid]){display:grid;grid-template-columns:1fr min(100%,var(--container-size)) 1fr;margin-inline:auto}.m_7485cace:where([data-strategy=grid])>*{grid-column:2}.m_7485cace:where([data-strategy=grid])>[data-breakout]{grid-column:1 / -1}.m_7485cace:where([data-strategy=grid])>[data-breakout]>[data-container]{max-width:var(--container-size);margin-inline:auto}.m_e2125a27{--dialog-size-xs: calc(10rem * var(--mantine-scale));--dialog-size-sm: calc(12.5rem * var(--mantine-scale));--dialog-size-md: calc(21.25rem * var(--mantine-scale));--dialog-size-lg: calc(25rem * var(--mantine-scale));--dialog-size-xl: calc(31.25rem * var(--mantine-scale));--dialog-size: var(--dialog-size-md);position:relative;width:var(--dialog-size);max-width:calc(100vw - var(--mantine-spacing-xl) * 2);min-height:calc(3.125rem * var(--mantine-scale))}.m_5abab665{position:absolute;top:calc(var(--mantine-spacing-md) / 2);inset-inline-end:calc(var(--mantine-spacing-md) / 2)}.m_3eebeb36{--divider-size-xs: calc(.0625rem * var(--mantine-scale));--divider-size-sm: calc(.125rem * var(--mantine-scale));--divider-size-md: calc(.1875rem * var(--mantine-scale));--divider-size-lg: calc(.25rem * var(--mantine-scale));--divider-size-xl: calc(.3125rem * var(--mantine-scale));--divider-size: var(--divider-size-xs)}:where([data-mantine-color-scheme=light]) .m_3eebeb36{--divider-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_3eebeb36{--divider-color: var(--mantine-color-dark-4)}.m_3eebeb36:where([data-orientation=horizontal]){border-top:var(--divider-size) var(--divider-border-style, solid) var(--divider-color)}.m_3eebeb36:where([data-orientation=vertical]){border-inline-start:var(--divider-size) var(--divider-border-style, solid) var(--divider-color);height:auto;align-self:stretch}.m_3eebeb36:where([data-with-label]){border:0}.m_9e365f20{display:flex;align-items:center;font-size:var(--mantine-font-size-xs);color:var(--mantine-color-dimmed);white-space:nowrap}.m_9e365f20:where([data-position=left]):before{display:none}.m_9e365f20:where([data-position=right]):after{display:none}.m_9e365f20:before{content:"";flex:1;height:calc(.0625rem * var(--mantine-scale));border-top:var(--divider-size) var(--divider-border-style, solid) var(--divider-color);margin-inline-end:var(--mantine-spacing-xs)}.m_9e365f20:after{content:"";flex:1;height:calc(.0625rem * var(--mantine-scale));border-top:var(--divider-size) var(--divider-border-style, solid) var(--divider-color);margin-inline-start:var(--mantine-spacing-xs)}.m_f11b401e{--drawer-size-xs: calc(20rem * var(--mantine-scale));--drawer-size-sm: calc(23.75rem * var(--mantine-scale));--drawer-size-md: calc(27.5rem * var(--mantine-scale));--drawer-size-lg: calc(38.75rem * var(--mantine-scale));--drawer-size-xl: calc(48.75rem * var(--mantine-scale));--drawer-size: var(--drawer-size-md);--drawer-offset: 0rem}.m_5a7c2c9{z-index:1000}.m_b8a05bbd{flex:var(--drawer-flex, 0 0 var(--drawer-size));height:var(--drawer-height, calc(100% - var(--drawer-offset) * 2));margin:var(--drawer-offset);max-width:calc(100% - var(--drawer-offset) * 2);max-height:calc(100% - var(--drawer-offset) * 2);overflow-y:auto}.m_b8a05bbd[data-hidden]{opacity:0!important;pointer-events:none}.m_31cd769a{display:flex;justify-content:var(--drawer-justify, flex-start);align-items:var(--drawer-align, flex-start)}.m_e9408a47{padding:var(--mantine-spacing-lg);padding-top:var(--mantine-spacing-xs);border-radius:var(--fieldset-radius, var(--mantine-radius-default));min-inline-size:auto}.m_84c9523a{border:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_84c9523a{border-color:var(--mantine-color-gray-3);background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_84c9523a{border-color:var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-7)}.m_ef274e49{border:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_ef274e49{border-color:var(--mantine-color-gray-3);background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_ef274e49{border-color:var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-6)}.m_eda993d3{padding:0;border:0;border-radius:0}.m_90794832{font-size:var(--mantine-font-size-sm)}.m_74ca27fe{padding:0;margin-bottom:var(--mantine-spacing-sm)}.m_8478a6da{container:mantine-grid / inline-size}.m_410352e9{--grid-overflow: visible;--grid-margin: calc(var(--grid-gutter) / -2);--grid-col-padding: calc(var(--grid-gutter) / 2);overflow:var(--grid-overflow)}.m_dee7bd2f{width:calc(100% + var(--grid-gutter));display:flex;flex-wrap:wrap;justify-content:var(--grid-justify);align-items:var(--grid-align);margin:var(--grid-margin)}.m_96bdd299{--col-flex-grow: 0;--col-offset: 0rem;flex-shrink:0;order:var(--col-order);flex-basis:var(--col-flex-basis);width:var(--col-width);max-width:var(--col-max-width);flex-grow:var(--col-flex-grow);margin-inline-start:var(--col-offset);padding:var(--grid-col-padding)}.m_bcb3f3c2{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=light]) .m_bcb3f3c2{background-color:var(--mark-bg-light)}:where([data-mantine-color-scheme=dark]) .m_bcb3f3c2{background-color:var(--mark-bg-dark)}.m_9e117634{display:block;object-fit:var(--image-object-fit, cover);width:100%;border-radius:var(--image-radius, 0)}@keyframes m_885901b1{0%{opacity:.6;transform:scale(0)}to{opacity:0;transform:scale(2.8)}}.m_e5262200{--indicator-size: calc(.625rem * var(--mantine-scale));--indicator-color: var(--mantine-primary-color-filled);position:relative;display:block}.m_e5262200:where([data-inline]){display:inline-block}.m_760d1fb1{position:absolute;top:var(--indicator-top);left:var(--indicator-left);right:var(--indicator-right);bottom:var(--indicator-bottom);transform:translate(var(--indicator-translate-x),var(--indicator-translate-y));min-width:var(--indicator-size);height:var(--indicator-size);border-radius:var(--indicator-radius, 1000rem);z-index:var(--indicator-z-index, 200);display:flex;align-items:center;justify-content:center;font-size:var(--mantine-font-size-xs);background-color:var(--indicator-color);color:var(--indicator-text-color, var(--mantine-color-white));white-space:nowrap}.m_760d1fb1:before{content:"";position:absolute;inset:0;background-color:var(--indicator-color);border-radius:var(--indicator-radius, 1000rem);z-index:-1}.m_760d1fb1:where([data-with-label]){padding-inline:calc(var(--mantine-spacing-xs) / 2)}.m_760d1fb1:where([data-with-border]){border:2px solid var(--mantine-color-body)}.m_760d1fb1[data-processing]:before{animation:m_885901b1 1s linear infinite}.m_dc6f14e2{--kbd-fz-xs: calc(.625rem * var(--mantine-scale));--kbd-fz-sm: calc(.75rem * var(--mantine-scale));--kbd-fz-md: calc(.875rem * var(--mantine-scale));--kbd-fz-lg: calc(1rem * var(--mantine-scale));--kbd-fz-xl: calc(1.25rem * var(--mantine-scale));--kbd-fz: var(--kbd-fz-sm);font-family:var(--mantine-font-family-monospace);line-height:var(--mantine-line-height);font-weight:700;font-size:var(--kbd-fz);border-radius:var(--mantine-radius-sm);border:calc(.0625rem * var(--mantine-scale)) solid;border-bottom-width:calc(.1875rem * var(--mantine-scale));unicode-bidi:embed;text-align:center;padding:.12em .45em}:where([data-mantine-color-scheme=light]) .m_dc6f14e2{border-color:var(--mantine-color-gray-3);color:var(--mantine-color-gray-7);background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_dc6f14e2{border-color:var(--mantine-color-dark-4);color:var(--mantine-color-dark-0);background-color:var(--mantine-color-dark-6)}.m_abbac491{--list-fz: var(--mantine-font-size-md);--list-lh: var(--mantine-line-height-md);--list-marker-gap: var(--mantine-spacing-lg);list-style-position:outside;font-size:var(--list-fz);line-height:var(--list-lh);margin:0;padding:0;padding-inline-start:var(--list-marker-gap)}.m_abbac491[data-type=none]{--list-marker-gap: 0}.m_abbac491:where([data-with-padding]){padding-inline-start:calc(var(--list-marker-gap) + var(--mantine-spacing-md))}.m_abb6bec2{white-space:normal;line-height:var(--list-lh)}.m_abb6bec2:where([data-with-icon]){list-style:none}.m_abb6bec2:where([data-with-icon]) .m_75cd9f71{--li-direction: row;--li-align: center}.m_abb6bec2:where(:not(:first-of-type)){margin-top:var(--list-spacing, 0)}.m_abb6bec2:where([data-centered]){line-height:1}.m_75cd9f71{display:inline-flex;flex-direction:var(--li-direction, column);align-items:var(--li-align, flex-start);white-space:normal}.m_60f83e5b{display:inline-block;vertical-align:middle;margin-inline-end:var(--mantine-spacing-sm)}.m_6e45937b{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden;z-index:var(--lo-z-index)}.m_e8eb006c{position:relative;z-index:calc(var(--lo-z-index) + 1)}.m_df587f17{z-index:var(--lo-z-index)}.m_dc9b7c9f{padding:calc(.25rem * var(--mantine-scale))}.m_9bfac126{color:var(--mantine-color-dimmed);font-weight:500;font-size:var(--mantine-font-size-xs);padding:calc(var(--mantine-spacing-xs) / 2) var(--mantine-spacing-sm);cursor:default}.m_efdf90cb{margin-top:calc(.25rem * var(--mantine-scale));margin-bottom:calc(.25rem * var(--mantine-scale));border-top:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_efdf90cb{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_efdf90cb{border-color:var(--mantine-color-dark-4)}.m_99ac2aa1{font-size:var(--mantine-font-size-sm);width:100%;padding:calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-sm);border-radius:var(--popover-radius, var(--mantine-radius-default));color:var(--menu-item-color, var(--mantine-color-text));display:flex;align-items:center;user-select:none}.m_99ac2aa1:where([data-disabled],:disabled){color:var(--mantine-color-disabled-color);opacity:.6;cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_99ac2aa1:where(:hover,:focus):where(:not(:disabled,[data-disabled])){background-color:var(--menu-item-hover, var(--mantine-color-gray-1))}:where([data-mantine-color-scheme=dark]) .m_99ac2aa1:where(:hover,:focus):where(:not(:disabled,[data-disabled])){background-color:var(--menu-item-hover, var(--mantine-color-dark-4))}.m_99ac2aa1:where([data-sub-menu-item]){padding-inline-end:calc(.3125rem * var(--mantine-scale))}.m_5476e0d3{flex:1}.m_8b75e504{display:flex;justify-content:center;align-items:center}.m_8b75e504:where([data-position=left]){margin-inline-end:var(--mantine-spacing-xs)}.m_8b75e504:where([data-position=right]){margin-inline-start:var(--mantine-spacing-xs)}.m_b85b0bed{transform:rotate(-90deg)}:where([dir=rtl]) .m_b85b0bed{transform:rotate(90deg)}.m_9df02822{--modal-size-xs: calc(20rem * var(--mantine-scale));--modal-size-sm: calc(23.75rem * var(--mantine-scale));--modal-size-md: calc(27.5rem * var(--mantine-scale));--modal-size-lg: calc(38.75rem * var(--mantine-scale));--modal-size-xl: calc(48.75rem * var(--mantine-scale));--modal-size: var(--modal-size-md);--modal-y-offset: 5dvh;--modal-x-offset: 5vw}.m_9df02822[data-full-screen]{--modal-border-radius: 0 !important}.m_9df02822[data-full-screen] .m_54c44539{--modal-content-flex: 0 0 100%;--modal-content-max-height: auto;--modal-content-height: 100dvh}.m_9df02822[data-full-screen] .m_1f958f16{--modal-inner-y-offset: 0;--modal-inner-x-offset: 0}.m_9df02822[data-centered] .m_1f958f16{--modal-inner-align: center}.m_d0e2b9cd{border-start-start-radius:var(--modal-radius, var(--mantine-radius-default));border-start-end-radius:var(--modal-radius, var(--mantine-radius-default))}.m_54c44539{flex:var(--modal-content-flex, 0 0 var(--modal-size));max-width:100%;max-height:var(--modal-content-max-height, calc(100dvh - var(--modal-y-offset) * 2));height:var(--modal-content-height, auto);overflow-y:auto}.m_54c44539[data-full-screen]{border-radius:0}.m_54c44539[data-hidden]{opacity:0!important;pointer-events:none}.m_1f958f16{display:flex;justify-content:center;align-items:var(--modal-inner-align, flex-start);padding-top:var(--modal-inner-y-offset, var(--modal-y-offset));padding-bottom:var(--modal-inner-y-offset, var(--modal-y-offset));padding-inline:var(--modal-inner-x-offset, var(--modal-x-offset))}.m_7cda1cd6{--pill-fz-xs: calc(.625rem * var(--mantine-scale));--pill-fz-sm: calc(.75rem * var(--mantine-scale));--pill-fz-md: calc(.875rem * var(--mantine-scale));--pill-fz-lg: calc(1rem * var(--mantine-scale));--pill-fz-xl: calc(1.125rem * var(--mantine-scale));--pill-height-xs: calc(1.125rem * var(--mantine-scale));--pill-height-sm: calc(1.375rem * var(--mantine-scale));--pill-height-md: calc(1.5625rem * var(--mantine-scale));--pill-height-lg: calc(1.75rem * var(--mantine-scale));--pill-height-xl: calc(2rem * var(--mantine-scale));--pill-fz: var(--pill-fz-sm);--pill-height: var(--pill-height-sm);font-size:var(--pill-fz);flex:0;height:var(--pill-height);padding-inline:.8em;display:inline-flex;align-items:center;border-radius:var(--pill-radius, 1000rem);line-height:1;white-space:nowrap;user-select:none;-webkit-user-select:none;max-width:100%}:where([data-mantine-color-scheme=dark]) .m_7cda1cd6{background-color:var(--mantine-color-dark-7);color:var(--mantine-color-dark-0)}:where([data-mantine-color-scheme=light]) .m_7cda1cd6{color:var(--mantine-color-black)}.m_7cda1cd6:where([data-with-remove]:not(:has(button:disabled))){padding-inline-end:0}.m_7cda1cd6:where([data-disabled],:has(button:disabled)){cursor:not-allowed}:where([data-mantine-color-scheme=light]) .m_44da308b{background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=light]) .m_44da308b:where([data-disabled],:has(button:disabled)){background-color:var(--mantine-color-disabled)}:where([data-mantine-color-scheme=light]) .m_e3a01f8{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=light]) .m_e3a01f8:where([data-disabled],:has(button:disabled)){background-color:var(--mantine-color-disabled)}.m_1e0e6180{cursor:inherit;overflow:hidden;height:100%;line-height:var(--pill-height);text-overflow:ellipsis}.m_ae386778{color:inherit;font-size:inherit;height:100%;min-height:unset;min-width:2em;width:unset;border-radius:0;padding-inline-start:.1em;padding-inline-end:.3em;flex:0;border-end-end-radius:var(--pill-radius, 50%);border-start-end-radius:var(--pill-radius, 50%)}.m_7cda1cd6[data-disabled]>.m_ae386778,.m_ae386778:disabled{display:none;background-color:transparent;width:.8em;min-width:.8em;padding:0;cursor:not-allowed}.m_7cda1cd6[data-disabled]>.m_ae386778>svg,.m_ae386778:disabled>svg{display:none}.m_ae386778>svg{pointer-events:none}.m_1dcfd90b{--pg-gap-xs: calc(.375rem * var(--mantine-scale));--pg-gap-sm: calc(.5rem * var(--mantine-scale));--pg-gap-md: calc(.625rem * var(--mantine-scale));--pg-gap-lg: calc(.75rem * var(--mantine-scale));--pg-gap-xl: calc(.75rem * var(--mantine-scale));--pg-gap: var(--pg-gap-sm);display:flex;align-items:center;gap:var(--pg-gap);flex-wrap:wrap}.m_45c4369d{background-color:transparent;appearance:none;min-width:calc(6.25rem * var(--mantine-scale));flex:1;border:0;font-size:inherit;height:1.6em;color:inherit;padding:0}.m_45c4369d::placeholder{color:var(--input-placeholder-color);opacity:1}.m_45c4369d:where([data-type=hidden],[data-type=auto]){height:calc(.0625rem * var(--mantine-scale));width:calc(.0625rem * var(--mantine-scale));top:0;left:0;pointer-events:none;position:absolute;opacity:0}.m_45c4369d:focus{outline:none}.m_45c4369d:where([data-type=auto]:focus){height:1.6em;visibility:visible;opacity:1;position:static}.m_45c4369d:where([data-pointer]:not([data-disabled],:disabled)){cursor:pointer}.m_45c4369d:where([data-disabled],:disabled){cursor:not-allowed}.m_f0824112{--nl-bg: var(--mantine-primary-color-light);--nl-hover: var(--mantine-primary-color-light-hover);--nl-color: var(--mantine-primary-color-light-color);display:flex;align-items:center;width:100%;padding:8px var(--mantine-spacing-sm);user-select:none}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_f0824112:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_f0824112:hover{background-color:var(--mantine-color-dark-6)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_f0824112:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_f0824112:active{background-color:var(--mantine-color-dark-6)}}.m_f0824112:where([data-disabled]){opacity:.4;pointer-events:none}.m_f0824112:where([data-active],[aria-current=page]){background-color:var(--nl-bg);color:var(--nl-color)}@media(hover:hover){.m_f0824112:where([data-active],[aria-current=page]):hover{background-color:var(--nl-hover)}}@media(hover:none){.m_f0824112:where([data-active],[aria-current=page]):active{background-color:var(--nl-hover)}}.m_f0824112:where([data-active],[aria-current=page]) .m_57492dcc{--description-opacity: .9;--description-color: var(--nl-color)}.m_690090b5{display:flex;align-items:center;justify-content:center;transition:transform .15s ease}.m_690090b5>svg{display:block}.m_690090b5:where([data-position=left]){margin-inline-end:var(--mantine-spacing-sm)}.m_690090b5:where([data-position=right]){margin-inline-start:var(--mantine-spacing-sm)}.m_690090b5:where([data-rotate]){transform:rotate(90deg)}.m_1f6ac4c4{font-size:var(--mantine-font-size-sm)}.m_f07af9d2{flex:1;overflow:hidden;text-overflow:ellipsis}.m_f07af9d2:where([data-no-wrap]){white-space:nowrap}.m_57492dcc{display:block;font-size:var(--mantine-font-size-xs);opacity:var(--description-opacity, 1);color:var(--description-color, var(--mantine-color-dimmed));overflow:hidden;text-overflow:ellipsis}:where([data-no-wrap]) .m_57492dcc{white-space:nowrap}.m_e17b862f{padding-inline-start:var(--nl-offset, var(--mantine-spacing-lg))}.m_1fd8a00b{transform:rotate(-90deg)}.m_a513464{--notification-radius: var(--mantine-radius-default);--notification-color: var(--mantine-primary-color-filled);overflow:hidden;box-sizing:border-box;position:relative;display:flex;align-items:center;padding-inline-start:calc(1.375rem * var(--mantine-scale));padding-inline-end:var(--mantine-spacing-xs);padding-top:var(--mantine-spacing-xs);padding-bottom:var(--mantine-spacing-xs);border-radius:var(--notification-radius);box-shadow:var(--mantine-shadow-lg)}.m_a513464:before{content:"";display:block;position:absolute;width:calc(.375rem * var(--mantine-scale));top:var(--notification-radius);bottom:var(--notification-radius);inset-inline-start:calc(.25rem * var(--mantine-scale));border-radius:var(--notification-radius);background-color:var(--notification-color)}:where([data-mantine-color-scheme=light]) .m_a513464{background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_a513464{background-color:var(--mantine-color-dark-6)}.m_a513464:where([data-with-icon]):before{display:none}:where([data-mantine-color-scheme=light]) .m_a513464:where([data-with-border]){border:1px solid var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_a513464:where([data-with-border]){border:1px solid var(--mantine-color-dark-4)}.m_a4ceffb{box-sizing:border-box;margin-inline-end:var(--mantine-spacing-md);width:calc(1.75rem * var(--mantine-scale));height:calc(1.75rem * var(--mantine-scale));border-radius:calc(1.75rem * var(--mantine-scale));display:flex;align-items:center;justify-content:center;background-color:var(--notification-color);color:var(--mantine-color-white)}.m_b0920b15{margin-inline-end:var(--mantine-spacing-md)}.m_a49ed24{flex:1;overflow:hidden;margin-inline-end:var(--mantine-spacing-xs)}.m_3feedf16{margin-bottom:calc(.125rem * var(--mantine-scale));overflow:hidden;text-overflow:ellipsis;font-size:var(--mantine-font-size-sm);line-height:var(--mantine-line-height-sm);font-weight:500}:where([data-mantine-color-scheme=light]) .m_3feedf16{color:var(--mantine-color-gray-9)}:where([data-mantine-color-scheme=dark]) .m_3feedf16{color:var(--mantine-color-white)}.m_3d733a3a{font-size:var(--mantine-font-size-sm);line-height:var(--mantine-line-height-sm);overflow:hidden;text-overflow:ellipsis}:where([data-mantine-color-scheme=light]) .m_3d733a3a{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_3d733a3a{color:var(--mantine-color-dark-0)}:where([data-mantine-color-scheme=light]) .m_3d733a3a:where([data-with-title]){color:var(--mantine-color-gray-6)}:where([data-mantine-color-scheme=dark]) .m_3d733a3a:where([data-with-title]){color:var(--mantine-color-dark-2)}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_919a4d88:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_919a4d88:hover{background-color:var(--mantine-color-dark-8)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_919a4d88:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_919a4d88:active{background-color:var(--mantine-color-dark-8)}}.m_e2f5cd4e{--ni-right-section-width-xs: calc(1.0625rem * var(--mantine-scale));--ni-right-section-width-sm: calc(1.5rem * var(--mantine-scale));--ni-right-section-width-md: calc(1.6875rem * var(--mantine-scale));--ni-right-section-width-lg: calc(1.9375rem * var(--mantine-scale));--ni-right-section-width-xl: calc(2.125rem * var(--mantine-scale))}.m_95e17d22{--ni-chevron-size-xs: calc(.625rem * var(--mantine-scale));--ni-chevron-size-sm: calc(.875rem * var(--mantine-scale));--ni-chevron-size-md: calc(1rem * var(--mantine-scale));--ni-chevron-size-lg: calc(1.125rem * var(--mantine-scale));--ni-chevron-size-xl: calc(1.25rem * var(--mantine-scale));--ni-chevron-size: var(--ni-chevron-size-sm);display:flex;flex-direction:column;width:100%;height:calc(var(--input-height) - calc(.125rem * var(--mantine-scale)));max-width:calc(var(--ni-chevron-size) * 1.7);margin-inline-start:auto}.m_80b4b171{--control-border: 1px solid var(--input-bd);--control-radius: calc(var(--input-radius) - calc(.0625rem * var(--mantine-scale)));flex:0 0 50%;width:100%;padding:0;height:calc(var(--input-height) / 2 - calc(.0625rem * var(--mantine-scale)));border-inline-start:var(--control-border);display:flex;align-items:center;justify-content:center;color:var(--mantine-color-text);background-color:transparent;cursor:pointer}.m_80b4b171:where(:disabled){background-color:transparent;cursor:not-allowed;opacity:.6;color:var(--mantine-color-disabled-color)}.m_e2f5cd4e[data-error] :where(.m_80b4b171){color:var(--mantine-color-error)}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_80b4b171:hover{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_80b4b171:hover{background-color:var(--mantine-color-dark-4)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_80b4b171:active{background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_80b4b171:active{background-color:var(--mantine-color-dark-4)}}.m_80b4b171:where(:first-of-type){border-radius:0;border-start-end-radius:var(--control-radius)}.m_80b4b171:last-of-type{border-radius:0;border-end-end-radius:var(--control-radius)}.m_4addd315{--pagination-control-size-xs: calc(1.375rem * var(--mantine-scale));--pagination-control-size-sm: calc(1.625rem * var(--mantine-scale));--pagination-control-size-md: calc(2rem * var(--mantine-scale));--pagination-control-size-lg: calc(2.375rem * var(--mantine-scale));--pagination-control-size-xl: calc(2.75rem * var(--mantine-scale));--pagination-control-size: var(--pagination-control-size-md);--pagination-control-fz: var(--mantine-font-size-md);--pagination-active-bg: var(--mantine-primary-color-filled)}.m_326d024a{display:flex;align-items:center;justify-content:center;border:calc(.0625rem * var(--mantine-scale)) solid;cursor:pointer;color:var(--mantine-color-text);height:var(--pagination-control-size);min-width:var(--pagination-control-size);font-size:var(--pagination-control-fz);line-height:1;border-radius:var(--pagination-control-radius, var(--mantine-radius-default))}.m_326d024a:where([data-with-padding]){padding:calc(var(--pagination-control-size) / 4)}.m_326d024a:where(:disabled,[data-disabled]){cursor:not-allowed;opacity:.4}:where([data-mantine-color-scheme=light]) .m_326d024a{border-color:var(--mantine-color-gray-4);background-color:var(--mantine-color-white)}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_326d024a:hover:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-gray-0)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_326d024a:active:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-gray-0)}}:where([data-mantine-color-scheme=dark]) .m_326d024a{border-color:var(--mantine-color-dark-4);background-color:var(--mantine-color-dark-6)}@media(hover:hover){:where([data-mantine-color-scheme=dark]) .m_326d024a:hover:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-dark-5)}}@media(hover:none){:where([data-mantine-color-scheme=dark]) .m_326d024a:active:where(:not(:disabled,[data-disabled])){background-color:var(--mantine-color-dark-5)}}.m_326d024a:where([data-active]){background-color:var(--pagination-active-bg);border-color:var(--pagination-active-bg);color:var(--pagination-active-color, var(--mantine-color-white))}@media(hover:hover){.m_326d024a:where([data-active]):hover{background-color:var(--pagination-active-bg)}}@media(hover:none){.m_326d024a:where([data-active]):active{background-color:var(--pagination-active-bg)}}.m_4ad7767d{height:var(--pagination-control-size);min-width:var(--pagination-control-size);display:flex;align-items:center;justify-content:center;pointer-events:none}.m_f61ca620{--psi-button-size-xs: calc(1.375rem * var(--mantine-scale));--psi-button-size-sm: calc(1.625rem * var(--mantine-scale));--psi-button-size-md: calc(1.75rem * var(--mantine-scale));--psi-button-size-lg: calc(2rem * var(--mantine-scale));--psi-button-size-xl: calc(2.5rem * var(--mantine-scale));--psi-icon-size-xs: calc(.75rem * var(--mantine-scale));--psi-icon-size-sm: calc(.9375rem * var(--mantine-scale));--psi-icon-size-md: calc(1.0625rem * var(--mantine-scale));--psi-icon-size-lg: calc(1.1875rem * var(--mantine-scale));--psi-icon-size-xl: calc(1.3125rem * var(--mantine-scale));--psi-button-size: var(--psi-button-size-sm);--psi-icon-size: var(--psi-icon-size-sm)}.m_ccf8da4c{position:relative;overflow:hidden}.m_f2d85dd2{font-family:var(--mantine-font-family);background-color:transparent;border:0;padding-inline-end:var(--input-padding-inline-end);padding-inline-start:var(--input-padding-inline-start);position:absolute;inset:0;outline:0;font-size:inherit;line-height:var(--mantine-line-height);height:100%;width:100%;color:inherit}.m_ccf8da4c[data-disabled] .m_f2d85dd2,.m_f2d85dd2:disabled{cursor:not-allowed}.m_f2d85dd2::placeholder{color:var(--input-placeholder-color);opacity:1}.m_f2d85dd2::-ms-reveal{display:none}.m_b1072d44{width:var(--psi-button-size);height:var(--psi-button-size);min-width:var(--psi-button-size);min-height:var(--psi-button-size)}.m_b1072d44:disabled{display:none}.m_f1cb205a{--pin-input-size-xs: calc(1.875rem * var(--mantine-scale));--pin-input-size-sm: calc(2.25rem * var(--mantine-scale));--pin-input-size-md: calc(2.625rem * var(--mantine-scale));--pin-input-size-lg: calc(3.125rem * var(--mantine-scale));--pin-input-size-xl: calc(3.75rem * var(--mantine-scale));--pin-input-size: var(--pin-input-size-sm)}.m_cb288ead{width:var(--pin-input-size);height:var(--pin-input-size)}@keyframes m_81a374bd{0%{background-position:0 0}to{background-position:calc(2.5rem * var(--mantine-scale)) 0}}@keyframes m_e0fb7a86{0%{background-position:0 0}to{background-position:0 calc(2.5rem * var(--mantine-scale))}}.m_db6d6462{--progress-radius: var(--mantine-radius-default);--progress-size: var(--progress-size-md);--progress-size-xs: calc(.1875rem * var(--mantine-scale));--progress-size-sm: calc(.3125rem * var(--mantine-scale));--progress-size-md: calc(.5rem * var(--mantine-scale));--progress-size-lg: calc(.75rem * var(--mantine-scale));--progress-size-xl: calc(1rem * var(--mantine-scale));position:relative;height:var(--progress-size);border-radius:var(--progress-radius);overflow:hidden;display:flex}:where([data-mantine-color-scheme=light]) .m_db6d6462{background-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_db6d6462{background-color:var(--mantine-color-dark-4)}.m_db6d6462:where([data-orientation=vertical]){height:auto;width:var(--progress-size);flex-direction:column-reverse}.m_2242eb65{background-color:var(--progress-section-color);height:100%;width:var(--progress-section-size);display:flex;align-items:center;justify-content:center;overflow:hidden;background-size:calc(1.25rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));transition:width var(--progress-transition-duration, .1s) ease}.m_2242eb65:where([data-striped]){background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.m_2242eb65:where([data-animated]){animation:m_81a374bd 1s linear infinite}.m_2242eb65:where(:last-of-type){border-radius:0;border-start-end-radius:var(--progress-radius);border-end-end-radius:var(--progress-radius)}.m_2242eb65:where(:first-of-type){border-radius:0;border-start-start-radius:var(--progress-radius);border-end-start-radius:var(--progress-radius)}.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65{width:100%;height:var(--progress-section-size);transition:height var(--progress-transition-duration, .1s) ease}.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where([data-striped]){background-image:linear-gradient(135deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where([data-animated]){animation:m_e0fb7a86 1s linear infinite}.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where(:last-of-type){border-radius:0;border-start-start-radius:var(--progress-radius);border-start-end-radius:var(--progress-radius)}.m_db6d6462:where([data-orientation=vertical]) .m_2242eb65:where(:first-of-type){border-radius:0;border-end-start-radius:var(--progress-radius);border-end-end-radius:var(--progress-radius)}.m_91e40b74{color:var(--progress-label-color, var(--mantine-color-white));font-weight:700;user-select:none;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-size:min(calc(var(--progress-size) * .65),calc(1.125rem * var(--mantine-scale)));line-height:1;padding-inline:calc(.25rem * var(--mantine-scale))}.m_db6d6462:where([data-orientation=vertical]) .m_91e40b74{writing-mode:vertical-rl}.m_9dc8ae12{--card-radius: var(--mantine-radius-default);display:block;width:100%;border-radius:var(--card-radius);cursor:pointer}.m_9dc8ae12 :where(*){cursor:inherit}.m_9dc8ae12:where([data-with-border]){border:calc(.0625rem * var(--mantine-scale)) solid transparent}:where([data-mantine-color-scheme=light]) .m_9dc8ae12:where([data-with-border]){border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_9dc8ae12:where([data-with-border]){border-color:var(--mantine-color-dark-4)}.m_717d7ff6{--radio-size-xs: calc(1rem * var(--mantine-scale));--radio-size-sm: calc(1.25rem * var(--mantine-scale));--radio-size-md: calc(1.5rem * var(--mantine-scale));--radio-size-lg: calc(1.875rem * var(--mantine-scale));--radio-size-xl: calc(2.25rem * var(--mantine-scale));--radio-icon-size-xs: calc(.375rem * var(--mantine-scale));--radio-icon-size-sm: calc(.5rem * var(--mantine-scale));--radio-icon-size-md: calc(.625rem * var(--mantine-scale));--radio-icon-size-lg: calc(.875rem * var(--mantine-scale));--radio-icon-size-xl: calc(1rem * var(--mantine-scale));--radio-icon-size: var(--radio-icon-size-sm);--radio-size: var(--radio-size-sm);--radio-color: var(--mantine-primary-color-filled);--radio-icon-color: var(--mantine-color-white);position:relative;border:calc(.0625rem * var(--mantine-scale)) solid transparent;width:var(--radio-size);min-width:var(--radio-size);height:var(--radio-size);min-height:var(--radio-size);border-radius:var(--radio-radius, 10000px);transition:border-color .1s ease,background-color .1s ease;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent;display:flex;align-items:center;justify-content:center}:where([data-mantine-color-scheme=light]) .m_717d7ff6{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_717d7ff6{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_717d7ff6[data-indeterminate],.m_717d7ff6[data-checked]{background-color:var(--radio-color);border-color:var(--radio-color)}.m_717d7ff6[data-indeterminate]>.m_3e4da632,.m_717d7ff6[data-checked]>.m_3e4da632{opacity:1;transform:none;color:var(--radio-icon-color)}.m_717d7ff6[data-disabled]{cursor:not-allowed;background-color:var(--mantine-color-disabled);border-color:var(--mantine-color-disabled-border)}.m_717d7ff6[data-disabled][data-checked]>.m_3e4da632{color:var(--mantine-color-disabled-color)}.m_2980836c[data-indeterminate]:not([data-disabled]),.m_2980836c[data-checked]:not([data-disabled]){background-color:transparent;border-color:var(--radio-color)}.m_2980836c[data-indeterminate]:not([data-disabled])>.m_3e4da632,.m_2980836c[data-checked]:not([data-disabled])>.m_3e4da632{color:var(--radio-color);opacity:1;transform:none}.m_3e4da632{display:block;width:var(--radio-icon-size);height:var(--radio-icon-size);color:transparent;pointer-events:none;transform:translateY(calc(.3125rem * var(--mantine-scale))) scale(.5);opacity:1;transition:transform .1s ease,opacity .1s ease}.m_f3f1af94{--radio-size-xs: calc(1rem * var(--mantine-scale));--radio-size-sm: calc(1.25rem * var(--mantine-scale));--radio-size-md: calc(1.5rem * var(--mantine-scale));--radio-size-lg: calc(1.875rem * var(--mantine-scale));--radio-size-xl: calc(2.25rem * var(--mantine-scale));--radio-size: var(--radio-size-sm);--radio-icon-size-xs: calc(.375rem * var(--mantine-scale));--radio-icon-size-sm: calc(.5rem * var(--mantine-scale));--radio-icon-size-md: calc(.625rem * var(--mantine-scale));--radio-icon-size-lg: calc(.875rem * var(--mantine-scale));--radio-icon-size-xl: calc(1rem * var(--mantine-scale));--radio-icon-size: var(--radio-icon-size-sm);--radio-icon-color: var(--mantine-color-white)}.m_89c4f5e4{position:relative;width:var(--radio-size);height:var(--radio-size);order:1}.m_89c4f5e4:where([data-label-position=left]){order:2}.m_f3ed6b2b{color:var(--radio-icon-color);opacity:var(--radio-icon-opacity, 0);transform:var(--radio-icon-transform, scale(.2) translateY(calc(.625rem * var(--mantine-scale))));transition:opacity .1s ease,transform .2s ease;pointer-events:none;width:var(--radio-icon-size);height:var(--radio-icon-size);position:absolute;top:calc(50% - var(--radio-icon-size) / 2);left:calc(50% - var(--radio-icon-size) / 2)}.m_8a3dbb89{border:calc(.0625rem * var(--mantine-scale)) solid;position:relative;appearance:none;width:var(--radio-size);height:var(--radio-size);border-radius:var(--radio-radius, var(--radio-size));margin:0;display:flex;align-items:center;justify-content:center;transition-property:background-color,border-color;transition-timing-function:ease;transition-duration:.1s;cursor:var(--mantine-cursor-type);-webkit-tap-highlight-color:transparent}:where([data-mantine-color-scheme=light]) .m_8a3dbb89{background-color:var(--mantine-color-white);border-color:var(--mantine-color-gray-4)}:where([data-mantine-color-scheme=dark]) .m_8a3dbb89{background-color:var(--mantine-color-dark-6);border-color:var(--mantine-color-dark-4)}.m_8a3dbb89:checked{background-color:var(--radio-color, var(--mantine-primary-color-filled));border-color:var(--radio-color, var(--mantine-primary-color-filled))}.m_8a3dbb89:checked+.m_f3ed6b2b{--radio-icon-opacity: 1;--radio-icon-transform: scale(1)}.m_8a3dbb89:disabled{cursor:not-allowed;background-color:var(--mantine-color-disabled);border-color:var(--mantine-color-disabled-border)}.m_8a3dbb89:disabled+.m_f3ed6b2b{--radio-icon-color: var(--mantine-color-disabled-color)}.m_8a3dbb89:where([data-error]){border-color:var(--mantine-color-error)}.m_1bfe9d39+.m_f3ed6b2b{--radio-icon-color: var(--radio-color)}.m_1bfe9d39:checked:not(:disabled){background-color:transparent;border-color:var(--radio-color)}.m_1bfe9d39:checked:not(:disabled)+.m_f3ed6b2b{--radio-icon-color: var(--radio-color);--radio-icon-opacity: 1;--radio-icon-transform: none}.m_f8d312f2{--rating-size-xs: calc(.875rem * var(--mantine-scale));--rating-size-sm: calc(1.125rem * var(--mantine-scale));--rating-size-md: calc(1.25rem * var(--mantine-scale));--rating-size-lg: calc(1.75rem * var(--mantine-scale));--rating-size-xl: calc(2rem * var(--mantine-scale));display:flex;width:max-content}.m_f8d312f2:where(:has(input:disabled)){pointer-events:none}.m_61734bb7{position:relative;transition:transform .1s ease}.m_61734bb7:where([data-active]){z-index:1;transform:scale(1.1)}.m_5662a89a{width:var(--rating-size);height:var(--rating-size);display:block}:where([data-mantine-color-scheme=light]) .m_5662a89a{fill:var(--mantine-color-gray-3);stroke:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_5662a89a{fill:var(--mantine-color-dark-3);stroke:var(--mantine-color-dark-3)}.m_5662a89a:where([data-filled]){fill:var(--rating-color);stroke:var(--rating-color)}.m_211007ba{height:0;width:0;position:absolute;overflow:hidden;white-space:nowrap;opacity:0;-webkit-tap-highlight-color:transparent}.m_211007ba:focus-visible+label{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_21342ee4{display:block;cursor:pointer;position:absolute;top:0;left:0;z-index:var(--rating-item-z-index, 0);-webkit-tap-highlight-color:transparent}.m_21342ee4:where([data-read-only]){cursor:default}.m_21342ee4:where(:last-of-type){position:relative}.m_fae05d6a{clip-path:var(--rating-symbol-clip-path)}.m_1b3c8819{--tooltip-radius: var(--mantine-radius-default);position:absolute;padding:calc(var(--mantine-spacing-xs) / 2) var(--mantine-spacing-xs);pointer-events:none;font-size:var(--mantine-font-size-sm);white-space:nowrap;border-radius:var(--tooltip-radius)}:where([data-mantine-color-scheme=light]) .m_1b3c8819{background-color:var(--tooltip-bg, var(--mantine-color-gray-9));color:var(--tooltip-color, var(--mantine-color-white))}:where([data-mantine-color-scheme=dark]) .m_1b3c8819{background-color:var(--tooltip-bg, var(--mantine-color-gray-2));color:var(--tooltip-color, var(--mantine-color-black))}.m_1b3c8819:where([data-multiline]){white-space:normal}.m_1b3c8819:where([data-fixed]){position:fixed}.m_f898399f{background-color:inherit;border:0;z-index:1}.m_b32e4812{position:relative;width:var(--rp-size);height:var(--rp-size);min-width:var(--rp-size);min-height:var(--rp-size);--rp-transition-duration: 0ms}.m_d43b5134{width:var(--rp-size);height:var(--rp-size);min-width:var(--rp-size);min-height:var(--rp-size);transform:rotate(-90deg)}.m_b1ca1fbf{stroke:var(--curve-color, var(--rp-curve-root-color));transition:stroke-dashoffset var(--rp-transition-duration) ease,stroke-dasharray var(--rp-transition-duration) ease,stroke var(--rp-transition-duration)}[data-mantine-color-scheme=light] .m_b1ca1fbf{--rp-curve-root-color: var(--mantine-color-gray-2)}[data-mantine-color-scheme=dark] .m_b1ca1fbf{--rp-curve-root-color: var(--mantine-color-dark-4)}.m_b23f9dc4{position:absolute;top:50%;transform:translateY(-50%);inset-inline:var(--rp-label-offset)}.m_cf365364{--sc-padding-xs: calc(.125rem * var(--mantine-scale)) calc(.375rem * var(--mantine-scale));--sc-padding-sm: calc(.1875rem * var(--mantine-scale)) calc(.625rem * var(--mantine-scale));--sc-padding-md: calc(.25rem * var(--mantine-scale)) calc(.875rem * var(--mantine-scale));--sc-padding-lg: calc(.4375rem * var(--mantine-scale)) calc(1rem * var(--mantine-scale));--sc-padding-xl: calc(.625rem * var(--mantine-scale)) calc(1.25rem * var(--mantine-scale));--sc-transition-duration: .2s;--sc-padding: var(--sc-padding-sm);--sc-transition-timing-function: ease;--sc-font-size: var(--mantine-font-size-sm);position:relative;display:inline-flex;flex-direction:row;width:auto;border-radius:var(--sc-radius, var(--mantine-radius-default));overflow:hidden;padding:calc(.25rem * var(--mantine-scale))}.m_cf365364:where([data-full-width]){display:flex}.m_cf365364:where([data-orientation=vertical]){display:flex;flex-direction:column;width:max-content}.m_cf365364:where([data-orientation=vertical]):where([data-full-width]){width:auto}:where([data-mantine-color-scheme=light]) .m_cf365364{background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_cf365364{background-color:var(--mantine-color-dark-8)}.m_9e182ccd{position:absolute;display:block;z-index:1;border-radius:var(--sc-radius, var(--mantine-radius-default))}:where([data-mantine-color-scheme=light]) .m_9e182ccd{box-shadow:var(--sc-shadow, none);background-color:var(--sc-color, var(--mantine-color-white))}:where([data-mantine-color-scheme=dark]) .m_9e182ccd{box-shadow:none;background-color:var(--sc-color, var(--mantine-color-dark-5))}.m_1738fcb2{-webkit-tap-highlight-color:transparent;font-weight:500;display:block;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;user-select:none;border-radius:var(--sc-radius, var(--mantine-radius-default));font-size:var(--sc-font-size);padding:var(--sc-padding);transition:color var(--sc-transition-duration) var(--sc-transition-timing-function);cursor:pointer;outline:var(--segmented-control-outline, none)}:where([data-mantine-color-scheme=light]) .m_1738fcb2{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_1738fcb2{color:var(--mantine-color-dark-1)}.m_1738fcb2:where([data-read-only]){cursor:default}fieldset:disabled .m_1738fcb2,.m_1738fcb2:where([data-disabled]){cursor:not-allowed;color:var(--mantine-color-disabled-color)}:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-active]){color:var(--sc-label-color, var(--mantine-color-black))}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-active]){color:var(--sc-label-color, var(--mantine-color-white))}.m_cf365364:where([data-initialized]) .m_1738fcb2:where([data-active]):before{display:none}.m_1738fcb2:where([data-active]):before{content:"";inset:0;z-index:0;position:absolute;border-radius:var(--sc-radius, var(--mantine-radius-default))}:where([data-mantine-color-scheme=light]) .m_1738fcb2:where([data-active]):before{box-shadow:var(--sc-shadow, none);background-color:var(--sc-color, var(--mantine-color-white))}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where([data-active]):before{box-shadow:none;background-color:var(--sc-color, var(--mantine-color-dark-5))}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):hover{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):hover{color:var(--mantine-color-white)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):active{color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_1738fcb2:where(:not([data-disabled],[data-active],[data-read-only])):active{color:var(--mantine-color-white)}}@media(hover:hover){fieldset:disabled .m_1738fcb2:hover{color:var(--mantine-color-disabled-color)!important}}@media(hover:none){fieldset:disabled .m_1738fcb2:active{color:var(--mantine-color-disabled-color)!important}}.m_1714d588{height:0;width:0;position:absolute;overflow:hidden;white-space:nowrap;opacity:0}.m_1714d588[data-focus-ring=auto]:focus:focus-visible+.m_1738fcb2{--segmented-control-outline: 2px solid var(--mantine-primary-color-filled)}.m_1714d588[data-focus-ring=always]:focus+.m_1738fcb2{--segmented-control-outline: 2px solid var(--mantine-primary-color-filled)}.m_69686b9b{position:relative;flex:1;z-index:2;transition:border-color var(--sc-transition-duration) var(--sc-transition-timing-function)}.m_cf365364[data-with-items-borders] :where(.m_69686b9b):before{content:"";position:absolute;top:0;bottom:0;inset-inline-start:0;background-color:var(--separator-color);width:calc(.0625rem * var(--mantine-scale));transition:background-color var(--sc-transition-duration) var(--sc-transition-timing-function)}.m_69686b9b[data-orientation=vertical]:before{top:0;inset-inline:0;bottom:auto;height:calc(.0625rem * var(--mantine-scale));width:auto}:where([data-mantine-color-scheme=light]) .m_69686b9b{--separator-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_69686b9b{--separator-color: var(--mantine-color-dark-4)}.m_69686b9b:first-of-type:before{--separator-color: transparent}[data-mantine-color-scheme] .m_69686b9b[data-active]:before,[data-mantine-color-scheme] .m_69686b9b[data-active]+.m_69686b9b:before{--separator-color: transparent}.m_78882f40{position:relative;z-index:2}.m_fa528724{--scp-filled-segment-color: var(--mantine-primary-color-filled);--scp-transition-duration: 0ms;--scp-thickness: calc(.625rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_fa528724{--scp-empty-segment-color: var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_fa528724{--scp-empty-segment-color: var(--mantine-color-dark-4)}.m_fa528724{position:relative;width:fit-content}.m_62e9e7e2{display:block;transform:var(--scp-rotation);overflow:hidden}.m_c573fb6f{transition:stroke-dashoffset var(--scp-transition-duration) ease,stroke-dasharray var(--scp-transition-duration) ease,stroke var(--scp-transition-duration)}.m_4fa340f2{position:absolute;margin:0;padding:0;inset-inline:0;text-align:center;z-index:1}.m_4fa340f2:where([data-position=bottom]){bottom:0;padding-inline:calc(var(--scp-thickness) * 2)}.m_4fa340f2:where([data-position=bottom]):where([data-orientation=down]){bottom:auto;top:0}.m_4fa340f2:where([data-position=center]){top:50%;padding-inline:calc(var(--scp-thickness) * 3)}.m_925c2d2c{container:simple-grid / inline-size}.m_2415a157{display:grid;grid-template-columns:repeat(var(--sg-cols),minmax(0,1fr));gap:var(--sg-spacing-y) var(--sg-spacing-x)}@keyframes m_299c329c{0%,to{opacity:.4}50%{opacity:1}}.m_18320242{height:var(--skeleton-height, auto);width:var(--skeleton-width, 100%);border-radius:var(--skeleton-radius, var(--mantine-radius-default));position:relative;transform:translateZ(0);-webkit-transform:translateZ(0)}.m_18320242:where([data-animate]):after{animation:m_299c329c 1.5s linear infinite}.m_18320242:where([data-visible]){overflow:hidden}.m_18320242:where([data-visible]):before{position:absolute;content:"";inset:0;z-index:10;background-color:var(--mantine-color-body)}.m_18320242:where([data-visible]):after{position:absolute;content:"";inset:0;z-index:11}:where([data-mantine-color-scheme=light]) .m_18320242:where([data-visible]):after{background-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_18320242:where([data-visible]):after{background-color:var(--mantine-color-dark-4)}.m_dd36362e{--slider-size-xs: calc(.25rem * var(--mantine-scale));--slider-size-sm: calc(.375rem * var(--mantine-scale));--slider-size-md: calc(.5rem * var(--mantine-scale));--slider-size-lg: calc(.625rem * var(--mantine-scale));--slider-size-xl: calc(.75rem * var(--mantine-scale));--slider-size: var(--slider-size-md);--slider-radius: calc(62.5rem * var(--mantine-scale));--slider-color: var(--mantine-primary-color-filled);--slider-track-disabled-bg: var(--mantine-color-disabled);-webkit-tap-highlight-color:transparent;outline:none;height:calc(var(--slider-size) * 2);padding-inline:var(--slider-size);display:flex;flex-direction:column;align-items:center;touch-action:none;position:relative}[data-mantine-color-scheme=light] .m_dd36362e{--slider-track-bg: var(--mantine-color-gray-2)}[data-mantine-color-scheme=dark] .m_dd36362e{--slider-track-bg: var(--mantine-color-dark-4)}.m_c9357328{position:absolute;top:calc(-2.25rem * var(--mantine-scale));font-size:var(--mantine-font-size-xs);color:var(--mantine-color-white);padding:calc(var(--mantine-spacing-xs) / 2);border-radius:var(--mantine-radius-sm);white-space:nowrap;pointer-events:none;user-select:none;touch-action:none}:where([data-mantine-color-scheme=light]) .m_c9357328{background-color:var(--mantine-color-gray-9)}:where([data-mantine-color-scheme=dark]) .m_c9357328{background-color:var(--mantine-color-dark-4)}.m_c9a9a60a{position:absolute;display:flex;height:var(--slider-thumb-size);width:var(--slider-thumb-size);border:calc(.25rem * var(--mantine-scale)) solid;transform:translate(-50%,-50%);top:50%;cursor:pointer;border-radius:var(--slider-radius);align-items:center;justify-content:center;transition:box-shadow .1s ease,transform .1s ease;z-index:3;user-select:none;touch-action:none;outline-offset:calc(.125rem * var(--mantine-scale));left:var(--slider-thumb-offset)}:where([dir=rtl]) .m_c9a9a60a{left:auto;right:calc(var(--slider-thumb-offset) - var(--slider-thumb-size))}fieldset:disabled .m_c9a9a60a,.m_c9a9a60a:where([data-disabled]){display:none}.m_c9a9a60a:where([data-dragging]){transform:translate(-50%,-50%) scale(1.05);box-shadow:var(--mantine-shadow-sm)}:where([data-mantine-color-scheme=light]) .m_c9a9a60a{color:var(--slider-color);border-color:var(--slider-color);background-color:var(--mantine-color-white)}:where([data-mantine-color-scheme=dark]) .m_c9a9a60a{color:var(--mantine-color-white);border-color:var(--mantine-color-white);background-color:var(--slider-color)}.m_a8645c2{display:flex;align-items:center;width:100%;height:calc(var(--slider-size) * 2);cursor:pointer}fieldset:disabled .m_a8645c2,.m_a8645c2:where([data-disabled]){cursor:not-allowed}.m_c9ade57f{position:relative;width:100%;height:var(--slider-size)}.m_c9ade57f:where([data-inverted]:not([data-disabled])){--track-bg: var(--slider-color)}fieldset:disabled .m_c9ade57f:where([data-inverted]),.m_c9ade57f:where([data-inverted][data-disabled]){--track-bg: var(--slider-track-disabled-bg)}.m_c9ade57f:before{content:"";position:absolute;top:0;bottom:0;border-radius:var(--slider-radius);inset-inline:calc(var(--slider-size) * -1);background-color:var(--track-bg, var(--slider-track-bg));z-index:0}.m_38aeed47{position:absolute;z-index:1;top:0;bottom:0;background-color:var(--slider-color);border-radius:var(--slider-radius);width:var(--slider-bar-width);inset-inline-start:var(--slider-bar-offset)}.m_38aeed47:where([data-inverted]){background-color:var(--slider-track-bg)}fieldset:disabled .m_38aeed47:where(:not([data-inverted])),.m_38aeed47:where([data-disabled]:not([data-inverted])){background-color:var(--mantine-color-disabled-color)}.m_b7b0423a{position:absolute;inset-inline-start:calc(var(--mark-offset) - var(--slider-size) / 2);top:0;z-index:2;height:0;pointer-events:none}.m_dd33bc19{border:calc(.125rem * var(--mantine-scale)) solid;height:var(--slider-size);width:var(--slider-size);border-radius:calc(62.5rem * var(--mantine-scale));background-color:var(--mantine-color-white);pointer-events:none}:where([data-mantine-color-scheme=light]) .m_dd33bc19{border-color:var(--mantine-color-gray-2)}:where([data-mantine-color-scheme=dark]) .m_dd33bc19{border-color:var(--mantine-color-dark-4)}.m_dd33bc19:where([data-filled]){border-color:var(--slider-color)}.m_dd33bc19:where([data-filled]):where([data-disabled]){border-color:var(--mantine-color-disabled-border)}.m_68c77a5b{transform:translate(calc(-50% + var(--slider-size) / 2),calc(var(--mantine-spacing-xs) / 2));font-size:var(--mantine-font-size-sm);white-space:nowrap;cursor:pointer;user-select:none}:where([data-mantine-color-scheme=light]) .m_68c77a5b{color:var(--mantine-color-gray-6)}:where([data-mantine-color-scheme=dark]) .m_68c77a5b{color:var(--mantine-color-dark-2)}.m_559cce2d{position:relative}.m_559cce2d:where([data-has-spoiler]){margin-bottom:calc(1.5rem * var(--mantine-scale))}.m_b912df4e{display:flex;flex-direction:column;overflow:hidden;transition:max-height var(--spoiler-transition-duration, .2s) ease}.m_b9131032{position:absolute;inset-inline-start:0;top:100%;height:calc(1.5rem * var(--mantine-scale))}.m_6d731127{display:flex;flex-direction:column;align-items:var(--stack-align, stretch);justify-content:var(--stack-justify, flex-start);gap:var(--stack-gap, var(--mantine-spacing-md))}.m_cbb4ea7e{--stepper-icon-size-xs: calc(2.125rem * var(--mantine-scale));--stepper-icon-size-sm: calc(2.25rem * var(--mantine-scale));--stepper-icon-size-md: calc(2.625rem * var(--mantine-scale));--stepper-icon-size-lg: calc(3rem * var(--mantine-scale));--stepper-icon-size-xl: calc(3.25rem * var(--mantine-scale));--stepper-icon-size: var(--stepper-icon-size-md);--stepper-color: var(--mantine-primary-color-filled);--stepper-content-padding: var(--mantine-spacing-md);--stepper-spacing: var(--mantine-spacing-md);--stepper-radius: calc(62.5rem * var(--mantine-scale));--stepper-fz: var(--mantine-font-size-md);--stepper-outline-thickness: calc(.125rem * var(--mantine-scale))}[data-mantine-color-scheme=light] .m_cbb4ea7e{--stepper-outline-color: var(--mantine-color-gray-2)}[data-mantine-color-scheme=dark] .m_cbb4ea7e{--stepper-outline-color: var(--mantine-color-dark-5)}.m_aaf89d0b{display:flex;flex-wrap:nowrap;align-items:center}.m_aaf89d0b:where([data-wrap]){flex-wrap:wrap;gap:var(--mantine-spacing-md) 0}.m_aaf89d0b:where([data-orientation=vertical]){flex-direction:column}.m_aaf89d0b:where([data-orientation=vertical]):where([data-icon-position=left]){align-items:flex-start}.m_aaf89d0b:where([data-orientation=vertical]):where([data-icon-position=right]){align-items:flex-end}.m_aaf89d0b:where([data-orientation=horizontal]){flex-direction:row}.m_2a371ac9{transition:background-color .15s ease;flex:1;height:var(--stepper-outline-thickness);margin-inline:var(--mantine-spacing-md);background-color:var(--stepper-outline-color)}.m_2a371ac9:where([data-active]){background-color:var(--stepper-color)}.m_78da155d{padding-top:var(--stepper-content-padding)}.m_cbb57068{--step-color: var(--stepper-color);display:flex;cursor:default}.m_cbb57068:where([data-allow-click]){cursor:pointer}.m_cbb57068:where([data-icon-position=left]){flex-direction:row}.m_cbb57068:where([data-icon-position=right]){flex-direction:row-reverse}.m_f56b1e2c{align-items:center}.m_833edb7e{--separator-spacing: calc(var(--mantine-spacing-xs) / 2);justify-content:flex-start;min-height:calc(var(--stepper-icon-size) + var(--mantine-spacing-xl) + var(--separator-spacing));margin-top:var(--separator-spacing);overflow:hidden}.m_833edb7e:where(:first-of-type){margin-top:0}.m_833edb7e:where(:last-of-type){min-height:auto}.m_833edb7e:where(:last-of-type) .m_6496b3f3{display:none}.m_818e70b{position:relative}.m_6496b3f3{top:calc(var(--stepper-icon-size) + var(--separator-spacing));inset-inline-start:calc(var(--stepper-icon-size) / 2);height:100vh;position:absolute;border-inline-start:var(--stepper-outline-thickness) solid var(--stepper-outline-color)}.m_6496b3f3:where([data-active]){border-color:var(--stepper-color)}.m_1959ad01{height:var(--stepper-icon-size);width:var(--stepper-icon-size);min-height:var(--stepper-icon-size);min-width:var(--stepper-icon-size);border-radius:var(--stepper-radius);font-size:var(--stepper-fz);display:flex;align-items:center;justify-content:center;position:relative;font-weight:700;transition:background-color .15s ease,border-color .15s ease;border:var(--stepper-outline-thickness) solid var(--stepper-outline-color);background-color:var(--stepper-outline-color)}:where([data-mantine-color-scheme=light]) .m_1959ad01{color:var(--mantine-color-gray-7)}:where([data-mantine-color-scheme=dark]) .m_1959ad01{color:var(--mantine-color-dark-1)}.m_1959ad01:where([data-progress]){border-color:var(--step-color)}.m_1959ad01:where([data-completed]){color:var(--stepper-icon-color, var(--mantine-color-white));background-color:var(--step-color);border-color:var(--step-color)}.m_a79331dc{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--stepper-icon-color, var(--mantine-color-white))}.m_1956aa2a{display:flex;flex-direction:column}.m_1956aa2a:where([data-icon-position=left]){margin-inline-start:var(--mantine-spacing-sm)}.m_1956aa2a:where([data-icon-position=right]){text-align:right;margin-inline-end:var(--mantine-spacing-sm)}:where([dir=rtl]) .m_1956aa2a:where([data-icon-position=right]){text-align:left}.m_12051f6c{font-weight:500;font-size:var(--stepper-fz);line-height:1}.m_164eea74{margin-top:calc(var(--stepper-spacing) / 3);margin-bottom:calc(var(--stepper-spacing) / 3);font-size:calc(var(--stepper-fz) - calc(.125rem * var(--mantine-scale)));line-height:1;color:var(--mantine-color-dimmed)}.m_5f93f3bb{--switch-height-xs: calc(1rem * var(--mantine-scale));--switch-height-sm: calc(1.25rem * var(--mantine-scale));--switch-height-md: calc(1.5rem * var(--mantine-scale));--switch-height-lg: calc(1.875rem * var(--mantine-scale));--switch-height-xl: calc(2.25rem * var(--mantine-scale));--switch-width-xs: calc(2rem * var(--mantine-scale));--switch-width-sm: calc(2.375rem * var(--mantine-scale));--switch-width-md: calc(2.875rem * var(--mantine-scale));--switch-width-lg: calc(3.5rem * var(--mantine-scale));--switch-width-xl: calc(4.5rem * var(--mantine-scale));--switch-thumb-size-xs: calc(.75rem * var(--mantine-scale));--switch-thumb-size-sm: calc(.875rem * var(--mantine-scale));--switch-thumb-size-md: calc(1.125rem * var(--mantine-scale));--switch-thumb-size-lg: calc(1.375rem * var(--mantine-scale));--switch-thumb-size-xl: calc(1.75rem * var(--mantine-scale));--switch-label-font-size-xs: calc(.3125rem * var(--mantine-scale));--switch-label-font-size-sm: calc(.375rem * var(--mantine-scale));--switch-label-font-size-md: calc(.4375rem * var(--mantine-scale));--switch-label-font-size-lg: calc(.5625rem * var(--mantine-scale));--switch-label-font-size-xl: calc(.6875rem * var(--mantine-scale));--switch-track-label-padding-xs: calc(.125rem * var(--mantine-scale));--switch-track-label-padding-sm: calc(.15625rem * var(--mantine-scale));--switch-track-label-padding-md: calc(.1875rem * var(--mantine-scale));--switch-track-label-padding-lg: calc(.1875rem * var(--mantine-scale));--switch-track-label-padding-xl: calc(.21875rem * var(--mantine-scale));--switch-height: var(--switch-height-sm);--switch-width: var(--switch-width-sm);--switch-thumb-size: var(--switch-thumb-size-sm);--switch-label-font-size: var(--switch-label-font-size-sm);--switch-track-label-padding: var(--switch-track-label-padding-sm);--switch-radius: calc(62.5rem * var(--mantine-scale));--switch-color: var(--mantine-primary-color-filled);--switch-disabled-color: var(--mantine-color-disabled);position:relative}.m_926b4011{height:0;width:0;opacity:0;margin:0;padding:0;position:absolute;overflow:hidden;white-space:nowrap}.m_9307d992{-webkit-tap-highlight-color:transparent;cursor:var(--switch-cursor, var(--mantine-cursor-type));overflow:hidden;position:relative;border-radius:var(--switch-radius);background-color:var(--switch-bg);height:var(--switch-height);min-width:var(--switch-width);margin:0;transition:background-color .15s ease,border-color .15s ease;appearance:none;display:flex;align-items:center;font-size:var(--switch-label-font-size);font-weight:600;order:var(--switch-order, 1);user-select:none;z-index:0;line-height:0;color:var(--switch-text-color)}.m_9307d992:where([data-without-labels]){width:var(--switch-width)}.m_926b4011:focus-visible+.m_9307d992{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_926b4011:checked+.m_9307d992{--switch-bg: var(--switch-color);--switch-text-color: var(--mantine-color-white)}.m_926b4011:disabled+.m_9307d992,.m_926b4011[data-disabled]+.m_9307d992{--switch-bg: var(--switch-disabled-color);--switch-cursor: not-allowed}[data-mantine-color-scheme=light] .m_9307d992{--switch-bg: var(--mantine-color-gray-3);--switch-text-color: var(--mantine-color-gray-6)}[data-mantine-color-scheme=dark] .m_9307d992{--switch-bg: var(--mantine-color-dark-5);--switch-text-color: var(--mantine-color-dark-1)}.m_9307d992[data-label-position=left]{--switch-order: 2}.m_93039a1d{position:absolute;z-index:1;border-radius:var(--switch-radius);display:flex;background-color:var(--switch-thumb-bg, var(--mantine-color-white));height:var(--switch-thumb-size);width:var(--switch-thumb-size);inset-inline-start:var(--switch-thumb-start, var(--switch-track-label-padding));transition:inset-inline-start .15s ease}.m_93039a1d:where([data-with-thumb-indicator]):before{content:"";width:40%;height:40%;background-color:var(--switch-bg);position:absolute;border-radius:var(--switch-radius);top:50%;left:50%;transform:translate(-50%,-50%)}.m_93039a1d>*{margin:auto}.m_926b4011:checked+*>.m_93039a1d{--switch-thumb-start: calc(100% - var(--switch-thumb-size) - var(--switch-track-label-padding))}.m_926b4011:disabled+*>.m_93039a1d,.m_926b4011[data-disabled]+*>.m_93039a1d{--switch-thumb-bg: var(--switch-thumb-bg-disabled)}[data-mantine-color-scheme=light] .m_93039a1d{--switch-thumb-bg-disabled: var(--mantine-color-gray-0)}[data-mantine-color-scheme=dark] .m_93039a1d{--switch-thumb-bg-disabled: var(--mantine-color-dark-3)}.m_8277e082{height:100%;display:grid;place-content:center;min-width:calc(var(--switch-width) - var(--switch-thumb-size));padding-inline:var(--switch-track-label-padding);margin-inline-start:calc(var(--switch-thumb-size) + var(--switch-track-label-padding));transition:margin .15s ease}.m_926b4011:checked+*>.m_8277e082{margin-inline-end:calc(var(--switch-thumb-size) + var(--switch-track-label-padding));margin-inline-start:0}.m_b23fa0ef{width:100%;border-collapse:collapse;border-spacing:0;line-height:var(--mantine-line-height);font-size:var(--mantine-font-size-sm);table-layout:var(--table-layout, auto);caption-side:var(--table-caption-side, bottom);border:none}:where([data-mantine-color-scheme=light]) .m_b23fa0ef{--table-hover-color: var(--mantine-color-gray-1);--table-striped-color: var(--mantine-color-gray-0);--table-border-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_b23fa0ef{--table-hover-color: var(--mantine-color-dark-5);--table-striped-color: var(--mantine-color-dark-6);--table-border-color: var(--mantine-color-dark-4)}.m_b23fa0ef:where([data-with-table-border]){border:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_b23fa0ef:where([data-tabular-nums]){font-variant-numeric:tabular-nums}.m_b23fa0ef:where([data-variant=vertical]) :where(.m_4e7aa4f3){font-weight:500}:where([data-mantine-color-scheme=light]) .m_b23fa0ef:where([data-variant=vertical]) :where(.m_4e7aa4f3){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_b23fa0ef:where([data-variant=vertical]) :where(.m_4e7aa4f3){background-color:var(--mantine-color-dark-6)}.m_4e7aa4f3{text-align:left}:where([dir=rtl]) .m_4e7aa4f3{text-align:right}.m_4e7aa4fd{border-bottom:none;background-color:transparent}@media(hover:hover){.m_4e7aa4fd:hover:where([data-hover]){background-color:var(--tr-hover-bg)}}@media(hover:none){.m_4e7aa4fd:active:where([data-hover]){background-color:var(--tr-hover-bg)}}.m_4e7aa4fd:where([data-with-row-border]){border-bottom:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_4e7aa4ef,.m_4e7aa4f3{padding:var(--table-vertical-spacing) var(--table-horizontal-spacing, var(--mantine-spacing-xs))}.m_4e7aa4ef:where([data-with-column-border]:not(:first-child)),.m_4e7aa4f3:where([data-with-column-border]:not(:first-child)){border-inline-start:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_4e7aa4ef:where([data-with-column-border]:not(:last-child)),.m_4e7aa4f3:where([data-with-column-border]:not(:last-child)){border-inline-end:calc(.0625rem * var(--mantine-scale)) solid var(--table-border-color)}.m_b2404537>:where(tr):where([data-with-row-border]:last-of-type){border-bottom:none}.m_b2404537>:where(tr):where([data-striped=odd]:nth-of-type(odd)){background-color:var(--table-striped-color)}.m_b2404537>:where(tr):where([data-striped=even]:nth-of-type(2n)){background-color:var(--table-striped-color)}.m_b2404537>:where(tr)[data-hover]{--tr-hover-bg: var(--table-highlight-on-hover-color, var(--table-hover-color))}.m_b242d975{top:var(--table-sticky-header-offset, 0);z-index:3}.m_b242d975:where([data-sticky]){position:sticky}.m_b242d975:where([data-sticky]) :where(.m_4e7aa4f3){position:sticky;top:var(--table-sticky-header-offset, 0);background-color:var(--mantine-color-body)}:where([data-with-table-border]) .m_b242d975[data-sticky]{position:sticky;top:var(--table-sticky-header-offset, 0);z-index:4;border-top:none}:where([data-with-table-border]) .m_b242d975[data-sticky]:before{content:"";display:block;position:absolute;left:0;top:calc(-.03125rem * var(--mantine-scale));width:100%;height:calc(.0625rem * var(--mantine-scale));background-color:var(--table-border-color);z-index:5}:where([data-with-table-border]) .m_b242d975[data-sticky] .m_4e7aa4f3:first-child{border-top:none}.m_9e5a3ac7{color:var(--mantine-color-dimmed)}.m_9e5a3ac7:where([data-side=top]){margin-bottom:var(--mantine-spacing-xs)}.m_9e5a3ac7:where([data-side=bottom]){margin-top:var(--mantine-spacing-xs)}.m_a100c15{overflow-x:var(--table-overflow)}.m_62259741{min-width:var(--table-min-width);max-height:var(--table-max-height)}.m_bcaa9990{display:flex;flex-direction:column;--toc-depth-offset: .8em}.m_375a65ef{display:block;padding:.3em .8em;font-size:var(--toc-size, var(--mantine-font-size-md));border-radius:var(--toc-radius, var(--mantine-radius-default));padding-left:max(calc(var(--depth-offset) * var(--toc-depth-offset)),.8em)}@media(hover:hover){:where([data-mantine-color-scheme=light]) .m_375a65ef:where(:hover):where(:not([data-variant=none])){background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_375a65ef:where(:hover):where(:not([data-variant=none])){background-color:var(--mantine-color-dark-5)}}@media(hover:none){:where([data-mantine-color-scheme=light]) .m_375a65ef:where(:active):where(:not([data-variant=none])){background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_375a65ef:where(:active):where(:not([data-variant=none])){background-color:var(--mantine-color-dark-5)}}.m_375a65ef:where([data-active]){background-color:var(--toc-bg);color:var(--toc-color)}[data-mantine-color-scheme=light] .m_89d60db1{--tab-border-color: var(--mantine-color-gray-3)}[data-mantine-color-scheme=dark] .m_89d60db1{--tab-border-color: var(--mantine-color-dark-4)}.m_89d60db1{display:var(--tabs-display);flex-direction:var(--tabs-flex-direction);--tabs-list-direction: row;--tabs-panel-grow: unset;--tabs-display: block;--tabs-flex-direction: row;--tabs-list-border-width: 0;--tabs-list-border-size: 0 0 var(--tabs-list-border-width) 0;--tabs-list-gap: unset;--tabs-list-line-bottom: 0;--tabs-list-line-top: unset;--tabs-list-line-start: 0;--tabs-list-line-end: 0;--tab-radius: var(--tabs-radius) var(--tabs-radius) 0 0;--tab-border-width: 0 0 var(--tabs-list-border-width) 0}.m_89d60db1[data-inverted]{--tabs-list-line-bottom: unset;--tabs-list-line-top: 0;--tab-radius: 0 0 var(--tabs-radius) var(--tabs-radius);--tab-border-width: var(--tabs-list-border-width) 0 0 0}.m_89d60db1[data-inverted] .m_576c9d4:before{top:0;bottom:unset}.m_89d60db1[data-orientation=vertical]{--tabs-list-line-start: unset;--tabs-list-line-end: 0;--tabs-list-line-top: 0;--tabs-list-line-bottom: 0;--tabs-list-border-size: 0 var(--tabs-list-border-width) 0 0;--tab-border-width: 0 var(--tabs-list-border-width) 0 0;--tab-radius: var(--tabs-radius) 0 0 var(--tabs-radius);--tabs-list-direction: column;--tabs-panel-grow: 1;--tabs-display: flex}[dir=rtl] .m_89d60db1[data-orientation=vertical]{--tabs-list-border-size: 0 0 0 var(--tabs-list-border-width);--tab-border-width: 0 0 0 var(--tabs-list-border-width);--tab-radius: 0 var(--tabs-radius) var(--tabs-radius) 0}.m_89d60db1[data-orientation=vertical][data-placement=right]{--tabs-flex-direction: row-reverse;--tabs-list-line-start: 0;--tabs-list-line-end: unset;--tabs-list-border-size: 0 0 0 var(--tabs-list-border-width);--tab-border-width: 0 0 0 var(--tabs-list-border-width);--tab-radius: 0 var(--tabs-radius) var(--tabs-radius) 0}[dir=rtl] .m_89d60db1[data-orientation=vertical][data-placement=right]{--tabs-list-border-size: 0 var(--tabs-list-border-width) 0 0;--tab-border-width: 0 var(--tabs-list-border-width) 0 0;--tab-radius: var(--tabs-radius) 0 0 var(--tabs-radius)}.m_89d60db1[data-variant=default]{--tabs-list-border-width: calc(.125rem * var(--mantine-scale))}[data-mantine-color-scheme=light] .m_89d60db1[data-variant=default]{--tab-hover-color: var(--mantine-color-gray-0)}[data-mantine-color-scheme=dark] .m_89d60db1[data-variant=default]{--tab-hover-color: var(--mantine-color-dark-6)}.m_89d60db1[data-variant=outline]{--tabs-list-border-width: calc(.0625rem * var(--mantine-scale))}.m_89d60db1[data-variant=pills]{--tabs-list-gap: calc(var(--mantine-spacing-sm) / 2)}[data-mantine-color-scheme=light] .m_89d60db1[data-variant=pills]{--tab-hover-color: var(--mantine-color-gray-0)}[data-mantine-color-scheme=dark] .m_89d60db1[data-variant=pills]{--tab-hover-color: var(--mantine-color-dark-6)}.m_89d33d6d{display:flex;flex-wrap:wrap;justify-content:var(--tabs-justify, flex-start);flex-direction:var(--tabs-list-direction);gap:var(--tabs-list-gap)}.m_89d33d6d:where([data-grow]) .m_4ec4dce6{flex:1}.m_b0c91715{flex-grow:var(--tabs-panel-grow)}.m_4ec4dce6{position:relative;padding:var(--mantine-spacing-xs) var(--mantine-spacing-md);font-size:var(--mantine-font-size-sm);white-space:nowrap;z-index:0;display:flex;align-items:center;line-height:1;user-select:none}.m_4ec4dce6:where(:disabled,[data-disabled]){opacity:.5;cursor:not-allowed}.m_4ec4dce6:focus{z-index:1}.m_fc420b1f{display:flex;align-items:center;justify-content:center}.m_fc420b1f:where([data-position=left]:not(:only-child)){margin-inline-end:var(--mantine-spacing-xs)}.m_fc420b1f:where([data-position=right]:not(:only-child)){margin-inline-start:var(--mantine-spacing-xs)}.m_42bbd1ae{flex:1;text-align:center}.m_576c9d4{position:relative}.m_576c9d4:before{content:"";position:absolute;border:1px solid var(--tab-border-color);bottom:var(--tabs-list-line-bottom);inset-inline-start:var(--tabs-list-line-start);inset-inline-end:var(--tabs-list-line-end);top:var(--tabs-list-line-top)}.m_539e827b{border-radius:var(--tab-radius);border-width:var(--tab-border-width);border-style:solid;border-color:transparent;background-color:transparent}.m_539e827b:where([data-active]){border-color:var(--tabs-color)}@media(hover:hover){.m_539e827b:hover{background-color:var(--tab-hover-color)}.m_539e827b:hover:where(:not([data-active])){border-color:var(--tab-border-color)}}@media(hover:none){.m_539e827b:active{background-color:var(--tab-hover-color)}.m_539e827b:active:where(:not([data-active])){border-color:var(--tab-border-color)}}@media(hover:hover){.m_539e827b:disabled:hover,.m_539e827b[data-disabled]:hover{background-color:transparent}}@media(hover:none){.m_539e827b:disabled:active,.m_539e827b[data-disabled]:active{background-color:transparent}}.m_6772fbd5{position:relative}.m_6772fbd5:before{content:"";position:absolute;border-color:var(--tab-border-color);border-width:var(--tabs-list-border-size);border-style:solid;bottom:var(--tabs-list-line-bottom);inset-inline-start:var(--tabs-list-line-start);inset-inline-end:var(--tabs-list-line-end);top:var(--tabs-list-line-top)}.m_b59ab47c{border-top:calc(.0625rem * var(--mantine-scale)) solid transparent;border-bottom:calc(.0625rem * var(--mantine-scale)) solid transparent;border-right:calc(.0625rem * var(--mantine-scale)) solid transparent;border-left:calc(.0625rem * var(--mantine-scale)) solid transparent;border-top-color:var(--tab-border-top-color);border-bottom-color:var(--tab-border-bottom-color);border-radius:var(--tab-radius);position:relative;--tab-border-bottom-color: transparent;--tab-border-top-color: transparent;--tab-border-inline-end-color: transparent;--tab-border-inline-start-color: transparent}.m_b59ab47c:where([data-active]):before{content:"";position:absolute;background-color:var(--tab-border-color);bottom:var(--tab-before-bottom, calc(-.0625rem * var(--mantine-scale)));left:var(--tab-before-left, calc(-.0625rem * var(--mantine-scale)));right:var(--tab-before-right, auto);top:var(--tab-before-top, auto);width:calc(.0625rem * var(--mantine-scale));height:calc(.0625rem * var(--mantine-scale))}.m_b59ab47c:where([data-active]):after{content:"";position:absolute;background-color:var(--tab-border-color);bottom:var(--tab-after-bottom, calc(-.0625rem * var(--mantine-scale)));right:var(--tab-after-right, calc(-.0625rem * var(--mantine-scale)));left:var(--tab-after-left, auto);top:var(--tab-after-top, auto);width:calc(.0625rem * var(--mantine-scale));height:calc(.0625rem * var(--mantine-scale))}.m_b59ab47c:where([data-active]){border-top-color:var(--tab-border-top-color);border-bottom-color:var(--tab-border-bottom-color);border-inline-start-color:var(--tab-border-inline-start-color);border-inline-end-color:var(--tab-border-inline-end-color);--tab-border-top-color: var(--tab-border-color);--tab-border-inline-start-color: var(--tab-border-color);--tab-border-inline-end-color: var(--tab-border-color);--tab-border-bottom-color: var(--mantine-color-body)}.m_b59ab47c:where([data-active])[data-inverted]{--tab-border-bottom-color: var(--tab-border-color);--tab-border-top-color: var(--mantine-color-body);--tab-before-bottom: auto;--tab-before-top: calc(-.0625rem * var(--mantine-scale));--tab-after-bottom: auto;--tab-after-top: calc(-.0625rem * var(--mantine-scale))}.m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=left]{--tab-border-inline-end-color: var(--mantine-color-body);--tab-border-inline-start-color: var(--tab-border-color);--tab-border-bottom-color: var(--tab-border-color);--tab-before-right: calc(-.0625rem * var(--mantine-scale));--tab-before-left: auto;--tab-before-bottom: auto;--tab-before-top: calc(-.0625rem * var(--mantine-scale));--tab-after-left: auto;--tab-after-right: calc(-.0625rem * var(--mantine-scale))}[dir=rtl] .m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=left]{--tab-before-right: auto;--tab-before-left: calc(-.0625rem * var(--mantine-scale));--tab-after-left: calc(-.0625rem * var(--mantine-scale));--tab-after-right: auto}.m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=right]{--tab-border-inline-start-color: var(--mantine-color-body);--tab-border-inline-end-color: var(--tab-border-color);--tab-border-bottom-color: var(--tab-border-color);--tab-before-left: calc(-.0625rem * var(--mantine-scale));--tab-before-right: auto;--tab-before-bottom: auto;--tab-before-top: calc(-.0625rem * var(--mantine-scale));--tab-after-right: auto;--tab-after-left: calc(-.0625rem * var(--mantine-scale))}[dir=rtl] .m_b59ab47c:where([data-active])[data-orientation=vertical][data-placement=right]{--tab-before-left: auto;--tab-before-right: calc(-.0625rem * var(--mantine-scale));--tab-after-right: calc(-.0625rem * var(--mantine-scale));--tab-after-left: auto}.m_c3381914{border-radius:var(--tabs-radius);background-color:var(--tab-bg);color:var(--tab-color);--tab-bg: transparent;--tab-color: inherit}@media(hover:hover){.m_c3381914:not([data-disabled]):hover{--tab-bg: var(--tab-hover-color)}}@media(hover:none){.m_c3381914:not([data-disabled]):active{--tab-bg: var(--tab-hover-color)}}.m_c3381914[data-active][data-active]{--tab-bg: var(--tabs-color);--tab-color: var(--tabs-text-color, var(--mantine-color-white))}@media(hover:hover){.m_c3381914[data-active][data-active]:hover{--tab-bg: var(--tabs-color)}}@media(hover:none){.m_c3381914[data-active][data-active]:active{--tab-bg: var(--tabs-color)}}.m_7341320d{--ti-size-xs: calc(1.125rem * var(--mantine-scale));--ti-size-sm: calc(1.375rem * var(--mantine-scale));--ti-size-md: calc(1.75rem * var(--mantine-scale));--ti-size-lg: calc(2.125rem * var(--mantine-scale));--ti-size-xl: calc(2.75rem * var(--mantine-scale));--ti-size: var(--ti-size-md);line-height:1;display:inline-flex;align-items:center;justify-content:center;position:relative;user-select:none;width:var(--ti-size);height:var(--ti-size);min-width:var(--ti-size);min-height:var(--ti-size);border-radius:var(--ti-radius, var(--mantine-radius-default));background:var(--ti-bg, var(--mantine-primary-color-filled));color:var(--ti-color, var(--mantine-color-white));border:var(--ti-bd, 1px solid transparent)}.m_43657ece{--offset: calc(var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2);--tl-bullet-size: calc(1.25rem * var(--mantine-scale));--tl-line-width: calc(.25rem * var(--mantine-scale));--tl-radius: calc(62.5rem * var(--mantine-scale));--tl-color: var(--mantine-primary-color-filled)}.m_43657ece:where([data-align=left]){padding-inline-start:var(--offset)}.m_43657ece:where([data-align=right]){padding-inline-end:var(--offset)}.m_2ebe8099{font-weight:500;line-height:1;margin-bottom:calc(var(--mantine-spacing-xs) / 2)}.m_436178ff{--item-border: var(--tl-line-width) var(--tli-border-style, solid) var(--item-border-color);position:relative;color:var(--mantine-color-text)}.m_436178ff:before{content:"";pointer-events:none;position:absolute;top:0;left:var(--timeline-line-left, 0);right:var(--timeline-line-right, 0);bottom:calc(var(--mantine-spacing-xl) * -1);border-inline-start:var(--item-border);display:var(--timeline-line-display, none)}.m_43657ece[data-align=left] .m_436178ff:before{--timeline-line-left: calc(var(--tl-line-width) * -1);--timeline-line-right: auto}[dir=rtl] .m_43657ece[data-align=left] .m_436178ff:before{--timeline-line-left: auto;--timeline-line-right: calc(var(--tl-line-width) * -1)}.m_43657ece[data-align=right] .m_436178ff:before{--timeline-line-left: auto;--timeline-line-right: calc(var(--tl-line-width) * -1)}[dir=rtl] .m_43657ece[data-align=right] .m_436178ff:before{--timeline-line-left: calc(var(--tl-line-width) * -1);--timeline-line-right: auto}.m_43657ece:where([data-align=left]) .m_436178ff{padding-inline-start:var(--offset);text-align:left}.m_43657ece:where([data-align=right]) .m_436178ff{padding-inline-end:var(--offset);text-align:right}:where([data-mantine-color-scheme=light]) .m_436178ff{--item-border-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_436178ff{--item-border-color: var(--mantine-color-dark-4)}.m_436178ff:where([data-line-active]):before{border-color:var(--tli-color, var(--tl-color))}.m_436178ff:where(:not(:last-of-type)){--timeline-line-display: block}.m_436178ff:where(:not(:first-of-type)){margin-top:var(--mantine-spacing-xl)}.m_8affcee1{width:var(--tl-bullet-size);height:var(--tl-bullet-size);border-radius:var(--tli-radius, var(--tl-radius));border:var(--tl-line-width) solid;background-color:var(--mantine-color-body);position:absolute;top:0;display:flex;align-items:center;justify-content:center;color:var(--mantine-color-text)}:where([data-mantine-color-scheme=light]) .m_8affcee1{border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_8affcee1{border-color:var(--mantine-color-dark-4)}.m_43657ece:where([data-align=left]) .m_8affcee1{left:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);right:auto}:where([dir=rtl]) .m_43657ece:where([data-align=left]) .m_8affcee1{left:auto;right:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1)}.m_43657ece:where([data-align=right]) .m_8affcee1{left:auto;right:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1)}:where([dir=rtl]) .m_43657ece:where([data-align=right]) .m_8affcee1{left:calc((var(--tl-bullet-size) / 2 + var(--tl-line-width) / 2) * -1);right:auto}.m_8affcee1:where([data-with-child]){border-width:var(--tl-line-width)}:where([data-mantine-color-scheme=light]) .m_8affcee1:where([data-with-child]){background-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_8affcee1:where([data-with-child]){background-color:var(--mantine-color-dark-4)}.m_8affcee1:where([data-active]){border-color:var(--tli-color, var(--tl-color));background-color:var(--mantine-color-white);color:var(--tl-icon-color, var(--mantine-color-white))}.m_8affcee1:where([data-active]):where([data-with-child]){background-color:var(--tli-color, var(--tl-color));color:var(--tl-icon-color, var(--mantine-color-white))}.m_43657ece:where([data-align=left]) .m_540e8f41{padding-inline-start:var(--offset);text-align:left}:where([dir=rtl]) .m_43657ece:where([data-align=left]) .m_540e8f41{text-align:right}.m_43657ece:where([data-align=right]) .m_540e8f41{padding-inline-end:var(--offset);text-align:right}:where([dir=rtl]) .m_43657ece:where([data-align=right]) .m_540e8f41{text-align:left}.m_8a5d1357{margin:0;font-weight:var(--title-fw);font-size:var(--title-fz);line-height:var(--title-lh);font-family:var(--mantine-font-family-headings);text-wrap:var(--title-text-wrap, var(--mantine-heading-text-wrap))}.m_8a5d1357:where([data-line-clamp]){overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:var(--title-line-clamp);-webkit-box-orient:vertical}.m_f698e191{--level-offset: var(--mantine-spacing-lg);margin:0;padding:0;user-select:none}.m_75f3ecf{margin:0;padding:0}.m_f6970eb1{cursor:pointer;list-style:none;margin:0;padding:0;outline:0}.m_f6970eb1:focus-visible>.m_dc283425{outline:2px solid var(--mantine-primary-color-filled);outline-offset:calc(.125rem * var(--mantine-scale))}.m_dc283425{padding-inline-start:var(--label-offset)}:where([data-mantine-color-scheme=light]) .m_dc283425:where([data-selected]){background-color:var(--mantine-color-gray-1)}:where([data-mantine-color-scheme=dark]) .m_dc283425:where([data-selected]){background-color:var(--mantine-color-dark-5)}.m_d08caa0 :first-child{margin-top:0}.m_d08caa0 :last-child{margin-bottom:0}.m_d08caa0 :where(h1,h2,h3,h4,h5,h6){margin-bottom:var(--mantine-spacing-xs);text-wrap:var(--mantine-heading-text-wrap);font-family:var(--mantine-font-family-headings)}.m_d08caa0 :where(h1){margin-top:calc(1.5 * var(--mantine-spacing-xl));font-size:var(--mantine-h1-font-size);line-height:var(--mantine-h1-line-height);font-weight:var(--mantine-h1-font-weight)}.m_d08caa0 :where(h2){margin-top:var(--mantine-spacing-xl);font-size:var(--mantine-h2-font-size);line-height:var(--mantine-h2-line-height);font-weight:var(--mantine-h2-font-weight)}.m_d08caa0 :where(h3){margin-top:calc(.8 * var(--mantine-spacing-xl));font-size:var(--mantine-h3-font-size);line-height:var(--mantine-h3-line-height);font-weight:var(--mantine-h3-font-weight)}.m_d08caa0 :where(h4){margin-top:calc(.8 * var(--mantine-spacing-xl));font-size:var(--mantine-h4-font-size);line-height:var(--mantine-h4-line-height);font-weight:var(--mantine-h4-font-weight)}.m_d08caa0 :where(h5){margin-top:calc(.5 * var(--mantine-spacing-xl));font-size:var(--mantine-h5-font-size);line-height:var(--mantine-h5-line-height);font-weight:var(--mantine-h5-font-weight)}.m_d08caa0 :where(h6){margin-top:calc(.5 * var(--mantine-spacing-xl));font-size:var(--mantine-h6-font-size);line-height:var(--mantine-h6-line-height);font-weight:var(--mantine-h6-font-weight)}.m_d08caa0 :where(img){max-width:100%;margin-bottom:var(--mantine-spacing-xs)}.m_d08caa0 :where(p){margin-top:0;margin-bottom:var(--mantine-spacing-lg)}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(mark){background-color:var(--mantine-color-yellow-2);color:inherit}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(mark){background-color:var(--mantine-color-yellow-5);color:var(--mantine-color-black)}.m_d08caa0 :where(a){color:var(--mantine-color-anchor);text-decoration:none}@media(hover:hover){.m_d08caa0 :where(a):hover{text-decoration:underline}}@media(hover:none){.m_d08caa0 :where(a):active{text-decoration:underline}}.m_d08caa0 :where(hr){margin-top:var(--mantine-spacing-md);margin-bottom:var(--mantine-spacing-md);border:0;border-top:calc(.0625rem * var(--mantine-scale)) solid}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(hr){border-color:var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(hr){border-color:var(--mantine-color-dark-3)}.m_d08caa0 :where(pre){padding:var(--mantine-spacing-xs);line-height:var(--mantine-line-height);margin:0;margin-top:var(--mantine-spacing-md);margin-bottom:var(--mantine-spacing-md);overflow-x:auto;font-family:var(--mantine-font-family-monospace);font-size:var(--mantine-font-size-xs);border-radius:var(--mantine-radius-sm)}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(pre){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(pre){background-color:var(--mantine-color-dark-8)}.m_d08caa0 :where(pre) :where(code){background-color:transparent;padding:0;border-radius:0;color:inherit;border:0}.m_d08caa0 :where(kbd){--kbd-fz: calc(.75rem * var(--mantine-scale));--kbd-padding: calc(.1875rem * var(--mantine-scale)) calc(.3125rem * var(--mantine-scale));font-family:var(--mantine-font-family-monospace);line-height:var(--mantine-line-height);font-weight:700;padding:var(--kbd-padding);font-size:var(--kbd-fz);border-radius:var(--mantine-radius-sm);border:calc(.0625rem * var(--mantine-scale)) solid;border-bottom-width:calc(.1875rem * var(--mantine-scale))}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(kbd){border-color:var(--mantine-color-gray-3);color:var(--mantine-color-gray-7);background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(kbd){border-color:var(--mantine-color-dark-3);color:var(--mantine-color-dark-0);background-color:var(--mantine-color-dark-5)}.m_d08caa0 :where(code){line-height:var(--mantine-line-height);padding:calc(.0625rem * var(--mantine-scale)) calc(.3125rem * var(--mantine-scale));border-radius:var(--mantine-radius-sm);font-family:var(--mantine-font-family-monospace);font-size:var(--mantine-font-size-xs)}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(code){background-color:var(--mantine-color-gray-0);color:var(--mantine-color-black)}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(code){background-color:var(--mantine-color-dark-5);color:var(--mantine-color-white)}.m_d08caa0 :where(ul,ol):not([data-type=taskList]){margin-bottom:var(--mantine-spacing-md);padding-inline-start:var(--mantine-spacing-xl);list-style-position:outside}.m_d08caa0 :where(table){width:100%;border-collapse:collapse;caption-side:bottom;margin-bottom:var(--mantine-spacing-md)}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(table){--table-border-color: var(--mantine-color-gray-3)}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(table){--table-border-color: var(--mantine-color-dark-4)}.m_d08caa0 :where(table) :where(caption){margin-top:var(--mantine-spacing-xs);font-size:var(--mantine-font-size-sm);color:var(--mantine-color-dimmed)}.m_d08caa0 :where(table) :where(th){text-align:left;font-weight:700;font-size:var(--mantine-font-size-sm);padding:var(--mantine-spacing-xs) var(--mantine-spacing-sm)}.m_d08caa0 :where(table) :where(thead th){border-bottom:calc(.0625rem * var(--mantine-scale)) solid;border-color:var(--table-border-color)}.m_d08caa0 :where(table) :where(tfoot th){border-top:calc(.0625rem * var(--mantine-scale)) solid;border-color:var(--table-border-color)}.m_d08caa0 :where(table) :where(td){padding:var(--mantine-spacing-xs) var(--mantine-spacing-sm);border-bottom:calc(.0625rem * var(--mantine-scale)) solid;border-color:var(--table-border-color);font-size:var(--mantine-font-size-sm)}.m_d08caa0 :where(table) :where(tr:last-of-type td){border-bottom:0}.m_d08caa0 :where(blockquote){font-size:var(--mantine-font-size-lg);line-height:var(--mantine-line-height);margin:var(--mantine-spacing-md) 0;border-radius:var(--mantine-radius-sm);padding:var(--mantine-spacing-md) var(--mantine-spacing-lg)}:where([data-mantine-color-scheme=light]) .m_d08caa0 :where(blockquote){background-color:var(--mantine-color-gray-0)}:where([data-mantine-color-scheme=dark]) .m_d08caa0 :where(blockquote){background-color:var(--mantine-color-dark-8)}}@layer xyflow{.react-flow{direction:ltr;--xy-edge-stroke-default: #b1b1b7;--xy-edge-stroke-width-default: 1;--xy-edge-stroke-selected-default: #555;--xy-connectionline-stroke-default: #b1b1b7;--xy-connectionline-stroke-width-default: 1;--xy-attribution-background-color-default: rgba(255, 255, 255, .5);--xy-minimap-background-color-default: #fff;--xy-minimap-mask-background-color-default: rgba(240, 240, 240, .6);--xy-minimap-mask-stroke-color-default: transparent;--xy-minimap-mask-stroke-width-default: 1;--xy-minimap-node-background-color-default: #e2e2e2;--xy-minimap-node-stroke-color-default: transparent;--xy-minimap-node-stroke-width-default: 2;--xy-background-color-default: transparent;--xy-background-pattern-dots-color-default: #91919a;--xy-background-pattern-lines-color-default: #eee;--xy-background-pattern-cross-color-default: #e2e2e2;background-color:var(--xy-background-color, var(--xy-background-color-default));--xy-node-color-default: inherit;--xy-node-border-default: 1px solid #1a192b;--xy-node-background-color-default: #fff;--xy-node-group-background-color-default: rgba(240, 240, 240, .25);--xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(0, 0, 0, .08);--xy-node-boxshadow-selected-default: 0 0 0 .5px #1a192b;--xy-node-border-radius-default: 3px;--xy-handle-background-color-default: #1a192b;--xy-handle-border-color-default: #fff;--xy-selection-background-color-default: rgba(0, 89, 220, .08);--xy-selection-border-default: 1px dotted rgba(0, 89, 220, .8);--xy-controls-button-background-color-default: #fefefe;--xy-controls-button-background-color-hover-default: #f4f4f4;--xy-controls-button-color-default: inherit;--xy-controls-button-color-hover-default: inherit;--xy-controls-button-border-color-default: #eee;--xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, .08);--xy-edge-label-background-color-default: #ffffff;--xy-edge-label-color-default: inherit;--xy-resize-background-color-default: #3367d9}.react-flow.dark{--xy-edge-stroke-default: #3e3e3e;--xy-edge-stroke-width-default: 1;--xy-edge-stroke-selected-default: #727272;--xy-connectionline-stroke-default: #b1b1b7;--xy-connectionline-stroke-width-default: 1;--xy-attribution-background-color-default: rgba(150, 150, 150, .25);--xy-minimap-background-color-default: #141414;--xy-minimap-mask-background-color-default: rgba(60, 60, 60, .6);--xy-minimap-mask-stroke-color-default: transparent;--xy-minimap-mask-stroke-width-default: 1;--xy-minimap-node-background-color-default: #2b2b2b;--xy-minimap-node-stroke-color-default: transparent;--xy-minimap-node-stroke-width-default: 2;--xy-background-color-default: #141414;--xy-background-pattern-dots-color-default: #777;--xy-background-pattern-lines-color-default: #777;--xy-background-pattern-cross-color-default: #777;--xy-node-color-default: #f8f8f8;--xy-node-border-default: 1px solid #3c3c3c;--xy-node-background-color-default: #1e1e1e;--xy-node-group-background-color-default: rgba(240, 240, 240, .25);--xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(255, 255, 255, .08);--xy-node-boxshadow-selected-default: 0 0 0 .5px #999;--xy-handle-background-color-default: #bebebe;--xy-handle-border-color-default: #1e1e1e;--xy-selection-background-color-default: rgba(200, 200, 220, .08);--xy-selection-border-default: 1px dotted rgba(200, 200, 220, .8);--xy-controls-button-background-color-default: #2b2b2b;--xy-controls-button-background-color-hover-default: #3e3e3e;--xy-controls-button-color-default: #f8f8f8;--xy-controls-button-color-hover-default: #fff;--xy-controls-button-border-color-default: #5b5b5b;--xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, .08);--xy-edge-label-background-color-default: #141414;--xy-edge-label-color-default: #f8f8f8}.react-flow__background{background-color:var(--xy-background-color-props, var(--xy-background-color, var(--xy-background-color-default)));pointer-events:none;z-index:-1}.react-flow__container{position:absolute;width:100%;height:100%;top:0;left:0}.react-flow__pane{z-index:1}.react-flow__pane.draggable{cursor:grab}.react-flow__pane.dragging{cursor:grabbing}.react-flow__pane.selection{cursor:pointer}.react-flow__viewport{transform-origin:0 0;z-index:2;pointer-events:none}.react-flow__renderer{z-index:4}.react-flow__selection{z-index:6}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible{outline:none}.react-flow__edge-path{stroke:var(--xy-edge-stroke, var(--xy-edge-stroke-default));stroke-width:var(--xy-edge-stroke-width, var(--xy-edge-stroke-width-default));fill:none}.react-flow__connection-path{stroke:var(--xy-connectionline-stroke, var(--xy-connectionline-stroke-default));stroke-width:var(--xy-connectionline-stroke-width, var(--xy-connectionline-stroke-width-default));fill:none}.react-flow .react-flow__edges{position:absolute}.react-flow .react-flow__edges svg{overflow:visible;position:absolute;pointer-events:none}.react-flow__edge{pointer-events:visibleStroke}.react-flow__edge.selectable{cursor:pointer}.react-flow__edge.animated path{stroke-dasharray:5;animation:dashdraw .5s linear infinite}.react-flow__edge.animated path.react-flow__edge-interaction{stroke-dasharray:none;animation:none}.react-flow__edge.inactive{pointer-events:none}.react-flow__edge.selected,.react-flow__edge:focus,.react-flow__edge:focus-visible{outline:none}.react-flow__edge.selected .react-flow__edge-path,.react-flow__edge.selectable:focus .react-flow__edge-path,.react-flow__edge.selectable:focus-visible .react-flow__edge-path{stroke:var(--xy-edge-stroke-selected, var(--xy-edge-stroke-selected-default))}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge .react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__arrowhead polyline{stroke:var(--xy-edge-stroke, var(--xy-edge-stroke-default))}.react-flow__arrowhead polyline.arrowclosed{fill:var(--xy-edge-stroke, var(--xy-edge-stroke-default))}.react-flow__connection{pointer-events:none}.react-flow__connection .animated{stroke-dasharray:5;animation:dashdraw .5s linear infinite}svg.react-flow__connectionline{z-index:1001;overflow:visible;position:absolute}.react-flow__nodes{pointer-events:none;transform-origin:0 0}.react-flow__node{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;pointer-events:all;transform-origin:0 0;box-sizing:border-box;cursor:default}.react-flow__node.selectable{cursor:pointer}.react-flow__node.draggable{cursor:grab;pointer-events:all}.react-flow__node.draggable.dragging{cursor:grabbing}.react-flow__nodesselection{z-index:3;transform-origin:left top;pointer-events:none}.react-flow__nodesselection-rect{position:absolute;pointer-events:all;cursor:grab}.react-flow__handle{position:absolute;pointer-events:none;min-width:5px;min-height:5px;width:6px;height:6px;background-color:var(--xy-handle-background-color, var(--xy-handle-background-color-default));border:1px solid var(--xy-handle-border-color, var(--xy-handle-border-color-default));border-radius:100%}.react-flow__handle.connectingfrom{pointer-events:all}.react-flow__handle.connectionindicator{pointer-events:all;cursor:crosshair}.react-flow__handle-bottom{top:auto;left:50%;bottom:0;transform:translate(-50%,50%)}.react-flow__handle-top{top:0;left:50%;transform:translate(-50%,-50%)}.react-flow__handle-left{top:50%;left:0;transform:translate(-50%,-50%)}.react-flow__handle-right{top:50%;right:0;transform:translate(50%,-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__pane.selection .react-flow__panel{pointer-events:none}.react-flow__panel{position:absolute;z-index:5;margin:15px}.react-flow__panel.top{top:0}.react-flow__panel.bottom{bottom:0}.react-flow__panel.top.center,.react-flow__panel.bottom.center{left:50%;transform:translate(-15px) translate(-50%)}.react-flow__panel.left{left:0}.react-flow__panel.right{right:0}.react-flow__panel.left.center,.react-flow__panel.right.center{top:50%;transform:translateY(-15px) translateY(-50%)}.react-flow__attribution{font-size:10px;background:var(--xy-attribution-background-color, var(--xy-attribution-background-color-default));padding:2px 3px;margin:0}.react-flow__attribution a{text-decoration:none;color:#999}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edgelabel-renderer{position:absolute;width:100%;height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;left:0;top:0}.react-flow__viewport-portal{position:absolute;width:100%;height:100%;left:0;top:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__minimap{background:var( --xy-minimap-background-color-props, var(--xy-minimap-background-color, var(--xy-minimap-background-color-default)) )}.react-flow__minimap-svg{display:block}.react-flow__minimap-mask{fill:var( --xy-minimap-mask-background-color-props, var(--xy-minimap-mask-background-color, var(--xy-minimap-mask-background-color-default)) );stroke:var( --xy-minimap-mask-stroke-color-props, var(--xy-minimap-mask-stroke-color, var(--xy-minimap-mask-stroke-color-default)) );stroke-width:var( --xy-minimap-mask-stroke-width-props, var(--xy-minimap-mask-stroke-width, var(--xy-minimap-mask-stroke-width-default)) )}.react-flow__minimap-node{fill:var( --xy-minimap-node-background-color-props, var(--xy-minimap-node-background-color, var(--xy-minimap-node-background-color-default)) );stroke:var( --xy-minimap-node-stroke-color-props, var(--xy-minimap-node-stroke-color, var(--xy-minimap-node-stroke-color-default)) );stroke-width:var( --xy-minimap-node-stroke-width-props, var(--xy-minimap-node-stroke-width, var(--xy-minimap-node-stroke-width-default)) )}.react-flow__background-pattern.dots{fill:var( --xy-background-pattern-color-props, var(--xy-background-pattern-color, var(--xy-background-pattern-dots-color-default)) )}.react-flow__background-pattern.lines{stroke:var( --xy-background-pattern-color-props, var(--xy-background-pattern-color, var(--xy-background-pattern-lines-color-default)) )}.react-flow__background-pattern.cross{stroke:var( --xy-background-pattern-color-props, var(--xy-background-pattern-color, var(--xy-background-pattern-cross-color-default)) )}.react-flow__controls{display:flex;flex-direction:column;box-shadow:var(--xy-controls-box-shadow, var(--xy-controls-box-shadow-default))}.react-flow__controls.horizontal{flex-direction:row}.react-flow__controls-button{display:flex;justify-content:center;align-items:center;height:26px;width:26px;padding:4px;border:none;background:var(--xy-controls-button-background-color, var(--xy-controls-button-background-color-default));border-bottom:1px solid var( --xy-controls-button-border-color-props, var(--xy-controls-button-border-color, var(--xy-controls-button-border-color-default)) );color:var( --xy-controls-button-color-props, var(--xy-controls-button-color, var(--xy-controls-button-color-default)) );cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__controls-button svg{width:100%;max-width:12px;max-height:12px;fill:currentColor}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-text{font-size:10px}.react-flow__node.selectable:focus,.react-flow__node.selectable:focus-visible{outline:none}.react-flow__node-input,.react-flow__node-default,.react-flow__node-output,.react-flow__node-group{padding:10px;border-radius:var(--xy-node-border-radius, var(--xy-node-border-radius-default));width:150px;font-size:12px;color:var(--xy-node-color, var(--xy-node-color-default));text-align:center;border:var(--xy-node-border, var(--xy-node-border-default));background-color:var(--xy-node-background-color, var(--xy-node-background-color-default))}.react-flow__node-input.selectable:hover,.react-flow__node-default.selectable:hover,.react-flow__node-output.selectable:hover,.react-flow__node-group.selectable:hover{box-shadow:var(--xy-node-boxshadow-hover, var(--xy-node-boxshadow-hover-default))}.react-flow__node-input.selectable.selected,.react-flow__node-input.selectable:focus,.react-flow__node-input.selectable:focus-visible,.react-flow__node-default.selectable.selected,.react-flow__node-default.selectable:focus,.react-flow__node-default.selectable:focus-visible,.react-flow__node-output.selectable.selected,.react-flow__node-output.selectable:focus,.react-flow__node-output.selectable:focus-visible,.react-flow__node-group.selectable.selected,.react-flow__node-group.selectable:focus,.react-flow__node-group.selectable:focus-visible{box-shadow:var(--xy-node-boxshadow-selected, var(--xy-node-boxshadow-selected-default))}.react-flow__node-group{background-color:var(--xy-node-group-background-color, var(--xy-node-group-background-color-default))}.react-flow__nodesselection-rect,.react-flow__selection{background:var(--xy-selection-background-color, var(--xy-selection-background-color-default));border:var(--xy-selection-border, var(--xy-selection-border-default))}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible,.react-flow__selection:focus,.react-flow__selection:focus-visible{outline:none}.react-flow__controls-button:hover{background:var( --xy-controls-button-background-color-hover-props, var(--xy-controls-button-background-color-hover, var(--xy-controls-button-background-color-hover-default)) );color:var( --xy-controls-button-color-hover-props, var(--xy-controls-button-color-hover, var(--xy-controls-button-color-hover-default)) )}.react-flow__controls-button:disabled{pointer-events:none}.react-flow__controls-button:disabled svg{fill-opacity:.4}.react-flow__controls-button:last-child{border-bottom:none}.react-flow__controls.horizontal .react-flow__controls-button{border-bottom:none;border-right:1px solid var( --xy-controls-button-border-color-props, var(--xy-controls-button-border-color, var(--xy-controls-button-border-color-default)) )}.react-flow__controls.horizontal .react-flow__controls-button:last-child{border-right:none}.react-flow__resize-control{position:absolute}.react-flow__resize-control.left,.react-flow__resize-control.right{cursor:ew-resize}.react-flow__resize-control.top,.react-flow__resize-control.bottom{cursor:ns-resize}.react-flow__resize-control.top.left,.react-flow__resize-control.bottom.right{cursor:nwse-resize}.react-flow__resize-control.bottom.left,.react-flow__resize-control.top.right{cursor:nesw-resize}.react-flow__resize-control.handle{width:5px;height:5px;border:1px solid #fff;border-radius:1px;background-color:var(--xy-resize-background-color, var(--xy-resize-background-color-default));translate:-50% -50%}.react-flow__resize-control.handle.left{left:0;top:50%}.react-flow__resize-control.handle.right{left:100%;top:50%}.react-flow__resize-control.handle.top{left:50%;top:0}.react-flow__resize-control.handle.bottom{left:50%;top:100%}.react-flow__resize-control.handle.top.left,.react-flow__resize-control.handle.bottom.left{left:0}.react-flow__resize-control.handle.top.right,.react-flow__resize-control.handle.bottom.right{left:100%}.react-flow__resize-control.line{border-color:var(--xy-resize-background-color, var(--xy-resize-background-color-default));border-width:0;border-style:solid}.react-flow__resize-control.line.left,.react-flow__resize-control.line.right{width:1px;transform:translate(-50%);top:0;height:100%}.react-flow__resize-control.line.left{left:0;border-left-width:1px}.react-flow__resize-control.line.right{left:100%;border-right-width:1px}.react-flow__resize-control.line.top,.react-flow__resize-control.line.bottom{height:1px;transform:translateY(-50%);left:0;width:100%}.react-flow__resize-control.line.top{top:0;border-top-width:1px}.react-flow__resize-control.line.bottom{border-bottom-width:1px;top:100%}.react-flow__edge-textbg{fill:var(--xy-edge-label-background-color, var(--xy-edge-label-background-color-default))}.react-flow__edge-text{fill:var(--xy-edge-label-color, var(--xy-edge-label-color-default))}}@layer base{:root{--made-with-panda: ""}*,:before,:after,::backdrop{--blur: ;--brightness: ;--contrast: ;--grayscale: ;--hue-rotate: ;--invert: ;--saturate: ;--sepia: ;--drop-shadow: ;--backdrop-blur: ;--backdrop-brightness: ;--backdrop-contrast: ;--backdrop-grayscale: ;--backdrop-hue-rotate: ;--backdrop-invert: ;--backdrop-opacity: ;--backdrop-saturate: ;--backdrop-sepia: ;--gradient-from-position: ;--gradient-to-position: ;--gradient-via-position: ;--scroll-snap-strictness: proximity;--border-spacing-x: 0;--border-spacing-y: 0;--translate-x: 0;--translate-y: 0;--rotate: 0;--rotate-x: 0;--rotate-y: 0;--skew-x: 0;--skew-y: 0;--scale-x: 1;--scale-y: 1}:where(:root,:host){--likec4-app-font-default: "IBM Plex Sans",'ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'}:where([data-likec4-text-size=xs]){--likec4-text-size: var(--font-sizes-likec4-xs)}:where([data-likec4-text-size=sm]){--likec4-text-size: var(--font-sizes-likec4-sm)}:where([data-likec4-text-size=md]){--likec4-text-size: var(--font-sizes-likec4-md)}:where([data-likec4-text-size=lg]){--likec4-text-size: var(--font-sizes-likec4-lg)}:where([data-likec4-text-size=xl]){--likec4-text-size: var(--font-sizes-likec4-xl)}:where([data-likec4-spacing=xs]){--likec4-spacing: var(--spacing-likec4-xs)}:where([data-likec4-spacing=sm]){--likec4-spacing: var(--spacing-likec4-sm)}:where([data-likec4-spacing=md]){--likec4-spacing: var(--spacing-likec4-md)}:where([data-likec4-spacing=lg]){--likec4-spacing: var(--spacing-likec4-lg)}:where([data-likec4-spacing=xl]){--likec4-spacing: var(--spacing-likec4-xl)}.likec4-shadow-root{--mantine-font-family: var(--likec4-app-font, var(--likec4-app-font-default));--mantine-font-family-headings: var(--likec4-app-font, var(--likec4-app-font-default));display:contents}.likec4-shadow-root dialog{color:var(--mantine-color-text)}.likec4-edge-label-container{position:absolute;top:var(--spacing-0);left:var(--spacing-0);width:auto;height:auto}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-edge-label-container{display:none}:where([data-likec4-zoom-small=true]) .likec4-edge-label-container{display:none}.likec4-root{padding:var(--spacing-0);margin:var(--spacing-0);border:0px solid transparent;background:var(--colors-transparent);overflow:hidden;position:relative;container-name:likec4-root;container-type:size;width:var(--sizes-100\\%);height:var(--sizes-100\\%)}.likec4-root .react-flow{--xy-background-color: var(--colors-likec4-background);--xy-background-pattern-color: var(--colors-likec4-background-pattern, var(--colors-likec4-background))}.likec4-root .react-flow:is(.bg-transparent){--xy-background-color: transparent !important;background:var(--colors-transparent)!important}.likec4-root .react-flow:is(.not-initialized){opacity:0}.likec4-root .react-flow .react-flow__pane{-webkit-user-select:none;user-select:none}.likec4-root .react-flow :where(.react-flow__nodes,.react-flow__edges,.react-flow__edgelabel-renderer){display:contents}.likec4-root .react-flow .react-flow__node.draggable:has(.likec4-compound-node){cursor:default}.likec4-root .react-flow .likec4-node-handle-center{visibility:hidden!important;transform:translate(-50%,-50%)!important;top:50%!important;left:50%!important;right:unset!important;bottom:unset!important;width:5px!important;height:5px!important}.likec4-root :where(.react-flow__edge,.likec4-edge-container,.likec4-edge-label-container){--xy-edge-stroke-width: 3;--xy-edge-stroke: var(--likec4-palette-relation-stroke);--xy-edge-stroke-selected: var(--likec4-palette-relation-stroke-selected);--xy-edge-label-color: var(--likec4-palette-relation-label);--xy-edge-label-background-color: var(--likec4-palette-relation-label-bg)}[data-mantine-color-scheme=dark] .likec4-root :where(.react-flow__edge,.likec4-edge-container,.likec4-edge-label-container){--xy-edge-label-background-color: color-mix(in oklab, var(--likec4-palette-relation-label-bg) 50%, transparent)}[data-mantine-color-scheme=light] .likec4-root :where(.react-flow__edge,.likec4-edge-container,.likec4-edge-label-container){--xy-edge-label-color: color-mix(in oklab, var(--likec4-palette-relation-label), #FFF 50%);--xy-edge-label-background-color: color-mix(in oklab, var(--likec4-palette-relation-label-bg) 65%, transparent)}.likec4-root :where(.react-flow__edge,.likec4-edge-container,.likec4-edge-label-container):is([data-likec4-hovered=true],[data-edge-active=true]){--xy-edge-stroke-width: 4;--xy-edge-stroke: var(--likec4-palette-relation-stroke-selected)}.likec4-root :where(.react-flow__node,.react-flow__edge):has([data-likec4-dimmed]){opacity:.25}.likec4-root .likec4-edge-label-container:is([data-likec4-dimmed]){opacity:.25}.likec4-root:is([data-likec4-reduced-graphics]) .hide-on-reduced-graphics{display:none}.likec4-root :where(.relationships-browser,.likec4-relationship-details) .react-flow__attribution{display:none}.likec4-root .mantine-ActionIcon-icon .tabler-icon{width:75%;height:75%}.likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__node,.react-flow__edge):has([data-likec4-dimmed]){filter:grayscale(85%)}.likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__node,.react-flow__edge):has([data-likec4-dimmed=true]){--transition-prop: opacity, filter;transition-property:opacity,filter;--transition-easing: cubic-bezier(.5, 0, .2, 1);transition-timing-function:cubic-bezier(.5,0,.2,1);--transition-duration: .4s;transition-duration:.4s}.likec4-root:not([data-likec4-reduced-graphics]) .likec4-edge-label-container:is([data-likec4-dimmed]){filter:grayscale(85%)}.likec4-root:not([data-likec4-reduced-graphics]) .likec4-edge-label-container:is([data-likec4-dimmed=true]){--transition-prop: opacity, filter;transition-property:opacity,filter;--transition-easing: cubic-bezier(.5, 0, .2, 1);transition-timing-function:cubic-bezier(.5,0,.2,1);--transition-duration: .4s;transition-duration:.4s}[data-mantine-color-scheme=dark] .likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__edgelabel-renderer)>*{mix-blend-mode:screen}[data-mantine-color-scheme=light] .likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__edgelabel-renderer)>*{mix-blend-mode:hard-light}[data-mantine-color-scheme=dark] .likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__edges)>svg{mix-blend-mode:plus-lighter}[data-mantine-color-scheme=light] .likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__edges)>svg{mix-blend-mode:multiply}[data-mantine-color-scheme=light] .likec4-root:not([data-likec4-reduced-graphics]):has(.react-flow__node-seq-parallel) :where(.react-flow__edges>svg){mix-blend-mode:color-burn}[data-mantine-color-scheme=dark] .likec4-root:not([data-likec4-reduced-graphics]) .react-flow__node-seq-parallel{mix-blend-mode:luminosity}[data-mantine-color-scheme=light] .likec4-root:not([data-likec4-reduced-graphics]) .react-flow__node-seq-parallel{mix-blend-mode:color-burn}.likec4-static-view .react-flow .react-flow__attribution{display:none}:where(:root,:host){--likec4-text-size: 1.2rem;--likec4-palette-fill: #3b82f6;--likec4-palette-stroke: #2563eb;--likec4-palette-hiContrast: #eff6ff;--likec4-palette-loContrast: #bfdbfe;--likec4-palette-relation-stroke: #8D8D8D;--likec4-palette-relation-label: #C9C9C9;--likec4-palette-relation-label-bg: #18191B;--mantine-scale: 1;--likec4-palette-outline: var(--likec4-palette-loContrast);--likec4-spacing: ;--text-fz: ;--likec4-icon-size: }@media print{.likec4-root .react-flow{--xy-background-color: transparent !important;background:var(--colors-transparent)!important}.likec4-root .react-flow__background{display:none}.likec4-root *{color-adjust:exact!important;print-color-adjust:exact!important}.likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__edgelabel-renderer)>*{mix-blend-mode:normal!important}.likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__edges)>svg{mix-blend-mode:normal!important}.likec4-root:not([data-likec4-reduced-graphics]) .react-flow__node-seq-parallel{mix-blend-mode:normal!important}}}@layer tokens{:where(:root,:host){--spacing-0: 0px;--spacing-1: 4px;--spacing-2: 8px;--spacing-3: 12px;--spacing-4: 16px;--spacing-5: 20px;--spacing-6: 24px;--spacing-7: 28px;--spacing-8: 32px;--spacing-9: 36px;--spacing-10: 40px;--spacing-likec4-xs: 8px;--spacing-likec4-sm: 10px;--spacing-likec4-md: 16px;--spacing-likec4-lg: 24px;--spacing-likec4-xl: 32px;--spacing-0\\.5: 2px;--spacing-1\\.5: 6px;--spacing-2\\.5: 10px;--spacing-3\\.5: 14px;--spacing-4\\.5: 18px;--spacing-xxs: calc(.5rem * var(--mantine-scale));--spacing-xs: calc(.625rem * var(--mantine-scale));--spacing-sm: calc(.75rem * var(--mantine-scale));--spacing-md: calc(1rem * var(--mantine-scale));--spacing-lg: calc(1.25rem * var(--mantine-scale));--spacing-xl: calc(2rem * var(--mantine-scale));--font-sizes-xxs: .625rem;--font-sizes-xs: calc(.75rem * var(--mantine-scale));--font-sizes-sm: calc(.875rem * var(--mantine-scale));--font-sizes-md: calc(1rem * var(--mantine-scale));--font-sizes-lg: calc(1.125rem * var(--mantine-scale));--font-sizes-xl: calc(1.25rem * var(--mantine-scale));--font-sizes-likec4-xs: .833rem;--font-sizes-likec4-sm: 1rem;--font-sizes-likec4-md: 1.2rem;--font-sizes-likec4-lg: 1.44rem;--font-sizes-likec4-xl: 1.73rem;--line-heights-1: 1;--line-heights-xs: 1.4;--line-heights-sm: 1.45;--line-heights-md: 1.55;--line-heights-lg: 1.6;--line-heights-xl: 1.65;--colors-mantine-colors-primary: var(--mantine-primary-color-6);--colors-mantine-colors-primary-filled: var(--mantine-primary-color-filled);--colors-mantine-colors-primary-filled-hover: var(--mantine-primary-color-filled-hover);--colors-mantine-colors-primary-light: var(--mantine-primary-color-light);--colors-mantine-colors-primary-light-hover: var(--mantine-primary-color-light-hover);--colors-mantine-colors-primary-light-color: var(--mantine-primary-color-light-color);--colors-mantine-colors-primary-outline: var(--mantine-primary-color-outline);--colors-mantine-colors-primary-outline-hover: var(--mantine-primary-color-outline-hover);--colors-mantine-colors-primary\\[0\\]: var(--mantine-primary-color-0);--colors-mantine-colors-primary\\[1\\]: var(--mantine-primary-color-1);--colors-mantine-colors-primary\\[2\\]: var(--mantine-primary-color-2);--colors-mantine-colors-primary\\[3\\]: var(--mantine-primary-color-3);--colors-mantine-colors-primary\\[4\\]: var(--mantine-primary-color-4);--colors-mantine-colors-primary\\[5\\]: var(--mantine-primary-color-5);--colors-mantine-colors-primary\\[6\\]: var(--mantine-primary-color-6);--colors-mantine-colors-primary\\[7\\]: var(--mantine-primary-color-7);--colors-mantine-colors-primary\\[8\\]: var(--mantine-primary-color-8);--colors-mantine-colors-primary\\[9\\]: var(--mantine-primary-color-9);--colors-mantine-colors-white: var(--mantine-color-white);--colors-mantine-colors-text: var(--mantine-color-text);--colors-mantine-colors-body: var(--mantine-color-body);--colors-mantine-colors-dimmed: var(--mantine-color-dimmed);--colors-mantine-colors-default-border: var(--mantine-color-default-border);--colors-mantine-colors-default-color: var(--mantine-color-default-color);--colors-mantine-colors-default-hover: var(--mantine-color-default-hover);--colors-mantine-colors-default: var(--mantine-color-default);--colors-mantine-colors-error: var(--mantine-color-error);--colors-mantine-colors-placeholder: var(--mantine-color-placeholder);--colors-mantine-colors-gray: var(--mantine-color-gray-6);--colors-mantine-colors-gray-filled: var(--mantine-color-gray-filled);--colors-mantine-colors-gray-filled-hover: var(--mantine-color-gray-filled-hover);--colors-mantine-colors-gray-light: var(--mantine-color-gray-light);--colors-mantine-colors-gray-light-hover: var(--mantine-color-gray-light-hover);--colors-mantine-colors-gray-light-color: var(--mantine-color-gray-light-color);--colors-mantine-colors-gray-outline: var(--mantine-color-gray-outline);--colors-mantine-colors-gray-outline-hover: var(--mantine-color-gray-outline-hover);--colors-mantine-colors-gray\\[0\\]: var(--mantine-color-gray-0);--colors-mantine-colors-gray\\[1\\]: var(--mantine-color-gray-1);--colors-mantine-colors-gray\\[2\\]: var(--mantine-color-gray-2);--colors-mantine-colors-gray\\[3\\]: var(--mantine-color-gray-3);--colors-mantine-colors-gray\\[4\\]: var(--mantine-color-gray-4);--colors-mantine-colors-gray\\[5\\]: var(--mantine-color-gray-5);--colors-mantine-colors-gray\\[6\\]: var(--mantine-color-gray-6);--colors-mantine-colors-gray\\[7\\]: var(--mantine-color-gray-7);--colors-mantine-colors-gray\\[8\\]: var(--mantine-color-gray-8);--colors-mantine-colors-gray\\[9\\]: var(--mantine-color-gray-9);--colors-mantine-colors-dark: var(--mantine-color-dark-6);--colors-mantine-colors-dark-filled: var(--mantine-color-dark-filled);--colors-mantine-colors-dark-filled-hover: var(--mantine-color-dark-filled-hover);--colors-mantine-colors-dark-light: var(--mantine-color-dark-light);--colors-mantine-colors-dark-light-hover: var(--mantine-color-dark-light-hover);--colors-mantine-colors-dark-light-color: var(--mantine-color-dark-light-color);--colors-mantine-colors-dark-outline: var(--mantine-color-dark-outline);--colors-mantine-colors-dark-outline-hover: var(--mantine-color-dark-outline-hover);--colors-mantine-colors-dark\\[0\\]: var(--mantine-color-dark-0);--colors-mantine-colors-dark\\[1\\]: var(--mantine-color-dark-1);--colors-mantine-colors-dark\\[2\\]: var(--mantine-color-dark-2);--colors-mantine-colors-dark\\[3\\]: var(--mantine-color-dark-3);--colors-mantine-colors-dark\\[4\\]: var(--mantine-color-dark-4);--colors-mantine-colors-dark\\[5\\]: var(--mantine-color-dark-5);--colors-mantine-colors-dark\\[6\\]: var(--mantine-color-dark-6);--colors-mantine-colors-dark\\[7\\]: var(--mantine-color-dark-7);--colors-mantine-colors-dark\\[8\\]: var(--mantine-color-dark-8);--colors-mantine-colors-dark\\[9\\]: var(--mantine-color-dark-9);--colors-mantine-colors-orange: var(--mantine-color-orange-6);--colors-mantine-colors-orange-filled: var(--mantine-color-orange-filled);--colors-mantine-colors-orange-filled-hover: var(--mantine-color-orange-filled-hover);--colors-mantine-colors-orange-light: var(--mantine-color-orange-light);--colors-mantine-colors-orange-light-hover: var(--mantine-color-orange-light-hover);--colors-mantine-colors-orange-light-color: var(--mantine-color-orange-light-color);--colors-mantine-colors-orange-outline: var(--mantine-color-orange-outline);--colors-mantine-colors-orange-outline-hover: var(--mantine-color-orange-outline-hover);--colors-mantine-colors-orange\\[0\\]: var(--mantine-color-orange-0);--colors-mantine-colors-orange\\[1\\]: var(--mantine-color-orange-1);--colors-mantine-colors-orange\\[2\\]: var(--mantine-color-orange-2);--colors-mantine-colors-orange\\[3\\]: var(--mantine-color-orange-3);--colors-mantine-colors-orange\\[4\\]: var(--mantine-color-orange-4);--colors-mantine-colors-orange\\[5\\]: var(--mantine-color-orange-5);--colors-mantine-colors-orange\\[6\\]: var(--mantine-color-orange-6);--colors-mantine-colors-orange\\[7\\]: var(--mantine-color-orange-7);--colors-mantine-colors-orange\\[8\\]: var(--mantine-color-orange-8);--colors-mantine-colors-orange\\[9\\]: var(--mantine-color-orange-9);--colors-mantine-colors-teal: var(--mantine-color-teal-6);--colors-mantine-colors-teal-filled: var(--mantine-color-teal-filled);--colors-mantine-colors-teal-filled-hover: var(--mantine-color-teal-filled-hover);--colors-mantine-colors-teal-light: var(--mantine-color-teal-light);--colors-mantine-colors-teal-light-hover: var(--mantine-color-teal-light-hover);--colors-mantine-colors-teal-light-color: var(--mantine-color-teal-light-color);--colors-mantine-colors-teal-outline: var(--mantine-color-teal-outline);--colors-mantine-colors-teal-outline-hover: var(--mantine-color-teal-outline-hover);--colors-mantine-colors-teal\\[0\\]: var(--mantine-color-teal-0);--colors-mantine-colors-teal\\[1\\]: var(--mantine-color-teal-1);--colors-mantine-colors-teal\\[2\\]: var(--mantine-color-teal-2);--colors-mantine-colors-teal\\[3\\]: var(--mantine-color-teal-3);--colors-mantine-colors-teal\\[4\\]: var(--mantine-color-teal-4);--colors-mantine-colors-teal\\[5\\]: var(--mantine-color-teal-5);--colors-mantine-colors-teal\\[6\\]: var(--mantine-color-teal-6);--colors-mantine-colors-teal\\[7\\]: var(--mantine-color-teal-7);--colors-mantine-colors-teal\\[8\\]: var(--mantine-color-teal-8);--colors-mantine-colors-teal\\[9\\]: var(--mantine-color-teal-9);--colors-mantine-colors-red: var(--mantine-color-red-6);--colors-mantine-colors-red-filled: var(--mantine-color-red-filled);--colors-mantine-colors-red-filled-hover: var(--mantine-color-red-filled-hover);--colors-mantine-colors-red-light: var(--mantine-color-red-light);--colors-mantine-colors-red-light-hover: var(--mantine-color-red-light-hover);--colors-mantine-colors-red-light-color: var(--mantine-color-red-light-color);--colors-mantine-colors-red-outline: var(--mantine-color-red-outline);--colors-mantine-colors-red-outline-hover: var(--mantine-color-red-outline-hover);--colors-mantine-colors-red\\[0\\]: var(--mantine-color-red-0);--colors-mantine-colors-red\\[1\\]: var(--mantine-color-red-1);--colors-mantine-colors-red\\[2\\]: var(--mantine-color-red-2);--colors-mantine-colors-red\\[3\\]: var(--mantine-color-red-3);--colors-mantine-colors-red\\[4\\]: var(--mantine-color-red-4);--colors-mantine-colors-red\\[5\\]: var(--mantine-color-red-5);--colors-mantine-colors-red\\[6\\]: var(--mantine-color-red-6);--colors-mantine-colors-red\\[7\\]: var(--mantine-color-red-7);--colors-mantine-colors-red\\[8\\]: var(--mantine-color-red-8);--colors-mantine-colors-red\\[9\\]: var(--mantine-color-red-9);--colors-mantine-colors-green: var(--mantine-color-green-6);--colors-mantine-colors-green-filled: var(--mantine-color-green-filled);--colors-mantine-colors-green-filled-hover: var(--mantine-color-green-filled-hover);--colors-mantine-colors-green-light: var(--mantine-color-green-light);--colors-mantine-colors-green-light-hover: var(--mantine-color-green-light-hover);--colors-mantine-colors-green-light-color: var(--mantine-color-green-light-color);--colors-mantine-colors-green-outline: var(--mantine-color-green-outline);--colors-mantine-colors-green-outline-hover: var(--mantine-color-green-outline-hover);--colors-mantine-colors-green\\[0\\]: var(--mantine-color-green-0);--colors-mantine-colors-green\\[1\\]: var(--mantine-color-green-1);--colors-mantine-colors-green\\[2\\]: var(--mantine-color-green-2);--colors-mantine-colors-green\\[3\\]: var(--mantine-color-green-3);--colors-mantine-colors-green\\[4\\]: var(--mantine-color-green-4);--colors-mantine-colors-green\\[5\\]: var(--mantine-color-green-5);--colors-mantine-colors-green\\[6\\]: var(--mantine-color-green-6);--colors-mantine-colors-green\\[7\\]: var(--mantine-color-green-7);--colors-mantine-colors-green\\[8\\]: var(--mantine-color-green-8);--colors-mantine-colors-green\\[9\\]: var(--mantine-color-green-9);--colors-mantine-colors-yellow: var(--mantine-color-yellow-6);--colors-mantine-colors-yellow-filled: var(--mantine-color-yellow-filled);--colors-mantine-colors-yellow-filled-hover: var(--mantine-color-yellow-filled-hover);--colors-mantine-colors-yellow-light: var(--mantine-color-yellow-light);--colors-mantine-colors-yellow-light-hover: var(--mantine-color-yellow-light-hover);--colors-mantine-colors-yellow-light-color: var(--mantine-color-yellow-light-color);--colors-mantine-colors-yellow-outline: var(--mantine-color-yellow-outline);--colors-mantine-colors-yellow-outline-hover: var(--mantine-color-yellow-outline-hover);--colors-mantine-colors-yellow\\[0\\]: var(--mantine-color-yellow-0);--colors-mantine-colors-yellow\\[1\\]: var(--mantine-color-yellow-1);--colors-mantine-colors-yellow\\[2\\]: var(--mantine-color-yellow-2);--colors-mantine-colors-yellow\\[3\\]: var(--mantine-color-yellow-3);--colors-mantine-colors-yellow\\[4\\]: var(--mantine-color-yellow-4);--colors-mantine-colors-yellow\\[5\\]: var(--mantine-color-yellow-5);--colors-mantine-colors-yellow\\[6\\]: var(--mantine-color-yellow-6);--colors-mantine-colors-yellow\\[7\\]: var(--mantine-color-yellow-7);--colors-mantine-colors-yellow\\[8\\]: var(--mantine-color-yellow-8);--colors-mantine-colors-yellow\\[9\\]: var(--mantine-color-yellow-9);--colors-transparent: transparent;--colors-none: none;--sizes-100\\%: 100%;--sizes-full: 100%;--sizes-breakpoint-xs: 36em;--sizes-breakpoint-sm: 48em;--sizes-breakpoint-md: 62em;--sizes-breakpoint-lg: 75em;--sizes-breakpoint-xl: 88em;--borders-none: none;--borders-transparent: 0px solid transparent;--borders-default: 1px solid var(--mantine-color-default-border);--radii-0: 0px;--radii-xs: .125rem;--radii-sm: .25rem;--radii-md: .5rem;--radii-lg: 1rem;--radii-xl: 2rem;--font-weights-normal: 400;--font-weights-medium: 500;--fonts-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;--fonts-body: var(--likec4-app-font, var(--likec4-app-font-default));--fonts-likec4: var(--likec4-app-font, var(--likec4-app-font-default));--fonts-likec4-element: var(--likec4-element-font, var(--fonts-likec4));--fonts-likec4-compound: var(--likec4-compound-font, var(--fonts-likec4));--fonts-likec4-relation: var(--likec4-relation-font, var(--fonts-likec4));--easings-default: cubic-bezier(.4, 0, .2, 1);--easings-in: cubic-bezier(.4, 0, 1, 1);--easings-out: cubic-bezier(0, 0, .4, 1);--easings-in-out: cubic-bezier(.5, 0, .2, 1);--durations-fastest: 50ms;--durations-faster: .1s;--durations-fast: .13s;--durations-normal: .17s;--durations-slow: .3s;--durations-slower: .4s;--durations-slowest: .5s;--shadows-none: none;--shadows-xs: 0 1px 3px rgb(0 0 0/5%), 0 1px 2px rgb(0 0 0/10%);--shadows-sm: 0 1px 3px rgb(0 0 0/5%), 0 10px 15px -5px rgb(0 0 0/5%), 0 7px 7px -5px rgb(0 0 0/4%);--shadows-md: 0 1px 3px rgb(0 0 0/5%), 0 20px 25px -5px rgb(0 0 0/5%), 0 10px 10px -5px rgb(0 0 0/4%);--shadows-lg: 0 1px 3px rgb(0 0 0/5%), 0 28px 23px -7px rgb(0 0 0/5%), 0 12px 12px -7px rgb(0 0 0/4%);--shadows-xl: 0 1px 3px rgb(0 0 0/5%), 0 36px 28px -7px rgb(0 0 0/5%), 0 17px 17px -7px rgb(0 0 0/4%);--z-index-0: 0;--z-index-1: 1;--z-index--1: -1;--z-index-likec4-panel: 100;--z-index-likec4-dropdown: 200;--breakpoints-xs: 36em;--breakpoints-sm: 48em;--breakpoints-md: 62em;--breakpoints-lg: 75em;--breakpoints-xl: 88em;--colors-amber-1: var(--colors-amber-light-1);--colors-amber-2: var(--colors-amber-light-2);--colors-amber-3: var(--colors-amber-light-3);--colors-amber-4: var(--colors-amber-light-4);--colors-amber-5: var(--colors-amber-light-5);--colors-amber-6: var(--colors-amber-light-6);--colors-amber-7: var(--colors-amber-light-7);--colors-amber-8: var(--colors-amber-light-8);--colors-amber-9: var(--colors-amber-light-9);--colors-amber-10: var(--colors-amber-light-10);--colors-amber-11: var(--colors-amber-light-11);--colors-amber-12: var(--colors-amber-light-12);--colors-amber-light-1: #fefdfb;--colors-amber-light-2: #fefbe9;--colors-amber-light-3: #fff7c2;--colors-amber-light-4: #ffee9c;--colors-amber-light-5: #fbe577;--colors-amber-light-6: #f3d673;--colors-amber-light-7: #e9c162;--colors-amber-light-8: #e2a336;--colors-amber-light-9: #ffc53d;--colors-amber-light-10: #ffba18;--colors-amber-light-11: #ab6400;--colors-amber-light-12: #4f3422;--colors-amber-light-a-1: #c0800004;--colors-amber-light-a-2: #f4d10016;--colors-amber-light-a-3: #ffde003d;--colors-amber-light-a-4: #ffd40063;--colors-amber-light-a-5: #f8cf0088;--colors-amber-light-a-6: #eab5008c;--colors-amber-light-a-7: #dc9b009d;--colors-amber-light-a-8: #da8a00c9;--colors-amber-light-a-9: #ffb300c2;--colors-amber-light-a-10: #ffb300e7;--colors-amber-light-a-11: #ab6400;--colors-amber-light-a-12: #341500dd;--colors-amber-light-p3-1: color(display-p3 .995 .992 .985);--colors-amber-light-p3-2: color(display-p3 .994 .986 .921);--colors-amber-light-p3-3: color(display-p3 .994 .969 .782);--colors-amber-light-p3-4: color(display-p3 .989 .937 .65);--colors-amber-light-p3-5: color(display-p3 .97 .902 .527);--colors-amber-light-p3-6: color(display-p3 .936 .844 .506);--colors-amber-light-p3-7: color(display-p3 .89 .762 .443);--colors-amber-light-p3-8: color(display-p3 .85 .65 .3);--colors-amber-light-p3-9: color(display-p3 1 .77 .26);--colors-amber-light-p3-10: color(display-p3 .959 .741 .274);--colors-amber-light-p3-11: color(display-p3 .64 .4 0);--colors-amber-light-p3-12: color(display-p3 .294 .208 .145);--colors-amber-light-p3-a-1: color(display-p3 .757 .514 .024 / .016);--colors-amber-light-p3-a-2: color(display-p3 .902 .804 .008 / .079);--colors-amber-light-p3-a-3: color(display-p3 .965 .859 .004 / .22);--colors-amber-light-p3-a-4: color(display-p3 .969 .82 .004 / .35);--colors-amber-light-p3-a-5: color(display-p3 .933 .796 .004 / .475);--colors-amber-light-p3-a-6: color(display-p3 .875 .682 .004 / .495);--colors-amber-light-p3-a-7: color(display-p3 .804 .573 0 / .557);--colors-amber-light-p3-a-8: color(display-p3 .788 .502 0 / .699);--colors-amber-light-p3-a-9: color(display-p3 1 .686 0 / .742);--colors-amber-light-p3-a-10: color(display-p3 .945 .643 0 / .726);--colors-amber-light-p3-a-11: color(display-p3 .64 .4 0);--colors-amber-light-p3-a-12: color(display-p3 .294 .208 .145);--colors-amber-dark-1: #16120c;--colors-amber-dark-2: #1d180f;--colors-amber-dark-3: #302008;--colors-amber-dark-4: #3f2700;--colors-amber-dark-5: #4d3000;--colors-amber-dark-6: #5c3d05;--colors-amber-dark-7: #714f19;--colors-amber-dark-8: #8f6424;--colors-amber-dark-9: #ffc53d;--colors-amber-dark-10: #ffd60a;--colors-amber-dark-11: #ffca16;--colors-amber-dark-12: #ffe7b3;--colors-amber-dark-a-1: #e63c0006;--colors-amber-dark-a-2: #fd9b000d;--colors-amber-dark-a-3: #fa820022;--colors-amber-dark-a-4: #fc820032;--colors-amber-dark-a-5: #fd8b0041;--colors-amber-dark-a-6: #fd9b0051;--colors-amber-dark-a-7: #ffab2567;--colors-amber-dark-a-8: #ffae3587;--colors-amber-dark-a-9: #ffc53d;--colors-amber-dark-a-10: #ffd60a;--colors-amber-dark-a-11: #ffca16;--colors-amber-dark-a-12: #ffe7b3;--colors-amber-dark-p3-1: color(display-p3 .082 .07 .05);--colors-amber-dark-p3-2: color(display-p3 .111 .094 .064);--colors-amber-dark-p3-3: color(display-p3 .178 .128 .049);--colors-amber-dark-p3-4: color(display-p3 .239 .156 0);--colors-amber-dark-p3-5: color(display-p3 .29 .193 0);--colors-amber-dark-p3-6: color(display-p3 .344 .245 .076);--colors-amber-dark-p3-7: color(display-p3 .422 .314 .141);--colors-amber-dark-p3-8: color(display-p3 .535 .399 .189);--colors-amber-dark-p3-9: color(display-p3 1 .77 .26);--colors-amber-dark-p3-10: color(display-p3 1 .87 .15);--colors-amber-dark-p3-11: color(display-p3 1 .8 .29);--colors-amber-dark-p3-12: color(display-p3 .984 .909 .726);--colors-amber-dark-p3-a-1: color(display-p3 .992 .298 0 / .017);--colors-amber-dark-p3-a-2: color(display-p3 .988 .651 0 / .047);--colors-amber-dark-p3-a-3: color(display-p3 1 .6 0 / .118);--colors-amber-dark-p3-a-4: color(display-p3 1 .557 0 / .185);--colors-amber-dark-p3-a-5: color(display-p3 1 .592 0 / .24);--colors-amber-dark-p3-a-6: color(display-p3 1 .659 .094 / .299);--colors-amber-dark-p3-a-7: color(display-p3 1 .714 .263 / .383);--colors-amber-dark-p3-a-8: color(display-p3 .996 .729 .306 / .5);--colors-amber-dark-p3-a-9: color(display-p3 1 .769 .259);--colors-amber-dark-p3-a-10: color(display-p3 1 .871 .149);--colors-amber-dark-p3-a-11: color(display-p3 1 .8 .29);--colors-amber-dark-p3-a-12: color(display-p3 .984 .909 .726);--colors-amber-a-1: var(--colors-amber-light-a-1);--colors-amber-a-2: var(--colors-amber-light-a-2);--colors-amber-a-3: var(--colors-amber-light-a-3);--colors-amber-a-4: var(--colors-amber-light-a-4);--colors-amber-a-5: var(--colors-amber-light-a-5);--colors-amber-a-6: var(--colors-amber-light-a-6);--colors-amber-a-7: var(--colors-amber-light-a-7);--colors-amber-a-8: var(--colors-amber-light-a-8);--colors-amber-a-9: var(--colors-amber-light-a-9);--colors-amber-a-10: var(--colors-amber-light-a-10);--colors-amber-a-11: var(--colors-amber-light-a-11);--colors-amber-a-12: var(--colors-amber-light-a-12);--colors-amber-p3-1: var(--colors-amber-light-p3-1);--colors-amber-p3-2: var(--colors-amber-light-p3-2);--colors-amber-p3-3: var(--colors-amber-light-p3-3);--colors-amber-p3-4: var(--colors-amber-light-p3-4);--colors-amber-p3-5: var(--colors-amber-light-p3-5);--colors-amber-p3-6: var(--colors-amber-light-p3-6);--colors-amber-p3-7: var(--colors-amber-light-p3-7);--colors-amber-p3-8: var(--colors-amber-light-p3-8);--colors-amber-p3-9: var(--colors-amber-light-p3-9);--colors-amber-p3-10: var(--colors-amber-light-p3-10);--colors-amber-p3-11: var(--colors-amber-light-p3-11);--colors-amber-p3-12: var(--colors-amber-light-p3-12);--colors-amber-p3-a-1: var(--colors-amber-light-p3-a-1);--colors-amber-p3-a-2: var(--colors-amber-light-p3-a-2);--colors-amber-p3-a-3: var(--colors-amber-light-p3-a-3);--colors-amber-p3-a-4: var(--colors-amber-light-p3-a-4);--colors-amber-p3-a-5: var(--colors-amber-light-p3-a-5);--colors-amber-p3-a-6: var(--colors-amber-light-p3-a-6);--colors-amber-p3-a-7: var(--colors-amber-light-p3-a-7);--colors-amber-p3-a-8: var(--colors-amber-light-p3-a-8);--colors-amber-p3-a-9: var(--colors-amber-light-p3-a-9);--colors-amber-p3-a-10: var(--colors-amber-light-p3-a-10);--colors-amber-p3-a-11: var(--colors-amber-light-p3-a-11);--colors-amber-p3-a-12: var(--colors-amber-light-p3-a-12);--colors-blue-1: var(--colors-blue-light-1);--colors-blue-2: var(--colors-blue-light-2);--colors-blue-3: var(--colors-blue-light-3);--colors-blue-4: var(--colors-blue-light-4);--colors-blue-5: var(--colors-blue-light-5);--colors-blue-6: var(--colors-blue-light-6);--colors-blue-7: var(--colors-blue-light-7);--colors-blue-8: var(--colors-blue-light-8);--colors-blue-9: var(--colors-blue-light-9);--colors-blue-10: var(--colors-blue-light-10);--colors-blue-11: var(--colors-blue-light-11);--colors-blue-12: var(--colors-blue-light-12);--colors-blue-light-1: #fbfdff;--colors-blue-light-2: #f4faff;--colors-blue-light-3: #e6f4fe;--colors-blue-light-4: #d5efff;--colors-blue-light-5: #c2e5ff;--colors-blue-light-6: #acd8fc;--colors-blue-light-7: #8ec8f6;--colors-blue-light-8: #5eb1ef;--colors-blue-light-9: #0090ff;--colors-blue-light-10: #0588f0;--colors-blue-light-11: #0d74ce;--colors-blue-light-12: #113264;--colors-blue-light-a-1: #0080ff04;--colors-blue-light-a-2: #008cff0b;--colors-blue-light-a-3: #008ff519;--colors-blue-light-a-4: #009eff2a;--colors-blue-light-a-5: #0093ff3d;--colors-blue-light-a-6: #0088f653;--colors-blue-light-a-7: #0083eb71;--colors-blue-light-a-8: #0084e6a1;--colors-blue-light-a-9: #0090ff;--colors-blue-light-a-10: #0086f0fa;--colors-blue-light-a-11: #006dcbf2;--colors-blue-light-a-12: #002359ee;--colors-blue-light-p3-1: color(display-p3 .986 .992 .999);--colors-blue-light-p3-2: color(display-p3 .96 .979 .998);--colors-blue-light-p3-3: color(display-p3 .912 .956 .991);--colors-blue-light-p3-4: color(display-p3 .853 .932 1);--colors-blue-light-p3-5: color(display-p3 .788 .894 .998);--colors-blue-light-p3-6: color(display-p3 .709 .843 .976);--colors-blue-light-p3-7: color(display-p3 .606 .777 .947);--colors-blue-light-p3-8: color(display-p3 .451 .688 .917);--colors-blue-light-p3-9: color(display-p3 .247 .556 .969);--colors-blue-light-p3-10: color(display-p3 .234 .523 .912);--colors-blue-light-p3-11: color(display-p3 .15 .44 .84);--colors-blue-light-p3-12: color(display-p3 .102 .193 .379);--colors-blue-light-p3-a-1: color(display-p3 .024 .514 1 / .016);--colors-blue-light-p3-a-2: color(display-p3 .024 .514 .906 / .04);--colors-blue-light-p3-a-3: color(display-p3 .012 .506 .914 / .087);--colors-blue-light-p3-a-4: color(display-p3 .008 .545 1 / .146);--colors-blue-light-p3-a-5: color(display-p3 .004 .502 .984 / .212);--colors-blue-light-p3-a-6: color(display-p3 .004 .463 .922 / .291);--colors-blue-light-p3-a-7: color(display-p3 .004 .431 .863 / .393);--colors-blue-light-p3-a-8: color(display-p3 0 .427 .851 / .55);--colors-blue-light-p3-a-9: color(display-p3 0 .412 .961 / .753);--colors-blue-light-p3-a-10: color(display-p3 0 .376 .886 / .765);--colors-blue-light-p3-a-11: color(display-p3 .15 .44 .84);--colors-blue-light-p3-a-12: color(display-p3 .102 .193 .379);--colors-blue-dark-1: #0d1520;--colors-blue-dark-2: #111927;--colors-blue-dark-3: #0d2847;--colors-blue-dark-4: #003362;--colors-blue-dark-5: #004074;--colors-blue-dark-6: #104d87;--colors-blue-dark-7: #205d9e;--colors-blue-dark-8: #2870bd;--colors-blue-dark-9: #0090ff;--colors-blue-dark-10: #3b9eff;--colors-blue-dark-11: #70b8ff;--colors-blue-dark-12: #c2e6ff;--colors-blue-dark-a-1: #004df211;--colors-blue-dark-a-2: #1166fb18;--colors-blue-dark-a-3: #0077ff3a;--colors-blue-dark-a-4: #0075ff57;--colors-blue-dark-a-5: #0081fd6b;--colors-blue-dark-a-6: #0f89fd7f;--colors-blue-dark-a-7: #2a91fe98;--colors-blue-dark-a-8: #3094feb9;--colors-blue-dark-a-9: #0090ff;--colors-blue-dark-a-10: #3b9eff;--colors-blue-dark-a-11: #70b8ff;--colors-blue-dark-a-12: #c2e6ff;--colors-blue-dark-p3-1: color(display-p3 .057 .081 .122);--colors-blue-dark-p3-2: color(display-p3 .072 .098 .147);--colors-blue-dark-p3-3: color(display-p3 .078 .154 .27);--colors-blue-dark-p3-4: color(display-p3 .033 .197 .37);--colors-blue-dark-p3-5: color(display-p3 .08 .245 .441);--colors-blue-dark-p3-6: color(display-p3 .14 .298 .511);--colors-blue-dark-p3-7: color(display-p3 .195 .361 .6);--colors-blue-dark-p3-8: color(display-p3 .239 .434 .72);--colors-blue-dark-p3-9: color(display-p3 .247 .556 .969);--colors-blue-dark-p3-10: color(display-p3 .344 .612 .973);--colors-blue-dark-p3-11: color(display-p3 .49 .72 1);--colors-blue-dark-p3-12: color(display-p3 .788 .898 .99);--colors-blue-dark-p3-a-1: color(display-p3 0 .333 1 / .059);--colors-blue-dark-p3-a-2: color(display-p3 .114 .435 .988 / .085);--colors-blue-dark-p3-a-3: color(display-p3 .122 .463 1 / .219);--colors-blue-dark-p3-a-4: color(display-p3 0 .467 1 / .324);--colors-blue-dark-p3-a-5: color(display-p3 .098 .51 1 / .4);--colors-blue-dark-p3-a-6: color(display-p3 .224 .557 1 / .475);--colors-blue-dark-p3-a-7: color(display-p3 .294 .584 1 / .572);--colors-blue-dark-p3-a-8: color(display-p3 .314 .592 1 / .702);--colors-blue-dark-p3-a-9: color(display-p3 .251 .573 .996 / .967);--colors-blue-dark-p3-a-10: color(display-p3 .357 .631 1 / .971);--colors-blue-dark-p3-a-11: color(display-p3 .49 .72 1);--colors-blue-dark-p3-a-12: color(display-p3 .788 .898 .99);--colors-blue-a-1: var(--colors-blue-light-a-1);--colors-blue-a-2: var(--colors-blue-light-a-2);--colors-blue-a-3: var(--colors-blue-light-a-3);--colors-blue-a-4: var(--colors-blue-light-a-4);--colors-blue-a-5: var(--colors-blue-light-a-5);--colors-blue-a-6: var(--colors-blue-light-a-6);--colors-blue-a-7: var(--colors-blue-light-a-7);--colors-blue-a-8: var(--colors-blue-light-a-8);--colors-blue-a-9: var(--colors-blue-light-a-9);--colors-blue-a-10: var(--colors-blue-light-a-10);--colors-blue-a-11: var(--colors-blue-light-a-11);--colors-blue-a-12: var(--colors-blue-light-a-12);--colors-blue-p3-1: var(--colors-blue-light-p3-1);--colors-blue-p3-2: var(--colors-blue-light-p3-2);--colors-blue-p3-3: var(--colors-blue-light-p3-3);--colors-blue-p3-4: var(--colors-blue-light-p3-4);--colors-blue-p3-5: var(--colors-blue-light-p3-5);--colors-blue-p3-6: var(--colors-blue-light-p3-6);--colors-blue-p3-7: var(--colors-blue-light-p3-7);--colors-blue-p3-8: var(--colors-blue-light-p3-8);--colors-blue-p3-9: var(--colors-blue-light-p3-9);--colors-blue-p3-10: var(--colors-blue-light-p3-10);--colors-blue-p3-11: var(--colors-blue-light-p3-11);--colors-blue-p3-12: var(--colors-blue-light-p3-12);--colors-blue-p3-a-1: var(--colors-blue-light-p3-a-1);--colors-blue-p3-a-2: var(--colors-blue-light-p3-a-2);--colors-blue-p3-a-3: var(--colors-blue-light-p3-a-3);--colors-blue-p3-a-4: var(--colors-blue-light-p3-a-4);--colors-blue-p3-a-5: var(--colors-blue-light-p3-a-5);--colors-blue-p3-a-6: var(--colors-blue-light-p3-a-6);--colors-blue-p3-a-7: var(--colors-blue-light-p3-a-7);--colors-blue-p3-a-8: var(--colors-blue-light-p3-a-8);--colors-blue-p3-a-9: var(--colors-blue-light-p3-a-9);--colors-blue-p3-a-10: var(--colors-blue-light-p3-a-10);--colors-blue-p3-a-11: var(--colors-blue-light-p3-a-11);--colors-blue-p3-a-12: var(--colors-blue-light-p3-a-12);--colors-crimson-1: var(--colors-crimson-light-1);--colors-crimson-2: var(--colors-crimson-light-2);--colors-crimson-3: var(--colors-crimson-light-3);--colors-crimson-4: var(--colors-crimson-light-4);--colors-crimson-5: var(--colors-crimson-light-5);--colors-crimson-6: var(--colors-crimson-light-6);--colors-crimson-7: var(--colors-crimson-light-7);--colors-crimson-8: var(--colors-crimson-light-8);--colors-crimson-9: var(--colors-crimson-light-9);--colors-crimson-10: var(--colors-crimson-light-10);--colors-crimson-11: var(--colors-crimson-light-11);--colors-crimson-12: var(--colors-crimson-light-12);--colors-crimson-light-1: #fffcfd;--colors-crimson-light-2: #fef7f9;--colors-crimson-light-3: #ffe9f0;--colors-crimson-light-4: #fedce7;--colors-crimson-light-5: #facedd;--colors-crimson-light-6: #f3bed1;--colors-crimson-light-7: #eaacc3;--colors-crimson-light-8: #e093b2;--colors-crimson-light-9: #e93d82;--colors-crimson-light-10: #df3478;--colors-crimson-light-11: #cb1d63;--colors-crimson-light-12: #621639;--colors-crimson-light-a-1: #ff005503;--colors-crimson-light-a-2: #e0004008;--colors-crimson-light-a-3: #ff005216;--colors-crimson-light-a-4: #f8005123;--colors-crimson-light-a-5: #e5004f31;--colors-crimson-light-a-6: #d0004b41;--colors-crimson-light-a-7: #bf004753;--colors-crimson-light-a-8: #b6004a6c;--colors-crimson-light-a-9: #e2005bc2;--colors-crimson-light-a-10: #d70056cb;--colors-crimson-light-a-11: #c4004fe2;--colors-crimson-light-a-12: #530026e9;--colors-crimson-light-p3-1: color(display-p3 .998 .989 .992);--colors-crimson-light-p3-2: color(display-p3 .991 .969 .976);--colors-crimson-light-p3-3: color(display-p3 .987 .917 .941);--colors-crimson-light-p3-4: color(display-p3 .975 .866 .904);--colors-crimson-light-p3-5: color(display-p3 .953 .813 .864);--colors-crimson-light-p3-6: color(display-p3 .921 .755 .817);--colors-crimson-light-p3-7: color(display-p3 .88 .683 .761);--colors-crimson-light-p3-8: color(display-p3 .834 .592 .694);--colors-crimson-light-p3-9: color(display-p3 .843 .298 .507);--colors-crimson-light-p3-10: color(display-p3 .807 .266 .468);--colors-crimson-light-p3-11: color(display-p3 .731 .195 .388);--colors-crimson-light-p3-12: color(display-p3 .352 .111 .221);--colors-crimson-light-p3-a-1: color(display-p3 .675 .024 .349 / .012);--colors-crimson-light-p3-a-2: color(display-p3 .757 .02 .267 / .032);--colors-crimson-light-p3-a-3: color(display-p3 .859 .008 .294 / .083);--colors-crimson-light-p3-a-4: color(display-p3 .827 .008 .298 / .134);--colors-crimson-light-p3-a-5: color(display-p3 .753 .008 .275 / .189);--colors-crimson-light-p3-a-6: color(display-p3 .682 .004 .247 / .244);--colors-crimson-light-p3-a-7: color(display-p3 .62 .004 .251 / .318);--colors-crimson-light-p3-a-8: color(display-p3 .6 .004 .251 / .408);--colors-crimson-light-p3-a-9: color(display-p3 .776 0 .298 / .702);--colors-crimson-light-p3-a-10: color(display-p3 .737 0 .275 / .734);--colors-crimson-light-p3-a-11: color(display-p3 .731 .195 .388);--colors-crimson-light-p3-a-12: color(display-p3 .352 .111 .221);--colors-crimson-dark-1: #191114;--colors-crimson-dark-2: #201318;--colors-crimson-dark-3: #381525;--colors-crimson-dark-4: #4d122f;--colors-crimson-dark-5: #5c1839;--colors-crimson-dark-6: #6d2545;--colors-crimson-dark-7: #873356;--colors-crimson-dark-8: #b0436e;--colors-crimson-dark-9: #e93d82;--colors-crimson-dark-10: #ee518a;--colors-crimson-dark-11: #ff92ad;--colors-crimson-dark-12: #fdd3e8;--colors-crimson-dark-a-1: #f4126709;--colors-crimson-dark-a-2: #f22f7a11;--colors-crimson-dark-a-3: #fe2a8b2a;--colors-crimson-dark-a-4: #fd158741;--colors-crimson-dark-a-5: #fd278f51;--colors-crimson-dark-a-6: #fe459763;--colors-crimson-dark-a-7: #fd559b7f;--colors-crimson-dark-a-8: #fe5b9bab;--colors-crimson-dark-a-9: #fe418de8;--colors-crimson-dark-a-10: #ff5693ed;--colors-crimson-dark-a-11: #ff92ad;--colors-crimson-dark-a-12: #ffd5eafd;--colors-crimson-dark-p3-1: color(display-p3 .093 .068 .078);--colors-crimson-dark-p3-2: color(display-p3 .117 .078 .095);--colors-crimson-dark-p3-3: color(display-p3 .203 .091 .143);--colors-crimson-dark-p3-4: color(display-p3 .277 .087 .182);--colors-crimson-dark-p3-5: color(display-p3 .332 .115 .22);--colors-crimson-dark-p3-6: color(display-p3 .394 .162 .268);--colors-crimson-dark-p3-7: color(display-p3 .489 .222 .336);--colors-crimson-dark-p3-8: color(display-p3 .638 .289 .429);--colors-crimson-dark-p3-9: color(display-p3 .843 .298 .507);--colors-crimson-dark-p3-10: color(display-p3 .864 .364 .539);--colors-crimson-dark-p3-11: color(display-p3 1 .56 .66);--colors-crimson-dark-p3-12: color(display-p3 .966 .834 .906);--colors-crimson-dark-p3-a-1: color(display-p3 .984 .071 .463 / .03);--colors-crimson-dark-p3-a-2: color(display-p3 .996 .282 .569 / .055);--colors-crimson-dark-p3-a-3: color(display-p3 .996 .227 .573 / .148);--colors-crimson-dark-p3-a-4: color(display-p3 1 .157 .569 / .227);--colors-crimson-dark-p3-a-5: color(display-p3 1 .231 .604 / .286);--colors-crimson-dark-p3-a-6: color(display-p3 1 .337 .643 / .349);--colors-crimson-dark-p3-a-7: color(display-p3 1 .416 .663 / .454);--colors-crimson-dark-p3-a-8: color(display-p3 .996 .427 .651 / .614);--colors-crimson-dark-p3-a-9: color(display-p3 1 .345 .596 / .832);--colors-crimson-dark-p3-a-10: color(display-p3 1 .42 .62 / .853);--colors-crimson-dark-p3-a-11: color(display-p3 1 .56 .66);--colors-crimson-dark-p3-a-12: color(display-p3 .966 .834 .906);--colors-crimson-a-1: var(--colors-crimson-light-a-1);--colors-crimson-a-2: var(--colors-crimson-light-a-2);--colors-crimson-a-3: var(--colors-crimson-light-a-3);--colors-crimson-a-4: var(--colors-crimson-light-a-4);--colors-crimson-a-5: var(--colors-crimson-light-a-5);--colors-crimson-a-6: var(--colors-crimson-light-a-6);--colors-crimson-a-7: var(--colors-crimson-light-a-7);--colors-crimson-a-8: var(--colors-crimson-light-a-8);--colors-crimson-a-9: var(--colors-crimson-light-a-9);--colors-crimson-a-10: var(--colors-crimson-light-a-10);--colors-crimson-a-11: var(--colors-crimson-light-a-11);--colors-crimson-a-12: var(--colors-crimson-light-a-12);--colors-crimson-p3-1: var(--colors-crimson-light-p3-1);--colors-crimson-p3-2: var(--colors-crimson-light-p3-2);--colors-crimson-p3-3: var(--colors-crimson-light-p3-3);--colors-crimson-p3-4: var(--colors-crimson-light-p3-4);--colors-crimson-p3-5: var(--colors-crimson-light-p3-5);--colors-crimson-p3-6: var(--colors-crimson-light-p3-6);--colors-crimson-p3-7: var(--colors-crimson-light-p3-7);--colors-crimson-p3-8: var(--colors-crimson-light-p3-8);--colors-crimson-p3-9: var(--colors-crimson-light-p3-9);--colors-crimson-p3-10: var(--colors-crimson-light-p3-10);--colors-crimson-p3-11: var(--colors-crimson-light-p3-11);--colors-crimson-p3-12: var(--colors-crimson-light-p3-12);--colors-crimson-p3-a-1: var(--colors-crimson-light-p3-a-1);--colors-crimson-p3-a-2: var(--colors-crimson-light-p3-a-2);--colors-crimson-p3-a-3: var(--colors-crimson-light-p3-a-3);--colors-crimson-p3-a-4: var(--colors-crimson-light-p3-a-4);--colors-crimson-p3-a-5: var(--colors-crimson-light-p3-a-5);--colors-crimson-p3-a-6: var(--colors-crimson-light-p3-a-6);--colors-crimson-p3-a-7: var(--colors-crimson-light-p3-a-7);--colors-crimson-p3-a-8: var(--colors-crimson-light-p3-a-8);--colors-crimson-p3-a-9: var(--colors-crimson-light-p3-a-9);--colors-crimson-p3-a-10: var(--colors-crimson-light-p3-a-10);--colors-crimson-p3-a-11: var(--colors-crimson-light-p3-a-11);--colors-crimson-p3-a-12: var(--colors-crimson-light-p3-a-12);--colors-grass-1: var(--colors-grass-light-1);--colors-grass-2: var(--colors-grass-light-2);--colors-grass-3: var(--colors-grass-light-3);--colors-grass-4: var(--colors-grass-light-4);--colors-grass-5: var(--colors-grass-light-5);--colors-grass-6: var(--colors-grass-light-6);--colors-grass-7: var(--colors-grass-light-7);--colors-grass-8: var(--colors-grass-light-8);--colors-grass-9: var(--colors-grass-light-9);--colors-grass-10: var(--colors-grass-light-10);--colors-grass-11: var(--colors-grass-light-11);--colors-grass-12: var(--colors-grass-light-12);--colors-grass-light-1: #fbfefb;--colors-grass-light-2: #f5fbf5;--colors-grass-light-3: #e9f6e9;--colors-grass-light-4: #daf1db;--colors-grass-light-5: #c9e8ca;--colors-grass-light-6: #b2ddb5;--colors-grass-light-7: #94ce9a;--colors-grass-light-8: #65ba74;--colors-grass-light-9: #46a758;--colors-grass-light-10: #3e9b4f;--colors-grass-light-11: #2a7e3b;--colors-grass-light-12: #203c25;--colors-grass-light-a-1: #00c00004;--colors-grass-light-a-2: #0099000a;--colors-grass-light-a-3: #00970016;--colors-grass-light-a-4: #009f0725;--colors-grass-light-a-5: #00930536;--colors-grass-light-a-6: #008f0a4d;--colors-grass-light-a-7: #018b0f6b;--colors-grass-light-a-8: #008d199a;--colors-grass-light-a-9: #008619b9;--colors-grass-light-a-10: #007b17c1;--colors-grass-light-a-11: #006514d5;--colors-grass-light-a-12: #002006df;--colors-grass-light-p3-1: color(display-p3 .986 .996 .985);--colors-grass-light-p3-2: color(display-p3 .966 .983 .964);--colors-grass-light-p3-3: color(display-p3 .923 .965 .917);--colors-grass-light-p3-4: color(display-p3 .872 .94 .865);--colors-grass-light-p3-5: color(display-p3 .811 .908 .802);--colors-grass-light-p3-6: color(display-p3 .733 .864 .724);--colors-grass-light-p3-7: color(display-p3 .628 .803 .622);--colors-grass-light-p3-8: color(display-p3 .477 .72 .482);--colors-grass-light-p3-9: color(display-p3 .38 .647 .378);--colors-grass-light-p3-10: color(display-p3 .344 .598 .342);--colors-grass-light-p3-11: color(display-p3 .263 .488 .261);--colors-grass-light-p3-12: color(display-p3 .151 .233 .153);--colors-grass-light-p3-a-1: color(display-p3 .024 .757 .024 / .016);--colors-grass-light-p3-a-2: color(display-p3 .024 .565 .024 / .036);--colors-grass-light-p3-a-3: color(display-p3 .059 .576 .008 / .083);--colors-grass-light-p3-a-4: color(display-p3 .035 .565 .008 / .134);--colors-grass-light-p3-a-5: color(display-p3 .047 .545 .008 / .197);--colors-grass-light-p3-a-6: color(display-p3 .031 .502 .004 / .275);--colors-grass-light-p3-a-7: color(display-p3 .012 .482 .004 / .377);--colors-grass-light-p3-a-8: color(display-p3 0 .467 .008 / .522);--colors-grass-light-p3-a-9: color(display-p3 .008 .435 0 / .624);--colors-grass-light-p3-a-10: color(display-p3 .008 .388 0 / .659);--colors-grass-light-p3-a-11: color(display-p3 .263 .488 .261);--colors-grass-light-p3-a-12: color(display-p3 .151 .233 .153);--colors-grass-dark-1: #0e1511;--colors-grass-dark-2: #141a15;--colors-grass-dark-3: #1b2a1e;--colors-grass-dark-4: #1d3a24;--colors-grass-dark-5: #25482d;--colors-grass-dark-6: #2d5736;--colors-grass-dark-7: #366740;--colors-grass-dark-8: #3e7949;--colors-grass-dark-9: #46a758;--colors-grass-dark-10: #53b365;--colors-grass-dark-11: #71d083;--colors-grass-dark-12: #c2f0c2;--colors-grass-dark-a-1: #00de1205;--colors-grass-dark-a-2: #5ef7780a;--colors-grass-dark-a-3: #70fe8c1b;--colors-grass-dark-a-4: #57ff802c;--colors-grass-dark-a-5: #68ff8b3b;--colors-grass-dark-a-6: #71ff8f4b;--colors-grass-dark-a-7: #77fd925d;--colors-grass-dark-a-8: #77fd9070;--colors-grass-dark-a-9: #65ff82a1;--colors-grass-dark-a-10: #72ff8dae;--colors-grass-dark-a-11: #89ff9fcd;--colors-grass-dark-a-12: #ceffceef;--colors-grass-dark-p3-1: color(display-p3 .062 .083 .067);--colors-grass-dark-p3-2: color(display-p3 .083 .103 .085);--colors-grass-dark-p3-3: color(display-p3 .118 .163 .122);--colors-grass-dark-p3-4: color(display-p3 .142 .225 .15);--colors-grass-dark-p3-5: color(display-p3 .178 .279 .186);--colors-grass-dark-p3-6: color(display-p3 .217 .337 .224);--colors-grass-dark-p3-7: color(display-p3 .258 .4 .264);--colors-grass-dark-p3-8: color(display-p3 .302 .47 .305);--colors-grass-dark-p3-9: color(display-p3 .38 .647 .378);--colors-grass-dark-p3-10: color(display-p3 .426 .694 .426);--colors-grass-dark-p3-11: color(display-p3 .535 .807 .542);--colors-grass-dark-p3-12: color(display-p3 .797 .936 .776);--colors-grass-dark-p3-a-1: color(display-p3 0 .992 .071 / .017);--colors-grass-dark-p3-a-2: color(display-p3 .482 .996 .584 / .038);--colors-grass-dark-p3-a-3: color(display-p3 .549 .992 .588 / .106);--colors-grass-dark-p3-a-4: color(display-p3 .51 .996 .557 / .169);--colors-grass-dark-p3-a-5: color(display-p3 .553 1 .588 / .227);--colors-grass-dark-p3-a-6: color(display-p3 .584 1 .608 / .29);--colors-grass-dark-p3-a-7: color(display-p3 .604 1 .616 / .358);--colors-grass-dark-p3-a-8: color(display-p3 .608 1 .62 / .433);--colors-grass-dark-p3-a-9: color(display-p3 .573 1 .569 / .622);--colors-grass-dark-p3-a-10: color(display-p3 .6 .996 .6 / .673);--colors-grass-dark-p3-a-11: color(display-p3 .535 .807 .542);--colors-grass-dark-p3-a-12: color(display-p3 .797 .936 .776);--colors-grass-a-1: var(--colors-grass-light-a-1);--colors-grass-a-2: var(--colors-grass-light-a-2);--colors-grass-a-3: var(--colors-grass-light-a-3);--colors-grass-a-4: var(--colors-grass-light-a-4);--colors-grass-a-5: var(--colors-grass-light-a-5);--colors-grass-a-6: var(--colors-grass-light-a-6);--colors-grass-a-7: var(--colors-grass-light-a-7);--colors-grass-a-8: var(--colors-grass-light-a-8);--colors-grass-a-9: var(--colors-grass-light-a-9);--colors-grass-a-10: var(--colors-grass-light-a-10);--colors-grass-a-11: var(--colors-grass-light-a-11);--colors-grass-a-12: var(--colors-grass-light-a-12);--colors-grass-p3-1: var(--colors-grass-light-p3-1);--colors-grass-p3-2: var(--colors-grass-light-p3-2);--colors-grass-p3-3: var(--colors-grass-light-p3-3);--colors-grass-p3-4: var(--colors-grass-light-p3-4);--colors-grass-p3-5: var(--colors-grass-light-p3-5);--colors-grass-p3-6: var(--colors-grass-light-p3-6);--colors-grass-p3-7: var(--colors-grass-light-p3-7);--colors-grass-p3-8: var(--colors-grass-light-p3-8);--colors-grass-p3-9: var(--colors-grass-light-p3-9);--colors-grass-p3-10: var(--colors-grass-light-p3-10);--colors-grass-p3-11: var(--colors-grass-light-p3-11);--colors-grass-p3-12: var(--colors-grass-light-p3-12);--colors-grass-p3-a-1: var(--colors-grass-light-p3-a-1);--colors-grass-p3-a-2: var(--colors-grass-light-p3-a-2);--colors-grass-p3-a-3: var(--colors-grass-light-p3-a-3);--colors-grass-p3-a-4: var(--colors-grass-light-p3-a-4);--colors-grass-p3-a-5: var(--colors-grass-light-p3-a-5);--colors-grass-p3-a-6: var(--colors-grass-light-p3-a-6);--colors-grass-p3-a-7: var(--colors-grass-light-p3-a-7);--colors-grass-p3-a-8: var(--colors-grass-light-p3-a-8);--colors-grass-p3-a-9: var(--colors-grass-light-p3-a-9);--colors-grass-p3-a-10: var(--colors-grass-light-p3-a-10);--colors-grass-p3-a-11: var(--colors-grass-light-p3-a-11);--colors-grass-p3-a-12: var(--colors-grass-light-p3-a-12);--colors-indigo-1: var(--colors-indigo-light-1);--colors-indigo-2: var(--colors-indigo-light-2);--colors-indigo-3: var(--colors-indigo-light-3);--colors-indigo-4: var(--colors-indigo-light-4);--colors-indigo-5: var(--colors-indigo-light-5);--colors-indigo-6: var(--colors-indigo-light-6);--colors-indigo-7: var(--colors-indigo-light-7);--colors-indigo-8: var(--colors-indigo-light-8);--colors-indigo-9: var(--colors-indigo-light-9);--colors-indigo-10: var(--colors-indigo-light-10);--colors-indigo-11: var(--colors-indigo-light-11);--colors-indigo-12: var(--colors-indigo-light-12);--colors-indigo-light-1: #fdfdfe;--colors-indigo-light-2: #f7f9ff;--colors-indigo-light-3: #edf2fe;--colors-indigo-light-4: #e1e9ff;--colors-indigo-light-5: #d2deff;--colors-indigo-light-6: #c1d0ff;--colors-indigo-light-7: #abbdf9;--colors-indigo-light-8: #8da4ef;--colors-indigo-light-9: #3e63dd;--colors-indigo-light-10: #3358d4;--colors-indigo-light-11: #3a5bc7;--colors-indigo-light-12: #1f2d5c;--colors-indigo-light-a-1: #00008002;--colors-indigo-light-a-2: #0040ff08;--colors-indigo-light-a-3: #0047f112;--colors-indigo-light-a-4: #0044ff1e;--colors-indigo-light-a-5: #0044ff2d;--colors-indigo-light-a-6: #003eff3e;--colors-indigo-light-a-7: #0037ed54;--colors-indigo-light-a-8: #0034dc72;--colors-indigo-light-a-9: #0031d2c1;--colors-indigo-light-a-10: #002ec9cc;--colors-indigo-light-a-11: #002bb7c5;--colors-indigo-light-a-12: #001046e0;--colors-indigo-light-p3-1: color(display-p3 .992 .992 .996);--colors-indigo-light-p3-2: color(display-p3 .971 .977 .998);--colors-indigo-light-p3-3: color(display-p3 .933 .948 .992);--colors-indigo-light-p3-4: color(display-p3 .885 .914 1);--colors-indigo-light-p3-5: color(display-p3 .831 .87 1);--colors-indigo-light-p3-6: color(display-p3 .767 .814 .995);--colors-indigo-light-p3-7: color(display-p3 .685 .74 .957);--colors-indigo-light-p3-8: color(display-p3 .569 .639 .916);--colors-indigo-light-p3-9: color(display-p3 .276 .384 .837);--colors-indigo-light-p3-10: color(display-p3 .234 .343 .801);--colors-indigo-light-p3-11: color(display-p3 .256 .354 .755);--colors-indigo-light-p3-12: color(display-p3 .133 .175 .348);--colors-indigo-light-p3-a-1: color(display-p3 .02 .02 .51 / .008);--colors-indigo-light-p3-a-2: color(display-p3 .024 .161 .863 / .028);--colors-indigo-light-p3-a-3: color(display-p3 .008 .239 .886 / .067);--colors-indigo-light-p3-a-4: color(display-p3 .004 .247 1 / .114);--colors-indigo-light-p3-a-5: color(display-p3 .004 .235 1 / .169);--colors-indigo-light-p3-a-6: color(display-p3 .004 .208 .984 / .232);--colors-indigo-light-p3-a-7: color(display-p3 .004 .176 .863 / .314);--colors-indigo-light-p3-a-8: color(display-p3 .004 .165 .812 / .432);--colors-indigo-light-p3-a-9: color(display-p3 0 .153 .773 / .726);--colors-indigo-light-p3-a-10: color(display-p3 0 .137 .737 / .765);--colors-indigo-light-p3-a-11: color(display-p3 .256 .354 .755);--colors-indigo-light-p3-a-12: color(display-p3 .133 .175 .348);--colors-indigo-dark-1: #11131f;--colors-indigo-dark-2: #141726;--colors-indigo-dark-3: #182449;--colors-indigo-dark-4: #1d2e62;--colors-indigo-dark-5: #253974;--colors-indigo-dark-6: #304384;--colors-indigo-dark-7: #3a4f97;--colors-indigo-dark-8: #435db1;--colors-indigo-dark-9: #3e63dd;--colors-indigo-dark-10: #5472e4;--colors-indigo-dark-11: #9eb1ff;--colors-indigo-dark-12: #d6e1ff;--colors-indigo-dark-a-1: #1133ff0f;--colors-indigo-dark-a-2: #3354fa17;--colors-indigo-dark-a-3: #2f62ff3c;--colors-indigo-dark-a-4: #3566ff57;--colors-indigo-dark-a-5: #4171fd6b;--colors-indigo-dark-a-6: #5178fd7c;--colors-indigo-dark-a-7: #5a7fff90;--colors-indigo-dark-a-8: #5b81feac;--colors-indigo-dark-a-9: #4671ffdb;--colors-indigo-dark-a-10: #5c7efee3;--colors-indigo-dark-a-11: #9eb1ff;--colors-indigo-dark-a-12: #d6e1ff;--colors-indigo-dark-p3-1: color(display-p3 .068 .074 .118);--colors-indigo-dark-p3-2: color(display-p3 .081 .089 .144);--colors-indigo-dark-p3-3: color(display-p3 .105 .141 .275);--colors-indigo-dark-p3-4: color(display-p3 .129 .18 .369);--colors-indigo-dark-p3-5: color(display-p3 .163 .22 .439);--colors-indigo-dark-p3-6: color(display-p3 .203 .262 .5);--colors-indigo-dark-p3-7: color(display-p3 .245 .309 .575);--colors-indigo-dark-p3-8: color(display-p3 .285 .362 .674);--colors-indigo-dark-p3-9: color(display-p3 .276 .384 .837);--colors-indigo-dark-p3-10: color(display-p3 .354 .445 .866);--colors-indigo-dark-p3-11: color(display-p3 .63 .69 1);--colors-indigo-dark-p3-12: color(display-p3 .848 .881 .99);--colors-indigo-dark-p3-a-1: color(display-p3 .071 .212 .996 / .055);--colors-indigo-dark-p3-a-2: color(display-p3 .251 .345 .988 / .085);--colors-indigo-dark-p3-a-3: color(display-p3 .243 .404 1 / .223);--colors-indigo-dark-p3-a-4: color(display-p3 .263 .42 1 / .324);--colors-indigo-dark-p3-a-5: color(display-p3 .314 .451 1 / .4);--colors-indigo-dark-p3-a-6: color(display-p3 .361 .49 1 / .467);--colors-indigo-dark-p3-a-7: color(display-p3 .388 .51 1 / .547);--colors-indigo-dark-p3-a-8: color(display-p3 .404 .518 1 / .652);--colors-indigo-dark-p3-a-9: color(display-p3 .318 .451 1 / .824);--colors-indigo-dark-p3-a-10: color(display-p3 .404 .506 1 / .858);--colors-indigo-dark-p3-a-11: color(display-p3 .63 .69 1);--colors-indigo-dark-p3-a-12: color(display-p3 .848 .881 .99);--colors-indigo-a-1: var(--colors-indigo-light-a-1);--colors-indigo-a-2: var(--colors-indigo-light-a-2);--colors-indigo-a-3: var(--colors-indigo-light-a-3);--colors-indigo-a-4: var(--colors-indigo-light-a-4);--colors-indigo-a-5: var(--colors-indigo-light-a-5);--colors-indigo-a-6: var(--colors-indigo-light-a-6);--colors-indigo-a-7: var(--colors-indigo-light-a-7);--colors-indigo-a-8: var(--colors-indigo-light-a-8);--colors-indigo-a-9: var(--colors-indigo-light-a-9);--colors-indigo-a-10: var(--colors-indigo-light-a-10);--colors-indigo-a-11: var(--colors-indigo-light-a-11);--colors-indigo-a-12: var(--colors-indigo-light-a-12);--colors-indigo-p3-1: var(--colors-indigo-light-p3-1);--colors-indigo-p3-2: var(--colors-indigo-light-p3-2);--colors-indigo-p3-3: var(--colors-indigo-light-p3-3);--colors-indigo-p3-4: var(--colors-indigo-light-p3-4);--colors-indigo-p3-5: var(--colors-indigo-light-p3-5);--colors-indigo-p3-6: var(--colors-indigo-light-p3-6);--colors-indigo-p3-7: var(--colors-indigo-light-p3-7);--colors-indigo-p3-8: var(--colors-indigo-light-p3-8);--colors-indigo-p3-9: var(--colors-indigo-light-p3-9);--colors-indigo-p3-10: var(--colors-indigo-light-p3-10);--colors-indigo-p3-11: var(--colors-indigo-light-p3-11);--colors-indigo-p3-12: var(--colors-indigo-light-p3-12);--colors-indigo-p3-a-1: var(--colors-indigo-light-p3-a-1);--colors-indigo-p3-a-2: var(--colors-indigo-light-p3-a-2);--colors-indigo-p3-a-3: var(--colors-indigo-light-p3-a-3);--colors-indigo-p3-a-4: var(--colors-indigo-light-p3-a-4);--colors-indigo-p3-a-5: var(--colors-indigo-light-p3-a-5);--colors-indigo-p3-a-6: var(--colors-indigo-light-p3-a-6);--colors-indigo-p3-a-7: var(--colors-indigo-light-p3-a-7);--colors-indigo-p3-a-8: var(--colors-indigo-light-p3-a-8);--colors-indigo-p3-a-9: var(--colors-indigo-light-p3-a-9);--colors-indigo-p3-a-10: var(--colors-indigo-light-p3-a-10);--colors-indigo-p3-a-11: var(--colors-indigo-light-p3-a-11);--colors-indigo-p3-a-12: var(--colors-indigo-light-p3-a-12);--colors-lime-1: var(--colors-lime-light-1);--colors-lime-2: var(--colors-lime-light-2);--colors-lime-3: var(--colors-lime-light-3);--colors-lime-4: var(--colors-lime-light-4);--colors-lime-5: var(--colors-lime-light-5);--colors-lime-6: var(--colors-lime-light-6);--colors-lime-7: var(--colors-lime-light-7);--colors-lime-8: var(--colors-lime-light-8);--colors-lime-9: var(--colors-lime-light-9);--colors-lime-10: var(--colors-lime-light-10);--colors-lime-11: var(--colors-lime-light-11);--colors-lime-12: var(--colors-lime-light-12);--colors-lime-light-1: #fcfdfa;--colors-lime-light-2: #f8faf3;--colors-lime-light-3: #eef6d6;--colors-lime-light-4: #e2f0bd;--colors-lime-light-5: #d3e7a6;--colors-lime-light-6: #c2da91;--colors-lime-light-7: #abc978;--colors-lime-light-8: #8db654;--colors-lime-light-9: #bdee63;--colors-lime-light-10: #b0e64c;--colors-lime-light-11: #5c7c2f;--colors-lime-light-12: #37401c;--colors-lime-light-a-1: #66990005;--colors-lime-light-a-2: #6b95000c;--colors-lime-light-a-3: #96c80029;--colors-lime-light-a-4: #8fc60042;--colors-lime-light-a-5: #81bb0059;--colors-lime-light-a-6: #72aa006e;--colors-lime-light-a-7: #61990087;--colors-lime-light-a-8: #559200ab;--colors-lime-light-a-9: #93e4009c;--colors-lime-light-a-10: #8fdc00b3;--colors-lime-light-a-11: #375f00d0;--colors-lime-light-a-12: #1e2900e3;--colors-lime-light-p3-1: color(display-p3 .989 .992 .981);--colors-lime-light-p3-2: color(display-p3 .975 .98 .954);--colors-lime-light-p3-3: color(display-p3 .939 .965 .851);--colors-lime-light-p3-4: color(display-p3 .896 .94 .76);--colors-lime-light-p3-5: color(display-p3 .843 .903 .678);--colors-lime-light-p3-6: color(display-p3 .778 .852 .599);--colors-lime-light-p3-7: color(display-p3 .694 .784 .508);--colors-lime-light-p3-8: color(display-p3 .585 .707 .378);--colors-lime-light-p3-9: color(display-p3 .78 .928 .466);--colors-lime-light-p3-10: color(display-p3 .734 .896 .397);--colors-lime-light-p3-11: color(display-p3 .386 .482 .227);--colors-lime-light-p3-12: color(display-p3 .222 .25 .128);--colors-lime-light-p3-a-1: color(display-p3 .412 .608 .02 / .02);--colors-lime-light-p3-a-2: color(display-p3 .514 .592 .024 / .048);--colors-lime-light-p3-a-3: color(display-p3 .584 .765 .008 / .15);--colors-lime-light-p3-a-4: color(display-p3 .561 .757 .004 / .24);--colors-lime-light-p3-a-5: color(display-p3 .514 .698 .004 / .322);--colors-lime-light-p3-a-6: color(display-p3 .443 .627 0 / .4);--colors-lime-light-p3-a-7: color(display-p3 .376 .561 .004 / .491);--colors-lime-light-p3-a-8: color(display-p3 .333 .529 0 / .624);--colors-lime-light-p3-a-9: color(display-p3 .588 .867 0 / .534);--colors-lime-light-p3-a-10: color(display-p3 .561 .827 0 / .604);--colors-lime-light-p3-a-11: color(display-p3 .386 .482 .227);--colors-lime-light-p3-a-12: color(display-p3 .222 .25 .128);--colors-lime-dark-1: #11130c;--colors-lime-dark-2: #151a10;--colors-lime-dark-3: #1f2917;--colors-lime-dark-4: #29371d;--colors-lime-dark-5: #334423;--colors-lime-dark-6: #3d522a;--colors-lime-dark-7: #496231;--colors-lime-dark-8: #577538;--colors-lime-dark-9: #bdee63;--colors-lime-dark-10: #d4ff70;--colors-lime-dark-11: #bde56c;--colors-lime-dark-12: #e3f7ba;--colors-lime-dark-a-1: #11bb0003;--colors-lime-dark-a-2: #78f7000a;--colors-lime-dark-a-3: #9bfd4c1a;--colors-lime-dark-a-4: #a7fe5c29;--colors-lime-dark-a-5: #affe6537;--colors-lime-dark-a-6: #b2fe6d46;--colors-lime-dark-a-7: #b6ff6f57;--colors-lime-dark-a-8: #b6fd6d6c;--colors-lime-dark-a-9: #caff69ed;--colors-lime-dark-a-10: #d4ff70;--colors-lime-dark-a-11: #d1fe77e4;--colors-lime-dark-a-12: #e9febff7;--colors-lime-dark-p3-1: color(display-p3 .067 .073 .048);--colors-lime-dark-p3-2: color(display-p3 .086 .1 .067);--colors-lime-dark-p3-3: color(display-p3 .13 .16 .099);--colors-lime-dark-p3-4: color(display-p3 .172 .214 .126);--colors-lime-dark-p3-5: color(display-p3 .213 .266 .153);--colors-lime-dark-p3-6: color(display-p3 .257 .321 .182);--colors-lime-dark-p3-7: color(display-p3 .307 .383 .215);--colors-lime-dark-p3-8: color(display-p3 .365 .456 .25);--colors-lime-dark-p3-9: color(display-p3 .78 .928 .466);--colors-lime-dark-p3-10: color(display-p3 .865 .995 .519);--colors-lime-dark-p3-11: color(display-p3 .771 .893 .485);--colors-lime-dark-p3-12: color(display-p3 .905 .966 .753);--colors-lime-dark-p3-a-1: color(display-p3 .067 .941 0 / .009);--colors-lime-dark-p3-a-2: color(display-p3 .584 .996 .071 / .038);--colors-lime-dark-p3-a-3: color(display-p3 .69 1 .38 / .101);--colors-lime-dark-p3-a-4: color(display-p3 .729 1 .435 / .16);--colors-lime-dark-p3-a-5: color(display-p3 .745 1 .471 / .215);--colors-lime-dark-p3-a-6: color(display-p3 .769 1 .482 / .274);--colors-lime-dark-p3-a-7: color(display-p3 .769 1 .506 / .341);--colors-lime-dark-p3-a-8: color(display-p3 .784 1 .51 / .416);--colors-lime-dark-p3-a-9: color(display-p3 .839 1 .502 / .925);--colors-lime-dark-p3-a-10: color(display-p3 .871 1 .522 / .996);--colors-lime-dark-p3-a-11: color(display-p3 .771 .893 .485);--colors-lime-dark-p3-a-12: color(display-p3 .905 .966 .753);--colors-lime-a-1: var(--colors-lime-light-a-1);--colors-lime-a-2: var(--colors-lime-light-a-2);--colors-lime-a-3: var(--colors-lime-light-a-3);--colors-lime-a-4: var(--colors-lime-light-a-4);--colors-lime-a-5: var(--colors-lime-light-a-5);--colors-lime-a-6: var(--colors-lime-light-a-6);--colors-lime-a-7: var(--colors-lime-light-a-7);--colors-lime-a-8: var(--colors-lime-light-a-8);--colors-lime-a-9: var(--colors-lime-light-a-9);--colors-lime-a-10: var(--colors-lime-light-a-10);--colors-lime-a-11: var(--colors-lime-light-a-11);--colors-lime-a-12: var(--colors-lime-light-a-12);--colors-lime-p3-1: var(--colors-lime-light-p3-1);--colors-lime-p3-2: var(--colors-lime-light-p3-2);--colors-lime-p3-3: var(--colors-lime-light-p3-3);--colors-lime-p3-4: var(--colors-lime-light-p3-4);--colors-lime-p3-5: var(--colors-lime-light-p3-5);--colors-lime-p3-6: var(--colors-lime-light-p3-6);--colors-lime-p3-7: var(--colors-lime-light-p3-7);--colors-lime-p3-8: var(--colors-lime-light-p3-8);--colors-lime-p3-9: var(--colors-lime-light-p3-9);--colors-lime-p3-10: var(--colors-lime-light-p3-10);--colors-lime-p3-11: var(--colors-lime-light-p3-11);--colors-lime-p3-12: var(--colors-lime-light-p3-12);--colors-lime-p3-a-1: var(--colors-lime-light-p3-a-1);--colors-lime-p3-a-2: var(--colors-lime-light-p3-a-2);--colors-lime-p3-a-3: var(--colors-lime-light-p3-a-3);--colors-lime-p3-a-4: var(--colors-lime-light-p3-a-4);--colors-lime-p3-a-5: var(--colors-lime-light-p3-a-5);--colors-lime-p3-a-6: var(--colors-lime-light-p3-a-6);--colors-lime-p3-a-7: var(--colors-lime-light-p3-a-7);--colors-lime-p3-a-8: var(--colors-lime-light-p3-a-8);--colors-lime-p3-a-9: var(--colors-lime-light-p3-a-9);--colors-lime-p3-a-10: var(--colors-lime-light-p3-a-10);--colors-lime-p3-a-11: var(--colors-lime-light-p3-a-11);--colors-lime-p3-a-12: var(--colors-lime-light-p3-a-12);--colors-orange-1: var(--colors-orange-light-1);--colors-orange-2: var(--colors-orange-light-2);--colors-orange-3: var(--colors-orange-light-3);--colors-orange-4: var(--colors-orange-light-4);--colors-orange-5: var(--colors-orange-light-5);--colors-orange-6: var(--colors-orange-light-6);--colors-orange-7: var(--colors-orange-light-7);--colors-orange-8: var(--colors-orange-light-8);--colors-orange-9: var(--colors-orange-light-9);--colors-orange-10: var(--colors-orange-light-10);--colors-orange-11: var(--colors-orange-light-11);--colors-orange-12: var(--colors-orange-light-12);--colors-orange-light-1: #fefcfb;--colors-orange-light-2: #fff7ed;--colors-orange-light-3: #ffefd6;--colors-orange-light-4: #ffdfb5;--colors-orange-light-5: #ffd19a;--colors-orange-light-6: #ffc182;--colors-orange-light-7: #f5ae73;--colors-orange-light-8: #ec9455;--colors-orange-light-9: #f76b15;--colors-orange-light-10: #ef5f00;--colors-orange-light-11: #cc4e00;--colors-orange-light-12: #582d1d;--colors-orange-light-a-1: #c0400004;--colors-orange-light-a-2: #ff8e0012;--colors-orange-light-a-3: #ff9c0029;--colors-orange-light-a-4: #ff91014a;--colors-orange-light-a-5: #ff8b0065;--colors-orange-light-a-6: #ff81007d;--colors-orange-light-a-7: #ed6c008c;--colors-orange-light-a-8: #e35f00aa;--colors-orange-light-a-9: #f65e00ea;--colors-orange-light-a-10: #ef5f00;--colors-orange-light-a-11: #cc4e00;--colors-orange-light-a-12: #431200e2;--colors-orange-light-p3-1: color(display-p3 .995 .988 .985);--colors-orange-light-p3-2: color(display-p3 .994 .968 .934);--colors-orange-light-p3-3: color(display-p3 .989 .938 .85);--colors-orange-light-p3-4: color(display-p3 1 .874 .687);--colors-orange-light-p3-5: color(display-p3 1 .821 .583);--colors-orange-light-p3-6: color(display-p3 .975 .767 .545);--colors-orange-light-p3-7: color(display-p3 .919 .693 .486);--colors-orange-light-p3-8: color(display-p3 .877 .597 .379);--colors-orange-light-p3-9: color(display-p3 .9 .45 .2);--colors-orange-light-p3-10: color(display-p3 .87 .409 .164);--colors-orange-light-p3-11: color(display-p3 .76 .34 0);--colors-orange-light-p3-12: color(display-p3 .323 .185 .127);--colors-orange-light-p3-a-1: color(display-p3 .757 .267 .024 / .016);--colors-orange-light-p3-a-2: color(display-p3 .886 .533 .008 / .067);--colors-orange-light-p3-a-3: color(display-p3 .922 .584 .008 / .15);--colors-orange-light-p3-a-4: color(display-p3 1 .604 .004 / .314);--colors-orange-light-p3-a-5: color(display-p3 1 .569 .004 / .416);--colors-orange-light-p3-a-6: color(display-p3 .949 .494 .004 / .455);--colors-orange-light-p3-a-7: color(display-p3 .839 .408 0 / .514);--colors-orange-light-p3-a-8: color(display-p3 .804 .349 0 / .62);--colors-orange-light-p3-a-9: color(display-p3 .878 .314 0 / .8);--colors-orange-light-p3-a-10: color(display-p3 .843 .29 0 / .836);--colors-orange-light-p3-a-11: color(display-p3 .76 .34 0);--colors-orange-light-p3-a-12: color(display-p3 .323 .185 .127);--colors-orange-dark-1: #17120e;--colors-orange-dark-2: #1e160f;--colors-orange-dark-3: #331e0b;--colors-orange-dark-4: #462100;--colors-orange-dark-5: #562800;--colors-orange-dark-6: #66350c;--colors-orange-dark-7: #7e451d;--colors-orange-dark-8: #a35829;--colors-orange-dark-9: #f76b15;--colors-orange-dark-10: #ff801f;--colors-orange-dark-11: #ffa057;--colors-orange-dark-12: #ffe0c2;--colors-orange-dark-a-1: #ec360007;--colors-orange-dark-a-2: #fe6d000e;--colors-orange-dark-a-3: #fb6a0025;--colors-orange-dark-a-4: #ff590039;--colors-orange-dark-a-5: #ff61004a;--colors-orange-dark-a-6: #fd75045c;--colors-orange-dark-a-7: #ff832c75;--colors-orange-dark-a-8: #fe84389d;--colors-orange-dark-a-9: #fe6d15f7;--colors-orange-dark-a-10: #ff801f;--colors-orange-dark-a-11: #ffa057;--colors-orange-dark-a-12: #ffe0c2;--colors-orange-dark-p3-1: color(display-p3 .088 .07 .057);--colors-orange-dark-p3-2: color(display-p3 .113 .089 .061);--colors-orange-dark-p3-3: color(display-p3 .189 .12 .056);--colors-orange-dark-p3-4: color(display-p3 .262 .132 0);--colors-orange-dark-p3-5: color(display-p3 .315 .168 .016);--colors-orange-dark-p3-6: color(display-p3 .376 .219 .088);--colors-orange-dark-p3-7: color(display-p3 .465 .283 .147);--colors-orange-dark-p3-8: color(display-p3 .601 .359 .201);--colors-orange-dark-p3-9: color(display-p3 .9 .45 .2);--colors-orange-dark-p3-10: color(display-p3 .98 .51 .23);--colors-orange-dark-p3-11: color(display-p3 1 .63 .38);--colors-orange-dark-p3-12: color(display-p3 .98 .883 .775);--colors-orange-dark-p3-a-1: color(display-p3 .961 .247 0 / .022);--colors-orange-dark-p3-a-2: color(display-p3 .992 .529 0 / .051);--colors-orange-dark-p3-a-3: color(display-p3 .996 .486 0 / .131);--colors-orange-dark-p3-a-4: color(display-p3 .996 .384 0 / .211);--colors-orange-dark-p3-a-5: color(display-p3 1 .455 0 / .265);--colors-orange-dark-p3-a-6: color(display-p3 1 .529 .129 / .332);--colors-orange-dark-p3-a-7: color(display-p3 1 .569 .251 / .429);--colors-orange-dark-p3-a-8: color(display-p3 1 .584 .302 / .572);--colors-orange-dark-p3-a-9: color(display-p3 1 .494 .216 / .895);--colors-orange-dark-p3-a-10: color(display-p3 1 .522 .235 / .979);--colors-orange-dark-p3-a-11: color(display-p3 1 .63 .38);--colors-orange-dark-p3-a-12: color(display-p3 .98 .883 .775);--colors-orange-a-1: var(--colors-orange-light-a-1);--colors-orange-a-2: var(--colors-orange-light-a-2);--colors-orange-a-3: var(--colors-orange-light-a-3);--colors-orange-a-4: var(--colors-orange-light-a-4);--colors-orange-a-5: var(--colors-orange-light-a-5);--colors-orange-a-6: var(--colors-orange-light-a-6);--colors-orange-a-7: var(--colors-orange-light-a-7);--colors-orange-a-8: var(--colors-orange-light-a-8);--colors-orange-a-9: var(--colors-orange-light-a-9);--colors-orange-a-10: var(--colors-orange-light-a-10);--colors-orange-a-11: var(--colors-orange-light-a-11);--colors-orange-a-12: var(--colors-orange-light-a-12);--colors-orange-p3-1: var(--colors-orange-light-p3-1);--colors-orange-p3-2: var(--colors-orange-light-p3-2);--colors-orange-p3-3: var(--colors-orange-light-p3-3);--colors-orange-p3-4: var(--colors-orange-light-p3-4);--colors-orange-p3-5: var(--colors-orange-light-p3-5);--colors-orange-p3-6: var(--colors-orange-light-p3-6);--colors-orange-p3-7: var(--colors-orange-light-p3-7);--colors-orange-p3-8: var(--colors-orange-light-p3-8);--colors-orange-p3-9: var(--colors-orange-light-p3-9);--colors-orange-p3-10: var(--colors-orange-light-p3-10);--colors-orange-p3-11: var(--colors-orange-light-p3-11);--colors-orange-p3-12: var(--colors-orange-light-p3-12);--colors-orange-p3-a-1: var(--colors-orange-light-p3-a-1);--colors-orange-p3-a-2: var(--colors-orange-light-p3-a-2);--colors-orange-p3-a-3: var(--colors-orange-light-p3-a-3);--colors-orange-p3-a-4: var(--colors-orange-light-p3-a-4);--colors-orange-p3-a-5: var(--colors-orange-light-p3-a-5);--colors-orange-p3-a-6: var(--colors-orange-light-p3-a-6);--colors-orange-p3-a-7: var(--colors-orange-light-p3-a-7);--colors-orange-p3-a-8: var(--colors-orange-light-p3-a-8);--colors-orange-p3-a-9: var(--colors-orange-light-p3-a-9);--colors-orange-p3-a-10: var(--colors-orange-light-p3-a-10);--colors-orange-p3-a-11: var(--colors-orange-light-p3-a-11);--colors-orange-p3-a-12: var(--colors-orange-light-p3-a-12);--colors-pink-1: var(--colors-pink-light-1);--colors-pink-2: var(--colors-pink-light-2);--colors-pink-3: var(--colors-pink-light-3);--colors-pink-4: var(--colors-pink-light-4);--colors-pink-5: var(--colors-pink-light-5);--colors-pink-6: var(--colors-pink-light-6);--colors-pink-7: var(--colors-pink-light-7);--colors-pink-8: var(--colors-pink-light-8);--colors-pink-9: var(--colors-pink-light-9);--colors-pink-10: var(--colors-pink-light-10);--colors-pink-11: var(--colors-pink-light-11);--colors-pink-12: var(--colors-pink-light-12);--colors-pink-light-1: #fffcfe;--colors-pink-light-2: #fef7fb;--colors-pink-light-3: #fee9f5;--colors-pink-light-4: #fbdcef;--colors-pink-light-5: #f6cee7;--colors-pink-light-6: #efbfdd;--colors-pink-light-7: #e7acd0;--colors-pink-light-8: #dd93c2;--colors-pink-light-9: #d6409f;--colors-pink-light-10: #cf3897;--colors-pink-light-11: #c2298a;--colors-pink-light-12: #651249;--colors-pink-light-a-1: #ff00aa03;--colors-pink-light-a-2: #e0008008;--colors-pink-light-a-3: #f4008c16;--colors-pink-light-a-4: #e2008b23;--colors-pink-light-a-5: #d1008331;--colors-pink-light-a-6: #c0007840;--colors-pink-light-a-7: #b6006f53;--colors-pink-light-a-8: #af006f6c;--colors-pink-light-a-9: #c8007fbf;--colors-pink-light-a-10: #c2007ac7;--colors-pink-light-a-11: #b60074d6;--colors-pink-light-a-12: #59003bed;--colors-pink-light-p3-1: color(display-p3 .998 .989 .996);--colors-pink-light-p3-2: color(display-p3 .992 .97 .985);--colors-pink-light-p3-3: color(display-p3 .981 .917 .96);--colors-pink-light-p3-4: color(display-p3 .963 .867 .932);--colors-pink-light-p3-5: color(display-p3 .939 .815 .899);--colors-pink-light-p3-6: color(display-p3 .907 .756 .859);--colors-pink-light-p3-7: color(display-p3 .869 .683 .81);--colors-pink-light-p3-8: color(display-p3 .825 .59 .751);--colors-pink-light-p3-9: color(display-p3 .775 .297 .61);--colors-pink-light-p3-10: color(display-p3 .748 .27 .581);--colors-pink-light-p3-11: color(display-p3 .698 .219 .528);--colors-pink-light-p3-12: color(display-p3 .363 .101 .279);--colors-pink-light-p3-a-1: color(display-p3 .675 .024 .675 / .012);--colors-pink-light-p3-a-2: color(display-p3 .757 .02 .51 / .032);--colors-pink-light-p3-a-3: color(display-p3 .765 .008 .529 / .083);--colors-pink-light-p3-a-4: color(display-p3 .737 .008 .506 / .134);--colors-pink-light-p3-a-5: color(display-p3 .663 .004 .451 / .185);--colors-pink-light-p3-a-6: color(display-p3 .616 .004 .424 / .244);--colors-pink-light-p3-a-7: color(display-p3 .596 .004 .412 / .318);--colors-pink-light-p3-a-8: color(display-p3 .573 .004 .404 / .412);--colors-pink-light-p3-a-9: color(display-p3 .682 0 .447 / .702);--colors-pink-light-p3-a-10: color(display-p3 .655 0 .424 / .73);--colors-pink-light-p3-a-11: color(display-p3 .698 .219 .528);--colors-pink-light-p3-a-12: color(display-p3 .363 .101 .279);--colors-pink-dark-1: #191117;--colors-pink-dark-2: #21121d;--colors-pink-dark-3: #37172f;--colors-pink-dark-4: #4b143d;--colors-pink-dark-5: #591c47;--colors-pink-dark-6: #692955;--colors-pink-dark-7: #833869;--colors-pink-dark-8: #a84885;--colors-pink-dark-9: #d6409f;--colors-pink-dark-10: #de51a8;--colors-pink-dark-11: #ff8dcc;--colors-pink-dark-12: #fdd1ea;--colors-pink-dark-a-1: #f412bc09;--colors-pink-dark-a-2: #f420bb12;--colors-pink-dark-a-3: #fe37cc29;--colors-pink-dark-a-4: #fc1ec43f;--colors-pink-dark-a-5: #fd35c24e;--colors-pink-dark-a-6: #fd51c75f;--colors-pink-dark-a-7: #fd62c87b;--colors-pink-dark-a-8: #ff68c8a2;--colors-pink-dark-a-9: #fe49bcd4;--colors-pink-dark-a-10: #ff5cc0dc;--colors-pink-dark-a-11: #ff8dcc;--colors-pink-dark-a-12: #ffd3ecfd;--colors-pink-dark-p3-1: color(display-p3 .093 .068 .089);--colors-pink-dark-p3-2: color(display-p3 .121 .073 .11);--colors-pink-dark-p3-3: color(display-p3 .198 .098 .179);--colors-pink-dark-p3-4: color(display-p3 .271 .095 .231);--colors-pink-dark-p3-5: color(display-p3 .32 .127 .273);--colors-pink-dark-p3-6: color(display-p3 .382 .177 .326);--colors-pink-dark-p3-7: color(display-p3 .477 .238 .405);--colors-pink-dark-p3-8: color(display-p3 .612 .304 .51);--colors-pink-dark-p3-9: color(display-p3 .775 .297 .61);--colors-pink-dark-p3-10: color(display-p3 .808 .356 .645);--colors-pink-dark-p3-11: color(display-p3 1 .535 .78);--colors-pink-dark-p3-12: color(display-p3 .964 .826 .912);--colors-pink-dark-p3-a-1: color(display-p3 .984 .071 .855 / .03);--colors-pink-dark-p3-a-2: color(display-p3 1 .2 .8 / .059);--colors-pink-dark-p3-a-3: color(display-p3 1 .294 .886 / .139);--colors-pink-dark-p3-a-4: color(display-p3 1 .192 .82 / .219);--colors-pink-dark-p3-a-5: color(display-p3 1 .282 .827 / .274);--colors-pink-dark-p3-a-6: color(display-p3 1 .396 .835 / .337);--colors-pink-dark-p3-a-7: color(display-p3 1 .459 .831 / .442);--colors-pink-dark-p3-a-8: color(display-p3 1 .478 .827 / .585);--colors-pink-dark-p3-a-9: color(display-p3 1 .373 .784 / .761);--colors-pink-dark-p3-a-10: color(display-p3 1 .435 .792 / .795);--colors-pink-dark-p3-a-11: color(display-p3 1 .535 .78);--colors-pink-dark-p3-a-12: color(display-p3 .964 .826 .912);--colors-pink-a-1: var(--colors-pink-light-a-1);--colors-pink-a-2: var(--colors-pink-light-a-2);--colors-pink-a-3: var(--colors-pink-light-a-3);--colors-pink-a-4: var(--colors-pink-light-a-4);--colors-pink-a-5: var(--colors-pink-light-a-5);--colors-pink-a-6: var(--colors-pink-light-a-6);--colors-pink-a-7: var(--colors-pink-light-a-7);--colors-pink-a-8: var(--colors-pink-light-a-8);--colors-pink-a-9: var(--colors-pink-light-a-9);--colors-pink-a-10: var(--colors-pink-light-a-10);--colors-pink-a-11: var(--colors-pink-light-a-11);--colors-pink-a-12: var(--colors-pink-light-a-12);--colors-pink-p3-1: var(--colors-pink-light-p3-1);--colors-pink-p3-2: var(--colors-pink-light-p3-2);--colors-pink-p3-3: var(--colors-pink-light-p3-3);--colors-pink-p3-4: var(--colors-pink-light-p3-4);--colors-pink-p3-5: var(--colors-pink-light-p3-5);--colors-pink-p3-6: var(--colors-pink-light-p3-6);--colors-pink-p3-7: var(--colors-pink-light-p3-7);--colors-pink-p3-8: var(--colors-pink-light-p3-8);--colors-pink-p3-9: var(--colors-pink-light-p3-9);--colors-pink-p3-10: var(--colors-pink-light-p3-10);--colors-pink-p3-11: var(--colors-pink-light-p3-11);--colors-pink-p3-12: var(--colors-pink-light-p3-12);--colors-pink-p3-a-1: var(--colors-pink-light-p3-a-1);--colors-pink-p3-a-2: var(--colors-pink-light-p3-a-2);--colors-pink-p3-a-3: var(--colors-pink-light-p3-a-3);--colors-pink-p3-a-4: var(--colors-pink-light-p3-a-4);--colors-pink-p3-a-5: var(--colors-pink-light-p3-a-5);--colors-pink-p3-a-6: var(--colors-pink-light-p3-a-6);--colors-pink-p3-a-7: var(--colors-pink-light-p3-a-7);--colors-pink-p3-a-8: var(--colors-pink-light-p3-a-8);--colors-pink-p3-a-9: var(--colors-pink-light-p3-a-9);--colors-pink-p3-a-10: var(--colors-pink-light-p3-a-10);--colors-pink-p3-a-11: var(--colors-pink-light-p3-a-11);--colors-pink-p3-a-12: var(--colors-pink-light-p3-a-12);--colors-purple-1: var(--colors-purple-light-1);--colors-purple-2: var(--colors-purple-light-2);--colors-purple-3: var(--colors-purple-light-3);--colors-purple-4: var(--colors-purple-light-4);--colors-purple-5: var(--colors-purple-light-5);--colors-purple-6: var(--colors-purple-light-6);--colors-purple-7: var(--colors-purple-light-7);--colors-purple-8: var(--colors-purple-light-8);--colors-purple-9: var(--colors-purple-light-9);--colors-purple-10: var(--colors-purple-light-10);--colors-purple-11: var(--colors-purple-light-11);--colors-purple-12: var(--colors-purple-light-12);--colors-purple-light-1: #fefcfe;--colors-purple-light-2: #fbf7fe;--colors-purple-light-3: #f7edfe;--colors-purple-light-4: #f2e2fc;--colors-purple-light-5: #ead5f9;--colors-purple-light-6: #e0c4f4;--colors-purple-light-7: #d1afec;--colors-purple-light-8: #be93e4;--colors-purple-light-9: #8e4ec6;--colors-purple-light-10: #8347b9;--colors-purple-light-11: #8145b5;--colors-purple-light-12: #402060;--colors-purple-light-a-1: #aa00aa03;--colors-purple-light-a-2: #8000e008;--colors-purple-light-a-3: #8e00f112;--colors-purple-light-a-4: #8d00e51d;--colors-purple-light-a-5: #8000db2a;--colors-purple-light-a-6: #7a01d03b;--colors-purple-light-a-7: #6d00c350;--colors-purple-light-a-8: #6600c06c;--colors-purple-light-a-9: #5c00adb1;--colors-purple-light-a-10: #53009eb8;--colors-purple-light-a-11: #52009aba;--colors-purple-light-a-12: #250049df;--colors-purple-light-p3-1: color(display-p3 .995 .988 .996);--colors-purple-light-p3-2: color(display-p3 .983 .971 .993);--colors-purple-light-p3-3: color(display-p3 .963 .931 .989);--colors-purple-light-p3-4: color(display-p3 .937 .888 .981);--colors-purple-light-p3-5: color(display-p3 .904 .837 .966);--colors-purple-light-p3-6: color(display-p3 .86 .774 .942);--colors-purple-light-p3-7: color(display-p3 .799 .69 .91);--colors-purple-light-p3-8: color(display-p3 .719 .583 .874);--colors-purple-light-p3-9: color(display-p3 .523 .318 .751);--colors-purple-light-p3-10: color(display-p3 .483 .289 .7);--colors-purple-light-p3-11: color(display-p3 .473 .281 .687);--colors-purple-light-p3-12: color(display-p3 .234 .132 .363);--colors-purple-light-p3-a-1: color(display-p3 .675 .024 .675 / .012);--colors-purple-light-p3-a-2: color(display-p3 .443 .024 .722 / .028);--colors-purple-light-p3-a-3: color(display-p3 .506 .008 .835 / .071);--colors-purple-light-p3-a-4: color(display-p3 .451 .004 .831 / .114);--colors-purple-light-p3-a-5: color(display-p3 .431 .004 .788 / .165);--colors-purple-light-p3-a-6: color(display-p3 .384 .004 .745 / .228);--colors-purple-light-p3-a-7: color(display-p3 .357 .004 .71 / .31);--colors-purple-light-p3-a-8: color(display-p3 .322 .004 .702 / .416);--colors-purple-light-p3-a-9: color(display-p3 .298 0 .639 / .683);--colors-purple-light-p3-a-10: color(display-p3 .271 0 .58 / .71);--colors-purple-light-p3-a-11: color(display-p3 .473 .281 .687);--colors-purple-light-p3-a-12: color(display-p3 .234 .132 .363);--colors-purple-dark-1: #18111b;--colors-purple-dark-2: #1e1523;--colors-purple-dark-3: #301c3b;--colors-purple-dark-4: #3d224e;--colors-purple-dark-5: #48295c;--colors-purple-dark-6: #54346b;--colors-purple-dark-7: #664282;--colors-purple-dark-8: #8457aa;--colors-purple-dark-9: #8e4ec6;--colors-purple-dark-10: #9a5cd0;--colors-purple-dark-11: #d19dff;--colors-purple-dark-12: #ecd9fa;--colors-purple-dark-a-1: #b412f90b;--colors-purple-dark-a-2: #b744f714;--colors-purple-dark-a-3: #c150ff2d;--colors-purple-dark-a-4: #bb53fd42;--colors-purple-dark-a-5: #be5cfd51;--colors-purple-dark-a-6: #c16dfd61;--colors-purple-dark-a-7: #c378fd7a;--colors-purple-dark-a-8: #c47effa4;--colors-purple-dark-a-9: #b661ffc2;--colors-purple-dark-a-10: #bc6fffcd;--colors-purple-dark-a-11: #d19dff;--colors-purple-dark-a-12: #f1ddfffa;--colors-purple-dark-p3-1: color(display-p3 .09 .068 .103);--colors-purple-dark-p3-2: color(display-p3 .113 .082 .134);--colors-purple-dark-p3-3: color(display-p3 .175 .112 .224);--colors-purple-dark-p3-4: color(display-p3 .224 .137 .297);--colors-purple-dark-p3-5: color(display-p3 .264 .167 .349);--colors-purple-dark-p3-6: color(display-p3 .311 .208 .406);--colors-purple-dark-p3-7: color(display-p3 .381 .266 .496);--colors-purple-dark-p3-8: color(display-p3 .49 .349 .649);--colors-purple-dark-p3-9: color(display-p3 .523 .318 .751);--colors-purple-dark-p3-10: color(display-p3 .57 .373 .791);--colors-purple-dark-p3-11: color(display-p3 .8 .62 1);--colors-purple-dark-p3-12: color(display-p3 .913 .854 .971);--colors-purple-dark-p3-a-1: color(display-p3 .686 .071 .996 / .038);--colors-purple-dark-p3-a-2: color(display-p3 .722 .286 .996 / .072);--colors-purple-dark-p3-a-3: color(display-p3 .718 .349 .996 / .169);--colors-purple-dark-p3-a-4: color(display-p3 .702 .353 1 / .248);--colors-purple-dark-p3-a-5: color(display-p3 .718 .404 1 / .303);--colors-purple-dark-p3-a-6: color(display-p3 .733 .455 1 / .366);--colors-purple-dark-p3-a-7: color(display-p3 .753 .506 1 / .458);--colors-purple-dark-p3-a-8: color(display-p3 .749 .522 1 / .622);--colors-purple-dark-p3-a-9: color(display-p3 .686 .408 1 / .736);--colors-purple-dark-p3-a-10: color(display-p3 .71 .459 1 / .778);--colors-purple-dark-p3-a-11: color(display-p3 .8 .62 1);--colors-purple-dark-p3-a-12: color(display-p3 .913 .854 .971);--colors-purple-a-1: var(--colors-purple-light-a-1);--colors-purple-a-2: var(--colors-purple-light-a-2);--colors-purple-a-3: var(--colors-purple-light-a-3);--colors-purple-a-4: var(--colors-purple-light-a-4);--colors-purple-a-5: var(--colors-purple-light-a-5);--colors-purple-a-6: var(--colors-purple-light-a-6);--colors-purple-a-7: var(--colors-purple-light-a-7);--colors-purple-a-8: var(--colors-purple-light-a-8);--colors-purple-a-9: var(--colors-purple-light-a-9);--colors-purple-a-10: var(--colors-purple-light-a-10);--colors-purple-a-11: var(--colors-purple-light-a-11);--colors-purple-a-12: var(--colors-purple-light-a-12);--colors-purple-p3-1: var(--colors-purple-light-p3-1);--colors-purple-p3-2: var(--colors-purple-light-p3-2);--colors-purple-p3-3: var(--colors-purple-light-p3-3);--colors-purple-p3-4: var(--colors-purple-light-p3-4);--colors-purple-p3-5: var(--colors-purple-light-p3-5);--colors-purple-p3-6: var(--colors-purple-light-p3-6);--colors-purple-p3-7: var(--colors-purple-light-p3-7);--colors-purple-p3-8: var(--colors-purple-light-p3-8);--colors-purple-p3-9: var(--colors-purple-light-p3-9);--colors-purple-p3-10: var(--colors-purple-light-p3-10);--colors-purple-p3-11: var(--colors-purple-light-p3-11);--colors-purple-p3-12: var(--colors-purple-light-p3-12);--colors-purple-p3-a-1: var(--colors-purple-light-p3-a-1);--colors-purple-p3-a-2: var(--colors-purple-light-p3-a-2);--colors-purple-p3-a-3: var(--colors-purple-light-p3-a-3);--colors-purple-p3-a-4: var(--colors-purple-light-p3-a-4);--colors-purple-p3-a-5: var(--colors-purple-light-p3-a-5);--colors-purple-p3-a-6: var(--colors-purple-light-p3-a-6);--colors-purple-p3-a-7: var(--colors-purple-light-p3-a-7);--colors-purple-p3-a-8: var(--colors-purple-light-p3-a-8);--colors-purple-p3-a-9: var(--colors-purple-light-p3-a-9);--colors-purple-p3-a-10: var(--colors-purple-light-p3-a-10);--colors-purple-p3-a-11: var(--colors-purple-light-p3-a-11);--colors-purple-p3-a-12: var(--colors-purple-light-p3-a-12);--colors-red-1: var(--colors-red-light-1);--colors-red-2: var(--colors-red-light-2);--colors-red-3: var(--colors-red-light-3);--colors-red-4: var(--colors-red-light-4);--colors-red-5: var(--colors-red-light-5);--colors-red-6: var(--colors-red-light-6);--colors-red-7: var(--colors-red-light-7);--colors-red-8: var(--colors-red-light-8);--colors-red-9: var(--colors-red-light-9);--colors-red-10: var(--colors-red-light-10);--colors-red-11: var(--colors-red-light-11);--colors-red-12: var(--colors-red-light-12);--colors-red-light-1: #fffcfc;--colors-red-light-2: #fff7f7;--colors-red-light-3: #feebec;--colors-red-light-4: #ffdbdc;--colors-red-light-5: #ffcdce;--colors-red-light-6: #fdbdbe;--colors-red-light-7: #f4a9aa;--colors-red-light-8: #eb8e90;--colors-red-light-9: #e5484d;--colors-red-light-10: #dc3e42;--colors-red-light-11: #ce2c31;--colors-red-light-12: #641723;--colors-red-light-a-1: #ff000003;--colors-red-light-a-2: #ff000008;--colors-red-light-a-3: #f3000d14;--colors-red-light-a-4: #ff000824;--colors-red-light-a-5: #ff000632;--colors-red-light-a-6: #f8000442;--colors-red-light-a-7: #df000356;--colors-red-light-a-8: #d2000571;--colors-red-light-a-9: #db0007b7;--colors-red-light-a-10: #d10005c1;--colors-red-light-a-11: #c40006d3;--colors-red-light-a-12: #55000de8;--colors-red-light-p3-1: color(display-p3 .998 .989 .988);--colors-red-light-p3-2: color(display-p3 .995 .971 .971);--colors-red-light-p3-3: color(display-p3 .985 .925 .925);--colors-red-light-p3-4: color(display-p3 .999 .866 .866);--colors-red-light-p3-5: color(display-p3 .984 .812 .811);--colors-red-light-p3-6: color(display-p3 .955 .751 .749);--colors-red-light-p3-7: color(display-p3 .915 .675 .672);--colors-red-light-p3-8: color(display-p3 .872 .575 .572);--colors-red-light-p3-9: color(display-p3 .83 .329 .324);--colors-red-light-p3-10: color(display-p3 .798 .294 .285);--colors-red-light-p3-11: color(display-p3 .744 .234 .222);--colors-red-light-p3-12: color(display-p3 .36 .115 .143);--colors-red-light-p3-a-1: color(display-p3 .675 .024 .024 / .012);--colors-red-light-p3-a-2: color(display-p3 .863 .024 .024 / .028);--colors-red-light-p3-a-3: color(display-p3 .792 .008 .008 / .075);--colors-red-light-p3-a-4: color(display-p3 1 .008 .008 / .134);--colors-red-light-p3-a-5: color(display-p3 .918 .008 .008 / .189);--colors-red-light-p3-a-6: color(display-p3 .831 .02 .004 / .251);--colors-red-light-p3-a-7: color(display-p3 .741 .016 .004 / .33);--colors-red-light-p3-a-8: color(display-p3 .698 .012 .004 / .428);--colors-red-light-p3-a-9: color(display-p3 .749 .008 0 / .675);--colors-red-light-p3-a-10: color(display-p3 .714 .012 0 / .714);--colors-red-light-p3-a-11: color(display-p3 .744 .234 .222);--colors-red-light-p3-a-12: color(display-p3 .36 .115 .143);--colors-red-dark-1: #191111;--colors-red-dark-2: #201314;--colors-red-dark-3: #3b1219;--colors-red-dark-4: #500f1c;--colors-red-dark-5: #611623;--colors-red-dark-6: #72232d;--colors-red-dark-7: #8c333a;--colors-red-dark-8: #b54548;--colors-red-dark-9: #e5484d;--colors-red-dark-10: #ec5d5e;--colors-red-dark-11: #ff9592;--colors-red-dark-12: #ffd1d9;--colors-red-dark-a-1: #f4121209;--colors-red-dark-a-2: #f22f3e11;--colors-red-dark-a-3: #ff173f2d;--colors-red-dark-a-4: #fe0a3b44;--colors-red-dark-a-5: #ff204756;--colors-red-dark-a-6: #ff3e5668;--colors-red-dark-a-7: #ff536184;--colors-red-dark-a-8: #ff5d61b0;--colors-red-dark-a-9: #fe4e54e4;--colors-red-dark-a-10: #ff6465eb;--colors-red-dark-a-11: #ff9592;--colors-red-dark-a-12: #ffd1d9;--colors-red-dark-p3-1: color(display-p3 .093 .068 .067);--colors-red-dark-p3-2: color(display-p3 .118 .077 .079);--colors-red-dark-p3-3: color(display-p3 .211 .081 .099);--colors-red-dark-p3-4: color(display-p3 .287 .079 .113);--colors-red-dark-p3-5: color(display-p3 .348 .11 .142);--colors-red-dark-p3-6: color(display-p3 .414 .16 .183);--colors-red-dark-p3-7: color(display-p3 .508 .224 .236);--colors-red-dark-p3-8: color(display-p3 .659 .298 .297);--colors-red-dark-p3-9: color(display-p3 .83 .329 .324);--colors-red-dark-p3-10: color(display-p3 .861 .403 .387);--colors-red-dark-p3-11: color(display-p3 1 .57 .55);--colors-red-dark-p3-12: color(display-p3 .971 .826 .852);--colors-red-dark-p3-a-1: color(display-p3 .984 .071 .071 / .03);--colors-red-dark-p3-a-2: color(display-p3 .996 .282 .282 / .055);--colors-red-dark-p3-a-3: color(display-p3 1 .169 .271 / .156);--colors-red-dark-p3-a-4: color(display-p3 1 .118 .267 / .236);--colors-red-dark-p3-a-5: color(display-p3 1 .212 .314 / .303);--colors-red-dark-p3-a-6: color(display-p3 1 .318 .38 / .374);--colors-red-dark-p3-a-7: color(display-p3 1 .4 .424 / .475);--colors-red-dark-p3-a-8: color(display-p3 1 .431 .431 / .635);--colors-red-dark-p3-a-9: color(display-p3 1 .388 .384 / .82);--colors-red-dark-p3-a-10: color(display-p3 1 .463 .447 / .853);--colors-red-dark-p3-a-11: color(display-p3 1 .57 .55);--colors-red-dark-p3-a-12: color(display-p3 .971 .826 .852);--colors-red-a-1: var(--colors-red-light-a-1);--colors-red-a-2: var(--colors-red-light-a-2);--colors-red-a-3: var(--colors-red-light-a-3);--colors-red-a-4: var(--colors-red-light-a-4);--colors-red-a-5: var(--colors-red-light-a-5);--colors-red-a-6: var(--colors-red-light-a-6);--colors-red-a-7: var(--colors-red-light-a-7);--colors-red-a-8: var(--colors-red-light-a-8);--colors-red-a-9: var(--colors-red-light-a-9);--colors-red-a-10: var(--colors-red-light-a-10);--colors-red-a-11: var(--colors-red-light-a-11);--colors-red-a-12: var(--colors-red-light-a-12);--colors-red-p3-1: var(--colors-red-light-p3-1);--colors-red-p3-2: var(--colors-red-light-p3-2);--colors-red-p3-3: var(--colors-red-light-p3-3);--colors-red-p3-4: var(--colors-red-light-p3-4);--colors-red-p3-5: var(--colors-red-light-p3-5);--colors-red-p3-6: var(--colors-red-light-p3-6);--colors-red-p3-7: var(--colors-red-light-p3-7);--colors-red-p3-8: var(--colors-red-light-p3-8);--colors-red-p3-9: var(--colors-red-light-p3-9);--colors-red-p3-10: var(--colors-red-light-p3-10);--colors-red-p3-11: var(--colors-red-light-p3-11);--colors-red-p3-12: var(--colors-red-light-p3-12);--colors-red-p3-a-1: var(--colors-red-light-p3-a-1);--colors-red-p3-a-2: var(--colors-red-light-p3-a-2);--colors-red-p3-a-3: var(--colors-red-light-p3-a-3);--colors-red-p3-a-4: var(--colors-red-light-p3-a-4);--colors-red-p3-a-5: var(--colors-red-light-p3-a-5);--colors-red-p3-a-6: var(--colors-red-light-p3-a-6);--colors-red-p3-a-7: var(--colors-red-light-p3-a-7);--colors-red-p3-a-8: var(--colors-red-light-p3-a-8);--colors-red-p3-a-9: var(--colors-red-light-p3-a-9);--colors-red-p3-a-10: var(--colors-red-light-p3-a-10);--colors-red-p3-a-11: var(--colors-red-light-p3-a-11);--colors-red-p3-a-12: var(--colors-red-light-p3-a-12);--colors-ruby-1: var(--colors-ruby-light-1);--colors-ruby-2: var(--colors-ruby-light-2);--colors-ruby-3: var(--colors-ruby-light-3);--colors-ruby-4: var(--colors-ruby-light-4);--colors-ruby-5: var(--colors-ruby-light-5);--colors-ruby-6: var(--colors-ruby-light-6);--colors-ruby-7: var(--colors-ruby-light-7);--colors-ruby-8: var(--colors-ruby-light-8);--colors-ruby-9: var(--colors-ruby-light-9);--colors-ruby-10: var(--colors-ruby-light-10);--colors-ruby-11: var(--colors-ruby-light-11);--colors-ruby-12: var(--colors-ruby-light-12);--colors-ruby-light-1: #fffcfd;--colors-ruby-light-2: #fff7f8;--colors-ruby-light-3: #feeaed;--colors-ruby-light-4: #ffdce1;--colors-ruby-light-5: #ffced6;--colors-ruby-light-6: #f8bfc8;--colors-ruby-light-7: #efacb8;--colors-ruby-light-8: #e592a3;--colors-ruby-light-9: #e54666;--colors-ruby-light-10: #dc3b5d;--colors-ruby-light-11: #ca244d;--colors-ruby-light-12: #64172b;--colors-ruby-light-a-1: #ff005503;--colors-ruby-light-a-2: #ff002008;--colors-ruby-light-a-3: #f3002515;--colors-ruby-light-a-4: #ff002523;--colors-ruby-light-a-5: #ff002a31;--colors-ruby-light-a-6: #e4002440;--colors-ruby-light-a-7: #ce002553;--colors-ruby-light-a-8: #c300286d;--colors-ruby-light-a-9: #db002cb9;--colors-ruby-light-a-10: #d2002cc4;--colors-ruby-light-a-11: #c10030db;--colors-ruby-light-a-12: #550016e8;--colors-ruby-light-p3-1: color(display-p3 .998 .989 .992);--colors-ruby-light-p3-2: color(display-p3 .995 .971 .974);--colors-ruby-light-p3-3: color(display-p3 .983 .92 .928);--colors-ruby-light-p3-4: color(display-p3 .987 .869 .885);--colors-ruby-light-p3-5: color(display-p3 .968 .817 .839);--colors-ruby-light-p3-6: color(display-p3 .937 .758 .786);--colors-ruby-light-p3-7: color(display-p3 .897 .685 .721);--colors-ruby-light-p3-8: color(display-p3 .851 .588 .639);--colors-ruby-light-p3-9: color(display-p3 .83 .323 .408);--colors-ruby-light-p3-10: color(display-p3 .795 .286 .375);--colors-ruby-light-p3-11: color(display-p3 .728 .211 .311);--colors-ruby-light-p3-12: color(display-p3 .36 .115 .171);--colors-ruby-light-p3-a-1: color(display-p3 .675 .024 .349 / .012);--colors-ruby-light-p3-a-2: color(display-p3 .863 .024 .024 / .028);--colors-ruby-light-p3-a-3: color(display-p3 .804 .008 .11 / .079);--colors-ruby-light-p3-a-4: color(display-p3 .91 .008 .125 / .13);--colors-ruby-light-p3-a-5: color(display-p3 .831 .004 .133 / .185);--colors-ruby-light-p3-a-6: color(display-p3 .745 .004 .118 / .244);--colors-ruby-light-p3-a-7: color(display-p3 .678 .004 .114 / .314);--colors-ruby-light-p3-a-8: color(display-p3 .639 .004 .125 / .412);--colors-ruby-light-p3-a-9: color(display-p3 .753 0 .129 / .679);--colors-ruby-light-p3-a-10: color(display-p3 .714 0 .125 / .714);--colors-ruby-light-p3-a-11: color(display-p3 .728 .211 .311);--colors-ruby-light-p3-a-12: color(display-p3 .36 .115 .171);--colors-ruby-dark-1: #191113;--colors-ruby-dark-2: #1e1517;--colors-ruby-dark-3: #3a141e;--colors-ruby-dark-4: #4e1325;--colors-ruby-dark-5: #5e1a2e;--colors-ruby-dark-6: #6f2539;--colors-ruby-dark-7: #883447;--colors-ruby-dark-8: #b3445a;--colors-ruby-dark-9: #e54666;--colors-ruby-dark-10: #ec5a72;--colors-ruby-dark-11: #ff949d;--colors-ruby-dark-12: #fed2e1;--colors-ruby-dark-a-1: #f4124a09;--colors-ruby-dark-a-2: #fe5a7f0e;--colors-ruby-dark-a-3: #ff235d2c;--colors-ruby-dark-a-4: #fd195e42;--colors-ruby-dark-a-5: #fe2d6b53;--colors-ruby-dark-a-6: #ff447665;--colors-ruby-dark-a-7: #ff577d80;--colors-ruby-dark-a-8: #ff5c7cae;--colors-ruby-dark-a-9: #fe4c70e4;--colors-ruby-dark-a-10: #ff617beb;--colors-ruby-dark-a-11: #ff949d;--colors-ruby-dark-a-12: #ffd3e2fe;--colors-ruby-dark-p3-1: color(display-p3 .093 .068 .074);--colors-ruby-dark-p3-2: color(display-p3 .113 .083 .089);--colors-ruby-dark-p3-3: color(display-p3 .208 .088 .117);--colors-ruby-dark-p3-4: color(display-p3 .279 .092 .147);--colors-ruby-dark-p3-5: color(display-p3 .337 .12 .18);--colors-ruby-dark-p3-6: color(display-p3 .401 .166 .223);--colors-ruby-dark-p3-7: color(display-p3 .495 .224 .281);--colors-ruby-dark-p3-8: color(display-p3 .652 .295 .359);--colors-ruby-dark-p3-9: color(display-p3 .83 .323 .408);--colors-ruby-dark-p3-10: color(display-p3 .857 .392 .455);--colors-ruby-dark-p3-11: color(display-p3 1 .57 .59);--colors-ruby-dark-p3-12: color(display-p3 .968 .83 .88);--colors-ruby-dark-p3-a-1: color(display-p3 .984 .071 .329 / .03);--colors-ruby-dark-p3-a-2: color(display-p3 .992 .376 .529 / .051);--colors-ruby-dark-p3-a-3: color(display-p3 .996 .196 .404 / .152);--colors-ruby-dark-p3-a-4: color(display-p3 1 .173 .416 / .227);--colors-ruby-dark-p3-a-5: color(display-p3 1 .259 .459 / .29);--colors-ruby-dark-p3-a-6: color(display-p3 1 .341 .506 / .358);--colors-ruby-dark-p3-a-7: color(display-p3 1 .412 .541 / .458);--colors-ruby-dark-p3-a-8: color(display-p3 1 .431 .537 / .627);--colors-ruby-dark-p3-a-9: color(display-p3 1 .376 .482 / .82);--colors-ruby-dark-p3-a-10: color(display-p3 1 .447 .522 / .849);--colors-ruby-dark-p3-a-11: color(display-p3 1 .57 .59);--colors-ruby-dark-p3-a-12: color(display-p3 .968 .83 .88);--colors-ruby-a-1: var(--colors-ruby-light-a-1);--colors-ruby-a-2: var(--colors-ruby-light-a-2);--colors-ruby-a-3: var(--colors-ruby-light-a-3);--colors-ruby-a-4: var(--colors-ruby-light-a-4);--colors-ruby-a-5: var(--colors-ruby-light-a-5);--colors-ruby-a-6: var(--colors-ruby-light-a-6);--colors-ruby-a-7: var(--colors-ruby-light-a-7);--colors-ruby-a-8: var(--colors-ruby-light-a-8);--colors-ruby-a-9: var(--colors-ruby-light-a-9);--colors-ruby-a-10: var(--colors-ruby-light-a-10);--colors-ruby-a-11: var(--colors-ruby-light-a-11);--colors-ruby-a-12: var(--colors-ruby-light-a-12);--colors-ruby-p3-1: var(--colors-ruby-light-p3-1);--colors-ruby-p3-2: var(--colors-ruby-light-p3-2);--colors-ruby-p3-3: var(--colors-ruby-light-p3-3);--colors-ruby-p3-4: var(--colors-ruby-light-p3-4);--colors-ruby-p3-5: var(--colors-ruby-light-p3-5);--colors-ruby-p3-6: var(--colors-ruby-light-p3-6);--colors-ruby-p3-7: var(--colors-ruby-light-p3-7);--colors-ruby-p3-8: var(--colors-ruby-light-p3-8);--colors-ruby-p3-9: var(--colors-ruby-light-p3-9);--colors-ruby-p3-10: var(--colors-ruby-light-p3-10);--colors-ruby-p3-11: var(--colors-ruby-light-p3-11);--colors-ruby-p3-12: var(--colors-ruby-light-p3-12);--colors-ruby-p3-a-1: var(--colors-ruby-light-p3-a-1);--colors-ruby-p3-a-2: var(--colors-ruby-light-p3-a-2);--colors-ruby-p3-a-3: var(--colors-ruby-light-p3-a-3);--colors-ruby-p3-a-4: var(--colors-ruby-light-p3-a-4);--colors-ruby-p3-a-5: var(--colors-ruby-light-p3-a-5);--colors-ruby-p3-a-6: var(--colors-ruby-light-p3-a-6);--colors-ruby-p3-a-7: var(--colors-ruby-light-p3-a-7);--colors-ruby-p3-a-8: var(--colors-ruby-light-p3-a-8);--colors-ruby-p3-a-9: var(--colors-ruby-light-p3-a-9);--colors-ruby-p3-a-10: var(--colors-ruby-light-p3-a-10);--colors-ruby-p3-a-11: var(--colors-ruby-light-p3-a-11);--colors-ruby-p3-a-12: var(--colors-ruby-light-p3-a-12);--colors-teal-1: var(--colors-teal-light-1);--colors-teal-2: var(--colors-teal-light-2);--colors-teal-3: var(--colors-teal-light-3);--colors-teal-4: var(--colors-teal-light-4);--colors-teal-5: var(--colors-teal-light-5);--colors-teal-6: var(--colors-teal-light-6);--colors-teal-7: var(--colors-teal-light-7);--colors-teal-8: var(--colors-teal-light-8);--colors-teal-9: var(--colors-teal-light-9);--colors-teal-10: var(--colors-teal-light-10);--colors-teal-11: var(--colors-teal-light-11);--colors-teal-12: var(--colors-teal-light-12);--colors-teal-light-1: #fafefd;--colors-teal-light-2: #f3fbf9;--colors-teal-light-3: #e0f8f3;--colors-teal-light-4: #ccf3ea;--colors-teal-light-5: #b8eae0;--colors-teal-light-6: #a1ded2;--colors-teal-light-7: #83cdc1;--colors-teal-light-8: #53b9ab;--colors-teal-light-9: #12a594;--colors-teal-light-10: #0d9b8a;--colors-teal-light-11: #008573;--colors-teal-light-12: #0d3d38;--colors-teal-light-a-1: #00cc9905;--colors-teal-light-a-2: #00aa800c;--colors-teal-light-a-3: #00c69d1f;--colors-teal-light-a-4: #00c39633;--colors-teal-light-a-5: #00b49047;--colors-teal-light-a-6: #00a6855e;--colors-teal-light-a-7: #0099807c;--colors-teal-light-a-8: #009783ac;--colors-teal-light-a-9: #009e8ced;--colors-teal-light-a-10: #009684f2;--colors-teal-light-a-11: #008573;--colors-teal-light-a-12: #00332df2;--colors-teal-light-p3-1: color(display-p3 .983 .996 .992);--colors-teal-light-p3-2: color(display-p3 .958 .983 .976);--colors-teal-light-p3-3: color(display-p3 .895 .971 .952);--colors-teal-light-p3-4: color(display-p3 .831 .949 .92);--colors-teal-light-p3-5: color(display-p3 .761 .914 .878);--colors-teal-light-p3-6: color(display-p3 .682 .864 .825);--colors-teal-light-p3-7: color(display-p3 .581 .798 .756);--colors-teal-light-p3-8: color(display-p3 .433 .716 .671);--colors-teal-light-p3-9: color(display-p3 .297 .637 .581);--colors-teal-light-p3-10: color(display-p3 .275 .599 .542);--colors-teal-light-p3-11: color(display-p3 .08 .5 .43);--colors-teal-light-p3-12: color(display-p3 .11 .235 .219);--colors-teal-light-p3-a-1: color(display-p3 .024 .757 .514 / .016);--colors-teal-light-p3-a-2: color(display-p3 .02 .647 .467 / .044);--colors-teal-light-p3-a-3: color(display-p3 .004 .741 .557 / .106);--colors-teal-light-p3-a-4: color(display-p3 .004 .702 .537 / .169);--colors-teal-light-p3-a-5: color(display-p3 .004 .643 .494 / .24);--colors-teal-light-p3-a-6: color(display-p3 .004 .569 .447 / .318);--colors-teal-light-p3-a-7: color(display-p3 .004 .518 .424 / .42);--colors-teal-light-p3-a-8: color(display-p3 0 .506 .424 / .569);--colors-teal-light-p3-a-9: color(display-p3 0 .482 .404 / .702);--colors-teal-light-p3-a-10: color(display-p3 0 .451 .369 / .726);--colors-teal-light-p3-a-11: color(display-p3 .08 .5 .43);--colors-teal-light-p3-a-12: color(display-p3 .11 .235 .219);--colors-teal-dark-1: #0d1514;--colors-teal-dark-2: #111c1b;--colors-teal-dark-3: #0d2d2a;--colors-teal-dark-4: #023b37;--colors-teal-dark-5: #084843;--colors-teal-dark-6: #145750;--colors-teal-dark-7: #1c6961;--colors-teal-dark-8: #207e73;--colors-teal-dark-9: #12a594;--colors-teal-dark-10: #0eb39e;--colors-teal-dark-11: #0bd8b6;--colors-teal-dark-12: #adf0dd;--colors-teal-dark-a-1: #00deab05;--colors-teal-dark-a-2: #12fbe60c;--colors-teal-dark-a-3: #00ffe61e;--colors-teal-dark-a-4: #00ffe92d;--colors-teal-dark-a-5: #00ffea3b;--colors-teal-dark-a-6: #1cffe84b;--colors-teal-dark-a-7: #2efde85f;--colors-teal-dark-a-8: #32ffe775;--colors-teal-dark-a-9: #13ffe49f;--colors-teal-dark-a-10: #0dffe0ae;--colors-teal-dark-a-11: #0afed5d6;--colors-teal-dark-a-12: #b8ffebef;--colors-teal-dark-p3-1: color(display-p3 .059 .083 .079);--colors-teal-dark-p3-2: color(display-p3 .075 .11 .107);--colors-teal-dark-p3-3: color(display-p3 .087 .175 .165);--colors-teal-dark-p3-4: color(display-p3 .087 .227 .214);--colors-teal-dark-p3-5: color(display-p3 .12 .277 .261);--colors-teal-dark-p3-6: color(display-p3 .162 .335 .314);--colors-teal-dark-p3-7: color(display-p3 .205 .406 .379);--colors-teal-dark-p3-8: color(display-p3 .245 .489 .453);--colors-teal-dark-p3-9: color(display-p3 .297 .637 .581);--colors-teal-dark-p3-10: color(display-p3 .319 .69 .62);--colors-teal-dark-p3-11: color(display-p3 .388 .835 .719);--colors-teal-dark-p3-12: color(display-p3 .734 .934 .87);--colors-teal-dark-p3-a-1: color(display-p3 0 .992 .761 / .017);--colors-teal-dark-p3-a-2: color(display-p3 .235 .988 .902 / .047);--colors-teal-dark-p3-a-3: color(display-p3 .235 1 .898 / .118);--colors-teal-dark-p3-a-4: color(display-p3 .18 .996 .929 / .173);--colors-teal-dark-p3-a-5: color(display-p3 .31 1 .933 / .227);--colors-teal-dark-p3-a-6: color(display-p3 .396 1 .933 / .286);--colors-teal-dark-p3-a-7: color(display-p3 .443 1 .925 / .366);--colors-teal-dark-p3-a-8: color(display-p3 .459 1 .925 / .454);--colors-teal-dark-p3-a-9: color(display-p3 .443 .996 .906 / .61);--colors-teal-dark-p3-a-10: color(display-p3 .439 .996 .89 / .669);--colors-teal-dark-p3-a-11: color(display-p3 .388 .835 .719);--colors-teal-dark-p3-a-12: color(display-p3 .734 .934 .87);--colors-teal-a-1: var(--colors-teal-light-a-1);--colors-teal-a-2: var(--colors-teal-light-a-2);--colors-teal-a-3: var(--colors-teal-light-a-3);--colors-teal-a-4: var(--colors-teal-light-a-4);--colors-teal-a-5: var(--colors-teal-light-a-5);--colors-teal-a-6: var(--colors-teal-light-a-6);--colors-teal-a-7: var(--colors-teal-light-a-7);--colors-teal-a-8: var(--colors-teal-light-a-8);--colors-teal-a-9: var(--colors-teal-light-a-9);--colors-teal-a-10: var(--colors-teal-light-a-10);--colors-teal-a-11: var(--colors-teal-light-a-11);--colors-teal-a-12: var(--colors-teal-light-a-12);--colors-teal-p3-1: var(--colors-teal-light-p3-1);--colors-teal-p3-2: var(--colors-teal-light-p3-2);--colors-teal-p3-3: var(--colors-teal-light-p3-3);--colors-teal-p3-4: var(--colors-teal-light-p3-4);--colors-teal-p3-5: var(--colors-teal-light-p3-5);--colors-teal-p3-6: var(--colors-teal-light-p3-6);--colors-teal-p3-7: var(--colors-teal-light-p3-7);--colors-teal-p3-8: var(--colors-teal-light-p3-8);--colors-teal-p3-9: var(--colors-teal-light-p3-9);--colors-teal-p3-10: var(--colors-teal-light-p3-10);--colors-teal-p3-11: var(--colors-teal-light-p3-11);--colors-teal-p3-12: var(--colors-teal-light-p3-12);--colors-teal-p3-a-1: var(--colors-teal-light-p3-a-1);--colors-teal-p3-a-2: var(--colors-teal-light-p3-a-2);--colors-teal-p3-a-3: var(--colors-teal-light-p3-a-3);--colors-teal-p3-a-4: var(--colors-teal-light-p3-a-4);--colors-teal-p3-a-5: var(--colors-teal-light-p3-a-5);--colors-teal-p3-a-6: var(--colors-teal-light-p3-a-6);--colors-teal-p3-a-7: var(--colors-teal-light-p3-a-7);--colors-teal-p3-a-8: var(--colors-teal-light-p3-a-8);--colors-teal-p3-a-9: var(--colors-teal-light-p3-a-9);--colors-teal-p3-a-10: var(--colors-teal-light-p3-a-10);--colors-teal-p3-a-11: var(--colors-teal-light-p3-a-11);--colors-teal-p3-a-12: var(--colors-teal-light-p3-a-12);--colors-tomato-1: var(--colors-tomato-light-1);--colors-tomato-2: var(--colors-tomato-light-2);--colors-tomato-3: var(--colors-tomato-light-3);--colors-tomato-4: var(--colors-tomato-light-4);--colors-tomato-5: var(--colors-tomato-light-5);--colors-tomato-6: var(--colors-tomato-light-6);--colors-tomato-7: var(--colors-tomato-light-7);--colors-tomato-8: var(--colors-tomato-light-8);--colors-tomato-9: var(--colors-tomato-light-9);--colors-tomato-10: var(--colors-tomato-light-10);--colors-tomato-11: var(--colors-tomato-light-11);--colors-tomato-12: var(--colors-tomato-light-12);--colors-tomato-light-1: #fffcfc;--colors-tomato-light-2: #fff8f7;--colors-tomato-light-3: #feebe7;--colors-tomato-light-4: #ffdcd3;--colors-tomato-light-5: #ffcdc2;--colors-tomato-light-6: #fdbdaf;--colors-tomato-light-7: #f5a898;--colors-tomato-light-8: #ec8e7b;--colors-tomato-light-9: #e54d2e;--colors-tomato-light-10: #dd4425;--colors-tomato-light-11: #d13415;--colors-tomato-light-12: #5c271f;--colors-tomato-light-a-1: #ff000003;--colors-tomato-light-a-2: #ff200008;--colors-tomato-light-a-3: #f52b0018;--colors-tomato-light-a-4: #ff35002c;--colors-tomato-light-a-5: #ff2e003d;--colors-tomato-light-a-6: #f92d0050;--colors-tomato-light-a-7: #e7280067;--colors-tomato-light-a-8: #db250084;--colors-tomato-light-a-9: #df2600d1;--colors-tomato-light-a-10: #d72400da;--colors-tomato-light-a-11: #cd2200ea;--colors-tomato-light-a-12: #460900e0;--colors-tomato-light-p3-1: color(display-p3 .998 .989 .988);--colors-tomato-light-p3-2: color(display-p3 .994 .974 .969);--colors-tomato-light-p3-3: color(display-p3 .985 .924 .909);--colors-tomato-light-p3-4: color(display-p3 .996 .868 .835);--colors-tomato-light-p3-5: color(display-p3 .98 .812 .77);--colors-tomato-light-p3-6: color(display-p3 .953 .75 .698);--colors-tomato-light-p3-7: color(display-p3 .917 .673 .611);--colors-tomato-light-p3-8: color(display-p3 .875 .575 .502);--colors-tomato-light-p3-9: color(display-p3 .831 .345 .231);--colors-tomato-light-p3-10: color(display-p3 .802 .313 .2);--colors-tomato-light-p3-11: color(display-p3 .755 .259 .152);--colors-tomato-light-p3-12: color(display-p3 .335 .165 .132);--colors-tomato-light-p3-a-1: color(display-p3 .675 .024 .024 / .012);--colors-tomato-light-p3-a-2: color(display-p3 .757 .145 .02 / .032);--colors-tomato-light-p3-a-3: color(display-p3 .831 .184 .012 / .091);--colors-tomato-light-p3-a-4: color(display-p3 .976 .192 .004 / .165);--colors-tomato-light-p3-a-5: color(display-p3 .918 .192 .004 / .232);--colors-tomato-light-p3-a-6: color(display-p3 .847 .173 .004 / .302);--colors-tomato-light-p3-a-7: color(display-p3 .788 .165 .004 / .389);--colors-tomato-light-p3-a-8: color(display-p3 .749 .153 .004 / .499);--colors-tomato-light-p3-a-9: color(display-p3 .78 .149 0 / .769);--colors-tomato-light-p3-a-10: color(display-p3 .757 .141 0 / .8);--colors-tomato-light-p3-a-11: color(display-p3 .755 .259 .152);--colors-tomato-light-p3-a-12: color(display-p3 .335 .165 .132);--colors-tomato-dark-1: #181111;--colors-tomato-dark-2: #1f1513;--colors-tomato-dark-3: #391714;--colors-tomato-dark-4: #4e1511;--colors-tomato-dark-5: #5e1c16;--colors-tomato-dark-6: #6e2920;--colors-tomato-dark-7: #853a2d;--colors-tomato-dark-8: #ac4d39;--colors-tomato-dark-9: #e54d2e;--colors-tomato-dark-10: #ec6142;--colors-tomato-dark-11: #ff977d;--colors-tomato-dark-12: #fbd3cb;--colors-tomato-dark-a-1: #f1121208;--colors-tomato-dark-a-2: #ff55330f;--colors-tomato-dark-a-3: #ff35232b;--colors-tomato-dark-a-4: #fd201142;--colors-tomato-dark-a-5: #fe332153;--colors-tomato-dark-a-6: #ff4f3864;--colors-tomato-dark-a-7: #fd644a7d;--colors-tomato-dark-a-8: #fe6d4ea7;--colors-tomato-dark-a-9: #fe5431e4;--colors-tomato-dark-a-10: #ff6847eb;--colors-tomato-dark-a-11: #ff977d;--colors-tomato-dark-a-12: #ffd6cefb;--colors-tomato-dark-p3-1: color(display-p3 .09 .068 .067);--colors-tomato-dark-p3-2: color(display-p3 .115 .084 .076);--colors-tomato-dark-p3-3: color(display-p3 .205 .097 .083);--colors-tomato-dark-p3-4: color(display-p3 .282 .099 .077);--colors-tomato-dark-p3-5: color(display-p3 .339 .129 .101);--colors-tomato-dark-p3-6: color(display-p3 .398 .179 .141);--colors-tomato-dark-p3-7: color(display-p3 .487 .245 .194);--colors-tomato-dark-p3-8: color(display-p3 .629 .322 .248);--colors-tomato-dark-p3-9: color(display-p3 .831 .345 .231);--colors-tomato-dark-p3-10: color(display-p3 .862 .415 .298);--colors-tomato-dark-p3-11: color(display-p3 1 .585 .455);--colors-tomato-dark-p3-12: color(display-p3 .959 .833 .802);--colors-tomato-dark-p3-a-1: color(display-p3 .973 .071 .071 / .026);--colors-tomato-dark-p3-a-2: color(display-p3 .992 .376 .224 / .051);--colors-tomato-dark-p3-a-3: color(display-p3 .996 .282 .176 / .148);--colors-tomato-dark-p3-a-4: color(display-p3 1 .204 .118 / .232);--colors-tomato-dark-p3-a-5: color(display-p3 1 .286 .192 / .29);--colors-tomato-dark-p3-a-6: color(display-p3 1 .392 .278 / .353);--colors-tomato-dark-p3-a-7: color(display-p3 1 .459 .349 / .45);--colors-tomato-dark-p3-a-8: color(display-p3 1 .49 .369 / .601);--colors-tomato-dark-p3-a-9: color(display-p3 1 .408 .267 / .82);--colors-tomato-dark-p3-a-10: color(display-p3 1 .478 .341 / .853);--colors-tomato-dark-p3-a-11: color(display-p3 1 .585 .455);--colors-tomato-dark-p3-a-12: color(display-p3 .959 .833 .802);--colors-tomato-a-1: var(--colors-tomato-light-a-1);--colors-tomato-a-2: var(--colors-tomato-light-a-2);--colors-tomato-a-3: var(--colors-tomato-light-a-3);--colors-tomato-a-4: var(--colors-tomato-light-a-4);--colors-tomato-a-5: var(--colors-tomato-light-a-5);--colors-tomato-a-6: var(--colors-tomato-light-a-6);--colors-tomato-a-7: var(--colors-tomato-light-a-7);--colors-tomato-a-8: var(--colors-tomato-light-a-8);--colors-tomato-a-9: var(--colors-tomato-light-a-9);--colors-tomato-a-10: var(--colors-tomato-light-a-10);--colors-tomato-a-11: var(--colors-tomato-light-a-11);--colors-tomato-a-12: var(--colors-tomato-light-a-12);--colors-tomato-p3-1: var(--colors-tomato-light-p3-1);--colors-tomato-p3-2: var(--colors-tomato-light-p3-2);--colors-tomato-p3-3: var(--colors-tomato-light-p3-3);--colors-tomato-p3-4: var(--colors-tomato-light-p3-4);--colors-tomato-p3-5: var(--colors-tomato-light-p3-5);--colors-tomato-p3-6: var(--colors-tomato-light-p3-6);--colors-tomato-p3-7: var(--colors-tomato-light-p3-7);--colors-tomato-p3-8: var(--colors-tomato-light-p3-8);--colors-tomato-p3-9: var(--colors-tomato-light-p3-9);--colors-tomato-p3-10: var(--colors-tomato-light-p3-10);--colors-tomato-p3-11: var(--colors-tomato-light-p3-11);--colors-tomato-p3-12: var(--colors-tomato-light-p3-12);--colors-tomato-p3-a-1: var(--colors-tomato-light-p3-a-1);--colors-tomato-p3-a-2: var(--colors-tomato-light-p3-a-2);--colors-tomato-p3-a-3: var(--colors-tomato-light-p3-a-3);--colors-tomato-p3-a-4: var(--colors-tomato-light-p3-a-4);--colors-tomato-p3-a-5: var(--colors-tomato-light-p3-a-5);--colors-tomato-p3-a-6: var(--colors-tomato-light-p3-a-6);--colors-tomato-p3-a-7: var(--colors-tomato-light-p3-a-7);--colors-tomato-p3-a-8: var(--colors-tomato-light-p3-a-8);--colors-tomato-p3-a-9: var(--colors-tomato-light-p3-a-9);--colors-tomato-p3-a-10: var(--colors-tomato-light-p3-a-10);--colors-tomato-p3-a-11: var(--colors-tomato-light-p3-a-11);--colors-tomato-p3-a-12: var(--colors-tomato-light-p3-a-12);--colors-violet-1: var(--colors-violet-light-1);--colors-violet-2: var(--colors-violet-light-2);--colors-violet-3: var(--colors-violet-light-3);--colors-violet-4: var(--colors-violet-light-4);--colors-violet-5: var(--colors-violet-light-5);--colors-violet-6: var(--colors-violet-light-6);--colors-violet-7: var(--colors-violet-light-7);--colors-violet-8: var(--colors-violet-light-8);--colors-violet-9: var(--colors-violet-light-9);--colors-violet-10: var(--colors-violet-light-10);--colors-violet-11: var(--colors-violet-light-11);--colors-violet-12: var(--colors-violet-light-12);--colors-violet-light-1: #fdfcfe;--colors-violet-light-2: #faf8ff;--colors-violet-light-3: #f4f0fe;--colors-violet-light-4: #ebe4ff;--colors-violet-light-5: #e1d9ff;--colors-violet-light-6: #d4cafe;--colors-violet-light-7: #c2b5f5;--colors-violet-light-8: #aa99ec;--colors-violet-light-9: #6e56cf;--colors-violet-light-10: #654dc4;--colors-violet-light-11: #6550b9;--colors-violet-light-12: #2f265f;--colors-violet-light-a-1: #5500aa03;--colors-violet-light-a-2: #4900ff07;--colors-violet-light-a-3: #4400ee0f;--colors-violet-light-a-4: #4300ff1b;--colors-violet-light-a-5: #3600ff26;--colors-violet-light-a-6: #3100fb35;--colors-violet-light-a-7: #2d01dd4a;--colors-violet-light-a-8: #2b00d066;--colors-violet-light-a-9: #2400b7a9;--colors-violet-light-a-10: #2300abb2;--colors-violet-light-a-11: #1f0099af;--colors-violet-light-a-12: #0b0043d9;--colors-violet-light-p3-1: color(display-p3 .991 .988 .995);--colors-violet-light-p3-2: color(display-p3 .978 .974 .998);--colors-violet-light-p3-3: color(display-p3 .953 .943 .993);--colors-violet-light-p3-4: color(display-p3 .916 .897 1);--colors-violet-light-p3-5: color(display-p3 .876 .851 1);--colors-violet-light-p3-6: color(display-p3 .825 .793 .981);--colors-violet-light-p3-7: color(display-p3 .752 .712 .943);--colors-violet-light-p3-8: color(display-p3 .654 .602 .902);--colors-violet-light-p3-9: color(display-p3 .417 .341 .784);--colors-violet-light-p3-10: color(display-p3 .381 .306 .741);--colors-violet-light-p3-11: color(display-p3 .383 .317 .702);--colors-violet-light-p3-12: color(display-p3 .179 .15 .359);--colors-violet-light-p3-a-1: color(display-p3 .349 .024 .675 / .012);--colors-violet-light-p3-a-2: color(display-p3 .161 .024 .863 / .028);--colors-violet-light-p3-a-3: color(display-p3 .204 .004 .871 / .059);--colors-violet-light-p3-a-4: color(display-p3 .196 .004 1 / .102);--colors-violet-light-p3-a-5: color(display-p3 .165 .008 1 / .15);--colors-violet-light-p3-a-6: color(display-p3 .153 .004 .906 / .208);--colors-violet-light-p3-a-7: color(display-p3 .141 .004 .796 / .287);--colors-violet-light-p3-a-8: color(display-p3 .133 .004 .753 / .397);--colors-violet-light-p3-a-9: color(display-p3 .114 0 .675 / .659);--colors-violet-light-p3-a-10: color(display-p3 .11 0 .627 / .695);--colors-violet-light-p3-a-11: color(display-p3 .383 .317 .702);--colors-violet-light-p3-a-12: color(display-p3 .179 .15 .359);--colors-violet-dark-1: #14121f;--colors-violet-dark-2: #1b1525;--colors-violet-dark-3: #291f43;--colors-violet-dark-4: #33255b;--colors-violet-dark-5: #3c2e69;--colors-violet-dark-6: #473876;--colors-violet-dark-7: #56468b;--colors-violet-dark-8: #6958ad;--colors-violet-dark-9: #6e56cf;--colors-violet-dark-10: #7d66d9;--colors-violet-dark-11: #baa7ff;--colors-violet-dark-12: #e2ddfe;--colors-violet-dark-a-1: #4422ff0f;--colors-violet-dark-a-2: #853ff916;--colors-violet-dark-a-3: #8354fe36;--colors-violet-dark-a-4: #7d51fd50;--colors-violet-dark-a-5: #845ffd5f;--colors-violet-dark-a-6: #8f6cfd6d;--colors-violet-dark-a-7: #9879ff83;--colors-violet-dark-a-8: #977dfea8;--colors-violet-dark-a-9: #8668ffcc;--colors-violet-dark-a-10: #9176fed7;--colors-violet-dark-a-11: #baa7ff;--colors-violet-dark-a-12: #e3defffe;--colors-violet-dark-p3-1: color(display-p3 .077 .071 .118);--colors-violet-dark-p3-2: color(display-p3 .101 .084 .141);--colors-violet-dark-p3-3: color(display-p3 .154 .123 .256);--colors-violet-dark-p3-4: color(display-p3 .191 .148 .345);--colors-violet-dark-p3-5: color(display-p3 .226 .182 .396);--colors-violet-dark-p3-6: color(display-p3 .269 .223 .449);--colors-violet-dark-p3-7: color(display-p3 .326 .277 .53);--colors-violet-dark-p3-8: color(display-p3 .399 .346 .656);--colors-violet-dark-p3-9: color(display-p3 .417 .341 .784);--colors-violet-dark-p3-10: color(display-p3 .477 .402 .823);--colors-violet-dark-p3-11: color(display-p3 .72 .65 1);--colors-violet-dark-p3-12: color(display-p3 .883 .867 .986);--colors-violet-dark-p3-a-1: color(display-p3 .282 .141 .996 / .055);--colors-violet-dark-p3-a-2: color(display-p3 .51 .263 1 / .08);--colors-violet-dark-p3-a-3: color(display-p3 .494 .337 .996 / .202);--colors-violet-dark-p3-a-4: color(display-p3 .49 .345 1 / .299);--colors-violet-dark-p3-a-5: color(display-p3 .525 .392 1 / .353);--colors-violet-dark-p3-a-6: color(display-p3 .569 .455 1 / .408);--colors-violet-dark-p3-a-7: color(display-p3 .588 .494 1 / .496);--colors-violet-dark-p3-a-8: color(display-p3 .596 .51 1 / .631);--colors-violet-dark-p3-a-9: color(display-p3 .522 .424 1 / .769);--colors-violet-dark-p3-a-10: color(display-p3 .576 .482 1 / .811);--colors-violet-dark-p3-a-11: color(display-p3 .72 .65 1);--colors-violet-dark-p3-a-12: color(display-p3 .883 .867 .986);--colors-violet-a-1: var(--colors-violet-light-a-1);--colors-violet-a-2: var(--colors-violet-light-a-2);--colors-violet-a-3: var(--colors-violet-light-a-3);--colors-violet-a-4: var(--colors-violet-light-a-4);--colors-violet-a-5: var(--colors-violet-light-a-5);--colors-violet-a-6: var(--colors-violet-light-a-6);--colors-violet-a-7: var(--colors-violet-light-a-7);--colors-violet-a-8: var(--colors-violet-light-a-8);--colors-violet-a-9: var(--colors-violet-light-a-9);--colors-violet-a-10: var(--colors-violet-light-a-10);--colors-violet-a-11: var(--colors-violet-light-a-11);--colors-violet-a-12: var(--colors-violet-light-a-12);--colors-violet-p3-1: var(--colors-violet-light-p3-1);--colors-violet-p3-2: var(--colors-violet-light-p3-2);--colors-violet-p3-3: var(--colors-violet-light-p3-3);--colors-violet-p3-4: var(--colors-violet-light-p3-4);--colors-violet-p3-5: var(--colors-violet-light-p3-5);--colors-violet-p3-6: var(--colors-violet-light-p3-6);--colors-violet-p3-7: var(--colors-violet-light-p3-7);--colors-violet-p3-8: var(--colors-violet-light-p3-8);--colors-violet-p3-9: var(--colors-violet-light-p3-9);--colors-violet-p3-10: var(--colors-violet-light-p3-10);--colors-violet-p3-11: var(--colors-violet-light-p3-11);--colors-violet-p3-12: var(--colors-violet-light-p3-12);--colors-violet-p3-a-1: var(--colors-violet-light-p3-a-1);--colors-violet-p3-a-2: var(--colors-violet-light-p3-a-2);--colors-violet-p3-a-3: var(--colors-violet-light-p3-a-3);--colors-violet-p3-a-4: var(--colors-violet-light-p3-a-4);--colors-violet-p3-a-5: var(--colors-violet-light-p3-a-5);--colors-violet-p3-a-6: var(--colors-violet-light-p3-a-6);--colors-violet-p3-a-7: var(--colors-violet-light-p3-a-7);--colors-violet-p3-a-8: var(--colors-violet-light-p3-a-8);--colors-violet-p3-a-9: var(--colors-violet-light-p3-a-9);--colors-violet-p3-a-10: var(--colors-violet-light-p3-a-10);--colors-violet-p3-a-11: var(--colors-violet-light-p3-a-11);--colors-violet-p3-a-12: var(--colors-violet-light-p3-a-12);--colors-yellow-1: var(--colors-yellow-light-1);--colors-yellow-2: var(--colors-yellow-light-2);--colors-yellow-3: var(--colors-yellow-light-3);--colors-yellow-4: var(--colors-yellow-light-4);--colors-yellow-5: var(--colors-yellow-light-5);--colors-yellow-6: var(--colors-yellow-light-6);--colors-yellow-7: var(--colors-yellow-light-7);--colors-yellow-8: var(--colors-yellow-light-8);--colors-yellow-9: var(--colors-yellow-light-9);--colors-yellow-10: var(--colors-yellow-light-10);--colors-yellow-11: var(--colors-yellow-light-11);--colors-yellow-12: var(--colors-yellow-light-12);--colors-yellow-light-1: #fdfdf9;--colors-yellow-light-2: #fefce9;--colors-yellow-light-3: #fffab8;--colors-yellow-light-4: #fff394;--colors-yellow-light-5: #ffe770;--colors-yellow-light-6: #f3d768;--colors-yellow-light-7: #e4c767;--colors-yellow-light-8: #d5ae39;--colors-yellow-light-9: #ffe629;--colors-yellow-light-10: #ffdc00;--colors-yellow-light-11: #9e6c00;--colors-yellow-light-12: #473b1f;--colors-yellow-light-a-1: #aaaa0006;--colors-yellow-light-a-2: #f4dd0016;--colors-yellow-light-a-3: #ffee0047;--colors-yellow-light-a-4: #ffe3016b;--colors-yellow-light-a-5: #ffd5008f;--colors-yellow-light-a-6: #ebbc0097;--colors-yellow-light-a-7: #d2a10098;--colors-yellow-light-a-8: #c99700c6;--colors-yellow-light-a-9: #ffe100d6;--colors-yellow-light-a-10: #ffdc00;--colors-yellow-light-a-11: #9e6c00;--colors-yellow-light-a-12: #2e2000e0;--colors-yellow-light-p3-1: color(display-p3 .992 .992 .978);--colors-yellow-light-p3-2: color(display-p3 .995 .99 .922);--colors-yellow-light-p3-3: color(display-p3 .997 .982 .749);--colors-yellow-light-p3-4: color(display-p3 .992 .953 .627);--colors-yellow-light-p3-5: color(display-p3 .984 .91 .51);--colors-yellow-light-p3-6: color(display-p3 .934 .847 .474);--colors-yellow-light-p3-7: color(display-p3 .876 .785 .46);--colors-yellow-light-p3-8: color(display-p3 .811 .689 .313);--colors-yellow-light-p3-9: color(display-p3 1 .92 .22);--colors-yellow-light-p3-10: color(display-p3 .977 .868 .291);--colors-yellow-light-p3-11: color(display-p3 .6 .44 0);--colors-yellow-light-p3-12: color(display-p3 .271 .233 .137);--colors-yellow-light-p3-a-1: color(display-p3 .675 .675 .024 / .024);--colors-yellow-light-p3-a-2: color(display-p3 .953 .855 .008 / .079);--colors-yellow-light-p3-a-3: color(display-p3 .988 .925 .004 / .251);--colors-yellow-light-p3-a-4: color(display-p3 .98 .875 .004 / .373);--colors-yellow-light-p3-a-5: color(display-p3 .969 .816 .004 / .491);--colors-yellow-light-p3-a-6: color(display-p3 .875 .71 0 / .526);--colors-yellow-light-p3-a-7: color(display-p3 .769 .604 0 / .542);--colors-yellow-light-p3-a-8: color(display-p3 .725 .549 0 / .687);--colors-yellow-light-p3-a-9: color(display-p3 1 .898 0 / .781);--colors-yellow-light-p3-a-10: color(display-p3 .969 .812 0 / .71);--colors-yellow-light-p3-a-11: color(display-p3 .6 .44 0);--colors-yellow-light-p3-a-12: color(display-p3 .271 .233 .137);--colors-yellow-dark-1: #14120b;--colors-yellow-dark-2: #1b180f;--colors-yellow-dark-3: #2d2305;--colors-yellow-dark-4: #362b00;--colors-yellow-dark-5: #433500;--colors-yellow-dark-6: #524202;--colors-yellow-dark-7: #665417;--colors-yellow-dark-8: #836a21;--colors-yellow-dark-9: #ffe629;--colors-yellow-dark-10: #ffff57;--colors-yellow-dark-11: #f5e147;--colors-yellow-dark-12: #f6eeb4;--colors-yellow-dark-a-1: #d1510004;--colors-yellow-dark-a-2: #f9b4000b;--colors-yellow-dark-a-3: #ffaa001e;--colors-yellow-dark-a-4: #fdb70028;--colors-yellow-dark-a-5: #febb0036;--colors-yellow-dark-a-6: #fec40046;--colors-yellow-dark-a-7: #fdcb225c;--colors-yellow-dark-a-8: #fdca327b;--colors-yellow-dark-a-9: #ffe629;--colors-yellow-dark-a-10: #ffff57;--colors-yellow-dark-a-11: #fee949f5;--colors-yellow-dark-a-12: #fef6baf6;--colors-yellow-dark-p3-1: color(display-p3 .078 .069 .047);--colors-yellow-dark-p3-2: color(display-p3 .103 .094 .063);--colors-yellow-dark-p3-3: color(display-p3 .168 .137 .039);--colors-yellow-dark-p3-4: color(display-p3 .209 .169 0);--colors-yellow-dark-p3-5: color(display-p3 .255 .209 0);--colors-yellow-dark-p3-6: color(display-p3 .31 .261 .07);--colors-yellow-dark-p3-7: color(display-p3 .389 .331 .135);--colors-yellow-dark-p3-8: color(display-p3 .497 .42 .182);--colors-yellow-dark-p3-9: color(display-p3 1 .92 .22);--colors-yellow-dark-p3-10: color(display-p3 1 1 .456);--colors-yellow-dark-p3-11: color(display-p3 .948 .885 .392);--colors-yellow-dark-p3-12: color(display-p3 .959 .934 .731);--colors-yellow-dark-p3-a-1: color(display-p3 .973 .369 0 / .013);--colors-yellow-dark-p3-a-2: color(display-p3 .996 .792 0 / .038);--colors-yellow-dark-p3-a-3: color(display-p3 .996 .71 0 / .11);--colors-yellow-dark-p3-a-4: color(display-p3 .996 .741 0 / .152);--colors-yellow-dark-p3-a-5: color(display-p3 .996 .765 0 / .202);--colors-yellow-dark-p3-a-6: color(display-p3 .996 .816 .082 / .261);--colors-yellow-dark-p3-a-7: color(display-p3 1 .831 .263 / .345);--colors-yellow-dark-p3-a-8: color(display-p3 1 .831 .314 / .463);--colors-yellow-dark-p3-a-9: color(display-p3 1 .922 .22);--colors-yellow-dark-p3-a-10: color(display-p3 1 1 .455);--colors-yellow-dark-p3-a-11: color(display-p3 .948 .885 .392);--colors-yellow-dark-p3-a-12: color(display-p3 .959 .934 .731);--colors-yellow-a-1: var(--colors-yellow-light-a-1);--colors-yellow-a-2: var(--colors-yellow-light-a-2);--colors-yellow-a-3: var(--colors-yellow-light-a-3);--colors-yellow-a-4: var(--colors-yellow-light-a-4);--colors-yellow-a-5: var(--colors-yellow-light-a-5);--colors-yellow-a-6: var(--colors-yellow-light-a-6);--colors-yellow-a-7: var(--colors-yellow-light-a-7);--colors-yellow-a-8: var(--colors-yellow-light-a-8);--colors-yellow-a-9: var(--colors-yellow-light-a-9);--colors-yellow-a-10: var(--colors-yellow-light-a-10);--colors-yellow-a-11: var(--colors-yellow-light-a-11);--colors-yellow-a-12: var(--colors-yellow-light-a-12);--colors-yellow-p3-1: var(--colors-yellow-light-p3-1);--colors-yellow-p3-2: var(--colors-yellow-light-p3-2);--colors-yellow-p3-3: var(--colors-yellow-light-p3-3);--colors-yellow-p3-4: var(--colors-yellow-light-p3-4);--colors-yellow-p3-5: var(--colors-yellow-light-p3-5);--colors-yellow-p3-6: var(--colors-yellow-light-p3-6);--colors-yellow-p3-7: var(--colors-yellow-light-p3-7);--colors-yellow-p3-8: var(--colors-yellow-light-p3-8);--colors-yellow-p3-9: var(--colors-yellow-light-p3-9);--colors-yellow-p3-10: var(--colors-yellow-light-p3-10);--colors-yellow-p3-11: var(--colors-yellow-light-p3-11);--colors-yellow-p3-12: var(--colors-yellow-light-p3-12);--colors-yellow-p3-a-1: var(--colors-yellow-light-p3-a-1);--colors-yellow-p3-a-2: var(--colors-yellow-light-p3-a-2);--colors-yellow-p3-a-3: var(--colors-yellow-light-p3-a-3);--colors-yellow-p3-a-4: var(--colors-yellow-light-p3-a-4);--colors-yellow-p3-a-5: var(--colors-yellow-light-p3-a-5);--colors-yellow-p3-a-6: var(--colors-yellow-light-p3-a-6);--colors-yellow-p3-a-7: var(--colors-yellow-light-p3-a-7);--colors-yellow-p3-a-8: var(--colors-yellow-light-p3-a-8);--colors-yellow-p3-a-9: var(--colors-yellow-light-p3-a-9);--colors-yellow-p3-a-10: var(--colors-yellow-light-p3-a-10);--colors-yellow-p3-a-11: var(--colors-yellow-light-p3-a-11);--colors-yellow-p3-a-12: var(--colors-yellow-light-p3-a-12);--colors-text: var(--mantine-color-text);--colors-text-dimmed: var(--mantine-color-dimmed);--colors-likec4-background: var(--mantine-color-body);--colors-likec4-tag-bg: var(--colors-tomato-9);--colors-likec4-tag-bg-hover: var(--colors-tomato-10);--colors-likec4-tag-border: var(--colors-tomato-8);--colors-likec4-tag-text: var(--colors-tomato-12);--colors-likec4-panel-bg: var(--mantine-color-body);--colors-likec4-panel-border: transparent;--colors-likec4-panel-text: color-mix(in oklab, var(--mantine-color-text) 85%, transparent 15%);--colors-likec4-panel-text-dimmed: var(--mantine-color-dimmed);--colors-likec4-panel-action: color-mix(in oklab, var(--mantine-color-text) 90%, transparent 10%);--colors-likec4-panel-action-disabled: var(--mantine-color-dimmed);--colors-likec4-panel-action-hover: var(--mantine-color-bright);--colors-likec4-panel-action-bg: var(--mantine-color-gray-1);--colors-likec4-panel-action-bg-hover: var(--mantine-color-gray-2);--colors-likec4-panel-action-warning: var(--mantine-color-orange-6);--colors-likec4-panel-action-warning-hover: var(--mantine-color-orange-7);--colors-likec4-panel-action-warning-bg: color-mix(in oklab, var(--mantine-color-orange-1) 90%, transparent 10%);--colors-likec4-panel-action-warning-bg-hover: color-mix(in oklab, var(--mantine-color-orange-3) 70%, transparent 30%);--colors-likec4-dropdown-bg: #FFF;--colors-likec4-dropdown-border: var(--colors-likec4-panel-border);--colors-likec4-overlay-backdrop: rgb(34 34 34);--colors-likec4-overlay-body: var(--mantine-color-body);--colors-likec4-overlay-border: color-mix(in oklab, var(--mantine-color-default-border) 50%, transparent 50%);--colors-likec4-compare-latest: var(--mantine-color-green-6)}[data-mantine-color-scheme=dark]{--colors-amber-1: var(--colors-amber-dark-1);--colors-amber-2: var(--colors-amber-dark-2);--colors-amber-3: var(--colors-amber-dark-3);--colors-amber-4: var(--colors-amber-dark-4);--colors-amber-5: var(--colors-amber-dark-5);--colors-amber-6: var(--colors-amber-dark-6);--colors-amber-7: var(--colors-amber-dark-7);--colors-amber-8: var(--colors-amber-dark-8);--colors-amber-9: var(--colors-amber-dark-9);--colors-amber-10: var(--colors-amber-dark-10);--colors-amber-11: var(--colors-amber-dark-11);--colors-amber-12: var(--colors-amber-dark-12);--colors-amber-a-1: var(--colors-amber-dark-a-1);--colors-amber-a-2: var(--colors-amber-dark-a-2);--colors-amber-a-3: var(--colors-amber-dark-a-3);--colors-amber-a-4: var(--colors-amber-dark-a-4);--colors-amber-a-5: var(--colors-amber-dark-a-5);--colors-amber-a-6: var(--colors-amber-dark-a-6);--colors-amber-a-7: var(--colors-amber-dark-a-7);--colors-amber-a-8: var(--colors-amber-dark-a-8);--colors-amber-a-9: var(--colors-amber-dark-a-9);--colors-amber-a-10: var(--colors-amber-dark-a-10);--colors-amber-a-11: var(--colors-amber-dark-a-11);--colors-amber-a-12: var(--colors-amber-dark-a-12);--colors-amber-p3-1: var(--colors-amber-dark-p3-1);--colors-amber-p3-2: var(--colors-amber-dark-p3-2);--colors-amber-p3-3: var(--colors-amber-dark-p3-3);--colors-amber-p3-4: var(--colors-amber-dark-p3-4);--colors-amber-p3-5: var(--colors-amber-dark-p3-5);--colors-amber-p3-6: var(--colors-amber-dark-p3-6);--colors-amber-p3-7: var(--colors-amber-dark-p3-7);--colors-amber-p3-8: var(--colors-amber-dark-p3-8);--colors-amber-p3-9: var(--colors-amber-dark-p3-9);--colors-amber-p3-10: var(--colors-amber-dark-p3-10);--colors-amber-p3-11: var(--colors-amber-dark-p3-11);--colors-amber-p3-12: var(--colors-amber-dark-p3-12);--colors-amber-p3-a-1: var(--colors-amber-dark-p3-a-1);--colors-amber-p3-a-2: var(--colors-amber-dark-p3-a-2);--colors-amber-p3-a-3: var(--colors-amber-dark-p3-a-3);--colors-amber-p3-a-4: var(--colors-amber-dark-p3-a-4);--colors-amber-p3-a-5: var(--colors-amber-dark-p3-a-5);--colors-amber-p3-a-6: var(--colors-amber-dark-p3-a-6);--colors-amber-p3-a-7: var(--colors-amber-dark-p3-a-7);--colors-amber-p3-a-8: var(--colors-amber-dark-p3-a-8);--colors-amber-p3-a-9: var(--colors-amber-dark-p3-a-9);--colors-amber-p3-a-10: var(--colors-amber-dark-p3-a-10);--colors-amber-p3-a-11: var(--colors-amber-dark-p3-a-11);--colors-amber-p3-a-12: var(--colors-amber-dark-p3-a-12);--colors-blue-1: var(--colors-blue-dark-1);--colors-blue-2: var(--colors-blue-dark-2);--colors-blue-3: var(--colors-blue-dark-3);--colors-blue-4: var(--colors-blue-dark-4);--colors-blue-5: var(--colors-blue-dark-5);--colors-blue-6: var(--colors-blue-dark-6);--colors-blue-7: var(--colors-blue-dark-7);--colors-blue-8: var(--colors-blue-dark-8);--colors-blue-9: var(--colors-blue-dark-9);--colors-blue-10: var(--colors-blue-dark-10);--colors-blue-11: var(--colors-blue-dark-11);--colors-blue-12: var(--colors-blue-dark-12);--colors-blue-a-1: var(--colors-blue-dark-a-1);--colors-blue-a-2: var(--colors-blue-dark-a-2);--colors-blue-a-3: var(--colors-blue-dark-a-3);--colors-blue-a-4: var(--colors-blue-dark-a-4);--colors-blue-a-5: var(--colors-blue-dark-a-5);--colors-blue-a-6: var(--colors-blue-dark-a-6);--colors-blue-a-7: var(--colors-blue-dark-a-7);--colors-blue-a-8: var(--colors-blue-dark-a-8);--colors-blue-a-9: var(--colors-blue-dark-a-9);--colors-blue-a-10: var(--colors-blue-dark-a-10);--colors-blue-a-11: var(--colors-blue-dark-a-11);--colors-blue-a-12: var(--colors-blue-dark-a-12);--colors-blue-p3-1: var(--colors-blue-dark-p3-1);--colors-blue-p3-2: var(--colors-blue-dark-p3-2);--colors-blue-p3-3: var(--colors-blue-dark-p3-3);--colors-blue-p3-4: var(--colors-blue-dark-p3-4);--colors-blue-p3-5: var(--colors-blue-dark-p3-5);--colors-blue-p3-6: var(--colors-blue-dark-p3-6);--colors-blue-p3-7: var(--colors-blue-dark-p3-7);--colors-blue-p3-8: var(--colors-blue-dark-p3-8);--colors-blue-p3-9: var(--colors-blue-dark-p3-9);--colors-blue-p3-10: var(--colors-blue-dark-p3-10);--colors-blue-p3-11: var(--colors-blue-dark-p3-11);--colors-blue-p3-12: var(--colors-blue-dark-p3-12);--colors-blue-p3-a-1: var(--colors-blue-dark-p3-a-1);--colors-blue-p3-a-2: var(--colors-blue-dark-p3-a-2);--colors-blue-p3-a-3: var(--colors-blue-dark-p3-a-3);--colors-blue-p3-a-4: var(--colors-blue-dark-p3-a-4);--colors-blue-p3-a-5: var(--colors-blue-dark-p3-a-5);--colors-blue-p3-a-6: var(--colors-blue-dark-p3-a-6);--colors-blue-p3-a-7: var(--colors-blue-dark-p3-a-7);--colors-blue-p3-a-8: var(--colors-blue-dark-p3-a-8);--colors-blue-p3-a-9: var(--colors-blue-dark-p3-a-9);--colors-blue-p3-a-10: var(--colors-blue-dark-p3-a-10);--colors-blue-p3-a-11: var(--colors-blue-dark-p3-a-11);--colors-blue-p3-a-12: var(--colors-blue-dark-p3-a-12);--colors-crimson-1: var(--colors-crimson-dark-1);--colors-crimson-2: var(--colors-crimson-dark-2);--colors-crimson-3: var(--colors-crimson-dark-3);--colors-crimson-4: var(--colors-crimson-dark-4);--colors-crimson-5: var(--colors-crimson-dark-5);--colors-crimson-6: var(--colors-crimson-dark-6);--colors-crimson-7: var(--colors-crimson-dark-7);--colors-crimson-8: var(--colors-crimson-dark-8);--colors-crimson-9: var(--colors-crimson-dark-9);--colors-crimson-10: var(--colors-crimson-dark-10);--colors-crimson-11: var(--colors-crimson-dark-11);--colors-crimson-12: var(--colors-crimson-dark-12);--colors-crimson-a-1: var(--colors-crimson-dark-a-1);--colors-crimson-a-2: var(--colors-crimson-dark-a-2);--colors-crimson-a-3: var(--colors-crimson-dark-a-3);--colors-crimson-a-4: var(--colors-crimson-dark-a-4);--colors-crimson-a-5: var(--colors-crimson-dark-a-5);--colors-crimson-a-6: var(--colors-crimson-dark-a-6);--colors-crimson-a-7: var(--colors-crimson-dark-a-7);--colors-crimson-a-8: var(--colors-crimson-dark-a-8);--colors-crimson-a-9: var(--colors-crimson-dark-a-9);--colors-crimson-a-10: var(--colors-crimson-dark-a-10);--colors-crimson-a-11: var(--colors-crimson-dark-a-11);--colors-crimson-a-12: var(--colors-crimson-dark-a-12);--colors-crimson-p3-1: var(--colors-crimson-dark-p3-1);--colors-crimson-p3-2: var(--colors-crimson-dark-p3-2);--colors-crimson-p3-3: var(--colors-crimson-dark-p3-3);--colors-crimson-p3-4: var(--colors-crimson-dark-p3-4);--colors-crimson-p3-5: var(--colors-crimson-dark-p3-5);--colors-crimson-p3-6: var(--colors-crimson-dark-p3-6);--colors-crimson-p3-7: var(--colors-crimson-dark-p3-7);--colors-crimson-p3-8: var(--colors-crimson-dark-p3-8);--colors-crimson-p3-9: var(--colors-crimson-dark-p3-9);--colors-crimson-p3-10: var(--colors-crimson-dark-p3-10);--colors-crimson-p3-11: var(--colors-crimson-dark-p3-11);--colors-crimson-p3-12: var(--colors-crimson-dark-p3-12);--colors-crimson-p3-a-1: var(--colors-crimson-dark-p3-a-1);--colors-crimson-p3-a-2: var(--colors-crimson-dark-p3-a-2);--colors-crimson-p3-a-3: var(--colors-crimson-dark-p3-a-3);--colors-crimson-p3-a-4: var(--colors-crimson-dark-p3-a-4);--colors-crimson-p3-a-5: var(--colors-crimson-dark-p3-a-5);--colors-crimson-p3-a-6: var(--colors-crimson-dark-p3-a-6);--colors-crimson-p3-a-7: var(--colors-crimson-dark-p3-a-7);--colors-crimson-p3-a-8: var(--colors-crimson-dark-p3-a-8);--colors-crimson-p3-a-9: var(--colors-crimson-dark-p3-a-9);--colors-crimson-p3-a-10: var(--colors-crimson-dark-p3-a-10);--colors-crimson-p3-a-11: var(--colors-crimson-dark-p3-a-11);--colors-crimson-p3-a-12: var(--colors-crimson-dark-p3-a-12);--colors-grass-1: var(--colors-grass-dark-1);--colors-grass-2: var(--colors-grass-dark-2);--colors-grass-3: var(--colors-grass-dark-3);--colors-grass-4: var(--colors-grass-dark-4);--colors-grass-5: var(--colors-grass-dark-5);--colors-grass-6: var(--colors-grass-dark-6);--colors-grass-7: var(--colors-grass-dark-7);--colors-grass-8: var(--colors-grass-dark-8);--colors-grass-9: var(--colors-grass-dark-9);--colors-grass-10: var(--colors-grass-dark-10);--colors-grass-11: var(--colors-grass-dark-11);--colors-grass-12: var(--colors-grass-dark-12);--colors-grass-a-1: var(--colors-grass-dark-a-1);--colors-grass-a-2: var(--colors-grass-dark-a-2);--colors-grass-a-3: var(--colors-grass-dark-a-3);--colors-grass-a-4: var(--colors-grass-dark-a-4);--colors-grass-a-5: var(--colors-grass-dark-a-5);--colors-grass-a-6: var(--colors-grass-dark-a-6);--colors-grass-a-7: var(--colors-grass-dark-a-7);--colors-grass-a-8: var(--colors-grass-dark-a-8);--colors-grass-a-9: var(--colors-grass-dark-a-9);--colors-grass-a-10: var(--colors-grass-dark-a-10);--colors-grass-a-11: var(--colors-grass-dark-a-11);--colors-grass-a-12: var(--colors-grass-dark-a-12);--colors-grass-p3-1: var(--colors-grass-dark-p3-1);--colors-grass-p3-2: var(--colors-grass-dark-p3-2);--colors-grass-p3-3: var(--colors-grass-dark-p3-3);--colors-grass-p3-4: var(--colors-grass-dark-p3-4);--colors-grass-p3-5: var(--colors-grass-dark-p3-5);--colors-grass-p3-6: var(--colors-grass-dark-p3-6);--colors-grass-p3-7: var(--colors-grass-dark-p3-7);--colors-grass-p3-8: var(--colors-grass-dark-p3-8);--colors-grass-p3-9: var(--colors-grass-dark-p3-9);--colors-grass-p3-10: var(--colors-grass-dark-p3-10);--colors-grass-p3-11: var(--colors-grass-dark-p3-11);--colors-grass-p3-12: var(--colors-grass-dark-p3-12);--colors-grass-p3-a-1: var(--colors-grass-dark-p3-a-1);--colors-grass-p3-a-2: var(--colors-grass-dark-p3-a-2);--colors-grass-p3-a-3: var(--colors-grass-dark-p3-a-3);--colors-grass-p3-a-4: var(--colors-grass-dark-p3-a-4);--colors-grass-p3-a-5: var(--colors-grass-dark-p3-a-5);--colors-grass-p3-a-6: var(--colors-grass-dark-p3-a-6);--colors-grass-p3-a-7: var(--colors-grass-dark-p3-a-7);--colors-grass-p3-a-8: var(--colors-grass-dark-p3-a-8);--colors-grass-p3-a-9: var(--colors-grass-dark-p3-a-9);--colors-grass-p3-a-10: var(--colors-grass-dark-p3-a-10);--colors-grass-p3-a-11: var(--colors-grass-dark-p3-a-11);--colors-grass-p3-a-12: var(--colors-grass-dark-p3-a-12);--colors-indigo-1: var(--colors-indigo-dark-1);--colors-indigo-2: var(--colors-indigo-dark-2);--colors-indigo-3: var(--colors-indigo-dark-3);--colors-indigo-4: var(--colors-indigo-dark-4);--colors-indigo-5: var(--colors-indigo-dark-5);--colors-indigo-6: var(--colors-indigo-dark-6);--colors-indigo-7: var(--colors-indigo-dark-7);--colors-indigo-8: var(--colors-indigo-dark-8);--colors-indigo-9: var(--colors-indigo-dark-9);--colors-indigo-10: var(--colors-indigo-dark-10);--colors-indigo-11: var(--colors-indigo-dark-11);--colors-indigo-12: var(--colors-indigo-dark-12);--colors-indigo-a-1: var(--colors-indigo-dark-a-1);--colors-indigo-a-2: var(--colors-indigo-dark-a-2);--colors-indigo-a-3: var(--colors-indigo-dark-a-3);--colors-indigo-a-4: var(--colors-indigo-dark-a-4);--colors-indigo-a-5: var(--colors-indigo-dark-a-5);--colors-indigo-a-6: var(--colors-indigo-dark-a-6);--colors-indigo-a-7: var(--colors-indigo-dark-a-7);--colors-indigo-a-8: var(--colors-indigo-dark-a-8);--colors-indigo-a-9: var(--colors-indigo-dark-a-9);--colors-indigo-a-10: var(--colors-indigo-dark-a-10);--colors-indigo-a-11: var(--colors-indigo-dark-a-11);--colors-indigo-a-12: var(--colors-indigo-dark-a-12);--colors-indigo-p3-1: var(--colors-indigo-dark-p3-1);--colors-indigo-p3-2: var(--colors-indigo-dark-p3-2);--colors-indigo-p3-3: var(--colors-indigo-dark-p3-3);--colors-indigo-p3-4: var(--colors-indigo-dark-p3-4);--colors-indigo-p3-5: var(--colors-indigo-dark-p3-5);--colors-indigo-p3-6: var(--colors-indigo-dark-p3-6);--colors-indigo-p3-7: var(--colors-indigo-dark-p3-7);--colors-indigo-p3-8: var(--colors-indigo-dark-p3-8);--colors-indigo-p3-9: var(--colors-indigo-dark-p3-9);--colors-indigo-p3-10: var(--colors-indigo-dark-p3-10);--colors-indigo-p3-11: var(--colors-indigo-dark-p3-11);--colors-indigo-p3-12: var(--colors-indigo-dark-p3-12);--colors-indigo-p3-a-1: var(--colors-indigo-dark-p3-a-1);--colors-indigo-p3-a-2: var(--colors-indigo-dark-p3-a-2);--colors-indigo-p3-a-3: var(--colors-indigo-dark-p3-a-3);--colors-indigo-p3-a-4: var(--colors-indigo-dark-p3-a-4);--colors-indigo-p3-a-5: var(--colors-indigo-dark-p3-a-5);--colors-indigo-p3-a-6: var(--colors-indigo-dark-p3-a-6);--colors-indigo-p3-a-7: var(--colors-indigo-dark-p3-a-7);--colors-indigo-p3-a-8: var(--colors-indigo-dark-p3-a-8);--colors-indigo-p3-a-9: var(--colors-indigo-dark-p3-a-9);--colors-indigo-p3-a-10: var(--colors-indigo-dark-p3-a-10);--colors-indigo-p3-a-11: var(--colors-indigo-dark-p3-a-11);--colors-indigo-p3-a-12: var(--colors-indigo-dark-p3-a-12);--colors-lime-1: var(--colors-lime-dark-1);--colors-lime-2: var(--colors-lime-dark-2);--colors-lime-3: var(--colors-lime-dark-3);--colors-lime-4: var(--colors-lime-dark-4);--colors-lime-5: var(--colors-lime-dark-5);--colors-lime-6: var(--colors-lime-dark-6);--colors-lime-7: var(--colors-lime-dark-7);--colors-lime-8: var(--colors-lime-dark-8);--colors-lime-9: var(--colors-lime-dark-9);--colors-lime-10: var(--colors-lime-dark-10);--colors-lime-11: var(--colors-lime-dark-11);--colors-lime-12: var(--colors-lime-dark-12);--colors-lime-a-1: var(--colors-lime-dark-a-1);--colors-lime-a-2: var(--colors-lime-dark-a-2);--colors-lime-a-3: var(--colors-lime-dark-a-3);--colors-lime-a-4: var(--colors-lime-dark-a-4);--colors-lime-a-5: var(--colors-lime-dark-a-5);--colors-lime-a-6: var(--colors-lime-dark-a-6);--colors-lime-a-7: var(--colors-lime-dark-a-7);--colors-lime-a-8: var(--colors-lime-dark-a-8);--colors-lime-a-9: var(--colors-lime-dark-a-9);--colors-lime-a-10: var(--colors-lime-dark-a-10);--colors-lime-a-11: var(--colors-lime-dark-a-11);--colors-lime-a-12: var(--colors-lime-dark-a-12);--colors-lime-p3-1: var(--colors-lime-dark-p3-1);--colors-lime-p3-2: var(--colors-lime-dark-p3-2);--colors-lime-p3-3: var(--colors-lime-dark-p3-3);--colors-lime-p3-4: var(--colors-lime-dark-p3-4);--colors-lime-p3-5: var(--colors-lime-dark-p3-5);--colors-lime-p3-6: var(--colors-lime-dark-p3-6);--colors-lime-p3-7: var(--colors-lime-dark-p3-7);--colors-lime-p3-8: var(--colors-lime-dark-p3-8);--colors-lime-p3-9: var(--colors-lime-dark-p3-9);--colors-lime-p3-10: var(--colors-lime-dark-p3-10);--colors-lime-p3-11: var(--colors-lime-dark-p3-11);--colors-lime-p3-12: var(--colors-lime-dark-p3-12);--colors-lime-p3-a-1: var(--colors-lime-dark-p3-a-1);--colors-lime-p3-a-2: var(--colors-lime-dark-p3-a-2);--colors-lime-p3-a-3: var(--colors-lime-dark-p3-a-3);--colors-lime-p3-a-4: var(--colors-lime-dark-p3-a-4);--colors-lime-p3-a-5: var(--colors-lime-dark-p3-a-5);--colors-lime-p3-a-6: var(--colors-lime-dark-p3-a-6);--colors-lime-p3-a-7: var(--colors-lime-dark-p3-a-7);--colors-lime-p3-a-8: var(--colors-lime-dark-p3-a-8);--colors-lime-p3-a-9: var(--colors-lime-dark-p3-a-9);--colors-lime-p3-a-10: var(--colors-lime-dark-p3-a-10);--colors-lime-p3-a-11: var(--colors-lime-dark-p3-a-11);--colors-lime-p3-a-12: var(--colors-lime-dark-p3-a-12);--colors-orange-1: var(--colors-orange-dark-1);--colors-orange-2: var(--colors-orange-dark-2);--colors-orange-3: var(--colors-orange-dark-3);--colors-orange-4: var(--colors-orange-dark-4);--colors-orange-5: var(--colors-orange-dark-5);--colors-orange-6: var(--colors-orange-dark-6);--colors-orange-7: var(--colors-orange-dark-7);--colors-orange-8: var(--colors-orange-dark-8);--colors-orange-9: var(--colors-orange-dark-9);--colors-orange-10: var(--colors-orange-dark-10);--colors-orange-11: var(--colors-orange-dark-11);--colors-orange-12: var(--colors-orange-dark-12);--colors-orange-a-1: var(--colors-orange-dark-a-1);--colors-orange-a-2: var(--colors-orange-dark-a-2);--colors-orange-a-3: var(--colors-orange-dark-a-3);--colors-orange-a-4: var(--colors-orange-dark-a-4);--colors-orange-a-5: var(--colors-orange-dark-a-5);--colors-orange-a-6: var(--colors-orange-dark-a-6);--colors-orange-a-7: var(--colors-orange-dark-a-7);--colors-orange-a-8: var(--colors-orange-dark-a-8);--colors-orange-a-9: var(--colors-orange-dark-a-9);--colors-orange-a-10: var(--colors-orange-dark-a-10);--colors-orange-a-11: var(--colors-orange-dark-a-11);--colors-orange-a-12: var(--colors-orange-dark-a-12);--colors-orange-p3-1: var(--colors-orange-dark-p3-1);--colors-orange-p3-2: var(--colors-orange-dark-p3-2);--colors-orange-p3-3: var(--colors-orange-dark-p3-3);--colors-orange-p3-4: var(--colors-orange-dark-p3-4);--colors-orange-p3-5: var(--colors-orange-dark-p3-5);--colors-orange-p3-6: var(--colors-orange-dark-p3-6);--colors-orange-p3-7: var(--colors-orange-dark-p3-7);--colors-orange-p3-8: var(--colors-orange-dark-p3-8);--colors-orange-p3-9: var(--colors-orange-dark-p3-9);--colors-orange-p3-10: var(--colors-orange-dark-p3-10);--colors-orange-p3-11: var(--colors-orange-dark-p3-11);--colors-orange-p3-12: var(--colors-orange-dark-p3-12);--colors-orange-p3-a-1: var(--colors-orange-dark-p3-a-1);--colors-orange-p3-a-2: var(--colors-orange-dark-p3-a-2);--colors-orange-p3-a-3: var(--colors-orange-dark-p3-a-3);--colors-orange-p3-a-4: var(--colors-orange-dark-p3-a-4);--colors-orange-p3-a-5: var(--colors-orange-dark-p3-a-5);--colors-orange-p3-a-6: var(--colors-orange-dark-p3-a-6);--colors-orange-p3-a-7: var(--colors-orange-dark-p3-a-7);--colors-orange-p3-a-8: var(--colors-orange-dark-p3-a-8);--colors-orange-p3-a-9: var(--colors-orange-dark-p3-a-9);--colors-orange-p3-a-10: var(--colors-orange-dark-p3-a-10);--colors-orange-p3-a-11: var(--colors-orange-dark-p3-a-11);--colors-orange-p3-a-12: var(--colors-orange-dark-p3-a-12);--colors-pink-1: var(--colors-pink-dark-1);--colors-pink-2: var(--colors-pink-dark-2);--colors-pink-3: var(--colors-pink-dark-3);--colors-pink-4: var(--colors-pink-dark-4);--colors-pink-5: var(--colors-pink-dark-5);--colors-pink-6: var(--colors-pink-dark-6);--colors-pink-7: var(--colors-pink-dark-7);--colors-pink-8: var(--colors-pink-dark-8);--colors-pink-9: var(--colors-pink-dark-9);--colors-pink-10: var(--colors-pink-dark-10);--colors-pink-11: var(--colors-pink-dark-11);--colors-pink-12: var(--colors-pink-dark-12);--colors-pink-a-1: var(--colors-pink-dark-a-1);--colors-pink-a-2: var(--colors-pink-dark-a-2);--colors-pink-a-3: var(--colors-pink-dark-a-3);--colors-pink-a-4: var(--colors-pink-dark-a-4);--colors-pink-a-5: var(--colors-pink-dark-a-5);--colors-pink-a-6: var(--colors-pink-dark-a-6);--colors-pink-a-7: var(--colors-pink-dark-a-7);--colors-pink-a-8: var(--colors-pink-dark-a-8);--colors-pink-a-9: var(--colors-pink-dark-a-9);--colors-pink-a-10: var(--colors-pink-dark-a-10);--colors-pink-a-11: var(--colors-pink-dark-a-11);--colors-pink-a-12: var(--colors-pink-dark-a-12);--colors-pink-p3-1: var(--colors-pink-dark-p3-1);--colors-pink-p3-2: var(--colors-pink-dark-p3-2);--colors-pink-p3-3: var(--colors-pink-dark-p3-3);--colors-pink-p3-4: var(--colors-pink-dark-p3-4);--colors-pink-p3-5: var(--colors-pink-dark-p3-5);--colors-pink-p3-6: var(--colors-pink-dark-p3-6);--colors-pink-p3-7: var(--colors-pink-dark-p3-7);--colors-pink-p3-8: var(--colors-pink-dark-p3-8);--colors-pink-p3-9: var(--colors-pink-dark-p3-9);--colors-pink-p3-10: var(--colors-pink-dark-p3-10);--colors-pink-p3-11: var(--colors-pink-dark-p3-11);--colors-pink-p3-12: var(--colors-pink-dark-p3-12);--colors-pink-p3-a-1: var(--colors-pink-dark-p3-a-1);--colors-pink-p3-a-2: var(--colors-pink-dark-p3-a-2);--colors-pink-p3-a-3: var(--colors-pink-dark-p3-a-3);--colors-pink-p3-a-4: var(--colors-pink-dark-p3-a-4);--colors-pink-p3-a-5: var(--colors-pink-dark-p3-a-5);--colors-pink-p3-a-6: var(--colors-pink-dark-p3-a-6);--colors-pink-p3-a-7: var(--colors-pink-dark-p3-a-7);--colors-pink-p3-a-8: var(--colors-pink-dark-p3-a-8);--colors-pink-p3-a-9: var(--colors-pink-dark-p3-a-9);--colors-pink-p3-a-10: var(--colors-pink-dark-p3-a-10);--colors-pink-p3-a-11: var(--colors-pink-dark-p3-a-11);--colors-pink-p3-a-12: var(--colors-pink-dark-p3-a-12);--colors-purple-1: var(--colors-purple-dark-1);--colors-purple-2: var(--colors-purple-dark-2);--colors-purple-3: var(--colors-purple-dark-3);--colors-purple-4: var(--colors-purple-dark-4);--colors-purple-5: var(--colors-purple-dark-5);--colors-purple-6: var(--colors-purple-dark-6);--colors-purple-7: var(--colors-purple-dark-7);--colors-purple-8: var(--colors-purple-dark-8);--colors-purple-9: var(--colors-purple-dark-9);--colors-purple-10: var(--colors-purple-dark-10);--colors-purple-11: var(--colors-purple-dark-11);--colors-purple-12: var(--colors-purple-dark-12);--colors-purple-a-1: var(--colors-purple-dark-a-1);--colors-purple-a-2: var(--colors-purple-dark-a-2);--colors-purple-a-3: var(--colors-purple-dark-a-3);--colors-purple-a-4: var(--colors-purple-dark-a-4);--colors-purple-a-5: var(--colors-purple-dark-a-5);--colors-purple-a-6: var(--colors-purple-dark-a-6);--colors-purple-a-7: var(--colors-purple-dark-a-7);--colors-purple-a-8: var(--colors-purple-dark-a-8);--colors-purple-a-9: var(--colors-purple-dark-a-9);--colors-purple-a-10: var(--colors-purple-dark-a-10);--colors-purple-a-11: var(--colors-purple-dark-a-11);--colors-purple-a-12: var(--colors-purple-dark-a-12);--colors-purple-p3-1: var(--colors-purple-dark-p3-1);--colors-purple-p3-2: var(--colors-purple-dark-p3-2);--colors-purple-p3-3: var(--colors-purple-dark-p3-3);--colors-purple-p3-4: var(--colors-purple-dark-p3-4);--colors-purple-p3-5: var(--colors-purple-dark-p3-5);--colors-purple-p3-6: var(--colors-purple-dark-p3-6);--colors-purple-p3-7: var(--colors-purple-dark-p3-7);--colors-purple-p3-8: var(--colors-purple-dark-p3-8);--colors-purple-p3-9: var(--colors-purple-dark-p3-9);--colors-purple-p3-10: var(--colors-purple-dark-p3-10);--colors-purple-p3-11: var(--colors-purple-dark-p3-11);--colors-purple-p3-12: var(--colors-purple-dark-p3-12);--colors-purple-p3-a-1: var(--colors-purple-dark-p3-a-1);--colors-purple-p3-a-2: var(--colors-purple-dark-p3-a-2);--colors-purple-p3-a-3: var(--colors-purple-dark-p3-a-3);--colors-purple-p3-a-4: var(--colors-purple-dark-p3-a-4);--colors-purple-p3-a-5: var(--colors-purple-dark-p3-a-5);--colors-purple-p3-a-6: var(--colors-purple-dark-p3-a-6);--colors-purple-p3-a-7: var(--colors-purple-dark-p3-a-7);--colors-purple-p3-a-8: var(--colors-purple-dark-p3-a-8);--colors-purple-p3-a-9: var(--colors-purple-dark-p3-a-9);--colors-purple-p3-a-10: var(--colors-purple-dark-p3-a-10);--colors-purple-p3-a-11: var(--colors-purple-dark-p3-a-11);--colors-purple-p3-a-12: var(--colors-purple-dark-p3-a-12);--colors-red-1: var(--colors-red-dark-1);--colors-red-2: var(--colors-red-dark-2);--colors-red-3: var(--colors-red-dark-3);--colors-red-4: var(--colors-red-dark-4);--colors-red-5: var(--colors-red-dark-5);--colors-red-6: var(--colors-red-dark-6);--colors-red-7: var(--colors-red-dark-7);--colors-red-8: var(--colors-red-dark-8);--colors-red-9: var(--colors-red-dark-9);--colors-red-10: var(--colors-red-dark-10);--colors-red-11: var(--colors-red-dark-11);--colors-red-12: var(--colors-red-dark-12);--colors-red-a-1: var(--colors-red-dark-a-1);--colors-red-a-2: var(--colors-red-dark-a-2);--colors-red-a-3: var(--colors-red-dark-a-3);--colors-red-a-4: var(--colors-red-dark-a-4);--colors-red-a-5: var(--colors-red-dark-a-5);--colors-red-a-6: var(--colors-red-dark-a-6);--colors-red-a-7: var(--colors-red-dark-a-7);--colors-red-a-8: var(--colors-red-dark-a-8);--colors-red-a-9: var(--colors-red-dark-a-9);--colors-red-a-10: var(--colors-red-dark-a-10);--colors-red-a-11: var(--colors-red-dark-a-11);--colors-red-a-12: var(--colors-red-dark-a-12);--colors-red-p3-1: var(--colors-red-dark-p3-1);--colors-red-p3-2: var(--colors-red-dark-p3-2);--colors-red-p3-3: var(--colors-red-dark-p3-3);--colors-red-p3-4: var(--colors-red-dark-p3-4);--colors-red-p3-5: var(--colors-red-dark-p3-5);--colors-red-p3-6: var(--colors-red-dark-p3-6);--colors-red-p3-7: var(--colors-red-dark-p3-7);--colors-red-p3-8: var(--colors-red-dark-p3-8);--colors-red-p3-9: var(--colors-red-dark-p3-9);--colors-red-p3-10: var(--colors-red-dark-p3-10);--colors-red-p3-11: var(--colors-red-dark-p3-11);--colors-red-p3-12: var(--colors-red-dark-p3-12);--colors-red-p3-a-1: var(--colors-red-dark-p3-a-1);--colors-red-p3-a-2: var(--colors-red-dark-p3-a-2);--colors-red-p3-a-3: var(--colors-red-dark-p3-a-3);--colors-red-p3-a-4: var(--colors-red-dark-p3-a-4);--colors-red-p3-a-5: var(--colors-red-dark-p3-a-5);--colors-red-p3-a-6: var(--colors-red-dark-p3-a-6);--colors-red-p3-a-7: var(--colors-red-dark-p3-a-7);--colors-red-p3-a-8: var(--colors-red-dark-p3-a-8);--colors-red-p3-a-9: var(--colors-red-dark-p3-a-9);--colors-red-p3-a-10: var(--colors-red-dark-p3-a-10);--colors-red-p3-a-11: var(--colors-red-dark-p3-a-11);--colors-red-p3-a-12: var(--colors-red-dark-p3-a-12);--colors-ruby-1: var(--colors-ruby-dark-1);--colors-ruby-2: var(--colors-ruby-dark-2);--colors-ruby-3: var(--colors-ruby-dark-3);--colors-ruby-4: var(--colors-ruby-dark-4);--colors-ruby-5: var(--colors-ruby-dark-5);--colors-ruby-6: var(--colors-ruby-dark-6);--colors-ruby-7: var(--colors-ruby-dark-7);--colors-ruby-8: var(--colors-ruby-dark-8);--colors-ruby-9: var(--colors-ruby-dark-9);--colors-ruby-10: var(--colors-ruby-dark-10);--colors-ruby-11: var(--colors-ruby-dark-11);--colors-ruby-12: var(--colors-ruby-dark-12);--colors-ruby-a-1: var(--colors-ruby-dark-a-1);--colors-ruby-a-2: var(--colors-ruby-dark-a-2);--colors-ruby-a-3: var(--colors-ruby-dark-a-3);--colors-ruby-a-4: var(--colors-ruby-dark-a-4);--colors-ruby-a-5: var(--colors-ruby-dark-a-5);--colors-ruby-a-6: var(--colors-ruby-dark-a-6);--colors-ruby-a-7: var(--colors-ruby-dark-a-7);--colors-ruby-a-8: var(--colors-ruby-dark-a-8);--colors-ruby-a-9: var(--colors-ruby-dark-a-9);--colors-ruby-a-10: var(--colors-ruby-dark-a-10);--colors-ruby-a-11: var(--colors-ruby-dark-a-11);--colors-ruby-a-12: var(--colors-ruby-dark-a-12);--colors-ruby-p3-1: var(--colors-ruby-dark-p3-1);--colors-ruby-p3-2: var(--colors-ruby-dark-p3-2);--colors-ruby-p3-3: var(--colors-ruby-dark-p3-3);--colors-ruby-p3-4: var(--colors-ruby-dark-p3-4);--colors-ruby-p3-5: var(--colors-ruby-dark-p3-5);--colors-ruby-p3-6: var(--colors-ruby-dark-p3-6);--colors-ruby-p3-7: var(--colors-ruby-dark-p3-7);--colors-ruby-p3-8: var(--colors-ruby-dark-p3-8);--colors-ruby-p3-9: var(--colors-ruby-dark-p3-9);--colors-ruby-p3-10: var(--colors-ruby-dark-p3-10);--colors-ruby-p3-11: var(--colors-ruby-dark-p3-11);--colors-ruby-p3-12: var(--colors-ruby-dark-p3-12);--colors-ruby-p3-a-1: var(--colors-ruby-dark-p3-a-1);--colors-ruby-p3-a-2: var(--colors-ruby-dark-p3-a-2);--colors-ruby-p3-a-3: var(--colors-ruby-dark-p3-a-3);--colors-ruby-p3-a-4: var(--colors-ruby-dark-p3-a-4);--colors-ruby-p3-a-5: var(--colors-ruby-dark-p3-a-5);--colors-ruby-p3-a-6: var(--colors-ruby-dark-p3-a-6);--colors-ruby-p3-a-7: var(--colors-ruby-dark-p3-a-7);--colors-ruby-p3-a-8: var(--colors-ruby-dark-p3-a-8);--colors-ruby-p3-a-9: var(--colors-ruby-dark-p3-a-9);--colors-ruby-p3-a-10: var(--colors-ruby-dark-p3-a-10);--colors-ruby-p3-a-11: var(--colors-ruby-dark-p3-a-11);--colors-ruby-p3-a-12: var(--colors-ruby-dark-p3-a-12);--colors-teal-1: var(--colors-teal-dark-1);--colors-teal-2: var(--colors-teal-dark-2);--colors-teal-3: var(--colors-teal-dark-3);--colors-teal-4: var(--colors-teal-dark-4);--colors-teal-5: var(--colors-teal-dark-5);--colors-teal-6: var(--colors-teal-dark-6);--colors-teal-7: var(--colors-teal-dark-7);--colors-teal-8: var(--colors-teal-dark-8);--colors-teal-9: var(--colors-teal-dark-9);--colors-teal-10: var(--colors-teal-dark-10);--colors-teal-11: var(--colors-teal-dark-11);--colors-teal-12: var(--colors-teal-dark-12);--colors-teal-a-1: var(--colors-teal-dark-a-1);--colors-teal-a-2: var(--colors-teal-dark-a-2);--colors-teal-a-3: var(--colors-teal-dark-a-3);--colors-teal-a-4: var(--colors-teal-dark-a-4);--colors-teal-a-5: var(--colors-teal-dark-a-5);--colors-teal-a-6: var(--colors-teal-dark-a-6);--colors-teal-a-7: var(--colors-teal-dark-a-7);--colors-teal-a-8: var(--colors-teal-dark-a-8);--colors-teal-a-9: var(--colors-teal-dark-a-9);--colors-teal-a-10: var(--colors-teal-dark-a-10);--colors-teal-a-11: var(--colors-teal-dark-a-11);--colors-teal-a-12: var(--colors-teal-dark-a-12);--colors-teal-p3-1: var(--colors-teal-dark-p3-1);--colors-teal-p3-2: var(--colors-teal-dark-p3-2);--colors-teal-p3-3: var(--colors-teal-dark-p3-3);--colors-teal-p3-4: var(--colors-teal-dark-p3-4);--colors-teal-p3-5: var(--colors-teal-dark-p3-5);--colors-teal-p3-6: var(--colors-teal-dark-p3-6);--colors-teal-p3-7: var(--colors-teal-dark-p3-7);--colors-teal-p3-8: var(--colors-teal-dark-p3-8);--colors-teal-p3-9: var(--colors-teal-dark-p3-9);--colors-teal-p3-10: var(--colors-teal-dark-p3-10);--colors-teal-p3-11: var(--colors-teal-dark-p3-11);--colors-teal-p3-12: var(--colors-teal-dark-p3-12);--colors-teal-p3-a-1: var(--colors-teal-dark-p3-a-1);--colors-teal-p3-a-2: var(--colors-teal-dark-p3-a-2);--colors-teal-p3-a-3: var(--colors-teal-dark-p3-a-3);--colors-teal-p3-a-4: var(--colors-teal-dark-p3-a-4);--colors-teal-p3-a-5: var(--colors-teal-dark-p3-a-5);--colors-teal-p3-a-6: var(--colors-teal-dark-p3-a-6);--colors-teal-p3-a-7: var(--colors-teal-dark-p3-a-7);--colors-teal-p3-a-8: var(--colors-teal-dark-p3-a-8);--colors-teal-p3-a-9: var(--colors-teal-dark-p3-a-9);--colors-teal-p3-a-10: var(--colors-teal-dark-p3-a-10);--colors-teal-p3-a-11: var(--colors-teal-dark-p3-a-11);--colors-teal-p3-a-12: var(--colors-teal-dark-p3-a-12);--colors-tomato-1: var(--colors-tomato-dark-1);--colors-tomato-2: var(--colors-tomato-dark-2);--colors-tomato-3: var(--colors-tomato-dark-3);--colors-tomato-4: var(--colors-tomato-dark-4);--colors-tomato-5: var(--colors-tomato-dark-5);--colors-tomato-6: var(--colors-tomato-dark-6);--colors-tomato-7: var(--colors-tomato-dark-7);--colors-tomato-8: var(--colors-tomato-dark-8);--colors-tomato-9: var(--colors-tomato-dark-9);--colors-tomato-10: var(--colors-tomato-dark-10);--colors-tomato-11: var(--colors-tomato-dark-11);--colors-tomato-12: var(--colors-tomato-dark-12);--colors-tomato-a-1: var(--colors-tomato-dark-a-1);--colors-tomato-a-2: var(--colors-tomato-dark-a-2);--colors-tomato-a-3: var(--colors-tomato-dark-a-3);--colors-tomato-a-4: var(--colors-tomato-dark-a-4);--colors-tomato-a-5: var(--colors-tomato-dark-a-5);--colors-tomato-a-6: var(--colors-tomato-dark-a-6);--colors-tomato-a-7: var(--colors-tomato-dark-a-7);--colors-tomato-a-8: var(--colors-tomato-dark-a-8);--colors-tomato-a-9: var(--colors-tomato-dark-a-9);--colors-tomato-a-10: var(--colors-tomato-dark-a-10);--colors-tomato-a-11: var(--colors-tomato-dark-a-11);--colors-tomato-a-12: var(--colors-tomato-dark-a-12);--colors-tomato-p3-1: var(--colors-tomato-dark-p3-1);--colors-tomato-p3-2: var(--colors-tomato-dark-p3-2);--colors-tomato-p3-3: var(--colors-tomato-dark-p3-3);--colors-tomato-p3-4: var(--colors-tomato-dark-p3-4);--colors-tomato-p3-5: var(--colors-tomato-dark-p3-5);--colors-tomato-p3-6: var(--colors-tomato-dark-p3-6);--colors-tomato-p3-7: var(--colors-tomato-dark-p3-7);--colors-tomato-p3-8: var(--colors-tomato-dark-p3-8);--colors-tomato-p3-9: var(--colors-tomato-dark-p3-9);--colors-tomato-p3-10: var(--colors-tomato-dark-p3-10);--colors-tomato-p3-11: var(--colors-tomato-dark-p3-11);--colors-tomato-p3-12: var(--colors-tomato-dark-p3-12);--colors-tomato-p3-a-1: var(--colors-tomato-dark-p3-a-1);--colors-tomato-p3-a-2: var(--colors-tomato-dark-p3-a-2);--colors-tomato-p3-a-3: var(--colors-tomato-dark-p3-a-3);--colors-tomato-p3-a-4: var(--colors-tomato-dark-p3-a-4);--colors-tomato-p3-a-5: var(--colors-tomato-dark-p3-a-5);--colors-tomato-p3-a-6: var(--colors-tomato-dark-p3-a-6);--colors-tomato-p3-a-7: var(--colors-tomato-dark-p3-a-7);--colors-tomato-p3-a-8: var(--colors-tomato-dark-p3-a-8);--colors-tomato-p3-a-9: var(--colors-tomato-dark-p3-a-9);--colors-tomato-p3-a-10: var(--colors-tomato-dark-p3-a-10);--colors-tomato-p3-a-11: var(--colors-tomato-dark-p3-a-11);--colors-tomato-p3-a-12: var(--colors-tomato-dark-p3-a-12);--colors-violet-1: var(--colors-violet-dark-1);--colors-violet-2: var(--colors-violet-dark-2);--colors-violet-3: var(--colors-violet-dark-3);--colors-violet-4: var(--colors-violet-dark-4);--colors-violet-5: var(--colors-violet-dark-5);--colors-violet-6: var(--colors-violet-dark-6);--colors-violet-7: var(--colors-violet-dark-7);--colors-violet-8: var(--colors-violet-dark-8);--colors-violet-9: var(--colors-violet-dark-9);--colors-violet-10: var(--colors-violet-dark-10);--colors-violet-11: var(--colors-violet-dark-11);--colors-violet-12: var(--colors-violet-dark-12);--colors-violet-a-1: var(--colors-violet-dark-a-1);--colors-violet-a-2: var(--colors-violet-dark-a-2);--colors-violet-a-3: var(--colors-violet-dark-a-3);--colors-violet-a-4: var(--colors-violet-dark-a-4);--colors-violet-a-5: var(--colors-violet-dark-a-5);--colors-violet-a-6: var(--colors-violet-dark-a-6);--colors-violet-a-7: var(--colors-violet-dark-a-7);--colors-violet-a-8: var(--colors-violet-dark-a-8);--colors-violet-a-9: var(--colors-violet-dark-a-9);--colors-violet-a-10: var(--colors-violet-dark-a-10);--colors-violet-a-11: var(--colors-violet-dark-a-11);--colors-violet-a-12: var(--colors-violet-dark-a-12);--colors-violet-p3-1: var(--colors-violet-dark-p3-1);--colors-violet-p3-2: var(--colors-violet-dark-p3-2);--colors-violet-p3-3: var(--colors-violet-dark-p3-3);--colors-violet-p3-4: var(--colors-violet-dark-p3-4);--colors-violet-p3-5: var(--colors-violet-dark-p3-5);--colors-violet-p3-6: var(--colors-violet-dark-p3-6);--colors-violet-p3-7: var(--colors-violet-dark-p3-7);--colors-violet-p3-8: var(--colors-violet-dark-p3-8);--colors-violet-p3-9: var(--colors-violet-dark-p3-9);--colors-violet-p3-10: var(--colors-violet-dark-p3-10);--colors-violet-p3-11: var(--colors-violet-dark-p3-11);--colors-violet-p3-12: var(--colors-violet-dark-p3-12);--colors-violet-p3-a-1: var(--colors-violet-dark-p3-a-1);--colors-violet-p3-a-2: var(--colors-violet-dark-p3-a-2);--colors-violet-p3-a-3: var(--colors-violet-dark-p3-a-3);--colors-violet-p3-a-4: var(--colors-violet-dark-p3-a-4);--colors-violet-p3-a-5: var(--colors-violet-dark-p3-a-5);--colors-violet-p3-a-6: var(--colors-violet-dark-p3-a-6);--colors-violet-p3-a-7: var(--colors-violet-dark-p3-a-7);--colors-violet-p3-a-8: var(--colors-violet-dark-p3-a-8);--colors-violet-p3-a-9: var(--colors-violet-dark-p3-a-9);--colors-violet-p3-a-10: var(--colors-violet-dark-p3-a-10);--colors-violet-p3-a-11: var(--colors-violet-dark-p3-a-11);--colors-violet-p3-a-12: var(--colors-violet-dark-p3-a-12);--colors-yellow-1: var(--colors-yellow-dark-1);--colors-yellow-2: var(--colors-yellow-dark-2);--colors-yellow-3: var(--colors-yellow-dark-3);--colors-yellow-4: var(--colors-yellow-dark-4);--colors-yellow-5: var(--colors-yellow-dark-5);--colors-yellow-6: var(--colors-yellow-dark-6);--colors-yellow-7: var(--colors-yellow-dark-7);--colors-yellow-8: var(--colors-yellow-dark-8);--colors-yellow-9: var(--colors-yellow-dark-9);--colors-yellow-10: var(--colors-yellow-dark-10);--colors-yellow-11: var(--colors-yellow-dark-11);--colors-yellow-12: var(--colors-yellow-dark-12);--colors-yellow-a-1: var(--colors-yellow-dark-a-1);--colors-yellow-a-2: var(--colors-yellow-dark-a-2);--colors-yellow-a-3: var(--colors-yellow-dark-a-3);--colors-yellow-a-4: var(--colors-yellow-dark-a-4);--colors-yellow-a-5: var(--colors-yellow-dark-a-5);--colors-yellow-a-6: var(--colors-yellow-dark-a-6);--colors-yellow-a-7: var(--colors-yellow-dark-a-7);--colors-yellow-a-8: var(--colors-yellow-dark-a-8);--colors-yellow-a-9: var(--colors-yellow-dark-a-9);--colors-yellow-a-10: var(--colors-yellow-dark-a-10);--colors-yellow-a-11: var(--colors-yellow-dark-a-11);--colors-yellow-a-12: var(--colors-yellow-dark-a-12);--colors-yellow-p3-1: var(--colors-yellow-dark-p3-1);--colors-yellow-p3-2: var(--colors-yellow-dark-p3-2);--colors-yellow-p3-3: var(--colors-yellow-dark-p3-3);--colors-yellow-p3-4: var(--colors-yellow-dark-p3-4);--colors-yellow-p3-5: var(--colors-yellow-dark-p3-5);--colors-yellow-p3-6: var(--colors-yellow-dark-p3-6);--colors-yellow-p3-7: var(--colors-yellow-dark-p3-7);--colors-yellow-p3-8: var(--colors-yellow-dark-p3-8);--colors-yellow-p3-9: var(--colors-yellow-dark-p3-9);--colors-yellow-p3-10: var(--colors-yellow-dark-p3-10);--colors-yellow-p3-11: var(--colors-yellow-dark-p3-11);--colors-yellow-p3-12: var(--colors-yellow-dark-p3-12);--colors-yellow-p3-a-1: var(--colors-yellow-dark-p3-a-1);--colors-yellow-p3-a-2: var(--colors-yellow-dark-p3-a-2);--colors-yellow-p3-a-3: var(--colors-yellow-dark-p3-a-3);--colors-yellow-p3-a-4: var(--colors-yellow-dark-p3-a-4);--colors-yellow-p3-a-5: var(--colors-yellow-dark-p3-a-5);--colors-yellow-p3-a-6: var(--colors-yellow-dark-p3-a-6);--colors-yellow-p3-a-7: var(--colors-yellow-dark-p3-a-7);--colors-yellow-p3-a-8: var(--colors-yellow-dark-p3-a-8);--colors-yellow-p3-a-9: var(--colors-yellow-dark-p3-a-9);--colors-yellow-p3-a-10: var(--colors-yellow-dark-p3-a-10);--colors-yellow-p3-a-11: var(--colors-yellow-dark-p3-a-11);--colors-yellow-p3-a-12: var(--colors-yellow-dark-p3-a-12);--colors-likec4-background-pattern: color-mix(in oklab, var(--mantine-color-dark-4) 70%, transparent 30%);--colors-likec4-mix-color: white;--colors-likec4-panel-bg: var(--mantine-color-dark-6);--colors-likec4-panel-action-bg: color-mix(in oklab, var(--mantine-color-dark-7) 70%, transparent 30%);--colors-likec4-panel-action-bg-hover: var(--mantine-color-dark-8);--colors-likec4-panel-action-warning-hover: var(--mantine-color-orange-5);--colors-likec4-panel-action-warning-bg: color-mix(in oklab, var(--mantine-color-orange-9) 10%, transparent 90%);--colors-likec4-panel-action-warning-bg-hover: color-mix(in oklab, var(--mantine-color-orange-9) 20%, transparent 80%);--colors-likec4-dropdown-bg: var(--mantine-color-dark-6);--colors-likec4-overlay-body: var(--mantine-color-dark-6);--colors-likec4-compare-manual: var(--mantine-color-orange-6);--colors-likec4-compare-manual-outline: color-mix(in oklab, var(--mantine-color-orange-6) 80%, transparent 20%) }[data-mantine-color-scheme=light]{--colors-likec4-background-pattern: var(--mantine-color-gray-4);--colors-likec4-mix-color: black;--colors-likec4-panel-border: var(--mantine-color-gray-2);--colors-likec4-overlay-backdrop: rgb(15 15 15);--colors-likec4-compare-manual: var(--mantine-color-orange-8);--colors-likec4-compare-manual-outline: var(--mantine-color-orange-8) }@keyframes indicatorOpacity{0%{opacity:.8}to{opacity:.3}}@keyframes xyedgeAnimated{0%{stroke-dashoffset:36}to{stroke-dashoffset:0}}}@layer recipes{@layer _base{.likec4-edge-label{background:var(--xy-edge-label-background-color);border:0px solid transparent;padding-block:var(--spacing-1);padding-inline:var(--spacing-1\\.5);gap:var(--spacing-0\\.5);border-radius:4px;font-family:var(--fonts-likec4-relation);display:flex;flex-direction:column;align-items:center;color:var(--xy-edge-label-color);width:max-content;max-width:var(--sizes-100\\%)}.likec4-edge-label .likec4-edge-label__step-number{padding:var(--spacing-1);background:color-mix(in oklab,var(--likec4-palette-relation-label-bg),var(--colors-likec4-mix-color) 10%);flex:0 0 auto;align-self:stretch;font-weight:600;font-size:14px;text-align:center;font-variant-numeric:tabular-nums;min-width:22px;border-top-left-radius:4px;border-bottom-left-radius:4px}.likec4-edge-label .likec4-edge-label__step-number:only-child{border-radius:4px;min-width:24px}[data-mantine-color-scheme=dark] :where([data-likec4-color=gray]) .likec4-edge-label .likec4-edge-label__step-number{background:color-mix(in oklab,var(--likec4-palette-relation-label-bg),var(--colors-likec4-mix-color) 15%)}.likec4-edge-label .likec4-edge-label__text{margin:var(--spacing-0);white-space-collapse:preserve-breaks;font-size:14px;line-height:1.2}.likec4-edge-label .likec4-edge-label__contents{display:contents}.likec4-edge-label .likec4-edge-label__contents:is(:empty,[data-empty]){display:none!important}.likec4-edge-label .likec4-edge-label__technology{text-align:center;white-space-collapse:preserve-breaks;font-size:11px;line-height:var(--line-heights-1);opacity:.75}.likec4-overlay{--_blur: 0px;--_level: 0;--_offset: 0px;--_inset: calc((1 + var(--_level) * .75) * var(--_offset));--_opacity: 0%;--_border-radius: 0px;margin:var(--spacing-0);background:var(--colors-likec4-overlay-border);border:var(--borders-transparent);inset:var(--spacing-0);padding:var(--spacing-0);outline:var(--borders-none);border-radius:var(--_border-radius);box-sizing:border-box;position:fixed;box-shadow:var(--shadows-xl);width:100vw;height:100vh;max-width:100vw;max-height:100vh}.likec4-overlay::backdrop{cursor:zoom-out}.likec4-overlay .likec4-overlay-body{border:var(--borders-transparent);background:var(--colors-likec4-overlay-body);overflow:hidden;position:relative;container-name:likec4-dialog;container-type:size;width:var(--sizes-100\\%);height:var(--sizes-100\\%)}.likec4-markdown-block{--text-fz: 1rem;--text-fz-sm: calc(var(--text-fz) * var(--mantine-scale, 1) / 1.125);--text-fz-md: calc(var(--text-fz) * var(--mantine-scale, 1));--typography-spacing: calc(.75 * var(--text-fz-md));--text-fw-headings: 600;--code-background: var(--mantine-color-gray-2);--code-color: var(--mantine-color-black);font-size:var(--text-fz-md);line-height:var(--mantine-line-height)}[data-mantine-color-scheme=dark] .likec4-markdown-block{--code-background: var(--mantine-color-dark-8);--code-color: var(--mantine-color-white);--color-border-default: #30363d;--color-accent-fg: #58a6ff;--color-accent-emphasis: #1f6feb;--color-danger-fg: #f85149;--color-danger-emphasis: #da3633;--color-attention-fg: #d29922;--color-attention-emphasis: #9e6a03;--color-done-fg: #a371f7;--color-done-emphasis: #8957e5;--color-success-fg: #3fb950;--color-success-emphasis: #238636}[data-mantine-color-scheme=light] .likec4-markdown-block{--color-border-default: #d0d7de;--color-accent-fg: #0969da;--color-accent-emphasis: #0969da;--color-danger-fg: #d1242f;--color-danger-emphasis: #cf222e;--color-attention-fg: #9a6700;--color-attention-emphasis: #9a6700;--color-done-fg: #8250df;--color-done-emphasis: #8250df;--color-success-fg: #1a7f37;--color-success-emphasis: #1f883d}.likec4-markdown-block :where(hr){border:var(--borders-none);border-bottom:1px solid;border-color:var(--mantine-color-gray-3);margin-top:calc(var(--typography-spacing) / 2);margin-bottom:calc(var(--typography-spacing) / 2)}[data-mantine-color-scheme=dark] .likec4-markdown-block :where(hr){border-color:var(--mantine-color-dark-3)}.likec4-markdown-block :where(pre){margin:var(--spacing-0);padding-inline:var(--spacing-3);padding-block:var(--spacing-2);border-radius:var(--radii-sm);line-height:var(--mantine-line-height-xs);font-family:var(--mantine-font-family-monospace);font-size:var(--text-fz-sm);background-color:var(--code-background);color:var(--code-color);margin-top:var(--typography-spacing);margin-bottom:var(--typography-spacing);overflow-x:auto}.likec4-markdown-block :where(code){padding:1px 4px;border-radius:var(--radii-xs);line-height:var(--line-heights-1);font-family:var(--mantine-font-family-monospace);font-size:var(--text-fz-sm);background-color:var(--code-background);color:var(--code-color)}.likec4-markdown-block :where(pre code){padding:var(--spacing-0);border:0;border-radius:var(--radii-0);background-color:var(--colors-transparent);color:inherit}.likec4-markdown-block :where(blockquote){margin:var(--spacing-0);padding:var(--spacing-xs);border-radius:var(--mantine-radius-sm);font-size:var(--text-fz-md);background-color:var(--mantine-color-gray-1)}[data-mantine-color-scheme=dark] .likec4-markdown-block :where(blockquote){background-color:var(--mantine-color-dark-5)}.likec4-markdown-block :where(blockquote):not(:first-child){margin-top:var(--typography-spacing)}.likec4-markdown-block :where(h1,h2,h3,h4,h5,h6){text-wrap:var(--mantine-heading-text-wrap);line-height:1.5;font-family:var(--mantine-font-family-headings);margin-bottom:var(--typography-spacing)}.likec4-markdown-block :where(a){text-decoration:none;font-size:var(--text-fz-md);color:var(--mantine-color-anchor);font-weight:500}.likec4-markdown-block :where(a):is(:hover,[data-hover]){text-decoration:underline}.likec4-markdown-block .markdown-alert{border-left:.25em solid var(--borderColor-default, var(--color-border-default));color:inherit;margin-bottom:calc(var(--typography-spacing) * 1.5);padding-left:1em;padding-right:.5em}.likec4-markdown-block .markdown-alert .markdown-alert-title{gap:var(--spacing-2);align-items:center;display:flex;font-size:var(--text-fz-md);font-weight:500;line-height:1.5;margin-bottom:.1em}.likec4-markdown-block .markdown-alert .markdown-alert-title svg{fill:currentColor;height:var(--text-fz-md)}.likec4-markdown-block .markdown-alert.markdown-alert-note .markdown-alert-title{color:var(--color-accent-fg)}.likec4-markdown-block .markdown-alert.markdown-alert-tip .markdown-alert-title{color:var(--color-success-fg)}.likec4-markdown-block .markdown-alert.markdown-alert-important .markdown-alert-title{color:var(--color-done-fg)}.likec4-markdown-block .markdown-alert.markdown-alert-warning .markdown-alert-title{color:var(--color-attention-fg)}.likec4-markdown-block .markdown-alert.markdown-alert-caution .markdown-alert-title{color:var(--color-danger-fg)}.likec4-markdown-block .markdown-alert:last-child{margin-bottom:var(--spacing-0)!important}.likec4-markdown-block .markdown-alert.markdown-alert-note{border-left-color:var(--borderColor-accent-emphasis,var(--color-accent-emphasis))}.likec4-markdown-block .markdown-alert.markdown-alert-tip{border-left-color:var(--borderColor-success-emphasis,var(--color-success-emphasis))}.likec4-markdown-block .markdown-alert.markdown-alert-important{border-left-color:var(--borderColor-done-emphasis,var(--color-done-emphasis))}.likec4-markdown-block .markdown-alert.markdown-alert-warning{border-left-color:var(--borderColor-attention-emphasis,var(--color-attention-emphasis))}.likec4-markdown-block .markdown-alert.markdown-alert-caution{border-left-color:var(--borderColor-danger-emphasis,var(--color-danger-emphasis))}.likec4-markdown-block :is(h1){font-size:calc(1.476 * var(--text-fz-md));font-weight:var(--text-fw-headings)}.likec4-markdown-block :is(h2){font-size:calc(1.383 * var(--text-fz-md));font-weight:var(--text-fw-headings)}.likec4-markdown-block :is(h3){font-size:calc(1.296 * var(--text-fz-md));font-weight:var(--text-fw-headings)}.likec4-markdown-block :is(h4){font-size:calc(1.215 * var(--text-fz-md));font-weight:var(--text-fw-headings)}.likec4-markdown-block :is(h5){font-size:calc(1.138 * var(--text-fz-md));font-weight:var(--text-fw-headings)}.likec4-markdown-block :is(h6){font-size:calc(1.067 * var(--text-fz-md));font-weight:var(--text-fw-headings)}.likec4-markdown-block :where(p){font-size:var(--text-fz-md);margin-top:var(--spacing-0);margin-bottom:var(--typography-spacing)}.likec4-markdown-block :where(strong){font-weight:500}.likec4-markdown-block :where(mark){font-size:var(--text-fz-md);background-color:var(--mantine-color-yellow-2);color:inherit}[data-mantine-color-scheme=dark] .likec4-markdown-block :where(mark){background-color:var(--mantine-color-yellow-5);color:var(--mantine-color-black)}.likec4-markdown-block :where(ul,ol):not([data-type=taskList]){padding-inline-start:var(--typography-spacing);list-style-position:inside;margin-bottom:var(--typography-spacing)}.likec4-markdown-block :where(table){border-collapse:collapse;caption-side:bottom;width:var(--sizes-100\\%);margin-bottom:var(--typography-spacing)}[data-mantine-color-scheme=light] .likec4-markdown-block :where(table){--table-border-color: var(--mantine-color-gray-3)}[data-mantine-color-scheme=dark] .likec4-markdown-block :where(table){--table-border-color: var(--mantine-color-dark-4)}.likec4-markdown-block :where(table) :where(th){padding:var(--typography-spacing);text-align:left;font-weight:700;font-size:var(--text-fz-sm)}.likec4-markdown-block :where(table) :where(td){padding:var(--typography-spacing);border-bottom:1px solid;border-color:var(--table-border-color);font-size:var(--text-fz-sm)}.likec4-markdown-block :where(table) :where(thead th){border-bottom:1px solid;border-color:var(--table-border-color)}.likec4-markdown-block :where(table) :where(tfoot th){border-top:1px solid;border-color:var(--table-border-color)}.likec4-markdown-block :where(table) :where(tr:last-of-type td){border-bottom:0}.likec4-markdown-block :where(table) :where(caption){font-size:var(--text-fz-sm);color:var(--mantine-color-dimmed);margin-top:calc(.5 * var(--typography-spacing) + 1px)}.likec4-markdown-block :first-child{margin-top:var(--spacing-0)}.likec4-markdown-block :last-child{margin-bottom:var(--spacing-0)}.likec4-markdown-block :is(h1,h2,h3,h4,h5,h6):not(:first-child){margin-top:var(--typography-spacing)}.likec4-markdown-block :where(img){max-width:var(--sizes-100\\%);margin-bottom:var(--typography-spacing)}.likec4-navigation-panel-icon{color:var(--colors-likec4-panel-action)}.likec4-navigation-panel-icon:is(:disabled,[disabled],[data-disabled],[aria-disabled=true]){color:var(--colors-likec4-panel-action-disabled);opacity:.5}.likec4-navigation-panel-icon:not(:is(:disabled,[disabled],[data-disabled])):is(:hover,[data-hover]){color:var(--colors-likec4-panel-action-hover)}.action-btn{--actionbtn-color: var(--likec4-palette-loContrast);--actionbtn-color-hovered: var(--likec4-palette-loContrast);--actionbtn-color-hovered-btn: var(--likec4-palette-hiContrast);--actionbtn-bg-idle: color-mix(in oklab , var(--likec4-palette-fill), transparent 99%);--actionbtn-bg-hovered: color-mix(in oklab , var(--likec4-palette-fill) 65%, var(--likec4-palette-stroke));--actionbtn-bg-hovered-btn: color-mix(in oklab , var(--likec4-palette-fill) 50%, var(--likec4-palette-stroke));--ai-bg: var(--actionbtn-bg-idle);background:var(--ai-bg);color:var(--actionbtn-color);opacity:.75}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .action-btn{--ai-bg: var(--actionbtn-bg-hovered);opacity:1;color:var(--actionbtn-color-hovered)}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selectable) .action-btn{pointer-events:all;cursor:pointer}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .action-btn{display:none}:where([data-likec4-zoom-small=true]) .action-btn{display:none}.action-btn *{pointer-events:none}.action-btn:is(:hover,[data-hover]){--ai-bg: var(--actionbtn-bg-hovered-btn);opacity:1;color:var(--actionbtn-color-hovered-btn)}.likec4-compound-node{--likec4-palette-outline: oklab(from var(--likec4-palette-stroke) calc(l - .05) a b);--_border-width: 3px;--_border-radius: 6px;--_compound-transparency: 100%;--_border-transparency: 100%;--_indicator-spacing: calc(var(--_border-width) + 1px);--_compound-color: var(--likec4-palette-loContrast);padding:var(--spacing-0);margin:var(--spacing-0);border-style:solid;border-width:var(--_border-width);border-radius:var(--_border-radius);position:relative;pointer-events:none;background-clip:padding-box;-webkit-background-clip:padding-box;box-sizing:border-box;color:var(--_compound-color);width:var(--sizes-100\\%);height:var(--sizes-100\\%)}[data-mantine-color-scheme=dark] .likec4-compound-node{--likec4-palette-outline: oklab(from var(--likec4-palette-stroke) calc(l + .2) a b)}.likec4-compound-node:before{border-style:solid;border-width:calc(var(--_border-width) + 1px);border-radius:calc(var(--_border-radius) + 4px);border-color:var(--likec4-palette-outline);position:absolute;content:" ";pointer-events:none;display:none;animation-duration:.8s;animation-iteration-count:infinite;animation-direction:alternate;animation-name:indicatorOpacity;animation-timing-function:var(--easings-in);animation-play-state:paused;top:calc(-1 * var(--_indicator-spacing));left:calc(-1 * var(--_indicator-spacing));width:calc(100% + 2 * var(--_indicator-spacing));height:calc(100% + 2 * var(--_indicator-spacing))}:where(.react-flow__node,.react-flow__edge):is(:focus-visible,:focus,:focus-within) .likec4-compound-node:before{display:block;animation-play-state:running}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-compound-node:before{display:block;animation-play-state:running}.likec4-root:is([data-likec4-diagram-panning=true]) .likec4-compound-node:before{animation-play-state:paused}.likec4-compound-node:has(.likec4-compound-navigation) .likec4-compound-title-container{padding-left:24px}.likec4-compound-node .action-btn{--actionbtn-color: var(--_compound-color);--actionbtn-color-hovered: var(--_compound-color);--actionbtn-color-hovered-btn: color-mix(in oklab, var(--_compound-color) 80%, #fff);opacity:.6}.likec4-root:not([data-likec4-reduced-graphics]) .likec4-compound-node .action-btn{transition:all var(--durations-fast) var(--easings-in-out)}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-compound-node .action-btn{opacity:.75}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-compound-node .action-btn{opacity:.75}.likec4-compound-node .action-btn:is(:hover,[data-hover]){opacity:1}.likec4-compound-node .likec4-compound-title-container{gap:var(--spacing-1\\.5);position:absolute;display:flex;align-items:center;left:var(--spacing-2\\.5);top:var(--spacing-0\\.5);right:30px;width:auto;min-height:30px}:where(.react-flow__node.draggable) .likec4-compound-node .likec4-compound-title-container{pointer-events:all;cursor:grab}.likec4-compound-node .likec4-compound-title{flex:1 1 0%;font-family:var(--fonts-likec4-compound);font-weight:600;font-size:15px;text-transform:uppercase;letter-spacing:.25px;line-height:var(--line-heights-1);color:var(--_compound-color)}.likec4-compound-node .likec4-compound-icon{flex:0 0 20px;display:flex;align-items:center;justify-content:center;mix-blend-mode:hard-light;height:20px;width:20px}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-compound-node .likec4-compound-icon{mix-blend-mode:normal}.likec4-compound-node .likec4-compound-icon svg,.likec4-compound-node .likec4-compound-icon img{pointer-events:none;filter:drop-shadow(0 0 3px rgb(0 0 0 / 12%)) drop-shadow(0 1px 8px rgb(0 0 0 / 8%)) drop-shadow(1px 1px 16px rgb(0 0 0 / 3%));width:var(--sizes-100\\%);height:auto;max-height:var(--sizes-100\\%)}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-compound-node .likec4-compound-icon svg,.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-compound-node .likec4-compound-icon img{filter:none}.likec4-compound-node .likec4-compound-icon img{object-fit:contain}.likec4-compound-node .likec4-compound-navigation{position:absolute;top:var(--spacing-1);left:var(--spacing-0\\.5)}:where([data-likec4-zoom-small=true]) .likec4-compound-node .likec4-compound-navigation{display:none}.likec4-compound-node .likec4-compound-details{position:absolute;top:var(--spacing-0\\.5);right:var(--spacing-0\\.5)}:where([data-likec4-zoom-small=true]) .likec4-compound-node .likec4-compound-details{display:none}.likec4-edge-action-btn{--ai-bg: transparent;--ai-hover: color-mix(in oklab , var(--xy-edge-label-background-color), var(--colors-likec4-mix-color) 10%);--ai-size: var(--ai-size-sm);--ai-radius: var(--radii-sm);transition:all var(--durations-fast) var(--easings-in-out);pointer-events:all;color:var(--xy-edge-label-color);cursor:pointer;opacity:.75;translate:var(--translate-x) var(--translate-y)}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-edge-action-btn{--ai-bg: var(--xy-edge-label-background-color);opacity:1}.likec4-edge-action-btn .tabler-icon{stroke-width:2;width:80%;height:80%}.likec4-edge-action-btn:is(:hover,[data-hover]){--translate-y: 2px;scale:1.15}.likec4-edge-action-btn:is(:active,[data-active]){--translate-y: -1px;scale:.9}.likec4-element-node-data{margin:0 auto;flex:1 1 0%;overflow:hidden;gap:var(--spacing-3);position:relative;display:flex;align-items:center;justify-content:center;flex-direction:row;pointer-events:none;text-align:center;height:fit-content;width:fit-content;max-height:var(--sizes-100\\%);max-width:var(--sizes-100\\%);padding-top:var(--likec4-spacing);padding-bottom:var(--likec4-spacing);padding-left:calc(var(--likec4-spacing) + 8px);padding-right:calc(var(--likec4-spacing) + 8px)}:where([data-likec4-shape-size=xs]) .likec4-element-node-data{--likec4-icon-size: 24px}:where([data-likec4-shape-size=sm]) .likec4-element-node-data{--likec4-icon-size: 36px}:where([data-likec4-shape-size=md]) .likec4-element-node-data{--likec4-icon-size: 60px}:where([data-likec4-shape-size=lg]) .likec4-element-node-data{--likec4-icon-size: 82px;gap:var(--spacing-4)}:where([data-likec4-shape-size=xl]) .likec4-element-node-data{--likec4-icon-size: 90px;gap:var(--spacing-4)}.likec4-element-node-data:has([data-likec4-icon]){gap:var(--spacing-4);text-align:left}.likec4-element-node-data:has([data-likec4-icon]) .likec4-element-node-content{align-items:flex-start;min-width:calc(50% + var(--likec4-icon-size))}:where([data-likec4-shape=queue]) .likec4-element-node-data{padding-left:46px;padding-right:16px}:where([data-likec4-shape=mobile]) .likec4-element-node-data{padding-left:46px;padding-right:16px}:where([data-likec4-shape=cylinder]) .likec4-element-node-data{padding-top:30px}:where([data-likec4-shape=storage]) .likec4-element-node-data{padding-top:30px}:where([data-likec4-shape=browser]) .likec4-element-node-data{padding-top:32px;padding-bottom:28px}:where([data-likec4-shape=bucket]) .likec4-element-node-data{padding-left:calc(var(--likec4-spacing) + 20px);padding-right:calc(var(--likec4-spacing) + 20px)}.likec4-element-node-data [data-likec4-icon]{flex:0 0 var(--likec4-icon-size, 48px);display:flex;align-self:flex-start;align-items:center;justify-content:center;mix-blend-mode:hard-light;height:var(--likec4-icon-size, 48px);width:var(--likec4-icon-size, 48px)}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-node-data [data-likec4-icon]{mix-blend-mode:normal}.likec4-element-node-data [data-likec4-icon] svg,.likec4-element-node-data [data-likec4-icon] img{pointer-events:none;filter:drop-shadow(0 0 3px rgb(0 0 0 / 12%));width:var(--sizes-100\\%);height:auto;max-height:var(--sizes-100\\%)}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-node-data [data-likec4-icon] svg,.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-node-data [data-likec4-icon] img{filter:none}.likec4-element-node-data [data-likec4-icon] img{object-fit:contain}.likec4-element-node-data .likec4-element-node-content{flex:0 1 auto;overflow:hidden;gap:var(--spacing-2);display:flex;flex-direction:column;align-items:stretch;justify-content:center;flex-wrap:nowrap;height:fit-content;width:fit-content;max-height:var(--sizes-100\\%);max-width:var(--sizes-100\\%)}.likec4-element-node-data .likec4-element-node-content:has([data-likec4-node-description]):has([data-likec4-node-technology]){gap:var(--spacing-1\\.5)}.likec4-element-node-data [data-likec4-node-title]{flex:0 0 auto;font-family:var(--likec4-element-font, var(--fonts-likec4));font-weight:500;font-size:var(--likec4-text-size);line-height:1.15;text-wrap-style:balance;white-space:preserve-breaks;text-align:var(__text-align);color:var(--likec4-palette-hiContrast)}.likec4-element-node-data [data-likec4-node-description]{overflow:hidden;flex-grow:0;flex-shrink:1;--text-fz: calc(var(--likec4-text-size) * .74);font-family:var(--likec4-element-font, var(--fonts-likec4));font-weight:400;font-size:calc(var(--likec4-text-size) * .74);line-height:1.3;text-wrap-style:pretty;color:var(--likec4-palette-loContrast);text-align:var(__text-align);text-overflow:ellipsis}:where([data-likec4-shape-size=xs]) .likec4-element-node-data [data-likec4-node-description]{display:none}:where([data-likec4-zoom-small=true]) .likec4-element-node-data [data-likec4-node-description]{display:none}.likec4-element-node-data [data-likec4-node-description] a{pointer-events:all}.likec4-element-node-data [data-likec4-node-description] .markdown-alert{mix-blend-mode:screen}.likec4-element-node-data [data-likec4-node-technology]{flex:0 0 auto;text-wrap:balance;--text-fz: calc(var(--likec4-text-size) * .74);font-family:var(--likec4-element-font, var(--fonts-likec4));font-weight:400;font-size:calc(var(--likec4-text-size) * .635);line-height:1.125;text-wrap-style:pretty;color:var(--likec4-palette-loContrast);text-align:var(__text-align);opacity:.92}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-element-node-data [data-likec4-node-technology]{opacity:1}:where([data-likec4-shape-size=xs]) .likec4-element-node-data [data-likec4-node-technology]{display:none}:where([data-likec4-shape-size=sm]) .likec4-element-node-data [data-likec4-node-technology]{display:none}:where([data-likec4-zoom-small=true]) .likec4-element-node-data [data-likec4-node-technology]{display:none}.likec4-element-node{padding:var(--spacing-0);margin:var(--spacing-0);position:relative;display:flex;align-items:center;justify-content:center;pointer-events:none;width:var(--sizes-full);height:var(--sizes-full)}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selectable) .likec4-element-node{pointer-events:all}:where(.react-flow__node.selectable:not(.dragging)) .likec4-element-node{cursor:pointer}.likec4-element-node:is([data-likec4-shape=document]){padding-bottom:16px}.likec4-element-node:is(:focus-visible,[data-focus-visible]){outline:var(--borders-none)}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selectable) .likec4-element-node:before{background:var(--colors-transparent);content:" ";position:absolute;pointer-events:all;top:calc(100% - 4px);left:var(--spacing-0);width:var(--sizes-full);height:24px}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-node:before{display:none}.likec4-element-shape{--likec4-palette-outline: oklab(from var(--likec4-palette-stroke) calc(l - .05) a b);--likec4-outline-size: 4px;overflow:visible;position:absolute;pointer-events:none;top:var(--spacing-0);left:var(--spacing-0);width:var(--sizes-100\\%);height:var(--sizes-100\\%)}[data-mantine-color-scheme=dark] .likec4-element-shape{--likec4-palette-outline: oklab(from var(--likec4-palette-stroke) calc(l + .2) a b)}.likec4-element-shape .likec4-shape-outline{opacity:.8;visibility:hidden;animation-play-state:paused;pointer-events:none}:where([data-likec4-zoom-small=true]) .likec4-element-shape .likec4-shape-outline{visibility:hidden}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-element-shape .likec4-shape-outline{visibility:visible;animation-play-state:running}:where(.react-flow__node,.react-flow__edge):is(:focus-visible,:focus,:focus-within) .likec4-element-shape .likec4-shape-outline{visibility:visible;animation-play-state:running}.group:is(:focus-visible,[data-focus-visible]) .likec4-element-shape .likec4-shape-outline{visibility:visible;animation-play-state:running}.likec4-root:is([data-likec4-diagram-panning=true]) .likec4-element-shape .likec4-shape-outline{animation-play-state:paused}.likec4-tag{transition:all var(--durations-fast) var(--easings-in-out);gap:1px;padding-inline:var(--spacing-1);padding-block:var(--spacing-0);pointer-events:all;display:inline-flex;align-items:center;justify-content:center;font-size:var(--font-sizes-xs);cursor:default;font-family:var(--fonts-likec4);font-weight:700;border:var(--borders-none);border-radius:3px;color:var(--colors-likec4-tag-text);background-color:var(--colors-likec4-tag-bg)}.likec4-tag:is(:hover,[data-hover]){background-color:var(--colors-likec4-tag-bg-hover)}.likec4-tag{white-space:nowrap;min-width:40px;width:min-content}@media screen and (min-width:36rem){.likec4-markdown-block .markdown-alert.markdown-alert-note .markdown-alert-title{color:var(--fgColor-accent,var(--color-accent-fg))}.likec4-markdown-block .markdown-alert.markdown-alert-tip .markdown-alert-title{color:var(--fgColor-success,var(--color-success-fg))}.likec4-markdown-block .markdown-alert.markdown-alert-important .markdown-alert-title{color:var(--fgColor-done,var(--color-done-fg))}.likec4-markdown-block .markdown-alert.markdown-alert-warning .markdown-alert-title{color:var(--fgColor-attention,var(--color-attention-fg))}.likec4-markdown-block .markdown-alert.markdown-alert-caution .markdown-alert-title{color:var(--fgColor-danger,var(--color-danger-fg))}.likec4-element-node-data [data-likec4-icon] svg,.likec4-element-node-data [data-likec4-icon] img{filter:drop-shadow(0 1px 8px rgb(0 0 0 / 8%))}}@media screen and (min-width:48rem){.likec4-element-node-data [data-likec4-icon] svg,.likec4-element-node-data [data-likec4-icon] img{filter:drop-shadow(1px 1px 16px rgb(0 0 0 / 3%))}}@media print{.action-btn{display:none}.likec4-compound-node .likec4-compound-icon{mix-blend-mode:normal!important}.likec4-compound-node .action-btn,.likec4-compound-node .likec4-compound-navigation,.likec4-compound-node .likec4-compound-details,.likec4-edge-action-btn{display:none}}}.likec4-edge-label--pointerEvents_all{pointer-events:all}.likec4-edge-label--cursor_default{cursor:default}.likec4-edge-label--cursor_pointer{cursor:pointer}.likec4-edge-label--isStepEdge_true{padding:var(--spacing-0);gap:var(--spacing-1);flex-direction:row}.likec4-edge-label--isStepEdge_true .likec4-edge-label__contents{gap:var(--spacing-0\\.5);display:flex;flex-direction:column;align-items:center;padding-top:var(--spacing-0\\.5);padding-right:var(--spacing-1);padding-bottom:var(--spacing-1)}.likec4-edge-label--isStepEdge_true .likec4-edge-label__text{padding-block:var(--spacing-0\\.5);padding-right:var(--spacing-0\\.5)}.likec4-edge-label--pointerEvents_none{pointer-events:none}.likec4-overlay--withBackdrop_true::backdrop{background:color-mix(in oklab,var(--colors-likec4-overlay-backdrop) var(--_opacity),transparent);backdrop-filter:blur(var(--_blur));-webkit-backdrop-filter:blur(var(--_blur))}.likec4-overlay--fullscreen_true{inset:var(--spacing-0);padding:var(--spacing-0)}.likec4-overlay--withBackdrop_false::backdrop{display:none}.likec4-markdown-block--value_plaintext :where(p){white-space:preserve-breaks}.likec4-markdown-block--uselikec4palette_true{--code-background: color-mix(in oklab , var(--likec4-palette-stroke) 70%, transparent);--code-color: var(--likec4-palette-loContrast);--typography-spacing: calc(.5 * var(--text-fz-md))}.likec4-markdown-block--uselikec4palette_true :where(blockquote){padding:var(--spacing-xxs);--mix-backgroundColor: color-mix(in srgb, var(--likec4-palette-stroke) 65%, transparent);background-color:var(--mix-backgroundColor, var(--likec4-palette-stroke))}.likec4-markdown-block--uselikec4palette_true :where(hr){--mix-borderColor: color-mix(in srgb, var(--likec4-palette-stroke) 85%, transparent);border-color:var(--mix-borderColor, var(--likec4-palette-stroke))}.likec4-markdown-block--uselikec4palette_true :where(a){--mix-color: color-mix(in srgb, var(--likec4-palette-fill) 45%, transparent);color:var(--mix-color, var(--likec4-palette-fill));mix-blend-mode:difference}.likec4-markdown-block--uselikec4palette_true :where(strong){color:color-mix(in oklab,var(--likec4-palette-hiContrast) 50%,var(--likec4-palette-loContrast))}.likec4-navigation-panel-icon--variant_default{background-color:var(--colors-transparent)}.likec4-navigation-panel-icon--variant_default:not(:is(:disabled,[disabled],[data-disabled])):is(:hover,[data-hover]){background-color:var(--colors-likec4-panel-action-bg-hover)}.likec4-navigation-panel-icon--variant_filled{background-color:var(--colors-likec4-panel-action-bg)}.likec4-navigation-panel-icon--variant_filled:not(:is(:disabled,[disabled],[data-disabled])):is(:hover,[data-hover]){background-color:var(--colors-likec4-panel-action-bg-hover)}.likec4-navigation-panel-icon--type_warning{color:var(--colors-likec4-panel-action-warning)}.likec4-navigation-panel-icon--type_warning:is(:hover,[data-hover]){color:var(--colors-likec4-panel-action-warning-hover)}.action-btn--size_md{--ai-size: var(--ai-size-md)}.action-btn--radius_md{--ai-radius: var(--mantine-radius-md)}.action-btn--variant_transparent{--actionbtn-bg-hovered: var(--actionbtn-bg-idle)}.action-btn--variant_filled{box-shadow:1px 1px 3px 0 transparent}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .action-btn--variant_filled{box-shadow:1px 1px 3px #0003}.likec4-root:is([data-likec4-reduced-graphics]) .action-btn--variant_filled{box-shadow:var(--shadows-none)}.action-btn--size_sm{--ai-size: var(--ai-size-sm)}.action-btn--radius_sm{--ai-radius: var(--mantine-radius-sm)}.likec4-compound-node--borderStyle_dashed{border-style:dashed}.likec4-compound-node--borderStyle_none{--_indicator-spacing: calc(var(--_border-width) * 2);border-color:var(--colors-transparent)!important;background-clip:border-box!important;-webkit-background-clip:border-box!important}.likec4-compound-node--isTransparent_false{border-color:var(--likec4-palette-stroke);background-color:var(--likec4-palette-fill)}.likec4-root:not([data-likec4-reduced-graphics]) .likec4-compound-node--isTransparent_false{box-shadow:0 4px 10px .5px #0000001a,0 2px 2px -1px #0006}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-compound-node--isTransparent_false{box-shadow:var(--shadows-none)}.likec4-root:is([data-likec4-diagram-panning=true]) .likec4-compound-node--isTransparent_false{box-shadow:var(--shadows-none)!important}.likec4-compound-node--isTransparent_true{border-color:color-mix(in oklab,var(--likec4-palette-stroke) var(--_border-transparency),transparent);background-color:color-mix(in oklab,var(--likec4-palette-fill) var(--_compound-transparency),transparent)}.likec4-compound-node--inverseColor_true{--_compound-color: var(--likec4-palette-stroke)}[data-mantine-color-scheme=dark] .likec4-compound-node--inverseColor_true{--_compound-color: color-mix(in oklab, var(--likec4-palette-loContrast) 60%, var(--likec4-palette-fill))}[data-mantine-color-scheme=dark] .likec4-compound-node--inverseColor_true .action-btn{--actionbtn-color-hovered-btn: var(--likec4-palette-loContrast)}[data-mantine-color-scheme=light] .likec4-compound-node--inverseColor_true .action-btn{--actionbtn-color: var(--likec4-palette-stroke);--actionbtn-color-hovered: var(--likec4-palette-stroke);--actionbtn-color-hovered-btn: var(--likec4-palette-hiContrast);--actionbtn-bg-hovered: var(--likec4-palette-fill)/50;--actionbtn-bg-hovered-btn: var(--likec4-palette-fill)}.likec4-compound-node--borderStyle_solid{border-style:solid}.likec4-compound-node--borderStyle_dotted{border-style:dotted}.likec4-element-shape--shapetype_html{border:var(--borders-none);border-radius:6px;transition:background-color .12s linear,box-shadow .13s var(--easings-in-out);background-color:var(--likec4-palette-fill);box-shadow:0 2px 1px #00000036,0 1px 1px color-mix(in oklab,var(--likec4-palette-stroke) 40%,transparent),0 5px 3px #0000001a;transition-delay:0ms}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-shape--shapetype_html{transition:none}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-element-shape--shapetype_html{box-shadow:#26394df2 0 20px 30px -10px}[data-mantine-color-scheme=dark] :where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-element-shape--shapetype_html{box-shadow:#0a0b10e5 0 20px 30px -10px}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-element-shape--shapetype_html{box-shadow:var(--shadows-none)}:where([data-likec4-zoom-small=true]) .likec4-element-shape--shapetype_html{box-shadow:var(--shadows-none)}.likec4-root:is([data-likec4-diagram-panning=true]) .likec4-element-shape--shapetype_html{box-shadow:var(--shadows-none)}.likec4-element-shape--shapetype_html .likec4-shape-multiple{border-radius:6px;transition:all var(--durations-fast) var(--easings-in-out);position:absolute;content:" ";background-color:var(--likec4-palette-fill);z-index:var(--z-index--1);filter:brightness(.5)!important;visibility:visible;top:16px;left:16px;width:calc(100% - 6px);height:calc(100% - 6px)}:where([data-likec4-zoom-small=true]) .likec4-element-shape--shapetype_html .likec4-shape-multiple{visibility:hidden}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-element-shape--shapetype_html .likec4-shape-multiple{visibility:hidden}:where(.react-flow__node,.react-flow__edge):is(:focus-visible,:focus,:focus-within) .likec4-element-shape--shapetype_html .likec4-shape-multiple{visibility:hidden}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-shape--shapetype_html .likec4-shape-multiple{visibility:hidden}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-element-shape--shapetype_html .likec4-shape-multiple{transform:translate(-14px,-14px)}.likec4-element-shape--shapetype_html .likec4-shape-outline{border-style:solid;border-width:var(--likec4-outline-size);border-radius:11px;border-color:var(--likec4-palette-outline);position:absolute;content:" ";animation-duration:.8s;animation-iteration-count:infinite;animation-direction:alternate;animation-name:indicatorOpacity;animation-timing-function:var(--easings-in);top:calc(-1 * var(--likec4-outline-size) - 1px);left:calc(-1 * var(--likec4-outline-size) - 1px);width:calc(100% + 2 * var(--likec4-outline-size) + 2px);height:calc(100% + 2 * var(--likec4-outline-size) + 2px)}.likec4-element-shape--shapetype_svg{transition:fill .12s linear,filter .13s var(--easings-in-out);fill:var(--likec4-palette-fill);stroke:var(--likec4-palette-stroke);transition-delay:0ms;filter:drop-shadow(0 2px 1px rgba(0,0,0,.21)) drop-shadow(0 1px 1px color-mix(in oklab,var(--likec4-palette-stroke) 40%,transparent)) drop-shadow(0 5px 3px rgba(0,0,0,.1))}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-element-shape--shapetype_svg{filter:drop-shadow(0 2px 1px rgba(0,0,0,.12)) drop-shadow(0px 4px 2px rgba(0,0,0,.12)) drop-shadow(0px 8px 4px rgba(0,0,0,.12)) drop-shadow(0px 16px 8px rgba(0,0,0,.1)) drop-shadow(0px 32px 16px rgba(0,0,0,.09))}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-element-shape--shapetype_svg{filter:none}:where([data-likec4-zoom-small=true]) .likec4-element-shape--shapetype_svg{filter:none}.likec4-root:is([data-likec4-diagram-panning=true]) .likec4-element-shape--shapetype_svg{filter:none}.likec4-element-shape--shapetype_svg [data-likec4-fill=fill]{fill:var(--likec4-palette-fill)}.likec4-element-shape--shapetype_svg [data-likec4-fill=stroke]{fill:var(--likec4-palette-stroke)}.likec4-element-shape--shapetype_svg [data-likec4-fill=mix-stroke]{fill:color-mix(in oklab,var(--likec4-palette-stroke) 80%,var(--likec4-palette-fill))}.likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){transition:all var(--durations-fast) var(--easings-in-out);transform-origin:50% 50%;transform:translate(14px,14px) perspective(200px) translateZ(-4px);filter:brightness(.5)!important;stroke:var(--colors-none)}:where([data-likec4-shape=queue]) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){transform-origin:75% 25%}:where([data-likec4-shape=cylinder]) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){transform-origin:50% 100%}:where([data-likec4-shape=storage]) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){transform-origin:50% 100%}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){transform:translate(2px,2px) perspective(200px) translateZ(-4px)}:where([data-likec4-zoom-small=true]) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){display:none}.likec4-root:is([data-likec4-reduced-graphics][data-likec4-diagram-panning=true]) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){display:none}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){display:none}:where(.react-flow__node,.react-flow__edge):is(:focus-visible,:focus,:focus-within) .likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]){display:none}.likec4-element-shape--shapetype_svg:is([data-likec4-shape-multiple=true]) [data-likec4-fill=mix-stroke]{fill:var(--likec4-palette-fill)}.likec4-element-shape--shapetype_svg .likec4-shape-outline{stroke:var(--likec4-palette-outline);fill:var(--colors-none);stroke-width:4;animation-duration:.8s;animation-iteration-count:infinite;animation-direction:alternate;animation-name:indicatorOpacity;animation-timing-function:var(--easings-in)}.likec4-tag--autoTextColor_false>span{color:var(--colors-likec4-tag-text)}.likec4-tag--autoTextColor_false>span:first-child{opacity:.65}.likec4-tag--autoTextColor_true>span{background:inherit;color:var(--colors-transparent);filter:invert(1) grayscale(1) brightness(1.3) contrast(1000);background-clip:text;-webkit-background-clip:text;mix-blend-mode:plus-lighter}.hover\\:likec4-tag--autoTextColor_true:is(:hover,[data-hover])>span{background:inherit;color:var(--colors-transparent);filter:invert(1) grayscale(1) brightness(1.3) contrast(1000);background-clip:text;-webkit-background-clip:text;mix-blend-mode:plus-lighter}.hover\\:likec4-tag--autoTextColor_false:is(:hover,[data-hover])>span{color:var(--colors-likec4-tag-text)}.hover\\:likec4-tag--autoTextColor_false:is(:hover,[data-hover])>span:first-child{opacity:.65}@media screen and (min-width:48rem){.likec4-overlay--fullscreen_false{--_border-radius: 6px;--_offset: 1rem;inset:var(--_inset) var(--_inset) var(--_offset) var(--_inset);padding:var(--spacing-1\\.5);border-radius:calc(var(--_border-radius) - 2px);width:calc(100vw - 2 * var(--_inset));height:calc(100vh - var(--_offset) - var(--_inset))}}@media screen and (min-width:62rem){.likec4-overlay--fullscreen_false{--_offset: 1rem}}@media screen and (min-width:75rem){.likec4-overlay--fullscreen_false{--_offset: 2rem}}@media screen and (min-width:88rem){.likec4-overlay--fullscreen_false{--_offset: 4rem}}@media print{.likec4-markdown-block--uselikec4palette_true :where(a){mix-blend-mode:normal!important}}@media print{.likec4-tag--autoTextColor_true>span{mix-blend-mode:normal!important}}@media print{.hover\\:likec4-tag--autoTextColor_true:is(:hover,[data-hover])>span{mix-blend-mode:normal!important}}}@layer recipes.slots{@layer _base{.likec4-navlink__root{border-radius:var(--radii-sm);padding-inline:var(--spacing-xs);padding-block:var(--spacing-xxs)}.likec4-navlink__root:is(:hover,[data-hover]):not([data-active]){background-color:var(--colors-mantine-colors-gray\\[1\\])}[data-mantine-color-scheme=dark] .likec4-navlink__root:is(:hover,[data-hover]):not([data-active]){background-color:var(--colors-mantine-colors-dark\\[5\\])}.likec4-navlink__body{gap:var(--spacing-0\\.5);display:flex;flex-direction:column}.likec4-navlink__section:where([data-position=left]){margin-inline-end:var(--spacing-xxs)}.likec4-navlink__label{display:block;font-size:var(--font-sizes-sm);font-weight:500;line-height:1.2}.likec4-navlink__description{display:block;font-size:var(--font-sizes-xxs);line-height:1.2}.likec4-navigation-panel__root{margin:var(--spacing-0);gap:var(--spacing-xxs);display:flex;flex-direction:column;align-items:flex-start;pointer-events:none;position:absolute;top:var(--spacing-0);left:var(--spacing-0);width:var(--sizes-100\\%);max-width:100vw}.likec4-navigation-panel__body{gap:var(--spacing-xs);display:flex;flex-direction:row;align-items:center;padding:var(--spacing-1);border:1px solid var(--colors-likec4-panel-border);border-radius:var(--radii-0);background-color:var(--colors-likec4-panel-bg);position:relative;pointer-events:all;cursor:default;width:var(--sizes-100\\%)}.likec4-navigation-panel__logo{padding:var(--spacing-0\\.5);margin:var(--spacing-0);background:var(--colors-none);border:var(--borders-none);display:flex;flex-direction:row;cursor:pointer}.likec4-navigation-panel__label{transition:all var(--durations-fast) var(--easings-in-out);font-size:var(--font-sizes-sm);font-weight:500;-webkit-user-select:none;user-select:none;color:var(--colors-likec4-panel-text)}.likec4-edge__path{fill:var(--colors-none);stroke-dashoffset:0}.likec4-root:not([data-likec4-reduced-graphics]) .likec4-edge__path{transition:stroke .13s ease-out,stroke-width .13s ease-out;animation-duration:.8s;animation-iteration-count:infinite;animation-timing-function:linear;animation-fill-mode:both;animation-name:xyedgeAnimated;animation-play-state:paused}:where([data-edge-dir=back]) .likec4-edge__path{animation-direction:reverse}:where(.react-flow__node,.react-flow__edge):has([data-likec4-dimmed]) .likec4-edge__path{animation-play-state:paused}:where([data-likec4-zoom-small=true]) .likec4-edge__path{animation-name:none}.likec4-root:is([data-likec4-diagram-panning=true]) .likec4-edge__path{stroke-dasharray:none!important;animation-play-state:paused}.likec4-root:not([data-likec4-reduced-graphics]) :where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-edge__path{animation-play-state:running;animation-delay:.45s}.likec4-root:not([data-likec4-reduced-graphics]) :where(.selected,[data-edge-active=true],[data-edge-animated=true]) .likec4-edge__path{animation-play-state:running;animation-delay:0ms}.likec4-edge__pathBg{pointer-events:none;fill:var(--colors-none);stroke-width:calc(var(--xy-edge-stroke-width) + 2);stroke-opacity:.08}.likec4-root:not([data-likec4-reduced-graphics]) .likec4-edge__pathBg{--transition-prop: stroke-width, stroke-opacity;transition-property:stroke-width,stroke-opacity;--transition-duration: var(--durations-fast);transition-duration:var(--durations-fast);--transition-easing: var(--easings-in-out);transition-timing-function:var(--easings-in-out)}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .likec4-edge__pathBg{--transition-easing: var(--easings-out);transition-timing-function:var(--easings-out);stroke-width:calc(var(--xy-edge-stroke-width) + 4);stroke-opacity:.2}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-edge__pathBg{stroke-width:calc(var(--xy-edge-stroke-width) + 6);stroke-opacity:.25}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) :where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .likec4-edge__pathBg{stroke-opacity:.4}.likec4-edge__markersCtx{fill:var(--xy-edge-stroke);stroke:var(--xy-edge-stroke)}.likec4-edge__middlePoint{visibility:hidden;offset-distance:50%;cx:0;cy:0;r:4px;pointer-events:none}@media screen and (min-width:36rem){.likec4-navigation-panel__root{max-width:100cqw}}@container (min-width: 40rem){.likec4-navigation-panel__root{margin:var(--spacing-xs);gap:var(--spacing-xs);width:max-content;max-width:calc(100vw - 2 * var(--spacing-md))}@media screen and (min-width:36rem){.likec4-navigation-panel__root{max-width:calc(100cqw - 2 * var(--spacing-md))}}}@container (min-width: 40rem){.likec4-navigation-panel__body{border-radius:var(--radii-md);padding-inline:var(--spacing-2);box-shadow:var(--shadows-lg)}}@media print{.likec4-navigation-panel__root{display:none}}}.likec4-navlink__label--truncateLabel_true,.likec4-navlink__description--truncateLabel_true{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:var(--sizes-100\\%)}.likec4-navigation-panel__body--size_md{min-height:40px}.likec4-navigation-panel__logo--size_md{width:20px}@container (min-width: 40rem){.likec4-navigation-panel__body--size_lg{gap:var(--spacing-sm);padding-inline:var(--spacing-md);min-height:48px}.likec4-navigation-panel__body--size_lg:is(:hover,[data-hover]){box-shadow:var(--shadows-xl)}}@container (min-width: 40rem){.likec4-navigation-panel__logo--size_lg{width:74px}.likec4-navigation-panel__label--size_lg{font-size:var(--font-sizes-md)}}@container (min-width: 48rem){.likec4-navigation-panel__logo--size_md{width:64px}}}@layer utilities{@layer compositions{.layerStyle_likec4\\.panel{padding:var(--spacing-1);border:1px solid var(--colors-likec4-panel-border);border-radius:var(--radii-0);background-color:var(--colors-likec4-panel-bg)}.layerStyle_likec4\\.dropdown{padding:var(--spacing-2);border:1px solid var(--colors-likec4-dropdown-border);border-radius:var(--radii-md);background-color:var(--colors-likec4-dropdown-bg);box-shadow:var(--shadows-lg)}.layerStyle_likec4\\.tag{border:var(--borders-none);border-radius:3px;color:var(--colors-likec4-tag-text);background-color:var(--colors-likec4-tag-bg)}.layerStyle_likec4\\.tag:is(:hover,[data-hover]){background-color:var(--colors-likec4-tag-bg-hover)}.textStyle_xs{font-size:.75rem;line-height:1rem}.layerStyle_likec4\\.panel\\.action{border:var(--borders-transparent);padding-inline:var(--spacing-xxs);padding-block:var(--spacing-xxs);border-radius:var(--radii-sm);color:var(--colors-likec4-panel-action);cursor:pointer}.layerStyle_likec4\\.panel\\.action:is(:disabled,[disabled],[data-disabled],[aria-disabled=true]){color:var(--colors-likec4-panel-action-disabled);cursor:not-allowed}.layerStyle_likec4\\.panel\\.action:not(:is(:disabled,[disabled],[data-disabled])):is(:hover,[data-hover]){color:var(--colors-likec4-panel-action-hover);background-color:var(--colors-likec4-panel-action-bg-hover)}.layerStyle_likec4\\.panel\\.action\\.filled{border:var(--borders-transparent);padding-inline:var(--spacing-xxs);padding-block:var(--spacing-xxs);border-radius:var(--radii-sm);color:var(--colors-likec4-panel-action);cursor:pointer;background-color:var(--colors-likec4-panel-action-bg)}.layerStyle_likec4\\.panel\\.action\\.filled:is(:disabled,[disabled],[data-disabled],[aria-disabled=true]){color:var(--colors-likec4-panel-action-disabled);cursor:not-allowed;background-color:var(--colors-likec4-panel-action-bg)}.layerStyle_likec4\\.panel\\.action\\.filled:not(:is(:disabled,[disabled],[data-disabled])):is(:hover,[data-hover]){color:var(--colors-likec4-panel-action-hover);background-color:var(--colors-likec4-panel-action-bg-hover)}@container (min-width: 40rem){.layerStyle_likec4\\.panel{border-radius:var(--radii-md);padding-inline:var(--spacing-2);box-shadow:var(--shadows-lg)}}}.--mantine-cursor-pointer_pointer{--mantine-cursor-pointer: pointer}.--thickness_1px{--thickness: 1px}.--bleed-x_token\\(spacing\\.2\\,_2\\){--bleed-x: var(--spacing-2, 2)}.--bleed-y_token\\(spacing\\.2\\,_2\\){--bleed-y: var(--spacing-2, 2)}.--text-fz_\\{fontSizes\\.sm\\}{--text-fz: var(--font-sizes-sm)}.--view-title-color_\\{colors\\.mantine\\.colors\\.dark\\[1\\]\\}{--view-title-color: var(--colors-mantine-colors-dark\\[1\\])}.--likec4-icon-size_24px{--likec4-icon-size: 24px}.--ti-size_var\\(--likec4-icon-size\\,_24px\\){--ti-size: var(--likec4-icon-size, 24px)}.--_color_var\\(--likec4-palette-stroke\\){--_color: var(--likec4-palette-stroke)}.--ai-radius_0px{--ai-radius: 0px}.--badge-radius_2px{--badge-radius: 2px}.--badge-fz_9\\.5px{--badge-fz: 9.5px}.--badge-padding-x_3px{--badge-padding-x: 3px}.--badge-height_13\\.5px{--badge-height: 13.5px}.--badge-lh_1{--badge-lh: 1}.--badge-bg_var\\(--likec4-palette-fill\\){--badge-bg: var(--likec4-palette-fill)}.--badge-color_var\\(--likec4-palette-hiContrast\\){--badge-color: var(--likec4-palette-hiContrast)}.bg_dots{background:dots}.bg_transparent{background:var(--colors-transparent)}.m_0{margin:var(--spacing-0)}.p_0{padding:var(--spacing-0)}.bg_likec4\\.overlay\\.body{background:var(--colors-likec4-overlay-body)}.p_xl{padding:var(--spacing-xl)}.bd_1px_solid{border:1px solid}.bg_mantine\\.colors\\.default{background:var(--colors-mantine-colors-default)}.p_\\[4px_7px\\]{padding:4px 7px}.bg_\\[transparent\\]{background:var(--colors-transparent)}.p_1{padding:var(--spacing-1)}.p_4{padding:var(--spacing-4)}.bg_white{background:#fff}.bd_default{border:var(--borders-default)}.m_xs{margin:var(--spacing-xs)}.p_md{padding:var(--spacing-md)}.p_1\\.5{padding:var(--spacing-1\\.5)}.p_0\\.5{padding:var(--spacing-0\\.5)}.p_8{padding:var(--spacing-8)}.p_xxs{padding:var(--spacing-xxs)}.p_\\[4px_6px\\]{padding:4px 6px}.bg_mantine\\.colors\\.gray\\[2\\]{background:var(--colors-mantine-colors-gray\\[2\\])}.bg_mantine\\.colors\\.gray\\[3\\]{background:var(--colors-mantine-colors-gray\\[3\\])}.bd_2px_solid{border:2px solid}.inset_0{inset:var(--spacing-0)}.bd_transparent{border:var(--borders-transparent)}.bd_none{border:var(--borders-none)}.bg_\\[_linear-gradient\\(180deg\\,_color-mix\\(in_oklab\\,_var\\(--likec4-palette-fill\\)_60\\%\\,_transparent\\)\\,_color-mix\\(in_oklab\\,_var\\(--likec4-palette-fill\\)_20\\%\\,_transparent\\)_8px\\,_color-mix\\(in_oklab\\,_var\\(--likec4-palette-fill\\)_14\\%\\,_transparent\\)_20px\\,_transparent_80px_\\)\\,_linear-gradient\\(180deg\\,_var\\(--likec4-palette-fill\\)\\,_var\\(--likec4-palette-fill\\)_4px\\,_transparent_4px\\)\\,_\\{colors\\.likec4\\.overlay\\.body\\}_\\]{background:linear-gradient(180deg,color-mix(in oklab,var(--likec4-palette-fill) 60%,transparent),color-mix(in oklab,var(--likec4-palette-fill) 20%,transparent) 8px,color-mix(in oklab,var(--likec4-palette-fill) 14%,transparent) 20px,transparent 80px),linear-gradient(180deg,var(--likec4-palette-fill),var(--likec4-palette-fill) 4px,transparent 4px),var(--colors-likec4-overlay-body)}.bg_mantine\\.colors\\.body{background:var(--colors-mantine-colors-body)}.p_\\[10px_8px\\]{padding:10px 8px}.bd_1px_dashed{border:1px dashed}.bg_mantine\\.colors\\.gray\\[1\\]{background:var(--colors-mantine-colors-gray\\[1\\])}.p_\\[6px_8px\\]{padding:6px 8px}.bd_3\\.5px_solid{border:3.5px solid}.p_xs{padding:var(--spacing-xs)}.p_\\[4px_8px\\]{padding:4px 8px}.p_\\[1px_4px\\]{padding:1px 4px}.p_\\[3px_6px\\]{padding:3px 6px}.bg_var\\(--likec4-palette-fill\\)\\/75{--mix-background: color-mix(in srgb, var(--likec4-palette-fill) 75%, transparent);background:var(--mix-background, var(--likec4-palette-fill))}.bd_1px_solid_\\{colors\\.mantine\\.colors\\.defaultBorder\\}{border:1px solid var(--colors-mantine-colors-default-border)}.p_\\[1px_5px\\]{padding:1px 5px}.bg_mantine\\.colors\\.dark\\[7\\]{background:var(--colors-mantine-colors-dark\\[7\\])}.p_\\[6px_2px_0_2px\\]{padding:6px 2px 0}.p_\\[0_4px_5px_4px\\]{padding:0 4px 5px}.bd_3px_dashed{border:3px dashed}.bg_mantine\\.colors\\.dark\\[9\\]\\/30{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-dark\\[9\\]) 30%, transparent);background:var(--mix-background, var(--colors-mantine-colors-dark\\[9\\]))}.bg_mantine\\.colors\\.primary\\[8\\]{background:var(--colors-mantine-colors-primary\\[8\\])}.p_\\[12px_8px_12px_14px\\]{padding:12px 8px 12px 14px}.bd_2px_dashed{border:2px dashed}.p_2{padding:var(--spacing-2)}.gap_20{gap:20px}.bdr_sm{border-radius:var(--radii-sm)}.bd-w_3{border-width:3px}.bd-c_likec4\\.overlay\\.border{border-color:var(--colors-likec4-overlay-border)}.ring_none{outline:var(--borders-none)}.gap_lg{gap:var(--spacing-lg)}.gap_md{gap:var(--spacing-md)}.gap_sm{gap:var(--spacing-sm)}.flex_1{flex:1 1 0%}.transition_fast{transition:all var(--durations-fast) var(--easings-in-out)}.td_none{text-decoration:none}.bd-c_mantine\\.colors\\.defaultBorder{border-color:var(--colors-mantine-colors-default-border)}.gap_xs{gap:var(--spacing-xs)}.gap_xxs{gap:var(--spacing-xxs)}.gap_1{gap:var(--spacing-1)}.ov_hidden{overflow:hidden}.gap_0\\.5{gap:var(--spacing-0\\.5)}.gap_\\[4px\\]{gap:4px}.px_xs{padding-inline:var(--spacing-xs)}.py_xxs{padding-block:var(--spacing-xxs)}.px_sm{padding-inline:var(--spacing-sm)}.gap_8px{gap:8px}.gap_1\\.5{gap:var(--spacing-1\\.5)}.bdr_\\[4px\\]{border-radius:4px}.px_1\\.5{padding-inline:var(--spacing-1\\.5)}.gap_3{gap:var(--spacing-3)}.mx_calc\\(var\\(--bleed-x\\,_0\\)_\\*_-1\\){margin-inline:calc(var(--bleed-x, 0) * -1)}.my_calc\\(var\\(--bleed-y\\,_0\\)_\\*_-1\\){margin-block:calc(var(--bleed-y, 0) * -1)}.py_2\\.5{padding-block:var(--spacing-2\\.5)}.px_2{padding-inline:var(--spacing-2)}.gap_2{gap:var(--spacing-2)}.offset_2{offset:2px}.offset_10{offset:10px}.py_1\\.5{padding-block:var(--spacing-1\\.5)}.bd-l_2px_dotted{border-left:2px dotted}.px_1{padding-inline:var(--spacing-1)}.py_0\\.5{padding-block:var(--spacing-0\\.5)}.bdr_\\[2px\\]{border-radius:2px}.bd-w_4{border-width:4px}.px_4{padding-inline:var(--spacing-4)}.py_1{padding-block:var(--spacing-1)}.gap_\\[1px\\]{gap:1px}.ov_auto{overflow:auto}.ovs-b_contain{overscroll-behavior:contain}.ov_visible{overflow:visible}.px_xxs{padding-inline:var(--spacing-xxs)}.my_10{margin-block:var(--spacing-10)}.flex_1_1_40\\%{flex:1 1 40%}.bd-c_mantine\\.colors\\.gray\\[4\\]{border-color:var(--colors-mantine-colors-gray\\[4\\])}.bd-c_mantine\\.colors\\.gray\\[5\\]{border-color:var(--colors-mantine-colors-gray\\[5\\])}.bdr_3{border-radius:3px}.bd-c_mantine\\.colors\\.orange\\[6\\]{border-color:var(--colors-mantine-colors-orange\\[6\\])}.tw_pretty{text-wrap:pretty}.flex_0{flex:0}.flex_0_0_40px{flex:0 0 40px}.gap_\\[24px_20px\\]{gap:24px 20px}.bd-c_mantine\\.colors\\.dark\\[3\\]{border-color:var(--colors-mantine-colors-dark\\[3\\])}.bd-t_none{border-top:var(--borders-none)}.bd-l_none{border-left:var(--borders-none)}.bdr_2px{border-radius:2px}.gap_4{gap:var(--spacing-4)}.gap_6{gap:var(--spacing-6)}.gap_\\[12px_16px\\]{gap:12px 16px}.bd-c_mantine\\.colors\\.gray\\[3\\]{border-color:var(--colors-mantine-colors-gray\\[3\\])}.flex_0_1_auto{flex:0 1 auto}.transition_all_150ms_ease{transition:all .15s ease}.bdr_xs{border-radius:var(--radii-xs)}.flex_1_1_100\\%{flex:1 1 100%}.offset_0{offset:0}.py_4{padding-block:var(--spacing-4)}.gap_8{gap:var(--spacing-8)}.px_md{padding-inline:var(--spacing-md)}.py_xs{padding-block:var(--spacing-xs)}.grid-c_1{grid-column:1}.grid-c_2{grid-column:2}.grid-c_3{grid-column:3}.bd-b_1px_solid{border-bottom:1px solid}.gap_0{gap:var(--spacing-0)}.gap_\\[10px_12px\\]{gap:10px 12px}.py_3{padding-block:var(--spacing-3)}.offset_4{offset:4px}.flex_1_0_auto{flex:1 0 auto}.bdr_md{border-radius:var(--radii-md)}.ring_none\\!{outline:var(--borders-none)!important}.bdr_4px{border-radius:4px}.mx_auto{margin-inline:auto}.py_md{padding-block:var(--spacing-md)}.bd-c_mantine\\.colors\\.primary\\[9\\]{border-color:var(--colors-mantine-colors-primary\\[9\\])}.flex_0_0_var\\(--likec4-icon-size\\,_24px\\){flex:0 0 var(--likec4-icon-size, 24px)}.py_xl{padding-block:var(--spacing-xl)}.bd-w_1{border-width:1px}.bd-c_\\[var\\(--_color\\)\\/30\\]{--mix-borderColor: color-mix(in srgb, var(--_color) 30%, transparent);border-color:var(--mix-borderColor, var(--_color))}.transition_all_100ms_ease-in{transition:all .1s ease-in}.transition_all_150ms_ease-in-out{transition:all .15s ease-in-out}.py_sm{padding-block:var(--spacing-sm)}.flex_0_0_auto{flex:0 0 auto}.flex_0_0_70px{flex:0 0 70px}.bd-w_3px{border-width:3px}.border-style_dashed{border-style:dashed}.px_6{padding-inline:var(--spacing-6)}.px_8{padding-inline:var(--spacing-8)}.px_5{padding-inline:var(--spacing-5)}.cursor_pointer{cursor:pointer}.pos_absolute{position:absolute}.z_999{z-index:999}.c_gray{color:gray}.pos_fixed{position:fixed}.bx-sh_xl{box-shadow:var(--shadows-xl)}.d_flex{display:flex}.ai_flex-start{align-items:flex-start}.flex-d_row{flex-direction:row}.flex-wrap_nowrap{flex-wrap:nowrap}.ai_center{align-items:center}.c_red{color:red}.ai_stretch{align-items:stretch}.flex-d_column{flex-direction:column}.c_teal{color:teal}.op_1{opacity:1}.op_0\\.45{opacity:.45}.us_all{-webkit-user-select:all;user-select:all}.bg-c_transparent{background-color:var(--colors-transparent)}.stk_2\\.5{stroke:2.5px}.op_0\\.7{opacity:.7}.fill_\\[\\#FCFBF7\\]{fill:#fcfbf7}.d_none{display:none}.d_block{display:block}.bx-sh_xs{box-shadow:var(--shadows-xs)}.fs_sm{font-size:var(--font-sizes-sm)}.fw_500{font-weight:500}.c_mantine\\.colors\\.placeholder{color:var(--colors-mantine-colors-placeholder)}.fs_11px{font-size:11px}.fw_600{font-weight:600}.lh_1{line-height:var(--line-heights-1)}.stk_2{stroke:2px}.pointer-events_none{pointer-events:none}.main-axis_4{main-axis:4px}.pos_bottom-start{position:bottom-start}.pos_relative{position:relative}.pointer-events_all{pointer-events:all}.us_none{-webkit-user-select:none;user-select:none}.flex-sh_1{flex-shrink:1}.flex-g_1{flex-grow:1}.flex-g_0{flex-grow:0}.op_0\\.3{opacity:.3}.bg-c_mantine\\.colors\\.gray\\[1\\]{background-color:var(--colors-mantine-colors-gray\\[1\\])}.stk_1\\.5{stroke:1.5px}.bd-e-w_var\\(--thickness\\){border-inline-end-width:var(--thickness)}.c_mantine\\.colors\\.gray\\[5\\]{color:var(--colors-mantine-colors-gray\\[5\\])}.bg-c_likec4\\.panel\\.action\\.warning\\.bg{background-color:var(--colors-likec4-panel-action-warning-bg)}.c_likec4\\.panel\\.action{color:var(--colors-likec4-panel-action)}.trunc_true{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.c_likec4\\.panel\\.text\\.dimmed{color:var(--colors-likec4-panel-text-dimmed)}.bg-c_\\[rgb\\(34_34_34_\\/_var\\(--_opacity\\,_95\\%\\)\\)\\]{background-color:rgb(34 34 34 / var(--_opacity, 95%))}.bkdp_auto{backdrop-filter:var(--backdrop-blur, ) var(--backdrop-brightness, ) var(--backdrop-contrast, ) var(--backdrop-grayscale, ) var(--backdrop-hue-rotate, ) var(--backdrop-invert, ) var(--backdrop-opacity, ) var(--backdrop-saturate, ) var(--backdrop-sepia, );-webkit-backdrop-filter:var(--backdrop-blur, ) var(--backdrop-brightness, ) var(--backdrop-contrast, ) var(--backdrop-grayscale, ) var(--backdrop-hue-rotate, ) var(--backdrop-invert, ) var(--backdrop-opacity, ) var(--backdrop-saturate, ) var(--backdrop-sepia, )}.bkdp-blur_var\\(--_blur\\,_10px\\){--backdrop-blur: blur(var(--_blur, 10px))}.jc_stretch{justify-content:stretch}.cq-n_likec4-search-elements{container-name:likec4-search-elements}.cq-t_size{container-type:size}.d_contents{display:contents}.d_grid{display:grid}.order_6{order:6}.stk_1\\.8{stroke:1.8px}.trunc_end{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.trs-dur_normal{--transition-duration: var(--durations-normal);transition-duration:var(--durations-normal)}.trs-dly_0\\.2s{transition-delay:.2s}.fill_none{fill:var(--colors-none)}.jc_center{justify-content:center}.z_1{z-index:var(--z-index-1)}.ai_flex-end{align-items:flex-end}.justify-items_stretch{justify-items:stretch}.fs_lg{font-size:var(--font-sizes-lg)}.ai_baseline{align-items:baseline}.flex-wrap_wrap{flex-wrap:wrap}.translate_auto{translate:var(--translate-x) var(--translate-y)}.translate-x_\\[-8px\\]{--translate-x: -8px}.bd-be-w_var\\(--thickness\\){border-block-end-width:var(--thickness)}.cursor_default{cursor:default}.c_orange{color:orange}.pos_top-start{position:top-start}.pos_right{position:right}.op_0\\.65{opacity:.65}.d_inline-flex{display:inline-flex}.op_0\\.5{opacity:.5}.fs_xxs{font-size:var(--font-sizes-xxs)}.lh_sm{line-height:var(--line-heights-sm)}.c_mantine\\.colors\\.dimmed{color:var(--colors-mantine-colors-dimmed)}.white-space_nowrap{white-space:nowrap}.white-space-collapse_preserve-breaks{white-space-collapse:preserve-breaks}.fs_xs{font-size:var(--font-sizes-xs)}.fw_medium{font-weight:var(--font-weights-medium)}.trf_translateY\\(-4px\\){transform:translateY(-4px)}.c_mantine\\.colors\\.gray\\[9\\]{color:var(--colors-mantine-colors-gray\\[9\\])}.bx-sh_lg{box-shadow:var(--shadows-lg)}.pos_right-start{position:right-start}.stk_1\\.7{stroke:1.7px}.c_likec4\\.panel\\.text{color:var(--colors-likec4-panel-text)}.c_green{color:green}.pos_bottom-end{position:bottom-end}.op_0\\.8{opacity:.8}.me_0\\.5{margin-inline-end:var(--spacing-0\\.5)}.cross-axis_-22{cross-axis:-22px}.bg-c_none{background-color:var(--colors-none)}.fw_400{font-weight:400}.bx-sh_md{box-shadow:var(--shadows-md)}.main-axis_2{main-axis:2px}.lh_1\\.1{line-height:1.1}.main-axis_10{main-axis:10px}.op_0\\.6{opacity:.6}.pos_top{position:top}.main-axis_12{main-axis:12px}.ta_center{text-align:center}.bx-sh_inset_1px_1px_3px_0px_\\#00000024{box-shadow:inset 1px 1px 3px #00000024}.trf_translate\\(-50\\%\\,_-50\\%\\){transform:translate(-50%,-50%)}.flex-sh_0{flex-shrink:0}.ms_0{margin-inline-start:var(--spacing-0)}.z_9{z-index:9}.ta_left{text-align:left}.lh_1\\.25{line-height:1.25}.bx-s_border-box{box-sizing:border-box}.c_mantine\\.colors\\.text{color:var(--colors-mantine-colors-text)}.cursor_move{cursor:move}.ff_likec4\\.element{font-family:var(--fonts-likec4-element)}.font-optical-sizing_auto{font-optical-sizing:auto}.font-style_normal{font-style:normal}.fs_24px{font-size:24px}.lh_xs{line-height:var(--line-heights-xs)}.as_flex-start{align-self:flex-start}.c_\\[var\\(--view-title-color\\,_\\{colors\\.mantine\\.colors\\.gray\\[7\\]\\}\\)\\]{color:var(--view-title-color, var(--colors-mantine-colors-gray\\[7\\]))}.fs_15px{font-size:15px}.lh_1\\.4{line-height:1.4}.c_mantine\\.colors\\.gray\\[7\\]{color:var(--colors-mantine-colors-gray\\[7\\])}.grid-tc_min-content_1fr{grid-template-columns:min-content 1fr}.grid-ar_min-content_max-content{grid-auto-rows:min-content max-content}.justify-self_end{justify-self:end}.ta_right{text-align:right}.cursor_se-resize{cursor:se-resize}.ai_start{align-items:start}.jc_space-between{justify-content:space-between}.stk_1\\.6{stroke:1.6px}.grid-ar_min-content{grid-auto-rows:min-content}.white-space_pre-wrap{white-space:pre-wrap}.tov_unset{text-overflow:unset}.tov_ellipsis{text-overflow:ellipsis}.wb_break-word{word-break:break-word}.wb_normal{word-break:normal}.bg-c_mantine\\.colors\\.white{background-color:var(--colors-mantine-colors-white)}.jc_flex-end{justify-content:flex-end}.c_mantine\\.colors\\.gray\\[6\\]{color:var(--colors-mantine-colors-gray\\[6\\])}.fw_700{font-weight:700}.justify-self_stretch{justify-self:stretch}.as_start{align-self:start}.ps_\\[16px\\]{padding-inline-start:16px}.pe_2\\.5{padding-inline-end:var(--spacing-2\\.5)}.stk_1\\.2{stroke:1.2px}.d_inline-block{display:inline-block}.lh_1\\.2{line-height:1.2}.c_var\\(--likec4-palette-hiContrast\\){color:var(--likec4-palette-hiContrast)}.fs_xl{font-size:var(--font-sizes-xl)}.c_mantine\\.colors\\.defaultColor{color:var(--colors-mantine-colors-default-color)}.bx-sh_none{box-shadow:var(--shadows-none)}.pos_top-right{position:top-right}.pos_top-left{position:top-left}.grid-cs_1{grid-column-start:1}.grid-ce_4{grid-column-end:4}.grid-tc_1fr_30px_1fr{grid-template-columns:1fr 30px 1fr}.justify-items_start{justify-items:start}.c_dark{color:dark}.stk_3\\.5{stroke:3.5px}.cq-n_likec4-tree{container-name:likec4-tree}.cq-t_inline-size{container-type:inline-size}.fs_10px{font-size:10px}.lh_1\\.3{line-height:1.3}.order_2{order:2}.grayscale_0\\.9{--grayscale: grayscale(.9)}.filter_auto{filter:var(--blur, ) var(--brightness, ) var(--contrast, ) var(--grayscale, ) var(--hue-rotate, ) var(--invert, ) var(--saturate, ) var(--sepia, ) var(--drop-shadow, )}.cross-axis_50{cross-axis:50px}.sr_true{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.fs_13px{font-size:13px}.fs_16px{font-size:16px}.c_mantine\\.colors\\.dark\\[1\\]{color:var(--colors-mantine-colors-dark\\[1\\])}.fs_12px{font-size:12px}.fs_md{font-size:var(--font-sizes-md)}.bg-c_\\[rgb\\(34_34_34_\\/_0\\.7\\)\\]{background-color:#222222b3}.z_902{z-index:902}.bkdp-blur_10px{--backdrop-blur: blur(10px)}.trf_translateX\\(-50\\%\\){transform:translate(-50%)}.z_903{z-index:903}.stk_likec4\\.compare\\.manual\\.outline{stroke:var(--colors-likec4-compare-manual-outline)}.stk-w_8px{stroke-width:8px}.stk-op_0\\.5{stroke-opacity:.5}.z_9999{z-index:9999}.fill_\\[var\\(--xy-edge-stroke\\)\\]{fill:var(--xy-edge-stroke)}.stk_transparent{stroke:var(--colors-transparent)}.fill-opacity_0\\.5{fill-opacity:.5}.stk-w_10{stroke-width:10}.r_4{r:4px}.cursor_grab{cursor:grab}.vis_hidden{visibility:hidden}.trs-dur_120ms{--transition-duration: .12s;transition-duration:.12s}.trs-prop_visibility\\,_fill\\,_fill-opacity\\,_r{--transition-prop: visibility, fill, fill-opacity, r;transition-property:visibility,fill,fill-opacity,r}.trs-tmf_inOut{--transition-easing: var(--easings-in-out);transition-timing-function:var(--easings-in-out)}.trs-dly_20ms{transition-delay:20ms}.bg-c_var\\(--likec4-palette-fill\\)\\/15{--mix-backgroundColor: color-mix(in srgb, var(--likec4-palette-fill) 15%, transparent);background-color:var(--mix-backgroundColor, var(--likec4-palette-fill))}.fw_bold{font-weight:700}.ls_\\.75px{letter-spacing:.75px}.c_\\[var\\(--_color\\)\\/75\\]{--mix-color: color-mix(in srgb, var(--_color) 75%, transparent);color:var(--mix-color, var(--_color))}.bg-c_var\\(--likec4-palette-fill\\){background-color:var(--likec4-palette-fill)}.translate-x_-1\\/2{--translate-x: -50%}.translate-y_-1\\/2{--translate-y: -50%}.ring-c_likec4\\.compare\\.manual\\.outline{outline-color:var(--colors-likec4-compare-manual-outline)}.ring-w_4px{outline-width:4px}.outline-style_dashed{outline-style:dashed}.ring-o_1\\.5{outline-offset:var(--spacing-1\\.5)}.bg-c_mantine\\.colors\\.body\\/80{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-body) 80%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-body))}.fill_var\\(--likec4-palette-fill\\){fill:var(--likec4-palette-fill)}.stk_var\\(--likec4-palette-stroke\\){stroke:var(--likec4-palette-stroke)}.stk-w_1{stroke-width:1}.filter_drop-shadow\\(0_2px_3px_rgb\\(0_0_0_\\/_22\\%\\)\\)_drop-shadow\\(0_1px_8px_rgb\\(0_0_0_\\/_10\\%\\)\\){filter:drop-shadow(0 2px 3px rgb(0 0 0 / 22%)) drop-shadow(0 1px 8px rgb(0 0 0 / 10%))}.ls_0\\.2px{letter-spacing:.2px}.tt_lowercase{text-transform:lowercase}.op_0\\.25{opacity:.25}.stk-w_5{stroke-width:5}.jc_flex-start{justify-content:flex-start}.pos_left-start{position:left-start}.top_4{top:var(--spacing-4)}.right_4{right:var(--spacing-4)}.top_10{top:var(--spacing-10)}.left_10{left:var(--spacing-10)}.w_\\[calc\\(100vw_-_\\(\\{spacing\\.10\\}_\\*_2\\)\\)\\]{width:calc(100vw - (var(--spacing-10) * 2))}.h_max-content{height:max-content}.max-h_\\[calc\\(100vh_-_\\(\\{spacing\\.10\\}_\\*_3\\)\\)\\]{max-height:calc(100vh - (var(--spacing-10) * 3))}.mt_md{margin-top:var(--spacing-md)}.min-h_24{min-height:24px}.max-w_500{max-width:500px}.pr_0{padding-right:var(--spacing-0)}.h_12{height:12px}.w_12{width:12px}.h_30px{height:30px}.pl_sm{padding-left:var(--spacing-sm)}.pr_1{padding-right:var(--spacing-1)}.w_100\\%{width:var(--sizes-100\\%)}.pr_2\\.5{padding-right:var(--spacing-2\\.5)}.top_0{top:var(--spacing-0)}.left_0{left:var(--spacing-0)}.max-w_calc\\(100vw\\){max-width:100vw}.max-w_200px{max-width:200px}.max-w_calc\\(100vw_-_50px\\){max-width:calc(100vw - 50px)}.max-w_calc\\(100vw_-_250px\\){max-width:calc(100vw - 250px)}.max-h_calc\\(100vh_-_200px\\){max-height:calc(100vh - 200px)}.max-h_calc\\(100vh_-_160px\\){max-height:calc(100vh - 160px)}.h_100\\%{height:var(--sizes-100\\%)}.mb_1{margin-bottom:var(--spacing-1)}.max-h_100vh{max-height:100vh}.pt_\\[20px\\]{padding-top:20px}.pl_md{padding-left:var(--spacing-md)}.pr_md{padding-right:var(--spacing-md)}.pb_sm{padding-bottom:var(--spacing-sm)}.pr_xs{padding-right:var(--spacing-xs)}.lc_5{-webkit-line-clamp:5}.lc_5,.lc_2{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical}.lc_2{-webkit-line-clamp:2}.lc_3{overflow:hidden;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical}.top_0\\.5{top:var(--spacing-0\\.5)}.right_0\\.5{right:var(--spacing-0\\.5)}.bottom_0{bottom:var(--spacing-0)}.max-w_50{max-width:50px}.h_5{height:5px}.w_max-content{width:max-content}.pt_2{padding-top:var(--spacing-2)}.mt_2{margin-top:var(--spacing-2)}.mt_0{margin-top:var(--spacing-0)}.w_350{width:350px}.pl_2\\.5{padding-left:var(--spacing-2\\.5)}.bd-l-c_mantine\\.colors\\.gray\\[3\\]{border-left-color:var(--colors-mantine-colors-gray\\[3\\])}.w_full{width:var(--sizes-full)}.h_full{height:var(--sizes-full)}.bdr-bl_sm{border-bottom-left-radius:var(--radii-sm)}.bdr-br_sm{border-bottom-right-radius:var(--radii-sm)}.pl_3{padding-left:var(--spacing-3)}.mt_1{margin-top:var(--spacing-1)}.mb_xxs{margin-bottom:var(--spacing-xxs)}.pb_lg{padding-bottom:var(--spacing-lg)}.max-w_calc\\(100cqw_-_52px\\){max-width:calc(100cqw - 52px)}.min-w_200px{min-width:200px}.max-h_calc\\(100cqh_-_100px\\){max-height:calc(100cqh - 100px)}.mt_4{margin-top:var(--spacing-4)}.mt_xs{margin-top:var(--spacing-xs)}.w_\\[20px\\]{width:20px}.h_auto{height:auto}.pt_6{padding-top:var(--spacing-6)}.mb_10{margin-bottom:var(--spacing-10)}.pt_100\\%{padding-top:100%}.left_2{left:var(--spacing-2)}.bottom_2{bottom:var(--spacing-2)}.top_md{top:var(--spacing-md)}.left_md{left:var(--spacing-md)}.w_8{width:8px}.h_8{height:8px}.mr_sm{margin-right:var(--spacing-sm)}.h_26{height:26px}.top_\\[1px\\]{top:1px}.right_\\[1px\\]{right:1px}.pt_xxs{padding-top:var(--spacing-xxs)}.max-w_calc\\(100cqw_-_32px\\){max-width:calc(100cqw - 32px)}.min-w_calc\\(100cqw_-_50px\\){min-width:calc(100cqw - 50px)}.w_100vw{width:100vw}.h_100vh{height:100vh}.max-w_100vw{max-width:100vw}.h_40px{height:40px}.w_40px{width:40px}.w_14px{width:14px}.h_14px{height:14px}.bottom_0\\.5{bottom:var(--spacing-0\\.5)}.mb_sm{margin-bottom:var(--spacing-sm)}.lc_1{overflow:hidden;display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical}.mt_6{margin-top:var(--spacing-6)}.pt_xs{padding-top:var(--spacing-xs)}.w_300{width:300px}.min-w_0{min-width:0}.min-h_32px{min-height:32px}.max-w_min\\(200px\\,_100\\%\\){max-width:min(200px,100%)}.min-w_60px{min-width:60px}.mb_0{margin-bottom:var(--spacing-0)}.h_36px{height:36px}.min-w_24{min-width:24px}.mb_4{margin-bottom:var(--spacing-4)}.top_12{top:12px}.right_12{right:12px}.mt_sm{margin-top:var(--spacing-sm)}.ml_sm{margin-left:var(--spacing-sm)}.pl_1{padding-left:var(--spacing-1)}.bd-b-c_mantine\\.colors\\.defaultBorder{border-bottom-color:var(--colors-mantine-colors-default-border)}.max-h_70vh{max-height:70vh}.mb_2{margin-bottom:var(--spacing-2)}.max-w_8xl{max-width:8xl}.pl_\\[48px\\]{padding-left:48px}.mr_1{margin-right:var(--spacing-1)}.min-h_60px{min-height:60px}.h_var\\(--likec4-icon-size\\,_24px\\){height:var(--likec4-icon-size, 24px)}.w_var\\(--likec4-icon-size\\,_24px\\){width:var(--likec4-icon-size, 24px)}.top_\\[2rem\\]{top:2rem}.left_\\[50\\%\\]{left:50%}.max-w_600px{max-width:600px}.pl_2{padding-left:var(--spacing-2)}.pt_0\\.5{padding-top:var(--spacing-0\\.5)}.w_5px{width:5px}.top_1{top:var(--spacing-1)}.right_0{right:var(--spacing-0)}.w_min-content{width:min-content}.h_min-content{height:min-content}.min-w_200{min-width:200px}.max-w_calc\\(100vw_-_20px\\){max-width:calc(100vw - 20px)}.pt_0{padding-top:var(--spacing-0)}.pb_0{padding-bottom:var(--spacing-0)}.ml_2{margin-left:var(--spacing-2)}.h_xs{height:xs}.pb_8{padding-bottom:var(--spacing-8)}.pt_4{padding-top:var(--spacing-4)}.max-w_220px{max-width:220px}.\\[\\&\\]\\:--likec4-outline-size_6px{--likec4-outline-size: 6px}.\\[\\&_\\.action-icon\\]\\:--ai-size_2rem .action-icon{--ai-size: 2rem}[data-mantine-color-scheme=light] .light\\:--icon-color_\\{colors\\.mantine\\.colors\\.gray\\[6\\]\\}{--icon-color: var(--colors-mantine-colors-gray\\[6\\])}[data-mantine-color-scheme=light] .light\\:--view-title-color_\\{colors\\.mantine\\.colors\\.gray\\[7\\]\\}{--view-title-color: var(--colors-mantine-colors-gray\\[7\\])}.\\[\\&_\\.mantine-ThemeIcon-root\\]\\:--ti-size_22px .mantine-ThemeIcon-root{--ti-size: 22px}[data-mantine-color-scheme=dark] .dark\\:--_color_\\[color-mix\\(in_oklab\\,_var\\(--likec4-palette-hiContrast\\)_40\\%\\,_var\\(--likec4-palette-fill\\)\\)\\]{--_color: color-mix(in oklab, var(--likec4-palette-hiContrast) 40%, var(--likec4-palette-fill))}.likec4-root:not([data-likec4-reduced-graphics]) .noReduceGraphics\\:--ai-radius_\\{radii\\.md\\}{--ai-radius: var(--radii-md)}.backdrop\\:bg_\\[color-mix\\(in_oklab\\,_\\{colors\\.likec4\\.overlay\\.backdrop\\}_60\\%\\,_transparent\\)\\]::backdrop{background:color-mix(in oklab,var(--colors-likec4-overlay-backdrop) 60%,transparent)}[data-mantine-color-scheme=light] .light\\:bg_mantine\\.colors\\.white{background:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=dark] .dark\\:bg_mantine\\.colors\\.dark\\[6\\]{background:var(--colors-mantine-colors-dark\\[6\\])}[data-mantine-color-scheme=light] .light\\:bg_var\\(--likec4-palette-fill\\)\\/90{--mix-background: color-mix(in srgb, var(--likec4-palette-fill) 90%, transparent);background:var(--mix-background, var(--likec4-palette-fill))}[data-mantine-color-scheme=dark] .dark\\:bg_var\\(--likec4-palette-fill\\)\\/60{--mix-background: color-mix(in srgb, var(--likec4-palette-fill) 60%, transparent);background:var(--mix-background, var(--likec4-palette-fill))}[data-mantine-color-scheme=dark] .dark\\:bg_mantine\\.colors\\.dark\\[5\\]{background:var(--colors-mantine-colors-dark\\[5\\])}[data-mantine-color-scheme=dark] .dark\\:bg_mantine\\.colors\\.dark\\[7\\]{background:var(--colors-mantine-colors-dark\\[7\\])}.\\[\\&\\[data-active\\]\\]\\:bg_mantine\\.colors\\.white[data-active]{background:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=light] .light\\:bg_mantine\\.colors\\.gray\\[1\\]{background:var(--colors-mantine-colors-gray\\[1\\])}.\\[\\&\\[data-missing\\]\\]\\:bg_mantine\\.colors\\.orange\\[8\\]\\/15[data-missing]{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-orange\\[8\\]) 15%, transparent);background:var(--mix-background, var(--colors-mantine-colors-orange\\[8\\]))}.\\[\\&\\[data-missing\\]\\]\\:bg_mantine\\.colors\\.orange\\[8\\]\\/20[data-missing]{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-orange\\[8\\]) 20%, transparent);background:var(--mix-background, var(--colors-mantine-colors-orange\\[8\\]))}[data-mantine-color-scheme=light] .light\\:bg_mantine\\.colors\\.gray\\[3\\]\\/20{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-gray\\[3\\]) 20%, transparent);background:var(--mix-background, var(--colors-mantine-colors-gray\\[3\\]))}[data-mantine-color-scheme=dark] .dark\\:bg_mantine\\.colors\\.dark\\[6\\]\\/80{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-dark\\[6\\]) 80%, transparent);background:var(--mix-background, var(--colors-mantine-colors-dark\\[6\\]))}[data-mantine-color-scheme=light] .light\\:bg_mantine\\.colors\\.white\\/80{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-white) 80%, transparent);background:var(--mix-background, var(--colors-mantine-colors-white))}[data-mantine-color-scheme=light] .light\\:bd-c_mantine\\.colors\\.gray\\[4\\]{border-color:var(--colors-mantine-colors-gray\\[4\\])}[data-mantine-color-scheme=dark] .dark\\:bd-c_mantine\\.colors\\.dark\\[4\\]{border-color:var(--colors-mantine-colors-dark\\[4\\])}.likec4-root:is([data-likec4-diagram-panning=true]) .whenPanning\\:transition_none\\!{transition:none!important}[data-mantine-color-scheme=light] .light\\:bd-c_mantine\\.colors\\.gray\\[2\\]{border-color:var(--colors-mantine-colors-gray\\[2\\])}[data-mantine-color-scheme=dark] .dark\\:bd-c_mantine\\.colors\\.dark\\[7\\]{border-color:var(--colors-mantine-colors-dark\\[7\\])}.\\[\\&\\]\\:border-style_solid{border-style:solid}.\\[\\&\\]\\:bd-w_3px{border-width:3px}.\\[\\&\\]\\:bd-c_var\\(--likec4-palette-stroke\\){border-color:var(--likec4-palette-stroke)}.\\[\\&_\\.likec4-shape-outline\\]\\:bdr_10px .likec4-shape-outline{border-radius:10px}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .whenHovered\\:bdr_4{border-radius:4px}.\\[\\&_\\.mantine-ThemeIcon-root\\]\\:transition_fast .mantine-ThemeIcon-root{transition:all var(--durations-fast) var(--easings-in-out)}.\\[\\&_\\>_\\*\\]\\:transition_all_130ms_\\{easings\\.inOut\\}>*{transition:all .13s var(--easings-in-out)}.\\[\\&\\[data-active\\]\\]\\:transition_none[data-active]{transition:none}.\\[\\&_\\>_\\*\\]\\:transition_fast>*,.\\[\\&_\\.tabler-icon\\]\\:transition_fast .tabler-icon{transition:all var(--durations-fast) var(--easings-in-out)}.\\[\\&\\[data-missing\\]\\]\\:bd-c_mantine\\.colors\\.orange\\[5\\]\\/20[data-missing]{--mix-borderColor: color-mix(in srgb, var(--colors-mantine-colors-orange\\[5\\]) 20%, transparent);border-color:var(--mix-borderColor, var(--colors-mantine-colors-orange\\[5\\]))}[data-mantine-color-scheme=light] .light\\:bd-c_mantine\\.colors\\.gray\\[3\\]{border-color:var(--colors-mantine-colors-gray\\[3\\])}.\\[\\&\\:last-child_\\.likec4-edge-label\\]\\:bd-b_none:last-child .likec4-edge-label{border-bottom:var(--borders-none)}.\\[\\&_\\>_\\*\\]\\:transition_all_0\\.15s_ease-in>*{transition:all .15s ease-in}[data-mantine-color-scheme=dark] .dark\\:bd-c_transparent{border-color:var(--colors-transparent)}.\\[\\&_\\:where\\(\\.likec4-diagram\\,_\\.likec4-compound-node\\,_\\.likec4-element-node\\)\\]\\:cursor_pointer :where(.likec4-diagram,.likec4-compound-node,.likec4-element-node){cursor:pointer}.backdrop\\:cursor_zoom-out::backdrop{cursor:zoom-out}.backdrop\\:bkdp_blur\\(18px\\)::backdrop{backdrop-filter:blur(18px);-webkit-backdrop-filter:blur(18px)}.\\[\\&\\:is\\(\\[data-position\\=\\"left\\"\\]\\)\\]\\:c_mantine\\.colors\\.dimmed:is([data-position=left]){color:var(--colors-mantine-colors-dimmed)}.\\[\\&\\:is\\(\\[data-position\\=\\"left\\"\\]\\)\\]\\:us_none:is([data-position=left]){-webkit-user-select:none;user-select:none}.\\[\\&\\:is\\(\\[data-position\\=\\"left\\"\\]\\)\\]\\:pointer-events_none:is([data-position=left]){pointer-events:none}[data-mantine-color-scheme=light] .light\\:fill_\\[\\#222221\\]{fill:#222221}.\\[\\&_\\.tabler-icon\\]\\:c_mantine\\.colors\\.text .tabler-icon{color:var(--colors-mantine-colors-text)}.likec4-root:is([data-likec4-diagram-panning=true]) .whenPanning\\:bx-sh_none\\!{box-shadow:var(--shadows-none)!important}[data-mantine-color-scheme=light] .light\\:c_mantine\\.colors\\.gray\\[7\\]{color:var(--colors-mantine-colors-gray\\[7\\])}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.dark\\[0\\]{color:var(--colors-mantine-colors-dark\\[0\\])}[data-mantine-color-scheme=light] .light\\:bg-c_mantine\\.colors\\.gray\\[2\\]\\/70{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-gray\\[2\\]) 70%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-gray\\[2\\]))}[data-mantine-color-scheme=dark] .dark\\:bg-c_mantine\\.colors\\.dark\\[8\\]\\/70{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-dark\\[8\\]) 70%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-dark\\[8\\]))}.empty\\:d_none:is(:empty,[data-empty]){display:none}.\\[\\&_\\>_mark\\]\\:bg-c_mantine\\.colors\\.yellow\\[2\\]\\/90>mark{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-yellow\\[2\\]) 90%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-yellow\\[2\\]))}[data-mantine-color-scheme=dark] .dark\\:op_0\\.5{opacity:.5}[data-mantine-color-scheme=dark] .dark\\:bg-c_mantine\\.colors\\.dark\\[5\\]\\/80{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-dark\\[5\\]) 80%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-dark\\[5\\]))}.placeholder\\:c_mantine\\.colors\\.dimmed::placeholder,.placeholder\\:c_mantine\\.colors\\.dimmed[data-placeholder]{color:var(--colors-mantine-colors-dimmed)}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.dark\\[3\\]{color:var(--colors-mantine-colors-dark\\[3\\])}[data-mantine-color-scheme=light] .light\\:bg-c_\\[rgb\\(250_250_250_\\/_var\\(--_opacity\\,_95\\%\\)\\)\\]{background-color:rgb(250 250 250 / var(--_opacity, 95%))}:where([data-likec4-zoom-small=true]) .smallZoom\\:d_none{display:none}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .whenHovered\\:trs-dly_\\.08s{transition-delay:.08s}.likec4-root:is([data-likec4-diagram-panning=true]) .whenPanning\\:pointer-events_none{pointer-events:none}[data-mantine-color-scheme=light] .light\\:c_var\\(--likec4-palette-hiContrast\\){color:var(--likec4-palette-hiContrast)}[data-mantine-color-scheme=dark] .dark\\:c_var\\(--likec4-palette-loContrast\\){color:var(--likec4-palette-loContrast)}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.gray\\[4\\]{color:var(--colors-mantine-colors-gray\\[4\\])}[data-mantine-color-scheme=light] .light\\:c_mantine\\.colors\\.gray\\[8\\]{color:var(--colors-mantine-colors-gray\\[8\\])}[data-mantine-color-scheme=light] .light\\:c_mantine\\.colors\\.gray\\[9\\]{color:var(--colors-mantine-colors-gray\\[9\\])}.\\[\\&\\:is\\(\\[data-position\\=\\"right\\"\\]\\)\\]\\:ms_1:is([data-position=right]){margin-inline-start:var(--spacing-1)}.\\[\\&_\\:where\\(button\\,_\\.action-icon\\,_\\[role\\=\\'dialog\\'\\]\\)\\]\\:pointer-events_all :where(button,.action-icon,[role=dialog]){pointer-events:all}.likec4-root:is([data-likec4-diagram-panning=true]) .whenPanning\\:bx-sh_none{box-shadow:var(--shadows-none)}.backdrop\\:bkdp_auto::backdrop{backdrop-filter:var(--backdrop-blur, ) var(--backdrop-brightness, ) var(--backdrop-contrast, ) var(--backdrop-grayscale, ) var(--backdrop-hue-rotate, ) var(--backdrop-invert, ) var(--backdrop-opacity, ) var(--backdrop-saturate, ) var(--backdrop-sepia, );-webkit-backdrop-filter:var(--backdrop-blur, ) var(--backdrop-brightness, ) var(--backdrop-contrast, ) var(--backdrop-grayscale, ) var(--backdrop-hue-rotate, ) var(--backdrop-invert, ) var(--backdrop-opacity, ) var(--backdrop-saturate, ) var(--backdrop-sepia, )}.backdrop\\:bkdp-blur_var\\(--_blur\\)::backdrop{--backdrop-blur: blur(var(--_blur))}.backdrop\\:bg-c_\\[rgb\\(36_36_36_\\/_var\\(--_opacity\\,_5\\%\\)\\)\\]::backdrop{background-color:rgb(36 36 36 / var(--_opacity, 5%))}.\\[\\&_\\.react-flow__attribution\\]\\:d_none .react-flow__attribution{display:none}[data-mantine-color-scheme=dark] .dark\\:mix-bm_hard-light{mix-blend-mode:hard-light}.\\[\\&_\\:where\\(svg\\,_img\\)\\]\\:pointer-events_none :where(svg,img){pointer-events:none}.\\[\\&_\\:where\\(svg\\,_img\\)\\]\\:filter_drop-shadow\\(0_0_3px_rgb\\(0_0_0_\\/_10\\%\\)\\)_drop-shadow\\(0_1px_8px_rgb\\(0_0_0_\\/_5\\%\\)\\)_drop-shadow\\(1px_1px_16px_rgb\\(0_0_0_\\/_2\\%\\)\\) :where(svg,img){filter:drop-shadow(0 0 3px rgb(0 0 0 / 10%)) drop-shadow(0 1px 8px rgb(0 0 0 / 5%)) drop-shadow(1px 1px 16px rgb(0 0 0 / 2%))}.\\[\\&_img\\]\\:obj-f_contain img{object-fit:contain}.\\[\\&_\\.mantine-ThemeIcon-root\\]\\:c_\\[var\\(--icon-color\\,_\\{colors\\.mantine\\.colors\\.dark\\[2\\]\\}\\)\\] .mantine-ThemeIcon-root{color:var(--icon-color, var(--colors-mantine-colors-dark\\[2\\]))}.\\[\\&\\[data-active\\]\\]\\:bx-sh_xs[data-active]{box-shadow:var(--shadows-xs)}.\\[\\&\\[data-active\\]\\]\\:c_mantine\\.colors\\.defaultColor[data-active]{color:var(--colors-mantine-colors-default-color)}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.dark\\[1\\]{color:var(--colors-mantine-colors-dark\\[1\\])}[data-mantine-color-scheme=dark] .dark\\:bg-c_mantine\\.colors\\.dark\\[9\\]{background-color:var(--colors-mantine-colors-dark\\[9\\])}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.text{color:var(--colors-mantine-colors-text)}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.dark\\[2\\]{color:var(--colors-mantine-colors-dark\\[2\\])}[data-mantine-color-scheme=dark] .dark\\:bg-c_mantine\\.colors\\.dark\\[6\\]{background-color:var(--colors-mantine-colors-dark\\[6\\])}[data-mantine-color-scheme=dark] .dark\\:c_mantine\\.colors\\.gray\\.lightColor{color:var(--colors-mantine-colors-gray-light-color)}.\\[\\&_\\.tabler-icon\\]\\:op_0\\.65 .tabler-icon{opacity:.65}.\\[\\&\\[data-missing\\]\\]\\:c_mantine\\.colors\\.orange\\[4\\][data-missing]{color:var(--colors-mantine-colors-orange\\[4\\])}.before\\:content_\\"scope\\:\\":before{content:"scope:"}.before\\:pos_absolute:before{position:absolute}.before\\:fs_xxs:before{font-size:var(--font-sizes-xxs)}.before\\:fw_500:before{font-weight:500}.before\\:lh_1:before{line-height:var(--line-heights-1)}.before\\:c_mantine\\.colors\\.dimmed:before{color:var(--colors-mantine-colors-dimmed)}.before\\:op_0\\.85:before{opacity:.85}.before\\:trf_translateY\\(-100\\%\\)_translateY\\(-2px\\):before{transform:translateY(-100%) translateY(-2px)}.\\[\\&\\[data-zero\\]\\]\\:c_mantine\\.colors\\.dimmed[data-zero]{color:var(--colors-mantine-colors-dimmed)}.\\[\\&_\\.mantine-Text-root\\]\\:c_mantine\\.colors\\.text\\/90 .mantine-Text-root{--mix-color: color-mix(in srgb, var(--colors-mantine-colors-text) 90%, transparent);color:var(--mix-color, var(--colors-mantine-colors-text))}.\\[\\&_\\.mantine-Text-root\\]\\:fs_xs .mantine-Text-root{font-size:var(--font-sizes-xs)}.\\[\\&_\\.mantine-Text-root\\]\\:fw_500 .mantine-Text-root{font-weight:500}.\\[\\&_\\.mantine-Text-root\\]\\:lh_1\\.2 .mantine-Text-root{line-height:1.2}.\\[\\&_\\.mantine-Text-root\\]\\:fs_xxs .mantine-Text-root{font-size:var(--font-sizes-xxs)}.\\[\\&_\\.mantine-Text-root\\]\\:fw_400 .mantine-Text-root{font-weight:400}.\\[\\&_\\.mantine-Text-root\\]\\:lh_xs .mantine-Text-root{line-height:var(--line-heights-xs)}.\\[\\&_\\.mantine-Text-root\\]\\:c_mantine\\.colors\\.dimmed .mantine-Text-root{color:var(--colors-mantine-colors-dimmed)}.\\[\\&\\[data-disabled\\]_\\.mantine-ThemeIcon-root\\]\\:op_0\\.45[data-disabled] .mantine-ThemeIcon-root{opacity:.45}:where(.likec4-view-btn[data-disabled]) .\\[\\:where\\(\\.likec4-view-btn\\[data-disabled\\]\\)_\\&\\]\\:op_0\\.85{opacity:.85}[data-mantine-color-scheme=light] .light\\:c_mantine\\.colors\\.gray\\[5\\]{color:var(--colors-mantine-colors-gray\\[5\\])}.\\[\\&_svg\\,_\\&_img\\]\\:pointer-events_none svg,.\\[\\&_svg\\,_\\&_img\\]\\:pointer-events_none img{pointer-events:none}.\\[\\&\\.likec4-shape-icon_svg\\]\\:stk-w_1\\.5.likec4-shape-icon svg{stroke-width:1.5}:where([data-disabled]) .\\[\\:where\\(\\[data-disabled\\]\\)_\\&\\]\\:op_0\\.4{opacity:.4}:where([data-disabled]) .\\[\\:where\\(\\[data-disabled\\]\\)_\\&\\]\\:op_0\\.85{opacity:.85}[data-mantine-color-scheme=light] .light\\:bg-c_\\[rgb\\(255_255_255_\\/_0\\.6\\)\\]{background-color:#fff9}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .whenHovered\\:stk-w_12px{stroke-width:12px}.\\[\\&_\\.react-flow__edge-interaction\\]\\:cursor_copy .react-flow__edge-interaction{cursor:copy}[data-mantine-color-scheme=dark] .dark\\:mix-bm_screen{mix-blend-mode:screen}[data-mantine-color-scheme=light] .light\\:mix-bm_multiply{mix-blend-mode:multiply}:where([data-likec4-selected=true],[data-likec4-hovered=true]) .\\[\\:where\\(\\[data-likec4-selected\\=\\'true\\'\\]\\,_\\[data-likec4-hovered\\=\\'true\\'\\]\\)_\\&\\]\\:vis_visible{visibility:visible}:where([data-likec4-selected=true],[data-likec4-hovered=true]) .\\[\\:where\\(\\[data-likec4-selected\\=\\'true\\'\\]\\,_\\[data-likec4-hovered\\=\\'true\\'\\]\\)_\\&\\]\\:fill-opacity_1{fill-opacity:1}:where([data-likec4-selected=true],[data-likec4-hovered=true]) .\\[\\:where\\(\\[data-likec4-selected\\=\\'true\\'\\]\\,_\\[data-likec4-hovered\\=\\'true\\'\\]\\)_\\&\\]\\:trs-tmf_out{--transition-easing: var(--easings-out);transition-timing-function:var(--easings-out)}:where([data-likec4-selected=true],[data-likec4-hovered=true]) .\\[\\:where\\(\\[data-likec4-selected\\=\\'true\\'\\]\\,_\\[data-likec4-hovered\\=\\'true\\'\\]\\)_\\&\\]\\:trs-dly_0ms{transition-delay:0ms}:where([data-likec4-selected=true]) .\\[\\:where\\(\\[data-likec4-selected\\=\\'true\\'\\]\\)_\\&\\]\\:r_6{r:6px}:is([data-likec4-hovered=true]) .\\[\\:is\\(\\[data-likec4-hovered\\=\\'true\\'\\]\\)_\\&\\]\\:r_8{r:8px}.\\[\\&_\\+_\\.likec4-element-shape\\]\\:ring-c_likec4\\.compare\\.manual\\.outline+.likec4-element-shape{outline-color:var(--colors-likec4-compare-manual-outline)}.\\[\\&_\\+_\\.likec4-element-shape\\]\\:ring-w_4px+.likec4-element-shape{outline-width:4px}.\\[\\&_\\+_\\.likec4-element-shape\\]\\:outline-style_dashed+.likec4-element-shape{outline-style:dashed}.\\[\\&_\\+_\\.likec4-element-shape\\]\\:ring-o_1\\.5+.likec4-element-shape{outline-offset:var(--spacing-1\\.5)}[data-mantine-color-scheme=dark] .dark\\:bg-c_mantine\\.colors\\.dark\\[6\\]\\/80{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-dark\\[6\\]) 80%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-dark\\[6\\]))}.\\[\\&_\\.mantine-ScrollArea-viewport\\]\\:min-h_100\\% .mantine-ScrollArea-viewport{min-height:var(--sizes-100\\%)}:where([data-likec4-shape=browser]) .shapeBrowser\\:right_\\[5px\\]{right:5px}:where([data-likec4-shape=cylinder]) .shapeCylinder\\:top_\\[14px\\]{top:14px}:where([data-likec4-shape=storage]) .shapeStorage\\:top_\\[14px\\]{top:14px}:where([data-likec4-shape=queue]) .shapeQueue\\:top_\\[1px\\]{top:1px}:where([data-likec4-shape=queue]) .shapeQueue\\:right_3{right:var(--spacing-3)}:where([data-likec4-shape=cylinder]) .shapeCylinder\\:bottom_\\[5px\\]{bottom:5px}:where([data-likec4-shape=storage]) .shapeStorage\\:bottom_\\[5px\\]{bottom:5px}:where([data-likec4-shape=queue]) .shapeQueue\\:bottom_0{bottom:var(--spacing-0)}:where([data-likec4-shape=queue]) .shapeQueue\\:pl_\\[14px\\]{padding-left:14px}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .whenHovered\\:h_12{height:12px}[data-mantine-color-scheme=dark] .dark\\:bd-l-c_mantine\\.colors\\.dark\\[4\\]{border-left-color:var(--colors-mantine-colors-dark\\[4\\])}.\\[\\&_\\>_svg\\]\\:w_70\\%>svg{width:70%}.\\[\\&_\\>_svg\\]\\:h_70\\%>svg{height:70%}.\\[\\&_\\.tabler-icon\\]\\:w_65\\% .tabler-icon{width:65%}.\\[\\&_\\.tabler-icon\\]\\:h_65\\% .tabler-icon{height:65%}.\\[\\&_\\:where\\(svg\\,_img\\)\\]\\:w_100\\% :where(svg,img){width:var(--sizes-100\\%)}.\\[\\&_\\:where\\(svg\\,_img\\)\\]\\:h_auto :where(svg,img){height:auto}.\\[\\&_\\:where\\(svg\\,_img\\)\\]\\:max-h_100\\% :where(svg,img){max-height:var(--sizes-100\\%)}.\\[\\&\\:not\\(\\:has\\(\\.mantine-ScrollArea-root\\)\\)\\]\\:pl_1:not(:has(.mantine-ScrollArea-root)){padding-left:var(--spacing-1)}.\\[\\&\\:not\\(\\:has\\(\\.mantine-ScrollArea-root\\)\\)\\]\\:pr_1:not(:has(.mantine-ScrollArea-root)){padding-right:var(--spacing-1)}.\\[\\&_\\.mantine-ScrollArea-root\\]\\:w_100\\% .mantine-ScrollArea-root{width:var(--sizes-100\\%)}.\\[\\&_\\.mantine-ScrollArea-root\\]\\:h_100\\% .mantine-ScrollArea-root{height:var(--sizes-100\\%)}.\\[\\&\\[data-level\\=\\'1\\'\\]\\]\\:mb_sm[data-level="1"]{margin-bottom:var(--spacing-sm)}.\\[\\&_\\.tabler-icon\\]\\:w_90\\% .tabler-icon{width:90%}.before\\:top_0:before{top:var(--spacing-0)}.before\\:left_2:before{left:var(--spacing-2)}.\\[\\&\\:last-child_\\.likec4-edge-label\\]\\:mb_0:last-child .likec4-edge-label{margin-bottom:var(--spacing-0)}.\\[\\&_svg\\,_\\&_img\\]\\:w_100\\% svg,.\\[\\&_svg\\,_\\&_img\\]\\:w_100\\% img{width:var(--sizes-100\\%)}.\\[\\&_svg\\,_\\&_img\\]\\:h_auto svg,.\\[\\&_svg\\,_\\&_img\\]\\:h_auto img{height:auto}.\\[\\&_svg\\,_\\&_img\\]\\:max-h_100\\% svg,.\\[\\&_svg\\,_\\&_img\\]\\:max-h_100\\% img{max-height:var(--sizes-100\\%)}:is(.\\[\\&_\\+_\\&\\]\\:mt_\\[32px\\])+:is(.\\[\\&_\\+_\\&\\]\\:mt_\\[32px\\]){margin-top:32px}:where(.react-flow__node:has([data-likec4-hovered=true]),.react-flow__edge:has([data-likec4-hovered=true]),.likec4-edge-container[data-likec4-hovered=true]) .whenHovered\\:w_7px{width:7px}:where(.react-flow__node,.react-flow__edge,.likec4-edge-container):is(.selected) .whenSelected\\:w_7px{width:7px}.focusWithin\\:bg_mantine\\.colors\\.gray\\[4\\]\\/55\\!:focus-within{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-gray\\[4\\]) 55%, transparent) !important;background:var(--mix-background, var(--colors-mantine-colors-gray\\[4\\]))!important}.group:focus-within .groupFocusWithin\\:op_1{opacity:1}.group:focus-within .groupFocusWithin\\:grayscale_0{--grayscale: grayscale(0)}.focus\\:bg_mantine\\.colors\\.primary\\[8\\]:is(:focus,[data-focus]){background:var(--colors-mantine-colors-primary\\[8\\])}.mantine-Tree-node:focus>.mantine-Tree-label .\\[\\.mantine-Tree-node\\:focus_\\>_\\.mantine-Tree-label_\\&\\]\\:bg_mantine\\.colors\\.primary\\[8\\]{background:var(--colors-mantine-colors-primary\\[8\\])}.group:is(:focus,[data-focus]) .groupFocus\\:transition_none{transition:none}.focus\\:ring_none:is(:focus,[data-focus]){outline:var(--borders-none)}.focus\\:bd-c_mantine\\.colors\\.primary\\[9\\]:is(:focus,[data-focus]){border-color:var(--colors-mantine-colors-primary\\[9\\])}.mantine-Tree-node:focus>.mantine-Tree-label .\\[\\.mantine-Tree-node\\:focus_\\>_\\.mantine-Tree-label_\\&\\]\\:ring_none{outline:var(--borders-none)}.mantine-Tree-node:focus>.mantine-Tree-label .\\[\\.mantine-Tree-node\\:focus_\\>_\\.mantine-Tree-label_\\&\\]\\:bd-c_mantine\\.colors\\.primary\\[9\\]{border-color:var(--colors-mantine-colors-primary\\[9\\])}.group:is(:focus,[data-focus]) .groupFocus\\:c_\\[inherit\\]\\!{color:inherit!important}.group:is(:focus,[data-focus]) .groupFocus\\:op_0\\.5{opacity:.5}.group:is(:focus,[data-focus]) .groupFocus\\:op_0\\.8{opacity:.8}.focus\\:bg-c_mantine\\.colors\\.gray\\[2\\]:is(:focus,[data-focus]){background-color:var(--colors-mantine-colors-gray\\[2\\])}.focus\\:c_mantine\\.colors\\.primary\\.lightColor\\!:is(:focus,[data-focus]){color:var(--colors-mantine-colors-primary-light-color)!important}.focus\\:bg-c_mantine\\.colors\\.primary\\.lightHover\\!:is(:focus,[data-focus]){background-color:var(--colors-mantine-colors-primary-light-hover)!important}.group:is(:focus,[data-focus]) .groupFocus\\:c_mantine\\.colors\\.primary\\[0\\]{color:var(--colors-mantine-colors-primary\\[0\\])}.mantine-Tree-node:focus>.mantine-Tree-label .\\[\\.mantine-Tree-node\\:focus_\\>_\\.mantine-Tree-label_\\&\\]\\:c_mantine\\.colors\\.primary\\[0\\]{color:var(--colors-mantine-colors-primary\\[0\\])}.group:is(:focus,[data-focus]) .groupFocus\\:c_mantine\\.colors\\.primary\\[1\\]{color:var(--colors-mantine-colors-primary\\[1\\])}.mantine-Tree-node:focus>.mantine-Tree-label .\\[\\.mantine-Tree-node\\:focus_\\>_\\.mantine-Tree-label_\\&\\]\\:c_mantine\\.colors\\.primary\\[1\\]{color:var(--colors-mantine-colors-primary\\[1\\])}.hover\\:--icon-color_\\{colors\\.mantine\\.colors\\.dark\\[1\\]\\}:is(:hover,[data-hover]){--icon-color: var(--colors-mantine-colors-dark\\[1\\])}.hover\\:--view-title-color_\\{colors\\.mantine\\.colors\\.defaultColor\\}:is(:hover,[data-hover]){--view-title-color: var(--colors-mantine-colors-default-color)}.hover\\:bg_mantine\\.colors\\.defaultHover:is(:hover,[data-hover]){background:var(--colors-mantine-colors-default-hover)}.hover\\:bg_mantine\\.colors\\.gray\\[3\\]:is(:hover,[data-hover]){background:var(--colors-mantine-colors-gray\\[3\\])}.hover\\:bg_mantine\\.colors\\.gray\\.lightHover:is(:hover,[data-hover]){background:var(--colors-mantine-colors-gray-light-hover)}.hover\\:bg_mantine\\.colors\\.primary\\[8\\]\\/60:is(:hover,[data-hover]){--mix-background: color-mix(in srgb, var(--colors-mantine-colors-primary\\[8\\]) 60%, transparent);background:var(--mix-background, var(--colors-mantine-colors-primary\\[8\\]))}.group:is(:hover,[data-hover]) .groupHover\\:bg_mantine\\.colors\\.gray\\[3\\]\\/35{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-gray\\[3\\]) 35%, transparent);background:var(--mix-background, var(--colors-mantine-colors-gray\\[3\\]))}.hover\\:td_underline:is(:hover,[data-hover]){text-decoration:underline}.hover\\:bd-c_mantine\\.colors\\.defaultBorder:is(:hover,[data-hover]){border-color:var(--colors-mantine-colors-default-border)}.hover\\:bd-w_4px:is(:hover,[data-hover]){border-width:4px}.hover\\:bd-c_mantine\\.colors\\.dark\\[1\\]:is(:hover,[data-hover]){border-color:var(--colors-mantine-colors-dark\\[1\\])}.hover\\:border-style_solid:is(:hover,[data-hover]){border-style:solid}.\\[\\&\\:is\\(\\:hover\\,_\\[data-selected\\=true\\]\\)_\\>_\\*\\]\\:transition_all_0\\.15s_ease-out:is(:hover,[data-selected=true])>*{transition:all .15s ease-out}.hover\\:ring_none:is(:hover,[data-hover]){outline:var(--borders-none)}.hover\\:bd-c_mantine\\.colors\\.primary\\[9\\]:is(:hover,[data-hover]){border-color:var(--colors-mantine-colors-primary\\[9\\])}.hover\\:transition_all_120ms_ease-out:is(:hover,[data-hover]){transition:all .12s ease-out}.hover\\:op_1:is(:hover,[data-hover]){opacity:1}.hover\\:bg-c_mantine\\.colors\\.gray\\[1\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-gray\\[1\\])}.hover\\:bx-sh_sm:is(:hover,[data-hover]){box-shadow:var(--shadows-sm)}.group:is(:hover,[data-hover]) .groupHover\\:c_mantine\\.colors\\.dimmed{color:var(--colors-mantine-colors-dimmed)}.group:is(:hover,[data-hover]) .groupHover\\:op_0\\.5{opacity:.5}.group:is(:hover,[data-hover]) .groupHover\\:op_0\\.8{opacity:.8}.hover\\:bg-c_mantine\\.colors\\.gray\\[2\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-gray\\[2\\])}.hover\\:bg-c_likec4\\.panel\\.action\\.warning\\.bg\\.hover:is(:hover,[data-hover]){background-color:var(--colors-likec4-panel-action-warning-bg-hover)}.hover\\:c_likec4\\.panel\\.action\\.hover:is(:hover,[data-hover]){color:var(--colors-likec4-panel-action-hover)}.hover\\:c_likec4\\.panel\\.action:is(:hover,[data-hover]){color:var(--colors-likec4-panel-action)}.hover\\:trs-dly_0s:is(:hover,[data-hover]){transition-delay:0s}.hover\\:bg-c_likec4\\.panel\\.action\\.bg\\.hover:is(:hover,[data-hover]){background-color:var(--colors-likec4-panel-action-bg-hover)}.\\[\\&\\:hover_\\>_\\*\\]\\:trs-tmf_out:hover>*{--transition-easing: var(--easings-out);transition-timing-function:var(--easings-out)}.\\[\\&\\:hover_\\>_\\*\\]\\:trf_translateX\\(1\\.6px\\):hover>*{transform:translate(1.6px)}.hover\\:trs-tmf_out:is(:hover,[data-hover]){--transition-easing: var(--easings-out);transition-timing-function:var(--easings-out)}.hover\\:c_mantine\\.colors\\.defaultColor:is(:hover,[data-hover]){color:var(--colors-mantine-colors-default-color)}.hover\\:c_mantine\\.colors\\.primary\\[6\\]:is(:hover,[data-hover]){color:var(--colors-mantine-colors-primary\\[6\\])}.\\[\\&\\:is\\(\\:hover\\,_\\[data-selected\\=true\\]\\)_\\>_\\*\\]\\:cursor_pointer:is(:hover,[data-selected=true])>*{cursor:pointer}.\\[\\&\\:is\\(\\:hover\\,_\\[data-selected\\=true\\]\\)_\\>_\\*\\]\\:bg-c_mantine\\.colors\\.defaultHover:is(:hover,[data-selected=true])>*{background-color:var(--colors-mantine-colors-default-hover)}.hover\\:bg-c_mantine\\.colors\\.gray\\[0\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-gray\\[0\\])}.group:is(:hover,[data-hover]) .groupHover\\:op_1{opacity:1}.group:is(:hover,[data-hover]) .groupHover\\:grayscale_0{--grayscale: grayscale(0)}.group:is(:hover,[data-hover]) .groupHover\\:c_mantine\\.colors\\.primary\\[0\\]{color:var(--colors-mantine-colors-primary\\[0\\])}.group:is(:hover,[data-hover]) .groupHover\\:c_mantine\\.colors\\.primary\\[1\\]{color:var(--colors-mantine-colors-primary\\[1\\])}.hover\\:fill_mantine\\.colors\\.primary\\.filledHover:is(:hover,[data-hover]){fill:var(--colors-mantine-colors-primary-filled-hover)}.hover\\:r_10:is(:hover,[data-hover]){r:10px}.hover\\:trs-dur_100ms:is(:hover,[data-hover]){--transition-duration: .1s;transition-duration:.1s}.hover\\:bg-c_mantine\\.colors\\.primary\\[2\\]\\/50:is(:hover,[data-hover]){--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-primary\\[2\\]) 50%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-primary\\[2\\]))}.group:is(:active,[data-active]) .groupActive\\:op_0\\.5{opacity:.5}.group:is(:active,[data-active]) .groupActive\\:op_0\\.8{opacity:.8}.active\\:trf_translateY\\(-3px\\):is(:active,[data-active]){transform:translateY(-3px)}.group:is(:active,[data-active]) .groupActive\\:cursor_grabbing{cursor:grabbing}.likec4-root:is([data-likec4-reduced-graphics]) .reduceGraphics\\:\\[\\&_\\.action-icon\\]\\:--ai-radius_0px .action-icon{--ai-radius: 0px}[data-mantine-color-scheme=dark] .dark\\:\\[\\&\\:is\\(\\[data-active\\]\\)\\]\\:bg_mantine\\.colors\\.dark\\[5\\]:is([data-active]){background:var(--colors-mantine-colors-dark\\[5\\])}[data-mantine-color-scheme=light] .light\\:\\[\\&_\\.mantine-SegmentedControl-root\\]\\:bg_mantine\\.colors\\.gray\\[3\\] .mantine-SegmentedControl-root{background:var(--colors-mantine-colors-gray\\[3\\])}.group:is(:hover,[data-hover]) .\\[\\&\\:is\\(\\[data-position\\=\\"left\\"\\]\\)\\]\\:groupHover\\:c_\\[var\\(--badge-color\\)\\]:is([data-position=left]){color:var(--badge-color)}.group:is(:hover,[data-hover]) .\\[\\&\\:is\\(\\[data-position\\=\\"left\\"\\]\\)\\]\\:groupHover\\:op_0\\.7:is([data-position=left]){opacity:.7}[data-mantine-color-scheme=dark] .\\[\\&_\\>_mark\\]\\:dark\\:bg-c_mantine\\.colors\\.yellow\\[5\\]\\/80>mark{--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-yellow\\[5\\]) 80%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-yellow\\[5\\]))}.group:is(:focus,[data-focus]) .\\[\\&_\\>_mark\\]\\:groupFocus\\:bg-c_\\[transparent\\]>mark{background-color:var(--colors-transparent)}.group:is(:focus,[data-focus]) .\\[\\&_\\>_mark\\]\\:groupFocus\\:c_\\[inherit\\]\\!>mark{color:inherit!important}.notDisabled\\:hover\\:bg-c_likec4\\.panel\\.action\\.bg\\.hover:not(:is(:disabled,[disabled],[data-disabled])):is(:hover,[data-hover]){background-color:var(--colors-likec4-panel-action-bg-hover)}.\\[\\&_\\.mantine-ThemeIcon-root\\]\\:hover\\:c_mantine\\.colors\\.defaultColor .mantine-ThemeIcon-root:is(:hover,[data-hover]){color:var(--colors-mantine-colors-default-color)}[data-mantine-color-scheme=dark] .dark\\:\\[\\&\\:is\\(\\[data-active\\]\\)\\]\\:c_mantine\\.colors\\.white:is([data-active]){color:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=light] .\\[\\&\\[data-missing\\]\\]\\:light\\:c_mantine\\.colors\\.orange\\[8\\][data-missing]{color:var(--colors-mantine-colors-orange\\[8\\])}.\\[\\&_\\.mantine-ScrollArea-viewport\\]\\:\\[\\&_\\>_div\\]\\:min-h_100\\% .mantine-ScrollArea-viewport>div{min-height:var(--sizes-100\\%)}.\\[\\&_\\.mantine-ScrollArea-viewport\\]\\:\\[\\&_\\>_div\\]\\:h_100\\% .mantine-ScrollArea-viewport>div{height:var(--sizes-100\\%)}.\\[\\&_\\.mantine-ScrollArea-root\\]\\:\\[\\&_\\>_div\\]\\:pl_1 .mantine-ScrollArea-root>div{padding-left:var(--spacing-1)}.\\[\\&_\\.mantine-ScrollArea-root\\]\\:\\[\\&_\\>_div\\]\\:pr_1 .mantine-ScrollArea-root>div{padding-right:var(--spacing-1)}[data-mantine-color-scheme=dark] .focusWithin\\:dark\\:bg_mantine\\.colors\\.dark\\[5\\]\\/55\\!:focus-within{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-dark\\[5\\]) 55%, transparent) !important;background:var(--mix-background, var(--colors-mantine-colors-dark\\[5\\]))!important}[data-mantine-color-scheme=dark] .focus\\:dark\\:bg-c_mantine\\.colors\\.dark\\[4\\]:is(:focus,[data-focus]){background-color:var(--colors-mantine-colors-dark\\[4\\])}[data-mantine-color-scheme=light] .group:is(:focus,[data-focus]) .groupFocus\\:light\\:c_mantine\\.colors\\.white{color:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=light] .mantine-Tree-node:focus>.mantine-Tree-label .\\[\\.mantine-Tree-node\\:focus_\\>_\\.mantine-Tree-label_\\&\\]\\:light\\:c_mantine\\.colors\\.white{color:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=light] .light\\:hover\\:--icon-color_\\{colors\\.mantine\\.colors\\.gray\\[7\\]\\}:is(:hover,[data-hover]){--icon-color: var(--colors-mantine-colors-gray\\[7\\])}[data-mantine-color-scheme=dark] .dark\\:hover\\:bg_mantine\\.colors\\.dark\\[6\\]:is(:hover,[data-hover]){background:var(--colors-mantine-colors-dark\\[6\\])}[data-mantine-color-scheme=dark] .group:is(:hover,[data-hover]) .groupHover\\:dark\\:bg_mantine\\.colors\\.dark\\[5\\]\\/35{--mix-background: color-mix(in srgb, var(--colors-mantine-colors-dark\\[5\\]) 35%, transparent);background:var(--mix-background, var(--colors-mantine-colors-dark\\[5\\]))}[data-mantine-color-scheme=light] .light\\:hover\\:bd-c_mantine\\.colors\\.primary\\[6\\]:is(:hover,[data-hover]){border-color:var(--colors-mantine-colors-primary\\[6\\])}[data-mantine-color-scheme=dark] .hover\\:dark\\:bg-c_mantine\\.colors\\.dark\\[5\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-dark\\[5\\])}[data-mantine-color-scheme=light] .group:is(:hover,[data-hover]) .groupHover\\:light\\:bg-c_mantine\\.colors\\.gray\\[2\\]{background-color:var(--colors-mantine-colors-gray\\[2\\])}[data-mantine-color-scheme=dark] .group:is(:hover,[data-hover]) .groupHover\\:dark\\:bg-c_mantine\\.colors\\.dark\\[8\\]{background-color:var(--colors-mantine-colors-dark\\[8\\])}[data-mantine-color-scheme=dark] .hover\\:dark\\:bg-c_mantine\\.colors\\.dark\\[4\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-dark\\[4\\])}[data-mantine-color-scheme=dark] .hover\\:dark\\:bg-c_mantine\\.colors\\.dark\\[5\\]\\/70:is(:hover,[data-hover]){--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-dark\\[5\\]) 70%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-dark\\[5\\]))}[data-mantine-color-scheme=dark] .dark\\:hover\\:c_mantine\\.colors\\.white:is(:hover,[data-hover]){color:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=dark] .hover\\:dark\\:bg-c_mantine\\.colors\\.dark\\[7\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-dark\\[7\\])}[data-mantine-color-scheme=dark] .hover\\:dark\\:c_mantine\\.colors\\.primary\\[4\\]:is(:hover,[data-hover]){color:var(--colors-mantine-colors-primary\\[4\\])}.hover\\:\\[\\&_\\>_\\:not\\(\\[data-no-transform\\]\\)\\]\\:trs-tmf_out:is(:hover,[data-hover])>:not([data-no-transform]){--transition-easing: var(--easings-out);transition-timing-function:var(--easings-out)}.hover\\:\\[\\&_\\>_\\:not\\(\\[data-no-transform\\]\\)\\]\\:trf_translateX\\(1px\\):is(:hover,[data-hover])>:not([data-no-transform]){transform:translate(1px)}.hover\\:\\[\\&_\\>_\\*\\]\\:trs-tmf_out:is(:hover,[data-hover])>*{--transition-easing: var(--easings-out);transition-timing-function:var(--easings-out)}.hover\\:\\[\\&_\\>_\\*\\]\\:trf_translateX\\(1px\\):is(:hover,[data-hover])>*{transform:translate(1px)}[data-mantine-color-scheme=dark] .hover\\:dark\\:bg-c_mantine\\.colors\\.defaultHover:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-default-hover)}[data-mantine-color-scheme=dark] .hover\\:dark\\:c_mantine\\.colors\\.white:is(:hover,[data-hover]){color:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=light] .light\\:hover\\:bg-c_mantine\\.colors\\.primary\\[5\\]:is(:hover,[data-hover]){background-color:var(--colors-mantine-colors-primary\\[5\\])}[data-mantine-color-scheme=light] .group:is(:hover,[data-hover]) .groupHover\\:light\\:c_mantine\\.colors\\.white{color:var(--colors-mantine-colors-white)}[data-mantine-color-scheme=light] .group:is(:hover,[data-hover]) .groupHover\\:light\\:c_mantine\\.colors\\.primary\\[0\\]{color:var(--colors-mantine-colors-primary\\[0\\])}[data-mantine-color-scheme=dark] .dark\\:hover\\:bg-c_mantine\\.colors\\.dark\\[3\\]\\/40:is(:hover,[data-hover]){--mix-backgroundColor: color-mix(in srgb, var(--colors-mantine-colors-dark\\[3\\]) 40%, transparent);background-color:var(--mix-backgroundColor, var(--colors-mantine-colors-dark\\[3\\]))}@container (min-width: 24rem){.\\@\\/xs\\:d_flex{display:flex}}@media screen and (min-width:36rem){.xs\\:max-w_calc\\(100cqw\\){max-width:100cqw}.xs\\:max-w_calc\\(100cqw_-_50px\\){max-width:calc(100cqw - 50px)}.xs\\:max-w_calc\\(100cqw_-_250px\\){max-width:calc(100cqw - 250px)}.xs\\:max-h_calc\\(100cqh_-_200px\\){max-height:calc(100cqh - 200px)}.xs\\:max-h_calc\\(100cqh_-_160px\\){max-height:calc(100cqh - 160px)}.xs\\:h_100cqh{height:100cqh}.xs\\:max-h_calc\\(100cqh_-_70px\\){max-height:calc(100cqh - 70px)}}@container (min-width: 40rem){.\\@\\/sm\\:m_xs{margin:var(--spacing-xs)}.\\@\\/sm\\:gap_xs{gap:var(--spacing-xs)}.\\@\\/sm\\:w_max-content{width:max-content}.\\@\\/sm\\:max-w_calc\\(100vw_-_2_\\*_\\{spacing\\.md\\}\\){max-width:calc(100vw - 2 * var(--spacing-md))}.\\@\\/sm\\:min-w_400{min-width:400px}.\\@\\/sm\\:max-w_550{max-width:550px}}@container (min-width: 40rem){@media screen and (min-width:36rem){.\\@\\/sm\\:xs\\:max-w_calc\\(100cqw_-_2_\\*_\\{spacing\\.md\\}\\){max-width:calc(100cqw - 2 * var(--spacing-md))}}}@container (min-width: 48rem){.\\@\\/md\\:d_block{display:block}.\\@\\/md\\:d_none{display:none}.\\@\\/md\\:d_flex{display:flex}.\\@\\/md\\:d_inherit{display:inherit}.\\@\\/md\\:ms_2{margin-inline-start:var(--spacing-2)}.\\@\\/md\\:w_\\[64px\\]{width:64px}}@media screen and (min-width:48rem){.sm\\:pr_\\[30px\\]{padding-right:30px}.sm\\:min-w_300{min-width:300px}.sm\\:max-w_65vw{max-width:65vw}}@media screen and (min-width:62rem){.md\\:--text-fz_\\{fontSizes\\.md\\}{--text-fz: var(--font-sizes-md)}.md\\:bd-w_4{border-width:4px}.md\\:px_6{padding-inline:var(--spacing-6)}.md\\:pr_\\[50px\\]{padding-right:50px}.md\\:max-w_40vw{max-width:40vw}}@container (min-width: 64rem){.\\@\\/lg\\:max-w_700{max-width:700px}}@media screen and (min-width:75rem){.lg\\:px_8{padding-inline:var(--spacing-8)}}@container likec4-tree (max-width: 450px){.\\[\\@container_likec4-tree_\\(max-width\\:_450px\\)\\]\\:--likec4-icon-size_18px{--likec4-icon-size: 18px}.\\[\\@container_likec4-tree_\\(max-width\\:_450px\\)\\]\\:gap_0\\.5{gap:var(--spacing-0\\.5)}.\\[\\@container_likec4-tree_\\(max-width\\:_450px\\)\\]\\:flex-d_column-reverse{flex-direction:column-reverse}.\\[\\@container_likec4-tree_\\(max-width\\:_450px\\)\\]\\:ai_flex-start{align-items:flex-start}.\\[\\@container_likec4-tree_\\(max-width\\:_450px\\)\\]\\:d_none{display:none}}@media print{.print\\:d_none{display:none}}}`, DefaultTheme = {
  autoContrast: !0,
  primaryColor: "indigo",
  cursorType: "pointer",
  defaultRadius: "sm",
  fontFamily: "var(--likec4-app-font, var(--likec4-app-font-default))",
  headings: {
    fontWeight: "500",
    sizes: {
      h1: {
        // fontSize: '2rem',
        fontWeight: "600"
      },
      h2: {
        fontWeight: "500"
        // fontSize: '1.85rem',
      }
    }
  },
  components: {
    Portal: Portal.extend({
      defaultProps: {
        reuseTargetNode: !0
      }
    }),
    Tooltip: Tooltip$6.extend({
      defaultProps: {
        color: "dark"
      }
    })
  }
};
css({
  cursor: "pointer",
  "--mantine-cursor-pointer": "pointer",
  "& :where(.likec4-diagram, .likec4-compound-node, .likec4-element-node)": {
    cursor: "pointer"
  }
});
function useBundledStyleSheet(injectFontCss, styleNonce) {
  const [styleSheets, setStyleSheets] = useState([]);
  return useIsomorphicLayoutEffect$3(() => {
    if (injectFontCss && !document.querySelector("style[data-likec4-font]")) {
      const style2 = document.createElement("style");
      style2.setAttribute("type", "text/css"), style2.setAttribute("data-likec4-font", ""), e$2(styleNonce) && style2.setAttribute("nonce", styleNonce), e$9(styleNonce) && style2.setAttribute("nonce", styleNonce()), style2.appendChild(document.createTextNode(fontsCss)), document.head.appendChild(style2);
    }
  }, [injectFontCss]), useIsomorphicLayoutEffect$3(() => {
    const css2 = new CSSStyleSheet();
    return css2.replaceSync(
      inlinedStyles.replaceAll(":where(:root,:host)", ".likec4-shadow-root").replaceAll(":root", ".likec4-shadow-root").replaceAll(/(?<![-_])\bbody\s*\{/g, ".likec4-shadow-root{")
    ), setStyleSheets([css2]), () => {
      css2.replaceSync("");
    };
  }, [inlinedStyles]), styleSheets;
}
const getComputedColorScheme = () => {
  try {
    const htmlScheme = window.getComputedStyle(document.documentElement).colorScheme ?? "", colorScheme = n$p(htmlScheme.split(" "));
    if (colorScheme === "light" || colorScheme === "dark")
      return colorScheme;
  } catch {
  }
  return null;
};
function useColorScheme(explicit) {
  const preferred = useColorScheme$1(), [computed, setComputed] = useState(getComputedColorScheme);
  return useMutationObserver(
    useDebouncedCallback(() => setComputed(getComputedColorScheme), 100),
    {
      attributes: !0,
      childList: !1,
      subtree: !1
    },
    () => document.documentElement
  ), explicit ?? computed ?? preferred;
}
function EnsureMantine({ children: children2 }) {
  const mantineCtx = useContext(MantineContext);
  return useEffect(() => {
    mantineCtx || console.warn("LikeC4Diagram must be a child of MantineProvider");
  }, []), mantineCtx ? /* @__PURE__ */ jsx(Fragment, { children: children2 }) : /* @__PURE__ */ jsx(MantineProvider, { defaultColorScheme: "auto", theme: DefaultTheme, children: children2 });
}
EnsureMantine.displayName = "EnsureMantine";
const FramerMotionConfig = ({
  reducedMotion = "user",
  children: children2
}) => {
  const nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx(LazyMotion, { features: domMax, strict: !0, children: /* @__PURE__ */ jsx(MotionConfig, { reducedMotion, ...nonce && { nonce }, children: children2 }) });
};
function LikeC4Diagram({
  onCanvasClick,
  onCanvasContextMenu,
  onCanvasDblClick,
  onEdgeClick,
  onEdgeContextMenu,
  onNavigateTo,
  onNodeClick,
  onNodeContextMenu,
  onOpenSource,
  onLogoClick,
  onLayoutTypeChange,
  onInitialized,
  view,
  className,
  controls = !0,
  fitView = !0,
  fitViewPadding: _fitViewPadding = controls ? FitViewPaddings.withControls : FitViewPaddings.default,
  pannable = !0,
  zoomable = !0,
  background = "dots",
  enableElementTags = !1,
  enableFocusMode = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = !1,
  enableCompareWithLatest = !!onLayoutTypeChange,
  nodesSelectable,
  enableNotations = !1,
  showNavigationButtons = !!onNavigateTo,
  enableDynamicViewWalkthrough = !1,
  dynamicViewVariant,
  enableSearch = !1,
  initialWidth,
  initialHeight,
  reduceGraphics = "auto",
  renderIcon,
  where,
  reactFlowProps,
  renderNodes,
  children: children2
}) {
  const id2 = useId(), initialRef = useRef(null), hasEditor = !!useOptionalLikeC4EditorPort(), readonly = !hasEditor;
  nodesSelectable ??= hasEditor || enableFocusMode || !!onNavigateTo || !!onNodeClick;
  const bounds = pickViewBounds(view, dynamicViewVariant), fitViewPadding = useNormalizedViewPadding(_fitViewPadding);
  initialRef.current == null && (initialRef.current = {
    defaultEdges: [],
    defaultNodes: [],
    initialWidth: initialWidth ?? bounds.width,
    initialHeight: initialHeight ?? bounds.height,
    initialFitViewOptions: {
      maxZoom: MaxZoom,
      minZoom: MinZoom,
      padding: fitViewPadding
    },
    initialMaxZoom: MaxZoom,
    initialMinZoom: MinZoom
  });
  const isReducedGraphicsMode = reduceGraphics === "auto" ? pannable && (bounds.width ?? 1) * (bounds.height ?? 1) > 6e6 && view.nodes.some((n2) => n2.children?.length > 0) : reduceGraphics;
  return /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsx(
    FramerMotionConfig,
    {
      ...isReducedGraphicsMode && { reducedMotion: "always" },
      children: /* @__PURE__ */ jsx(IconRendererProvider, { value: renderIcon ?? null, children: /* @__PURE__ */ jsx(
        DiagramFeatures,
        {
          features: {
            enableFitView: fitView,
            enableEditor: hasEditor,
            enableReadOnly: readonly,
            enableFocusMode,
            enableNavigateTo: !!onNavigateTo,
            enableElementDetails,
            enableRelationshipDetails,
            enableRelationshipBrowser,
            enableSearch,
            enableNavigationButtons: showNavigationButtons && !!onNavigateTo,
            enableDynamicViewWalkthrough: view._type === "dynamic" && enableDynamicViewWalkthrough,
            enableNotations,
            enableVscode: !!onOpenSource,
            enableControls: controls,
            enableElementTags,
            enableCompareWithLatest: enableCompareWithLatest && !!onLayoutTypeChange
          },
          children: /* @__PURE__ */ jsxs(
            DiagramEventHandlers,
            {
              handlers: {
                onCanvasClick,
                onCanvasContextMenu,
                onCanvasDblClick,
                onEdgeClick,
                onEdgeContextMenu,
                onNavigateTo,
                onNodeClick,
                onNodeContextMenu,
                onOpenSource,
                onLogoClick,
                onInitialized,
                onLayoutTypeChange
              },
              children: [
                /* @__PURE__ */ jsx(LikeC4Styles, { id: id2 }),
                /* @__PURE__ */ jsx(TagStylesProvider, { rootSelector: `#${id2}`, children: /* @__PURE__ */ jsx(RootContainer, { id: id2, className, reduceGraphics: isReducedGraphicsMode, children: /* @__PURE__ */ jsx(
                  ReactFlowProvider,
                  {
                    fitView,
                    ...initialRef.current,
                    children: /* @__PURE__ */ jsxs(
                      DiagramActorProvider,
                      {
                        view,
                        zoomable,
                        pannable,
                        fitViewPadding,
                        nodesDraggable: hasEditor,
                        nodesSelectable,
                        where: where ?? null,
                        dynamicViewVariant,
                        children: [
                          /* @__PURE__ */ jsx(
                            LikeC4DiagramXYFlow,
                            {
                              background,
                              reactFlowProps,
                              renderNodes,
                              children: children2
                            }
                          ),
                          /* @__PURE__ */ jsx(LikeC4DiagramUI, {})
                        ]
                      }
                    )
                  }
                ) }) })
              ]
            }
          )
        }
      ) })
    }
  ) });
}
const toLiteralPaddingWithUnit = (value) => typeof value == "number" ? `${value}px` : value;
function useNormalizedViewPadding(raw) {
  return useCustomCompareMemo(
    () => {
      if (e$3(raw))
        return t$d(raw, toLiteralPaddingWithUnit);
      const v2 = toLiteralPaddingWithUnit(raw);
      return {
        x: v2,
        y: v2
      };
    },
    [raw],
    deepEqual$1
  );
}
function LikeC4ModelProvider({
  children: children2,
  likec4model
}) {
  return /* @__PURE__ */ jsx(LikeC4ModelContext.Provider, { value: likec4model, children: children2 });
}
function LikeC4ProjectsProvider({
  children: children2,
  projects,
  onProjectChange: _onProjectChange
}) {
  useContext(LikeC4ProjectsContext) && console.warn("LikeC4ProjectsProvider should not be nested inside another one");
  const onProjectChange = useCallbackRef(_onProjectChange), [value, setValue] = useState(() => ({ projects, onProjectChange }));
  return useEffect(() => {
    setValue((current2) => deepEqual$1(current2.projects, projects) ? current2 : { projects, onProjectChange });
  }, [projects]), /* @__PURE__ */ jsx(LikeC4ProjectsContext.Provider, { value, children: children2 });
}
function StaticLikeC4Diagram({
  view,
  fitView = !0,
  fitViewPadding = "8px",
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = enableRelationshipDetails,
  background = "transparent",
  className,
  ...rest
}) {
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      className: cx(className, "likec4-static-view"),
      fitView,
      fitViewPadding,
      pannable: !1,
      zoomable: !1,
      controls: !1,
      background,
      enableNotations: !1,
      enableElementDetails: !1,
      enableRelationshipDetails,
      enableRelationshipBrowser,
      enableDynamicViewWalkthrough: !1,
      showNavigationButtons: !1,
      enableCompareWithLatest: !1,
      enableFocusMode: !1,
      enableSearch: !1,
      nodesSelectable: !1,
      enableElementTags: !1,
      ...rest
    }
  );
}
const ErrorMessage = ({ children: children2 }) => /* @__PURE__ */ jsx(
  "div",
  {
    style: {
      margin: "1rem 0"
    },
    children: /* @__PURE__ */ jsx(
      "div",
      {
        style: {
          margin: "0 auto",
          display: "inline-block",
          padding: "2rem",
          background: "rgba(250,82,82,.15)",
          color: "#ffa8a8"
        },
        children: children2
      }
    )
  }
), ViewNotFound = ({ viewId }) => /* @__PURE__ */ jsxs(ErrorMessage, { children: [
  "View ",
  /* @__PURE__ */ jsx("code", { children: viewId }),
  " not found"
] }), renderToString = (_view) => {
  throw new Error("LikeC4View is not available SSR");
};
var propTypes = { exports: {} }, ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = ReactPropTypesSecret, ReactPropTypesSecret_1;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  return emptyFunctionWithReset.resetWarningCache = emptyFunction, factoryWithThrowingShims = function() {
    function shim2(props, propName, componentName, location, propFullName, secret) {
      if (secret !== ReactPropTypesSecret) {
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw err.name = "Invariant Violation", err;
      }
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bigint: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    return ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
  }, factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  return hasRequiredPropTypes || (hasRequiredPropTypes = 1, propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()()), propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const s = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var f = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function p(e2, r2) {
  return e2(r2 = { exports: {} }, r2.exports), r2.exports;
}
var d = p((function(e2) {
  (function(r2) {
    var t2 = function(e3, r3, n3) {
      if (!u(r3) || s2(r3) || f2(r3) || p2(r3) || i2(r3)) return r3;
      var o2, a3 = 0, c2 = 0;
      if (l(r3)) for (o2 = [], c2 = r3.length; a3 < c2; a3++) o2.push(t2(e3, r3[a3], n3));
      else for (var d3 in o2 = {}, r3) Object.prototype.hasOwnProperty.call(r3, d3) && (o2[e3(d3, n3)] = t2(e3, r3[d3], n3));
      return o2;
    }, n2 = function(e3) {
      return d2(e3) ? e3 : (e3 = e3.replace(/[\-_\s]+(.)?/g, (function(e4, r3) {
        return r3 ? r3.toUpperCase() : "";
      }))).substr(0, 1).toLowerCase() + e3.substr(1);
    }, o = function(e3) {
      var r3 = n2(e3);
      return r3.substr(0, 1).toUpperCase() + r3.substr(1);
    }, a2 = function(e3, r3) {
      return (function(e4, r4) {
        var t3 = (r4 = r4 || {}).separator || "_", n3 = r4.split || /(?=[A-Z])/;
        return e4.split(n3).join(t3);
      })(e3, r3).toLowerCase();
    }, c = Object.prototype.toString, i2 = function(e3) {
      return typeof e3 == "function";
    }, u = function(e3) {
      return e3 === Object(e3);
    }, l = function(e3) {
      return c.call(e3) == "[object Array]";
    }, s2 = function(e3) {
      return c.call(e3) == "[object Date]";
    }, f2 = function(e3) {
      return c.call(e3) == "[object RegExp]";
    }, p2 = function(e3) {
      return c.call(e3) == "[object Boolean]";
    }, d2 = function(e3) {
      return (e3 -= 0) == e3;
    }, y2 = function(e3, r3) {
      var t3 = r3 && "process" in r3 ? r3.process : r3;
      return typeof t3 != "function" ? e3 : function(r4, n3) {
        return t3(r4, e3, n3);
      };
    }, h2 = { camelize: n2, decamelize: a2, pascalize: o, depascalize: a2, camelizeKeys: function(e3, r3) {
      return t2(y2(n2, r3), e3);
    }, decamelizeKeys: function(e3, r3) {
      return t2(y2(a2, r3), e3, r3);
    }, pascalizeKeys: function(e3, r3) {
      return t2(y2(o, r3), e3);
    }, depascalizeKeys: function() {
      return this.decamelizeKeys.apply(this, arguments);
    } };
    e2.exports ? e2.exports = h2 : r2.humps = h2;
  })(f);
})).decamelize, y = function(e2) {
  if (Array.isArray(e2)) return e2;
}, h = function(e2, r2) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e2)) {
    var t2 = [], n2 = !0, o = !1, a2 = void 0;
    try {
      for (var c, i2 = e2[Symbol.iterator](); !(n2 = (c = i2.next()).done) && (t2.push(c.value), !r2 || t2.length !== r2); n2 = !0) ;
    } catch (e3) {
      o = !0, a2 = e3;
    } finally {
      try {
        n2 || i2.return == null || i2.return();
      } finally {
        if (o) throw a2;
      }
    }
    return t2;
  }
}, v = function(e2, r2) {
  (r2 == null || r2 > e2.length) && (r2 = e2.length);
  for (var t2 = 0, n2 = new Array(r2); t2 < r2; t2++) n2[t2] = e2[t2];
  return n2;
}, m = function(e2, r2) {
  if (e2) {
    if (typeof e2 == "string") return v(e2, r2);
    var t2 = Object.prototype.toString.call(e2).slice(8, -1);
    return t2 === "Object" && e2.constructor && (t2 = e2.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(e2) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? v(e2, r2) : void 0;
  }
}, b = function() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}, g = function(e2, r2) {
  return y(e2) || h(e2, r2) || m(e2, r2) || b();
}, S = p((function(e2) {
  function r2() {
    return e2.exports = r2 = Object.assign || function(e3) {
      for (var r3 = 1; r3 < arguments.length; r3++) {
        var t2 = arguments[r3];
        for (var n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (e3[n2] = t2[n2]);
      }
      return e3;
    }, r2.apply(this, arguments);
  }
  e2.exports = r2;
})), w = function(e2, r2) {
  if (e2 == null) return {};
  var t2, n2, o = {}, a2 = Object.keys(e2);
  for (n2 = 0; n2 < a2.length; n2++) t2 = a2[n2], r2.indexOf(t2) >= 0 || (o[t2] = e2[t2]);
  return o;
}, O = function(e2, r2) {
  if (e2 == null) return {};
  var t2, n2, o = w(e2, r2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e2);
    for (n2 = 0; n2 < a2.length; n2++) t2 = a2[n2], r2.indexOf(t2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, t2) && (o[t2] = e2[t2]);
  }
  return o;
}, j = createContext(null);
function x(r2) {
  var t2 = r2.children, n2 = t2 === void 0 ? "" : t2, o = O(r2, ["children"]);
  return typeof n2 != "string" && (n2 = renderToString()), React__default.createElement("template", S({}, o, { dangerouslySetInnerHTML: { __html: n2 } }));
}
function z(e2) {
  var r2 = e2.root, t2 = e2.children;
  return createPortal(t2 === void 0 ? null : t2, r2);
}
function E(n2) {
  var i2 = forwardRef((function(o, i3) {
    var u, l, s2 = o.mode, f2 = s2 === void 0 ? "open" : s2, p2 = o.delegatesFocus, d2 = p2 !== void 0 && p2, y2 = o.styleSheets, h2 = y2 === void 0 ? [] : y2, v2 = o.ssr, m2 = v2 !== void 0 && v2, b2 = o.children, w2 = O(o, ["mode", "delegatesFocus", "styleSheets", "ssr", "children"]), E2 = (l = useRef((u = i3) && u.current), useEffect((function() {
      u && (u.current = l.current);
    }), [u]), l), T2 = useState(null), A = g(T2, 2), C2 = A[0], P2 = A[1], F = "node_".concat(f2).concat(d2);
    return useLayoutEffect((function() {
      if (E2.current) try {
        if (typeof i3 == "function" && i3(E2.current), m2) {
          var e2 = E2.current.shadowRoot;
          return void P2(e2);
        }
        var r2 = E2.current.attachShadow({ mode: f2, delegatesFocus: d2 });
        h2.length > 0 && (r2.adoptedStyleSheets = h2), P2(r2);
      } catch (e3) {
        (function(e4) {
          var r3 = e4.error, t2 = e4.styleSheets, n3 = e4.root;
          if (r3.name === "NotSupportedError")
            t2.length > 0 && (n3.adoptedStyleSheets = t2);
          else
            throw r3;
        })({ error: e3, styleSheets: h2, root: C2 });
      }
    }), [i3, E2, h2]), React__default.createElement(React__default.Fragment, null, React__default.createElement(n2.tag, S({ key: F, ref: E2 }, w2), (C2 || m2) && React__default.createElement(j.Provider, { value: C2 }, m2 ? React__default.createElement(x, { shadowroot: f2, shadowrootmode: f2 }, n2.render({ root: C2, ssr: m2, children: b2 })) : React__default.createElement(z, { root: C2 }, n2.render({ root: C2, ssr: m2, children: b2 })))));
  }));
  return i2.propTypes = { mode: s.oneOf(["open", "closed"]), delegatesFocus: s.bool, styleSheets: s.arrayOf(s.instanceOf(globalThis.CSSStyleSheet)), ssr: s.bool, children: s.node }, i2;
}
x.propTypes = { children: s.oneOfType([s.string, s.node]) }, z.propTypes = { root: s.object.isRequired, children: s.node };
var T = /* @__PURE__ */ new Map();
function C() {
  var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "core", t2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(e3) {
    return e3.children;
  };
  return new Proxy(e2, { get: function(e3, n2) {
    var o = d(n2, { separator: "-" }), a2 = "".concat(r2, "-").concat(o);
    return T.has(a2) || T.set(a2, E({ tag: o, render: t2 })), T.get(a2);
  } });
}
var P = C();
const Root$1 = P.div;
function useShadowRootStyle(instanceId, keepAspectRatio = !1) {
  if (keepAspectRatio === !1)
    return `
:where([data-likec4-instance="${instanceId}"]) {
  display: block;
  box-sizing: border-box;
  border: 0 solid transparent;
  background: transparent;
  padding: 0;
  margin: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
  min-width: 80px;
  min-height: 80px;
}
  `.trim();
  const { width, height } = keepAspectRatio, isLandscape = width > height;
  return `
:where([data-likec4-instance="${instanceId}"]) {
  display: block;
  box-sizing: border-box;
  border: 0 solid transparent;
  background: transparent;
  padding: 0;
  overflow: hidden;
  aspect-ratio: ${Math.ceil(width)} / ${Math.ceil(height)};
  ${isLandscape ? "" : `
  max-width: min(100%, var(--likec4-view-max-width, ${Math.ceil(width)}px));
  margin-left: auto;
  margin-right: auto;`}
  width: ${isLandscape ? "100%" : "auto"};
  height: ${isLandscape ? "auto" : "100%"};
  ${isLandscape ? "min-width: 80px;" : "min-height: 80px;"}
  max-height: min(100%, var(--likec4-view-max-height, ${Math.ceil(height)}px));
}
`.trim();
}
const ShadowRoot$1 = forwardRef(({
  children: children2,
  theme = DefaultTheme,
  injectFontCss = !0,
  styleNonce,
  colorScheme: explicitColorScheme,
  keepAspectRatio = !1,
  ...props
}, ref) => {
  const colorScheme = useColorScheme(explicitColorScheme), id2 = useId(), cssstyle = useShadowRootStyle(id2, keepAspectRatio), rootRef = useRef(null), styleSheets = useBundledStyleSheet(injectFontCss, styleNonce), getRootElement2 = useCallback(() => rootRef.current ?? void 0, [rootRef]), getStyleNonce = useCallbackRef(() => {
    if (e$b(styleNonce)) {
      if (typeof styleNonce == "string")
        return styleNonce;
      if (typeof styleNonce == "function")
        return styleNonce();
    }
    return "";
  });
  let nonce = e$b(styleNonce) ? getStyleNonce() : void 0;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "style",
      {
        type: "text/css",
        nonce,
        dangerouslySetInnerHTML: { __html: cssstyle }
      }
    ),
    /* @__PURE__ */ jsx(Root$1, { ssr: !1, ...props, styleSheets, "data-likec4-instance": id2, children: /* @__PURE__ */ jsx(
      "div",
      {
        ref: useMergedRef(rootRef, ref),
        "data-mantine-color-scheme": colorScheme,
        className: "likec4-shadow-root",
        children: /* @__PURE__ */ jsx(
          MantineProvider,
          {
            ...explicitColorScheme && { forceColorScheme: explicitColorScheme },
            defaultColorScheme: colorScheme,
            getRootElement: getRootElement2,
            ...!!nonce && { getStyleNonce },
            cssVariablesSelector: ".likec4-shadow-root",
            theme,
            children: /* @__PURE__ */ jsx(FramerMotionConfig, { children: children2 })
          }
        )
      }
    ) })
  ] });
});
ShadowRoot$1.displayName = "ShadowRoot";
const cssInteractive = css({
  cursor: "pointer",
  "--mantine-cursor-pointer": "pointer",
  "& :where(.likec4-diagram, .likec4-compound-node, .likec4-element-node)": {
    cursor: "pointer"
  }
});
function LikeC4View({
  viewId,
  className,
  pannable = !1,
  zoomable = !1,
  keepAspectRatio = !0,
  colorScheme,
  injectFontCss = !0,
  controls = !1,
  background = "transparent",
  browser = !0,
  showNavigationButtons = !1,
  enableNotations,
  enableFocusMode = !1,
  enableDynamicViewWalkthrough = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = enableRelationshipDetails,
  reduceGraphics = "auto",
  mantineTheme,
  styleNonce,
  style: style2,
  reactFlowProps,
  renderNodes,
  children: children2,
  ...props
}) {
  const rootRef = useRef(null), likec4model = useOptionalLikeC4Model(), [layoutType, setLayoutType] = useState("manual"), [browserViewId, _onNavigateTo] = useState(null), onNavigateTo = useCallbackRef((viewId2) => {
    viewId2 && viewId2 !== browserViewId && setLayoutType("manual"), _onNavigateTo(viewId2);
  }), onNavigateToThisView = useCallbackRef(() => {
    onNavigateTo(viewId);
  });
  if (!likec4model)
    return /* @__PURE__ */ jsx(ErrorMessage, { children: "LikeC4Model not found. Make sure you provided LikeC4ModelProvider." });
  const view = likec4model.findView(viewId)?.$layouted;
  if (!view)
    return /* @__PURE__ */ jsx(ViewNotFound, { viewId });
  if (view._stage !== "layouted")
    return /* @__PURE__ */ jsxs(ErrorMessage, { children: [
      'LikeC4 View "$',
      viewId,
      '" is not layouted. Make sure you have LikeC4ModelProvider with layouted model.'
    ] });
  const browserViewModel = browserViewId ? likec4model.findView(browserViewId) : null, browserView = layoutType === "manual" ? browserViewModel?.$layouted : browserViewModel?.$view, hasNotations = !!enableNotations && (view.notation?.nodes?.length ?? 0) > 0, browserViewHasNotations = (browserView?.notation?.nodes?.length ?? 0) > 0, isBrowserEnabled = browser !== !1, browserProps = e$c(browser) ? {} : browser, bounds = pickViewBounds(view, props.dynamicViewVariant), root2 = rootRef.current ? { root: rootRef.current } : void 0;
  return /* @__PURE__ */ jsx(
    ShadowRoot$1,
    {
      ref: rootRef,
      injectFontCss,
      theme: mantineTheme,
      colorScheme,
      styleNonce,
      keepAspectRatio: keepAspectRatio ? bounds : !1,
      className: cx(
        "likec4-view",
        className
      ),
      style: style2,
      children: /* @__PURE__ */ jsxs(FramerMotionConfig, { children: [
        /* @__PURE__ */ jsx(
          LikeC4Diagram,
          {
            view,
            pannable,
            zoomable,
            background,
            fitView: !0,
            fitViewPadding: FitViewPaddings.default,
            enableNotations: hasNotations,
            enableDynamicViewWalkthrough,
            showNavigationButtons,
            enableCompareWithLatest: !1,
            enableFocusMode,
            enableRelationshipDetails,
            enableElementDetails,
            enableRelationshipBrowser,
            enableElementTags: !1,
            controls,
            reduceGraphics,
            className: cx(
              "likec4-static-view",
              isBrowserEnabled && cssInteractive
            ),
            enableSearch: !1,
            ...isBrowserEnabled && {
              onCanvasClick: onNavigateToThisView,
              onNodeClick: onNavigateToThisView
            },
            reactFlowProps,
            renderNodes,
            children: children2,
            ...props
          }
        ),
        /* @__PURE__ */ jsx(AnimatePresence, { ...root2, children: browserView && /* @__PURE__ */ jsxs(Overlay, { openDelay: 0, onClose: () => onNavigateTo(null), children: [
          /* @__PURE__ */ jsx(
            LikeC4Diagram,
            {
              view: browserView,
              pannable: !0,
              zoomable: !0,
              background: "dots",
              onNavigateTo,
              showNavigationButtons: !0,
              enableDynamicViewWalkthrough: !0,
              enableFocusMode: !0,
              enableRelationshipBrowser: !0,
              enableElementDetails: !0,
              enableRelationshipDetails: !0,
              enableSearch: !0,
              enableElementTags: !0,
              enableCompareWithLatest: !0,
              controls: !0,
              fitView: !0,
              ...props,
              fitViewPadding: FitViewPaddings.withControls,
              ...browserProps,
              enableNotations: browserViewHasNotations && (browserProps.enableNotations ?? !0),
              renderNodes,
              onLayoutTypeChange: setLayoutType
            }
          ),
          /* @__PURE__ */ jsx(Box, { pos: "absolute", top: "4", right: "4", zIndex: "999", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              variant: "default",
              color: "gray",
              onClick: (e2) => {
                e2.stopPropagation(), onNavigateTo(null);
              },
              children: /* @__PURE__ */ jsx(IconX, {})
            }
          ) })
        ] }) })
      ] })
    }
  );
}
function ReactLikeC4({
  viewId,
  className,
  colorScheme,
  injectFontCss = !0,
  enableNotations,
  keepAspectRatio,
  style: style2,
  mantineTheme,
  styleNonce,
  ...props
}) {
  const likec4model = useOptionalLikeC4Model();
  if (!likec4model)
    return /* @__PURE__ */ jsx(ErrorMessage, { children: "LikeC4Model not found. Make sure you provided LikeC4ModelProvider." });
  const view = likec4model.findView(viewId)?.$view;
  if (!view)
    return /* @__PURE__ */ jsx(ViewNotFound, { viewId });
  if (view._stage !== "layouted")
    return /* @__PURE__ */ jsxs(ErrorMessage, { children: [
      'LikeC4 View "$',
      viewId,
      '" is not layouted. Make sure you have LikeC4ModelProvider with layouted model.'
    ] });
  const bounds = pickViewBounds(view, props.dynamicViewVariant), hasNotations = !!enableNotations && (view.notation?.nodes?.length ?? 0) > 0;
  return /* @__PURE__ */ jsx(
    ShadowRoot$1,
    {
      injectFontCss,
      theme: mantineTheme,
      colorScheme,
      styleNonce,
      keepAspectRatio: keepAspectRatio ? bounds : !1,
      className: cx(
        "likec4-view",
        className
      ),
      style: style2,
      children: /* @__PURE__ */ jsx(
        LikeC4Diagram,
        {
          view,
          enableNotations: hasNotations,
          ...props
        }
      )
    }
  );
}
function layoutedProjectsViewToXYFlow(view) {
  return {
    xynodes: t$f(view.nodes, projectNodeToXY),
    xyedges: t$f(view.edges, projectEdgeToXY)
  };
}
function projectNodeToXY({ id: id2, x: x2, y: y2, width, height, ...node2 }) {
  return {
    id: id2,
    position: { x: x2, y: y2 },
    type: "project",
    initialWidth: width,
    initialHeight: height,
    draggable: !1,
    deletable: !1,
    zIndex: ZIndexes.Element,
    style: {
      width,
      height
    },
    data: {
      id: id2,
      width,
      height,
      ...node2
    }
  };
}
function projectEdgeToXY({ id: id2, source, target, ...edge }) {
  return {
    id: id2,
    source,
    target,
    type: "relationship",
    zIndex: ZIndexes.Edge,
    deletable: !1,
    data: {
      id: id2,
      technology: null,
      labelBBox: null,
      ...edge
    }
  };
}
const key = "likec4:projects-overview:lastViewport", ProjectsOverviewViewportPersistence = {
  read() {
    try {
      let fromStorage = sessionStorage.getItem(key);
      return fromStorage ? JSON.parse(fromStorage) : null;
    } catch (e2) {
      return console.error(`Error reading fromStorage ${key}:`, e2), null;
    }
  },
  write(viewport) {
    if (!viewport) {
      sessionStorage.removeItem(key);
      return;
    }
    sessionStorage.setItem(key, JSON.stringify(viewport));
  }
}, machine = setup({
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow && !!context2.xystore && !!context2.xyflow,
    "click: selected node": ({ event }) => (assertEvent(event, ["xyflow.click.node"]), event.node.selected === !0)
  }
}), updateView = () => machine.assign(({ event }) => {
  assertEvent(event, "update.view");
  const { xynodes, xyedges } = layoutedProjectsViewToXYFlow(event.view);
  return {
    view: event.view,
    xynodes,
    xyedges
  };
}), xyflowApplyNodeChanges = () => machine.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyNodeChanges"), {
  xynodes: applyNodeChanges(event.changes, context2.xynodes)
})), xyflowApplyEdgeChanges = () => machine.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyEdgeChanges"), {
  xyedges: applyEdgeChanges(event.changes, context2.xyedges)
})), onMouseEnterOrLeave = () => machine.assign(({ context: context2, event }) => {
  assertEvent(event, [
    "xyflow.mouse.enter.edge",
    "xyflow.mouse.leave.edge",
    "xyflow.mouse.enter.node",
    "xyflow.mouse.leave.node"
  ]);
  const isEnter = event.type.startsWith("xyflow.mouse.enter");
  switch (event.type) {
    case "xyflow.mouse.enter.edge":
    case "xyflow.mouse.leave.edge": {
      const edgeId = event.edge.id;
      return {
        xyedges: context2.xyedges.map((e2) => e2.id === edgeId ? Base.setHovered(e2, isEnter) : e2)
      };
    }
    case "xyflow.mouse.enter.node":
    case "xyflow.mouse.leave.node": {
      const nodeId = event.node.id;
      return {
        xynodes: context2.xynodes.map((n2) => n2.id === nodeId ? Base.setHovered(n2, isEnter) : n2)
      };
    }
    default:
      nonexhaustive(event);
  }
}), saveViewport = () => machine.createAction(({ context: context2 }) => {
  const xyflow2 = context2.xyflow;
  xyflow2 && ProjectsOverviewViewportPersistence.write(xyflow2.getViewport());
}), handleClick = () => machine.enqueueActions(({ event, enqueue }) => {
  if (event.type === "xyflow.click.double") {
    enqueue(cancelFitDiagram()), enqueue(raiseFitDiagram());
    return;
  }
  if (event.type === "xyflow.click.pane") {
    enqueue(cancelFitDiagram());
    return;
  }
  console.warn("Unknown event", event);
}), cancelFitDiagram = () => machine.cancel("fitDiagram"), raiseFitDiagram = (params) => {
  const { delay: delay2 = 30, ...rest } = {};
  return machine.raise(
    {
      type: "xyflow.fitDiagram",
      ...rest
    },
    {
      id: "fitDiagram",
      delay: delay2
    }
  );
}, fitDiagram = (params) => machine.enqueueActions(({ context: context2, event, enqueue }) => {
  enqueue(cancelFitDiagram());
  let bounds = context2.view.bounds, duration;
  params ? (bounds = params.bounds ?? context2.view.bounds, duration = params.duration) : event.type === "xyflow.fitDiagram" && (bounds = event.bounds ?? context2.view.bounds, duration = event.duration), duration ??= 450;
  const { width, height, panZoom, transform: transform2 } = nonNullable(context2.xystore).getState(), maxZoom = Math.max(1, transform2[2]), viewport = getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
  viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y);
  const animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport(viewport, animationProps).catch((err) => {
    console.error("Error during fitDiagram panZoom setViewport", { err });
  }), ProjectsOverviewViewportPersistence.write(null);
}), restoreViewport = () => machine.enqueueActions(({ context: context2, enqueue }) => {
  const viewport = ProjectsOverviewViewportPersistence.read();
  if (viewport) {
    nonNullable(context2.xyflow).setViewport(viewport, {
      duration: 0
    });
    return;
  }
  enqueue(fitDiagram({ duration: 0 }));
}), dispose = () => machine.assign({
  xyflow: null,
  xystore: null,
  initialized: {
    xyflow: !1,
    xydata: !1
  },
  xyedges: [],
  xynodes: []
}), assignNavigateTo = () => machine.assign(({ event, context: context2 }) => {
  let navigateTo;
  switch (event.type) {
    case "xyflow.click.node": {
      navigateTo = event.node;
      break;
    }
    case "navigate.to": {
      navigateTo = nonNullable(context2.xynodes.find((n2) => n2.id === event.fromNode), `Node ${event.fromNode} not found`);
      break;
    }
    default:
      return console.warn(`Unexpected event ${event.type} in assignNavigateTo`), {};
  }
  return {
    navigateTo
  };
}), _projectOverviewLogic = machine.createMachine({
  id: "projects-overview",
  context: ({ input: input2 }) => ({
    ...input2,
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    xyflow: null,
    xystore: null,
    xynodes: [],
    xyedges: []
  }),
  initial: "init",
  on: {
    close: {
      target: ".closed"
    }
  },
  states: {
    init: {
      on: {
        "update.view": {
          actions: [
            updateView(),
            xstateActions_cjsExports.assign(({ context: context2 }) => ({
              initialized: {
                ...context2.initialized,
                xydata: !0
              }
            }))
          ],
          target: "isReady"
        },
        "xyflow.init": {
          actions: [
            xstateActions_cjsExports.assign(({ context: context2, event }) => ({
              initialized: {
                ...context2.initialized,
                xyflow: !0
              },
              xyflow: event.xyflow,
              xystore: event.xystore
            }))
          ],
          target: "isReady"
        }
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        target: "active"
      }, {
        target: "init"
      }]
    },
    active: {
      tags: "active",
      entry: [
        restoreViewport()
      ],
      on: {
        "navigate.to": {
          actions: assignNavigateTo(),
          target: "navigate"
        },
        "xyflow.applyNodeChanges": {
          actions: xyflowApplyNodeChanges()
        },
        "xyflow.applyEdgeChanges": {
          actions: xyflowApplyEdgeChanges()
        },
        "xyflow.mouse.*": {
          actions: onMouseEnterOrLeave()
        },
        "xyflow.click.node": [
          {
            guard: "click: selected node",
            actions: assignNavigateTo(),
            target: "navigate"
          }
        ],
        "xyflow.click.*": {
          actions: handleClick()
        },
        "xyflow.fitDiagram": {
          actions: fitDiagram()
        },
        "update.view": {
          actions: updateView()
        }
      }
    },
    navigate: {
      tags: "active",
      entry: [
        cancelFitDiagram(),
        saveViewport(),
        xstateActions_cjsExports.assign({
          xyedges: []
        }),
        ({ context: { navigateTo, xyflow: xyflow2, xystore }, self: self2 }) => {
          invariant$2(xyflow2 && navigateTo, "Invalid state, xyflow is undefined");
          const { width, domNode } = nonNullable(xystore).getState(), nextZoom = t$v(
            Math.min(
              width * 2 / 3 / navigateTo.data.width
              // (height - 200) / (navigateTo.data.height),
            ),
            { min: MinZoom, max: 2.5 }
          ), next = {
            x: Math.round(
              -nextZoom * navigateTo.position.x + (width - nextZoom * navigateTo.data.width) / 2
            ),
            y: Math.round(-nextZoom * navigateTo.position.y) + 50
          }, current2 = xyflow2.getViewport(), otherNodes = domNode.querySelectorAll(
            `.react-flow__node-project:not([data-id="${navigateTo.id}"]) > *`
          ), otherNodesAnimation = animate(otherNodes, {
            opacity: 0,
            scale: 0.9
          }, {
            visualDuration: 0.25,
            delay: stagger(0.08, { from: "center" })
          }), v2 = motionValue(1), transform2 = mapValue(
            v2,
            [1, 0],
            [
              `translate(${current2.x}px, ${current2.y}px) scale(${current2.zoom})`,
              `translate(${next.x}px, ${next.y}px) scale(${nextZoom})`
            ]
          ), cancelViewportAnimation = styleEffect(
            domNode.querySelector(".xyflow__viewport"),
            { transform: transform2 }
          ), cancelOpacityAnimation = styleEffect(
            domNode.querySelector(`.react-flow__node-project:is([data-id="${navigateTo.id}"]) > *`),
            { opacity: v2 }
          ), targetAnimation = animate(
            v2,
            0,
            {
              delay: otherNodes.length > 3 ? 0.25 : 0,
              type: "spring",
              stiffness: 350,
              damping: 40,
              mass: 1.5,
              visualDuration: 0.55
            }
          );
          Promise.race([
            targetAnimation.finished,
            sleep(750)
          ]).then(() => {
            cancelViewportAnimation(), cancelOpacityAnimation(), targetAnimation.stop(), otherNodesAnimation.stop(), self2.send({
              type: "emit.navigate.to",
              projectId: navigateTo.data.projectId
            });
          });
        }
      ],
      on: {
        "emit.navigate.to": {
          actions: xstateActions_cjsExports.emit(({ event }) => ({
            ...event,
            type: "navigate.to"
          }))
        }
      }
    },
    closed: {
      id: "closed",
      type: "final",
      entry: dispose()
    }
  }
}), projectOverviewLogic = _projectOverviewLogic;
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const ProjectsOverviewActorContext = createContext(null);
function useProjectsOverviewActor() {
  return nonNullable(useContext(ProjectsOverviewActorContext), "No ProjectsOverviewActorContext");
}
const { withProvider, withContext } = createStyleContext(navigationPanel), shouldForwardProp = (prop, variantKeys) => isValidMotionProp(prop) || !variantKeys.includes(prop) && !isCssProperty(prop), LogoButton = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxs(
  "button",
  {
    ...props,
    ref,
    className: cx(
      "mantine-active",
      className
    ),
    children: [
      /* @__PURE__ */ jsx("div", {}),
      /* @__PURE__ */ jsx(
        Logo$1,
        {
          className: css({
            display: {
              base: "none",
              "@/md": "block"
            }
          })
        }
      ),
      /* @__PURE__ */ jsx(
        Logo$1,
        {
          className: css({
            display: {
              base: "block",
              "@/md": "none"
            }
          })
        }
      )
    ]
  }
)), Root = withProvider(MotionDiv, "root", {
  shouldForwardProp
}), Body = withContext(MotionDiv, "body", {
  shouldForwardProp
}), Logo = withContext(LogoButton, "logo"), Label = withContext(MotionDiv, "label", {
  shouldForwardProp
});
withContext(MotionDiv, "dropdown", {
  shouldForwardProp
});
const NavigationPanel = {
  Root,
  Body,
  Logo,
  Label
}, ProjectsOverviewPanel = () => /* @__PURE__ */ jsx(NavigationPanel.Root, { size: "lg", children: /* @__PURE__ */ jsxs(NavigationPanel.Body, { children: [
  /* @__PURE__ */ jsx(NavigationPanel.Logo, {}),
  /* @__PURE__ */ jsx(NavigationPanel.Label, { children: "Projects Overview" })
] }) });
function useProjectsOverviewState(selector3, compare2 = shallowEqual$1) {
  const actor = useProjectsOverviewActor();
  return useSelector(actor, selector3, compare2);
}
function useProjectsOverviewXYStoreApi() {
  return useStoreApi();
}
const RelationshipEdge = memoEdge((edgeProps) => {
  const path = bezierPath(edgeProps.data.points);
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...edgeProps, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps,
        svgPath: path
      }
    ),
    /* @__PURE__ */ jsx(EdgeLabelContainer, { edgeProps, children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps }) })
  ] });
});
function ProjectNode(props) {
  const actor = useProjectsOverviewActor(), navigateTo = useCallbackRef$1((e2) => {
    e2.stopPropagation(), actor.send({ type: "navigate.to", fromNode: props.data.id, projectId: props.data.projectId });
  });
  return /* @__PURE__ */ jsxs(
    ElementNodeContainer,
    {
      layout: !0,
      nodeProps: props,
      children: [
        /* @__PURE__ */ jsx(ElementShape, { ...props }),
        /* @__PURE__ */ jsx(ElementData, { ...props }),
        /* @__PURE__ */ jsx(
          ElementActionButtons,
          {
            ...props,
            buttons: [
              {
                key: "navigate",
                icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
                onClick: navigateTo
              }
            ]
          }
        ),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    },
    props.id
  );
}
const nodeTypes = {
  project: ProjectNode
}, edgeTypes = {
  relationship: RelationshipEdge
}, selector = (state) => ({
  isActive: state.hasTag("active"),
  nodes: state.context.xynodes,
  edges: state.context.xyedges
}), selectorEq = (a2, b2) => a2.isActive === b2.isActive && shallowEqual$1(a2.nodes, b2.nodes) && shallowEqual$1(a2.edges, b2.edges), ProjectsOverviewXY = memo$3(({
  background = "dots",
  ...props
}) => {
  const actorRef = useProjectsOverviewActor(), {
    isActive,
    nodes,
    edges
  } = useProjectsOverviewState(
    selector,
    selectorEq
  ), xystore = useProjectsOverviewXYStoreApi();
  return /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      nodes,
      edges,
      className: cx(
        isActive ? "initialized" : "not-initialized",
        "projects-overview"
      ),
      nodeTypes,
      edgeTypes,
      fitView: !1,
      onNodeClick: useCallbackRef((_e, node2) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.node", node: node2 });
      }),
      onEdgeClick: useCallbackRef((_e, edge) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.edge", edge });
      }),
      onPaneClick: useCallbackRef((_e) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.pane" });
      }),
      onDoubleClick: useCallbackRef((_e) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.double" });
      }),
      onNodesChange: useCallbackRef((changes) => {
        actorRef.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        actorRef.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      onEdgeMouseEnter: useCallbackRef((event, edge) => {
        actorRef.send({ type: "xyflow.mouse.enter.edge", edge, event });
      }),
      onEdgeMouseLeave: useCallbackRef((event, edge) => {
        actorRef.send({ type: "xyflow.mouse.leave.edge", edge, event });
      }),
      onNodeMouseEnter: useCallbackRef((event, node2) => {
        actorRef.send({ type: "xyflow.mouse.enter.node", node: node2 });
      }),
      onNodeMouseLeave: useCallbackRef((event, node2) => {
        actorRef.send({ type: "xyflow.mouse.leave.node", node: node2 });
      }),
      onInit: useCallbackRef((xyflow2) => {
        actorRef.send({ type: "xyflow.init", xyflow: xyflow2, xystore });
      }),
      nodesDraggable: !1,
      nodesSelectable: !0,
      pannable: !0,
      zoomable: !0,
      background,
      ...props
    }
  );
});
ProjectsOverviewXY.displayName = "ProjectsOverviewXY";
function ProjectsOverview({
  view,
  onNavigateToProject,
  fitViewPadding = {
    top: "50px",
    bottom: "32px",
    left: "32px",
    right: "32px"
  },
  ...props
}) {
  const actorRef = useActorRef(
    projectOverviewLogic,
    {
      input: { view, fitViewPadding }
    }
  );
  useEffect(() => {
    actorRef.send({ type: "update.view", view });
  }, [actorRef, view]);
  const onNavigateToProjectRef = useSyncedRef(onNavigateToProject);
  useEffect(() => {
    const subs = [
      actorRef.on("navigate.to", ({ projectId }) => {
        onNavigateToProjectRef.current?.(projectId);
      })
    ];
    return () => {
      subs.forEach((sub) => sub.unsubscribe());
    };
  }, [actorRef]);
  const bounds = view.bounds, initialRef = useRef({
    initialNodes: [],
    initialEdges: [],
    initialWidth: bounds.width,
    initialHeight: bounds.height,
    fitView: !1
  });
  return /* @__PURE__ */ jsx(ProjectsOverviewActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsxs(ReactFlowProvider, { ...initialRef.current, children: [
    /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsx(ProjectsOverviewXY, { ...props }) }),
    /* @__PURE__ */ jsx(ProjectsOverviewPanel, {})
  ] }) });
}
function LikeC4ProjectsOverview({
  view,
  className,
  onNavigateToProject,
  ...props
}) {
  const onChangeLikeC4Project = useChangeLikeC4Project(), id2 = useId();
  return onNavigateToProject ??= onChangeLikeC4Project, /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsxs(FramerMotionConfig, { children: [
    /* @__PURE__ */ jsx(LikeC4Styles, { id: id2 }),
    /* @__PURE__ */ jsx(RootContainer, { id: id2, className, children: /* @__PURE__ */ jsx(
      ProjectsOverview,
      {
        view,
        onNavigateToProject,
        ...props
      }
    ) })
  ] }) });
}
function customDiagramNode(Node2) {
  return ((props) => {
    const viewId = props.data.viewId, viewModel = useLikeC4Model().findView(viewId);
    if (!viewModel)
      return console.error(`View "${viewId}" not found, requested by customNode "${props.data.id}"`, { props }), null;
    const model = viewModel.findNode(props.data.id);
    return model ? /* @__PURE__ */ jsx(Node2, { nodeProps: props, nodeModel: model }) : (console.error(
      `Node "${props.id}" not found in view "${viewId}", requested by customNode "${props.data.id}"`,
      { props }
    ), null);
  });
}
function elementNode(component) {
  return customDiagramNode(component);
}
function deploymentNode(component) {
  return customDiagramNode(component);
}
function compoundElementNode(component) {
  return customDiagramNode(component);
}
function compoundDeploymentNode(component) {
  return customDiagramNode(component);
}
function viewGroupNode(component) {
  return customDiagramNode(component);
}
function sequenceActorNode(component) {
  return customDiagramNode(component);
}
function useSetState(initialState2) {
  const [state, _setState] = useState(initialState2), setState = useCallback(
    (statePartial) => _setState((current2) => {
      const next = {
        ...current2,
        ...typeof statePartial == "function" ? statePartial(current2) : statePartial
      };
      return shallowEqual$1(current2, next) ? current2 : next;
    }),
    []
  );
  return [state, setState];
}
const MiniMap = MiniMap$1, xyflow = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ControlButton,
  Controls,
  MiniMap,
  MiniMapNode,
  NodeToolbar,
  Panel,
  get Position() {
    return Position;
  },
  ViewportPortal
}, Symbol.toStringTag, { value: "Module" }));
export {
  Base,
  CompoundActionButton,
  CompoundActions,
  CompoundDeploymentNode,
  CompoundDeploymentToolbar,
  CompoundDetailsButton,
  CompoundDetailsButtonWithHandler,
  CompoundElementNode,
  CompoundElementToolbar,
  CompoundNodeContainer,
  CompoundTitle,
  DefaultHandles,
  DeploymentElementActions,
  DeploymentElementToolbar,
  DeploymentNode,
  ElementActionButtons,
  ElementActions,
  ElementData,
  ElementDetailsButton,
  ElementDetailsButtonWithHandler,
  ElementNode,
  ElementNodeContainer,
  ElementShape,
  ElementTag,
  ElementTags,
  ElementToolbar,
  FramerMotionConfig,
  IconRendererProvider,
  IfEnabled,
  IfNotEnabled,
  IfNotReadOnly,
  IfReadOnly,
  LikeC4Diagram,
  LikeC4EditorProvider,
  LikeC4ModelProvider,
  LikeC4ProjectsOverview,
  LikeC4ProjectsProvider,
  LikeC4View,
  Markdown,
  Overlay,
  PortalToContainer,
  ReactLikeC4,
  SequenceActorNode,
  SequenceParallelArea,
  ShadowRoot$1 as ShadowRoot,
  StaticLikeC4Diagram,
  Toolbar,
  ViewGroupNode,
  xyflow as XYFlow,
  compoundDeploymentNode,
  compoundElementNode,
  deploymentNode,
  elementNode,
  memoEdge,
  memoNode,
  pickViewBounds,
  sequenceActorNode,
  useChangeLikeC4Project,
  useCurrentView,
  useCurrentViewId,
  useCurrentViewModel,
  useDiagram,
  useDiagramActorRef,
  useDiagramContext,
  useDiagramEventHandlers,
  useEnabledFeatures,
  useHasProjects,
  useLikeC4Model,
  useLikeC4Project,
  useLikeC4ProjectId,
  useLikeC4Projects,
  useLikeC4ProjectsContext,
  useLikeC4Specification,
  useLikeC4Styles,
  useLikeC4ViewModel,
  useOnDiagramEvent,
  useSetState,
  useUpdateEffect,
  viewGroupNode
};
