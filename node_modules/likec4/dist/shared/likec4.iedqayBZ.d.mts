import * as _likec4_core from '@likec4/core';
import { Fqn, EdgeId, AnyAux, aux, ComputedView, LikeC4Styles, DiagramView, ProjectId, NonEmptyArray, NonEmptyReadonlyArray, UnknownParsed, UnknownComputed, ViewId, ViewChange, RelationId, DeploymentFqn, LayoutedView, LayoutType, UnknownLayouted } from '@likec4/core';
import { ComputedProjectsView, LayoutedProjectsView } from '@likec4/core/compute-view';
import * as type_fest from 'type-fest';
import { Tagged, ValueOf as ValueOf$1, ConditionalPick, Writable, Simplify, MergeExclusive } from 'type-fest';
import { U as URI$1, L as LikeC4ProjectConfig, I as IncludeConfig, a as LikeC4ProjectConfigInput } from './likec4.DqDU0qex.mjs';
import { LikeC4Model } from '@likec4/core/model';
import { ProjectId as ProjectId$1, scalar, Fqn as Fqn$1 } from '@likec4/core/types';
import picomatch from '/home/runner/work/likec4/likec4/node_modules/.pnpm/@types+picomatch@4.0.2/node_modules/@types/picomatch/index.d.ts';
import { MultiMap as MultiMap$1, DefaultWeakMap } from '@likec4/core/utils';

/**
 * A tagging type for string properties that are actually document URIs.
 */
type DocumentUri$1 = string;
declare namespace DocumentUri$1 {
    function is(value: any): value is DocumentUri$1;
}
/**
 * A tagging type for string properties that are actually URIs
 *
 * @since 3.16.0
 */
type URI = string;
declare namespace URI {
    function is(value: any): value is URI;
}
/**
 * Defines an integer in the range of -2^31 to 2^31 - 1.
 */
type integer = number;
declare namespace integer {
    const MIN_VALUE = -2147483648;
    const MAX_VALUE = 2147483647;
    function is(value: any): value is integer;
}
/**
 * Defines an unsigned integer in the range of 0 to 2^31 - 1.
 */
type uinteger = number;
declare namespace uinteger {
    const MIN_VALUE = 0;
    const MAX_VALUE = 2147483647;
    function is(value: any): value is uinteger;
}
/**
 * Defines a decimal number. Since decimal numbers are very
 * rare in the language server specification we denote the
 * exact range with every decimal using the mathematics
 * interval notations (e.g. [0, 1] denotes all decimals d with
 * 0 <= d <= 1.
 */
type decimal = number;
/**
 * The LSP any type.
 *
 * In the current implementation we map LSPAny to any. This is due to the fact
 * that the TypeScript compilers can't infer string access signatures for
 * interface correctly (it can though for types). See the following issue for
 * details: https://github.com/microsoft/TypeScript/issues/15300.
 *
 * When the issue is addressed LSPAny can be defined as follows:
 *
 * ```ts
 * export type LSPAny = LSPObject | LSPArray | string | integer | uinteger | decimal | boolean | null | undefined;
 * export type LSPObject = { [key: string]: LSPAny };
 * export type LSPArray = LSPAny[];
 * ```
 *
 * Please note that strictly speaking a property with the value `undefined`
 * can't be converted into JSON preserving the property name. However for
 * convenience it is allowed and assumed that all these properties are
 * optional as well.
 *
 * @since 3.17.0
 */
type LSPAny = any;
type LSPObject = object;
/**
 * Position in a text document expressed as zero-based line and character
 * offset. Prior to 3.17 the offsets were always based on a UTF-16 string
 * representation. So a string of the form `að€b` the character offset of the
 * character `a` is 0, the character offset of `ð€` is 1 and the character
 * offset of b is 3 since `ð€` is represented using two code units in UTF-16.
 * Since 3.17 clients and servers can agree on a different string encoding
 * representation (e.g. UTF-8). The client announces it's supported encoding
 * via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
 * The value is an array of position encodings the client supports, with
 * decreasing preference (e.g. the encoding at index `0` is the most preferred
 * one). To stay backwards compatible the only mandatory encoding is UTF-16
 * represented via the string `utf-16`. The server can pick one of the
 * encodings offered by the client and signals that encoding back to the
 * client via the initialize result's property
 * [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
 * `utf-16` is missing from the client's capability `general.positionEncodings`
 * servers can safely assume that the client supports UTF-16. If the server
 * omits the position encoding in its initialize result the encoding defaults
 * to the string value `utf-16`. Implementation considerations: since the
 * conversion from one encoding into another requires the content of the
 * file / line the conversion is best done where the file is read which is
 * usually on the server side.
 *
 * Positions are line end character agnostic. So you can not specify a position
 * that denotes `\r|\n` or `\n|` where `|` represents the character offset.
 *
 * @since 3.17.0 - support for negotiated position encoding.
 */
interface Position$1 {
    /**
     * Line position in a document (zero-based).
     *
     * If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     */
    line: uinteger;
    /**
     * Character offset on a line in a document (zero-based).
     *
     * The meaning of this offset is determined by the negotiated
     * `PositionEncodingKind`.
     *
     * If the character value is greater than the line length it defaults back to the
     * line length.
     */
    character: uinteger;
}
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
declare namespace Position$1 {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line: uinteger, character: uinteger): Position$1;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value: any): value is Position$1;
}
/**
 * A range in a text document expressed as (zero-based) start and end positions.
 *
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
interface Range$1 {
    /**
     * The range's start position.
     */
    start: Position$1;
    /**
     * The range's end position.
     */
    end: Position$1;
}
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
declare namespace Range$1 {
    /**
     * Create a new Range literal.
     * @param start The range's start position.
     * @param end The range's end position.
     */
    function create(start: Position$1, end: Position$1): Range$1;
    /**
     * Create a new Range literal.
     * @param startLine The start line number.
     * @param startCharacter The start character.
     * @param endLine The end line number.
     * @param endCharacter The end character.
     */
    function create(startLine: uinteger, startCharacter: uinteger, endLine: uinteger, endCharacter: uinteger): Range$1;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value: any): value is Range$1;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    uri: DocumentUri$1;
    range: Range$1;
}
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
declare namespace Location {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri: DocumentUri$1, range: Range$1): Location;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value: any): value is Location;
}
/**
     * Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
     * including an origin range.
 */
interface LocationLink {
    /**
     * Span of the origin of this link.
     *
     * Used as the underlined span for mouse interaction. Defaults to the word range at
     * the definition position.
     */
    originSelectionRange?: Range$1;
    /**
     * The target resource identifier of this link.
     */
    targetUri: DocumentUri$1;
    /**
     * The full target range of this link. If the target for example is a symbol then target range is the
     * range enclosing this symbol not including leading/trailing whitespace but everything else
     * like comments. This information is typically used to highlight the range in the editor.
     */
    targetRange: Range$1;
    /**
     * The range that should be selected and revealed when this link is being followed, e.g the name of a function.
     * Must be contained by the `targetRange`. See also `DocumentSymbol#range`
     */
    targetSelectionRange: Range$1;
}
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
declare namespace LocationLink {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri: DocumentUri$1, targetRange: Range$1, targetSelectionRange: Range$1, originSelectionRange?: Range$1): LocationLink;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value: any): value is LocationLink;
}
/**
 * Represents a color in RGBA space.
 */
interface Color {
    /**
     * The red component of this color in the range [0-1].
     */
    readonly red: decimal;
    /**
     * The green component of this color in the range [0-1].
     */
    readonly green: decimal;
    /**
     * The blue component of this color in the range [0-1].
     */
    readonly blue: decimal;
    /**
     * The alpha component of this color in the range [0-1].
     */
    readonly alpha: decimal;
}
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
declare namespace Color {
    /**
     * Creates a new Color literal.
     */
    function create(red: decimal, green: decimal, blue: decimal, alpha: decimal): Color;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value: any): value is Color;
}
/**
 * Represents a color range from a document.
 */
interface ColorInformation {
    /**
     * The range in the document where this color appears.
     */
    range: Range$1;
    /**
     * The actual color value for this color range.
     */
    color: Color;
}
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
declare namespace ColorInformation {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range: Range$1, color: Color): ColorInformation;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value: any): value is ColorInformation;
}
interface ColorPresentation {
    /**
     * The label of this color presentation. It will be shown on the color
     * picker header. By default this is also the text that is inserted when selecting
     * this color presentation.
     */
    label: string;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
     * is used.
     */
    textEdit?: TextEdit$1;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
     */
    additionalTextEdits?: TextEdit$1[];
}
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
declare namespace ColorPresentation {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label: string, textEdit?: TextEdit$1, additionalTextEdits?: TextEdit$1[]): ColorPresentation;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value: any): value is ColorPresentation;
}
/**
 * A set of predefined range kinds.
 */
declare namespace FoldingRangeKind {
    /**
     * Folding range for a comment
     */
    const Comment = "comment";
    /**
     * Folding range for an import or include
     */
    const Imports = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    const Region = "region";
}
/**
 * A predefined folding range kind.
 *
 * The type is a string since the value set is extensible
 */
type FoldingRangeKind = string;
/**
 * Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
 * than the number of lines in the document. Clients are free to ignore invalid ranges.
 */
interface FoldingRange {
    /**
     * The zero-based start line of the range to fold. The folded area starts after the line's last character.
     * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
     */
    startLine: uinteger;
    /**
     * The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
     */
    startCharacter?: uinteger;
    /**
     * The zero-based end line of the range to fold. The folded area ends with the line's last character.
     * To be valid, the end must be zero or larger and smaller than the number of lines in the document.
     */
    endLine: uinteger;
    /**
     * The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
     */
    endCharacter?: uinteger;
    /**
     * Describes the kind of the folding range such as `comment' or 'region'. The kind
     * is used to categorize folding ranges and used by commands like 'Fold all comments'.
     * See {@link FoldingRangeKind} for an enumeration of standardized kinds.
     */
    kind?: FoldingRangeKind;
    /**
     * The text that the client should show when the specified range is
     * collapsed. If not defined or not supported by the client, a default
     * will be chosen by the client.
     *
     * @since 3.17.0
     */
    collapsedText?: string;
}
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
declare namespace FoldingRange {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine: uinteger, endLine: uinteger, startCharacter?: uinteger, endCharacter?: uinteger, kind?: FoldingRangeKind, collapsedText?: string): FoldingRange;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value: any): value is FoldingRange;
}
/**
 * Represents a related message and source code location for a diagnostic. This should be
 * used to point to code locations that cause or related to a diagnostics, e.g when duplicating
 * a symbol in a scope.
 */
interface DiagnosticRelatedInformation {
    /**
     * The location of this related diagnostic information.
     */
    location: Location;
    /**
     * The message of this related diagnostic information.
     */
    message: string;
}
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
declare namespace DiagnosticRelatedInformation {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location: Location, message: string): DiagnosticRelatedInformation;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value: any): value is DiagnosticRelatedInformation;
}
/**
 * The diagnostic's severity.
 */
declare namespace DiagnosticSeverity {
    /**
     * Reports an error.
     */
    const Error: 1;
    /**
     * Reports a warning.
     */
    const Warning: 2;
    /**
     * Reports an information.
     */
    const Information: 3;
    /**
     * Reports a hint.
     */
    const Hint: 4;
}
type DiagnosticSeverity = 1 | 2 | 3 | 4;
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
declare namespace DiagnosticTag {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    const Unnecessary: 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    const Deprecated: 2;
}
type DiagnosticTag = 1 | 2;
/**
 * Structure to capture a description for an error code.
 *
 * @since 3.16.0
 */
interface CodeDescription {
    /**
     * An URI to open with more information about the diagnostic error.
     */
    href: URI;
}
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
declare namespace CodeDescription {
    function is(value: any): value is CodeDescription;
}
/**
 * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
 * are only valid in the scope of a resource.
 */
interface Diagnostic {
    /**
     * The range at which the message applies
     */
    range: Range$1;
    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverity;
    /**
     * The diagnostic's code, which usually appear in the user interface.
     */
    code?: integer | string;
    /**
     * An optional property to describe the error code.
     * Requires the code field (above) to be present/not null.
     *
     * @since 3.16.0
     */
    codeDescription?: CodeDescription;
    /**
     * A human-readable string describing the source of this
     * diagnostic, e.g. 'typescript' or 'super lint'. It usually
     * appears in the user interface.
     */
    source?: string;
    /**
     * The diagnostic's message. It usually appears in the user interface
     */
    message: string;
    /**
     * Additional metadata about the diagnostic.
     *
     * @since 3.15.0
     */
    tags?: DiagnosticTag[];
    /**
     * An array of related diagnostic information, e.g. when symbol-names within
     * a scope collide all definitions can be marked via this property.
     */
    relatedInformation?: DiagnosticRelatedInformation[];
    /**
     * A data entry field that is preserved between a `textDocument/publishDiagnostics`
     * notification and `textDocument/codeAction` request.
     *
     * @since 3.16.0
     */
    data?: LSPAny;
}
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
declare namespace Diagnostic {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range: Range$1, message: string, severity?: DiagnosticSeverity, code?: integer | string, source?: string, relatedInformation?: DiagnosticRelatedInformation[]): Diagnostic;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value: any): value is Diagnostic;
}
/**
 * Represents a reference to a command. Provides a title which
 * will be used to represent a command in the UI and, optionally,
 * an array of arguments which will be passed to the command handler
 * function when invoked.
 */
interface Command {
    /**
     * Title of the command, like `save`.
     */
    title: string;
    /**
     * The identifier of the actual command handler.
     */
    command: string;
    /**
     * Arguments that the command handler should be
     * invoked with.
     */
    arguments?: LSPAny[];
}
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
declare namespace Command {
    /**
     * Creates a new Command literal.
     */
    function create(title: string, command: string, ...args: any[]): Command;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value: any): value is Command;
}
/**
 * A text edit applicable to a text document.
 */
interface TextEdit$1 {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: Range$1;
    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
}
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
declare namespace TextEdit$1 {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range: Range$1, newText: string): TextEdit$1;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position: Position$1, newText: string): TextEdit$1;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range: Range$1): TextEdit$1;
    function is(value: any): value is TextEdit$1;
}
/**
 * Additional information that describes document changes.
 *
 * @since 3.16.0
 */
interface ChangeAnnotation {
    /**
     * A human-readable string describing the actual change. The string
     * is rendered prominent in the user interface.
     */
    label: string;
    /**
     * A flag which indicates that user confirmation is needed
     * before applying the change.
     */
    needsConfirmation?: boolean;
    /**
     * A human-readable string which is rendered less prominent in
     * the user interface.
     */
    description?: string;
}
declare namespace ChangeAnnotation {
    function create(label: string, needsConfirmation?: boolean, description?: string): ChangeAnnotation;
    function is(value: any): value is ChangeAnnotation;
}
declare namespace ChangeAnnotationIdentifier {
    function is(value: any): value is ChangeAnnotationIdentifier;
}
/**
 * An identifier to refer to a change annotation stored with a workspace edit.
 */
type ChangeAnnotationIdentifier = string;
/**
 * A special text edit with an additional change annotation.
 *
 * @since 3.16.0.
 */
interface AnnotatedTextEdit extends TextEdit$1 {
    /**
     * The actual identifier of the change annotation
     */
    annotationId: ChangeAnnotationIdentifier;
}
declare namespace AnnotatedTextEdit {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range: Range$1, newText: string, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position: Position$1, newText: string, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range: Range$1, annotation: ChangeAnnotationIdentifier): AnnotatedTextEdit;
    function is(value: any): value is AnnotatedTextEdit;
}
/**
 * Describes textual changes on a text document. A TextDocumentEdit describes all changes
 * on a document version Si and after they are applied move the document to version Si+1.
 * So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
 * kind of ordering. However the edits must be non overlapping.
 */
interface TextDocumentEdit {
    /**
     * The text document to change.
     */
    textDocument: OptionalVersionedTextDocumentIdentifier;
    /**
     * The edits to be applied.
     *
     * @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
     * client capability.
     */
    edits: (TextEdit$1 | AnnotatedTextEdit)[];
}
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
declare namespace TextDocumentEdit {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument: OptionalVersionedTextDocumentIdentifier, edits: (TextEdit$1 | AnnotatedTextEdit)[]): TextDocumentEdit;
    function is(value: any): value is TextDocumentEdit;
}
/**
 * A generic resource operation.
 */
interface ResourceOperation {
    /**
     * The resource operation kind.
     */
    kind: string;
    /**
     * An optional annotation identifier describing the operation.
     *
     * @since 3.16.0
     */
    annotationId?: ChangeAnnotationIdentifier;
}
/**
 * Options to create a file.
 */
interface CreateFileOptions {
    /**
     * Overwrite existing file. Overwrite wins over `ignoreIfExists`
     */
    overwrite?: boolean;
    /**
     * Ignore if exists.
     */
    ignoreIfExists?: boolean;
}
/**
 * Create file operation.
 */
interface CreateFile extends ResourceOperation {
    /**
     * A create
     */
    kind: 'create';
    /**
     * The resource to create.
     */
    uri: DocumentUri$1;
    /**
     * Additional options
     */
    options?: CreateFileOptions;
}
declare namespace CreateFile {
    function create(uri: DocumentUri$1, options?: CreateFileOptions, annotation?: ChangeAnnotationIdentifier): CreateFile;
    function is(value: any): value is CreateFile;
}
/**
 * Rename file options
 */
interface RenameFileOptions {
    /**
     * Overwrite target if existing. Overwrite wins over `ignoreIfExists`
     */
    overwrite?: boolean;
    /**
     * Ignores if target exists.
     */
    ignoreIfExists?: boolean;
}
/**
 * Rename file operation
 */
interface RenameFile extends ResourceOperation {
    /**
     * A rename
     */
    kind: 'rename';
    /**
     * The old (existing) location.
     */
    oldUri: DocumentUri$1;
    /**
     * The new location.
     */
    newUri: DocumentUri$1;
    /**
     * Rename options.
     */
    options?: RenameFileOptions;
}
declare namespace RenameFile {
    function create(oldUri: DocumentUri$1, newUri: DocumentUri$1, options?: RenameFileOptions, annotation?: ChangeAnnotationIdentifier): RenameFile;
    function is(value: any): value is RenameFile;
}
/**
 * Delete file options
 */
interface DeleteFileOptions {
    /**
     * Delete the content recursively if a folder is denoted.
     */
    recursive?: boolean;
    /**
     * Ignore the operation if the file doesn't exist.
     */
    ignoreIfNotExists?: boolean;
}
/**
 * Delete file operation
 */
interface DeleteFile extends ResourceOperation {
    /**
     * A delete
     */
    kind: 'delete';
    /**
     * The file to delete.
     */
    uri: DocumentUri$1;
    /**
     * Delete options.
     */
    options?: DeleteFileOptions;
}
declare namespace DeleteFile {
    function create(uri: DocumentUri$1, options?: DeleteFileOptions, annotation?: ChangeAnnotationIdentifier): DeleteFile;
    function is(value: any): value is DeleteFile;
}
/**
 * A workspace edit represents changes to many resources managed in the workspace. The edit
 * should either provide `changes` or `documentChanges`. If documentChanges are present
 * they are preferred over `changes` if the client can handle versioned document edits.
 *
 * Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
 * operations are present clients need to execute the operations in the order in which they
 * are provided. So a workspace edit for example can consist of the following two changes:
 * (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
 *
 * An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
 * cause failure of the operation. How the client recovers from the failure is described by
 * the client capability: `workspace.workspaceEdit.failureHandling`
 */
interface WorkspaceEdit {
    /**
     * Holds changes to existing resources.
     */
    changes?: {
        [uri: DocumentUri]: TextEdit$1[];
    };
    /**
     * Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
     * are either an array of `TextDocumentEdit`s to express changes to n different text documents
     * where each text document edit addresses a specific version of a text document. Or it can contain
     * above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
     *
     * Whether a client supports versioned document edits is expressed via
     * `workspace.workspaceEdit.documentChanges` client capability.
     *
     * If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
     * only plain `TextEdit`s using the `changes` property are supported.
     */
    documentChanges?: (TextDocumentEdit | CreateFile | RenameFile | DeleteFile)[];
    /**
     * A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
     * delete file / folder operations.
     *
     * Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
     *
     * @since 3.16.0
     */
    changeAnnotations?: {
        [id: ChangeAnnotationIdentifier]: ChangeAnnotation;
    };
}
declare namespace WorkspaceEdit {
    function is(value: any): value is WorkspaceEdit;
}
/**
 * A literal to identify a text document in the client.
 */
interface TextDocumentIdentifier {
    /**
     * The text document's uri.
     */
    uri: DocumentUri$1;
}
/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
declare namespace TextDocumentIdentifier {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri: DocumentUri$1): TextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value: any): value is TextDocumentIdentifier;
}
/**
 * A text document identifier to denote a specific version of a text document.
 */
interface VersionedTextDocumentIdentifier extends TextDocumentIdentifier {
    /**
     * The version number of this document.
     */
    version: integer;
}
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
declare namespace VersionedTextDocumentIdentifier {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri: DocumentUri$1, version: integer): VersionedTextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value: any): value is VersionedTextDocumentIdentifier;
}
/**
 * A text document identifier to optionally denote a specific version of a text document.
 */
interface OptionalVersionedTextDocumentIdentifier extends TextDocumentIdentifier {
    /**
     * The version number of this document. If a versioned text document identifier
     * is sent from the server to the client and the file is not open in the editor
     * (the server has not received an open notification before) the server can send
     * `null` to indicate that the version is unknown and the content on disk is the
     * truth (as specified with document content ownership).
     */
    version: integer | null;
}
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
declare namespace OptionalVersionedTextDocumentIdentifier {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri: DocumentUri$1, version: integer | null): OptionalVersionedTextDocumentIdentifier;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value: any): value is OptionalVersionedTextDocumentIdentifier;
}
/**
 * An item to transfer a text document from the client to the
 * server.
 */
interface TextDocumentItem {
    /**
     * The text document's uri.
     */
    uri: DocumentUri$1;
    /**
     * The text document's language identifier.
     */
    languageId: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     */
    version: integer;
    /**
     * The content of the opened text document.
     */
    text: string;
}
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
declare namespace TextDocumentItem {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri: DocumentUri$1, languageId: string, version: integer, text: string): TextDocumentItem;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value: any): value is TextDocumentItem;
}
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
declare namespace MarkupKind {
    /**
     * Plain text is supported as a content format
     */
    const PlainText: 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    const Markdown: 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value: any): value is MarkupKind;
}
type MarkupKind = 'plaintext' | 'markdown';
/**
 * A `MarkupContent` literal represents a string value which content is interpreted base on its
 * kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
 *
 * If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
 * See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
 *
 * Here is an example how such a string can be constructed using JavaScript / TypeScript:
 * ```ts
 * let markdown: MarkdownContent = {
 *  kind: MarkupKind.Markdown,
 *  value: [
 *    '# Header',
 *    'Some text',
 *    '```typescript',
 *    'someCode();',
 *    '```'
 *  ].join('\n')
 * };
 * ```
 *
 * *Please Note* that clients might sanitize the return markdown. A client could decide to
 * remove HTML from the markdown to avoid script execution.
 */
interface MarkupContent {
    /**
     * The type of the Markup
     */
    kind: MarkupKind;
    /**
     * The content itself
     */
    value: string;
}
declare namespace MarkupContent {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value: any): value is MarkupContent;
}
/**
 * The kind of a completion entry.
 */
declare namespace CompletionItemKind {
    const Text: 1;
    const Method: 2;
    const Function: 3;
    const Constructor: 4;
    const Field: 5;
    const Variable: 6;
    const Class: 7;
    const Interface: 8;
    const Module: 9;
    const Property: 10;
    const Unit: 11;
    const Value: 12;
    const Enum: 13;
    const Keyword: 14;
    const Snippet: 15;
    const Color: 16;
    const File: 17;
    const Reference: 18;
    const Folder: 19;
    const EnumMember: 20;
    const Constant: 21;
    const Struct: 22;
    const Event: 23;
    const Operator: 24;
    const TypeParameter: 25;
}
type CompletionItemKind = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25;
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
declare namespace InsertTextFormat {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    const PlainText: 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    const Snippet: 2;
}
type InsertTextFormat = 1 | 2;
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
declare namespace CompletionItemTag {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    const Deprecated = 1;
}
type CompletionItemTag = 1;
/**
 * A special text edit to provide an insert and a replace operation.
 *
 * @since 3.16.0
 */
interface InsertReplaceEdit {
    /**
     * The string to be inserted.
     */
    newText: string;
    /**
     * The range if the insert is requested
     */
    insert: Range$1;
    /**
     * The range if the replace is requested.
     */
    replace: Range$1;
}
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
declare namespace InsertReplaceEdit {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText: string, insert: Range$1, replace: Range$1): InsertReplaceEdit;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value: TextEdit$1 | InsertReplaceEdit): value is InsertReplaceEdit;
}
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
declare namespace InsertTextMode {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    const asIs: 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    const adjustIndentation: 2;
}
type InsertTextMode = 1 | 2;
/**
 * Additional details for a completion item label.
 *
 * @since 3.17.0
 */
interface CompletionItemLabelDetails {
    /**
     * An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
     * without any spacing. Should be used for function signatures and type annotations.
     */
    detail?: string;
    /**
     * An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
     * for fully qualified names and file paths.
     */
    description?: string;
}
declare namespace CompletionItemLabelDetails {
    function is(value: any): value is CompletionItemLabelDetails;
}
/**
 * A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 */
interface CompletionItem {
    /**
     * The label of this completion item.
     *
     * The label property is also by default the text that
     * is inserted when selecting this completion.
     *
     * If label details are provided the label itself should
     * be an unqualified name of the completion item.
     */
    label: string;
    /**
     * Additional details for the label
     *
     * @since 3.17.0
     */
    labelDetails?: CompletionItemLabelDetails;
    /**
     * The kind of this completion item. Based of the kind
     * an icon is chosen by the editor.
     */
    kind?: CompletionItemKind;
    /**
     * Tags for this completion item.
     *
     * @since 3.15.0
     */
    tags?: CompletionItemTag[];
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string | MarkupContent;
    /**
     * Indicates if this item is deprecated.
     * @deprecated Use `tags` instead.
     */
    deprecated?: boolean;
    /**
     * Select this item when showing.
     *
     * *Note* that only one completion item can be selected and that the
     * tool / client decides which item that is. The rule is that the *first*
     * item of those that match best is selected.
     */
    preselect?: boolean;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    sortText?: string;
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    filterText?: string;
    /**
     * A string that should be inserted into a document when selecting
     * this completion. When `falsy` the {@link CompletionItem.label label}
     * is used.
     *
     * The `insertText` is subject to interpretation by the client side.
     * Some tools might not take the string literally. For example
     * VS Code when code complete is requested in this example
     * `con<cursor position>` and a completion item with an `insertText` of
     * `console` is provided it will only insert `sole`. Therefore it is
     * recommended to use `textEdit` instead since it avoids additional client
     * side interpretation.
     */
    insertText?: string;
    /**
     * The format of the insert text. The format applies to both the
     * `insertText` property and the `newText` property of a provided
     * `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
     *
     * Please note that the insertTextFormat doesn't apply to
     * `additionalTextEdits`.
     */
    insertTextFormat?: InsertTextFormat;
    /**
     * How whitespace and indentation is handled during completion
     * item insertion. If not provided the clients default value depends on
     * the `textDocument.completion.insertTextMode` client capability.
     *
     * @since 3.16.0
     */
    insertTextMode?: InsertTextMode;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this completion. When an edit is provided the value of
     * {@link CompletionItem.insertText insertText} is ignored.
     *
     * Most editors support two different operations when accepting a completion
     * item. One is to insert a completion text and the other is to replace an
     * existing text with a completion text. Since this can usually not be
     * predetermined by a server it can report both ranges. Clients need to
     * signal support for `InsertReplaceEdits` via the
     * `textDocument.completion.insertReplaceSupport` client capability
     * property.
     *
     * *Note 1:* The text edit's range as well as both ranges from an insert
     * replace edit must be a [single line] and they must contain the position
     * at which completion has been requested.
     * *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
     * must be a prefix of the edit's replace range, that means it must be
     * contained and starting at the same position.
     *
     * @since 3.16.0 additional type `InsertReplaceEdit`
     */
    textEdit?: TextEdit$1 | InsertReplaceEdit;
    /**
     * The edit text used if the completion item is part of a CompletionList and
     * CompletionList defines an item default for the text edit range.
     *
     * Clients will only honor this property if they opt into completion list
     * item defaults using the capability `completionList.itemDefaults`.
     *
     * If not provided and a list's default range is provided the label
     * property is used as a text.
     *
     * @since 3.17.0
     */
    textEditText?: string;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this completion. Edits must not overlap (including the same insert position)
     * with the main {@link CompletionItem.textEdit edit} nor with themselves.
     *
     * Additional text edits should be used to change text unrelated to the current cursor position
     * (for example adding an import statement at the top of the file if the completion item will
     * insert an unqualified type).
     */
    additionalTextEdits?: TextEdit$1[];
    /**
     * An optional set of characters that when pressed while this completion is active will accept it first and
     * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
     * characters will be ignored.
     */
    commitCharacters?: string[];
    /**
     * An optional {@link Command command} that is executed *after* inserting this completion. *Note* that
     * additional modifications to the current document should be described with the
     * {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a completion item between a
     * {@link CompletionRequest} and a {@link CompletionResolveRequest}.
     */
    data?: LSPAny;
}
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
declare namespace CompletionItem {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label: string): CompletionItem;
}
/**
 * Represents a collection of {@link CompletionItem completion items} to be presented
 * in the editor.
 */
interface CompletionList {
    /**
     * This list it not complete. Further typing results in recomputing this list.
     *
     * Recomputed lists have all their items replaced (not appended) in the
     * incomplete completion sessions.
     */
    isIncomplete: boolean;
    /**
     * In many cases the items of an actual completion result share the same
     * value for properties like `commitCharacters` or the range of a text
     * edit. A completion list can therefore define item defaults which will
     * be used if a completion item itself doesn't specify the value.
     *
     * If a completion list specifies a default value and a completion item
     * also specifies a corresponding value the one from the item is used.
     *
     * Servers are only allowed to return default values if the client
     * signals support for this via the `completionList.itemDefaults`
     * capability.
     *
     * @since 3.17.0
     */
    itemDefaults?: {
        /**
         * A default commit character set.
         *
         * @since 3.17.0
         */
        commitCharacters?: string[];
        /**
         * A default edit range.
         *
         * @since 3.17.0
         */
        editRange?: Range$1 | {
            insert: Range$1;
            replace: Range$1;
        };
        /**
         * A default insert text format.
         *
         * @since 3.17.0
         */
        insertTextFormat?: InsertTextFormat;
        /**
         * A default insert text mode.
         *
         * @since 3.17.0
         */
        insertTextMode?: InsertTextMode;
        /**
         * A default data value.
         *
         * @since 3.17.0
         */
        data?: LSPAny;
    };
    /**
     * The completion items.
     */
    items: CompletionItem[];
}
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
declare namespace CompletionList {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items?: CompletionItem[], isIncomplete?: boolean): CompletionList;
}
/**
 * MarkedString can be used to render human readable text. It is either a markdown string
 * or a code-block that provides a language and a code snippet. The language identifier
 * is semantically equal to the optional language identifier in fenced code blocks in GitHub
 * issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
 *
 * The pair of a language and a value is an equivalent to markdown:
 * ```${language}
 * ${value}
 * ```
 *
 * Note that markdown strings will be sanitized - that means html will be escaped.
 * @deprecated use MarkupContent instead.
 */
type MarkedString = string | {
    language: string;
    value: string;
};
declare namespace MarkedString {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText: string): string;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value: any): value is MarkedString;
}
/**
 * The result of a hover request.
 */
interface Hover {
    /**
     * The hover's content
     */
    contents: MarkupContent | MarkedString | MarkedString[];
    /**
     * An optional range inside the text document that is used to
     * visualize the hover, e.g. by changing the background color.
     */
    range?: Range$1;
}
declare namespace Hover {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value: any): value is Hover;
}
/**
 * Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.
 */
interface ParameterInformation {
    /**
     * The label of this parameter information.
     *
     * Either a string or an inclusive start and exclusive end offsets within its containing
     * signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
     * string representation as `Position` and `Range` does.
     *
     * *Note*: a label of type string should be a substring of its containing signature label.
     * Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
     */
    label: string | [uinteger, uinteger];
    /**
     * The human-readable doc-comment of this parameter. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | MarkupContent;
}
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
declare namespace ParameterInformation {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label: string | [uinteger, uinteger], documentation?: string): ParameterInformation;
}
/**
 * Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.
 */
interface SignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | MarkupContent;
    /**
     * The parameters of this signature.
     */
    parameters?: ParameterInformation[];
    /**
     * The index of the active parameter.
     *
     * If provided, this is used in place of `SignatureHelp.activeParameter`.
     *
     * @since 3.16.0
     */
    activeParameter?: uinteger;
}
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
declare namespace SignatureInformation {
    function create(label: string, documentation?: string, ...parameters: ParameterInformation[]): SignatureInformation;
}
/**
 * Signature help represents the signature of something
 * callable. There can be multiple signature but only one
 * active and only one active parameter.
 */
interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: SignatureInformation[];
    /**
     * The active signature. If omitted or the value lies outside the
     * range of `signatures` the value defaults to zero or is ignored if
     * the `SignatureHelp` has no signatures.
     *
     * Whenever possible implementors should make an active decision about
     * the active signature and shouldn't rely on a default value.
     *
     * In future version of the protocol this property might become
     * mandatory to better express this.
     */
    activeSignature?: uinteger;
    /**
     * The active parameter of the active signature. If omitted or the value
     * lies outside the range of `signatures[activeSignature].parameters`
     * defaults to 0 if the active signature has parameters. If
     * the active signature has no parameters it is ignored.
     * In future version of the protocol this property might become
     * mandatory to better express the active parameter if the
     * active signature does have any.
     */
    activeParameter?: uinteger;
}
/**
 * The definition of a symbol represented as one or many {@link Location locations}.
 * For most programming languages there is only one location at which a symbol is
 * defined.
 *
 * Servers should prefer returning `DefinitionLink` over `Definition` if supported
 * by the client.
 */
type Definition = Location | Location[];
/**
 * Information about where a symbol is defined.
 *
 * Provides additional metadata over normal {@link Location location} definitions, including the range of
 * the defining symbol
 */
type DefinitionLink = LocationLink;
/**
 * The declaration of a symbol representation as one or many {@link Location locations}.
 */
type Declaration = Location | Location[];
/**
 * Information about where a symbol is declared.
 *
 * Provides additional metadata over normal {@link Location location} declarations, including the range of
 * the declaring symbol.
 *
 * Servers should prefer returning `DeclarationLink` over `Declaration` if supported
 * by the client.
 */
type DeclarationLink = LocationLink;
/**
 * Value-object that contains additional information when
 * requesting references.
 */
interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
}
/**
 * A document highlight kind.
 */
declare namespace DocumentHighlightKind {
    /**
     * A textual occurrence.
     */
    const Text: 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    const Read: 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    const Write: 3;
}
type DocumentHighlightKind = 1 | 2 | 3;
/**
 * A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.
 */
interface DocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: Range$1;
    /**
     * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
     */
    kind?: DocumentHighlightKind;
}
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
declare namespace DocumentHighlight {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range: Range$1, kind?: DocumentHighlightKind): DocumentHighlight;
}
/**
 * A symbol kind.
 */
declare namespace SymbolKind {
    const File: 1;
    const Module: 2;
    const Namespace: 3;
    const Package: 4;
    const Class: 5;
    const Method: 6;
    const Property: 7;
    const Field: 8;
    const Constructor: 9;
    const Enum: 10;
    const Interface: 11;
    const Function: 12;
    const Variable: 13;
    const Constant: 14;
    const String: 15;
    const Number: 16;
    const Boolean: 17;
    const Array: 18;
    const Object: 19;
    const Key: 20;
    const Null: 21;
    const EnumMember: 22;
    const Struct: 23;
    const Event: 24;
    const Operator: 25;
    const TypeParameter: 26;
}
type SymbolKind = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26;
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
declare namespace SymbolTag {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    const Deprecated: 1;
}
type SymbolTag = 1;
/**
 * A base for all symbol information.
 */
interface BaseSymbolInformation {
    /**
     * The name of this symbol.
     */
    name: string;
    /**
     * The kind of this symbol.
     */
    kind: SymbolKind;
    /**
     * Tags for this symbol.
     *
     * @since 3.16.0
     */
    tags?: SymbolTag[];
    /**
     * The name of the symbol containing this symbol. This information is for
     * user interface purposes (e.g. to render a qualifier in the user interface
     * if necessary). It can't be used to re-infer a hierarchy for the document
     * symbols.
     */
    containerName?: string;
}
/**
 * Represents information about programming constructs like variables, classes,
 * interfaces etc.
 */
interface SymbolInformation extends BaseSymbolInformation {
    /**
     * Indicates if this symbol is deprecated.
     *
     * @deprecated Use tags instead
     */
    deprecated?: boolean;
    /**
     * The location of this symbol. The location's range is used by a tool
     * to reveal the location in the editor. If the symbol is selected in the
     * tool the range's start information is used to position the cursor. So
     * the range usually spans more than the actual symbol's name and does
     * normally include things like visibility modifiers.
     *
     * The range doesn't have to denote a node range in the sense of an abstract
     * syntax tree. It can therefore not be used to re-construct a hierarchy of
     * the symbols.
     */
    location: Location;
}
declare namespace SymbolInformation {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name: string, kind: SymbolKind, range: Range$1, uri: DocumentUri$1, containerName?: string): SymbolInformation;
}
/**
 * A special workspace symbol that supports locations without a range.
 *
 * See also SymbolInformation.
 *
 * @since 3.17.0
 */
interface WorkspaceSymbol extends BaseSymbolInformation {
    /**
     * The location of the symbol. Whether a server is allowed to
     * return a location without a range depends on the client
     * capability `workspace.symbol.resolveSupport`.
     *
     * See SymbolInformation#location for more details.
     */
    location: Location | {
        uri: DocumentUri$1;
    };
    /**
     * A data entry field that is preserved on a workspace symbol between a
     * workspace symbol request and a workspace symbol resolve request.
     */
    data?: LSPAny;
}
declare namespace WorkspaceSymbol {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name: string, kind: SymbolKind, uri: DocumentUri$1, range?: Range$1): WorkspaceSymbol;
}
/**
 * Represents programming constructs like variables, classes, interfaces etc.
 * that appear in a document. Document symbols can be hierarchical and they
 * have two ranges: one that encloses its definition and one that points to
 * its most interesting range, e.g. the range of an identifier.
 */
interface DocumentSymbol {
    /**
     * The name of this symbol. Will be displayed in the user interface and therefore must not be
     * an empty string or a string only consisting of white spaces.
     */
    name: string;
    /**
     * More detail for this symbol, e.g the signature of a function.
     */
    detail?: string;
    /**
     * The kind of this symbol.
     */
    kind: SymbolKind;
    /**
     * Tags for this document symbol.
     *
     * @since 3.16.0
     */
    tags?: SymbolTag[];
    /**
     * Indicates if this symbol is deprecated.
     *
     * @deprecated Use tags instead
     */
    deprecated?: boolean;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace but everything else
     * like comments. This information is typically used to determine if the clients cursor is
     * inside the symbol to reveal in the symbol in the UI.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
     * Must be contained by the `range`.
     */
    selectionRange: Range$1;
    /**
     * Children of this symbol, e.g. properties of a class.
     */
    children?: DocumentSymbol[];
}
declare namespace DocumentSymbol {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name: string, detail: string | undefined, kind: SymbolKind, range: Range$1, selectionRange: Range$1, children?: DocumentSymbol[]): DocumentSymbol;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value: any): value is DocumentSymbol;
}
/**
 * The kind of a code action.
 *
 * Kinds are a hierarchical list of identifiers separated by `.`, e.g. `"refactor.extract.function"`.
 *
 * The set of kinds is open and client needs to announce the kinds it supports to the server during
 * initialization.
 */
type CodeActionKind = string;
/**
 * A set of predefined code action kinds
 */
declare namespace CodeActionKind {
    /**
     * Empty kind.
     */
    const Empty: '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    const QuickFix: 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    const Refactor: 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    const RefactorExtract: 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    const RefactorInline: 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    const RefactorRewrite: 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    const Source: 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    const SourceOrganizeImports: 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    const SourceFixAll: 'source.fixAll';
}
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
declare namespace CodeActionTriggerKind {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    const Invoked: 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    const Automatic: 2;
}
type CodeActionTriggerKind = 1 | 2;
/**
 * Contains additional diagnostic information about the context in which
 * a {@link CodeActionProvider.provideCodeActions code action} is run.
 */
interface CodeActionContext {
    /**
     * An array of diagnostics known on the client side overlapping the range provided to the
     * `textDocument/codeAction` request. They are provided so that the server knows which
     * errors are currently presented to the user for the given range. There is no guarantee
     * that these accurately reflect the error state of the resource. The primary parameter
     * to compute code actions is the provided range.
     */
    diagnostics: Diagnostic[];
    /**
     * Requested kind of actions to return.
     *
     * Actions not of this kind are filtered out by the client before being shown. So servers
     * can omit computing them.
     */
    only?: CodeActionKind[];
    /**
     * The reason why code actions were requested.
     *
     * @since 3.17.0
     */
    triggerKind?: CodeActionTriggerKind;
}
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
declare namespace CodeActionContext {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics: Diagnostic[], only?: CodeActionKind[], triggerKind?: CodeActionTriggerKind): CodeActionContext;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value: any): value is CodeActionContext;
}
/**
 * A code action represents a change that can be performed in code, e.g. to fix a problem or
 * to refactor code.
 *
 * A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
 */
interface CodeAction {
    /**
     * A short, human-readable, title for this code action.
     */
    title: string;
    /**
     * The kind of the code action.
     *
     * Used to filter code actions.
     */
    kind?: CodeActionKind;
    /**
     * The diagnostics that this code action resolves.
     */
    diagnostics?: Diagnostic[];
    /**
     * Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
     * by keybindings.
     *
     * A quick fix should be marked preferred if it properly addresses the underlying error.
     * A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
     *
     * @since 3.15.0
     */
    isPreferred?: boolean;
    /**
     * Marks that the code action cannot currently be applied.
     *
     * Clients should follow the following guidelines regarding disabled code actions:
     *
     *   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
     *     code action menus.
     *
     *   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
     *     of code action, such as refactorings.
     *
     *   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
     *     that auto applies a code action and only disabled code actions are returned, the client should show the user an
     *     error message with `reason` in the editor.
     *
     * @since 3.16.0
     */
    disabled?: {
        /**
         * Human readable description of why the code action is currently disabled.
         *
         * This is displayed in the code actions UI.
         */
        reason: string;
    };
    /**
     * The workspace edit this code action performs.
     */
    edit?: WorkspaceEdit;
    /**
     * A command this code action executes. If a code action
     * provides an edit and a command, first the edit is
     * executed and then the command.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a code action between
     * a `textDocument/codeAction` and a `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    data?: LSPAny;
}
declare namespace CodeAction {
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param kind The kind of the code action.
     */
    function create(title: string, kind?: CodeActionKind): CodeAction;
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param command The command to execute.
     * @param kind The kind of the code action.
     */
    function create(title: string, command: Command, kind?: CodeActionKind): CodeAction;
    /**
     * Creates a new code action.
     *
     * @param title The title of the code action.
     * @param edit The edit to perform.
     * @param kind The kind of the code action.
     */
    function create(title: string, edit: WorkspaceEdit, kind?: CodeActionKind): CodeAction;
    function is(value: any): value is CodeAction;
}
/**
 * A code lens represents a {@link Command command} that should be shown along with
 * source text, like the number of references, a way to run tests, etc.
 *
 * A code lens is _unresolved_ when no command is associated to it. For performance
 * reasons the creation of a code lens and resolving should be done in two stages.
 */
interface CodeLens {
    /**
     * The range in which this code lens is valid. Should only span a single line.
     */
    range: Range$1;
    /**
     * The command this code lens represents.
     */
    command?: Command;
    /**
     * A data entry field that is preserved on a code lens item between
     * a {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
     */
    data?: LSPAny;
}
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
declare namespace CodeLens {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range: Range$1, data?: LSPAny): CodeLens;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value: any): value is CodeLens;
}
/**
 * Value-object describing what options formatting should use.
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: uinteger;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
    /**
     * Trim trailing whitespace on a line.
     *
     * @since 3.15.0
     */
    trimTrailingWhitespace?: boolean;
    /**
     * Insert a newline character at the end of the file if one does not exist.
     *
     * @since 3.15.0
     */
    insertFinalNewline?: boolean;
    /**
     * Trim all newlines after the final newline at the end of the file.
     *
     * @since 3.15.0
     */
    trimFinalNewlines?: boolean;
    /**
     * Signature for further properties.
     */
    [key: string]: boolean | integer | string | undefined;
}
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
declare namespace FormattingOptions {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize: uinteger, insertSpaces: boolean): FormattingOptions;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value: any): value is FormattingOptions;
}
/**
 * A document link is a range in a text document that links to an internal or external resource, like another
 * text document or a web site.
 */
interface DocumentLink {
    /**
     * The range this link applies to.
     */
    range: Range$1;
    /**
     * The uri this link points to. If missing a resolve request is sent later.
     */
    target?: URI;
    /**
     * The tooltip text when you hover over this link.
     *
     * If a tooltip is provided, is will be displayed in a string that includes instructions on how to
     * trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
     * user settings, and localization.
     *
     * @since 3.15.0
     */
    tooltip?: string;
    /**
     * A data entry field that is preserved on a document link between a
     * DocumentLinkRequest and a DocumentLinkResolveRequest.
     */
    data?: LSPAny;
}
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
declare namespace DocumentLink {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range: Range$1, target?: string, data?: LSPAny): DocumentLink;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value: any): value is DocumentLink;
}
/**
 * A selection range represents a part of a selection hierarchy. A selection range
 * may have a parent selection range that contains it.
 */
interface SelectionRange {
    /**
     * The {@link Range range} of this selection range.
     */
    range: Range$1;
    /**
     * The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
     */
    parent?: SelectionRange;
}
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
declare namespace SelectionRange {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range: Range$1, parent?: SelectionRange): SelectionRange;
    function is(value: any): value is SelectionRange;
}
/**
 * Represents programming constructs like functions or constructors in the context
 * of call hierarchy.
 *
 * @since 3.16.0
 */
interface CallHierarchyItem {
    /**
     * The name of this item.
     */
    name: string;
    /**
     * The kind of this item.
     */
    kind: SymbolKind;
    /**
     * Tags for this item.
     */
    tags?: SymbolTag[];
    /**
     * More detail for this item, e.g. the signature of a function.
     */
    detail?: string;
    /**
     * The resource identifier of this item.
     */
    uri: DocumentUri$1;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
     * Must be contained by the {@link CallHierarchyItem.range `range`}.
     */
    selectionRange: Range$1;
    /**
     * A data entry field that is preserved between a call hierarchy prepare and
     * incoming calls or outgoing calls requests.
     */
    data?: LSPAny;
}
/**
 * Represents an incoming call, e.g. a caller of a method or constructor.
 *
 * @since 3.16.0
 */
interface CallHierarchyIncomingCall {
    /**
     * The item that makes the call.
     */
    from: CallHierarchyItem;
    /**
     * The ranges at which the calls appear. This is relative to the caller
     * denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
     */
    fromRanges: Range$1[];
}
/**
 * Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
 *
 * @since 3.16.0
 */
interface CallHierarchyOutgoingCall {
    /**
     * The item that is called.
     */
    to: CallHierarchyItem;
    /**
     * The range at which this item is called. This is the range relative to the caller, e.g the item
     * passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}
     * and not {@link CallHierarchyOutgoingCall.to `this.to`}.
     */
    fromRanges: Range$1[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensLegend {
    /**
     * The token types a server uses.
     */
    tokenTypes: string[];
    /**
     * The token modifiers a server uses.
     */
    tokenModifiers: string[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokens {
    /**
     * An optional result id. If provided and clients support delta updating
     * the client will include the result id in the next semantic token request.
     * A server can then instead of computing all semantic tokens again simply
     * send a delta.
     */
    resultId?: string;
    /**
     * The actual tokens.
     */
    data: uinteger[];
}
/**
 * @since 3.16.0
 */
declare namespace SemanticTokens {
    function is(value: any): value is SemanticTokens;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensEdit {
    /**
     * The start offset of the edit.
     */
    start: uinteger;
    /**
     * The count of elements to remove.
     */
    deleteCount: uinteger;
    /**
     * The elements to insert.
     */
    data?: uinteger[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDelta {
    readonly resultId?: string;
    /**
     * The semantic token edits to transform a previous result into a new result.
     */
    edits: SemanticTokensEdit[];
}
/**
 * @since 3.17.0
 */
type TypeHierarchyItem = {
    /**
     * The name of this item.
     */
    name: string;
    /**
     * The kind of this item.
     */
    kind: SymbolKind;
    /**
     * Tags for this item.
     */
    tags?: SymbolTag[];
    /**
     * More detail for this item, e.g. the signature of a function.
     */
    detail?: string;
    /**
     * The resource identifier of this item.
     */
    uri: DocumentUri$1;
    /**
     * The range enclosing this symbol not including leading/trailing whitespace
     * but everything else, e.g. comments and code.
     */
    range: Range$1;
    /**
     * The range that should be selected and revealed when this symbol is being
     * picked, e.g. the name of a function. Must be contained by the
     * {@link TypeHierarchyItem.range `range`}.
     */
    selectionRange: Range$1;
    /**
     * A data entry field that is preserved between a type hierarchy prepare and
     * supertypes or subtypes requests. It could also be used to identify the
     * type hierarchy in the server, helping improve the performance on
     * resolving supertypes and subtypes.
     */
    data?: LSPAny;
};
/**
 * Provide inline value as text.
 *
 * @since 3.17.0
 */
type InlineValueText = {
    /**
     * The document range for which the inline value applies.
     */
    range: Range$1;
    /**
     * The text of the inline value.
     */
    text: string;
};
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
declare namespace InlineValueText {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range: Range$1, text: string): InlineValueText;
    function is(value: InlineValue | undefined | null): value is InlineValueText;
}
/**
 * Provide inline value through a variable lookup.
 * If only a range is specified, the variable name will be extracted from the underlying document.
 * An optional variable name can be used to override the extracted name.
 *
 * @since 3.17.0
 */
type InlineValueVariableLookup = {
    /**
     * The document range for which the inline value applies.
     * The range is used to extract the variable name from the underlying document.
     */
    range: Range$1;
    /**
     * If specified the name of the variable to look up.
     */
    variableName?: string;
    /**
     * How to perform the lookup.
     */
    caseSensitiveLookup: boolean;
};
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
declare namespace InlineValueVariableLookup {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range: Range$1, variableName: string | undefined, caseSensitiveLookup: boolean): InlineValueVariableLookup;
    function is(value: InlineValue | undefined | null): value is InlineValueVariableLookup;
}
/**
 * Provide an inline value through an expression evaluation.
 * If only a range is specified, the expression will be extracted from the underlying document.
 * An optional expression can be used to override the extracted expression.
 *
 * @since 3.17.0
 */
type InlineValueEvaluatableExpression = {
    /**
     * The document range for which the inline value applies.
     * The range is used to extract the evaluatable expression from the underlying document.
     */
    range: Range$1;
    /**
     * If specified the expression overrides the extracted expression.
     */
    expression?: string;
};
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
declare namespace InlineValueEvaluatableExpression {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range: Range$1, expression: string | undefined): InlineValueEvaluatableExpression;
    function is(value: InlineValue | undefined | null): value is InlineValueEvaluatableExpression;
}
/**
 * Inline value information can be provided by different means:
 * - directly as a text value (class InlineValueText).
 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
 * The InlineValue types combines all inline value types into one type.
 *
 * @since 3.17.0
 */
type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueEvaluatableExpression;
/**
 * @since 3.17.0
 */
type InlineValueContext = {
    /**
     * The stack frame (as a DAP Id) where the execution has stopped.
     */
    frameId: integer;
    /**
     * The document range where execution has stopped.
     * Typically the end position of the range denotes the line where the inline values are shown.
     */
    stoppedLocation: Range$1;
};
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
declare namespace InlineValueContext {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId: integer, stoppedLocation: Range$1): InlineValueContext;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value: any): value is InlineValueContext;
}
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
declare namespace InlayHintKind {
    /**
     * An inlay hint that for a type annotation.
     */
    const Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    const Parameter = 2;
    function is(value: number): value is InlayHintKind;
}
type InlayHintKind = 1 | 2;
/**
 * An inlay hint label part allows for interactive and composite labels
 * of inlay hints.
 *
 * @since 3.17.0
 */
type InlayHintLabelPart = {
    /**
     * The value of this label part.
     */
    value: string;
    /**
     * The tooltip text when you hover over this label part. Depending on
     * the client capability `inlayHint.resolveSupport` clients might resolve
     * this property late using the resolve request.
     */
    tooltip?: string | MarkupContent;
    /**
     * An optional source code location that represents this
     * label part.
     *
     * The editor will use this location for the hover and for code navigation
     * features: This part will become a clickable link that resolves to the
     * definition of the symbol at the given location (not necessarily the
     * location itself), it shows the hover that shows at the given location,
     * and it shows a context menu with further code navigation commands.
     *
     * Depending on the client capability `inlayHint.resolveSupport` clients
     * might resolve this property late using the resolve request.
     */
    location?: Location;
    /**
     * An optional command for this label part.
     *
     * Depending on the client capability `inlayHint.resolveSupport` clients
     * might resolve this property late using the resolve request.
     */
    command?: Command;
};
declare namespace InlayHintLabelPart {
    function create(value: string): InlayHintLabelPart;
    function is(value: any): value is InlayHintLabelPart;
}
/**
 * Inlay hint information.
 *
 * @since 3.17.0
 */
type InlayHint = {
    /**
     * The position of this hint.
     */
    position: Position$1;
    /**
     * The label of this hint. A human readable string or an array of
     * InlayHintLabelPart label parts.
     *
     * *Note* that neither the string nor the label part can be empty.
     */
    label: string | InlayHintLabelPart[];
    /**
     * The kind of this hint. Can be omitted in which case the client
     * should fall back to a reasonable default.
     */
    kind?: InlayHintKind;
    /**
     * Optional text edits that are performed when accepting this inlay hint.
     *
     * *Note* that edits are expected to change the document so that the inlay
     * hint (or its nearest variant) is now part of the document and the inlay
     * hint itself is now obsolete.
     */
    textEdits?: TextEdit$1[];
    /**
     * The tooltip text when you hover over this item.
     */
    tooltip?: string | MarkupContent;
    /**
     * Render padding before the hint.
     *
     * Note: Padding should use the editor's background color, not the
     * background color of the hint itself. That means padding can be used
     * to visually align/separate an inlay hint.
     */
    paddingLeft?: boolean;
    /**
     * Render padding after the hint.
     *
     * Note: Padding should use the editor's background color, not the
     * background color of the hint itself. That means padding can be used
     * to visually align/separate an inlay hint.
     */
    paddingRight?: boolean;
    /**
     * A data entry field that is preserved on an inlay hint between
     * a `textDocument/inlayHint` and a `inlayHint/resolve` request.
     */
    data?: LSPAny;
};
declare namespace InlayHint {
    function create(position: Position$1, label: string | InlayHintLabelPart[], kind?: InlayHintKind): InlayHint;
    function is(value: any): value is InlayHint;
}
/**
 * A workspace folder inside a client.
 */
interface WorkspaceFolder {
    /**
     * The associated URI for this workspace folder.
     */
    uri: URI;
    /**
     * The name of the workspace folder. Used to refer to this
     * workspace folder in the user interface.
     */
    name: string;
}
declare namespace WorkspaceFolder {
    function is(value: any): value is WorkspaceFolder;
}

type ParserMethod<ARGS extends unknown[], R> = (...args: ARGS) => R;

/**
 * This class does not actually exist nor is exposed at runtime.
 * This is just a helper to avoid duplications in the Type Definitions
 * Of `CstParser` and `EmbeddedActionsParser`
 */
declare abstract class BaseParser$2 {
  /**
   * This must be called at the end of a Parser constructor.
   * See: http://chevrotain.io/docs/tutorial/step2_parsing.html#under-the-hood
   */
  protected performSelfAnalysis(): void;

  /**
   * It is recommended to reuse the same Parser instance
   * by passing an empty array to the input argument
   * and only later setting the input by using the input property.
   * See: http://chevrotain.io/docs/FAQ.html#major-performance-benefits
   *
   * @param tokenVocabulary - A data structure containing all the Tokens used by the Parser.
   * @param config - The Parser's configuration.
   */
  constructor(tokenVocabulary: TokenVocabulary, config?: IParserConfig);

  errors: IRecognitionException[];

  /**
   * Flag indicating the Parser is at the recording phase.
   * Can be used to implement methods similar to {@link BaseParser.ACTION}
   * Or any other logic to requires knowledge of the recording phase.
   * See:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   * to learn more on the recording phase and how Chevrotain works.
   */
  RECORDING_PHASE: boolean;

  /**
   * Resets the parser state, should be overridden for custom parsers which "carry" additional state.
   * When overriding, remember to also invoke the super implementation!
   */
  reset(): void;

  getBaseCstVisitorConstructor<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>;
  };

  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>;
  };

  getGAstProductions(): Record<string, Rule>;

  getSerializedGastProductions(): ISerializedGast[];

  /**
   * @param startRuleName
   * @param precedingInput - The token vector up to (not including) the content assist point
   */
  computeContentAssist(
    startRuleName: string,
    precedingInput: IToken[],
  ): ISyntacticContentAssistPath[];

  /**
   * @param grammarRule - The rule to try and parse in backtracking mode.
   * @param args - argument to be passed to the grammar rule execution
   *
   * @return a lookahead function that will try to parse the given grammarRule and will return true if succeed.
   */
  protected BACKTRACK<T>(
    grammarRule: (...args: any[]) => T,
    args?: any[],
  ): () => boolean;

  /**
   * The Semantic Actions wrapper.
   * Should be used to wrap semantic actions that either:
   * - May fail when executing in "recording phase".
   * - Have global side effects that should be avoided during "recording phase".
   *
   * For more information see:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   */
  protected ACTION<T>(impl: () => T): T;

  /**
   * Like `CONSUME` with the numerical suffix as a parameter, e.g:
   * consume(0, X) === CONSUME(X)
   * consume(1, X) === CONSUME1(X)
   * consume(2, X) === CONSUME2(X)
   * ...
   * @see CONSUME
   */
  protected consume(
    idx: number,
    tokType: TokenType,
    options?: ConsumeMethodOpts,
  ): IToken;

  /**
   * Like `OPTION` with the numerical suffix as a parameter, e.g:
   * option(0, X) === OPTION(X)
   * option(1, X) === OPTION1(X)
   * option(2, X) === OPTION2(X)
   * ...
   * @see OPTION
   */
  protected option<OUT>(
    idx: number,
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * Like `OR` with the numerical suffix as a parameter, e.g:
   * or(0, X) === OR(X)
   * or(1, X) === OR1(X)
   * or(2, X) === OR2(X)
   * ...
   * @see OR
   */
  protected or(idx: number, altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;
  protected or<T>(idx: number, altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;

  /**
   * Like `MANY` with the numerical suffix as a parameter, e.g:
   * many(0, X) === MANY(X)
   * many(1, X) === MANY1(X)
   * many(2, X) === MANY2(X)
   * ...
   * @see MANY
   */
  protected many(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * Like `AT_LEAST_ONE` with the numerical suffix as a parameter, e.g:
   * atLeastOne(0, X) === AT_LEAST_ONE(X)
   * atLeastOne(1, X) === AT_LEAST_ONE1(X)
   * atLeastOne(2, X) === AT_LEAST_ONE2(X)
   * ...
   * @see AT_LEAST_ONE
   */
  protected atLeastOne(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   *
   * A Parsing DSL method use to consume a single Token.
   * In EBNF terms this is equivalent to a Terminal.
   *
   * A Token will be consumed, IFF the next token in the token vector matches `tokType`.
   * otherwise the parser may attempt to perform error recovery (if enabled).
   *
   * The index in the method name indicates the unique occurrence of a terminal consumption
   * inside a the top level rule. What this means is that if a terminal appears
   * more than once in a single rule, each appearance must have a **different** index.
   *
   * For example:
   * ```
   *   this.RULE("qualifiedName", () => {
   *   this.CONSUME1(Identifier);
   *     this.MANY(() => {
   *       this.CONSUME1(Dot);
   *       // here we use CONSUME2 because the terminal
   *       // 'Identifier' has already appeared previously in the
   *       // the rule 'parseQualifiedName'
   *       this.CONSUME2(Identifier);
   *     });
   *   })
   * ```
   *
   * - See more details on the [unique suffixes requirement](http://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES).
   *
   * @param tokType - The Type of the token to be consumed.
   * @param options - optional properties to modify the behavior of CONSUME.
   */
  protected CONSUME(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME1(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME2(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME3(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME4(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME5(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME6(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME7(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME8(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME9(tokType: TokenType, options?: ConsumeMethodOpts): IToken;

  /**
   * Parsing DSL Method that Indicates an Optional production.
   * in EBNF notation this is equivalent to: "[...]".
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.OPTION(() => {
   *       this.CONSUME(Digit)}
   *     );
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.OPTION({
   *       GATE:predicateFunc,
   *       DEF: () => {
   *         this.CONSUME(Digit)
   *     }});
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the optional production in it's top rule.
   *
   * @param  actionORMethodDef - The grammar action to optionally invoke once
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   * @returns The `GrammarAction` return value (OUT) if the optional syntax is encountered
   *          or `undefined` if not.
   */
  protected OPTION<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION1<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION2<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION3<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION4<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION5<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION6<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION7<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION8<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION9<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,
  ): OUT | undefined;

  /**
   * Parsing DSL method that indicates a choice between a set of alternatives must be made.
   * This is equivalent to an EBNF alternation (A | B | C | D ...), except
   * that the alternatives are ordered like in a PEG grammar.
   * This means that the **first** matching alternative is always chosen.
   *
   * There are several forms for the inner alternatives array:
   *
   * - Passing alternatives array directly:
   *   ```
   *     this.OR([
   *       { ALT:() => { this.CONSUME(One) }},
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Passing alternative array directly with predicates (GATE):
   *   ```
   *     this.OR([
   *       { GATE: predicateFunc1, ALT:() => { this.CONSUME(One) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Two) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - These syntax forms can also be mixed:
   *   ```
   *     this.OR([
   *       {
   *         GATE: predicateFunc1,
   *         ALT:() => { this.CONSUME(One) }
   *       },
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Additionally an "options" object may be used:
   *   ```
   *     this.OR({
   *       DEF:[
   *         { ALT:() => { this.CONSUME(One) }},
   *         { ALT:() => { this.CONSUME(Two) }},
   *         { ALT:() => { this.CONSUME(Three) }}
   *       ],
   *       // OPTIONAL property
   *       ERR_MSG: "A Number"
   *     })
   *   ```
   *
   * The 'predicateFuncX' in the long form can be used to add constraints to choosing the alternative.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the alternation production in it's top rule.
   *
   * @param altsOrOpts - A set of alternatives or an "OPTIONS" object describing the alternatives and optional properties.
   *
   * @returns The result of invoking the chosen alternative.
   */
  protected OR<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR1<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR1(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR2<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR2(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR3<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR3(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR4<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR4(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR5<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR5(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR6<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR6(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR7<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR7(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR8<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR8(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * @see OR
   * @hidden
   */
  protected OR9<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T;
  protected OR9(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any;

  /**
   * Parsing DSL method, that indicates a repetition of zero or more.
   * This is equivalent to EBNF repetition \{...\}.
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.MANY(() => {
   *       this.CONSUME(Comma)
   *       this.CONSUME(Digit)
   *      })
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.MANY({
   *       GATE: predicateFunc,
   *       DEF: () => {
   *              this.CONSUME(Comma)
   *              this.CONSUME(Digit)
   *            }
   *     });
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param actionORMethodDef - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected MANY(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * @see MANY
   * @hidden
   */
  protected MANY9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,
  ): void;

  /**
   * Parsing DSL method, that indicates a repetition of zero or more with a separator
   * Token between the repetitions.
   *
   * Example:
   *
   * ```
   *     this.MANY_SEP({
   *         SEP:Comma,
   *         DEF: () => {
   *             this.CONSUME(Number};
   *             // ...
   *         })
   * ```
   *
   * Note that because this DSL method always requires more than one argument the options object is always required
   * and it is not possible to use a shorter form like in the MANY DSL method.
   *
   * Note that for the purposes of deciding on whether or not another iteration exists
   * Only a single Token is examined (The separator). Therefore if the grammar being implemented is
   * so "crazy" to require multiple tokens to identify an item separator please use the more basic DSL methods
   * to implement it.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   */
  protected MANY_SEP(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP1(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP2(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP3(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP4(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP5(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP6(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP7(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP8(options: ManySepMethodOpts<any>): void;

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP9(options: ManySepMethodOpts<any>): void;

  /**
   * Convenience method, same as MANY but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause a parsing error.
   *
   * @see MANY
   *
   * @param actionORMethodDef  - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected AT_LEAST_ONE(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,
  ): void;

  /**
   * Convenience method, same as MANY_SEP but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause the parser to attempt error recovery.
   *
   * Note that an additional optional property ERR_MSG can be used to provide custom error messages.
   *
   * @see MANY_SEP
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   * @return {ISeparatedIterationResult<OUT>}
   */
  protected AT_LEAST_ONE_SEP(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP1(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP2(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP3(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP4(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP5(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP6(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP7(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP8(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP9(options: AtLeastOneSepMethodOpts<any>): void;

  /**
   * Returns an "imaginary" Token to insert when Single Token Insertion is done
   * Override this if you require special behavior in your grammar.
   * For example if an IntegerToken is required provide one with the image '0' so it would be valid syntactically.
   */
  protected getTokenToInsert(tokType: TokenType): IToken;

  /**
   * By default, all tokens type may be inserted. This behavior may be overridden in inheriting Recognizers
   * for example: One may decide that only punctuation tokens may be inserted automatically as they have no additional
   * semantic value. (A mandatory semicolon has no additional semantic meaning, but an Integer may have additional meaning
   * depending on its int value and context (Inserting an integer 0 in cardinality: "[1..]" will cause semantic issues
   * as the max of the cardinality will be greater than the min value (and this is a false error!).
   */
  protected canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean;

  /**
   * By default, all token types may be deleted. This behavior may be overridden in inheriting parsers.
   * The method receives the expected token type. The token that would be deleted can be received with {@link LA}.
   */
  protected canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean;

  /**
   * @deprecated - will be removed in the future
   */
  protected getNextPossibleTokenTypes(
    grammarPath: ITokenGrammarPath,
  ): TokenType[];

  input: IToken[];

  /**
   * Will consume a single token and return the **next** token, meaning
   * the token **after** the skipped token.
   */
  protected SKIP_TOKEN(): IToken;

  /**
   * Look-Ahead for the Token Vector
   * LA(1) is the next Token ahead.
   * LA(n) is the nth Token ahead.
   * LA(0) is the previously consumed Token.
   *
   * Looking beyond the end of the Token Vector or before its begining
   * will return in an IToken of type EOF {@link EOF}.
   * This behavior can be used to avoid infinite loops.
   *
   * This is often used to implement custom lookahead logic for GATES.
   * https://chevrotain.io/docs/features/gates.html
   */
  protected LA(howMuch: number): IToken;
}

/**
 * A Parser that relies on end user's embedded actions to control its output.
 * For more details see:
 *   - https://chevrotain.io/docs/tutorial/step3_adding_actions_root.html#alternatives
 *   - https://chevrotain.io/docs/tutorial/step3b_adding_actions_embedded.html#simple-example
 */
declare class EmbeddedActionsParser extends BaseParser$2 {
  /**
   * Creates a Grammar Rule
   *
   * Note that any parameters of your implementation must be optional as it will
   * be called without parameters during the grammar recording phase.
   */
  protected RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>,
  ): ParserMethod<Parameters<F>, ReturnType<F>>;

  /**
   * Overrides a Grammar Rule
   * See usage example in: https://github.com/chevrotain/chevrotain/blob/master/examples/parser/versioning/versioning.js
   */
  protected OVERRIDE_RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>,
  ): ParserMethod<Parameters<F>, ReturnType<F>>;

  /**
   * Like `SUBRULE` with the numerical suffix as a parameter, e.g:
   * subrule(0, X) === SUBRULE(X)
   * subrule(1, X) === SUBRULE1(X)
   * subrule(2, X) === SUBRULE2(X)
   * ...
   * @see SUBRULE
   */
  protected subrule<ARGS extends unknown[], R>(
    idx: number,
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * The Parsing DSL Method is used by one rule to call another.
   * It is equivalent to a non-Terminal in EBNF notation.
   *
   * This may seem redundant as it does not actually do much.
   * However using it is **mandatory** for all sub rule invocations.
   *
   * Calling another rule without wrapping in SUBRULE(...)
   * will cause errors/mistakes in the Parser's self analysis phase,
   * which will lead to errors in error recovery/automatic lookahead calculation
   * and any other functionality relying on the Parser's self analysis
   * output.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the sub rule invocation in its rule.
   *
   */
  protected SUBRULE<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE1<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE2<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE3<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE4<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE5<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE6<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE7<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE8<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE9<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>,
  ): R;
}

interface ILexingError {
  offset: number;
  line: number | undefined;
  column: number | undefined;
  length: number;
  message: string;
}

interface ILexerErrorMessageProvider {
  /**
   * An Unexpected Character Error occurs when the lexer is unable to match a range of one or more
   * characters in the input text against any of the Token Types in it's Lexer definition
   *
   * @param fullText - Full original input text.
   *
   * @param startOffset - Offset in input text where error starts.
   *
   * @param length - Error length.
   *
   * @param line - Line number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   *
   * @param column - Column number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   */
  buildUnexpectedCharactersMessage(
    fullText: string,
    startOffset: number,
    length: number,
    line?: number,
    column?: number,
  ): string;

  /**
   * Unable To Pop Lexer Mode Error happens when lexer tries to pop the last remaining mode from the mode stack
   * so that there is no longer any active lexer mode
   * This error only relevant for multi-mode lexers
   *
   * @param token - The Token that requested pop mode.
   */
  buildUnableToPopLexerModeMessage(token: IToken): string;
}

type TokenPattern =
  | RegExp
  | string
  | CustomPatternMatcherFunc
  | ICustomPattern;

/**
 *  API #1 [Custom Token Patterns](http://chevrotain.io/docs/guide/custom_token_patterns.html).
 */
declare type CustomPatternMatcherFunc = (
  /**
   * The full input string.
   */
  text: string,
  /**
   * The offset at which to attempt a match
   */
  offset: number,
  /**
   * Previously scanned Tokens
   */
  tokens: IToken[],
  /**
   * Token Groups
   */
  groups: {
    [groupName: string]: IToken[];
  },
) => CustomPatternMatcherReturn | RegExpExecArray | null; // RegExpExecArray included for legacy reasons

type CustomPatternMatcherReturn = [string] & { payload?: any };

interface TokenType {
  name: string;
  GROUP?: string;
  PATTERN?: TokenPattern;
  LABEL?: string;
  LONGER_ALT?: TokenType | TokenType[];
  POP_MODE?: boolean;
  PUSH_MODE?: string;
  LINE_BREAKS?: boolean;
  CATEGORIES?: TokenType[];
  tokenTypeIdx?: number;
  categoryMatches?: number[];
  categoryMatchesMap?: {
    [tokType: number]: boolean;
  };
  isParent?: boolean;
  START_CHARS_HINT?: (string | number)[];
}

/**
 *  API #2 for [Custom Token Patterns](http://chevrotain.io/docs/guide/custom_token_patterns.html).
 */
interface ICustomPattern {
  exec: CustomPatternMatcherFunc;
}

/**
 * Things to note:
 *  - The offset range is inclusive to exclusive.
 *
 * - A lineTerminator as the last character does not effect the Token's line numbering.
 *   In other words a new line only starts **after** a line terminator.
 *
 * - A Token's image is it's **literal** text.
 *   e.g unicode escaping is untouched.
 */
interface IToken {
  /** The textual representation of the Token as it appeared in the text. */
  image: string;
  /** Offset of the first character of the Token. 0-indexed. */
  startOffset: number;
  /** Line of the first character of the Token. 1-indexed. */
  startLine?: number;
  /**
   * Column of the first character of the Token. 1-indexed.
   *
   * For token foo in the following line, startColumn will be 3 and endColumn will be 5.
   * ```
   * a foo
   * 123456
   * ```
   */
  startColumn?: number;
  /**
   * Offset of the last character of the Token. 0-indexed.
   * Note that this points at the last character, not the end of the token, so the original image would be
   * `input.substring(token.startOffset, token.endOffset + 1)`.
   */
  endOffset?: number;
  /** Line of the last character of the Token. 1-indexed. Will be the same as startLine for single-line tokens.*/
  endLine?: number;
  /** Column of the last character of the Token. 1-indexed. See also startColumn. */
  endColumn?: number;
  /** this marks if a Token does not really exist and has been inserted "artificially" during parsing in rule error recovery. */
  isInsertedInRecovery?: boolean;
  /** An number index representing the type of the Token use <getTokenConstructor> to get the Token Type from a token "instance"  */
  tokenTypeIdx: number;
  /**
   * The actual Token Type of this Token "instance"
   * This is the same Object returned by the "createToken" API.
   * This property is very useful for debugging the Lexing and Parsing phases.
   */
  tokenType: TokenType;

  /**
   * Custom Payload value, this is an optional feature of Custom Token Patterns
   * For additional details see the docs:
   * https://chevrotain.io/docs/guide/custom_token_patterns.html#custom-payloads
   */
  payload?: any;
}

declare type MultiModesDefinition = {
  [modeName: string]: TokenType[];
};

interface IMultiModeLexerDefinition {
  modes: MultiModesDefinition;
  defaultMode: string;
}

type TokenTypeDictionary = { [tokenName: string]: TokenType };

declare type TokenVocabulary =
  | TokenTypeDictionary
  | TokenType[]
  | IMultiModeLexerDefinition;

interface IRuleConfig<T> {
  /**
   * The function which will be invoked to produce the returned value for a production that have not been
   * successfully executed and the parser recovered from.
   */
  recoveryValueFunc?: (e: IRecognitionException) => T;
  /**
   * Enable/Disable re-sync error recovery for this specific production.
   */
  resyncEnabled?: boolean;
}

interface DSLMethodOpts<T> {
  /**
   * The Grammar to process in this method.
   */
  DEF: GrammarAction<T>;
  /**
   * A semantic constraint on this DSL method
   * @see https://github.com/chevrotain/chevrotain/blob/master/examples/parser/predicate_lookahead/predicate_lookahead.js
   * For farther details.
   */
  GATE?: () => boolean;

  /**
   * Maximum number of "following tokens" which would be used to
   * Choose between the alternatives.
   *
   * By default this value is determined by the {@link IParserConfig.maxLookahead} value.
   * A Higher value may be used for a specific DSL method to resolve ambiguities
   * And a lower value may be used to resolve slow initialization times issues.
   *
   * TODO: create full docs and link
   */
  MAX_LOOKAHEAD?: number;
}

interface DSLMethodOptsWithErr<T> extends DSLMethodOpts<T> {
  /**
   *  Short title/classification to what is being matched.
   *  Will be used in the error message,.
   *  If none is provided, the error message will include the names of the expected
   *  Tokens sequences which start the method's inner grammar
   */
  ERR_MSG?: string;
}

interface OrMethodOpts<T> {
  /**
   * The set of alternatives,
   * See detailed description in {@link BaseParser.OR}
   */
  DEF: IOrAlt<T>[];
  /**
   * A description for the alternatives used in error messages
   * If none is provided, the error message will include the names of the expected
   * Tokens sequences which may start each alternative.
   */
  ERR_MSG?: string;

  /**
   * A Flag indicating that **all** ambiguities in this alternation should
   * be ignored.
   *
   * This flag should only be used in rare circumstances,
   * As normally alternation ambiguities should be resolved in other ways:
   * - Re-ordering the alternatives.
   * - Re-factoring the grammar to extract common prefixes before alternation.
   * - Using gates {@link IOrAlt.GATE} to implement custom lookahead logic.
   * - Using the more granular {@link IOrAlt.IGNORE_AMBIGUITIES} on a **specific** alternative.
   */
  IGNORE_AMBIGUITIES?: boolean;

  /**
   * Maximum number of "following tokens" which would be used to
   * Choose between the alternatives.
   *
   * By default this value is determined by the {@link IParserConfig.maxLookahead} value.
   * A Higher value may be used for a specific DSL method to resolve ambiguities
   * And a lower value may be used to resolve slow initialization times issues.
   *
   * TODO: create full docs and link
   */
  MAX_LOOKAHEAD?: number;
}

interface ManySepMethodOpts<T> {
  /**
   * The grammar to process in each iteration.
   */
  DEF: GrammarAction<T>;
  /**
   * The separator between each iteration.
   */
  SEP: TokenType;

  /**
   * @see DSLMethodOpts.MAX_LOOKAHEAD
   */
  MAX_LOOKAHEAD?: number;
}

interface AtLeastOneSepMethodOpts<T> extends ManySepMethodOpts<T> {
  /**
   *  Short title/classification to what is being matched.
   *  Will be used in the error message,.
   *  If none is provided, the error message will include the names of the expected
   *  Tokens sequences which start the method's inner grammar.
   */
  ERR_MSG?: string;
}

interface ConsumeMethodOpts {
  /**
   *  A custom Error message if the Token could not be consumed.
   *  This will override any error message provided by the parser's "errorMessageProvider"
   */
  ERR_MSG?: string;
  /**
   * A label to be used instead of the TokenType name in the created CST.
   */
  LABEL?: string;
}

interface SubruleMethodOpts<ARGS> {
  /**
   * The arguments to parameterized rules, see:
   * https://github.com/chevrotain/chevrotain/blob/master/examples/parser/parametrized_rules/parametrized.js
   */
  ARGS?: ARGS;
  /**
   * A label to be used instead of the subrule's name in the created CST.
   */
  LABEL?: string;
}

declare type GrammarAction<OUT> = () => OUT;

interface IOrAlt<T> {
  GATE?: () => boolean;
  ALT: () => T;
  /**
   * A Flag indicating that any ambiguities involving this
   * specific alternative Should be ignored.
   *
   * This flag will be **implicitly** enabled if a GATE is used
   * as the assumption is that the GATE is used to resolve an ambiguity.
   */
  IGNORE_AMBIGUITIES?: boolean;
}

interface ICstVisitor<IN, OUT> {
  visit(cstNode: CstNode$1 | CstNode$1[], param?: IN): OUT;

  /**
   * Will throw an error if the visitor is missing any required methods
   * - `visitXYZ` for each `XYZ` grammar rule.
   */
  validateVisitor(): void;
}

/**
 * A [Concrete Syntax Tree](http://chevrotain.io/docs/guide/concrete_syntax_tree.html) Node.
 * This structure represents the whole parse tree of the grammar
 * This means that information on each and every Token is present.
 * This is unlike an AST (Abstract Syntax Tree) where some of the syntactic information is missing.
 *
 * For example given an ECMAScript grammar, an AST would normally not contain information on the location
 * of Commas, Semi colons, redundant parenthesis ect, however a CST would have that information.
 */
interface CstNode$1 {
  readonly name: string;
  readonly children: CstChildrenDictionary;
  /**
   * A flag indicating the whole CSTNode has been recovered during **re-sync** error recovery.
   * This means that some of the node's children may be missing.
   * - Note that single token insertion/deletion recovery would not activate this flag.
   *   This flag would only be activated in **re-sync** recovery when the rule's
   *   grammar cannot be fully parsed.
   * - See: https://chevrotain.io/docs/tutorial/step4_fault_tolerance.html
   *   for more info on error recovery and fault tolerance.
   */
  readonly recoveredNode?: boolean;

  /**
   * Will only be present if the {@link IParserConfig.nodeLocationTracking} is
   * **not** set to "none".
   * See: https://chevrotain.io/docs/guide/concrete_syntax_tree.html#cstnodes-location
   * For more details.
   */
  readonly location?: CstNodeLocation;
}

/**
 *  The Column/Line properties will only be present when
 *  The {@link IParserConfig.nodeLocationTracking} is set to "full".
 */
interface CstNodeLocation {
  startOffset: number;
  startLine?: number;
  startColumn?: number;
  endOffset?: number;
  endLine?: number;
  endColumn?: number;
}

declare type CstChildrenDictionary = {
  [identifier: string]: CstElement[];
};

declare type CstElement = IToken | CstNode$1;

declare type nodeLocationTrackingOptions =
  | "full"
  | "onlyOffset"
  | "none";

interface IParserConfig {
  /**
   * Is the error recovery / fault tolerance of the Chevrotain Parser enabled.
   */
  recoveryEnabled?: boolean;
  /**
   * Maximum number of tokens the parser will use to choose between alternatives.
   * By default this value is `4`.
   * In the future it may be reduced to `3` due to performance considerations.
   */
  maxLookahead?: number;
  /**
   * Enable This Flag to to support Dynamically defined Tokens.
   * This will disable performance optimizations which cannot work if the whole Token vocabulary is not known
   * During Parser initialization.
   *
   * See [runnable example](https://github.com/chevrotain/chevrotain/tree/master/examples/parser/dynamic_tokens)
   */
  dynamicTokensEnabled?: boolean;
  /**
   * Enable computation of CST nodes location.
   * By default this is set to "none", meaning this feature is disabled.
   * See: http://chevrotain.io/docs/guide/concrete_syntax_tree.html#cstnode-location
   * For more details.
   */
  nodeLocationTracking?: nodeLocationTrackingOptions;
  /**
   * A custom error message provider.
   * Can be used to override the default error messages.
   * For example:
   *   - Translating the error messages to a different languages.
   *   - Changing the formatting.
   *   - Providing special error messages under certain conditions, e.g: missing semicolons.
   */
  errorMessageProvider?: IParserErrorMessageProvider;
  /**
   * Enabling this flag will print performance tracing logs during parser
   * Initialization (constructor invocation), this is useful to narrow down the cause
   * of the initialization performance problem.
   *
   * You can also pass a numerical value which affects the verbosity
   * of the traces, this number is the maximum nesting level of the traces, e.g:
   * 0: Traces disabled === 'false'
   * 1: Top Level traces only.
   * 2: One level of nested inner traces.
   * ...
   *
   * Note that passing the boolean `true` is identical to passing the numerical value `infinity`
   */
  traceInitPerf?: boolean | number;
  /**
   * This flag will avoid running the grammar validations during Parser initialization.
   *
   * This can substantially improve the Parser's initialization (constructor) time.
   * @see IParserConfig.traceInitPerf to measure the grammar validations cost for your parser.
   *
   * Note that the grammar validations are **extremely useful** during development time,
   * e.g: detecting ambiguities / left recursion.
   * So they should not be skipped during development flows.
   *   - For example: via a conditional that checks an env variable.
   */
  skipValidations?: boolean;
  /**
   * @experimental
   *
   * A custom lookahead strategy.
   * Can be used to override the default LL(*k*) lookahead behavior.
   *
   * Note that the default lookahead strategy is very well optimized and using a custom lookahead
   * strategy might lead to massively reduced performance.
   */
  lookaheadStrategy?: ILookaheadStrategy;
}

/**
 * A set of methods used to customize parsing error messages.
 * Call {@link defaultParserErrorProvider} to implement the default behavior
 */
interface IParserErrorMessageProvider {
  /**
   * Mismatched Token Error happens when the parser attempted to consume a terminal and failed.
   * It corresponds to a failed {@link BaseParser.CONSUME} in Chevrotain DSL terms.
   *
   * @param options.expected - The expected Token Type.
   *
   * @param options.actual - The actual Token "instance".
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildMismatchTokenMessage(options: {
    expected: TokenType;
    actual: IToken;
    previous: IToken;
    ruleName: string;
  }): string;
  /**
   * A Redundant Input Error happens when the parser has completed parsing but there
   * is still unprocessed input remaining.
   *
   * @param options.firstRedundant - The first unprocessed token "instance".
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildNotAllInputParsedMessage(options: {
    firstRedundant: IToken;
    ruleName: string;
  }): string;
  /**
   * A No Viable Alternative Error happens when the parser cannot detect any valid alternative in an alternation.
   * It corresponds to a failed {@link BaseParser.OR} in Chevrotain DSL terms.
   *
   * @param options.expectedPathsPerAlt - First level of the array represents each alternative
   *                           The next two levels represent valid (expected) paths in each alternative.
   *
   * @param options.actual - The actual sequence of tokens encountered.
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.customUserDescription - A user may provide custom error message descriptor in the {@link BaseParser.AT_LEAST_ONE_SEP} DSL method
   *                                        options parameter, this is that custom message.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildNoViableAltMessage(options: {
    expectedPathsPerAlt: TokenType[][][];
    actual: IToken[];
    previous: IToken;
    customUserDescription?: string;
    ruleName: string;
  }): string;
  /**
   * An Early Exit Error happens when the parser cannot detect the first mandatory iteration of a repetition.
   * It corresponds to a failed {@link BaseParser.AT_LEAST_ONE_SEP} or {@link BaseParser.AT_LEAST_ONE_SEP} in Chevrotain DSL terms.
   *
   * @param options.expectedIterationPaths - The valid (expected) paths in the first iteration.
   *
   * @param options.actual - The actual sequence of tokens encountered.
   *
   * @param options.previous - The previous Token "instance".
   *                                This is useful if options.actual[0] is of type chevrotain.EOF and you need to know the last token parsed.
   *
   * @param options.customUserDescription - A user may provide custom error message descriptor in the {@link BaseParser.AT_LEAST_ONE_SEP} DSL method
   *                                        options parameter, this is that custom message.
   *
   * @param options.ruleName - The rule in which the error occurred.
   */
  buildEarlyExitMessage(options: {
    expectedIterationPaths: TokenType[][];
    actual: IToken[];
    previous: IToken;
    customUserDescription?: string;
    ruleName: string;
  }): string;
}

/**
 * @experimental
 */
interface ILookaheadStrategy {
  /**
   * Performs validations on the grammar specific to this lookahead strategy.
   * This method is not called if parser validations are disabled.
   *
   * @param options.rules All parser rules of the grammar.
   *
   * @param options.tokenTypes All token types of the grammar.
   *
   * @param options.grammarName The name of the grammar.
   */
  validate(options: {
    rules: Rule[];
    tokenTypes: TokenType[];
    grammarName: string;
  }): ILookaheadValidationError[];

  /**
   * Initializes the lookahead for a grammar.
   *
   * Note that this method does not build the lookahead functions.
   * It only initializes the internal state of the strategy based on all grammar rules.
   *
   * @param options.rules All parser rules of the grammar.
   */
  initialize?(options: { rules: Rule[] }): void;

  /**
   * Builds a lookahead function for alternations/`OR` parser methods.
   *
   * @param options.prodOccurrence The occurrence number of this `OR` within its rule.
   *
   * @param options.rule The rule that contains this `OR`.
   *
   * @param options.maxLookahead The maximum amount of lookahead for this `OR`.
   *
   * @param options.hasPredicates Whether any of the alternatives contain a predicate.
   *
   * @param options.dynamicTokensEnabled Whether dynamic tokens are enabled for this parser.
   *
   * @returns A function that is able to compute which of the alternatives to choose while parsing.
   */
  buildLookaheadForAlternation(options: {
    prodOccurrence: number;
    rule: Rule;
    maxLookahead: number;
    hasPredicates: boolean;
    dynamicTokensEnabled: boolean;
  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined;

  /**
   * Builds a lookahead function for optional productions.
   *
   * @param options.prodOccurrence The occurrence number of this production within its rule.
   *
   * @param options.prodType The type of this production.
   *
   * @param options.rule The rule that contains this production.
   *
   * @param options.maxLookahead The maximum amount of lookahead for this production.
   *
   * @param options.dynamicTokensEnabled Whether dynamic tokens are enabled for this parser.
   *
   * @returns A function is able to compute whether to parse the production or to continue with the rest of the parser rule.
   */
  buildLookaheadForOptional(options: {
    prodOccurrence: number;
    prodType: OptionalProductionType;
    rule: Rule;
    maxLookahead: number;
    dynamicTokensEnabled: boolean;
  }): () => boolean;
}

interface ILookaheadValidationError {
  message: string;
  ruleName?: string;
}

type OptionalProductionType =
  | "Option"
  | "RepetitionMandatory"
  | "RepetitionMandatoryWithSeparator"
  | "Repetition"
  | "RepetitionWithSeparator";

type LookaheadProductionType = OptionalProductionType | "Alternation";

interface IRecognizerContext {
  /**
   * A copy of the parser's rule stack at the "time" the RecognitionException occurred.
   * This can be used to help debug parsing errors (How did we get here?).
   */
  ruleStack: string[];
  /**
   * A copy of the parser's rule occurrence stack at the "time" the RecognitionException occurred.
   * This can be used to help debug parsing errors (How did we get here?).
   */
  ruleOccurrenceStack: number[];
}

interface ISerializedGast {
  type: ProductionType;
  definition?: ISerializedGast[];
}

type ProductionType =
  | LookaheadProductionType
  | "NonTerminal"
  | "Alternative"
  | "Terminal"
  | "Rule";

/**
 * Structure for the path the parser "took" to reach a certain position
 * in the grammar.
 */
interface IGrammarPath {
  /**
   * The Grammar rules invoked and still unterminated to reach this Grammar Path.
   */
  ruleStack: string[];
  /**
   * The occurrence index (SUBRULE1/2/3/5/...) of each Grammar rule invoked and still unterminated.
   * Used to distinguish between **different** invocations of the same subrule at the same top level rule.
   */
  occurrenceStack: number[];
}

interface ISyntacticContentAssistPath extends IGrammarPath {
  nextTokenType: TokenType;
  nextTokenOccurrence: number;
}

interface ITokenGrammarPath extends IGrammarPath {
  lastTok: TokenType;
  lastTokOccurrence: number;
}

/**
 * A Chevrotain Parser runtime exception.
 */
interface IRecognitionException extends Error {
  name: string;
  message: string;
  /**
   * The token which caused the parser error.
   */
  token: IToken;
  /**
   * Additional tokens which have been re-synced in error recovery due to the original error.
   * This information can be used the calculate the whole text area which has been skipped due to an error.
   * For example for displaying with a red underline in a text editor.
   */
  resyncedTokens: IToken[];
  context: IRecognizerContext;
}

interface IProduction {
  accept(visitor: IGASTVisitor): void;
}

/**
 * The Grammar AST class representing a top level {@link CstParser.RULE} or {@link EmbeddedActionsParser.RULE} call.
 */
declare class Rule {
  name: string;
  orgText: string;
  definition: IProduction[];

  constructor(options: {
    name: string;
    definition: IProduction[];
    orgText?: string;
  });

  accept(visitor: IGASTVisitor): void;
}

interface IGASTVisitor {
  visit(prod: IProduction): any;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface GrammarConfig {
    /**
     * Lists all rule names which are classified as multiline comment rules
     */
    multilineCommentRules: string[];
    /**
     * A regular expression which matches characters of names
     */
    nameRegexp: RegExp;
}

/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type AbstractRule = ParserRule | TerminalRule;
declare const AbstractRule = "AbstractRule";
type AbstractType = InferredType | Interface | ParserRule | Type;
declare const AbstractType = "AbstractType";
type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;
declare const Condition = "Condition";
type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;
type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';
type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;
declare const TypeDefinition = "TypeDefinition";
type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;
declare const ValueLiteral = "ValueLiteral";
interface AbstractElement extends AstNode {
    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';
    cardinality?: '*' | '+' | '?';
    lookahead?: '?!' | '?<!' | '?<=' | '?=';
}
declare const AbstractElement = "AbstractElement";
interface ArrayLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'ArrayLiteral';
    elements: Array<ValueLiteral>;
}
declare const ArrayLiteral = "ArrayLiteral";
interface ArrayType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ArrayType';
    elementType: TypeDefinition;
}
declare const ArrayType = "ArrayType";
interface BooleanLiteral extends AstNode {
    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;
    readonly $type: 'BooleanLiteral';
    true: boolean;
}
declare const BooleanLiteral = "BooleanLiteral";
interface Conjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Conjunction';
    left: Condition;
    right: Condition;
}
declare const Conjunction = "Conjunction";
interface Disjunction extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Disjunction';
    left: Condition;
    right: Condition;
}
declare const Disjunction = "Disjunction";
interface Grammar extends AstNode {
    readonly $type: 'Grammar';
    definesHiddenTokens: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    imports: Array<GrammarImport>;
    interfaces: Array<Interface>;
    isDeclared: boolean;
    name?: string;
    rules: Array<AbstractRule>;
    types: Array<Type>;
    usedGrammars: Array<Reference<Grammar>>;
}
declare const Grammar = "Grammar";
interface GrammarImport extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'GrammarImport';
    path: string;
}
declare const GrammarImport = "GrammarImport";
interface InferredType extends AstNode {
    readonly $container: Action | ParserRule;
    readonly $type: 'InferredType';
    name: string;
}
declare const InferredType = "InferredType";
interface Interface extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Interface';
    attributes: Array<TypeAttribute>;
    name: string;
    superTypes: Array<Reference<AbstractType>>;
}
declare const Interface = "Interface";
interface NamedArgument extends AstNode {
    readonly $container: RuleCall;
    readonly $type: 'NamedArgument';
    calledByName: boolean;
    parameter?: Reference<Parameter>;
    value: Condition;
}
declare const NamedArgument = "NamedArgument";
interface Negation extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'Negation';
    value: Condition;
}
declare const Negation = "Negation";
interface NumberLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'NumberLiteral';
    value: number;
}
declare const NumberLiteral = "NumberLiteral";
interface Parameter extends AstNode {
    readonly $container: ParserRule;
    readonly $type: 'Parameter';
    name: string;
}
declare const Parameter = "Parameter";
interface ParameterReference extends AstNode {
    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;
    readonly $type: 'ParameterReference';
    parameter: Reference<Parameter>;
}
declare const ParameterReference = "ParameterReference";
interface ParserRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'ParserRule';
    dataType?: PrimitiveType;
    definesHiddenTokens: boolean;
    definition: AbstractElement;
    entry: boolean;
    fragment: boolean;
    hiddenTokens: Array<Reference<AbstractRule>>;
    inferredType?: InferredType;
    name: string;
    parameters: Array<Parameter>;
    returnType?: Reference<AbstractType>;
    wildcard: boolean;
}
declare const ParserRule = "ParserRule";
interface ReferenceType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'ReferenceType';
    referenceType: TypeDefinition;
}
declare const ReferenceType = "ReferenceType";
interface ReturnType$1 extends AstNode {
    readonly $container: TerminalRule;
    readonly $type: 'ReturnType';
    name: PrimitiveType | string;
}
declare const ReturnType$1 = "ReturnType";
interface SimpleType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'SimpleType';
    primitiveType?: PrimitiveType;
    stringType?: string;
    typeRef?: Reference<AbstractType>;
}
declare const SimpleType = "SimpleType";
interface StringLiteral extends AstNode {
    readonly $container: ArrayLiteral | TypeAttribute;
    readonly $type: 'StringLiteral';
    value: string;
}
declare const StringLiteral = "StringLiteral";
interface TerminalRule extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'TerminalRule';
    definition: AbstractElement;
    fragment: boolean;
    hidden: boolean;
    name: string;
    type?: ReturnType$1;
}
declare const TerminalRule = "TerminalRule";
interface Type extends AstNode {
    readonly $container: Grammar;
    readonly $type: 'Type';
    name: string;
    type: TypeDefinition;
}
declare const Type = "Type";
interface TypeAttribute extends AstNode {
    readonly $container: Interface;
    readonly $type: 'TypeAttribute';
    defaultValue?: ValueLiteral;
    isOptional: boolean;
    name: FeatureName;
    type: TypeDefinition;
}
declare const TypeAttribute = "TypeAttribute";
interface UnionType extends AstNode {
    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;
    readonly $type: 'UnionType';
    types: Array<TypeDefinition>;
}
declare const UnionType = "UnionType";
interface Action extends AbstractElement {
    readonly $type: 'Action';
    feature?: FeatureName;
    inferredType?: InferredType;
    operator?: '+=' | '=';
    type?: Reference<AbstractType>;
}
declare const Action = "Action";
interface CharacterRange extends AbstractElement {
    readonly $type: 'CharacterRange';
    left: Keyword;
    right?: Keyword;
}
declare const CharacterRange = "CharacterRange";
interface CrossReference extends AbstractElement {
    readonly $type: 'CrossReference';
    deprecatedSyntax: boolean;
    terminal?: AbstractElement;
    type: Reference<AbstractType>;
}
declare const CrossReference = "CrossReference";
interface Group extends AbstractElement {
    readonly $type: 'Group';
    elements: Array<AbstractElement>;
    guardCondition?: Condition;
}
declare const Group = "Group";
interface Keyword extends AbstractElement {
    readonly $container: CharacterRange;
    readonly $type: 'Keyword';
    value: string;
}
declare const Keyword = "Keyword";
interface RuleCall extends AbstractElement {
    readonly $type: 'RuleCall';
    arguments: Array<NamedArgument>;
    rule: Reference<AbstractRule>;
}
declare const RuleCall = "RuleCall";

/**
 * A tagging type for string properties that are actually URIs.
 */
type DocumentUri = string;
/**
 * Position in a text document expressed as zero-based line and character offset.
 * The offsets are based on a UTF-16 string representation. So a string of the form
 * `að€b` the character offset of the character `a` is 0, the character offset of `ð€`
 * is 1 and the character offset of b is 3 since `ð€` is represented using two code
 * units in UTF-16.
 *
 * Positions are line end character agnostic. So you can not specify a position that
 * denotes `\r|\n` or `\n|` where `|` represents the character offset.
 */
interface Position {
    /**
     * Line position in a document (zero-based).
     *
     * If a line number is greater than the number of lines in a document, it
     * defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     *
     * The above two properties are implementation specific.
     */
    line: number;
    /**
     * Character offset on a line in a document (zero-based).
     *
     * The meaning of this offset is determined by the negotiated
     * `PositionEncodingKind`.
     *
     * If the character value is greater than the line length it defaults back
     * to the line length. This property is implementation specific.
     */
    character: number;
}
/**
 * A range in a text document expressed as (zero-based) start and end positions.
 *
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
interface Range {
    /**
     * The range's start position.
     */
    start: Position;
    /**
     * The range's end position.
     */
    end: Position;
}
/**
 * A text edit applicable to a text document.
 */
interface TextEdit {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: Range;
    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
}
/**
 * An event describing a change to a text document. If range and rangeLength are omitted
 * the new text is considered to be the full content of the document.
 */
type TextDocumentContentChangeEvent$1 = {
    /**
     * The range of the document that changed.
     */
    range: Range;
    /**
     * The optional length of the range that got replaced.
     *
     * @deprecated use range instead.
     */
    rangeLength?: number;
    /**
     * The new text for the provided range.
     */
    text: string;
} | {
    /**
     * The new text of the whole document.
     */
    text: string;
};
/**
 * A simple text document. Not to be implemented. The document keeps the content
 * as string.
 */
interface TextDocument {
    /**
     * The associated URI for this document. Most documents have the __file__-scheme, indicating that they
     * represent files on disk. However, some documents may have other schemes indicating that they are not
     * available on disk.
     *
     * @readonly
     */
    readonly uri: DocumentUri;
    /**
     * The identifier of the language associated with this document.
     *
     * @readonly
     */
    readonly languageId: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     *
     * @readonly
     */
    readonly version: number;
    /**
     * Get the text of this document. A substring can be retrieved by
     * providing a range.
     *
     * @param range (optional) An range within the document to return.
     * If no range is passed, the full content is returned.
     * Invalid range positions are adjusted as described in {@link Position.line}
     * and {@link Position.character}.
     * If the start range position is greater than the end range position,
     * then the effect of getText is as if the two positions were swapped.

     * @return The text of this document or a substring of the text if a
     *         range is provided.
     */
    getText(range?: Range): string;
    /**
     * Converts a zero-based offset to a position.
     *
     * @param offset A zero-based offset.
     * @return A valid {@link Position position}.
     * @example The text document "ab\ncd" produces:
     * * position { line: 0, character: 0 } for `offset` 0.
     * * position { line: 0, character: 1 } for `offset` 1.
     * * position { line: 0, character: 2 } for `offset` 2.
     * * position { line: 1, character: 0 } for `offset` 3.
     * * position { line: 1, character: 1 } for `offset` 4.
     */
    positionAt(offset: number): Position;
    /**
     * Converts the position to a zero-based offset.
     * Invalid positions are adjusted as described in {@link Position.line}
     * and {@link Position.character}.
     *
     * @param position A position.
     * @return A valid zero-based offset.
     */
    offsetAt(position: Position): number;
    /**
     * The number of lines in this document.
     *
     * @readonly
     */
    readonly lineCount: number;
}
declare namespace TextDocument {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri: DocumentUri, languageId: string, version: number, content: string): TextDocument;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document: TextDocument, changes: TextDocumentContentChangeEvent$1[], version: number): TextDocument;
    function applyEdits(document: TextDocument, edits: TextEdit[]): string;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface FileSystemNode {
    readonly isFile: boolean;
    readonly isDirectory: boolean;
    readonly uri: URI$1;
}
/**
 * Provides methods to interact with an abstract file system. The default implementation is based on the node.js `fs` API.
 */
interface FileSystemProvider$1 {
    /**
     * Reads a document asynchronously from a given URI.
     * @returns The string content of the file with the specified URI.
     */
    readFile(uri: URI$1): Promise<string>;
    /**
     * Reads the directory information for the given URI.
     * @returns The list of file system entries that are contained within the specified directory.
     */
    readDirectory(uri: URI$1): Promise<FileSystemNode[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * A stream is a read-only sequence of values. While the contents of an array can be accessed
 * both sequentially and randomly (via index), a stream allows only sequential access.
 *
 * The advantage of this is that a stream can be evaluated lazily, so it does not require
 * to store intermediate values. This can boost performance when a large sequence is
 * processed via filtering, mapping etc. and accessed at most once. However, lazy
 * evaluation means that all processing is repeated when you access the sequence multiple
 * times; in such a case, it may be better to store the resulting sequence into an array.
 */
interface Stream<T> extends Iterable<T> {
    /**
     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.
     */
    iterator(): IterableIterator<T>;
    /**
     * Determines whether this stream contains no elements.
     */
    isEmpty(): boolean;
    /**
     * Determines the number of elements in this stream.
     */
    count(): number;
    /**
     * Collects all elements of this stream into an array.
     */
    toArray(): T[];
    /**
     * Collects all elements of this stream into a Set.
     */
    toSet(): Set<T>;
    /**
     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.
     *
     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.
     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.
     */
    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;
    /**
     * Returns a string representation of a stream.
     */
    toString(): string;
    /**
     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.
     *
     * @param other Stream to be concatenated with this one.
     */
    concat<T2>(other: Iterable<T2>): Stream<T | T2>;
    /**
     * Adds all elements of the stream into a string, separated by the specified separator string.
     *
     * @param separator A string used to separate one element of the stream from the next in the resulting string.
     *        If omitted, the steam elements are separated with a comma.
     */
    join(separator?: string): string;
    /**
     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.
     *
     * @param searchElement The value to locate in the array.
     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search
     *        starts at index 0.
     */
    indexOf(searchElement: T, fromIndex?: number): number;
    /**
     * Determines whether all members of the stream satisfy the specified test.
     *
     * @param predicate This method calls the predicate function for each element in the stream until the
     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end
     *        of the stream.
     */
    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;
    every(predicate: (value: T) => unknown): boolean;
    /**
     * Determines whether any member of the stream satisfies the specified test.
     *
     * @param predicate This method calls the predicate function for each element in the stream until the
     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end
     *        of the stream.
     */
    some(predicate: (value: T) => unknown): boolean;
    /**
     * Performs the specified action for each element in the stream.
     *
     * @param callbackfn Function called once for each element in the stream.
     */
    forEach(callbackfn: (value: T, index: number) => void): void;
    /**
     * Returns a stream that yields the results of calling the specified callback function on each element
     * of the stream. The function is called when the resulting stream elements are actually accessed, so
     * accessing the resulting stream multiple times means the function is also called multiple times for
     * each element of the stream.
     *
     * @param callbackfn Lazily evaluated function mapping stream elements.
     */
    map<U>(callbackfn: (value: T) => U): Stream<U>;
    /**
     * Returns the elements of the stream that meet the condition specified in a callback function.
     * The function is called when the resulting stream elements are actually accessed, so accessing the
     * resulting stream multiple times means the function is also called multiple times for each element
     * of the stream.
     *
     * @param predicate Lazily evaluated function checking a condition on stream elements.
     */
    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;
    filter(predicate: (value: T) => unknown): Stream<T>;
    /**
     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`
     * nor `null`.
     */
    nonNullable(): Stream<NonNullable<T>>;
    /**
     * Calls the specified callback function for all elements in the stream. The return value of the
     * callback function is the accumulated result, and is provided as an argument in the next call to
     * the callback function.
     *
     * @param callbackfn This method calls the function once for each element in the stream, providing
     *        the previous and current values of the reduction.
     * @param initialValue If specified, `initialValue` is used as the initial value to start the
     *        accumulation. The first call to the function provides this value as an argument instead
     *        of a stream value.
     */
    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;
    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;
    /**
     * Calls the specified callback function for all elements in the stream, in descending order.
     * The return value of the callback function is the accumulated result, and is provided as an
     * argument in the next call to the callback function.
     *
     * @param callbackfn This method calls the function once for each element in the stream, providing
     *        the previous and current values of the reduction.
     * @param initialValue If specified, `initialValue` is used as the initial value to start the
     *        accumulation. The first call to the function provides this value as an argument instead
     *        of an array value.
     */
    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;
    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;
    /**
     * Returns the value of the first element in the stream that meets the condition, or `undefined`
     * if there is no such element.
     *
     * @param predicate This method calls `predicate` once for each element of the stream, in ascending
     *        order, until it finds one where `predicate` returns a value which is coercible to the
     *        Boolean value `true`.
     */
    find<S extends T>(predicate: (value: T) => value is S): S | undefined;
    find(predicate: (value: T) => unknown): T | undefined;
    /**
     * Returns the index of the first element in the stream that meets the condition, or `-1`
     * if there is no such element.
     *
     * @param predicate This method calls `predicate` once for each element of the stream, in ascending
     *        order, until it finds one where `predicate` returns a value which is coercible to the
     *        Boolean value `true`.
     */
    findIndex(predicate: (value: T) => unknown): number;
    /**
     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.
     *
     * @param searchElement The element to search for.
     */
    includes(searchElement: T): boolean;
    /**
     * Calls a defined callback function on each element of the stream and then flattens the result into
     * a new stream. This is identical to a `map` followed by `flat` with depth 1.
     *
     * @param callbackfn Lazily evaluated function mapping stream elements.
     */
    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;
    /**
     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up
     * to the specified depth.
     *
     * @param depth The maximum recursion depth. Defaults to 1.
     */
    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;
    /**
     * Returns the first element in the stream, or `undefined` if the stream is empty.
     */
    head(): T | undefined;
    /**
     * Returns a stream that skips the first `skipCount` elements from this stream.
     *
     * @param skipCount The number of elements to skip. If this is larger than the number of elements in
     *        the stream, an empty stream is returned. Defaults to 1.
     */
    tail(skipCount?: number): Stream<T>;
    /**
     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`
     * in length.
     *
     * @param maxSize The number of elements the stream should be limited to
     */
    limit(maxSize: number): Stream<T>;
    /**
     * Returns a stream containing only the distinct elements from this stream.
     * Equality is determined with the same rules as a standard `Set`.
     *
     * @param by A function returning the key used to check equality with a previous stream element.
     *        If omitted, the stream elements themselves are used for comparison.
     */
    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;
    /**
     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.
     * Equality is determined with the same rules as a standard `Set`.
     * @param other The elements that should be exluded from this stream.
     * @param key A function returning the key used to check quality.
     *        If omitted, the stream elements themselves are used for comparison.
     */
    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;
}
type FlatStream<T, Depth extends number> = {
    'done': Stream<T>;
    'recur': T extends Iterable<infer Content> ? FlatStream<Content, MinusOne<Depth>> : Stream<T>;
}[Depth extends 0 ? 'done' : 'recur'];
type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface TokenBuilderOptions {
    caseInsensitive?: boolean;
}
interface TokenBuilder {
    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary;
    /**
     * Produces a lexing report for the given text that was just tokenized using the tokens provided by this builder.
     *
     * @param text The text that was tokenized.
     */
    flushLexingReport?(text: string): LexingReport;
}
/**
 * A custom lexing report that can be produced by the token builder during the lexing process.
 * Adopters need to ensure that the any custom fields are serializable so they can be sent across worker threads.
 */
interface LexingReport {
    diagnostics: LexingDiagnostic[];
}
type LexingDiagnosticSeverity = 'error' | 'warning' | 'info' | 'hint';
interface LexingDiagnostic extends ILexingError {
    severity?: LexingDiagnosticSeverity;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface LexerResult {
    /**
     * A list of all tokens that were lexed from the input.
     *
     * Note that Langium requires the optional properties
     * `startLine`, `startColumn`, `endOffset`, `endLine` and `endColumn` to be set on each token.
     */
    tokens: IToken[];
    /**
     * Contains hidden tokens, usually comments.
     */
    hidden: IToken[];
    errors: ILexingError[];
    report?: LexingReport;
}
type TokenizeMode = 'full' | 'partial';
interface TokenizeOptions {
    mode?: TokenizeMode;
}
interface Lexer {
    readonly definition: TokenTypeDictionary;
    tokenize(text: string, options?: TokenizeOptions): LexerResult;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type ParseResult<T = AstNode> = {
    value: T;
    parserErrors: IRecognitionException[];
    lexerErrors: ILexingError[];
    lexerReport?: LexingReport;
};
type RuleResult = (args: Args) => any;
type Args = Record<string, boolean>;
type RuleImpl = (args: Args) => any;
/**
 * Base interface for all parsers. Mainly used by the `parser-builder-base.ts` to perform work on different kinds of parsers.
 * The main use cases are:
 * * AST parser: Based on a string, create an AST for the current grammar
 * * Completion parser: Based on a partial string, identify the current position of the input within the grammar
 */
interface BaseParser$1 {
    /**
     * Adds a new parser rule to the parser
     */
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    /**
     * Returns the executable rule function for the specified rule name
     */
    getRule(name: string): RuleResult | undefined;
    /**
     * Performs alternatives parsing (the `|` operation in EBNF/Langium)
     */
    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;
    /**
     * Parses the callback as optional (the `?` operation in EBNF/Langium)
     */
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Parses the callback 0 or more times (the `*` operation in EBNF/Langium)
     */
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Parses the callback 1 or more times (the `+` operation in EBNF/Langium)
     */
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    /**
     * Consumes a specific token type from the token input stream.
     * Requires a unique index within the rule for a specific token type.
     */
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    /**
     * Invokes the executable function for a given parser rule.
     * Requires a unique index within the rule for a specific sub rule.
     * Arguments can be supplied to the rule invocation for semantic predicates
     */
    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    /**
     * Executes a grammar action that modifies the currently active AST node
     */
    action($type: string, action: Action): void;
    /**
     * Whether the parser is currently actually in use or in "recording mode".
     * Recording mode is activated once when the parser is analyzing itself.
     * During this phase, no input exists and therefore no AST should be constructed
     */
    isRecording(): boolean;
    /**
     * Current state of the unordered groups
     */
    get unorderedGroups(): Map<string, boolean[]>;
    /**
     * The rule stack indicates the indices of rules that are currently invoked,
     * in order of their invocation.
     */
    getRuleStack(): number[];
}
declare abstract class AbstractLangiumParser implements BaseParser$1 {
    protected readonly lexer: Lexer;
    protected readonly wrapper: ChevrotainWrapper;
    protected _unorderedGroups: Map<string, boolean[]>;
    protected allRules: Map<string, RuleResult>;
    protected mainRule: RuleResult;
    constructor(services: LangiumCoreServices);
    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;
    optional(idx: number, callback: DSLMethodOpts<unknown>): void;
    many(idx: number, callback: DSLMethodOpts<unknown>): void;
    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
    abstract rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    abstract consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    abstract subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    abstract action($type: string, action: Action): void;
    getRule(name: string): RuleResult | undefined;
    isRecording(): boolean;
    get unorderedGroups(): Map<string, boolean[]>;
    getRuleStack(): number[];
    finalize(): void;
}
interface ParserOptions {
    rule?: string;
}
declare class LangiumParser extends AbstractLangiumParser {
    private readonly linker;
    private readonly converter;
    private readonly astReflection;
    private readonly nodeBuilder;
    private lexerResult?;
    private stack;
    private assignmentMap;
    private get current();
    constructor(services: LangiumCoreServices);
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    private computeRuleType;
    parse<T extends AstNode = AstNode>(input: string, options?: ParserOptions): ParseResult<T>;
    private doParse;
    private startImplementation;
    private extractHiddenTokens;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    /**
     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
     *
     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
     */
    private isValidToken;
    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    private performSubruleAssignment;
    action($type: string, action: Action): void;
    private construct;
    private getAssignment;
    private assign;
    private assignWithoutOverride;
    get definitionErrors(): IParserDefinitionError[];
}
interface IParserDefinitionError {
    message: string;
    type: number;
    ruleName?: string;
}
interface CompletionParserResult {
    tokens: IToken[];
    elementStack: AbstractElement[];
    tokenIndex: number;
}
declare class LangiumCompletionParser extends AbstractLangiumParser {
    private tokens;
    private elementStack;
    private lastElementStack;
    private nextTokenIndex;
    private stackSize;
    action(): void;
    construct(): unknown;
    parse(input: string): CompletionParserResult;
    rule(rule: ParserRule, impl: RuleImpl): RuleResult;
    private resetState;
    private startImplementation;
    private removeUnexpectedElements;
    keepStackSize(): number;
    resetStackSize(size: number): void;
    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;
    subrule(idx: number, rule: RuleResult, fragment: boolean, feature: AbstractElement, args: Args): void;
    before(element: AbstractElement): void;
    after(element: AbstractElement): void;
    get currIdx(): number;
}
/**
 * This class wraps the embedded actions parser of chevrotain and exposes protected methods.
 * This way, we can build the `LangiumParser` as a composition.
 */
declare class ChevrotainWrapper extends EmbeddedActionsParser {
    definitionErrors: IParserDefinitionError[];
    constructor(tokens: TokenVocabulary, config: IParserConfig);
    get IS_RECORDING(): boolean;
    DEFINE_RULE(name: string, impl: RuleImpl, config?: IRuleConfig<any>): RuleResult;
    wrapSelfAnalysis(): void;
    wrapConsume(idx: number, tokenType: TokenType): IToken;
    wrapSubrule(idx: number, rule: RuleResult, args: Args): unknown;
    wrapOr(idx: number, choices: Array<IOrAlt<any>>): void;
    wrapOption(idx: number, callback: DSLMethodOpts<unknown>): void;
    wrapMany(idx: number, callback: DSLMethodOpts<unknown>): void;
    wrapAtLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The service registry provides access to the language-specific {@link LangiumCoreServices} optionally including LSP-related services.
 * These are resolved via the URI of a text document.
 */
interface ServiceRegistry {
    /**
     * Register a language via its injected services.
     */
    register(language: LangiumCoreServices): void;
    /**
     * Retrieve the language-specific services for the given URI. In case only one language is
     * registered, it may be used regardless of the URI format.
     */
    getServices(uri: URI$1): LangiumCoreServices;
    /**
     * Check whether services are available for the given URI.
     */
    hasServices(uri: URI$1): boolean;
    /**
     * The full set of registered language services.
     */
    readonly all: readonly LangiumCoreServices[];
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A multimap is a variation of a Map that has potentially multiple values for every key.
 */
declare class MultiMap<K, V> {
    private map;
    constructor();
    constructor(elements: Array<[K, V]>);
    /**
     * The total number of values in the multimap.
     */
    get size(): number;
    /**
     * Clear all entries in the multimap.
     */
    clear(): void;
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method deletes the specific key / value pair from the multimap.
     *  * Without a value, all values associated with the given key are deleted.
     *
     * @returns `true` if a value existed and has been removed, or `false` if the specified
     *     key / value does not exist.
     */
    delete(key: K, value?: V): boolean;
    /**
     * Returns an array of all values associated with the given key. If no value exists,
     * an empty array is returned.
     *
     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
     * value and `delete` to remove a value from the multimap.
     */
    get(key: K): readonly V[];
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
     *  * Without a value, this method returns `true` if the given key is present in the multimap.
     */
    has(key: K, value?: V): boolean;
    /**
     * Add the given key / value pair to the multimap.
     */
    add(key: K, value: V): this;
    /**
     * Add the given set of key / value pairs to the multimap.
     */
    addAll(key: K, values: Iterable<V>): this;
    /**
     * Invokes the given callback function for every key / value pair in the multimap.
     */
    forEach(callbackfn: (value: V, key: K, map: this) => void): void;
    /**
     * Returns an iterator of key, value pairs for every entry in the map.
     */
    [Symbol.iterator](): Iterator<[K, V]>;
    /**
     * Returns a stream of key, value pairs for every entry in the map.
     */
    entries(): Stream<[K, V]>;
    /**
     * Returns a stream of keys in the map.
     */
    keys(): Stream<K>;
    /**
     * Returns a stream of values in the map.
     */
    values(): Stream<V>;
    /**
     * Returns a stream of key, value set pairs for every key in the map.
     */
    entriesGroupedByKey(): Stream<[K, V[]]>;
}

interface Disposable$2 {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare namespace Disposable$2 {
    function create(func: () => void): Disposable$2;
}

/**
 * Represents a typed event.
 */
interface Event<T> {
    /**
     *
     * @param listener The listener function will be called when the event happens.
     * @param thisArgs The 'this' which will be used when calling the event listener.
     * @param disposables An array to which a {{IDisposable}} will be added.
     * @return
    */
    (listener: (e: T) => any, thisArgs?: any, disposables?: Disposable$2[]): Disposable$2;
}
declare namespace Event {
    const None: Event<any>;
}

/**
 * Defines a CancellationToken. This interface is not
 * intended to be implemented. A CancellationToken must
 * be created via a CancellationTokenSource.
 */
interface CancellationToken$1 {
    /**
     * Is `true` when the token has been cancelled, `false` otherwise.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An {@link Event event} which fires upon cancellation.
     */
    readonly onCancellationRequested: Event<any>;
}
declare namespace CancellationToken$1 {
    const None: CancellationToken$1;
    const Cancelled: CancellationToken$1;
    function is(value: any): value is CancellationToken$1;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,
 *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,
 *  the overhead is very small, just a few kilobytes.
 * Everything else of that package (at the time contributing) is also defined
 *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.
 */

/**
 * A Langium document holds the parse result (AST and CST) and any additional state that is derived
 * from the AST, e.g. the result of scope precomputation.
 */
interface LangiumDocument<T extends AstNode = AstNode> {
    /** The Uniform Resource Identifier (URI) of the document */
    readonly uri: URI$1;
    /** The text document used to convert between offsets and positions */
    readonly textDocument: TextDocument;
    /** The current state of the document */
    state: DocumentState;
    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */
    parseResult: ParseResult<T>;
    /** Result of the scope precomputation phase */
    precomputedScopes?: PrecomputedScopes;
    /** An array of all cross-references found in the AST while linking */
    references: Reference[];
    /** Result of the validation phase */
    diagnostics?: Diagnostic[];
}
/**
 * A document is subject to several phases that are run in predefined order. Any state value implies that
 * smaller state values are finished as well.
 */
declare enum DocumentState {
    /**
     * The text content has changed and needs to be parsed again. The AST held by this outdated
     * document instance is no longer valid.
     */
    Changed = 0,
    /**
     * An AST has been created from the text content. The document structure can be traversed,
     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated
     * at this stage as a preprocessing step.
     */
    Parsed = 1,
    /**
     * The `IndexManager` service has processed AST nodes of this document. This means the
     * exported symbols are available in the global scope and can be resolved from other documents.
     */
    IndexedContent = 2,
    /**
     * The `ScopeComputation` service has processed this document. This means the local symbols
     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.
     * Once a document has reached this state, you may follow every reference - it will lazily
     * resolve its `ref` property and yield either the target AST node or `undefined` in case
     * the target is not in scope.
     */
    ComputedScopes = 3,
    /**
     * The `Linker` service has processed this document. All outgoing references have been
     * resolved or marked as erroneous.
     */
    Linked = 4,
    /**
     * The `IndexManager` service has processed AST node references of this document. This is
     * necessary to determine which documents are affected by a change in one of the workspace
     * documents.
     */
    IndexedReferences = 5,
    /**
     * The `DocumentValidator` service has processed this document. The language server listens
     * to the results of this phase and sends diagnostics to the client.
     */
    Validated = 6
}
/**
 * Result of the scope precomputation phase (`ScopeComputation` service).
 * It maps every AST node to the set of symbols that are visible in the subtree of that node.
 */
type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>;
interface DocumentSegment {
    readonly range: Range$1;
    readonly offset: number;
    readonly length: number;
    readonly end: number;
}
/**
 * Surrogate definition of the `TextDocuments` interface from the `vscode-languageserver` package.
 * No implementation object is expected to be offered by `LangiumCoreServices`, but only by `LangiumLSPServices`.
 */
type TextDocumentProvider = {
    get(uri: string | URI$1): TextDocument | undefined;
};
/**
 * Shared service for creating `LangiumDocument` instances.
 *
 * Register a custom implementation if special (additional) behavior is required for your language(s).
 * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to
 * specialize {@link update}, too!
 */
interface LangiumDocumentFactory {
    /**
     * Create a Langium document from a `TextDocument` (usually associated with a file).
     */
    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI$1, options?: ParserOptions): LangiumDocument<T>;
    /**
     * Create a Langium document from a `TextDocument` asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.
     */
    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI$1 | undefined, cancellationToken: CancellationToken$1): Promise<LangiumDocument<T>>;
    /**
     * Create an Langium document from an in-memory string.
     */
    fromString<T extends AstNode = AstNode>(text: string, uri: URI$1, options?: ParserOptions): LangiumDocument<T>;
    /**
     * Create a Langium document from an in-memory string asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.
     */
    fromString<T extends AstNode = AstNode>(text: string, uri: URI$1, cancellationToken: CancellationToken$1): Promise<LangiumDocument<T>>;
    /**
     * Create an Langium document from a model that has been constructed in memory.
     */
    fromModel<T extends AstNode = AstNode>(model: T, uri: URI$1): LangiumDocument<T>;
    /**
     * Create an Langium document from a specified `URI`. The factory will use the `FileSystemAccess` service to read the file.
     */
    fromUri<T extends AstNode = AstNode>(uri: URI$1, cancellationToken?: CancellationToken$1): Promise<LangiumDocument<T>>;
    /**
     * Update the given document after changes in the corresponding textual representation.
     * Method is called by the document builder after it has been requested to build an existing
     * document and the document's state is {@link DocumentState.Changed}.
     * The text parsing is expected to be done the same way as in {@link fromTextDocument}
     * and {@link fromString}.
     */
    update<T extends AstNode = AstNode>(document: LangiumDocument<T>, cancellationToken: CancellationToken$1): Promise<LangiumDocument<T>>;
}
/**
 * Shared service for managing Langium documents.
 */
interface LangiumDocuments$1 {
    /**
     * A stream of all documents managed under this service.
     */
    readonly all: Stream<LangiumDocument>;
    /**
     * Manage a new document under this service.
     * @throws an error if a document with the same URI is already present.
     */
    addDocument(document: LangiumDocument): void;
    /**
     * Retrieve the document with the given URI, if present. Otherwise returns `undefined`.
     */
    getDocument(uri: URI$1): LangiumDocument | undefined;
    /**
     * Retrieve the document with the given URI. If not present, a new one will be created using the file system access.
     * The new document will be added to the list of documents managed under this service.
     */
    getOrCreateDocument(uri: URI$1, cancellationToken?: CancellationToken$1): Promise<LangiumDocument>;
    /**
     * Creates a new document with the given URI and text content.
     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.
     *
     * @throws an error if a document with the same URI is already present.
     */
    createDocument(uri: URI$1, text: string): LangiumDocument;
    /**
     * Creates a new document with the given URI and text content asynchronously.
     * The process can be interrupted with a cancellation token.
     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.
     *
     * @throws an error if a document with the same URI is already present.
     */
    createDocument(uri: URI$1, text: string, cancellationToken: CancellationToken$1): Promise<LangiumDocument>;
    /**
     * Returns `true` if a document with the given URI is managed under this service.
     */
    hasDocument(uri: URI$1): boolean;
    /**
     * Flag the document with the given URI as `Changed`, if present, meaning that its content
     * is no longer valid. The content (parseResult) stays untouched, while internal data may
     * be dropped to reduce memory footprint.
     *
     * @returns the affected {@link LangiumDocument} if existing for convenience
     */
    invalidateDocument(uri: URI$1): LangiumDocument | undefined;
    /**
     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning
     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same
     * URI will create a new document instance.
     *
     * @returns the affected {@link LangiumDocument} if existing for convenience
     */
    deleteDocument(uri: URI$1): LangiumDocument | undefined;
}
declare class DefaultLangiumDocuments implements LangiumDocuments$1 {
    protected readonly langiumDocumentFactory: LangiumDocumentFactory;
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly documentMap: Map<string, LangiumDocument>;
    constructor(services: LangiumSharedCoreServices);
    get all(): Stream<LangiumDocument>;
    addDocument(document: LangiumDocument): void;
    getDocument(uri: URI$1): LangiumDocument | undefined;
    getOrCreateDocument(uri: URI$1, cancellationToken?: CancellationToken$1): Promise<LangiumDocument>;
    createDocument(uri: URI$1, text: string): LangiumDocument;
    createDocument(uri: URI$1, text: string, cancellationToken: CancellationToken$1): Promise<LangiumDocument>;
    hasDocument(uri: URI$1): boolean;
    invalidateDocument(uri: URI$1): LangiumDocument | undefined;
    deleteDocument(uri: URI$1): LangiumDocument | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A node in the Abstract Syntax Tree (AST).
 */
interface AstNode {
    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */
    readonly $type: string;
    /** The container node in the AST; every node except the root node has a container. */
    readonly $container?: AstNode;
    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */
    readonly $containerProperty?: string;
    /** In case `$containerProperty` is an array, the array index is stored here. */
    readonly $containerIndex?: number;
    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */
    readonly $cstNode?: CstNode;
    /** The document containing the AST; only the root node has a direct reference to the document. */
    readonly $document?: LangiumDocument;
}
type SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;
/**
 * The property names of a given AST node type.
 */
type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>;
/**
 * A cross-reference in the AST. Cross-references may or may not be successfully resolved.
 */
interface Reference<T extends AstNode = AstNode> {
    /**
     * The target AST node of this reference. Accessing this property may trigger cross-reference
     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,
     * the value is `undefined`.
     */
    readonly ref?: T;
    /** If any problem occurred while resolving the reference, it is described by this property. */
    readonly error?: LinkingError;
    /** The CST node from which the reference was parsed */
    readonly $refNode?: CstNode;
    /** The actual text used to look up in the surrounding scope */
    readonly $refText: string;
    /** The node description for the AstNode returned by `ref`  */
    readonly $nodeDescription?: AstNodeDescription;
}
/**
 * A description of an AST node is used when constructing scopes and looking up cross-reference targets.
 */
interface AstNodeDescription {
    /** The target node; should be present only for local references (linking to the same document). */
    node?: AstNode;
    /**
     * The document segment that represents the range of the name of the AST node.
     */
    nameSegment?: DocumentSegment;
    /**
     * The document segment that represents the full range of the AST node.
     */
    selectionSegment?: DocumentSegment;
    /** `$type` property value of the AST node */
    type: string;
    /** Name of the AST node; this is usually determined by the `NameProvider` service. */
    name: string;
    /** URI to the document containing the AST node */
    documentUri: URI$1;
    /** Navigation path inside the document */
    path: string;
}
/**
 * Information about a cross-reference. This is used when traversing references in an AST or to describe
 * unresolved references.
 */
interface ReferenceInfo {
    reference: Reference;
    container: AstNode;
    property: string;
    index?: number;
}
/**
 * Used to collect information when the `Linker` service fails to resolve a cross-reference.
 */
interface LinkingError extends ReferenceInfo {
    message: string;
    targetDescription?: AstNodeDescription;
}
/**
 * Service used for generic access to the structure of the AST. This service is shared between
 * all involved languages, so it operates on the superset of types of these languages.
 */
interface AstReflection {
    getAllTypes(): string[];
    getAllSubTypes(type: string): string[];
    getReferenceType(refInfo: ReferenceInfo): string;
    getTypeMetaData(type: string): TypeMetaData;
    isInstance(node: unknown, type: string): boolean;
    isSubtype(subtype: string, supertype: string): boolean;
}
/**
 * Represents runtime meta data about a meta model type.
 */
interface TypeMetaData {
    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */
    name: string;
    /** A list of properties. They can contain default values for their respective property in the AST. */
    properties: TypeProperty[];
}
/**
 * Describes the meta data of a property of an AST node.
 *
 * The optional `defaultValue` indicates that the property is mandatory in the AST node.
 * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.
 */
interface TypeProperty {
    name: string;
    defaultValue?: PropertyType;
}
/**
 * Represents a default value for an AST property.
 */
type PropertyType = number | string | boolean | PropertyType[];
/**
 * A node in the Concrete Syntax Tree (CST).
 */
interface CstNode extends DocumentSegment {
    /** The container node in the CST */
    readonly container?: CompositeCstNode;
    /** @deprecated use `container` instead. */
    readonly parent?: CompositeCstNode;
    /** The actual text */
    readonly text: string;
    /** The root CST node */
    readonly root: RootCstNode;
    /** The grammar element from which this node was parsed */
    readonly grammarSource?: AbstractElement;
    /** @deprecated use `grammarSource` instead. */
    readonly feature?: AbstractElement;
    /** The AST node created from this CST node */
    readonly astNode: AstNode;
    /** @deprecated use `astNode` instead. */
    readonly element: AstNode;
    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */
    readonly hidden: boolean;
}
/**
 * A composite CST node contains other nodes, but no directly associated token.
 */
interface CompositeCstNode extends CstNode {
    readonly content: CstNode[];
    /** @deprecated use `content` instead. */
    readonly children: CstNode[];
}
interface RootCstNode extends CompositeCstNode {
    readonly fullText: string;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provides comments for AST nodes.
 */
interface CommentProvider {
    /**
     * Returns the comment associated with the specified AST node.
     * @param node The AST node to get the comment for.
     * @returns The comment associated with the specified AST node or `undefined` if there is no comment.
     */
    getComment(node: AstNode): string | undefined;
}

interface AsyncDisposable {
    /**
     * Dispose this object.
     */
    dispose(): Promise<void>;
}
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
interface Disposable$1 {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare namespace Disposable$1 {
    function create(callback: () => Promise<void>): AsyncDisposable;
    function create(callback: () => void): Disposable$1;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

declare abstract class DisposableCache implements Disposable$1 {
    protected toDispose: Disposable$1[];
    protected isDisposed: boolean;
    onDispose(disposable: Disposable$1): void;
    dispose(): void;
    protected throwIfDisposed(): void;
    abstract clear(): void;
}
declare class SimpleCache<K, V> extends DisposableCache {
    protected readonly cache: Map<K, V>;
    has(key: K): boolean;
    set(key: K, value: V): void;
    get(key: K): V | undefined;
    get(key: K, provider: () => V): V;
    delete(key: K): boolean;
    clear(): void;
}
declare class ContextCache<Context, Key, Value, ContextKey = Context> extends DisposableCache {
    private readonly cache;
    private readonly converter;
    constructor(converter?: (input: Context) => ContextKey);
    has(contextKey: Context, key: Key): boolean;
    set(contextKey: Context, key: Key, value: Value): void;
    get(contextKey: Context, key: Key): Value | undefined;
    get(contextKey: Context, key: Key, provider: () => Value): Value;
    delete(contextKey: Context, key: Key): boolean;
    clear(): void;
    clear(contextKey: Context): void;
    protected cacheForContext(contextKey: Context): Map<Key, Value>;
}
/**
 * Every key/value pair in this cache is scoped to the whole workspace.
 * If any document in the workspace is added, changed or deleted, the whole cache is evicted.
 */
declare class WorkspaceCache<K, V> extends SimpleCache<K, V> {
    /**
     * Creates a new workspace cache.
     *
     * @param sharedServices Service container instance to hook into document lifecycle events.
     * @param state Optional document state on which the cache should evict.
     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
     * *Deleted* documents are considered in both cases.
     */
    constructor(sharedServices: LangiumSharedCoreServices, state?: DocumentState);
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Utility service for retrieving the `name` of an `AstNode` or the `CstNode` containing a `name`.
 */
interface NameProvider {
    /**
     * Returns the `name` of a given AstNode.
     * @param node Specified `AstNode` whose name node shall be retrieved.
     */
    getName(node: AstNode): string | undefined;
    /**
     * Returns the `CstNode` which contains the parsed value of the `name` assignment.
     * @param node Specified `AstNode` whose name node shall be retrieved.
     */
    getNameNode(node: AstNode): CstNode | undefined;
}
declare class DefaultNameProvider implements NameProvider {
    getName(node: AstNode): string | undefined;
    getNameNode(node: AstNode): CstNode | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for locating an `AstNode` in a document.
 */
interface AstNodeLocator {
    /**
     * Creates a path represented by a `string` that identifies an `AstNode` inside its document.
     * It must be possible to retrieve exactly the same `AstNode` from the document using this path.
     *
     * @param node The `AstNode` for which to create the path.
     * @returns a path represented by a `string` that identifies `node` inside its document.
     * @see AstNodeLocator.getAstNode
     */
    getAstNodePath(node: AstNode): string;
    /**
     * Locates an `AstNode` inside another node by following the given path.
     *
     * @param node Parent element.
     * @param path Describes how to locate the `AstNode` inside the given `node`.
     * @returns The `AstNode` located under the given path, or `undefined` if the path cannot be resolved.
     * @see AstNodeLocator.getAstNodePath
     */
    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for creating descriptions of AST nodes to be used for cross-reference resolutions.
 */
interface AstNodeDescriptionProvider {
    /**
     * Create a description for the given AST node. This service method is typically used while indexing
     * the contents of a document and during scope computation.
     *
     * @param node An AST node.
     * @param name The name to be used to refer to the AST node. By default, this is determined by the
     *     `NameProvider` service, but alternative names may be provided according to the semantics
     *     of your language.
     * @param document The document containing the AST node. If omitted, it is taken from the root AST node.
     */
    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription;
}
/**
 * Describes a cross-reference within a document or between two documents.
 */
interface ReferenceDescription {
    /** URI of the document that holds a reference */
    sourceUri: URI$1;
    /** Path to AstNode that holds a reference */
    sourcePath: string;
    /** Target document uri */
    targetUri: URI$1;
    /** Path to the target AstNode inside the document */
    targetPath: string;
    /** Segment of the reference text. */
    segment: DocumentSegment;
    /** Marks a local reference i.e. a cross reference inside a document.   */
    local?: boolean;
}
/**
 * Language-specific service to create descriptions of all cross-references in a document. These are used by the `IndexManager`
 * to determine which documents are affected and should be rebuilt when a document is changed.
 */
interface ReferenceDescriptionProvider {
    /**
     * Create descriptions of all cross-references found in the given document. These descriptions are
     * gathered by the `IndexManager` and stored in the global index so they can be considered when
     * a document change is reported by the client.
     *
     * @param document The document in which to gather cross-references.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    createDescriptions(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<ReferenceDescription[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The index manager is responsible for keeping metadata about symbols and cross-references
 * in the workspace. It is used to look up symbols in the global scope, mostly during linking
 * and completion. This service is shared between all languages of a language server.
 */
interface IndexManager$1 {
    /**
     * Removes the specified document URI from the index.
     * Necessary when documents are deleted and not referenceable anymore.
     *
     * @param uri The URI of the document for which index data shall be removed
     */
    remove(uri: URI$1): void;
    /**
     * Updates the information about the exportable content of a document inside the index.
     *
     * @param document Document to be updated
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * Updates the information about the cross-references of a document inside the index.
     *
     * @param document Document to be updated
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * Determine whether the given document could be affected by changes of the documents
     * identified by the given URIs (second parameter). The document is typically regarded as
     * affected if it contains a reference to any of the changed files.
     *
     * @param document Document to check whether it's affected
     * @param changedUris URIs of the changed documents
     */
    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;
    /**
     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.
     *
     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.
     * @param uris If specified, only returns elements from the given URIs.
     * @returns a `Stream` containing all globally visible nodes (of a given type).
     */
    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
    /**
     * Returns all known references that are pointing to the given `targetNode`.
     *
     * @param targetNode the `AstNode` to look up references for
     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`
     *
     * @returns a `Stream` of references that are targeting the `targetNode`
     */
    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;
}
declare class DefaultIndexManager implements IndexManager$1 {
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly documents: LangiumDocuments$1;
    protected readonly astReflection: AstReflection;
    /**
     * The symbol index stores all `AstNodeDescription` items exported by a document.
     * The key used in this map is the string representation of the specific document URI.
     */
    protected readonly symbolIndex: Map<string, AstNodeDescription[]>;
    /**
     * This is a cache for the `allElements()` method.
     * It caches the descriptions from `symbolIndex` grouped by types.
     */
    protected readonly symbolByTypeIndex: ContextCache<string, string, AstNodeDescription[], string>;
    /**
     * This index keeps track of all `ReferenceDescription` items exported by a document.
     * This is used to compute which elements are affected by a document change
     * and for finding references to an AST node.
     */
    protected readonly referenceIndex: Map<string, ReferenceDescription[]>;
    constructor(services: LangiumSharedCoreServices);
    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;
    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
    protected getFileDescriptions(uri: string, nodeType?: string): AstNodeDescription[];
    remove(uri: URI$1): void;
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<void>;
    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<void>;
    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provides documentation for AST nodes.
 */
interface DocumentationProvider {
    /**
     * Returns a markdown documentation string for the specified AST node.
     *
     * The default implementation `JSDocDocumentationProvider` will inspect the comment associated with the specified node.
     */
    getDocumentation(node: AstNode): string | undefined;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Metadata of a language.
 */
interface LanguageMetaData {
    languageId: string;
    fileExtensions: readonly string[];
    fileNames?: readonly string[];
    caseInsensitive: boolean;
    /**
     * Mode used to optimize code for development or production environments.
     *
     * In production mode, all Chevrotain lexer/parser validations are disabled.
     */
    mode: 'development' | 'production';
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A scope describes what target elements are visible from a specific cross-reference context.
 */
interface Scope {
    /**
     * Find a target element matching the given name. If no element is found, `undefined` is returned.
     * If multiple matching elements are present, the selection of the returned element should be done
     * according to the semantics of your language. Usually it is the element that is most closely defined.
     *
     * @param name Name of the cross-reference target as it appears in the source text.
     */
    getElement(name: string): AstNodeDescription | undefined;
    /**
     * Create a stream of all elements in the scope. This is used to compute completion proposals to be
     * shown in the editor.
     */
    getAllElements(): Stream<AstNodeDescription>;
}
interface ScopeOptions {
    caseInsensitive?: boolean;
}

/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.
 */
interface ScopeProvider {
    /**
     * Return a scope describing what elements are visible for the given AST node and cross-reference
     * identifier.
     *
     * @param context Information about the reference for which a scope is requested.
     */
    getScope(context: ReferenceInfo): Scope;
}
declare class DefaultScopeProvider implements ScopeProvider {
    protected readonly reflection: AstReflection;
    protected readonly nameProvider: NameProvider;
    protected readonly descriptions: AstNodeDescriptionProvider;
    protected readonly indexManager: IndexManager$1;
    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;
    constructor(services: LangiumCoreServices);
    getScope(context: ReferenceInfo): Scope;
    /**
     * Create a scope for the given collection of AST node descriptions.
     */
    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope;
    /**
     * Create a scope for the given collection of AST nodes, which need to be transformed into respective
     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
     */
    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for resolving cross-references in the AST.
 */
interface Linker {
    /**
     * Links all cross-references within the specified document. The default implementation loads only target
     * elements from documents that are present in the `LangiumDocuments` service. The linked references are
     * stored in the document's `references` property.
     *
     * @param document A LangiumDocument that shall be linked.
     * @param cancelToken A token for cancelling the operation.
     *
     * @throws `OperationCancelled` if a cancellation event is detected
     */
    link(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * Unlinks all references within the specified document and removes them from the list of `references`.
     *
     * @param document A LangiumDocument that shall be unlinked.
     */
    unlink(document: LangiumDocument): void;
    /**
     * Determines a candidate AST node description for linking the given reference.
     *
     * @param refInfo Information about the reference.
     */
    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;
    /**
     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,
     * the cross reference text denoting the target AstNode being already extracted of the document text,
     * as well as the unique cross reference identifier.
     *
     * Default behavior:
     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its
     *    first visit.
     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed
     *    and further resolution attempts will *not* be performed.
     *
     * @param node The containing AST node
     * @param property The AST node property being referenced
     * @param refNode The corresponding CST node
     * @param refText The cross reference text denoting the target AstNode
     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.
     */
    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;
}

/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The hydrator service is responsible for allowing AST parse results to be sent across worker threads.
 */
interface Hydrator {
    /**
     * Converts a parse result to a plain object. The resulting object can be sent across worker threads.
     */
    dehydrate(result: ParseResult<AstNode>): ParseResult<object>;
    /**
     * Converts a plain object to a parse result. The included AST node can then be used in the main thread.
     * Calling this method on objects that have not been dehydrated first will result in undefined behavior.
     */
    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type MaybePromise<T> = T | Promise<T>;
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
declare class Deferred<T = void> {
    resolve: (value: T) => this;
    reject: (err?: unknown) => this;
    promise: Promise<T>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Async parser that allows cancellation of the current parsing process.
 *
 * @remarks
 * The sync parser implementation is blocking the event loop, which can become quite problematic for large files.
 * The default implementation is not actually async. It just wraps the sync parser in a promise. A real implementation would create worker threads or web workers to offload the parsing work.
 */
interface AsyncParser {
    /**
     * Parses the given text and returns the parse result.
     *
     * @param text The text to parse.
     * @param cancelToken A cancellation token that can be used to cancel the parsing process.
     * @returns A promise that resolves to the parse result.
     *
     * @throws `OperationCancelled` if the parsing process is cancelled.
     */
    parse<T extends AstNode>(text: string, cancelToken: CancellationToken$1): Promise<ParseResult<T>>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type ValueType = string | number | boolean | bigint | Date;
declare class DefaultValueConverter implements ValueConverter {
    convert(input: string, cstNode: CstNode): ValueType;
    protected runConverter(rule: AbstractRule, input: string, cstNode: CstNode): ValueType;
}
/**
 * Language-specific service for converting string values from the source text format into a value to be held in the AST.
 */
interface ValueConverter {
    /**
     * Converts a string value from the source text format into a value to be held in the AST.
     */
    convert(input: string, cstNode: CstNode): ValueType;
}
declare namespace ValueConverter {
    function convertString(input: string): string;
    function convertID(input: string): string;
    function convertInt(input: string): number;
    function convertBigint(input: string): bigint;
    function convertDate(input: string): Date;
    function convertNumber(input: string): number;
    function convertBoolean(input: string): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for finding references and declaration of a given `CstNode`.
 */
interface References {
    /**
     * If the CstNode is a reference node the target CstNode will be returned.
     * If the CstNode is a significant node of the CstNode this CstNode will be returned.
     *
     * @param sourceCstNode CstNode that points to a AstNode
     */
    findDeclaration(sourceCstNode: CstNode): AstNode | undefined;
    /**
     * If the CstNode is a reference node the target CstNode will be returned.
     * If the CstNode is a significant node of the CstNode this CstNode will be returned.
     *
     * @param sourceCstNode CstNode that points to a AstNode
     */
    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined;
    /**
     * Finds all references to the target node as references (local references) or reference descriptions.
     *
     * @param targetNode Specified target node whose references should be returned
     */
    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription>;
}
interface FindReferencesOptions {
    /**
     * @deprecated Since v1.2.0. Please use `documentUri` instead.
     */
    onlyLocal?: boolean;
    /**
     * When set, the `findReferences` method will only return references/declarations from the specified document.
     */
    documentUri?: URI$1;
    /**
     * Whether the returned list of references should include the declaration.
     */
    includeDeclaration?: boolean;
}

/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for precomputing global and local scopes. The service methods are executed
 * as the first and second phase in the `DocumentBuilder`.
 */
interface ScopeComputation {
    /**
     * Creates descriptions of all AST nodes that shall be exported into the _global_ scope from the given
     * document. These descriptions are gathered by the `IndexManager` and stored in the global index so
     * they can be referenced from other documents.
     *
     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference resolution
     * depends on the scope computation phase to be completed (`computeScope` method), which runs after the
     * initial indexing where this method is used.
     *
     * @param document The document from which to gather exported AST nodes.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    computeExports(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<AstNodeDescription[]>;
    /**
     * Precomputes the _local_ scopes for a document, which are necessary for the default way of
     * resolving references to symbols in the same document. The result is a multimap assigning a
     * set of AST node descriptions to every level of the AST. These data are used by the `ScopeProvider`
     * service to determine which target nodes are visible in the context of a specific cross-reference.
     *
     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference
     * resolution depends on the scope computation phase to be completed.
     *
     * @param document The document in which to compute scopes.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<PrecomputedScopes>;
}
/**
 * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the
 * _global_ scope from the given document. By default those are the document's root AST node and its directly
 * contained child nodes.
 *
 * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them
 * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,
 * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)
 * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)
 * are _invisible_ by default, but that can be changed by customizing this service.
 */
declare class DefaultScopeComputation implements ScopeComputation {
    protected readonly nameProvider: NameProvider;
    protected readonly descriptions: AstNodeDescriptionProvider;
    constructor(services: LangiumCoreServices);
    computeExports(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<AstNodeDescription[]>;
    /**
     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
     * The list of children to be considered is determined by the function parameter {@link children}.
     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
     *
     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
     * @param document The document containing the AST node to be exported.
     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCancelled` if a user action occurs during execution.
     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
     */
    computeExportsForNode(parentNode: AstNode, document: LangiumDocument<AstNode>, children?: (root: AstNode) => Iterable<AstNode>, cancelToken?: CancellationToken$1): Promise<AstNodeDescription[]>;
    /**
     * Add a single node to the list of exports if it has a name. Override this method to change how
     * symbols are exported, e.g. by modifying their exported name.
     */
    protected exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void;
    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<PrecomputedScopes>;
    /**
     * Process a single node during scopes computation. The default implementation makes the node visible
     * in the subtree of its container (if the node has a name). Override this method to change this,
     * e.g. by increasing the visibility to a higher level in the AST.
     */
    protected processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface JsonSerializeOptions {
    /** The space parameter for `JSON.stringify`, controlling whether and how to pretty-print the output. */
    space?: string | number;
    /** Whether to include the `$refText` property for references (the name used to identify the target node). */
    refText?: boolean;
    /** Whether to include the `$sourceText` property, which holds the full source text from which an AST node was parsed. */
    sourceText?: boolean;
    /** Whether to include the `$textRegion` property, which holds information to trace AST node properties to their respective source text regions. */
    textRegions?: boolean;
    /** Whether to include the `$comment` property, which holds comments according to the CommentProvider service. */
    comments?: boolean;
    /** The replacer parameter for `JSON.stringify`; the default replacer given as parameter should be used to apply basic replacements. */
    replacer?: (key: string, value: unknown, defaultReplacer: (key: string, value: unknown) => unknown) => unknown;
    /** Used to convert and serialize URIs when the target of a cross-reference is in a different document. */
    uriConverter?: (uri: URI$1, reference: Reference) => string;
}
interface JsonDeserializeOptions {
    /** Used to parse and convert URIs when the target of a cross-reference is in a different document. */
    uriConverter?: (uri: string) => URI$1;
}
/**
 * Utility service for transforming an `AstNode` into a JSON string and vice versa.
 */
interface JsonSerializer {
    /**
     * Serialize an `AstNode` into a JSON `string`.
     * @param node The `AstNode` to be serialized.
     * @param options Serialization options
     */
    serialize(node: AstNode, options?: JsonSerializeOptions): string;
    /**
     * Deserialize (parse) a JSON `string` into an `AstNode`.
     */
    deserialize<T extends AstNode = AstNode>(content: string, options?: JsonDeserializeOptions): T;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type DiagnosticInfo<N extends AstNode, P extends string = Properties<N>> = {
    /** The AST node to which the diagnostic is attached. */
    node: N;
    /** If a property name is given, the diagnostic is restricted to the corresponding text region. */
    property?: P;
    /** If the value of a keyword is given, the diagnostic will appear at its corresponding text region */
    keyword?: string;
    /** In case of a multi-value property (array), an index can be given to select a specific element. */
    index?: number;
    /** If you want to create a diagnostic independent to any property, use the range property. */
    range?: Range$1;
    /** The diagnostic's code, which usually appear in the user interface. */
    code?: integer | string;
    /** An optional property to describe the error code. */
    codeDescription?: CodeDescription;
    /** Additional metadata about the diagnostic. */
    tags?: DiagnosticTag[];
    /** An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property. */
    relatedInformation?: DiagnosticRelatedInformation[];
    /** A data entry field that is preserved between a `textDocument/publishDiagnostics` notification and `textDocument/codeAction` request. */
    data?: unknown;
};
type ValidationSeverity = 'error' | 'warning' | 'info' | 'hint';
type ValidationAcceptor = <N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N>) => void;
type ValidationCheck<T extends AstNode = AstNode> = (node: T, accept: ValidationAcceptor, cancelToken: CancellationToken$1) => MaybePromise<void>;
/**
 * A utility type for describing functions which will be called once before or after all the AstNodes of an AST/Langium document are validated.
 *
 * The AST is represented by its root AstNode.
 *
 * The given validation acceptor helps to report some early or lately detected issues.
 *
 * The 'categories' indicate, which validation categories are executed for all the AstNodes.
 * This helps to tailor the preparations/tear-down logic to the actually executed checks on the nodes.
 *
 * It is recommended to support interrupts during long-running logic with 'interruptAndCheck(cancelToken)'.
 */
type ValidationPreparation = (rootNode: AstNode, accept: ValidationAcceptor, categories: ValidationCategory[], cancelToken: CancellationToken$1) => MaybePromise<void>;
/**
 * A utility type for associating non-primitive AST types to corresponding validation checks. For example:
 *
 * ```ts
 *   const checks: ValidationChecks<StatemachineAstType> = {
 *       State: validator.checkStateNameStartsWithCapital
 *    };
 * ```
 *
 * If an AST type does not extend AstNode, e.g. if it describes a union of string literals, that type's name must not occur as a key in objects of type `ValidationCheck<...>`.
 *
 * @param T a type definition mapping language specific type names (keys) to the corresponding types (values)
 */
type ValidationChecks<T> = {
    [K in keyof T]?: T[K] extends AstNode ? ValidationCheck<T[K]> | Array<ValidationCheck<T[K]>> : never;
} & {
    AstNode?: ValidationCheck<AstNode> | Array<ValidationCheck<AstNode>>;
};
/**
 * There are 3 pre-defined categories: `fast`, `slow` and `built-in`.
 *
 * `fast` checks can be executed after every document change (i.e. as the user is typing). If a check
 * is too slow it can delay the response to document changes, yielding bad user experience. By marking
 * it as `slow`, it will be skipped for normal as-you-type validation. Then it's up to you when to
 * schedule these long-running checks: after the fast checks are done, or after saving a document,
 * or with an explicit command, etc.
 *
 * `built-in` checks are errors produced by the lexer, the parser, or the linker. They cannot be used
 * for custom validation checks.
 *
 * You can also provide user-defined categories. These check will be skipped by default. Then it's up
 * to you to schedule these checks: after the fast checks are done, or after saving a document,
 * or with an explicit command, etc.
 */
type ValidationCategory = 'fast' | 'slow' | 'built-in' | (string & {});
declare namespace ValidationCategory {
    const all: readonly ValidationCategory[];
}
type ValidationCheckEntry = {
    check: ValidationCheck;
    category: ValidationCategory;
};
/**
 * Manages a set of `ValidationCheck`s to be applied when documents are validated.
 */
declare class ValidationRegistry {
    private readonly entries;
    private readonly reflection;
    private entriesBefore;
    private entriesAfter;
    constructor(services: LangiumCoreServices);
    /**
     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
     * or an array of validation checks.
     *
     * @param checksRecord Set of validation checks to register.
     * @param category Optional category for the validation checks (defaults to `'fast'`).
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    register<T>(checksRecord: ValidationChecks<T>, thisObj?: ThisParameterType<unknown>, category?: ValidationCategory): void;
    protected wrapValidationException(check: ValidationCheck, thisObj: unknown): ValidationCheck;
    protected handleException(functionality: () => MaybePromise<void>, messageContext: string, accept: ValidationAcceptor, node: AstNode): Promise<void>;
    protected addEntry(type: string, entry: ValidationCheckEntry): void;
    getChecks(type: string, categories?: ValidationCategory[]): Stream<ValidationCheck>;
    /**
     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map for mapping names to nodes could be established.
     * During the usual checks on the nodes, they are put into this map with their name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerBeforeDocument(checkBefore: ValidationPreparation, thisObj?: ThisParameterType<unknown>): void;
    /**
     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
     * This helps to finally evaluate information which are collected during the checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map with all the collected nodes and their names is checked
     * and validation hints are created for all nodes with the same name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerAfterDocument(checkAfter: ValidationPreparation, thisObj?: ThisParameterType<unknown>): void;
    protected wrapPreparationException(check: ValidationPreparation, messageContext: string, thisObj: unknown): ValidationPreparation;
    get checksBefore(): ValidationPreparation[];
    get checksAfter(): ValidationPreparation[];
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ValidationOptions {
    /**
     * If this is set, only the checks associated with these categories are executed; otherwise
     * all checks are executed. The default category if not specified to the registry is `'fast'`.
     */
    categories?: ValidationCategory[];
    /** If true, no further diagnostics are reported if there are lexing errors. */
    stopAfterLexingErrors?: boolean;
    /** If true, no further diagnostics are reported if there are parsing errors. Lexing errors are reported first. */
    stopAfterParsingErrors?: boolean;
    /** If true, no further diagnostics are reported if there are linking errors. Lexing and parsing errors are reported first. */
    stopAfterLinkingErrors?: boolean;
}
declare class DefaultDocumentValidator implements DocumentValidator {
    protected readonly validationRegistry: ValidationRegistry;
    protected readonly metadata: LanguageMetaData;
    constructor(services: LangiumCoreServices);
    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken$1): Promise<Diagnostic[]>;
    protected processLexingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void;
    protected processParsingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void;
    protected processLinkingErrors(document: LangiumDocument, diagnostics: Diagnostic[], _options: ValidationOptions): void;
    protected validateAst(rootNode: AstNode, options: ValidationOptions, cancelToken?: CancellationToken$1): Promise<Diagnostic[]>;
    protected validateAstBefore(rootNode: AstNode, options: ValidationOptions, acceptor: ValidationAcceptor, cancelToken?: CancellationToken$1): Promise<void>;
    protected validateAstNodes(rootNode: AstNode, options: ValidationOptions, acceptor: ValidationAcceptor, cancelToken?: CancellationToken$1): Promise<void>;
    protected validateAstAfter(rootNode: AstNode, options: ValidationOptions, acceptor: ValidationAcceptor, cancelToken?: CancellationToken$1): Promise<void>;
    protected toDiagnostic<N extends AstNode>(severity: ValidationSeverity, message: string, info: DiagnosticInfo<N, string>): Diagnostic;
    protected getSource(): string | undefined;
}
/**
 * Language-specific service for validating `LangiumDocument`s.
 */
interface DocumentValidator {
    /**
     * Validates the whole specified document.
     *
     * @param document specified document to validate
     * @param options options to control the validation process
     * @param cancelToken allows to cancel the current operation
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken$1): Promise<Diagnostic[]>;
}
declare namespace DocumentValidator {
    const LexingError = "lexing-error";
    const LexingWarning = "lexing-warning";
    const LexingInfo = "lexing-info";
    const LexingHint = "lexing-hint";
    const ParsingError = "parsing-error";
    const LinkingError = "linking-error";
}

interface ResponseErrorLiteral<D = void> {
    /**
     * A number indicating the error type that occurred.
     */
    code: number;
    /**
     * A string providing a short description of the error.
     */
    message: string;
    /**
     * A Primitive or Structured value that contains additional
     * information about the error. Can be omitted.
     */
    data?: D;
}
/**
 * An error object return in a response in case a request
 * has failed.
 */
declare class ResponseError<D = void> extends Error {
    readonly code: number;
    readonly data: D | undefined;
    constructor(code: number, message: string, data?: D);
    toJson(): ResponseErrorLiteral<D>;
}
declare class ParameterStructures {
    private readonly kind;
    /**
     * The parameter structure is automatically inferred on the number of parameters
     * and the parameter type in case of a single param.
     */
    static readonly auto: ParameterStructures;
    /**
     * Forces `byPosition` parameter structure. This is useful if you have a single
     * parameter which has a literal type.
     */
    static readonly byPosition: ParameterStructures;
    /**
     * Forces `byName` parameter structure. This is only useful when having a single
     * parameter. The library will report errors if used with a different number of
     * parameters.
     */
    static readonly byName: ParameterStructures;
    private constructor();
    static is(value: any): value is ParameterStructures;
    toString(): string;
}
/**
 * An interface to type messages.
 */
interface MessageSignature {
    readonly method: string;
    readonly numberOfParams: number;
    readonly parameterStructures: ParameterStructures;
}
/**
 * An abstract implementation of a MessageType.
 */
declare abstract class AbstractMessageSignature implements MessageSignature {
    readonly method: string;
    readonly numberOfParams: number;
    constructor(method: string, numberOfParams: number);
    get parameterStructures(): ParameterStructures;
}
/**
 * End marker interface for request and notification types.
 */
interface _EM {
    _$endMarker$_: number;
}
/**
 * Classes to type request response pairs
 */
declare class RequestType0<R, E> extends AbstractMessageSignature {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [R, E, _EM] | undefined;
    constructor(method: string);
}
declare class RequestType<P, R, E> extends AbstractMessageSignature {
    private _parameterStructures;
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [P, R, E, _EM] | undefined;
    constructor(method: string, _parameterStructures?: ParameterStructures);
    get parameterStructures(): ParameterStructures;
}
declare class NotificationType<P> extends AbstractMessageSignature {
    private _parameterStructures;
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [P, _EM] | undefined;
    constructor(method: string, _parameterStructures?: ParameterStructures);
    get parameterStructures(): ParameterStructures;
}
declare class NotificationType0 extends AbstractMessageSignature {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly _: [_EM] | undefined;
    constructor(method: string);
}

type ProgressToken = number | string;
declare namespace ProgressToken {
    function is(value: any): value is number | string;
}
declare class ProgressType<PR> {
    /**
     * Clients must not use these properties. They are here to ensure correct typing.
     * in TypeScript
     */
    readonly __: [PR, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor();
}
type HandlerResult<R, E> = R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>> | Thenable<R | ResponseError<E>>;
interface StarRequestHandler {
    (method: string, params: any[] | object | undefined, token: CancellationToken$1): HandlerResult<any, any>;
}
interface GenericRequestHandler<R, E> {
    (...params: any[]): HandlerResult<R, E>;
}
interface RequestHandler0<R, E> {
    (token: CancellationToken$1): HandlerResult<R, E>;
}
interface RequestHandler<P, R, E> {
    (params: P, token: CancellationToken$1): HandlerResult<R, E>;
}
interface StarNotificationHandler {
    (method: string, params: any[] | object | undefined): void;
}
interface GenericNotificationHandler {
    (...params: any[]): void;
}
interface NotificationHandler0 {
    (): void;
}
interface NotificationHandler<P> {
    (params: P): void;
}
interface NotificationHandler1<P1> {
    (p1: P1): void;
}
declare namespace TraceValues {
    /**
     * Turn tracing off.
     */
    const Off: 'off';
    /**
     * Trace messages only.
     */
    const Messages: 'messages';
    /**
     * Compact message tracing.
     */
    const Compact: 'compact';
    /**
     * Verbose message tracing.
     */
    const Verbose: 'verbose';
}
type TraceValues = 'off' | 'messages' | 'compact' | 'verbose';

declare class RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ____: [RO, _EM] | undefined;
    readonly method: string;
    constructor(method: string);
}
declare class ProtocolRequestType0<R, PR, E, RO> extends RequestType0<R, E> implements ProgressType<PR>, RegistrationType<RO> {
    /**
     * Clients must not use these properties. They are here to ensure correct typing.
     * in TypeScript
     */
    readonly __: [PR, _EM] | undefined;
    readonly ___: [PR, RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor(method: string);
}
declare class ProtocolRequestType<P, R, PR, E, RO> extends RequestType<P, R, E> implements ProgressType<PR>, RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly __: [PR, _EM] | undefined;
    readonly ___: [PR, RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    readonly _pr: PR | undefined;
    constructor(method: string);
}
declare class ProtocolNotificationType0<RO> extends NotificationType0 implements RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ___: [RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    constructor(method: string);
}
declare class ProtocolNotificationType<P, RO> extends NotificationType<P> implements RegistrationType<RO> {
    /**
     * Clients must not use this property. It is here to ensure correct typing.
     */
    readonly ___: [RO, _EM] | undefined;
    readonly ____: [RO, _EM] | undefined;
    constructor(method: string);
}

/**
 * @since 3.6.0
 */
interface ImplementationClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `ImplementationRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * @since 3.14.0
     */
    linkSupport?: boolean;
}
interface ImplementationOptions extends WorkDoneProgressOptions {
}
interface ImplementationRegistrationOptions extends TextDocumentRegistrationOptions, ImplementationOptions, StaticRegistrationOptions {
}
interface ImplementationParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

/**
 * Since 3.6.0
 */
interface TypeDefinitionClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `TypeDefinitionRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * Since 3.14.0
     */
    linkSupport?: boolean;
}
interface TypeDefinitionOptions extends WorkDoneProgressOptions {
}
interface TypeDefinitionRegistrationOptions extends TextDocumentRegistrationOptions, TypeDefinitionOptions, StaticRegistrationOptions {
}
interface TypeDefinitionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

interface WorkspaceFoldersInitializeParams {
    /**
     * The workspace folders configured in the client when the server starts.
     *
     * This property is only available if the client supports workspace folders.
     * It can be `null` if the client supports workspace folders but none are
     * configured.
     *
     * @since 3.6.0
     */
    workspaceFolders?: WorkspaceFolder[] | null;
}
interface WorkspaceFoldersServerCapabilities {
    /**
     * The server has support for workspace folders
     */
    supported?: boolean;
    /**
     * Whether the server wants to receive workspace folder
     * change notifications.
     *
     * If a string is provided the string is treated as an ID
     * under which the notification is registered on the client
     * side. The ID can be used to unregister for these events
     * using the `client/unregisterCapability` request.
     */
    changeNotifications?: string | boolean;
}
/**
 * The workspace folder change event.
 */
interface WorkspaceFoldersChangeEvent {
    /**
     * The array of added workspace folders
     */
    added: WorkspaceFolder[];
    /**
     * The array of the removed workspace folders
     */
    removed: WorkspaceFolder[];
}

interface ConfigurationItem {
    /**
     * The scope to get the configuration section for.
     */
    scopeUri?: URI;
    /**
     * The configuration section asked for.
     */
    section?: string;
}

interface DocumentColorClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `DocumentColorRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface DocumentColorOptions extends WorkDoneProgressOptions {
}
interface DocumentColorRegistrationOptions extends TextDocumentRegistrationOptions, StaticRegistrationOptions, DocumentColorOptions {
}
/**
 * Parameters for a {@link DocumentColorRequest}.
 */
interface DocumentColorParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Parameters for a {@link ColorPresentationRequest}.
 */
interface ColorPresentationParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The color to request presentations for.
     */
    color: Color;
    /**
     * The range where the color would be inserted. Serves as a context.
     */
    range: Range$1;
}

interface FoldingRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration for folding range
     * providers. If this is set to `true` the client supports the new
     * `FoldingRangeRegistrationOptions` return value for the corresponding
     * server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The maximum number of folding ranges that the client prefers to receive
     * per document. The value serves as a hint, servers are free to follow the
     * limit.
     */
    rangeLimit?: uinteger;
    /**
     * If set, the client signals that it only supports folding complete lines.
     * If set, client will ignore specified `startCharacter` and `endCharacter`
     * properties in a FoldingRange.
     */
    lineFoldingOnly?: boolean;
    /**
     * Specific options for the folding range kind.
     *
     * @since 3.17.0
     */
    foldingRangeKind?: {
        /**
         * The folding range kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         */
        valueSet?: FoldingRangeKind[];
    };
    /**
     * Specific options for the folding range.
     *
     * @since 3.17.0
     */
    foldingRange?: {
        /**
        * If set, the client signals that it supports setting collapsedText on
        * folding ranges to display custom labels instead of the default text.
        *
        * @since 3.17.0
        */
        collapsedText?: boolean;
    };
}
/**
 * Client workspace capabilities specific to folding ranges
 *
 * @since 3.18.0
 * @proposed
 */
interface FoldingRangeWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * folding ranges currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     *
     * @since 3.18.0
     * @proposed
     */
    refreshSupport?: boolean;
}
interface FoldingRangeOptions extends WorkDoneProgressOptions {
}
interface FoldingRangeRegistrationOptions extends TextDocumentRegistrationOptions, FoldingRangeOptions, StaticRegistrationOptions {
}
/**
 * Parameters for a {@link FoldingRangeRequest}.
 */
interface FoldingRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}

/**
 * @since 3.14.0
 */
interface DeclarationClientCapabilities {
    /**
     * Whether declaration supports dynamic registration. If this is set to `true`
     * the client supports the new `DeclarationRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of declaration links.
     */
    linkSupport?: boolean;
}
interface DeclarationOptions extends WorkDoneProgressOptions {
}
interface DeclarationRegistrationOptions extends DeclarationOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions {
}
interface DeclarationParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

interface SelectionRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
     * the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
     * capability as well.
     */
    dynamicRegistration?: boolean;
}
interface SelectionRangeOptions extends WorkDoneProgressOptions {
}
interface SelectionRangeRegistrationOptions extends SelectionRangeOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions {
}
/**
 * A parameter literal used in selection range requests.
 */
interface SelectionRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The positions inside the text document.
     */
    positions: Position$1[];
}

/**
 * @since 3.16.0
 */
interface CallHierarchyClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
/**
 * Call hierarchy options used during static registration.
 *
 * @since 3.16.0
 */
interface CallHierarchyOptions extends WorkDoneProgressOptions {
}
/**
 * Call hierarchy options used during static or dynamic registration.
 *
 * @since 3.16.0
 */
interface CallHierarchyRegistrationOptions extends TextDocumentRegistrationOptions, CallHierarchyOptions, StaticRegistrationOptions {
}
/**
 * The parameter of a `textDocument/prepareCallHierarchy` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyPrepareParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * The parameter of a `callHierarchy/incomingCalls` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyIncomingCallsParams extends WorkDoneProgressParams, PartialResultParams {
    item: CallHierarchyItem;
}
/**
 * The parameter of a `callHierarchy/outgoingCalls` request.
 *
 * @since 3.16.0
 */
interface CallHierarchyOutgoingCallsParams extends WorkDoneProgressParams, PartialResultParams {
    item: CallHierarchyItem;
}

/**
 * @since 3.16.0
 */
interface SemanticTokensPartialResult {
    data: uinteger[];
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDeltaPartialResult {
    edits: SemanticTokensEdit[];
}
declare namespace TokenFormat {
    const Relative: 'relative';
}
type TokenFormat = 'relative';
/**
 * @since 3.16.0
 */
interface SemanticTokensClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * Which requests the client supports and might send to the server
     * depending on the server's capability. Please note that clients might not
     * show semantic tokens or degrade some of the user experience if a range
     * or full request is advertised by the client but not provided by the
     * server. If for example the client capability `requests.full` and
     * `request.range` are both set to true but the server only provides a
     * range provider the client might not render a minimap correctly or might
     * even decide to not show any semantic tokens at all.
     */
    requests: {
        /**
         * The client will send the `textDocument/semanticTokens/range` request if
         * the server provides a corresponding handler.
         */
        range?: boolean | {};
        /**
         * The client will send the `textDocument/semanticTokens/full` request if
         * the server provides a corresponding handler.
         */
        full?: boolean | {
            /**
             * The client will send the `textDocument/semanticTokens/full/delta` request if
             * the server provides a corresponding handler.
             */
            delta?: boolean;
        };
    };
    /**
     * The token types that the client supports.
     */
    tokenTypes: string[];
    /**
     * The token modifiers that the client supports.
     */
    tokenModifiers: string[];
    /**
     * The token formats the clients supports.
     */
    formats: TokenFormat[];
    /**
     * Whether the client supports tokens that can overlap each other.
     */
    overlappingTokenSupport?: boolean;
    /**
     * Whether the client supports tokens that can span multiple lines.
     */
    multilineTokenSupport?: boolean;
    /**
     * Whether the client allows the server to actively cancel a
     * semantic token request, e.g. supports returning
     * LSPErrorCodes.ServerCancelled. If a server does the client
     * needs to retrigger the request.
     *
     * @since 3.17.0
     */
    serverCancelSupport?: boolean;
    /**
     * Whether the client uses semantic tokens to augment existing
     * syntax tokens. If set to `true` client side created syntax
     * tokens and semantic tokens are both used for colorization. If
     * set to `false` the client only uses the returned semantic tokens
     * for colorization.
     *
     * If the value is `undefined` then the client behavior is not
     * specified.
     *
     * @since 3.17.0
     */
    augmentsSyntaxTokens?: boolean;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensOptions extends WorkDoneProgressOptions {
    /**
     * The legend used by the server
     */
    legend: SemanticTokensLegend;
    /**
     * Server supports providing semantic tokens for a specific range
     * of a document.
     */
    range?: boolean | {};
    /**
     * Server supports providing semantic tokens for a full document.
     */
    full?: boolean | {
        /**
         * The server supports deltas for full documents.
         */
        delta?: boolean;
    };
}
/**
 * @since 3.16.0
 */
interface SemanticTokensRegistrationOptions extends TextDocumentRegistrationOptions, SemanticTokensOptions, StaticRegistrationOptions {
}
/**
 * @since 3.16.0
 */
interface SemanticTokensParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensDeltaParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The result id of a previous response. The result Id can either point to a full response
     * or a delta response depending on what was received last.
     */
    previousResultId: string;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensRangeParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range the semantic tokens are requested for.
     */
    range: Range$1;
}
/**
 * @since 3.16.0
 */
interface SemanticTokensWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * semantic tokens currently shown. It should be used with absolute care
     * and is useful for situation where a server for example detects a project
     * wide change that requires such a calculation.
     */
    refreshSupport?: boolean;
}

/**
 * Client capabilities for the showDocument request.
 *
 * @since 3.16.0
 */
interface ShowDocumentClientCapabilities {
    /**
     * The client has support for the showDocument
     * request.
     */
    support: boolean;
}
/**
 * Params to show a resource in the UI.
 *
 * @since 3.16.0
 */
interface ShowDocumentParams {
    /**
     * The uri to show.
     */
    uri: URI;
    /**
     * Indicates to show the resource in an external program.
     * To show, for example, `https://code.visualstudio.com/`
     * in the default WEB browser set `external` to `true`.
     */
    external?: boolean;
    /**
     * An optional property to indicate whether the editor
     * showing the document should take focus or not.
     * Clients might ignore this property if an external
     * program is started.
     */
    takeFocus?: boolean;
    /**
     * An optional selection range if the document is a text
     * document. Clients might ignore the property if an
     * external program is started or the file is not a text
     * file.
     */
    selection?: Range$1;
}
/**
 * The result of a showDocument request.
 *
 * @since 3.16.0
 */
interface ShowDocumentResult {
    /**
     * A boolean indicating if the show was successful.
     */
    success: boolean;
}

/**
 * Client capabilities for the linked editing range request.
 *
 * @since 3.16.0
 */
interface LinkedEditingRangeClientCapabilities {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface LinkedEditingRangeParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
interface LinkedEditingRangeOptions extends WorkDoneProgressOptions {
}
interface LinkedEditingRangeRegistrationOptions extends TextDocumentRegistrationOptions, LinkedEditingRangeOptions, StaticRegistrationOptions {
}
/**
 * The result of a linked editing range request.
 *
 * @since 3.16.0
 */
interface LinkedEditingRanges {
    /**
     * A list of ranges that can be edited together. The ranges must have
     * identical length and contain identical text content. The ranges cannot overlap.
     */
    ranges: Range$1[];
    /**
     * An optional word pattern (regular expression) that describes valid contents for
     * the given ranges. If no pattern is provided, the client configuration's word
     * pattern will be used.
     */
    wordPattern?: string;
}

/**
 * Options for notifications/requests for user operations on files.
 *
 * @since 3.16.0
 */
interface FileOperationOptions {
    /**
    * The server is interested in receiving didCreateFiles notifications.
    */
    didCreate?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willCreateFiles requests.
    */
    willCreate?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving didRenameFiles notifications.
    */
    didRename?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willRenameFiles requests.
    */
    willRename?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving didDeleteFiles file notifications.
    */
    didDelete?: FileOperationRegistrationOptions;
    /**
    * The server is interested in receiving willDeleteFiles file requests.
    */
    willDelete?: FileOperationRegistrationOptions;
}
/**
 * The options to register for file operations.
 *
 * @since 3.16.0
 */
interface FileOperationRegistrationOptions {
    /**
     * The actual filters.
     */
    filters: FileOperationFilter[];
}
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
declare namespace FileOperationPatternKind {
    /**
     * The pattern matches a file only.
     */
    const file: 'file';
    /**
     * The pattern matches a folder only.
     */
    const folder: 'folder';
}
type FileOperationPatternKind = 'file' | 'folder';
/**
 * Matching options for the file operation pattern.
 *
 * @since 3.16.0
 */
interface FileOperationPatternOptions {
    /**
     * The pattern should be matched ignoring casing.
     */
    ignoreCase?: boolean;
}
/**
 * A pattern to describe in which file operation requests or notifications
 * the server is interested in receiving.
 *
 * @since 3.16.0
 */
interface FileOperationPattern {
    /**
     * The glob pattern to match. Glob patterns can have the following syntax:
     * - `*` to match one or more characters in a path segment
     * - `?` to match on one character in a path segment
     * - `**` to match any number of path segments, including none
     * - `{}` to group sub patterns into an OR expression. (e.g. `**â€‹/*.{ts,js}` matches all TypeScript and JavaScript files)
     * - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, â€¦)
     * - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
     */
    glob: string;
    /**
     * Whether to match files or folders with this pattern.
     *
     * Matches both if undefined.
     */
    matches?: FileOperationPatternKind;
    /**
     * Additional options used during matching.
     */
    options?: FileOperationPatternOptions;
}
/**
 * A filter to describe in which file operation requests or notifications
 * the server is interested in receiving.
 *
 * @since 3.16.0
 */
interface FileOperationFilter {
    /**
     * A Uri scheme like `file` or `untitled`.
     */
    scheme?: string;
    /**
     * The actual file operation pattern.
     */
    pattern: FileOperationPattern;
}
/**
 * Capabilities relating to events from file operations by the user in the client.
 *
 * These events do not come from the file system, they come from user operations
 * like renaming a file in the UI.
 *
 * @since 3.16.0
 */
interface FileOperationClientCapabilities {
    /**
     * Whether the client supports dynamic registration for file requests/notifications.
     */
    dynamicRegistration?: boolean;
    /**
     * The client has support for sending didCreateFiles notifications.
     */
    didCreate?: boolean;
    /**
     * The client has support for sending willCreateFiles requests.
     */
    willCreate?: boolean;
    /**
     * The client has support for sending didRenameFiles notifications.
     */
    didRename?: boolean;
    /**
     * The client has support for sending willRenameFiles requests.
     */
    willRename?: boolean;
    /**
     * The client has support for sending didDeleteFiles notifications.
     */
    didDelete?: boolean;
    /**
     * The client has support for sending willDeleteFiles requests.
     */
    willDelete?: boolean;
}
/**
 * The parameters sent in notifications/requests for user-initiated creation of
 * files.
 *
 * @since 3.16.0
 */
interface CreateFilesParams {
    /**
     * An array of all files/folders created in this operation.
     */
    files: FileCreate[];
}
/**
 * Represents information on a file/folder create.
 *
 * @since 3.16.0
 */
interface FileCreate {
    /**
     * A file:// URI for the location of the file/folder being created.
     */
    uri: string;
}
/**
 * The parameters sent in notifications/requests for user-initiated renames of
 * files.
 *
 * @since 3.16.0
 */
interface RenameFilesParams {
    /**
     * An array of all files/folders renamed in this operation. When a folder is renamed, only
     * the folder will be included, and not its children.
     */
    files: FileRename[];
}
/**
 * Represents information on a file/folder rename.
 *
 * @since 3.16.0
 */
interface FileRename {
    /**
     * A file:// URI for the original location of the file/folder being renamed.
     */
    oldUri: string;
    /**
     * A file:// URI for the new location of the file/folder being renamed.
     */
    newUri: string;
}
/**
 * The parameters sent in notifications/requests for user-initiated deletes of
 * files.
 *
 * @since 3.16.0
 */
interface DeleteFilesParams {
    /**
     * An array of all files/folders deleted in this operation.
     */
    files: FileDelete[];
}
/**
 * Represents information on a file/folder delete.
 *
 * @since 3.16.0
 */
interface FileDelete {
    /**
     * A file:// URI for the location of the file/folder being deleted.
     */
    uri: string;
}

/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
declare namespace UniquenessLevel {
    /**
     * The moniker is only unique inside a document
     */
    const document = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    const project = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    const group = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    const scheme = "scheme";
    /**
     * The moniker is globally unique
     */
    const global = "global";
}
type UniquenessLevel = 'document' | 'project' | 'group' | 'scheme' | 'global';
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
declare namespace MonikerKind {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    const $import = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    const $export = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    const local = "local";
}
type MonikerKind = 'import' | 'export' | 'local';
/**
 * Moniker definition to match LSIF 0.5 moniker definition.
 *
 * @since 3.16.0
 */
interface Moniker {
    /**
     * The scheme of the moniker. For example tsc or .Net
     */
    scheme: string;
    /**
     * The identifier of the moniker. The value is opaque in LSIF however
     * schema owners are allowed to define the structure if they want.
     */
    identifier: string;
    /**
     * The scope in which the moniker is unique
     */
    unique: UniquenessLevel;
    /**
     * The moniker kind if known.
     */
    kind?: MonikerKind;
}
/**
 * Client capabilities specific to the moniker request.
 *
 * @since 3.16.0
 */
interface MonikerClientCapabilities {
    /**
     * Whether moniker supports dynamic registration. If this is set to `true`
     * the client supports the new `MonikerRegistrationOptions` return value
     * for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
}
interface MonikerOptions extends WorkDoneProgressOptions {
}
interface MonikerRegistrationOptions extends TextDocumentRegistrationOptions, MonikerOptions {
}
interface MonikerParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}

/**
 * @since 3.17.0
 */
type TypeHierarchyClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
};
/**
 * Type hierarchy options used during static registration.
 *
 * @since 3.17.0
 */
type TypeHierarchyOptions = WorkDoneProgressOptions;
/**
 * Type hierarchy options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type TypeHierarchyRegistrationOptions = TextDocumentRegistrationOptions & TypeHierarchyOptions & StaticRegistrationOptions;
/**
 * The parameter of a `textDocument/prepareTypeHierarchy` request.
 *
 * @since 3.17.0
 */
type TypeHierarchyPrepareParams = TextDocumentPositionParams & WorkDoneProgressParams;
/**
 * The parameter of a `typeHierarchy/supertypes` request.
 *
 * @since 3.17.0
 */
type TypeHierarchySupertypesParams = WorkDoneProgressParams & PartialResultParams & {
    item: TypeHierarchyItem;
};
/**
 * The parameter of a `typeHierarchy/subtypes` request.
 *
 * @since 3.17.0
 */
type TypeHierarchySubtypesParams = WorkDoneProgressParams & PartialResultParams & {
    item: TypeHierarchyItem;
};

/**
 * Client capabilities specific to inline values.
 *
 * @since 3.17.0
 */
type InlineValueClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration for inline value providers.
     */
    dynamicRegistration?: boolean;
};
/**
 * Client workspace capabilities specific to inline values.
 *
 * @since 3.17.0
 */
type InlineValueWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * inline values currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Inline value options used during static registration.
 *
 * @since 3.17.0
 */
type InlineValueOptions = WorkDoneProgressOptions;
/**
 * Inline value options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type InlineValueRegistrationOptions = InlineValueOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions;
/**
 * A parameter literal used in inline value requests.
 *
 * @since 3.17.0
 */
type InlineValueParams = WorkDoneProgressParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The document range for which inline values should be computed.
     */
    range: Range$1;
    /**
     * Additional information about the context in which inline values were
     * requested.
     */
    context: InlineValueContext;
};

/**
 * Inlay hint client capabilities.
 *
 * @since 3.17.0
 */
type InlayHintClientCapabilities = {
    /**
     * Whether inlay hints support dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Indicates which properties a client can resolve lazily on an inlay
     * hint.
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily.
         */
        properties: string[];
    };
};
/**
 * Client workspace capabilities specific to inlay hints.
 *
 * @since 3.17.0
 */
type InlayHintWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * inlay hints currently shown. It should be used with absolute care and
     * is useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Inlay hint options used during static registration.
 *
 * @since 3.17.0
 */
type InlayHintOptions = WorkDoneProgressOptions & {
    /**
     * The server provides support to resolve additional
     * information for an inlay hint item.
     */
    resolveProvider?: boolean;
};
/**
 * Inlay hint options used during static or dynamic registration.
 *
 * @since 3.17.0
 */
type InlayHintRegistrationOptions = InlayHintOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions;
/**
 * A parameter literal used in inlay hint requests.
 *
 * @since 3.17.0
 */
type InlayHintParams = WorkDoneProgressParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The document range for which inlay hints should be computed.
     */
    range: Range$1;
};

/**
 * Client capabilities specific to diagnostic pull requests.
 *
 * @since 3.17.0
 */
type DiagnosticClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is set to `true`
     * the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the clients supports related documents for document diagnostic pulls.
     */
    relatedDocumentSupport?: boolean;
};
/**
 * Workspace client capabilities specific to diagnostic pull requests.
 *
 * @since 3.17.0
 */
type DiagnosticWorkspaceClientCapabilities = {
    /**
     * Whether the client implementation supports a refresh request sent from
     * the server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * pulled diagnostics currently shown. It should be used with absolute care and
     * is useful for situation where a server for example detects a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
};
/**
 * Diagnostic options.
 *
 * @since 3.17.0
 */
type DiagnosticOptions = WorkDoneProgressOptions & {
    /**
     * An optional identifier under which the diagnostics are
     * managed by the client.
     */
    identifier?: string;
    /**
     * Whether the language has inter file dependencies meaning that
     * editing code in one file can result in a different diagnostic
     * set in another file. Inter file dependencies are common for
     * most programming languages and typically uncommon for linters.
     */
    interFileDependencies: boolean;
    /**
     * The server provides support for workspace diagnostics as well.
     */
    workspaceDiagnostics: boolean;
};
/**
 * Diagnostic registration options.
 *
 * @since 3.17.0
 */
type DiagnosticRegistrationOptions = TextDocumentRegistrationOptions & DiagnosticOptions & StaticRegistrationOptions;
/**
 * Cancellation data returned from a diagnostic request.
 *
 * @since 3.17.0
 */
type DiagnosticServerCancellationData = {
    retriggerRequest: boolean;
};
/**
 * @since 3.17.0
 */
declare namespace DiagnosticServerCancellationData {
    function is(value: any): value is DiagnosticServerCancellationData;
}
/**
 * Parameters of the document diagnostic request.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticParams = WorkDoneProgressParams & PartialResultParams & {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The additional identifier  provided during registration.
     */
    identifier?: string;
    /**
     * The result id of a previous response if provided.
     */
    previousResultId?: string;
};
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
declare namespace DocumentDiagnosticReportKind {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    const Full = "full";
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    const Unchanged = "unchanged";
}
type DocumentDiagnosticReportKind = 'full' | 'unchanged';
/**
 * A diagnostic report with a full set of problems.
 *
 * @since 3.17.0
 */
type FullDocumentDiagnosticReport = {
    /**
     * A full document diagnostic report.
     */
    kind: typeof DocumentDiagnosticReportKind.Full;
    /**
     * An optional result id. If provided it will
     * be sent on the next diagnostic request for the
     * same document.
     */
    resultId?: string;
    /**
     * The actual items.
     */
    items: Diagnostic[];
};
/**
 * A full diagnostic report with a set of related documents.
 *
 * @since 3.17.0
 */
type RelatedFullDocumentDiagnosticReport = FullDocumentDiagnosticReport & {
    /**
     * Diagnostics of related documents. This information is useful
     * in programming languages where code in a file A can generate
     * diagnostics in a file B which A depends on. An example of
     * such a language is C/C++ where marco definitions in a file
     * a.cpp and result in errors in a header file b.hpp.
     *
     * @since 3.17.0
     */
    relatedDocuments?: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * A diagnostic report indicating that the last returned
 * report is still accurate.
 *
 * @since 3.17.0
 */
type UnchangedDocumentDiagnosticReport = {
    /**
     * A document diagnostic report indicating
     * no changes to the last result. A server can
     * only return `unchanged` if result ids are
     * provided.
     */
    kind: typeof DocumentDiagnosticReportKind.Unchanged;
    /**
     * A result id which will be sent on the next
     * diagnostic request for the same document.
     */
    resultId: string;
};
/**
 * An unchanged diagnostic report with a set of related documents.
 *
 * @since 3.17.0
 */
type RelatedUnchangedDocumentDiagnosticReport = UnchangedDocumentDiagnosticReport & {
    /**
     * Diagnostics of related documents. This information is useful
     * in programming languages where code in a file A can generate
     * diagnostics in a file B which A depends on. An example of
     * such a language is C/C++ where marco definitions in a file
     * a.cpp and result in errors in a header file b.hpp.
     *
     * @since 3.17.0
     */
    relatedDocuments?: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * The result of a document diagnostic pull request. A report can
 * either be a full report containing all diagnostics for the
 * requested document or an unchanged report indicating that nothing
 * has changed in terms of diagnostics in comparison to the last
 * pull request.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticReport = RelatedFullDocumentDiagnosticReport | RelatedUnchangedDocumentDiagnosticReport;
/**
 * A partial result for a document diagnostic report.
 *
 * @since 3.17.0
 */
type DocumentDiagnosticReportPartialResult = {
    relatedDocuments: {
        [uri: DocumentUri]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport;
    };
};
/**
 * A previous result id in a workspace pull request.
 *
 * @since 3.17.0
 */
type PreviousResultId = {
    /**
     * The URI for which the client knowns a
     * result id.
     */
    uri: DocumentUri$1;
    /**
     * The value of the previous result id.
     */
    value: string;
};
/**
 * Parameters of the workspace diagnostic request.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticParams = WorkDoneProgressParams & PartialResultParams & {
    /**
     * The additional identifier provided during registration.
     */
    identifier?: string;
    /**
     * The currently known diagnostic reports with their
     * previous result ids.
     */
    previousResultIds: PreviousResultId[];
};
/**
 * A full document diagnostic report for a workspace diagnostic result.
 *
 * @since 3.17.0
 */
type WorkspaceFullDocumentDiagnosticReport = FullDocumentDiagnosticReport & {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * The version number for which the diagnostics are reported.
     * If the document is not marked as open `null` can be provided.
     */
    version: integer | null;
};
/**
 * An unchanged document diagnostic report for a workspace diagnostic result.
 *
 * @since 3.17.0
 */
type WorkspaceUnchangedDocumentDiagnosticReport = UnchangedDocumentDiagnosticReport & {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * The version number for which the diagnostics are reported.
     * If the document is not marked as open `null` can be provided.
     */
    version: integer | null;
};
/**
 * A workspace diagnostic document report.
 *
 * @since 3.17.0
 */
type WorkspaceDocumentDiagnosticReport = WorkspaceFullDocumentDiagnosticReport | WorkspaceUnchangedDocumentDiagnosticReport;
/**
 * A workspace diagnostic report.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticReport = {
    items: WorkspaceDocumentDiagnosticReport[];
};
/**
 * A partial result for a workspace diagnostic report.
 *
 * @since 3.17.0
 */
type WorkspaceDiagnosticReportPartialResult = {
    items: WorkspaceDocumentDiagnosticReport[];
};

/**
 * Notebook specific client capabilities.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration. If this is
     * set to `true` the client supports the new
     * `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
     * return value for the corresponding server capability as well.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports sending execution summary data per cell.
     */
    executionSummarySupport?: boolean;
};
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
declare namespace NotebookCellKind {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    const Markup: 1;
    /**
     * A code-cell is source code.
     */
    const Code: 2;
    function is(value: any): value is NotebookCellKind;
}
type NotebookCellKind = 1 | 2;
type ExecutionSummary = {
    /**
     * A strict monotonically increasing value
     * indicating the execution order of a cell
     * inside a notebook.
     */
    executionOrder: uinteger;
    /**
     * Whether the execution was successful or
     * not if known by the client.
     */
    success?: boolean;
};
declare namespace ExecutionSummary {
    function create(executionOrder: number, success?: boolean): ExecutionSummary;
    function is(value: any): value is ExecutionSummary;
    function equals(one: ExecutionSummary | undefined, other: ExecutionSummary | undefined): boolean;
}
/**
 * A notebook cell.
 *
 * A cell's document URI must be unique across ALL notebook
 * cells and can therefore be used to uniquely identify a
 * notebook cell or the cell's text document.
 *
 * @since 3.17.0
 */
type NotebookCell = {
    /**
     * The cell's kind
     */
    kind: NotebookCellKind;
    /**
     * The URI of the cell's text document
     * content.
     */
    document: DocumentUri$1;
    /**
     * Additional metadata stored with the cell.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * Additional execution summary information
     * if supported by the client.
     */
    executionSummary?: ExecutionSummary;
};
declare namespace NotebookCell {
    function create(kind: NotebookCellKind, document: DocumentUri$1): NotebookCell;
    function is(value: any): value is NotebookCell;
    function diff(one: NotebookCell, two: NotebookCell): Set<keyof NotebookCell>;
}
/**
 * A notebook document.
 *
 * @since 3.17.0
 */
type NotebookDocument = {
    /**
     * The notebook document's uri.
     */
    uri: URI;
    /**
     * The type of the notebook.
     */
    notebookType: string;
    /**
     * The version number of this document (it will increase after each
     * change, including undo/redo).
     */
    version: integer;
    /**
     * Additional metadata stored with the notebook
     * document.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * The cells of a notebook.
     */
    cells: NotebookCell[];
};
declare namespace NotebookDocument {
    function create(uri: URI, notebookType: string, version: integer, cells: NotebookCell[]): NotebookDocument;
    function is(value: any): value is NotebookDocument;
}
/**
 * A literal to identify a notebook document in the client.
 *
 * @since 3.17.0
 */
type NotebookDocumentIdentifier = {
    /**
     * The notebook document's uri.
     */
    uri: URI;
};
/**
 * A versioned notebook document identifier.
 *
 * @since 3.17.0
 */
type VersionedNotebookDocumentIdentifier = {
    /**
     * The version number of this notebook document.
     */
    version: integer;
    /**
     * The notebook document's uri.
     */
    uri: URI;
};
/**
 * Options specific to a notebook plus its cells
 * to be synced to the server.
 *
 * If a selector provides a notebook document
 * filter but no cell selector all cells of a
 * matching notebook document will be synced.
 *
 * If a selector provides no notebook document
 * filter but only a cell selector all notebook
 * document that contain at least one matching
 * cell will be synced.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncOptions = {
    /**
     * The notebooks to be synced
     */
    notebookSelector: ({
        /**
         * The notebook to be synced If a string
         * value is provided it matches against the
         * notebook type. '*' matches every notebook.
         */
        notebook: string | NotebookDocumentFilter;
        /**
         * The cells of the matching notebook to be synced.
         */
        cells?: {
            language: string;
        }[];
    } | {
        /**
         * The notebook to be synced If a string
         * value is provided it matches against the
         * notebook type. '*' matches every notebook.
         */
        notebook?: string | NotebookDocumentFilter;
        /**
         * The cells of the matching notebook to be synced.
         */
        cells: {
            language: string;
        }[];
    })[];
    /**
     * Whether save notification should be forwarded to
     * the server. Will only be honored if mode === `notebook`.
     */
    save?: boolean;
};
/**
 * Registration options specific to a notebook.
 *
 * @since 3.17.0
 */
type NotebookDocumentSyncRegistrationOptions = NotebookDocumentSyncOptions & StaticRegistrationOptions;
/**
 * The params sent in an open notebook document notification.
 *
 * @since 3.17.0
 */
type DidOpenNotebookDocumentParams = {
    /**
     * The notebook document that got opened.
     */
    notebookDocument: NotebookDocument;
    /**
     * The text documents that represent the content
     * of a notebook cell.
     */
    cellTextDocuments: TextDocumentItem[];
};
/**
 * A change describing how to move a `NotebookCell`
 * array from state S to S'.
 *
 * @since 3.17.0
 */
type NotebookCellArrayChange = {
    /**
     * The start oftest of the cell that changed.
     */
    start: uinteger;
    /**
     * The deleted cells
     */
    deleteCount: uinteger;
    /**
     * The new cells, if any
     */
    cells?: NotebookCell[];
};
declare namespace NotebookCellArrayChange {
    function is(value: any): value is NotebookCellArrayChange;
    function create(start: uinteger, deleteCount: uinteger, cells?: NotebookCell[]): NotebookCellArrayChange;
}
/**
 * A change event for a notebook document.
 *
 * @since 3.17.0
 */
type NotebookDocumentChangeEvent$1 = {
    /**
     * The changed meta data if any.
     *
     * Note: should always be an object literal (e.g. LSPObject)
     */
    metadata?: LSPObject;
    /**
     * Changes to cells
     */
    cells?: {
        /**
         * Changes to the cell structure to add or
         * remove cells.
         */
        structure?: {
            /**
             * The change to the cell array.
             */
            array: NotebookCellArrayChange;
            /**
             * Additional opened cell text documents.
             */
            didOpen?: TextDocumentItem[];
            /**
             * Additional closed cell text documents.
             */
            didClose?: TextDocumentIdentifier[];
        };
        /**
         * Changes to notebook cells properties like its
         * kind, execution summary or metadata.
         */
        data?: NotebookCell[];
        /**
         * Changes to the text content of notebook cells.
         */
        textContent?: {
            document: VersionedTextDocumentIdentifier;
            changes: TextDocumentContentChangeEvent[];
        }[];
    };
};
/**
 * The params sent in a change notebook document notification.
 *
 * @since 3.17.0
 */
type DidChangeNotebookDocumentParams = {
    /**
     * The notebook document that did change. The version number points
     * to the version after all provided changes have been applied. If
     * only the text document content of a cell changes the notebook version
     * doesn't necessarily have to change.
     */
    notebookDocument: VersionedNotebookDocumentIdentifier;
    /**
     * The actual changes to the notebook document.
     *
     * The changes describe single state changes to the notebook document.
     * So if there are two changes c1 (at array index 0) and c2 (at array
     * index 1) for a notebook in state S then c1 moves the notebook from
     * S to S' and c2 from S' to S''. So c1 is computed on the state S and
     * c2 is computed on the state S'.
     *
     * To mirror the content of a notebook using change events use the following approach:
     * - start with the same initial content
     * - apply the 'notebookDocument/didChange' notifications in the order you receive them.
     * - apply the `NotebookChangeEvent`s in a single notification in the order
     *   you receive them.
     */
    change: NotebookDocumentChangeEvent$1;
};
/**
 * The params sent in a save notebook document notification.
 *
 * @since 3.17.0
 */
type DidSaveNotebookDocumentParams = {
    /**
     * The notebook document that got saved.
     */
    notebookDocument: NotebookDocumentIdentifier;
};
/**
 * The params sent in a close notebook document notification.
 *
 * @since 3.17.0
 */
type DidCloseNotebookDocumentParams = {
    /**
     * The notebook document that got closed.
     */
    notebookDocument: NotebookDocumentIdentifier;
    /**
     * The text documents that represent the content
     * of a notebook cell that got closed.
     */
    cellTextDocuments: TextDocumentIdentifier[];
};

/**
 * Client capabilities specific to inline completions.
 *
 * @since 3.18.0
 * @proposed
 */
type InlineCompletionClientCapabilities = {
    /**
     * Whether implementation supports dynamic registration for inline completion providers.
     */
    dynamicRegistration?: boolean;
};
/**
 * Inline completion options used during static registration.
 *
 * @since 3.18.0
 * @proposed
 */
type InlineCompletionOptions = WorkDoneProgressOptions;

/**
 * A document filter denotes a document by different properties like
 * the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
 * its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
 *
 * Glob patterns can have the following syntax:
 * - `*` to match one or more characters in a path segment
 * - `?` to match on one character in a path segment
 * - `**` to match any number of path segments, including none
 * - `{}` to group sub patterns into an OR expression. (e.g. `**â€‹/*.{ts,js}` matches all TypeScript and JavaScript files)
 * - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, â€¦)
 * - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
 *
 * @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
 * @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
 *
 * @since 3.17.0
 */
type TextDocumentFilter = {
    /** A language id, like `typescript`. */
    language: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern, like **â€‹/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern?: string;
} | {
    /** A language id, like `typescript`. */
    language?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme: string;
    /** A glob pattern, like **â€‹/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern?: string;
} | {
    /** A language id, like `typescript`. */
    language?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern, like **â€‹/*.{ts,js}. See TextDocumentFilter for examples. */
    pattern: string;
};
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace TextDocumentFilter {
    function is(value: any): value is TextDocumentFilter;
}
/**
 * A notebook document filter denotes a notebook document by
 * different properties. The properties will be match
 * against the notebook's URI (same as with documents)
 *
 * @since 3.17.0
 */
type NotebookDocumentFilter = {
    /** The type of the enclosing notebook. */
    notebookType: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern. */
    pattern?: string;
} | {
    /** The type of the enclosing notebook. */
    notebookType?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`.*/
    scheme: string;
    /** A glob pattern. */
    pattern?: string;
} | {
    /** The type of the enclosing notebook. */
    notebookType?: string;
    /** A Uri {@link Uri.scheme scheme}, like `file` or `untitled`. */
    scheme?: string;
    /** A glob pattern. */
    pattern: string;
};
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace NotebookDocumentFilter {
    function is(value: any): value is NotebookDocumentFilter;
}
/**
 * A notebook cell text document filter denotes a cell text
 * document by different properties.
 *
 * @since 3.17.0
 */
type NotebookCellTextDocumentFilter = {
    /**
     * A filter that matches against the notebook
     * containing the notebook cell. If a string
     * value is provided it matches against the
     * notebook type. '*' matches every notebook.
     */
    notebook: string | NotebookDocumentFilter;
    /**
     * A language id like `python`.
     *
     * Will be matched against the language id of the
     * notebook cell document. '*' matches every language.
     */
    language?: string;
};
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
declare namespace NotebookCellTextDocumentFilter {
    function is(value: any): value is NotebookCellTextDocumentFilter;
}
/**
 * A document filter describes a top level text document or
 * a notebook cell document.
 *
 * @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
 */
type DocumentFilter = TextDocumentFilter | NotebookCellTextDocumentFilter;
/**
 * A document selector is the combination of one or many document filters.
 *
 * @sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**âˆ•tsconfig.json' }]`;
 *
 * The use of a string as a document filter is deprecated @since 3.16.0.
 */
type DocumentSelector = (string | DocumentFilter)[];
/**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */
declare namespace DocumentSelector {
    function is(value: any[] | undefined | null): value is DocumentSelector;
}
interface WorkDoneProgressParams {
    /**
     * An optional token that a server can use to report work done progress.
     */
    workDoneToken?: ProgressToken;
}
interface PartialResultParams {
    /**
     * An optional token that a server can use to report partial results (e.g. streaming) to
     * the client.
     */
    partialResultToken?: ProgressToken;
}
/**
 * A parameter literal used in requests to pass a text document and a position inside that
 * document.
 */
interface TextDocumentPositionParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position inside the text document.
     */
    position: Position$1;
}
/**
 * The kind of resource operations supported by the client.
 */
type ResourceOperationKind = 'create' | 'rename' | 'delete';
declare namespace ResourceOperationKind {
    /**
     * Supports creating new files and folders.
     */
    const Create: ResourceOperationKind;
    /**
     * Supports renaming existing files and folders.
     */
    const Rename: ResourceOperationKind;
    /**
     * Supports deleting existing files and folders.
     */
    const Delete: ResourceOperationKind;
}
type FailureHandlingKind = 'abort' | 'transactional' | 'undo' | 'textOnlyTransactional';
declare namespace FailureHandlingKind {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    const Abort: FailureHandlingKind;
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    const Transactional: FailureHandlingKind;
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    const TextOnlyTransactional: FailureHandlingKind;
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    const Undo: FailureHandlingKind;
}
/**
 * Workspace specific client capabilities.
 */
interface WorkspaceClientCapabilities {
    /**
     * The client supports applying batch edits
     * to the workspace by supporting the request
     * 'workspace/applyEdit'
     */
    applyEdit?: boolean;
    /**
     * Capabilities specific to `WorkspaceEdit`s.
     */
    workspaceEdit?: WorkspaceEditClientCapabilities;
    /**
     * Capabilities specific to the `workspace/didChangeConfiguration` notification.
     */
    didChangeConfiguration?: DidChangeConfigurationClientCapabilities;
    /**
     * Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
     */
    didChangeWatchedFiles?: DidChangeWatchedFilesClientCapabilities;
    /**
     * Capabilities specific to the `workspace/symbol` request.
     */
    symbol?: WorkspaceSymbolClientCapabilities;
    /**
     * Capabilities specific to the `workspace/executeCommand` request.
     */
    executeCommand?: ExecuteCommandClientCapabilities;
    /**
     * The client has support for workspace folders.
     *
     * @since 3.6.0
     */
    workspaceFolders?: boolean;
    /**
     * The client supports `workspace/configuration` requests.
     *
     * @since 3.6.0
     */
    configuration?: boolean;
    /**
     * Capabilities specific to the semantic token requests scoped to the
     * workspace.
     *
     * @since 3.16.0.
     */
    semanticTokens?: SemanticTokensWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the code lens requests scoped to the
     * workspace.
     *
     * @since 3.16.0.
     */
    codeLens?: CodeLensWorkspaceClientCapabilities;
    /**
     * The client has support for file notifications/requests for user operations on files.
     *
     * Since 3.16.0
     */
    fileOperations?: FileOperationClientCapabilities;
    /**
     * Capabilities specific to the inline values requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    inlineValue?: InlineValueWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the inlay hint requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    inlayHint?: InlayHintWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the diagnostic requests scoped to the
     * workspace.
     *
     * @since 3.17.0.
     */
    diagnostics?: DiagnosticWorkspaceClientCapabilities;
    /**
     * Capabilities specific to the folding range requests scoped to the workspace.
     *
     * @since 3.18.0
     * @proposed
     */
    foldingRange?: FoldingRangeWorkspaceClientCapabilities;
}
/**
 * Text document specific client capabilities.
 */
interface TextDocumentClientCapabilities {
    /**
     * Defines which synchronization capabilities the client supports.
     */
    synchronization?: TextDocumentSyncClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/completion` request.
     */
    completion?: CompletionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/hover` request.
     */
    hover?: HoverClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/signatureHelp` request.
     */
    signatureHelp?: SignatureHelpClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/declaration` request.
     *
     * @since 3.14.0
     */
    declaration?: DeclarationClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/definition` request.
     */
    definition?: DefinitionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/typeDefinition` request.
     *
     * @since 3.6.0
     */
    typeDefinition?: TypeDefinitionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/implementation` request.
     *
     * @since 3.6.0
     */
    implementation?: ImplementationClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/references` request.
     */
    references?: ReferenceClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentHighlight` request.
     */
    documentHighlight?: DocumentHighlightClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentSymbol` request.
     */
    documentSymbol?: DocumentSymbolClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/codeAction` request.
     */
    codeAction?: CodeActionClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/codeLens` request.
     */
    codeLens?: CodeLensClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentLink` request.
     */
    documentLink?: DocumentLinkClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/documentColor` and the
     * `textDocument/colorPresentation` request.
     *
     * @since 3.6.0
     */
    colorProvider?: DocumentColorClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/formatting` request.
     */
    formatting?: DocumentFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/rangeFormatting` request.
     */
    rangeFormatting?: DocumentRangeFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/onTypeFormatting` request.
     */
    onTypeFormatting?: DocumentOnTypeFormattingClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/rename` request.
     */
    rename?: RenameClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/foldingRange` request.
     *
     * @since 3.10.0
     */
    foldingRange?: FoldingRangeClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/selectionRange` request.
     *
     * @since 3.15.0
     */
    selectionRange?: SelectionRangeClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/publishDiagnostics` notification.
     */
    publishDiagnostics?: PublishDiagnosticsClientCapabilities;
    /**
     * Capabilities specific to the various call hierarchy requests.
     *
     * @since 3.16.0
     */
    callHierarchy?: CallHierarchyClientCapabilities;
    /**
     * Capabilities specific to the various semantic token request.
     *
     * @since 3.16.0
     */
    semanticTokens?: SemanticTokensClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/linkedEditingRange` request.
     *
     * @since 3.16.0
     */
    linkedEditingRange?: LinkedEditingRangeClientCapabilities;
    /**
     * Client capabilities specific to the `textDocument/moniker` request.
     *
     * @since 3.16.0
     */
    moniker?: MonikerClientCapabilities;
    /**
     * Capabilities specific to the various type hierarchy requests.
     *
     * @since 3.17.0
     */
    typeHierarchy?: TypeHierarchyClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/inlineValue` request.
     *
     * @since 3.17.0
     */
    inlineValue?: InlineValueClientCapabilities;
    /**
     * Capabilities specific to the `textDocument/inlayHint` request.
     *
     * @since 3.17.0
     */
    inlayHint?: InlayHintClientCapabilities;
    /**
     * Capabilities specific to the diagnostic pull model.
     *
     * @since 3.17.0
     */
    diagnostic?: DiagnosticClientCapabilities;
    /**
     * Client capabilities specific to inline completions.
     *
     * @since 3.18.0
     * @proposed
     */
    inlineCompletion?: InlineCompletionClientCapabilities;
}
interface WindowClientCapabilities {
    /**
     * It indicates whether the client supports server initiated
     * progress using the `window/workDoneProgress/create` request.
     *
     * The capability also controls Whether client supports handling
     * of progress notifications. If set servers are allowed to report a
     * `workDoneProgress` property in the request specific server
     * capabilities.
     *
     * @since 3.15.0
     */
    workDoneProgress?: boolean;
    /**
     * Capabilities specific to the showMessage request.
     *
     * @since 3.16.0
     */
    showMessage?: ShowMessageRequestClientCapabilities;
    /**
     * Capabilities specific to the showDocument request.
     *
     * @since 3.16.0
     */
    showDocument?: ShowDocumentClientCapabilities;
}
/**
 * Client capabilities specific to regular expressions.
 *
 * @since 3.16.0
 */
interface RegularExpressionsClientCapabilities {
    /**
     * The engine's name.
     */
    engine: string;
    /**
     * The engine's version.
     */
    version?: string;
}
/**
 * Client capabilities specific to the used markdown parser.
 *
 * @since 3.16.0
 */
interface MarkdownClientCapabilities {
    /**
     * The name of the parser.
     */
    parser: string;
    /**
     * The version of the parser.
     */
    version?: string;
    /**
     * A list of HTML tags that the client allows / supports in
     * Markdown.
     *
     * @since 3.17.0
     */
    allowedTags?: string[];
}
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
declare namespace PositionEncodingKind {
    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */
    const UTF8: PositionEncodingKind;
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    const UTF16: PositionEncodingKind;
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    const UTF32: PositionEncodingKind;
}
/**
 * A type indicating how positions are encoded,
 * specifically what column offsets mean.
 *
 * @since 3.17.0
 */
type PositionEncodingKind = string;
/**
 * General client capabilities.
 *
 * @since 3.16.0
 */
interface GeneralClientCapabilities {
    /**
     * Client capability that signals how the client
     * handles stale requests (e.g. a request
     * for which the client will not process the response
     * anymore since the information is outdated).
     *
     * @since 3.17.0
     */
    staleRequestSupport?: {
        /**
         * The client will actively cancel the request.
         */
        cancel: boolean;
        /**
         * The list of requests for which the client
         * will retry the request if it receives a
         * response with error code `ContentModified`
         */
        retryOnContentModified: string[];
    };
    /**
     * Client capabilities specific to regular expressions.
     *
     * @since 3.16.0
     */
    regularExpressions?: RegularExpressionsClientCapabilities;
    /**
     * Client capabilities specific to the client's markdown parser.
     *
     * @since 3.16.0
     */
    markdown?: MarkdownClientCapabilities;
    /**
     * The position encodings supported by the client. Client and server
     * have to agree on the same position encoding to ensure that offsets
     * (e.g. character position in a line) are interpreted the same on both
     * sides.
     *
     * To keep the protocol backwards compatible the following applies: if
     * the value 'utf-16' is missing from the array of position encodings
     * servers can assume that the client supports UTF-16. UTF-16 is
     * therefore a mandatory encoding.
     *
     * If omitted it defaults to ['utf-16'].
     *
     * Implementation considerations: since the conversion from one encoding
     * into another requires the content of the file / line the conversion
     * is best done where the file is read which is usually on the server
     * side.
     *
     * @since 3.17.0
     */
    positionEncodings?: PositionEncodingKind[];
}
/**
 * Capabilities specific to the notebook document support.
 *
 * @since 3.17.0
 */
interface NotebookDocumentClientCapabilities {
    /**
     * Capabilities specific to notebook document synchronization
     *
     * @since 3.17.0
     */
    synchronization: NotebookDocumentSyncClientCapabilities;
}
/**
 * Defines the capabilities provided by the client.
 */
interface ClientCapabilities$1 {
    /**
     * Workspace specific client capabilities.
     */
    workspace?: WorkspaceClientCapabilities;
    /**
     * Text document specific client capabilities.
     */
    textDocument?: TextDocumentClientCapabilities;
    /**
     * Capabilities specific to the notebook document support.
     *
     * @since 3.17.0
     */
    notebookDocument?: NotebookDocumentClientCapabilities;
    /**
     * Window specific client capabilities.
     */
    window?: WindowClientCapabilities;
    /**
     * General client capabilities.
     *
     * @since 3.16.0
     */
    general?: GeneralClientCapabilities;
    /**
     * Experimental client capabilities.
     */
    experimental?: LSPAny;
}
/**
 * Static registration options to be returned in the initialize
 * request.
 */
interface StaticRegistrationOptions {
    /**
     * The id used to register the request. The id can be used to deregister
     * the request again. See also Registration#id.
     */
    id?: string;
}
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */
declare namespace StaticRegistrationOptions {
    function hasId(value: object): value is {
        id: string;
    };
}
/**
 * General text document registration options.
 */
interface TextDocumentRegistrationOptions {
    /**
     * A document selector to identify the scope of the registration. If set to null
     * the document selector provided on the client side will be used.
     */
    documentSelector: DocumentSelector | null;
}
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */
declare namespace TextDocumentRegistrationOptions {
    function is(value: any): value is TextDocumentRegistrationOptions;
}
/**
 * Save options.
 */
interface SaveOptions {
    /**
     * The client is supposed to include the content on save.
     */
    includeText?: boolean;
}
interface WorkDoneProgressOptions {
    workDoneProgress?: boolean;
}
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */
declare namespace WorkDoneProgressOptions {
    function is(value: any): value is WorkDoneProgressOptions;
    function hasWorkDoneProgress(value: any): value is {
        workDoneProgress: boolean;
    };
}
/**
 * Defines the capabilities provided by a language
 * server.
 */
interface ServerCapabilities$1<T = LSPAny> {
    /**
     * The position encoding the server picked from the encodings offered
     * by the client via the client capability `general.positionEncodings`.
     *
     * If the client didn't provide any position encodings the only valid
     * value that a server can return is 'utf-16'.
     *
     * If omitted it defaults to 'utf-16'.
     *
     * @since 3.17.0
     */
    positionEncoding?: PositionEncodingKind;
    /**
     * Defines how text documents are synced. Is either a detailed structure
     * defining each notification or for backwards compatibility the
     * TextDocumentSyncKind number.
     */
    textDocumentSync?: TextDocumentSyncOptions | TextDocumentSyncKind;
    /**
     * Defines how notebook documents are synced.
     *
     * @since 3.17.0
     */
    notebookDocumentSync?: NotebookDocumentSyncOptions | NotebookDocumentSyncRegistrationOptions;
    /**
     * The server provides completion support.
     */
    completionProvider?: CompletionOptions;
    /**
     * The server provides hover support.
     */
    hoverProvider?: boolean | HoverOptions;
    /**
     * The server provides signature help support.
     */
    signatureHelpProvider?: SignatureHelpOptions;
    /**
     * The server provides Goto Declaration support.
     */
    declarationProvider?: boolean | DeclarationOptions | DeclarationRegistrationOptions;
    /**
     * The server provides goto definition support.
     */
    definitionProvider?: boolean | DefinitionOptions;
    /**
     * The server provides Goto Type Definition support.
     */
    typeDefinitionProvider?: boolean | TypeDefinitionOptions | TypeDefinitionRegistrationOptions;
    /**
     * The server provides Goto Implementation support.
     */
    implementationProvider?: boolean | ImplementationOptions | ImplementationRegistrationOptions;
    /**
     * The server provides find references support.
     */
    referencesProvider?: boolean | ReferenceOptions;
    /**
     * The server provides document highlight support.
     */
    documentHighlightProvider?: boolean | DocumentHighlightOptions;
    /**
     * The server provides document symbol support.
     */
    documentSymbolProvider?: boolean | DocumentSymbolOptions;
    /**
     * The server provides code actions. CodeActionOptions may only be
     * specified if the client states that it supports
     * `codeActionLiteralSupport` in its initial `initialize` request.
     */
    codeActionProvider?: boolean | CodeActionOptions;
    /**
     * The server provides code lens.
     */
    codeLensProvider?: CodeLensOptions;
    /**
     * The server provides document link support.
     */
    documentLinkProvider?: DocumentLinkOptions;
    /**
     * The server provides color provider support.
     */
    colorProvider?: boolean | DocumentColorOptions | DocumentColorRegistrationOptions;
    /**
     * The server provides workspace symbol support.
     */
    workspaceSymbolProvider?: boolean | WorkspaceSymbolOptions;
    /**
     * The server provides document formatting.
     */
    documentFormattingProvider?: boolean | DocumentFormattingOptions;
    /**
     * The server provides document range formatting.
     */
    documentRangeFormattingProvider?: boolean | DocumentRangeFormattingOptions;
    /**
     * The server provides document formatting on typing.
     */
    documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions;
    /**
     * The server provides rename support. RenameOptions may only be
     * specified if the client states that it supports
     * `prepareSupport` in its initial `initialize` request.
     */
    renameProvider?: boolean | RenameOptions;
    /**
     * The server provides folding provider support.
     */
    foldingRangeProvider?: boolean | FoldingRangeOptions | FoldingRangeRegistrationOptions;
    /**
     * The server provides selection range support.
     */
    selectionRangeProvider?: boolean | SelectionRangeOptions | SelectionRangeRegistrationOptions;
    /**
     * The server provides execute command support.
     */
    executeCommandProvider?: ExecuteCommandOptions;
    /**
     * The server provides call hierarchy support.
     *
     * @since 3.16.0
     */
    callHierarchyProvider?: boolean | CallHierarchyOptions | CallHierarchyRegistrationOptions;
    /**
     * The server provides linked editing range support.
     *
     * @since 3.16.0
     */
    linkedEditingRangeProvider?: boolean | LinkedEditingRangeOptions | LinkedEditingRangeRegistrationOptions;
    /**
     * The server provides semantic tokens support.
     *
     * @since 3.16.0
     */
    semanticTokensProvider?: SemanticTokensOptions | SemanticTokensRegistrationOptions;
    /**
     * The server provides moniker support.
     *
     * @since 3.16.0
     */
    monikerProvider?: boolean | MonikerOptions | MonikerRegistrationOptions;
    /**
     * The server provides type hierarchy support.
     *
     * @since 3.17.0
     */
    typeHierarchyProvider?: boolean | TypeHierarchyOptions | TypeHierarchyRegistrationOptions;
    /**
     * The server provides inline values.
     *
     * @since 3.17.0
     */
    inlineValueProvider?: boolean | InlineValueOptions | InlineValueRegistrationOptions;
    /**
     * The server provides inlay hints.
     *
     * @since 3.17.0
     */
    inlayHintProvider?: boolean | InlayHintOptions | InlayHintRegistrationOptions;
    /**
     * The server has support for pull model diagnostics.
     *
     * @since 3.17.0
     */
    diagnosticProvider?: DiagnosticOptions | DiagnosticRegistrationOptions;
    /**
     * Inline completion options used during static registration.
     *
     * @since 3.18.0
     * @proposed
     */
    inlineCompletionProvider?: boolean | InlineCompletionOptions;
    /**
     * Workspace specific server capabilities.
     */
    workspace?: {
        /**
         * The server supports workspace folder.
         *
         * @since 3.6.0
         */
        workspaceFolders?: WorkspaceFoldersServerCapabilities;
        /**
        * The server is interested in notifications/requests for operations on files.
        *
        * @since 3.16.0
        */
        fileOperations?: FileOperationOptions;
    };
    /**
     * Experimental server capabilities.
     */
    experimental?: T;
}
/**
 * The initialize parameters
 */
interface _InitializeParams extends WorkDoneProgressParams {
    /**
     * The process Id of the parent process that started
     * the server.
     *
     * Is `null` if the process has not been started by another process.
     * If the parent process is not alive then the server should exit.
     */
    processId: integer | null;
    /**
     * Information about the client
     *
     * @since 3.15.0
     */
    clientInfo?: {
        /**
         * The name of the client as defined by the client.
         */
        name: string;
        /**
         * The client's version as defined by the client.
         */
        version?: string;
    };
    /**
     * The locale the client is currently showing the user interface
     * in. This must not necessarily be the locale of the operating
     * system.
     *
     * Uses IETF language tags as the value's syntax
     * (See https://en.wikipedia.org/wiki/IETF_language_tag)
     *
     * @since 3.16.0
     */
    locale?: string;
    /**
     * The rootPath of the workspace. Is null
     * if no folder is open.
     *
     * @deprecated in favour of rootUri.
     */
    rootPath?: string | null;
    /**
     * The rootUri of the workspace. Is null if no
     * folder is open. If both `rootPath` and `rootUri` are set
     * `rootUri` wins.
     *
     * @deprecated in favour of workspaceFolders.
     */
    rootUri: DocumentUri$1 | null;
    /**
     * The capabilities provided by the client (editor or tool)
     */
    capabilities: ClientCapabilities$1;
    /**
     * User provided initialization options.
     */
    initializationOptions?: LSPAny;
    /**
     * The initial trace setting. If omitted trace is disabled ('off').
     */
    trace?: TraceValues;
}
type InitializeParams = _InitializeParams & WorkspaceFoldersInitializeParams;
/**
 * The result returned from an initialize request.
 */
interface InitializeResult<T = any> {
    /**
     * The capabilities the language server provides.
     */
    capabilities: ServerCapabilities$1<T>;
    /**
     * Information about the server.
     *
     * @since 3.15.0
     */
    serverInfo?: {
        /**
         * The name of the server as defined by the server.
         */
        name: string;
        /**
         * The server's version as defined by the server.
         */
        version?: string;
    };
    /**
     * Custom initialization results.
     */
    [custom: string]: LSPAny | ServerCapabilities$1<T> | undefined; /** undefined is needed since serverInfo is optional */
}
/**
 * The data type of the ResponseError if the
 * initialize request fails.
 */
interface InitializeError {
    /**
     * Indicates whether the client execute the following retry logic:
     * (1) show the message provided by the ResponseError to the user
     * (2) user selects retry or cancel
     * (3) if user selected retry the initialize method is sent again.
     */
    retry: boolean;
}
interface InitializedParams {
}
interface DidChangeConfigurationClientCapabilities {
    /**
     * Did change configuration notification supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
interface DidChangeConfigurationRegistrationOptions {
    section?: string | string[];
}
/**
 * The parameters of a change configuration notification.
 */
interface DidChangeConfigurationParams {
    /**
     * The actual changed settings
     */
    settings: LSPAny;
}
/**
 * Show message request client capabilities
 */
interface ShowMessageRequestClientCapabilities {
    /**
     * Capabilities specific to the `MessageActionItem` type.
     */
    messageActionItem?: {
        /**
         * Whether the client supports additional attributes which
         * are preserved and send back to the server in the
         * request's response.
         */
        additionalPropertiesSupport?: boolean;
    };
}
interface MessageActionItem {
    /**
     * A short title like 'Retry', 'Open Log' etc.
     */
    title: string;
    /**
     * Additional attributes that the client preserves and
     * sends back to the server. This depends on the client
     * capability window.messageActionItem.additionalPropertiesSupport
     */
    [key: string]: string | boolean | integer | object;
}
interface TextDocumentSyncClientCapabilities {
    /**
     * Whether text document synchronization supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports sending will save notifications.
     */
    willSave?: boolean;
    /**
     * The client supports sending a will save request and
     * waits for a response providing text edits which will
     * be applied to the document before it is saved.
     */
    willSaveWaitUntil?: boolean;
    /**
     * The client supports did save notifications.
     */
    didSave?: boolean;
}
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
declare namespace TextDocumentSyncKind {
    /**
     * Documents should not be synced at all.
     */
    const None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    const Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    const Incremental = 2;
}
type TextDocumentSyncKind = 0 | 1 | 2;
interface TextDocumentSyncOptions {
    /**
     * Open and close notifications are sent to the server. If omitted open close notification should not
     * be sent.
     */
    openClose?: boolean;
    /**
     * Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
     * and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
     */
    change?: TextDocumentSyncKind;
    /**
     * If present will save notifications are sent to the server. If omitted the notification should not be
     * sent.
     */
    willSave?: boolean;
    /**
     * If present will save wait until requests are sent to the server. If omitted the request should not be
     * sent.
     */
    willSaveWaitUntil?: boolean;
    /**
     * If present save notifications are sent to the server. If omitted the notification should not be
     * sent.
     */
    save?: boolean | SaveOptions;
}
/**
 * The parameters sent in an open text document notification
 */
interface DidOpenTextDocumentParams {
    /**
     * The document that was opened.
     */
    textDocument: TextDocumentItem;
}
/**
 * An event describing a change to a text document. If only a text is provided
 * it is considered to be the full content of the document.
 */
type TextDocumentContentChangeEvent = {
    /**
     * The range of the document that changed.
     */
    range: Range$1;
    /**
     * The optional length of the range that got replaced.
     *
     * @deprecated use range instead.
     */
    rangeLength?: uinteger;
    /**
     * The new text for the provided range.
     */
    text: string;
} | {
    /**
     * The new text of the whole document.
     */
    text: string;
};
declare namespace TextDocumentContentChangeEvent {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event: TextDocumentContentChangeEvent): event is {
        range: Range$1;
        rangeLength?: uinteger;
        text: string;
    };
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event: TextDocumentContentChangeEvent): event is {
        text: string;
    };
}
/**
 * The change text document notification's parameters.
 */
interface DidChangeTextDocumentParams {
    /**
     * The document that did change. The version number points
     * to the version after all provided content changes have
     * been applied.
     */
    textDocument: VersionedTextDocumentIdentifier;
    /**
     * The actual content changes. The content changes describe single state changes
     * to the document. So if there are two content changes c1 (at array index 0) and
     * c2 (at array index 1) for a document in state S then c1 moves the document from
     * S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
     * on the state S'.
     *
     * To mirror the content of a document using change events use the following approach:
     * - start with the same initial content
     * - apply the 'textDocument/didChange' notifications in the order you receive them.
     * - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
     *   you receive them.
     */
    contentChanges: TextDocumentContentChangeEvent[];
}
/**
 * The parameters sent in a close text document notification
 */
interface DidCloseTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * The parameters sent in a save text document notification
 */
interface DidSaveTextDocumentParams {
    /**
     * The document that was saved.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * Optional the content when saved. Depends on the includeText value
     * when the save notification was requested.
     */
    text?: string;
}
/**
 * Represents reasons why a text document is saved.
 */
declare namespace TextDocumentSaveReason {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    const Manual: 1;
    /**
     * Automatic after a delay.
     */
    const AfterDelay: 2;
    /**
     * When the editor lost focus.
     */
    const FocusOut: 3;
}
type TextDocumentSaveReason = 1 | 2 | 3;
/**
 * The parameters sent in a will save text document notification.
 */
interface WillSaveTextDocumentParams {
    /**
     * The document that will be saved.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The 'TextDocumentSaveReason'.
     */
    reason: TextDocumentSaveReason;
}
interface DidChangeWatchedFilesClientCapabilities {
    /**
     * Did change watched files notification supports dynamic registration. Please note
     * that the current protocol doesn't support static configuration for file changes
     * from the server side.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client has support for {@link  RelativePattern relative pattern}
     * or not.
     *
     * @since 3.17.0
     */
    relativePatternSupport?: boolean;
}
/**
 * The watched files change notification's parameters.
 */
interface DidChangeWatchedFilesParams {
    /**
     * The actual file events.
     */
    changes: FileEvent[];
}
/**
 * The file event type
 */
declare namespace FileChangeType {
    /**
     * The file got created.
     */
    const Created = 1;
    /**
     * The file got changed.
     */
    const Changed = 2;
    /**
     * The file got deleted.
     */
    const Deleted = 3;
}
type FileChangeType = 1 | 2 | 3;
/**
 * An event describing a file change.
 */
interface FileEvent {
    /**
     * The file's uri.
     */
    uri: DocumentUri$1;
    /**
     * The change type.
     */
    type: FileChangeType;
}
/**
 * The publish diagnostic client capabilities.
 */
interface PublishDiagnosticsClientCapabilities {
    /**
     * Whether the clients accepts diagnostics with related information.
     */
    relatedInformation?: boolean;
    /**
     * Client supports the tag property to provide meta data about a diagnostic.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.15.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: DiagnosticTag[];
    };
    /**
     * Whether the client interprets the version property of the
     * `textDocument/publishDiagnostics` notification's parameter.
     *
     * @since 3.15.0
     */
    versionSupport?: boolean;
    /**
     * Client supports a codeDescription property
     *
     * @since 3.16.0
     */
    codeDescriptionSupport?: boolean;
    /**
     * Whether code action supports the `data` property which is
     * preserved between a `textDocument/publishDiagnostics` and
     * `textDocument/codeAction` request.
     *
     * @since 3.16.0
     */
    dataSupport?: boolean;
}
/**
 * The publish diagnostic notification's parameters.
 */
interface PublishDiagnosticsParams {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: DocumentUri$1;
    /**
     * Optional the version number of the document the diagnostics are published for.
     *
     * @since 3.15.0
     */
    version?: integer;
    /**
     * An array of diagnostic information items.
     */
    diagnostics: Diagnostic[];
}
/**
 * Completion client capabilities
 */
interface CompletionClientCapabilities {
    /**
     * Whether completion supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports the following `CompletionItem` specific
     * capabilities.
     */
    completionItem?: {
        /**
         * Client supports snippets as insert text.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         */
        snippetSupport?: boolean;
        /**
         * Client supports commit characters on a completion item.
         */
        commitCharactersSupport?: boolean;
        /**
         * Client supports the following content formats for the documentation
         * property. The order describes the preferred format of the client.
         */
        documentationFormat?: MarkupKind[];
        /**
         * Client supports the deprecated property on a completion item.
         */
        deprecatedSupport?: boolean;
        /**
         * Client supports the preselect property on a completion item.
         */
        preselectSupport?: boolean;
        /**
         * Client supports the tag property on a completion item. Clients supporting
         * tags have to handle unknown tags gracefully. Clients especially need to
         * preserve unknown tags when sending a completion item back to the server in
         * a resolve call.
         *
         * @since 3.15.0
         */
        tagSupport?: {
            /**
             * The tags supported by the client.
             */
            valueSet: CompletionItemTag[];
        };
        /**
         * Client support insert replace edit to control different behavior if a
         * completion item is inserted in the text or should replace text.
         *
         * @since 3.16.0
         */
        insertReplaceSupport?: boolean;
        /**
         * Indicates which properties a client can resolve lazily on a completion
         * item. Before version 3.16.0 only the predefined properties `documentation`
         * and `details` could be resolved lazily.
         *
         * @since 3.16.0
         */
        resolveSupport?: {
            /**
             * The properties that a client can resolve lazily.
             */
            properties: string[];
        };
        /**
         * The client supports the `insertTextMode` property on
         * a completion item to override the whitespace handling mode
         * as defined by the client (see `insertTextMode`).
         *
         * @since 3.16.0
         */
        insertTextModeSupport?: {
            valueSet: InsertTextMode[];
        };
        /**
         * The client has support for completion item label
         * details (see also `CompletionItemLabelDetails`).
         *
         * @since 3.17.0
         */
        labelDetailsSupport?: boolean;
    };
    completionItemKind?: {
        /**
         * The completion item kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the completion items kinds from `Text` to `Reference` as defined in
         * the initial version of the protocol.
         */
        valueSet?: CompletionItemKind[];
    };
    /**
     * Defines how the client handles whitespace and indentation
     * when accepting a completion item that uses multi line
     * text in either `insertText` or `textEdit`.
     *
     * @since 3.17.0
     */
    insertTextMode?: InsertTextMode;
    /**
     * The client supports to send additional context information for a
     * `textDocument/completion` request.
     */
    contextSupport?: boolean;
    /**
     * The client supports the following `CompletionList` specific
     * capabilities.
     *
     * @since 3.17.0
     */
    completionList?: {
        /**
         * The client supports the following itemDefaults on
         * a completion list.
         *
         * The value lists the supported property names of the
         * `CompletionList.itemDefaults` object. If omitted
         * no properties are supported.
         *
         * @since 3.17.0
         */
        itemDefaults?: string[];
    };
}
/**
 * How a completion was triggered
 */
declare namespace CompletionTriggerKind {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    const Invoked: 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    const TriggerCharacter: 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    const TriggerForIncompleteCompletions: 3;
}
type CompletionTriggerKind = 1 | 2 | 3;
/**
 * Contains additional information about the context in which a completion request is triggered.
 */
interface CompletionContext$1 {
    /**
     * How the completion was triggered.
     */
    triggerKind: CompletionTriggerKind;
    /**
     * The trigger character (a single character) that has trigger code complete.
     * Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
     */
    triggerCharacter?: string;
}
/**
 * Completion parameters
 */
interface CompletionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
    /**
     * The completion context. This is only available it the client specifies
     * to send this using the client capability `textDocument.completion.contextSupport === true`
     */
    context?: CompletionContext$1;
}
/**
 * Completion options.
 */
interface CompletionOptions extends WorkDoneProgressOptions {
    /**
     * Most tools trigger completion request automatically without explicitly requesting
     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
     * starts to type an identifier. For example if the user types `c` in a JavaScript file
     * code complete will automatically pop up present `console` besides others as a
     * completion item. Characters that make up identifiers don't need to be listed here.
     *
     * If code complete should automatically be trigger on characters not being valid inside
     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
     */
    triggerCharacters?: string[];
    /**
     * The list of all possible characters that commit a completion. This field can be used
     * if clients don't support individual commit characters per completion item. See
     * `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
     *
     * If a server provides both `allCommitCharacters` and commit characters on an individual
     * completion item the ones on the completion item win.
     *
     * @since 3.2.0
     */
    allCommitCharacters?: string[];
    /**
     * The server provides support to resolve additional
     * information for a completion item.
     */
    resolveProvider?: boolean;
    /**
     * The server supports the following `CompletionItem` specific
     * capabilities.
     *
     * @since 3.17.0
     */
    completionItem?: {
        /**
         * The server has support for completion item label
         * details (see also `CompletionItemLabelDetails`) when
         * receiving a completion item in a resolve call.
         *
         * @since 3.17.0
         */
        labelDetailsSupport?: boolean;
    };
}
interface HoverClientCapabilities {
    /**
     * Whether hover supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Client supports the following content formats for the content
     * property. The order describes the preferred format of the client.
     */
    contentFormat?: MarkupKind[];
}
/**
 * Hover options.
 */
interface HoverOptions extends WorkDoneProgressOptions {
}
/**
 * Parameters for a {@link HoverRequest}.
 */
interface HoverParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * Client Capabilities for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpClientCapabilities {
    /**
     * Whether signature help supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports the following `SignatureInformation`
     * specific properties.
     */
    signatureInformation?: {
        /**
         * Client supports the following content formats for the documentation
         * property. The order describes the preferred format of the client.
         */
        documentationFormat?: MarkupKind[];
        /**
         * Client capabilities specific to parameter information.
         */
        parameterInformation?: {
            /**
             * The client supports processing label offsets instead of a
             * simple label string.
             *
             * @since 3.14.0
             */
            labelOffsetSupport?: boolean;
        };
        /**
         * The client supports the `activeParameter` property on `SignatureInformation`
         * literal.
         *
         * @since 3.16.0
         */
        activeParameterSupport?: boolean;
    };
    /**
     * The client supports to send additional context information for a
     * `textDocument/signatureHelp` request. A client that opts into
     * contextSupport will also support the `retriggerCharacters` on
     * `SignatureHelpOptions`.
     *
     * @since 3.15.0
     */
    contextSupport?: boolean;
}
/**
 * Server Capabilities for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpOptions extends WorkDoneProgressOptions {
    /**
     * List of characters that trigger signature help automatically.
     */
    triggerCharacters?: string[];
    /**
     * List of characters that re-trigger signature help.
     *
     * These trigger characters are only active when signature help is already showing. All trigger characters
     * are also counted as re-trigger characters.
     *
     * @since 3.15.0
     */
    retriggerCharacters?: string[];
}
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
declare namespace SignatureHelpTriggerKind {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    const Invoked: 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    const TriggerCharacter: 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    const ContentChange: 3;
}
type SignatureHelpTriggerKind = 1 | 2 | 3;
/**
 * Additional information about the context in which a signature help request was triggered.
 *
 * @since 3.15.0
 */
interface SignatureHelpContext {
    /**
     * Action that caused signature help to be triggered.
     */
    triggerKind: SignatureHelpTriggerKind;
    /**
     * Character that caused signature help to be triggered.
     *
     * This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
     */
    triggerCharacter?: string;
    /**
     * `true` if signature help was already showing when it was triggered.
     *
     * Retriggers occurs when the signature help is already active and can be caused by actions such as
     * typing a trigger character, a cursor move, or document content changes.
     */
    isRetrigger: boolean;
    /**
     * The currently active `SignatureHelp`.
     *
     * The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
     * the user navigating through available signatures.
     */
    activeSignatureHelp?: SignatureHelp;
}
/**
 * Parameters for a {@link SignatureHelpRequest}.
 */
interface SignatureHelpParams extends TextDocumentPositionParams, WorkDoneProgressParams {
    /**
     * The signature help context. This is only available if the client specifies
     * to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
     *
     * @since 3.15.0
     */
    context?: SignatureHelpContext;
}
/**
 * Client Capabilities for a {@link DefinitionRequest}.
 */
interface DefinitionClientCapabilities {
    /**
     * Whether definition supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client supports additional metadata in the form of definition links.
     *
     * @since 3.14.0
     */
    linkSupport?: boolean;
}
/**
 * Server Capabilities for a {@link DefinitionRequest}.
 */
interface DefinitionOptions extends WorkDoneProgressOptions {
}
/**
 * Parameters for a {@link DefinitionRequest}.
 */
interface DefinitionParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}
/**
 * Client Capabilities for a {@link ReferencesRequest}.
 */
interface ReferenceClientCapabilities {
    /**
     * Whether references supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * Parameters for a {@link ReferencesRequest}.
 */
interface ReferenceParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
    context: ReferenceContext;
}
/**
 * Reference options.
 */
interface ReferenceOptions extends WorkDoneProgressOptions {
}
/**
 * Client Capabilities for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightClientCapabilities {
    /**
     * Whether document highlight supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * Parameters for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightParams extends TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams {
}
/**
 * Provider options for a {@link DocumentHighlightRequest}.
 */
interface DocumentHighlightOptions extends WorkDoneProgressOptions {
}
/**
 * Client Capabilities for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolClientCapabilities {
    /**
     * Whether document symbol supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Specific capabilities for the `SymbolKind` in the
     * `textDocument/documentSymbol` request.
     */
    symbolKind?: {
        /**
         * The symbol kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the symbol kinds from `File` to `Array` as defined in
         * the initial version of the protocol.
         */
        valueSet?: SymbolKind[];
    };
    /**
     * The client supports hierarchical document symbols.
     */
    hierarchicalDocumentSymbolSupport?: boolean;
    /**
     * The client supports tags on `SymbolInformation`. Tags are supported on
     * `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.16.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: SymbolTag[];
    };
    /**
     * The client supports an additional label presented in the UI when
     * registering a document symbol provider.
     *
     * @since 3.16.0
     */
    labelSupport?: boolean;
}
/**
 * Parameters for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Provider options for a {@link DocumentSymbolRequest}.
 */
interface DocumentSymbolOptions extends WorkDoneProgressOptions {
    /**
     * A human-readable string that is shown when multiple outlines trees
     * are shown for the same document.
     *
     * @since 3.16.0
     */
    label?: string;
}
/**
 * The Client Capabilities of a {@link CodeActionRequest}.
 */
interface CodeActionClientCapabilities {
    /**
     * Whether code action supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * The client support code action literals of type `CodeAction` as a valid
     * response of the `textDocument/codeAction` request. If the property is not
     * set the request can only return `Command` literals.
     *
     * @since 3.8.0
     */
    codeActionLiteralSupport?: {
        /**
         * The code action kind is support with the following value
         * set.
         */
        codeActionKind: {
            /**
             * The code action kind values the client supports. When this
             * property exists the client also guarantees that it will
             * handle values outside its set gracefully and falls back
             * to a default value when unknown.
             */
            valueSet: CodeActionKind[];
        };
    };
    /**
     * Whether code action supports the `isPreferred` property.
     *
     * @since 3.15.0
     */
    isPreferredSupport?: boolean;
    /**
     * Whether code action supports the `disabled` property.
     *
     * @since 3.16.0
     */
    disabledSupport?: boolean;
    /**
     * Whether code action supports the `data` property which is
     * preserved between a `textDocument/codeAction` and a
     * `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    dataSupport?: boolean;
    /**
     * Whether the client supports resolving additional code action
     * properties via a separate `codeAction/resolve` request.
     *
     * @since 3.16.0
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily.
         */
        properties: string[];
    };
    /**
     * Whether the client honors the change annotations in
     * text edits and resource operations returned via the
     * `CodeAction#edit` property by for example presenting
     * the workspace edit in the user interface and asking
     * for confirmation.
     *
     * @since 3.16.0
     */
    honorsChangeAnnotations?: boolean;
}
/**
 * The parameters of a {@link CodeActionRequest}.
 */
interface CodeActionParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document in which the command was invoked.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range for which the command was invoked.
     */
    range: Range$1;
    /**
     * Context carrying additional information.
     */
    context: CodeActionContext;
}
/**
 * Provider options for a {@link CodeActionRequest}.
 */
interface CodeActionOptions extends WorkDoneProgressOptions {
    /**
     * CodeActionKinds that this server may return.
     *
     * The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
     * may list out every specific kind they provide.
     */
    codeActionKinds?: CodeActionKind[];
    /**
     * The server provides support to resolve additional
     * information for a code action.
     *
     * @since 3.16.0
     */
    resolveProvider?: boolean;
}
/**
 * Client capabilities for a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolClientCapabilities {
    /**
     * Symbol request supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
     */
    symbolKind?: {
        /**
         * The symbol kind values the client supports. When this
         * property exists the client also guarantees that it will
         * handle values outside its set gracefully and falls back
         * to a default value when unknown.
         *
         * If this property is not present the client only supports
         * the symbol kinds from `File` to `Array` as defined in
         * the initial version of the protocol.
         */
        valueSet?: SymbolKind[];
    };
    /**
     * The client supports tags on `SymbolInformation`.
     * Clients supporting tags have to handle unknown tags gracefully.
     *
     * @since 3.16.0
     */
    tagSupport?: {
        /**
         * The tags supported by the client.
         */
        valueSet: SymbolTag[];
    };
    /**
     * The client support partial workspace symbols. The client will send the
     * request `workspaceSymbol/resolve` to the server to resolve additional
     * properties.
     *
     * @since 3.17.0
     */
    resolveSupport?: {
        /**
         * The properties that a client can resolve lazily. Usually
         * `location.range`
         */
        properties: string[];
    };
}
/**
 * The parameters of a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * A query string to filter symbols by. Clients may send an empty
     * string here to request all symbols.
     */
    query: string;
}
/**
 * Server capabilities for a {@link WorkspaceSymbolRequest}.
 */
interface WorkspaceSymbolOptions extends WorkDoneProgressOptions {
    /**
     * The server provides support to resolve additional
     * information for a workspace symbol.
     *
     * @since 3.17.0
     */
    resolveProvider?: boolean;
}
/**
 * The client capabilities  of a {@link CodeLensRequest}.
 */
interface CodeLensClientCapabilities {
    /**
     * Whether code lens supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * @since 3.16.0
 */
interface CodeLensWorkspaceClientCapabilities {
    /**
     * Whether the client implementation supports a refresh request sent from the
     * server to the client.
     *
     * Note that this event is global and will force the client to refresh all
     * code lenses currently shown. It should be used with absolute care and is
     * useful for situation where a server for example detect a project wide
     * change that requires such a calculation.
     */
    refreshSupport?: boolean;
}
/**
 * The parameters of a {@link CodeLensRequest}.
 */
interface CodeLensParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document to request code lens for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Code Lens provider options of a {@link CodeLensRequest}.
 */
interface CodeLensOptions extends WorkDoneProgressOptions {
    /**
     * Code lens has a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * The client capabilities of a {@link DocumentLinkRequest}.
 */
interface DocumentLinkClientCapabilities {
    /**
     * Whether document link supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client supports the `tooltip` property on `DocumentLink`.
     *
     * @since 3.15.0
     */
    tooltipSupport?: boolean;
}
/**
 * The parameters of a {@link DocumentLinkRequest}.
 */
interface DocumentLinkParams extends WorkDoneProgressParams, PartialResultParams {
    /**
     * The document to provide document links for.
     */
    textDocument: TextDocumentIdentifier;
}
/**
 * Provider options for a {@link DocumentLinkRequest}.
 */
interface DocumentLinkOptions extends WorkDoneProgressOptions {
    /**
     * Document links have a resolve provider as well.
     */
    resolveProvider?: boolean;
}
/**
 * Client capabilities of a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingClientCapabilities {
    /**
     * Whether formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingParams extends WorkDoneProgressParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The format options.
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentFormattingRequest}.
 */
interface DocumentFormattingOptions extends WorkDoneProgressOptions {
}
/**
 * Client capabilities of a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingClientCapabilities {
    /**
     * Whether range formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Whether the client supports formatting multiple ranges at once.
     *
     * @since 3.18.0
     * @proposed
     */
    rangesSupport?: boolean;
}
/**
 * The parameters of a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingParams extends WorkDoneProgressParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The range to format
     */
    range: Range$1;
    /**
     * The format options
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentRangeFormattingRequest}.
 */
interface DocumentRangeFormattingOptions extends WorkDoneProgressOptions {
    /**
     * Whether the server supports formatting multiple ranges at once.
     *
     * @since 3.18.0
     * @proposed
     */
    rangesSupport?: boolean;
}
/**
 * Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingClientCapabilities {
    /**
     * Whether on type formatting supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position around which the on type formatting should happen.
     * This is not necessarily the exact position where the character denoted
     * by the property `ch` got typed.
     */
    position: Position$1;
    /**
     * The character that has been typed that triggered the formatting
     * on type request. That is not necessarily the last character that
     * got inserted into the document since the client could auto insert
     * characters as well (e.g. like automatic brace completion).
     */
    ch: string;
    /**
     * The formatting options.
     */
    options: FormattingOptions;
}
/**
 * Provider options for a {@link DocumentOnTypeFormattingRequest}.
 */
interface DocumentOnTypeFormattingOptions {
    /**
     * A character on which formatting should be triggered, like `{`.
     */
    firstTriggerCharacter: string;
    /**
     * More trigger characters.
     */
    moreTriggerCharacter?: string[];
}
declare namespace PrepareSupportDefaultBehavior {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    const Identifier: 1;
}
type PrepareSupportDefaultBehavior = 1;
interface RenameClientCapabilities {
    /**
     * Whether rename supports dynamic registration.
     */
    dynamicRegistration?: boolean;
    /**
     * Client supports testing for validity of rename operations
     * before execution.
     *
     * @since 3.12.0
     */
    prepareSupport?: boolean;
    /**
     * Client supports the default behavior result.
     *
     * The value indicates the default behavior used by the
     * client.
     *
     * @since 3.16.0
     */
    prepareSupportDefaultBehavior?: PrepareSupportDefaultBehavior;
    /**
     * Whether the client honors the change annotations in
     * text edits and resource operations returned via the
     * rename request's workspace edit by for example presenting
     * the workspace edit in the user interface and asking
     * for confirmation.
     *
     * @since 3.16.0
     */
    honorsChangeAnnotations?: boolean;
}
/**
 * The parameters of a {@link RenameRequest}.
 */
interface RenameParams extends WorkDoneProgressParams {
    /**
     * The document to rename.
     */
    textDocument: TextDocumentIdentifier;
    /**
     * The position at which this request was sent.
     */
    position: Position$1;
    /**
     * The new name of the symbol. If the given name is not valid the
     * request must return a {@link ResponseError} with an
     * appropriate message set.
     */
    newName: string;
}
/**
 * Provider options for a {@link RenameRequest}.
 */
interface RenameOptions extends WorkDoneProgressOptions {
    /**
     * Renames should be checked and tested before being executed.
     *
     * @since version 3.12.0
     */
    prepareProvider?: boolean;
}
interface PrepareRenameParams extends TextDocumentPositionParams, WorkDoneProgressParams {
}
/**
 * The client capabilities of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandClientCapabilities {
    /**
     * Execute command supports dynamic registration.
     */
    dynamicRegistration?: boolean;
}
/**
 * The parameters of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandParams extends WorkDoneProgressParams {
    /**
     * The identifier of the actual command handler.
     */
    command: string;
    /**
     * Arguments that the command should be invoked with.
     */
    arguments?: LSPAny[];
}
/**
 * The server capabilities of a {@link ExecuteCommandRequest}.
 */
interface ExecuteCommandOptions extends WorkDoneProgressOptions {
    /**
     * The commands to be executed on the server
     */
    commands: string[];
}
interface WorkspaceEditClientCapabilities {
    /**
     * The client supports versioned document changes in `WorkspaceEdit`s
     */
    documentChanges?: boolean;
    /**
     * The resource operations the client supports. Clients should at least
     * support 'create', 'rename' and 'delete' files and folders.
     *
     * @since 3.13.0
     */
    resourceOperations?: ResourceOperationKind[];
    /**
     * The failure handling strategy of a client if applying the workspace edit
     * fails.
     *
     * @since 3.13.0
     */
    failureHandling?: FailureHandlingKind;
    /**
     * Whether the client normalizes line endings to the client specific
     * setting.
     * If set to `true` the client will normalize line ending characters
     * in a workspace edit to the client-specified new line
     * character.
     *
     * @since 3.16.0
     */
    normalizesLineEndings?: boolean;
    /**
     * Whether the client in general supports change annotations on text edits,
     * create file, rename file and delete file changes.
     *
     * @since 3.16.0
     */
    changeAnnotationSupport?: {
        /**
         * Whether the client groups edits with equal labels into tree nodes,
         * for instance all edits labelled with "Changes in Strings" would
         * be a tree node.
         */
        groupsOnLabel?: boolean;
    };
}
/**
 * The parameters passed via an apply workspace edit request.
 */
interface ApplyWorkspaceEditParams {
    /**
     * An optional label of the workspace edit. This label is
     * presented in the user interface for example on an undo
     * stack to undo the workspace edit.
     */
    label?: string;
    /**
     * The edits to apply.
     */
    edit: WorkspaceEdit;
}
/**
 * The result returned from the apply workspace edit request.
 *
 * @since 3.17 renamed from ApplyWorkspaceEditResponse
 */
interface ApplyWorkspaceEditResult {
    /**
     * Indicates whether the edit was applied or not.
     */
    applied: boolean;
    /**
     * An optional textual description for why the edit was not applied.
     * This may be used by the server for diagnostic logging or to provide
     * a suitable error for a request that triggered the edit.
     */
    failureReason?: string;
    /**
     * Depending on the client's failure handling strategy `failedChange` might
     * contain the index of the change that failed. This property is only available
     * if the client signals a `failureHandlingStrategy` in its client capabilities.
     */
    failedChange?: uinteger;
}
/**
 * @deprecated Use ApplyWorkspaceEditResult instead.
 */
type ApplyWorkspaceEditResponse = ApplyWorkspaceEditResult;

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ConfigurationProvider {
    /**
     * A promise that resolves when the configuration provider is ready to be used.
     */
    readonly ready: Promise<void>;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialize` request.
     */
    initialize(params: InitializeParams): void;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialized` notification.
     */
    initialized(params: ConfigurationInitializedParams): Promise<void>;
    /**
     * Returns a configuration value stored for the given language.
     *
     * @param language The language id
     * @param configuration Configuration name
     */
    getConfiguration(language: string, configuration: string): Promise<any>;
    /**
     *  Updates the cached configurations using the `change` notification parameters.
     *
     * @param change The parameters of a change configuration notification.
     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
     */
    updateConfiguration(change: DidChangeConfigurationParams): void;
    /**
     * Get notified after a configuration section has been updated.
     */
    onConfigurationSectionUpdate(callback: ConfigurationSectionUpdateListener): Disposable$2;
}
interface ConfigurationInitializedParams extends InitializedParams {
    register?: (params: DidChangeConfigurationRegistrationOptions) => void;
    fetchConfiguration?: (configuration: ConfigurationItem[]) => Promise<any>;
}
interface ConfigurationSectionUpdate {
    /**
     * The name of the configuration section that has been updated.
     */
    section: string;
    /**
     * The updated configuration section.
     */
    configuration: any;
}
type ConfigurationSectionUpdateListener = (update: ConfigurationSectionUpdate) => void;

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface BuildOptions {
    /**
     * Control the linking and references indexing phase with this option. The default if not specified is `true`.
     * If set to `false`, references can still be resolved - that's done lazily when you access the `ref` property of
     * a reference. But you won't get any diagnostics for linking errors and the references won't be considered
     * when updating other documents.
     */
    eagerLinking?: boolean;
    /**
     * Control the validation phase with this option:
     *  - `true` enables all validation checks and forces revalidating the documents
     *  - `false` or `undefined` disables all validation checks
     *  - An object runs only the necessary validation checks; the `categories` property restricts this to a specific subset
     */
    validation?: boolean | ValidationOptions;
}
/**
 * Shared-service for building and updating `LangiumDocument`s.
 */
interface DocumentBuilder {
    /** The options used for rebuilding documents after an update. */
    updateBuildOptions: BuildOptions;
    /**
     * Execute all necessary build steps for the given documents.
     *
     * @param documents Set of documents to be built.
     * @param options Options for the document builder.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCanceled` if a user action occurs during execution
     */
    build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options?: BuildOptions, cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * This method is called when a document change is detected. It updates the state of all
     * affected documents, including those with references to the changed ones, so they are rebuilt.
     *
     * @param changed URIs of changed or created documents
     * @param deleted URIs of deleted documents
     * @param cancelToken allows to cancel the current operation
     * @throws `OperationCancelled` if cancellation is detected during execution
     */
    update(changed: URI$1[], deleted: URI$1[], cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * Notify the given callback when a document update was triggered, but before any document
     * is rebuilt. Listeners to this event should not perform any long-running task.
     */
    onUpdate(callback: DocumentUpdateListener): Disposable$1;
    /**
     * Notify the given callback when a set of documents has been built reaching the specified target state.
     */
    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable$1;
    /**
     * Notify the specified callback when a document has been built reaching the specified target state.
     * Unlike {@link onBuildPhase} the listener is called for every single document.
     *
     * There are two main advantages compared to {@link onBuildPhase}:
     * 1. If the build is cancelled, {@link onDocumentPhase} will still fire for documents that have reached a specific state.
     *    Meanwhile, {@link onBuildPhase} won't fire for that state.
     * 2. The {@link DocumentBuilder} ensures that all {@link DocumentPhaseListener} instances are called for a built document.
     *    Even if the build is cancelled before those listeners were called.
     */
    onDocumentPhase(targetState: DocumentState, callback: DocumentPhaseListener): Disposable$1;
    /**
     * Wait until the workspace has reached the specified state for all documents.
     *
     * @param state The desired state. The promise won't resolve until all documents have reached this state
     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process
     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached
     */
    waitUntil(state: DocumentState, cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * Wait until the document specified by the {@link uri} has reached the specified state.
     *
     * @param state The desired state. The promise won't resolve until the document has reached this state.
     * @param uri The specified URI that points to the document. If the URI does not exist, the promise will resolve once the workspace has reached the specified state.
     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process.
     * @return The URI of the document that has reached the desired state, or `undefined` if the document does not exist.
     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached
     */
    waitUntil(state: DocumentState, uri?: URI$1, cancelToken?: CancellationToken$1): Promise<URI$1 | undefined>;
}
type DocumentUpdateListener = (changed: URI$1[], deleted: URI$1[]) => void | Promise<void>;
type DocumentBuildListener = (built: LangiumDocument[], cancelToken: CancellationToken$1) => void | Promise<void>;
type DocumentPhaseListener = (built: LangiumDocument, cancelToken: CancellationToken$1) => void | Promise<void>;

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Utility service to execute mutually exclusive actions.
 */
interface WorkspaceLock {
    /**
     * Performs a single async action, like initializing the workspace or processing document changes.
     * Only one action will be executed at a time.
     *
     * When another action is queued up, the token provided for the action will be cancelled.
     * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.
     */
    write(action: (token: CancellationToken$1) => MaybePromise<void>): Promise<void>;
    /**
     * Performs a single action, like computing completion results or providing workspace symbols.
     * Read actions will only be executed after all write actions have finished. They will be executed in parallel if possible.
     *
     * If a write action is currently running, the read action will be queued up and executed afterwards.
     * If a new write action is queued up while a read action is waiting, the write action will receive priority and will be handled before the read action.
     *
     * Note that read actions are not allowed to modify anything in the workspace. Please use {@link write} instead.
     */
    read<T>(action: () => MaybePromise<T>): Promise<T>;
    /**
     * Cancels the last queued write action. All previous write actions already have been cancelled.
     */
    cancelWrite(): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The workspace manager is responsible for finding source files in the workspace.
 * This service is shared between all languages of a language server.
 */
interface WorkspaceManager {
    /** The options used for the initial workspace build. */
    initialBuildOptions: BuildOptions | undefined;
    /**
     * A promise that resolves when the workspace manager is ready to be used.
     * Use this to ensure that the workspace manager has finished its initialization.
     */
    readonly ready: Promise<void>;
    /**
     * The workspace folders of the current workspace.
     * Available only after the `ready` promise resolves.
     */
    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialize` request.
     */
    initialize(params: InitializeParams): void;
    /**
     * When used in a language server context, this method is called when the server receives
     * the `initialized` notification.
     */
    initialized(params: InitializedParams): Promise<void>;
    /**
     * Does the initial indexing of workspace folders.
     * Collects information about exported and referenced AstNodes in
     * each language file and stores it locally.
     *
     * @param folders The set of workspace folders to be indexed.
     * @param cancelToken A cancellation token that can be used to cancel the operation.
     *
     * @throws OperationCancelled if a cancellation event has been detected
     */
    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken$1): Promise<void>;
}
/**
 * The FileSelector provides file names and extensions used by this extension.
 */
interface FileSelector {
    /** Allowed file extensions (e.g., ["ts", "js"]). */
    fileExtensions: string[];
    /** Allowed file names (e.g., ["config", "settings"]). */
    fileNames: string[];
}
declare class DefaultWorkspaceManager implements WorkspaceManager {
    initialBuildOptions: BuildOptions;
    protected readonly serviceRegistry: ServiceRegistry;
    protected readonly langiumDocuments: LangiumDocuments$1;
    protected readonly documentBuilder: DocumentBuilder;
    protected readonly fileSystemProvider: FileSystemProvider$1;
    protected readonly mutex: WorkspaceLock;
    protected readonly _ready: Deferred<void>;
    protected folders?: WorkspaceFolder[];
    constructor(services: LangiumSharedCoreServices);
    get ready(): Promise<void>;
    get workspaceFolders(): readonly WorkspaceFolder[] | undefined;
    initialize(params: InitializeParams): void;
    initialized(_params: InitializedParams): Promise<void>;
    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken$1): Promise<void>;
    /**
     * Performs the uninterruptable startup sequence of the workspace manager.
     * This methods loads all documents in the workspace and other documents and returns them.
     */
    protected performStartup(folders: WorkspaceFolder[]): Promise<LangiumDocument[]>;
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    protected loadAdditionalDocuments(_folders: WorkspaceFolder[], _collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine the root folder of the source documents in the given workspace folder.
     * The default implementation returns the URI of the workspace folder, but you can override
     * this to return a subfolder like `src` instead.
     */
    protected getRootFolder(workspaceFolder: WorkspaceFolder): URI$1;
    /**
     * Traverse the file system folder identified by the given URI and its subfolders. All
     * contained files that match the file extensions are added to the collector.
     */
    protected traverseFolder(workspaceFolder: WorkspaceFolder, folderPath: URI$1, selector: FileSelector, collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, selector: FileSelector): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The services generated by `langium-cli` for a specific language. These are derived from the
 * grammar definition and the language configuration.
 */
type LangiumGeneratedCoreServices = {
    readonly Grammar: Grammar;
    readonly LanguageMetaData: LanguageMetaData;
    readonly parser: {
        readonly ParserConfig?: IParserConfig;
    };
};
/**
 * Core services for a specific language of which Langium provides default implementations.
 */
type LangiumDefaultCoreServices = {
    readonly parser: {
        readonly AsyncParser: AsyncParser;
        readonly GrammarConfig: GrammarConfig;
        readonly ValueConverter: ValueConverter;
        readonly LangiumParser: LangiumParser;
        readonly ParserErrorMessageProvider: IParserErrorMessageProvider;
        readonly LexerErrorMessageProvider: ILexerErrorMessageProvider;
        readonly CompletionParser: LangiumCompletionParser;
        readonly TokenBuilder: TokenBuilder;
        readonly Lexer: Lexer;
    };
    readonly documentation: {
        readonly CommentProvider: CommentProvider;
        readonly DocumentationProvider: DocumentationProvider;
    };
    readonly references: {
        readonly Linker: Linker;
        readonly NameProvider: NameProvider;
        readonly References: References;
        readonly ScopeProvider: ScopeProvider;
        readonly ScopeComputation: ScopeComputation;
    };
    readonly serializer: {
        readonly Hydrator: Hydrator;
        readonly JsonSerializer: JsonSerializer;
    };
    readonly validation: {
        readonly DocumentValidator: DocumentValidator;
        readonly ValidationRegistry: ValidationRegistry;
    };
    readonly workspace: {
        readonly AstNodeLocator: AstNodeLocator;
        readonly AstNodeDescriptionProvider: AstNodeDescriptionProvider;
        readonly ReferenceDescriptionProvider: ReferenceDescriptionProvider;
    };
    readonly shared: LangiumSharedCoreServices;
};
/**
 * The core set of services available for a language. These are either generated by `langium-cli`
 * or provided as default implementations.
 */
type LangiumCoreServices = LangiumGeneratedCoreServices & LangiumDefaultCoreServices;
/**
 * The services generated by `langium-cli` that are shared between multiple languages. These are
 * derived from the grammar definition.
 */
type LangiumGeneratedSharedCoreServices = {
    readonly AstReflection: AstReflection;
};
/**
 * Core services shared between multiple languages where Langium provides default implementations.
 */
type LangiumDefaultSharedCoreServices = {
    readonly ServiceRegistry: ServiceRegistry;
    readonly workspace: {
        readonly ConfigurationProvider: ConfigurationProvider;
        readonly DocumentBuilder: DocumentBuilder;
        readonly FileSystemProvider: FileSystemProvider$1;
        readonly IndexManager: IndexManager$1;
        readonly LangiumDocuments: LangiumDocuments$1;
        readonly LangiumDocumentFactory: LangiumDocumentFactory;
        readonly TextDocuments?: TextDocumentProvider;
        readonly WorkspaceLock: WorkspaceLock;
        readonly WorkspaceManager: WorkspaceManager;
    };
};
/**
 * The shared core services are a set of services that are used by every language within a Langium project (excluding LSP services)
 * This is necessary to enable features like cross references across different languages.
 */
type LangiumSharedCoreServices = LangiumDefaultSharedCoreServices & LangiumGeneratedSharedCoreServices;

/**
 * @hidden
 */
type $keywords<T extends string> = {
  [key in T]: key;
};

/**
 * Partially implements CancellationToken interface from vscode-jsonrpc
 */
type CancellationToken = {
    /**
     * Is `true` when the token has been cancelled, `false` otherwise.
     */
    readonly isCancellationRequested: boolean;
};
declare module 'ts-graphviz' {
    namespace GraphAttributeKey {
        interface $values extends $keywords<'likec4_viewId'> {
        }
    }
    namespace ClusterSubgraphAttributeKey {
        interface $values extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_level' | 'likec4_depth'> {
        }
    }
    namespace NodeAttributeKey {
        interface $values extends $keywords<'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_project' | 'likec4_level'> {
        }
    }
    namespace EdgeAttributeKey {
        interface $values extends $keywords<'likec4_id' | 'likec4_project'> {
        }
    }
    namespace Attribute {
        interface $keys extends $keywords<'likec4_viewId' | 'likec4_type' | 'likec4_path' | 'likec4_id' | 'likec4_project' | 'likec4_level' | 'likec4_depth'> {
        }
        interface $types {
            likec4_viewId: string;
            likec4_type: 'folder' | 'file' | 'view';
            likec4_path: string;
            likec4_id: string;
            likec4_project: string;
            likec4_level: number;
            likec4_depth: number;
        }
    }
}
type DotSource = Tagged<string, 'DotSource'>;

type GvNodeName = Tagged<string, 'GvNodeName'>;
type GvId = Tagged<number, 'GvId'>;
type Point = [x: number, y: number];
interface GraphvizJson {
    name: GvNodeName;
    directed: boolean;
    strict: boolean;
    _draw_: GraphvizJson.Draw[];
    bb: string;
    compound: string;
    fontname: string;
    fontsize: string;
    label: string;
    nodesep: string;
    outputorder: string;
    rankdir: string;
    ranksep: string;
    splines: string;
    xdotversion: string;
    _subgraph_cnt: number;
    objects?: GraphvizJson.GvObject[];
    edges?: GraphvizJson.Edge[];
}
declare namespace GraphvizJson {
    interface Draw {
        op: string;
        grad: string;
        color: string;
        points: Point[];
    }
    interface Draw2 {
        op: string;
        grad: string;
        color: string;
        points: Point[];
    }
    namespace DrawOps {
        type Style = {
            op: 'S';
            style: string;
        };
        type BSpline = {
            op: 'b' | 'B';
            points: Point[];
        };
        type Color = {
            op: 'c';
            grad: string;
            color: string;
        };
        type Polygon = {
            op: 'p' | 'P';
            points: Point[];
        };
    }
    type DrawOp = DrawOps.Style | DrawOps.BSpline | DrawOps.Color | DrawOps.Polygon;
    type LabelDrawOps = {
        op: 'F';
        size: number;
        face: string;
    } | {
        op: 'c';
        color: string;
    } | {
        op: 't';
        fontchar: number;
    } | {
        op: 'T';
        pt: Point;
        align: 'l' | 'r' | 'c';
        width: number;
        text: string;
    };
    type GvObject = GvNodeObject | GvSubgraph;
    interface GvSubgraph {
        bb: string;
        label?: string;
        compound: 'true';
        _ldraw_?: LabelDrawOps[];
        likec4_type?: 'folder' | 'file';
        likec4_path?: string;
        likec4_id?: Fqn;
        likec4_level?: number;
        likec4_depth?: number;
        _gvid: GvId;
        subgraphs?: GvId[];
        nodes?: GvId[];
        edges?: GvId[];
    }
    interface GvNodeObject {
        _draw_: Draw[];
        _ldraw_?: LabelDrawOps[];
        likec4_type?: 'folder' | 'file' | 'view';
        likec4_path?: string;
        likec4_id?: Fqn;
        likec4_level?: number;
        _gvid: GvId;
        height: string;
        pos: string;
        shape: 'rect';
        width: string;
        label?: string;
    }
    interface Draw3 {
        op: string;
        grad: string;
        color: string;
        points: Point[];
    }
    interface Hdraw {
        op: string;
        style: string;
        grad: string;
        color: string;
        points: Point[];
    }
    interface Edge {
        _gvid: GvId;
        tail: GvId;
        head: GvId;
        dir?: 'forward' | 'back' | 'both' | 'none';
        _draw_: DrawOp[];
        _hdraw_?: DrawOp[];
        _tdraw_?: DrawOp[];
        _ldraw_?: LabelDrawOps[];
        _tldraw_?: LabelDrawOps[];
        _hldraw_?: LabelDrawOps[];
        fontname: string;
        fontsize: string;
        likec4_id?: EdgeId;
        label: string;
        lp: string;
        nojustify?: 'true' | 'false';
        pos?: string;
    }
}

interface GraphvizPort extends Disposable {
    get concurrency(): number;
    unflatten(dot: DotSource): Promise<DotSource>;
    acyclic(dot: DotSource): Promise<DotSource>;
    layoutJson(dot: DotSource): Promise<string>;
    svg(dot: DotSource): Promise<string>;
    dispose(): void;
}
type LayoutTaskParams<A extends aux.Any = aux.Any> = {
    view: ComputedView<A>;
    styles: LikeC4Styles;
};
type LayoutResult<A extends aux.Any = aux.Any> = {
    dot: DotSource;
    diagram: DiagramView<A>;
};
declare class GraphvizLayouter implements Disposable {
    private graphviz;
    constructor(graphviz?: GraphvizPort);
    dispose(): void;
    [Symbol.dispose](): void;
    get graphvizPort(): GraphvizPort;
    changePort(graphviz: GraphvizPort): void;
    dotToJson(dot: DotSource): Promise<GraphvizJson>;
    layout<A extends AnyAux>(params: LayoutTaskParams<A>): Promise<LayoutResult<A>>;
    svg<A extends AnyAux>(params: LayoutTaskParams<A>): Promise<{
        svg: string;
        dot: DotSource;
    }>;
    dot<A extends AnyAux>(params: LayoutTaskParams<A>): Promise<DotSource>;
    layoutProjectsView(view: ComputedProjectsView): Promise<LayoutedProjectsView>;
}

declare class QueueGraphvizLayoter extends GraphvizLayouter {
    private queue;
    private isProcessingBatch;
    constructor(options?: {
        graphviz?: GraphvizPort;
        /**
         * Concurrency limit.
         * Minimum: `1`.
         * @default 2
         */
        concurrency?: number;
        /**
         * Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
         * @default 20_000
         */
        timeout?: number;
        /**
         * Whether or not a timeout is considered an exception.
         * @default true
         */
        throwOnTimeout?: boolean;
    });
    private runInQueue;
    changePort(graphvizPort: GraphvizPort): void;
    layout<A extends AnyAux>(params: LayoutTaskParams<A>): Promise<LayoutResult<A>>;
    layoutProjectsView(view: ComputedProjectsView): Promise<LayoutedProjectsView>;
    batchLayout<A extends AnyAux>(params: {
        batch: LayoutTaskParams<A>[];
        cancelToken?: CancellationToken | undefined;
        onSuccess?: (task: LayoutTaskParams<A>, result: LayoutResult<A>) => void;
        onError?: (task: LayoutTaskParams<A>, error: unknown) => void;
    }): Promise<LayoutResult<A>[]>;
    dispose(): void;
}

interface WorkDoneProgressReporter {
    begin(title: string, percentage?: number, message?: string, cancellable?: boolean): void;
    report(percentage: number): void;
    report(message: string): void;
    report(percentage: number, message: string): void;
    done(): void;
}
interface WorkDoneProgressServerReporter extends WorkDoneProgressReporter {
    readonly token: CancellationToken$1;
}
interface WindowProgress {
    attachWorkDoneProgress(token: ProgressToken | undefined): WorkDoneProgressReporter;
    createWorkDoneProgress(): Promise<WorkDoneProgressServerReporter>;
}
interface ResultProgressReporter<R> {
    report(data: R): void;
}

interface Configuration {
    getConfiguration(): Promise<any>;
    getConfiguration(section: string): Promise<any>;
    getConfiguration(item: ConfigurationItem): Promise<any>;
    getConfiguration(items: ConfigurationItem[]): Promise<any[]>;
}

interface WorkspaceFolders {
    getWorkspaceFolders(): Promise<WorkspaceFolder[] | null>;
    onDidChangeWorkspaceFolders: Event<WorkspaceFoldersChangeEvent>;
}

/**
 * Shape of the call hierarchy feature
 *
 * @since 3.16.0
 */
interface CallHierarchy {
    callHierarchy: {
        onPrepare(handler: ServerRequestHandler<CallHierarchyPrepareParams, CallHierarchyItem[] | null, never, void>): Disposable$2;
        onIncomingCalls(handler: ServerRequestHandler<CallHierarchyIncomingCallsParams, CallHierarchyIncomingCall[] | null, CallHierarchyIncomingCall[], void>): Disposable$2;
        onOutgoingCalls(handler: ServerRequestHandler<CallHierarchyOutgoingCallsParams, CallHierarchyOutgoingCall[] | null, CallHierarchyOutgoingCall[], void>): Disposable$2;
    };
}

/**
 * Shape of the semantic token feature
 *
 * @since 3.16.0
 */
interface SemanticTokensFeatureShape {
    semanticTokens: {
        refresh(): void;
        on(handler: ServerRequestHandler<SemanticTokensParams, SemanticTokens, SemanticTokensPartialResult, void>): Disposable$2;
        onDelta(handler: ServerRequestHandler<SemanticTokensDeltaParams, SemanticTokensDelta | SemanticTokens, SemanticTokensDeltaPartialResult | SemanticTokensPartialResult, void>): Disposable$2;
        onRange(handler: ServerRequestHandler<SemanticTokensRangeParams, SemanticTokens, SemanticTokensPartialResult, void>): Disposable$2;
    };
}
declare class SemanticTokensBuilder$1 {
    private _id;
    private _prevLine;
    private _prevChar;
    private _data;
    private _dataLen;
    private _prevData;
    constructor();
    private initialize;
    push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void;
    get id(): string;
    previousResult(id: string): void;
    build(): SemanticTokens;
    canBuildEdits(): boolean;
    buildEdits(): SemanticTokens | SemanticTokensDelta;
}

interface ShowDocumentFeatureShape {
    showDocument(params: ShowDocumentParams): Promise<ShowDocumentResult>;
}

/**
 * Shape of the file operations feature
 *
 * @since 3.16.0
 */
interface FileOperationsFeatureShape {
    onDidCreateFiles(handler: NotificationHandler<CreateFilesParams>): Disposable$2;
    onDidRenameFiles(handler: NotificationHandler<RenameFilesParams>): Disposable$2;
    onDidDeleteFiles(handler: NotificationHandler<DeleteFilesParams>): Disposable$2;
    onWillCreateFiles(handler: RequestHandler<CreateFilesParams, WorkspaceEdit | null, never>): Disposable$2;
    onWillRenameFiles(handler: RequestHandler<RenameFilesParams, WorkspaceEdit | null, never>): Disposable$2;
    onWillDeleteFiles(handler: RequestHandler<DeleteFilesParams, WorkspaceEdit | null, never>): Disposable$2;
}

/**
 * Shape of the linked editing feature
 *
 * @since 3.16.0
 */
interface LinkedEditingRangeFeatureShape {
    /**
     * Installs a handler for the linked editing range request.
     *
     * @param handler The corresponding handler.
     */
    onLinkedEditingRange(handler: ServerRequestHandler<LinkedEditingRangeParams, LinkedEditingRanges | undefined | null, never, never>): Disposable$2;
}

/**
 * Shape of the type hierarchy feature
 *
 * @since 3.17.0
 */
interface TypeHierarchyFeatureShape {
    typeHierarchy: {
        onPrepare(handler: ServerRequestHandler<TypeHierarchyPrepareParams, TypeHierarchyItem[] | null, never, void>): Disposable$2;
        onSupertypes(handler: ServerRequestHandler<TypeHierarchySupertypesParams, TypeHierarchyItem[] | null, TypeHierarchyItem[], void>): Disposable$2;
        onSubtypes(handler: ServerRequestHandler<TypeHierarchySubtypesParams, TypeHierarchyItem[] | null, TypeHierarchyItem[], void>): Disposable$2;
    };
}

/**
 * Shape of the inline values feature
 *
 * @since 3.17.0
 */
interface InlineValueFeatureShape {
    inlineValue: {
        /**
         * Ask the client to refresh all inline values.
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the inline values request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<InlineValueParams, InlineValue[] | undefined | null, InlineValue[], void>): Disposable$2;
    };
}

/**
 * Shape of the folding range feature
 */
interface FoldingRangeFeatureShape {
    foldingRange: {
        /**
         * Ask the client to refresh all folding ranges
         *
         * @since 3.18.0.
         * @proposed
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the folding range request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<FoldingRangeParams, FoldingRange[] | undefined | null, FoldingRange[], void>): Disposable$2;
    };
}

/**
 * Shape of the inlay hints feature
 *
 * @since 3.17.0
 */
interface InlayHintFeatureShape {
    inlayHint: {
        /**
         * Ask the client to refresh all inlay hints.
         */
        refresh(): Promise<void>;
        /**
         * Installs a handler for the inlay hints request.
         *
         * @param handler The corresponding handler.
         */
        on(handler: ServerRequestHandler<InlayHintParams, InlayHint[] | undefined | null, InlayHint[], void>): Disposable$2;
        /**
         * Installs a handler for the inlay hint resolve request.
         *
         * @param handler The corresponding handler.
         */
        resolve(handler: RequestHandler<InlayHint, InlayHint, void>): Disposable$2;
    };
}

/**
 * Shape of the linked editing feature
 *
 * @since 3.16.0
 */
interface DiagnosticFeatureShape {
    diagnostics: {
        /**
        * Asks the client to refresh all diagnostics provided by this server by
        * pull for the corresponding documents again.
        */
        refresh(): void;
        /**
        * Installs a handler for the document diagnostic request.
        *
        * @param handler The corresponding handler.
        */
        on(handler: ServerRequestHandler<DocumentDiagnosticParams, DocumentDiagnosticReport, DocumentDiagnosticReportPartialResult, DiagnosticServerCancellationData>): Disposable$2;
        /**
         * Installs a handler for the workspace diagnostic request.
         *
         * @param handler The corresponding handler.
         */
        onWorkspace(handler: ServerRequestHandler<WorkspaceDiagnosticParams, WorkspaceDiagnosticReport, WorkspaceDiagnosticReportPartialResult, DiagnosticServerCancellationData>): Disposable$2;
    };
}

/**
 * Event to signal changes to a text document.
 */
interface TextDocumentChangeEvent<T> {
    /**
     * The document that has changed.
     */
    document: T;
}
/**
 * Event to signal that a document will be saved.
 */
interface TextDocumentWillSaveEvent<T> {
    /**
     * The document that will be saved
     */
    document: T;
    /**
     * The reason why save was triggered.
     */
    reason: TextDocumentSaveReason;
}

/**
 * Shape of the notebooks feature
 *
 * @since 3.17.0
 */
interface NotebookSyncFeatureShape {
    synchronization: {
        onDidOpenNotebookDocument(handler: NotificationHandler1<DidOpenNotebookDocumentParams>): Disposable$2;
        onDidChangeNotebookDocument(handler: NotificationHandler1<DidChangeNotebookDocumentParams>): Disposable$2;
        onDidSaveNotebookDocument(handler: NotificationHandler1<DidSaveNotebookDocumentParams>): Disposable$2;
        onDidCloseNotebookDocument(handler: NotificationHandler1<DidCloseNotebookDocumentParams>): Disposable$2;
    };
}
type NotebookDocumentChangeEvent = {
    /**
     * The notebook document that changed.
     */
    notebookDocument: NotebookDocument;
    /**
     * The meta data change if any.
     *
     * Note: old and new should always be an object literal (e.g. LSPObject)
     */
    metadata?: {
        old: LSPObject | undefined;
        new: LSPObject | undefined;
    };
    /**
     * The cell changes if any.
     */
    cells?: {
        /**
         * The cells that got added.
         */
        added: NotebookCell[];
        /**
         * The cells that got removed.
         */
        removed: NotebookCell[];
        /**
         * The cells that changed.
         */
        changed: {
            /**
             * The cell data has changed, excluding its
             * text content which is reported via
             * `textContentChanged`.
             */
            data: {
                old: NotebookCell;
                new: NotebookCell;
            }[];
            /**
             * The text content of a cell has changed.
             * The actual text is available via the `Notebooks`
             * text document manager.
             */
            textContent: NotebookCell[];
        };
    };
};

/**
 * Shape of the moniker feature
 *
 * @since 3.16.0
 */
interface MonikerFeatureShape {
    moniker: {
        on(handler: ServerRequestHandler<MonikerParams, Moniker[] | null, Moniker[], void>): Disposable$2;
    };
}

interface FeatureBase {
    /**
     * Called to initialize the remote with the given
     * client capabilities
     *
     * @param capabilities The client capabilities
     */
    initialize(capabilities: ClientCapabilities$1): void;
    /**
     * Called to fill in the server capabilities this feature implements.
     *
     * @param capabilities The server capabilities to fill.
     */
    fillServerCapabilities(capabilities: ServerCapabilities$1): void;
}
/**
 * The RemoteConsole interface contains all functions to interact with
 * the tools / clients console or log system. Internally it used `window/logMessage`
 * notifications.
 */
interface RemoteConsole extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Show an error message.
     *
     * @param message The message to show.
     */
    error(message: string): void;
    /**
     * Show a warning message.
     *
     * @param message The message to show.
     */
    warn(message: string): void;
    /**
     * Show an information message.
     *
     * @param message The message to show.
     */
    info(message: string): void;
    /**
     * Log a message.
     *
     * @param message The message to log.
     */
    log(message: string): void;
    /**
     * Log a debug message.
     *
     * @param message The message to log.
     *
     * @since 3.18.0
     */
    debug(message: string): void;
}
/**
 * The RemoteWindow interface contains all functions to interact with
 * the visual window of VS Code.
 */
interface _RemoteWindow extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Shows an error message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showErrorMessage(message: string): void;
    showErrorMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
    /**
     * Shows a warning message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showWarningMessage(message: string): void;
    showWarningMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
    /**
     * Shows an information message in the client's user interface. Depending on the client this might
     * be a modal dialog with a confirmation button or a notification in a notification center
     *
     * @param message The message to show.
     * @param actions Possible additional actions presented in the user interface. The selected action
     *  will be the value of the resolved promise
     */
    showInformationMessage(message: string): void;
    showInformationMessage<T extends MessageActionItem>(message: string, ...actions: T[]): Promise<T | undefined>;
}
type RemoteWindow = _RemoteWindow & WindowProgress & ShowDocumentFeatureShape;
/**
 * A bulk registration manages n single registration to be able to register
 * for n notifications or requests using one register request.
 */
interface BulkRegistration {
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: ProtocolNotificationType0<RO>, registerParams: RO): void;
    add<P, RO>(type: ProtocolNotificationType<P, RO>, registerParams: RO): void;
    /**
     * Adds a single registration.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     */
    add<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, registerParams: RO): void;
    add<P, PR, R, E, RO>(type: ProtocolRequestType<P, PR, R, E, RO>, registerParams: RO): void;
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: RegistrationType<RO>, registerParams: RO): void;
}
declare namespace BulkRegistration {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create(): BulkRegistration;
}
/**
 * A `BulkUnregistration` manages n unregistrations.
 */
interface BulkUnregistration extends Disposable$2 {
    /**
     * Disposes a single registration. It will be removed from the
     * `BulkUnregistration`.
     */
    disposeSingle(arg: string | MessageSignature): boolean;
}
declare namespace BulkUnregistration {
    function create(): BulkUnregistration;
}
/**
 * Interface to register and unregister `listeners` on the client / tools side.
 */
interface RemoteClient extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Registers a listener for the given request.
     *
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<P, RO>(type: ProtocolNotificationType<P, RO>, registerParams?: RO): Promise<Disposable$2>;
    register<RO>(type: ProtocolNotificationType0<RO>, registerParams?: RO): Promise<Disposable$2>;
    /**
     * Registers a listener for the given request.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<P, RO>(unregisteration: BulkUnregistration, type: ProtocolNotificationType<P, RO>, registerParams?: RO): Promise<Disposable$2>;
    register<RO>(unregisteration: BulkUnregistration, type: ProtocolNotificationType0<RO>, registerParams?: RO): Promise<Disposable$2>;
    /**
     * Registers a listener for the given request.
     *
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, registerParams?: RO): Promise<Disposable$2>;
    register<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, registerParams?: RO): Promise<Disposable$2>;
    /**
     * Registers a listener for the given request.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<P, R, PR, E, RO>(unregisteration: BulkUnregistration, type: ProtocolRequestType<P, R, PR, E, RO>, registerParams?: RO): Promise<Disposable$2>;
    register<R, PR, E, RO>(unregisteration: BulkUnregistration, type: ProtocolRequestType0<R, PR, E, RO>, registerParams?: RO): Promise<Disposable$2>;
    /**
     * Registers a listener for the given registration type.
     *
     * @param type the registration type.
     * @param registerParams special registration parameters.
     * @return a `Disposable` to unregister the listener again.
     */
    register<RO>(type: RegistrationType<RO>, registerParams?: RO): Promise<Disposable$2>;
    /**
     * Registers a listener for the given registration type.
     *
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the registration type.
     * @param registerParams special registration parameters.
     * @return the updated unregistration.
     */
    register<RO>(unregisteration: BulkUnregistration, type: RegistrationType<RO>, registerParams?: RO): Promise<Disposable$2>;
    /**
     * Registers a set of listeners.
     * @param registrations the bulk registration
     * @return a `Disposable` to unregister the listeners again.
     */
    register(registrations: BulkRegistration): Promise<BulkUnregistration>;
}
/**
 * Represents the workspace managed by the client.
 */
interface _RemoteWorkspace extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Applies a `WorkspaceEdit` to the workspace
     * @param param the workspace edit params.
     * @return a thenable that resolves to the `ApplyWorkspaceEditResponse`.
     */
    applyEdit(paramOrEdit: ApplyWorkspaceEditParams | WorkspaceEdit): Promise<ApplyWorkspaceEditResponse>;
}
type RemoteWorkspace = _RemoteWorkspace & Configuration & WorkspaceFolders & FileOperationsFeatureShape;
/**
 * Interface to log telemetry events. The events are actually send to the client
 * and the client needs to feed the event into a proper telemetry system.
 */
interface Telemetry extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Log the given data to telemetry.
     *
     * @param data The data to log. Must be a JSON serializable object.
     */
    logEvent(data: any): void;
}
/**
 * Interface to log traces to the client. The events are sent to the client and the
 * client needs to log the trace events.
 */
interface RemoteTracer extends FeatureBase {
    /**
     * The connection this remote is attached to.
     */
    connection: Connection;
    /**
     * Log the given data to the trace Log
     */
    log(message: string, verbose?: string): void;
}
interface _Languages extends FeatureBase {
    connection: Connection;
    attachWorkDoneProgress(params: WorkDoneProgressParams): WorkDoneProgressReporter;
    attachPartialResultProgress<PR>(type: ProgressType<PR>, params: PartialResultParams): ResultProgressReporter<PR> | undefined;
}
type Languages = _Languages & CallHierarchy & SemanticTokensFeatureShape & LinkedEditingRangeFeatureShape & TypeHierarchyFeatureShape & InlineValueFeatureShape & InlayHintFeatureShape & DiagnosticFeatureShape & MonikerFeatureShape & FoldingRangeFeatureShape;
interface _Notebooks extends FeatureBase {
    connection: Connection;
    attachWorkDoneProgress(params: WorkDoneProgressParams): WorkDoneProgressReporter;
    attachPartialResultProgress<PR>(type: ProgressType<PR>, params: PartialResultParams): ResultProgressReporter<PR> | undefined;
}
type Notebooks = _Notebooks & NotebookSyncFeatureShape;
/**
 * An empty interface for new proposed API.
 */
interface _ {
}
interface ServerRequestHandler<P, R, PR, E> {
    (params: P, token: CancellationToken$1, workDoneProgress: WorkDoneProgressReporter, resultProgress?: ResultProgressReporter<PR>): HandlerResult<R, E>;
}
/**
 * Interface to describe the shape of the server connection.
 */
interface _Connection<PConsole = _, PTracer = _, PTelemetry = _, PClient = _, PWindow = _, PWorkspace = _, PLanguages = _, PNotebooks = _> {
    /**
     * Start listening on the input stream for messages to process.
     */
    listen(): void;
    /**
     * Installs a request handler described by the given {@link RequestType}.
     *
     * @param type The {@link RequestType} describing the request.
     * @param handler The handler to install
     */
    onRequest<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, handler: RequestHandler0<R, E>): Disposable$2;
    onRequest<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, handler: RequestHandler<P, R, E>): Disposable$2;
    onRequest<R, PR, E, RO>(type: RequestType0<R, E>, handler: RequestHandler0<R, E>): Disposable$2;
    onRequest<P, R, E>(type: RequestType<P, R, E>, handler: RequestHandler<P, R, E>): Disposable$2;
    /**
     * Installs a request handler for the given method.
     *
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): Disposable$2;
    /**
     * Installs a request handler that is invoked if no specific request handler can be found.
     *
     * @param handler a handler that handles all requests.
     */
    onRequest(handler: StarRequestHandler): Disposable$2;
    /**
     * Send a request to the client.
     *
     * @param type The {@link RequestType} describing the request.
     * @param params The request's parameters.
     */
    sendRequest<R, PR, E, RO>(type: ProtocolRequestType0<R, PR, E, RO>, token?: CancellationToken$1): Promise<R>;
    sendRequest<P, R, PR, E, RO>(type: ProtocolRequestType<P, R, PR, E, RO>, params: P, token?: CancellationToken$1): Promise<R>;
    sendRequest<R, E>(type: RequestType0<R, E>, token?: CancellationToken$1): Promise<R>;
    sendRequest<P, R, E>(type: RequestType<P, R, E>, params: P, token?: CancellationToken$1): Promise<R>;
    /**
     * Send a request to the client.
     *
     * @param method The method to invoke on the client.
     * @param params The request's parameters.
     */
    sendRequest<R>(method: string, token?: CancellationToken$1): Promise<R>;
    sendRequest<R>(method: string, params: any, token?: CancellationToken$1): Promise<R>;
    /**
     * Installs a notification handler described by the given {@link NotificationType}.
     *
     * @param type The {@link NotificationType} describing the notification.
     * @param handler The handler to install.
     */
    onNotification<RO>(type: ProtocolNotificationType0<RO>, handler: NotificationHandler0): Disposable$2;
    onNotification<P, RO>(type: ProtocolNotificationType<P, RO>, handler: NotificationHandler<P>): Disposable$2;
    onNotification(type: NotificationType0, handler: NotificationHandler0): Disposable$2;
    onNotification<P>(type: NotificationType<P>, handler: NotificationHandler<P>): Disposable$2;
    /**
     * Installs a notification handler for the given method.
     *
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onNotification(method: string, handler: GenericNotificationHandler): Disposable$2;
    /**
     * Installs a notification handler that is invoked if no specific notification handler can be found.
     *
     * @param handler a handler that handles all notifications.
     */
    onNotification(handler: StarNotificationHandler): Disposable$2;
    /**
     * Send a notification to the client.
     *
     * @param type The {@link NotificationType} describing the notification.
     * @param params The notification's parameters.
     */
    sendNotification<RO>(type: ProtocolNotificationType0<RO>): Promise<void>;
    sendNotification<P, RO>(type: ProtocolNotificationType<P, RO>, params: P): Promise<void>;
    sendNotification(type: NotificationType0): Promise<void>;
    sendNotification<P>(type: NotificationType<P>, params: P): Promise<void>;
    /**
     * Send a notification to the client.
     *
     * @param method The method to invoke on the client.
     * @param params The notification's parameters.
     */
    sendNotification(method: string, params?: any): Promise<void>;
    /**
     * Installs a progress handler for a given token.
     * @param type the progress type
     * @param token the token
     * @param handler the handler
     */
    onProgress<P>(type: ProgressType<P>, token: string | number, handler: NotificationHandler<P>): Disposable$2;
    /**
     * Sends progress.
     * @param type the progress type
     * @param token the token to use
     * @param value the progress value
     */
    sendProgress<P>(type: ProgressType<P>, token: string | number, value: P): Promise<void>;
    /**
     * Installs a handler for the initialize request.
     *
     * @param handler The initialize handler.
     */
    onInitialize(handler: ServerRequestHandler<InitializeParams, InitializeResult, never, InitializeError>): Disposable$2;
    /**
     * Installs a handler for the initialized notification.
     *
     * @param handler The initialized handler.
     */
    onInitialized(handler: NotificationHandler<InitializedParams>): Disposable$2;
    /**
     * Installs a handler for the shutdown request.
     *
     * @param handler The initialize handler.
     */
    onShutdown(handler: RequestHandler0<void, void>): Disposable$2;
    /**
     * Installs a handler for the exit notification.
     *
     * @param handler The exit handler.
     */
    onExit(handler: NotificationHandler0): Disposable$2;
    /**
     * A property to provide access to console specific features.
     */
    console: RemoteConsole & PConsole;
    /**
     * A property to provide access to tracer specific features.
     */
    tracer: RemoteTracer & PTracer;
    /**
     * A property to provide access to telemetry specific features.
     */
    telemetry: Telemetry & PTelemetry;
    /**
     * A property to provide access to client specific features like registering
     * for requests or notifications.
     */
    client: RemoteClient & PClient;
    /**
     * A property to provide access to windows specific features.
     */
    window: RemoteWindow & PWindow;
    /**
     * A property to provide access to workspace specific features.
     */
    workspace: RemoteWorkspace & PWorkspace;
    /**
     * A property to provide access to language specific features.
     */
    languages: Languages & PLanguages;
    /**
     * A property to provide access to notebook specific features.
     */
    notebooks: Notebooks & PNotebooks;
    /**
     * Installs a handler for the `DidChangeConfiguration` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeConfiguration(handler: NotificationHandler<DidChangeConfigurationParams>): Disposable$2;
    /**
     * Installs a handler for the `DidChangeWatchedFiles` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeWatchedFiles(handler: NotificationHandler<DidChangeWatchedFilesParams>): Disposable$2;
    /**
     * Installs a handler for the `DidOpenTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidOpenTextDocument(handler: NotificationHandler<DidOpenTextDocumentParams>): Disposable$2;
    /**
     * Installs a handler for the `DidChangeTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidChangeTextDocument(handler: NotificationHandler<DidChangeTextDocumentParams>): Disposable$2;
    /**
     * Installs a handler for the `DidCloseTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidCloseTextDocument(handler: NotificationHandler<DidCloseTextDocumentParams>): Disposable$2;
    /**
     * Installs a handler for the `WillSaveTextDocument` notification.
     *
     * Note that this notification is opt-in. The client will not send it unless
     * your server has the `textDocumentSync.willSave` capability or you've
     * dynamically registered for the `textDocument/willSave` method.
     *
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocument(handler: NotificationHandler<WillSaveTextDocumentParams>): Disposable$2;
    /**
     * Installs a handler for the `WillSaveTextDocumentWaitUntil` request.
     *
     * Note that this request is opt-in. The client will not send it unless
     * your server has the `textDocumentSync.willSaveWaitUntil` capability,
     * or you've dynamically registered for the `textDocument/willSaveWaitUntil`
     * method.
     *
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocumentWaitUntil(handler: RequestHandler<WillSaveTextDocumentParams, TextEdit$1[] | undefined | null, void>): Disposable$2;
    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     *
     * @param handler The corresponding handler.
     */
    onDidSaveTextDocument(handler: NotificationHandler<DidSaveTextDocumentParams>): Disposable$2;
    /**
     * Sends diagnostics computed for a given document to VSCode to render them in the
     * user interface.
     *
     * @param params The diagnostic parameters.
     */
    sendDiagnostics(params: PublishDiagnosticsParams): Promise<void>;
    /**
     * Installs a handler for the `Hover` request.
     *
     * @param handler The corresponding handler.
     */
    onHover(handler: ServerRequestHandler<HoverParams, Hover | undefined | null, never, void>): Disposable$2;
    /**
     * Installs a handler for the `Completion` request.
     *
     * @param handler The corresponding handler.
     */
    onCompletion(handler: ServerRequestHandler<CompletionParams, CompletionItem[] | CompletionList | undefined | null, CompletionItem[], void>): Disposable$2;
    /**
     * Installs a handler for the `CompletionResolve` request.
     *
     * @param handler The corresponding handler.
     */
    onCompletionResolve(handler: RequestHandler<CompletionItem, CompletionItem, void>): Disposable$2;
    /**
     * Installs a handler for the `SignatureHelp` request.
     *
     * @param handler The corresponding handler.
     */
    onSignatureHelp(handler: ServerRequestHandler<SignatureHelpParams, SignatureHelp | undefined | null, never, void>): Disposable$2;
    /**
     * Installs a handler for the `Declaration` request.
     *
     * @param handler The corresponding handler.
     */
    onDeclaration(handler: ServerRequestHandler<DeclarationParams, Declaration | DeclarationLink[] | undefined | null, Location[] | DeclarationLink[], void>): Disposable$2;
    /**
     * Installs a handler for the `Definition` request.
     *
     * @param handler The corresponding handler.
     */
    onDefinition(handler: ServerRequestHandler<DefinitionParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$2;
    /**
     * Installs a handler for the `Type Definition` request.
     *
     * @param handler The corresponding handler.
     */
    onTypeDefinition(handler: ServerRequestHandler<TypeDefinitionParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$2;
    /**
     * Installs a handler for the `Implementation` request.
     *
     * @param handler The corresponding handler.
     */
    onImplementation(handler: ServerRequestHandler<ImplementationParams, Definition | DefinitionLink[] | undefined | null, Location[] | DefinitionLink[], void>): Disposable$2;
    /**
     * Installs a handler for the `References` request.
     *
     * @param handler The corresponding handler.
     */
    onReferences(handler: ServerRequestHandler<ReferenceParams, Location[] | undefined | null, Location[], void>): Disposable$2;
    /**
     * Installs a handler for the `DocumentHighlight` request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentHighlight(handler: ServerRequestHandler<DocumentHighlightParams, DocumentHighlight[] | undefined | null, DocumentHighlight[], void>): Disposable$2;
    /**
     * Installs a handler for the `DocumentSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentSymbol(handler: ServerRequestHandler<DocumentSymbolParams, SymbolInformation[] | DocumentSymbol[] | undefined | null, SymbolInformation[] | DocumentSymbol[], void>): Disposable$2;
    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbol(handler: ServerRequestHandler<WorkspaceSymbolParams, SymbolInformation[] | WorkspaceSymbol[] | undefined | null, SymbolInformation[], void>): Disposable$2;
    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     *
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbolResolve(handler: RequestHandler<WorkspaceSymbol, WorkspaceSymbol, void>): Disposable$2;
    /**
     * Installs a handler for the `CodeAction` request.
     *
     * @param handler The corresponding handler.
     */
    onCodeAction(handler: ServerRequestHandler<CodeActionParams, (Command | CodeAction)[] | undefined | null, (Command | CodeAction)[], void>): Disposable$2;
    /**
     * Installs a handler for the `CodeAction` resolve request.
     *
     * @param handler The corresponding handler.
     */
    onCodeActionResolve(handler: RequestHandler<CodeAction, CodeAction, void>): Disposable$2;
    /**
     * Compute a list of {@link CodeLens lenses}. This call should return as fast as possible and if
     * computing the commands is expensive implementers should only return code lens objects with the
     * range set and handle the resolve request.
     *
     * @param handler The corresponding handler.
     */
    onCodeLens(handler: ServerRequestHandler<CodeLensParams, CodeLens[] | undefined | null, CodeLens[], void>): Disposable$2;
    /**
     * This function will be called for each visible code lens, usually when scrolling and after
     * the onCodeLens has been called.
     *
     * @param handler The corresponding handler.
     */
    onCodeLensResolve(handler: RequestHandler<CodeLens, CodeLens, void>): Disposable$2;
    /**
     * Installs a handler for the document formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentFormatting(handler: ServerRequestHandler<DocumentFormattingParams, TextEdit$1[] | undefined | null, never, void>): Disposable$2;
    /**
     * Installs a handler for the document range formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentRangeFormatting(handler: ServerRequestHandler<DocumentRangeFormattingParams, TextEdit$1[] | undefined | null, never, void>): Disposable$2;
    /**
     * Installs a handler for the document on type formatting request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentOnTypeFormatting(handler: RequestHandler<DocumentOnTypeFormattingParams, TextEdit$1[] | undefined | null, void>): Disposable$2;
    /**
     * Installs a handler for the rename request.
     *
     * @param handler The corresponding handler.
     */
    onRenameRequest(handler: ServerRequestHandler<RenameParams, WorkspaceEdit | undefined | null, never, void>): Disposable$2;
    /**
     * Installs a handler for the prepare rename request.
     *
     * @param handler The corresponding handler.
     */
    onPrepareRename(handler: RequestHandler<PrepareRenameParams, Range$1 | {
        range: Range$1;
        placeholder: string;
    } | {
        defaultBehavior: boolean;
    } | undefined | null, void>): Disposable$2;
    /**
     * Installs a handler for the document links request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentLinks(handler: ServerRequestHandler<DocumentLinkParams, DocumentLink[] | undefined | null, DocumentLink[], void>): Disposable$2;
    /**
     * Installs a handler for the document links resolve request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentLinkResolve(handler: RequestHandler<DocumentLink, DocumentLink | undefined | null, void>): Disposable$2;
    /**
     * Installs a handler for the document color request.
     *
     * @param handler The corresponding handler.
     */
    onDocumentColor(handler: ServerRequestHandler<DocumentColorParams, ColorInformation[] | undefined | null, ColorInformation[], void>): Disposable$2;
    /**
     * Installs a handler for the document color request.
     *
     * @param handler The corresponding handler.
     */
    onColorPresentation(handler: ServerRequestHandler<ColorPresentationParams, ColorPresentation[] | undefined | null, ColorPresentation[], void>): Disposable$2;
    /**
     * Installs a handler for the folding ranges request.
     *
     * @param handler The corresponding handler.
     */
    onFoldingRanges(handler: ServerRequestHandler<FoldingRangeParams, FoldingRange[] | undefined | null, FoldingRange[], void>): Disposable$2;
    /**
     * Installs a handler for the selection ranges request.
     *
     * @param handler The corresponding handler.
     */
    onSelectionRanges(handler: ServerRequestHandler<SelectionRangeParams, SelectionRange[] | undefined | null, SelectionRange[], void>): Disposable$2;
    /**
     * Installs a handler for the execute command request.
     *
     * @param handler The corresponding handler.
     */
    onExecuteCommand(handler: ServerRequestHandler<ExecuteCommandParams, any | undefined | null, never, void>): Disposable$2;
    /**
     * Disposes the connection
     */
    dispose(): void;
}
interface Connection extends _Connection {
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling call hierarchy requests.
 */
interface CallHierarchyProvider {
    prepareCallHierarchy(document: LangiumDocument, params: CallHierarchyPrepareParams, cancelToken?: CancellationToken$1): MaybePromise<CallHierarchyItem[] | undefined>;
    incomingCalls(params: CallHierarchyIncomingCallsParams, cancelToken?: CancellationToken$1): MaybePromise<CallHierarchyIncomingCall[] | undefined>;
    outgoingCalls(params: CallHierarchyOutgoingCallsParams, cancelToken?: CancellationToken$1): MaybePromise<CallHierarchyOutgoingCall[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface CodeActionProvider {
    /**
     * Handle a code action request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCodeActions(document: LangiumDocument, params: CodeActionParams, cancelToken?: CancellationToken$1): MaybePromise<Array<Command | CodeAction> | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface CodeLensProvider {
    provideCodeLens(document: LangiumDocument, params: CodeLensParams, cancelToken?: CancellationToken$1): MaybePromise<CodeLens[] | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to declaration requests
 */
interface DeclarationProvider {
    /**
     * Handle a go to declaration request.
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDeclaration(document: LangiumDocument, params: DeclarationParams, cancelToken?: CancellationToken$1): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to definition requests.
 */
interface DefinitionProvider {
    /**
     * Handle a go to definition request.
     *
     * @param document The document in which the request was triggered.
     * @param params The parameters of the request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A list of location links to the definition(s) of the symbol at the given position.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDefinition(document: LangiumDocument, params: DefinitionParams, cancelToken?: CancellationToken$1): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document highlight requests.
 */
interface DocumentHighlightProvider {
    /**
     * Handle a document highlight request.
     *
     * @param document The document in which the request was received.
     * @param params The parameters of the document highlight request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns The document highlights or `undefined` if no highlights are available.
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, cancelToken?: CancellationToken$1): MaybePromise<DocumentHighlight[] | undefined>;
}
declare class DefaultDocumentHighlightProvider implements DocumentHighlightProvider {
    protected readonly references: References;
    protected readonly nameProvider: NameProvider;
    protected readonly grammarConfig: GrammarConfig;
    constructor(services: LangiumServices);
    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, _cancelToken?: CancellationToken$1): MaybePromise<DocumentHighlight[] | undefined>;
    /**
    * Override this method to determine the highlight kind of the given reference.
    */
    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document link requests.
 */
interface DocumentLinkProvider {
    /**
     * Handle a document links request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getDocumentLinks(document: LangiumDocument, params: DocumentLinkParams, cancelToken?: CancellationToken$1): MaybePromise<DocumentLink[]>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * This service consolidates the logic for gathering LSP kind information based on AST nodes or their descriptions.
 */
interface NodeKindProvider$1 {
    /**
     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.
     * @param node AST node or node description.
     * @returns The corresponding symbol kind.
     */
    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;
    /**
     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.
     * @param node AST node or node description.
     * @returns The corresponding completion item kind.
     */
    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling document symbols requests.
 */
interface DocumentSymbolProvider {
    /**
     * Handle a document symbols request.
     *
     * @param document The document in the workspace.
     * @param params The parameters of the request.
     * @param cancelToken A cancellation token that migh be used to cancel the request.
     * @returns The symbols for the given document.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getSymbols(document: LangiumDocument, params: DocumentSymbolParams, cancelToken?: CancellationToken$1): MaybePromise<DocumentSymbol[]>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling text document changes and watching relevant files.
 */
interface DocumentUpdateHandler {
    /**
     * A document open event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didOpenDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A content change event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didChangeContent?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A document save event (initiated) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    willSaveDocument?(event: TextDocumentWillSaveEvent<TextDocument>): void;
    /**
     * A document save event (initiated) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     * @returns An array of text edits which will be applied to the document before it is saved.
     */
    willSaveDocumentWaitUntil?(event: TextDocumentWillSaveEvent<TextDocument>): MaybePromise<TextEdit$1[]>;
    /**
     * A document save event (completed) was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didSaveDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * A document close event was triggered by the `TextDocuments` service.
     * @param event The document change event.
     */
    didCloseDocument?(event: TextDocumentChangeEvent<TextDocument>): void;
    /**
     * The client detected changes to files and folders watched by the language client.
     * @param params The files/folders change event.
     */
    didChangeWatchedFiles?(params: DidChangeWatchedFilesParams): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface ExecuteCommandHandler {
    get commands(): string[];
    executeCommand(name: string, args: any[], cancelToken?: CancellationToken$1): Promise<unknown>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling file changes such as file creation, deletion and renaming.
 * The interface methods are optional, so they are only registered if they are implemented.
 */
interface FileOperationHandler {
    /**
     * These options are reported to the client as part of the ServerCapabilities.
     */
    readonly fileOperationOptions: FileOperationOptions;
    /**
     * Files were created from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didCreateFiles?(params: CreateFilesParams): void;
    /**
     * Files were renamed from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didRenameFiles?(params: RenameFilesParams): void;
    /**
     * Files were deleted from within the client.
     * This notification must be registered with the {@link fileOperationOptions}.
     */
    didDeleteFiles?(params: DeleteFilesParams): void;
    /**
     * Called before files are actually created as long as the creation is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are created.
     */
    willCreateFiles?(params: CreateFilesParams): MaybePromise<WorkspaceEdit | null>;
    /**
     * Called before files are actually renamed as long as the rename is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are renamed.
     */
    willRenameFiles?(params: RenameFilesParams): MaybePromise<WorkspaceEdit | null>;
    /**
     * Called before files are actually deleted as long as the deletion is triggered from within
     * the client either by a user action or by applying a workspace edit.
     * This request must be registered with the {@link fileOperationOptions}.
     * @returns a WorkspaceEdit which will be applied to workspace before the files are deleted.
     */
    willDeleteFiles?(params: DeleteFilesParams): MaybePromise<WorkspaceEdit | null>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling folding range requests.
 */
interface FoldingRangeProvider {
    /**
     * Handle a folding range request.
     *
     * @param document The document to compute folding ranges for
     * @param params The folding range parameters
     * @param cancelToken A cancellation token that can be used to cancel the request
     * @returns The computed folding ranges
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getFoldingRanges(document: LangiumDocument, params: FoldingRangeParams, cancelToken?: CancellationToken$1): MaybePromise<FoldingRange[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language specific service for handling formatting related LSP requests.
 */
interface Formatter {
    /**
     * Handles full document formatting.
     */
    formatDocument(document: LangiumDocument, params: DocumentFormattingParams, cancelToken?: CancellationToken$1): MaybePromise<TextEdit$1[]>;
    /**
     * Handles partial document formatting. Only parts of the document within the `params.range` property are formatted.
     */
    formatDocumentRange(document: LangiumDocument, params: DocumentRangeFormattingParams, cancelToken?: CancellationToken$1): MaybePromise<TextEdit$1[]>;
    /**
     * Handles document formatting while typing. Only formats the current line.
     */
    formatDocumentOnType(document: LangiumDocument, params: DocumentOnTypeFormattingParams, cancelToken?: CancellationToken$1): MaybePromise<TextEdit$1[]>;
    /**
     * Options that determine when the `formatDocumentOnType` method should be invoked by the language client.
     * When `undefined` is returned, document format on type will be disabled.
     */
    get formatOnTypeOptions(): DocumentOnTypeFormattingOptions | undefined;
}
declare abstract class AbstractFormatter implements Formatter {
    protected collector: FormattingCollector;
    /**
     * Creates a formatter scoped to the supplied AST node.
     * Allows to define fine-grained formatting rules for elements.
     *
     * Example usage:
     *
     * ```ts
     * export class CustomFormatter extends AbstractFormatter {
     *   protected override format(node: AstNode): void {
     *     if (isPerson(node)) {
     *       const formatter = this.getNodeFormatter(node);
     *       formatter.property('name').prepend(Formatting.oneSpace());
     *     }
     *   }
     * }
     * ```
     * @param node The specific node the formatter should be scoped to. Every call to properties or keywords will only select those which belong to the supplied AST node.
     */
    protected getNodeFormatter<T extends AstNode>(node: T): NodeFormatter<T>;
    formatDocument(document: LangiumDocument, params: DocumentFormattingParams): MaybePromise<TextEdit$1[]>;
    /**
     * Returns whether a range for a given document is error free, i.e. safe to format
     *
     * @param document Document to inspect for lexer & parser errors that may produce an unsafe range
     * @param range Formatting range to check for safety
     * @returns Whether the given formatting range does not overlap with or follow any regions with an error
     */
    protected isFormatRangeErrorFree(document: LangiumDocument, range: Range$1): boolean;
    formatDocumentRange(document: LangiumDocument, params: DocumentRangeFormattingParams): MaybePromise<TextEdit$1[]>;
    formatDocumentOnType(document: LangiumDocument, params: DocumentOnTypeFormattingParams): MaybePromise<TextEdit$1[]>;
    get formatOnTypeOptions(): DocumentOnTypeFormattingOptions | undefined;
    protected doDocumentFormat(document: LangiumDocument, options: FormattingOptions, range?: Range$1): TextEdit$1[];
    protected avoidOverlappingEdits(textDocument: TextDocument, textEdits: TextEdit$1[]): TextEdit$1[];
    protected iterateAstFormatting(document: LangiumDocument, range?: Range$1): void;
    protected abstract format(node: AstNode): void;
    protected nodeModeToKey(node: CstNode, mode: 'prepend' | 'append'): string;
    protected insideRange(inside: Range$1, total?: Range$1): boolean;
    protected isNecessary(edit: TextEdit$1, document: TextDocument): boolean;
    protected iterateCstFormatting(document: LangiumDocument, formattings: Map<string, FormattingAction>, options: FormattingOptions, range?: Range$1): TextEdit$1[];
    protected createHiddenTextEdits(previous: CstNode | undefined, hidden: CstNode, formatting: FormattingAction | undefined, context: FormattingContext): TextEdit$1[];
    protected getExistingIndentationCharacterCount(text: string, context: FormattingContext): number;
    protected getIndentationCharacterCount(context: FormattingContext, formattingMove?: FormattingMove): number;
    protected createTextEdit(a: CstNode | undefined, b: CstNode, formatting: FormattingAction, context: FormattingContext): TextEdit$1[];
    protected createSpaceTextEdit(range: Range$1, spaces: number, options: FormattingActionOptions): TextEdit$1;
    protected createLineTextEdit(range: Range$1, lines: number, context: FormattingContext, options: FormattingActionOptions): TextEdit$1;
    protected createTabTextEdit(range: Range$1, hasPrevious: boolean, context: FormattingContext): TextEdit$1;
    protected fitIntoOptions(value: number, existing: number, options: FormattingActionOptions): number;
    protected findFittingMove(range: Range$1, moves: FormattingMove[], _context: FormattingContext): FormattingMove | undefined;
    protected iterateCstTree(document: LangiumDocument, context: FormattingContext): Stream<CstNode>;
    protected iterateCst(node: CstNode, context: FormattingContext): Stream<CstNode>;
}
/**
 * Represents an object that allows to format certain parts of a specific node, like its keywords or properties.
 */
interface NodeFormatter<T extends AstNode> {
    /**
     * Creates a new formatting region that contains the specified node.
     */
    node(node: AstNode): FormattingRegion;
    /**
     * Creates a new formatting region that contains all of the specified nodes.
     */
    nodes(...nodes: AstNode[]): FormattingRegion;
    /**
     * Creates a new formatting region that contains the specified property of the supplied node.
     *
     * @param property The name of the property to format. Scoped to the supplied node.
     * @param index The index of the property, if the property is an array. `0` by default. To retrieve all elements of this array, use the {@link properties} method instead.
     */
    property(property: Properties<T>, index?: number): FormattingRegion;
    /**
     * Creates a new formatting region that contains the all of the specified properties of the supplied node.
     *
     * @param properties The names of the properties to format. Scoped to the supplied node.
     */
    properties(...properties: Array<Properties<T>>): FormattingRegion;
    /**
     * Creates a new formatting region that contains the specified keyword of the supplied node.
     *
     * @param keyword The keyword to format. Scoped to the supplied node.
     * @param index The index of the keyword, necessary if the keyword appears multiple times. `0` by default. To retrieve all keywords, use the {@link keywords} method instead.
     */
    keyword(keyword: string, index?: number): FormattingRegion;
    /**
     * Creates a new formatting region that contains the all of the specified keywords of the supplied node.
     *
     * @param keywords The keywords to format. Scoped to the supplied node.
     */
    keywords(...keywords: string[]): FormattingRegion;
    /**
     * Creates a new formatting region that contains the all of the specified CST nodes.
     *
     * @param nodes A list of CST nodes to format
     */
    cst(nodes: CstNode[]): FormattingRegion;
    /**
     * Creates a new formatting region that contains all nodes between the given formatting regions.
     *
     * For example, can be used to retrieve a formatting region that contains all nodes between two curly braces:
     *
     * ```ts
     * const formatter = this.getNodeFormatter(node);
     * const bracesOpen = formatter.keyword('{');
     * const bracesClose = formatter.keyword('}');
     * formatter.interior(bracesOpen, bracesClose).prepend(Formatting.indent());
     * ```
     *
     * @param start Determines where the search for interior nodes should start
     * @param end Determines where the search for interior nodes should end
     */
    interior(start: FormattingRegion, end: FormattingRegion): FormattingRegion;
}
interface FormattingContext {
    document: TextDocument;
    options: FormattingOptions;
    indentation: number;
}
declare class FormattingRegion {
    readonly nodes: CstNode[];
    protected readonly collector: FormattingCollector;
    constructor(nodes: CstNode[], collector: FormattingCollector);
    /**
     * Prepends the specified formatting to all nodes of this region.
     */
    prepend(formatting: FormattingAction): FormattingRegion;
    /**
     * Appends the specified formatting to all nodes of this region.
     */
    append(formatting: FormattingAction): FormattingRegion;
    /**
     * Sorrounds all nodes of this region with the specified formatting.
     * Functionally the same as invoking `prepend` and `append` with the same formatting.
     */
    surround(formatting: FormattingAction): FormattingRegion;
    /**
     * Creates a copy of this region with a slice of the selected nodes.
     * For both start and end, a negative index can be used to indicate an offset from the end of the array.
     * For example, -2 refers to the second to last element of the array.
     * @param start The beginning index of the specified portion of the region. If start is undefined, then the slice begins at index 0.
     * @param end The end index of the specified portion of the region. This is exclusive of the element at the index 'end'. If end is undefined, then the slice extends to the end of the region.
     */
    slice(start?: number, end?: number): FormattingRegion;
}
interface FormattingAction {
    options: FormattingActionOptions;
    moves: FormattingMove[];
}
interface FormattingActionOptions {
    /**
     * The priority of this formatting. Formattings with a higher priority override those with lower priority.
     * `0` by default.
     */
    priority?: number;
    /**
     * Determines whether this formatting allows more spaces/lines than expected. For example, if {@link Formatting.newLine} is used, but 2 empty lines already exist between the elements, no formatting is applied.
     */
    allowMore?: boolean;
    /**
     * Determines whether this formatting allows less spaces/lines than expected. For example, if {@link Formatting.oneSpace} is used, but no spaces exist between the elements, no formatting is applied.
     */
    allowLess?: boolean;
}
interface FormattingMove {
    characters?: number;
    tabs?: number;
    lines?: number;
}
type FormattingCollector = (node: CstNode, mode: 'prepend' | 'append', formatting: FormattingAction) => void;

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * This service implements a [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching) method.
 */
interface FuzzyMatcher {
    /**
     * Performs [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching).
     *
     * Fuzzy matching improves search/completion user experience by allowing to omit characters.
     * For example, a query such as `FuMa` matches the text `FuzzyMatcher`.
     *
     * @param query The user input search query.
     * @param text The text that should be matched against the query.
     * @returns Whether the query matches the text.
     */
    match(query: string, text: string): boolean;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling hover requests.
 */
interface HoverProvider {
    /**
     * Handle a hover request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getHoverContent(document: LangiumDocument, params: HoverParams, cancelToken?: CancellationToken$1): MaybePromise<Hover | undefined>;
}
declare abstract class AstNodeHoverProvider implements HoverProvider {
    protected readonly references: References;
    protected readonly grammarConfig: GrammarConfig;
    constructor(services: LangiumServices);
    getHoverContent(document: LangiumDocument, params: HoverParams): MaybePromise<Hover | undefined>;
    protected abstract getAstNodeHoverContent(node: AstNode): MaybePromise<Hover | undefined>;
    protected getKeywordHoverContent(node: AstNode): MaybePromise<Hover | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to implementation requests.
 */
interface ImplementationProvider {
    /**
     * Handles a go to implementation request.
     */
    getImplementation(document: LangiumDocument, params: ImplementationParams, cancelToken?: CancellationToken$1): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Provider for the inlay hint LSP type.
 */
interface InlayHintProvider {
    /**
     * Handle the `textDocument.inlayHint` language server request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getInlayHints(document: LangiumDocument, params: InlayHintParams, cancelToken?: CancellationToken$1): MaybePromise<InlayHint[] | undefined>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface LanguageServer {
    initialize(params: InitializeParams): Promise<InitializeResult>;
    initialized(params: InitializedParams): void;
    onInitialize(callback: (params: InitializeParams) => void): Disposable$2;
    onInitialized(callback: (params: InitializedParams) => void): Disposable$2;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling find references requests.
 */
interface ReferencesProvider {
    /**
     * Handle a find references request.
     *
     * @param document The document in which to search for references.
     * @param params The parameters of the find references request.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns The locations of the references.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    findReferences(document: LangiumDocument, params: ReferenceParams, cancelToken?: CancellationToken$1): MaybePromise<Location[]>;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling rename requests and prepare rename requests.
 */
interface RenameProvider {
    /**
     * Handle a rename request.
     *
     * @param document The document in which the rename request was triggered.
     * @param params The rename parameters.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A workspace edit that describes the changes to be applied to the workspace.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    rename(document: LangiumDocument, params: RenameParams, cancelToken?: CancellationToken$1): MaybePromise<WorkspaceEdit | undefined>;
    /**
     * Handle a prepare rename request.
     *
     * @param document The document in which the prepare rename request was triggered.
     * @param params The prepare rename parameters.
     * @param cancelToken A cancellation token that can be used to cancel the request.
     * @returns A range that describes the range of the symbol to be renamed.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    prepareRename(document: LangiumDocument, params: TextDocumentPositionParams, cancelToken?: CancellationToken$1): MaybePromise<Range$1 | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface SemanticTokenProvider {
    semanticHighlight(document: LangiumDocument, params: SemanticTokensParams, cancelToken?: CancellationToken$1): MaybePromise<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken$1): MaybePromise<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken$1): MaybePromise<SemanticTokens | SemanticTokensDelta>;
    readonly tokenTypes: Record<string, number>;
    readonly tokenModifiers: Record<string, number>;
    readonly semanticTokensOptions: SemanticTokensOptions;
}
type SemanticTokenAcceptorOptions<N extends AstNode = AstNode> = ({
    line: number;
    char: number;
    length: number;
} | {
    node: N;
    property: Properties<N>;
    index?: number;
} | {
    node: N;
    keyword: string;
    index?: number;
} | {
    cst: CstNode;
} | {
    range: Range$1;
}) & {
    type: string;
    modifier?: string | string[];
};
interface SemanticTokenPropertyOptions<T extends AstNode> {
    node: T;
    property: Properties<T>;
    index?: number;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenKeywordOptions {
    node: AstNode;
    keyword: string;
    index?: number;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenNodeOptions {
    node: CstNode;
    type: string;
    modifier?: string | string[];
}
interface SemanticTokenRangeOptions {
    range: Range$1;
    type: string;
    modifier?: string | string[];
}
declare class SemanticTokensBuilder extends SemanticTokensBuilder$1 {
    private _tokens;
    push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void;
    build(): SemanticTokens;
    buildEdits(): SemanticTokens | SemanticTokensDelta;
    /**
     * Flushes the cached delta token values
     */
    flush(): void;
    private applyTokens;
    private compareTokens;
}
type SemanticTokenAcceptor = <N extends AstNode = AstNode>(options: SemanticTokenAcceptorOptions<N>) => void;
/**
 * A basic super class for providing semantic token data.
 * Users of Langium should extend this class to create their own `SemanticTokenProvider`.
 *
 * The entry method for generating semantic tokens based on an `AstNode` is the `highlightElement` method.
 */
declare abstract class AbstractSemanticTokenProvider implements SemanticTokenProvider {
    /**
     * Store a token builder for each open document.
     */
    protected tokensBuilders: Map<string, SemanticTokensBuilder>;
    protected currentDocument?: LangiumDocument;
    protected currentTokensBuilder?: SemanticTokensBuilder;
    protected currentRange?: Range$1;
    protected clientCapabilities?: SemanticTokensClientCapabilities;
    constructor(services: LangiumServices);
    initialize(clientCapabilities?: SemanticTokensClientCapabilities): void;
    get tokenTypes(): Record<string, number>;
    get tokenModifiers(): Record<string, number>;
    get semanticTokensOptions(): SemanticTokensOptions;
    semanticHighlight(document: LangiumDocument, _params: SemanticTokensParams, cancelToken?: CancellationToken$1): Promise<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken$1): Promise<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken$1): Promise<SemanticTokens | SemanticTokensDelta>;
    protected createAcceptor(): SemanticTokenAcceptor;
    protected getDocumentTokensBuilder(document: LangiumDocument): SemanticTokensBuilder;
    protected computeHighlighting(document: LangiumDocument, acceptor: SemanticTokenAcceptor, cancelToken: CancellationToken$1): Promise<void>;
    /**
     * @return `'prune'` to skip the children of this element, nothing otherwise.
     */
    protected abstract highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';
    protected highlightToken(options: SemanticTokenRangeOptions): void;
    protected highlightProperty<N extends AstNode>(options: SemanticTokenPropertyOptions<N>): void;
    protected highlightKeyword(options: SemanticTokenKeywordOptions): void;
    protected highlightNode(options: SemanticTokenNodeOptions): void;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling signature help requests.
 */
interface SignatureHelpProvider {
    /**
     * Handles a signature help request
     */
    provideSignatureHelp(document: LangiumDocument, params: SignatureHelpParams, cancelToken?: CancellationToken$1): MaybePromise<SignatureHelp | undefined>;
    /**
     * Options that determine the server capabilities for a signature help request. It contains the list of triggering characters.
     */
    get signatureHelpOptions(): SignatureHelpOptions;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling type hierarchy requests.
 */
interface TypeHierarchyProvider {
    prepareTypeHierarchy(document: LangiumDocument, params: TypeHierarchyPrepareParams, cancelToken?: CancellationToken$1): MaybePromise<TypeHierarchyItem[] | undefined>;
    supertypes(params: TypeHierarchySupertypesParams, cancelToken?: CancellationToken$1): MaybePromise<TypeHierarchyItem[] | undefined>;
    subtypes(params: TypeHierarchySubtypesParams, cancelToken?: CancellationToken$1): MaybePromise<TypeHierarchyItem[] | undefined>;
}

/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Language-specific service for handling go to type requests.
 */
interface TypeDefinitionProvider {
    /**
     * Handles a go to type definition request.
     */
    getTypeDefinition(document: LangiumDocument, params: TypeDefinitionParams, cancelToken?: CancellationToken$1): MaybePromise<LocationLink[] | undefined>;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Shared service for handling workspace symbols requests.
 */
interface WorkspaceSymbolProvider$1 {
    /**
     * Handle a workspace symbols request.
     *
     * @param params workspaces symbols request parameters
     * @param cancelToken a cancellation token tha can be used to cancel the request
     * @returns a list of workspace symbols
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken$1): MaybePromise<WorkspaceSymbol[]>;
    /**
     * Handle a resolve request for a workspace symbol.
     *
     * @param symbol the workspace symbol to resolve
     * @param cancelToken a cancellation token tha can be used to cancel the request
     * @returns the resolved workspace symbol
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    resolveSymbol?(symbol: WorkspaceSymbol, cancelToken?: CancellationToken$1): MaybePromise<WorkspaceSymbol>;
}
declare class DefaultWorkspaceSymbolProvider implements WorkspaceSymbolProvider$1 {
    protected readonly indexManager: IndexManager$1;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly fuzzyMatcher: FuzzyMatcher;
    constructor(services: LangiumSharedServices);
    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken$1): Promise<WorkspaceSymbol[]>;
    protected getWorkspaceSymbol(astDescription: AstNodeDescription): WorkspaceSymbol | undefined;
}

/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type TextDocumentConnection = Pick<Connection, 'onDidOpenTextDocument' | 'onDidChangeTextDocument' | 'onDidCloseTextDocument' | 'onWillSaveTextDocument' | 'onWillSaveTextDocumentWaitUntil' | 'onDidSaveTextDocument'>;
/**
 * A manager service that keeps track of all currently opened text documents.
 *
 * Designed to be compatible with the `TextDocuments` class in the `vscode-languageserver` package.
 */
interface TextDocuments<T extends {
    uri: string;
}> {
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    readonly onDidOpen: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    readonly onDidChangeContent: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    readonly onWillSave: Event<TextDocumentWillSaveEvent<T>>;
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler: RequestHandler<TextDocumentWillSaveEvent<T>, TextEdit$1[], void>): void;
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    readonly onDidSave: Event<TextDocumentChangeEvent<T>>;
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    readonly onDidClose: Event<TextDocumentChangeEvent<T>>;
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri: string | URI$1): T | undefined;
    /**
     * Sets the text document managed by this instance.
     * @param document The text document to add.
     * @returns `true` if the document didn't exist yet, `false` if it was already present.
     */
    set(document: T): boolean;
    /**
     * Deletes a text document managed by this instance.
     */
    delete(uri: string | URI$1 | T): void;
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all(): T[];
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys(): string[];
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection: TextDocumentConnection): Disposable$2;
}
interface NotebookDocuments<T extends {
    uri: string;
}> {
    get cellTextDocuments(): TextDocuments<T>;
    getCellTextDocument(cell: NotebookCell): T | undefined;
    getNotebookDocument(uri: string | URI$1): NotebookDocument | undefined;
    getNotebookCell(uri: string | URI$1): NotebookCell | undefined;
    findNotebookDocumentForCell(cell: string | URI$1 | NotebookCell): NotebookDocument | undefined;
    get onDidOpen(): Event<NotebookDocument>;
    get onDidSave(): Event<NotebookDocument>;
    get onDidChange(): Event<NotebookDocumentChangeEvent>;
    get onDidClose(): Event<NotebookDocument>;
    /**
     * Listens for `low level` notification on the given connection to
     * update the notebook documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
     *  and `onDidCloseNotebookDocument`.
     *
     * @param connection The connection to listen on.
     */
    listen(connection: Connection): Disposable$2;
}

/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Combined Core + LSP services of Langium (total services)
 */
type LangiumServices = LangiumCoreServices & LangiumLSPServices;
/**
 * Combined Core + LSP shared services of Langium (total services)
 */
type LangiumSharedServices = LangiumSharedCoreServices & LangiumSharedLSPServices;
/**
 * LSP services for a specific language of which Langium provides default implementations.
 */
type LangiumLSPServices = {
    readonly lsp: {
        readonly CompletionProvider?: CompletionProvider;
        readonly DocumentHighlightProvider?: DocumentHighlightProvider;
        readonly DocumentSymbolProvider?: DocumentSymbolProvider;
        readonly HoverProvider?: HoverProvider;
        readonly FoldingRangeProvider?: FoldingRangeProvider;
        readonly DefinitionProvider?: DefinitionProvider;
        readonly TypeProvider?: TypeDefinitionProvider;
        readonly ImplementationProvider?: ImplementationProvider;
        readonly ReferencesProvider?: ReferencesProvider;
        readonly CodeActionProvider?: CodeActionProvider;
        readonly SemanticTokenProvider?: SemanticTokenProvider;
        readonly RenameProvider?: RenameProvider;
        readonly Formatter?: Formatter;
        readonly SignatureHelp?: SignatureHelpProvider;
        readonly CallHierarchyProvider?: CallHierarchyProvider;
        readonly TypeHierarchyProvider?: TypeHierarchyProvider;
        readonly DeclarationProvider?: DeclarationProvider;
        readonly InlayHintProvider?: InlayHintProvider;
        readonly CodeLensProvider?: CodeLensProvider;
        readonly DocumentLinkProvider?: DocumentLinkProvider;
    };
    readonly shared: LangiumSharedServices;
};
/**
 * LSP services shared between multiple languages of which Langium provides default implementations.
 */
type LangiumSharedLSPServices = {
    readonly lsp: {
        readonly Connection?: Connection;
        readonly DocumentUpdateHandler: DocumentUpdateHandler;
        readonly ExecuteCommandHandler?: ExecuteCommandHandler;
        readonly FileOperationHandler?: FileOperationHandler;
        readonly FuzzyMatcher: FuzzyMatcher;
        readonly LanguageServer: LanguageServer;
        readonly NodeKindProvider: NodeKindProvider$1;
        readonly WorkspaceSymbolProvider?: WorkspaceSymbolProvider$1;
    };
    readonly workspace: {
        readonly TextDocuments: TextDocuments<TextDocument>;
        readonly NotebookDocuments: NotebookDocuments<TextDocument>;
    };
};

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

interface NextFeature<T extends AbstractElement = AbstractElement> {
    /**
     * A feature that could appear during completion.
     */
    feature: T;
    /**
     * The type that carries this `feature`. Only set if we encounter a new type.
     */
    type?: string;
    /**
     * The container property for the new `type`
     */
    property?: string;
}

/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

type CompletionAcceptor = (context: CompletionContext, value: CompletionValueItem) => void;
type CompletionValueItem = ({
    label?: string;
} | {
    node: AstNode;
} | {
    nodeDescription: AstNodeDescription;
}) & Partial<CompletionItem>;
interface CompletionContext {
    node?: AstNode;
    document: LangiumDocument;
    textDocument: TextDocument;
    features: NextFeature[];
    /**
     * Index at the start of the token related to this context.
     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.
     */
    tokenOffset: number;
    /**
     * Index at the end of the token related to this context, even if it is behind the cursor position.
     * Points at the first character after the last token.
     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.
     */
    tokenEndOffset: number;
    /**
     * Index of the requested completed position.
     */
    offset: number;
    position: Position$1;
}
interface CompletionProviderOptions {
    /**
     * Most tools trigger completion request automatically without explicitly requesting
     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
     * starts to type an identifier. For example if the user types `c` in a JavaScript file
     * code complete will automatically pop up present `console` besides others as a
     * completion item. Characters that make up identifiers don't need to be listed here.
     *
     * If code complete should automatically be trigger on characters not being valid inside
     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
     */
    triggerCharacters?: string[];
    /**
     * The list of all possible characters that commit a completion. This field can be used
     * if clients don't support individual commit characters per completion item.
     *
     * If a server provides both `allCommitCharacters` and commit characters on an individual
     * completion item the ones on the completion item win.
     */
    allCommitCharacters?: string[];
}
interface CompletionBacktrackingInformation {
    previousTokenStart?: number;
    previousTokenEnd?: number;
    nextTokenStart: number;
    nextTokenEnd: number;
}
/**
 * Language-specific service for handling completion requests.
 */
interface CompletionProvider {
    /**
     * Handle a completion request.
     *
     * @param document - the document for which the completion request was triggered
     * @param params - the completion parameters
     * @param cancelToken - a token that can be used to cancel the request
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCompletion(document: LangiumDocument, params: CompletionParams, cancelToken?: CancellationToken$1): MaybePromise<CompletionList | undefined>;
    /**
     * Contains the completion options for this completion provider.
     *
     * If multiple languages return different options, they are merged before being sent to the language client.
     */
    readonly completionOptions?: CompletionProviderOptions;
}
declare class DefaultCompletionProvider implements CompletionProvider {
    protected readonly completionParser: LangiumCompletionParser;
    protected readonly documentationProvider: DocumentationProvider;
    protected readonly scopeProvider: ScopeProvider;
    protected readonly grammar: Grammar;
    protected readonly nameProvider: NameProvider;
    protected readonly lexer: Lexer;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly fuzzyMatcher: FuzzyMatcher;
    protected readonly grammarConfig: GrammarConfig;
    protected readonly astReflection: AstReflection;
    readonly completionOptions?: CompletionProviderOptions;
    constructor(services: LangiumServices);
    getCompletion(document: LangiumDocument, params: CompletionParams, _cancelToken?: CancellationToken$1): Promise<CompletionList | undefined>;
    /**
     * The completion algorithm could yield the same reference/keyword multiple times.
     *
     * This methods deduplicates these items afterwards before returning to the client.
     * Unique items are identified as a combination of `kind`, `label` and `detail`.
     */
    protected deduplicateItems(items: CompletionItem[]): CompletionItem[];
    protected findFeaturesAt(document: TextDocument, offset: number): NextFeature[];
    protected buildContexts(document: LangiumDocument, position: Position$1): IterableIterator<CompletionContext>;
    protected performNextTokenCompletion(document: LangiumDocument, text: string, _offset: number, _end: number): boolean;
    protected findDataTypeRuleStart(cst: CstNode, offset: number): [number, number] | undefined;
    /**
     * Indicates whether the completion should continue to process the next completion context.
     *
     * The default implementation continues the completion only if there are currently no proposed completion items.
     */
    protected continueCompletion(items: CompletionItem[]): boolean;
    /**
     * This method returns two sets of token offset information.
     *
     * The `nextToken*` offsets are related to the token at the cursor position.
     * If there is none, both offsets are simply set to `offset`.
     *
     * The `previousToken*` offsets are related to the last token before the current token at the cursor position.
     * They are `undefined`, if there is no token before the cursor position.
     */
    protected backtrackToAnyToken(text: string, offset: number): CompletionBacktrackingInformation;
    protected completionFor(context: CompletionContext, next: NextFeature, acceptor: CompletionAcceptor): MaybePromise<void>;
    protected completionForCrossReference(context: CompletionContext, next: NextFeature<CrossReference>, acceptor: CompletionAcceptor): MaybePromise<void>;
    /**
     * Override this method to change how the stream of candidates is determined for a reference.
     * This way completion-specific modifications and refinements can be added to the proposals computation
     *  beyond the rules being implemented in the scope provider, e.g. filtering.
     *
     * @param refInfo Information about the reference for which the candidates are requested.
     * @param _context Information about the completion request including document, cursor position, token under cursor, etc.
     * @returns A stream of all elements being valid for the given reference.
     */
    protected getReferenceCandidates(refInfo: ReferenceInfo, _context: CompletionContext): Stream<AstNodeDescription>;
    /**
     * Override this method to change how reference completion items are created.
     *
     * To change the `kind` of a completion item, override the `NodeKindProvider` service instead.
     * To change the `documentation`, override the `DocumentationProvider` service instead.
     *
     * @param nodeDescription The description of a reference candidate
     * @returns A partial completion item
     */
    protected createReferenceCompletionItem(nodeDescription: AstNodeDescription): CompletionValueItem;
    protected getReferenceDocumentation(nodeDescription: AstNodeDescription): MarkupContent | string | undefined;
    protected completionForKeyword(context: CompletionContext, keyword: Keyword, acceptor: CompletionAcceptor): MaybePromise<void>;
    protected getKeywordCompletionItemKind(_keyword: Keyword): CompletionItemKind;
    protected filterKeyword(context: CompletionContext, keyword: Keyword): boolean;
    protected fillCompletionItem(context: CompletionContext, item: CompletionValueItem): CompletionItem | undefined;
    protected buildCompletionTextEdit(context: CompletionContext, label: string, newText: string): TextEdit$1 | undefined;
}

declare class LikeC4DocumentationProvider implements DocumentationProvider {
    private parser;
    private locator;
    constructor(services: LikeC4Services);
    getDocumentation(node: AstNode): string | undefined;
}

type QuoteStyle = 'single' | 'double' | 'ignore' | 'auto';
interface LikeC4FormatterOptions {
    quoteStyle: QuoteStyle;
}
type ExtendedFormattingCommandType = 'normalizeQuotes';
interface ExtendedFormattingCommand {
    type: ExtendedFormattingCommandType;
    region: FormattingRegion;
}
declare class LikeC4Formatter extends AbstractFormatter {
    protected options: LikeC4FormatterOptions;
    extendedFormattingCommands: ExtendedFormattingCommand[];
    constructor(services: LikeC4Services);
    protected doDocumentFormat(document: LangiumDocument, options: FormattingOptions, range?: Range$1): TextEdit$1[];
    protected format(node: AstNode): void;
    protected formatTags(node: AstNode): void;
    protected formatDeploymentRelation(node: AstNode): void;
    protected formatExtendDeployment(node: AstNode): void;
    protected formatRelation(node: AstNode): void;
    protected removeIndentFromTopLevelStatements(node: AstNode): void;
    protected indentContentInBraces(node: AstNode): void;
    protected appendKeywordsWithSpace(node: AstNode): void;
    protected formatView(node: AstNode): void;
    protected formatLeafProperty(node: AstNode): void;
    protected formatLinkProperty(node: AstNode): void;
    protected formatNavigateToProperty(node: AstNode): void;
    protected formatAutolayoutProperty(node: AstNode): void;
    protected formatMetadataProperty(node: AstNode): void;
    protected formatElementDeclaration(node: AstNode): void;
    protected formatExtendElement(node: AstNode): void;
    protected formatGlobals(node: AstNode): void;
    protected formatImports(node: AstNode): void;
    protected formatSpecificationRule(node: AstNode): void;
    protected formatWithPredicate(node: AstNode): void;
    protected formatDeploymentNodeDeclaration(node: AstNode): void;
    protected formatDeployedInstance(node: AstNode): void;
    protected formatViewRuleGlobalStyle(node: AstNode): void;
    protected formatViewRuleGlobalPredicate(node: AstNode): void;
    protected formatViewRuleGroup(node: AstNode): void;
    protected formatViewRuleStyle(node: AstNode): void;
    protected formatWhereExpression(node: AstNode): void;
    protected formatWhereRelationExpression(node: AstNode): void;
    protected formatWhereElementExpression(node: AstNode): void;
    protected formatIncludeExcludeExpressions(node: AstNode): void;
    protected formatRelationExpression(node: AstNode): void;
    private findPredicateExpressionRoot;
    private on;
    private doExtendedFormatting;
    protected normalizeQuotes(node: AstNode): void;
    private quotesNormalizerFactory;
    private escapeQuotesInternalQuotes;
    private getAutoQuoteStyle;
    private onConfigurationUpdate;
}

/******************************************************************************
 * This file was generated by langium-cli 3.5.2.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type AnyProperty = DynamicViewProperty | ElementProperty | RelationProperty | StringProperty | ViewProperty;
declare const AnyProperty = "AnyProperty";
type ArrowType = 'crow' | 'diamond' | 'dot' | 'none' | 'normal' | 'odiamond' | 'odot' | 'onormal' | 'open' | 'vee';
type BorderStyleValue = 'none' | LineOptions;
type ColorLiteral = HexColor | RGBAColor;
declare const ColorLiteral = "ColorLiteral";
type CustomColorId = 'element' | 'model' | ArrowType | ElementShape | LineOptions | string;
type DeploymentElement = DeployedInstance | DeploymentNode;
declare const DeploymentElement = "DeploymentElement";
type DeploymentNodeOrElementKind = DeploymentNodeKind | ElementKind;
declare const DeploymentNodeOrElementKind = "DeploymentNodeOrElementKind";
type DeploymentViewRule = DeploymentViewRulePredicate | DeploymentViewRuleStyle | ViewRuleAutoLayout;
declare const DeploymentViewRule = "DeploymentViewRule";
type DynamicViewDisplayVariantValue = 'diagram' | 'sequence';
type DynamicViewProperty = DynamicViewDisplayVariantProperty | ViewProperty;
declare const DynamicViewProperty = "DynamicViewProperty";
type DynamicViewRule = DynamicViewGlobalPredicateRef | DynamicViewIncludePredicate | ViewRuleAutoLayout | ViewRuleStyleOrGlobalRef;
declare const DynamicViewRule = "DynamicViewRule";
type DynamicViewStep = DynamicStepChain | DynamicStepSingle;
declare const DynamicViewStep = "DynamicViewStep";
type ElementProperty = ElementStringProperty | ElementStyleProperty | IconProperty | LinkProperty | MetadataProperty;
declare const ElementProperty = "ElementProperty";
type ElementShape = 'browser' | 'bucket' | 'cylinder' | 'document' | 'mobile' | 'person' | 'queue' | 'rectangle' | 'storage';
type ExpressionV2 = FqnExprOrWith | RelationExprOrWith;
declare const ExpressionV2 = "ExpressionV2";
type ExtendElementProperty = LinkProperty | MetadataProperty;
declare const ExtendElementProperty = "ExtendElementProperty";
type ExtendRelationProperty = LinkProperty | MetadataProperty;
declare const ExtendRelationProperty = "ExtendRelationProperty";
type FqnExpr = ElementKindExpression | ElementTagExpression | FqnRefExpr | WildcardExpression;
declare const FqnExpr = "FqnExpr";
type FqnExprOrWhere = FqnExpr | FqnExprWhere;
declare const FqnExprOrWhere = "FqnExprOrWhere";
type FqnExprOrWith = FqnExprOrWhere | FqnExprWith;
declare const FqnExprOrWith = "FqnExprOrWith";
type FqnReferenceable = Element | ExtendDeployment | ExtendElement | Referenceable;
declare const FqnReferenceable = "FqnReferenceable";
type IconId = string;
type Id = 'deployment' | 'element' | 'group' | 'instance' | 'model' | 'node' | ArrowType | DynamicViewDisplayVariantValue | ElementShape | LineOptions | Participant | SizeValue | ThemeColor | string;
type LikeC4View = DeploymentView | DynamicView | ElementView;
declare const LikeC4View = "LikeC4View";
type LineOptions = 'dashed' | 'dotted' | 'solid';
type MetadataProperty = MetadataBody;
declare const MetadataProperty = "MetadataProperty";
type MetadataValue = MarkdownOrString | MetadataArray;
declare const MetadataValue = "MetadataValue";
type ModelReferenceable = Element | Imported;
declare const ModelReferenceable = "ModelReferenceable";
type Participant = 'source' | 'target';
type RankValue = 'max' | 'min' | 'same' | 'sink' | 'source';
type Referenceable = DeployedInstance | DeploymentNode | Element | Imported;
declare const Referenceable = "Referenceable";
type RelationExpr = DirectedRelationExpr | InOutRelationExpr | IncomingRelationExpr | OutgoingRelationExpr;
declare const RelationExpr = "RelationExpr";
type RelationExprOrWhere = RelationExpr | RelationExprWhere;
declare const RelationExprOrWhere = "RelationExprOrWhere";
type RelationExprOrWith = RelationExprOrWhere | RelationExprWith;
declare const RelationExprOrWith = "RelationExprOrWith";
type RelationProperty = LinkProperty | MetadataProperty | RelationNavigateToProperty | RelationStringProperty | RelationStyleProperty;
declare const RelationProperty = "RelationProperty";
type RelationshipStyleProperty = ArrowProperty | ColorProperty | LineProperty;
declare const RelationshipStyleProperty = "RelationshipStyleProperty";
type SizeProperty = PaddingSizeProperty | ShapeSizeProperty | TextSizeProperty;
declare const SizeProperty = "SizeProperty";
type SizeValue = 'large' | 'lg' | 'md' | 'medium' | 'sm' | 'small' | 'xl' | 'xlarge' | 'xs' | 'xsmall';
type StringProperty = ElementStringProperty | MetadataAttribute | NotationProperty | NotesProperty | RelationStringProperty | SpecificationElementStringProperty | SpecificationRelationshipStringProperty | ViewStringProperty;
declare const StringProperty = "StringProperty";
type StyleProperty = BorderProperty | ColorProperty | IconProperty | MultipleProperty | OpacityProperty | PaddingSizeProperty | ShapeProperty | ShapeSizeProperty | TextSizeProperty;
declare const StyleProperty = "StyleProperty";
type ThemeColor = 'amber' | 'blue' | 'gray' | 'green' | 'indigo' | 'muted' | 'primary' | 'red' | 'secondary' | 'sky' | 'slate';
type Uri = string;
type ViewLayoutDirection = 'BottomTop' | 'LeftRight' | 'RightLeft' | 'TopBottom';
type ViewProperty = LinkProperty | ViewStringProperty;
declare const ViewProperty = "ViewProperty";
type ViewRule = ViewRuleAutoLayout | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRulePredicate | ViewRuleRank | ViewRuleStyleOrGlobalRef;
declare const ViewRule = "ViewRule";
type ViewRuleStyleOrGlobalRef = ViewRuleGlobalStyle | ViewRuleStyle;
declare const ViewRuleStyleOrGlobalRef = "ViewRuleStyleOrGlobalRef";
type WhereElement = WhereElementKind | WhereElementTag;
declare const WhereElement = "WhereElement";
type WhereElementExpression = WhereBinaryExpression | WhereElement | WhereElementNegation;
declare const WhereElementExpression = "WhereElementExpression";
type WhereExpression = WhereElementExpression | WhereRelationExpression;
declare const WhereExpression = "WhereExpression";
type WhereKindEqual = WhereElementKind | WhereRelationKind | WhereRelationParticipantKind;
declare const WhereKindEqual = "WhereKindEqual";
type WhereRelation = WhereRelationKind | WhereRelationParticipantKind | WhereRelationParticipantTag | WhereRelationTag;
declare const WhereRelation = "WhereRelation";
type WhereRelationExpression = WhereBinaryExpression | WhereRelation | WhereRelationNegation;
declare const WhereRelationExpression = "WhereRelationExpression";
type WhereTagEqual = WhereElementTag | WhereRelationParticipantTag | WhereRelationTag;
declare const WhereTagEqual = "WhereTagEqual";
interface AbstractDynamicStep extends AstNode {
    readonly $container: DynamicStepChain | DynamicViewBody | DynamicViewParallelSteps;
    readonly $type: 'AbstractDynamicStep' | 'DynamicStepChain' | 'DynamicStepSingle';
    custom?: CustomRelationProperties;
    dotKind?: RelationKindDotRef;
    kind?: Reference<RelationshipKind>;
    target: ElementRef;
    title?: string;
}
declare const AbstractDynamicStep = "AbstractDynamicStep";
interface ArrowProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationStyleProperty | SpecificationRelationshipKind;
    readonly $type: 'ArrowProperty';
    key: 'head' | 'tail';
    value: ArrowType;
}
declare const ArrowProperty = "ArrowProperty";
interface BorderProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'BorderProperty';
    key: 'border';
    value: BorderStyleValue;
}
declare const BorderProperty = "BorderProperty";
interface ColorProperty extends AstNode {
    readonly $container: CustomElementProperties | CustomRelationProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | RelationStyleProperty | SpecificationRelationshipKind | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'ColorProperty';
    customColor?: Reference<CustomColor>;
    key: 'color';
    themeColor?: ThemeColor;
}
declare const ColorProperty = "ColorProperty";
interface CustomColor extends AstNode {
    readonly $container: SpecificationColor;
    readonly $type: 'CustomColor';
    name: CustomColorId;
}
declare const CustomColor = "CustomColor";
interface CustomElementProperties extends AstNode {
    readonly $container: FqnExprWith;
    readonly $type: 'CustomElementProperties';
    props: Array<ElementStringProperty | NavigateToProperty | NotationProperty | StyleProperty>;
}
declare const CustomElementProperties = "CustomElementProperties";
interface CustomRelationProperties extends AstNode {
    readonly $container: AbstractDynamicStep | RelationExprWith;
    readonly $type: 'CustomRelationProperties';
    props: Array<NotationProperty | NotesProperty | RelationNavigateToProperty | RelationStringProperty | RelationshipStyleProperty>;
}
declare const CustomRelationProperties = "CustomRelationProperties";
interface DeployedInstance extends AstNode {
    readonly $container: DeploymentNodeBody | ExtendDeploymentBody;
    readonly $type: 'DeployedInstance';
    body?: DeployedInstanceBody;
    name?: Id;
    summary?: string;
    target: ElementRef;
    title?: string;
}
declare const DeployedInstance = "DeployedInstance";
interface DeployedInstanceBody extends AstNode {
    readonly $container: DeployedInstance;
    readonly $type: 'DeployedInstanceBody';
    elements: Array<DeploymentRelation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const DeployedInstanceBody = "DeployedInstanceBody";
interface DeploymentNode extends AstNode {
    readonly $container: DeploymentNodeBody | ExtendDeploymentBody | ModelDeployments;
    readonly $type: 'DeploymentNode';
    body?: DeploymentNodeBody;
    kind: Reference<DeploymentNodeKind>;
    name: Id;
    summary?: string;
    title?: string;
}
declare const DeploymentNode = "DeploymentNode";
interface DeploymentNodeBody extends AstNode {
    readonly $container: DeploymentNode;
    readonly $type: 'DeploymentNodeBody';
    elements: Array<DeployedInstance | DeploymentNode | DeploymentRelation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const DeploymentNodeBody = "DeploymentNodeBody";
interface DeploymentNodeKind extends AstNode {
    readonly $container: SpecificationDeploymentNodeKind;
    readonly $type: 'DeploymentNodeKind';
    name: Id;
}
declare const DeploymentNodeKind = "DeploymentNodeKind";
interface DeploymentRelation extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | ExtendDeploymentBody | ModelDeployments;
    readonly $type: 'DeploymentRelation';
    body?: DeploymentRelationBody;
    description?: string;
    dotKind?: RelationKindDotRef;
    kind?: Reference<RelationshipKind>;
    source?: FqnRef;
    tags?: Tags;
    target: FqnRef;
    technology?: string;
    title?: string;
}
declare const DeploymentRelation = "DeploymentRelation";
interface DeploymentRelationBody extends AstNode {
    readonly $container: DeploymentRelation;
    readonly $type: 'DeploymentRelationBody';
    props: Array<RelationProperty>;
    tags?: Tags;
}
declare const DeploymentRelationBody = "DeploymentRelationBody";
interface DeploymentView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'DeploymentView';
    body?: DeploymentViewBody;
    name: Id;
}
declare const DeploymentView = "DeploymentView";
interface DeploymentViewBody extends AstNode {
    readonly $container: DeploymentView;
    readonly $type: 'DeploymentViewBody';
    props: Array<ViewProperty>;
    rules: Array<DeploymentViewRule>;
    tags?: Tags;
}
declare const DeploymentViewBody = "DeploymentViewBody";
interface DeploymentViewRulePredicate extends AstNode {
    readonly $container: DeploymentViewBody;
    readonly $type: 'DeploymentViewRulePredicate';
    expr: Expressions;
    isInclude: boolean;
}
declare const DeploymentViewRulePredicate = "DeploymentViewRulePredicate";
interface DeploymentViewRuleStyle extends AstNode {
    readonly $container: DeploymentViewBody;
    readonly $type: 'DeploymentViewRuleStyle';
    props: Array<NotationProperty | StyleProperty>;
    targets: FqnExpressions;
}
declare const DeploymentViewRuleStyle = "DeploymentViewRuleStyle";
interface DirectedRelationExpr extends AstNode {
    readonly $container: Expressions | RelationExprWhere | RelationExprWith;
    readonly $type: 'DirectedRelationExpr';
    source: OutgoingRelationExpr;
    target: FqnExpr;
}
declare const DirectedRelationExpr = "DirectedRelationExpr";
interface DynamicView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'DynamicView';
    body?: DynamicViewBody;
    name: Id;
}
declare const DynamicView = "DynamicView";
interface DynamicViewBody extends AstNode {
    readonly $container: DynamicView;
    readonly $type: 'DynamicViewBody';
    props: Array<DynamicViewProperty>;
    rules: Array<DynamicViewRule>;
    steps: Array<DynamicViewParallelSteps | DynamicViewStep>;
    tags?: Tags;
}
declare const DynamicViewBody = "DynamicViewBody";
interface DynamicViewDisplayVariantProperty extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewDisplayVariantProperty';
    key: 'variant';
    value: DynamicViewDisplayVariantValue;
}
declare const DynamicViewDisplayVariantProperty = "DynamicViewDisplayVariantProperty";
interface DynamicViewGlobalPredicateRef extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewGlobalPredicateRef';
    predicate: Reference<GlobalDynamicPredicateGroup>;
}
declare const DynamicViewGlobalPredicateRef = "DynamicViewGlobalPredicateRef";
interface DynamicViewIncludePredicate extends AstNode {
    readonly $container: DynamicViewBody | GlobalDynamicPredicateGroup;
    readonly $type: 'DynamicViewIncludePredicate';
    exprs: Expressions;
}
declare const DynamicViewIncludePredicate = "DynamicViewIncludePredicate";
interface DynamicViewParallelSteps extends AstNode {
    readonly $container: DynamicViewBody;
    readonly $type: 'DynamicViewParallelSteps';
    steps: Array<DynamicViewStep>;
}
declare const DynamicViewParallelSteps = "DynamicViewParallelSteps";
interface DynamicViewRef extends AstNode {
    readonly $container: RelationNavigateToProperty;
    readonly $type: 'DynamicViewRef';
    view: Reference<DynamicView>;
}
declare const DynamicViewRef = "DynamicViewRef";
interface Element extends AstNode {
    readonly $container: ElementBody | ExtendElementBody | Model;
    readonly $type: 'Element';
    body?: ElementBody;
    kind: Reference<ElementKind>;
    name: Id;
    props: Array<string>;
}
declare const Element = "Element";
interface ElementBody extends AstNode {
    readonly $container: Element;
    readonly $type: 'ElementBody';
    elements: Array<Element | Relation>;
    props: Array<ElementProperty>;
    tags?: Tags;
}
declare const ElementBody = "ElementBody";
interface ElementKind extends AstNode {
    readonly $container: SpecificationElementKind;
    readonly $type: 'ElementKind';
    name: Id;
}
declare const ElementKind = "ElementKind";
interface ElementKindExpression extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'ElementKindExpression';
    isEqual: boolean;
    kind: Reference<ElementKind>;
}
declare const ElementKindExpression = "ElementKindExpression";
interface ElementRef extends AstNode {
    readonly $container: AbstractDynamicStep | DeployedInstance | DynamicStepSingle | ElementView;
    readonly $type: 'ElementRef';
    modelElement: FqnRef;
}
declare const ElementRef = "ElementRef";
interface ElementStringProperty extends AstNode {
    readonly $container: CustomElementProperties | DeployedInstanceBody | DeploymentNodeBody | ElementBody;
    readonly $type: 'ElementStringProperty';
    key: 'description' | 'summary' | 'technology' | 'title';
    value: MarkdownOrString;
}
declare const ElementStringProperty = "ElementStringProperty";
interface ElementStyleProperty extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | ElementBody | SpecificationDeploymentNodeKind | SpecificationElementKind;
    readonly $type: 'ElementStyleProperty';
    key: 'style';
    props: Array<StyleProperty>;
}
declare const ElementStyleProperty = "ElementStyleProperty";
interface ElementTagExpression extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'ElementTagExpression';
    isEqual: boolean;
    tag: TagRef;
}
declare const ElementTagExpression = "ElementTagExpression";
interface ElementView extends AstNode {
    readonly $container: ModelViews;
    readonly $type: 'ElementView';
    body?: ElementViewBody;
    extends?: ElementViewRef;
    name?: Id;
    viewOf?: ElementRef;
}
declare const ElementView = "ElementView";
interface ElementViewBody extends AstNode {
    readonly $container: ElementView;
    readonly $type: 'ElementViewBody';
    props: Array<ViewProperty>;
    rules: Array<ViewRule>;
    tags?: Tags;
}
declare const ElementViewBody = "ElementViewBody";
interface ElementViewRef extends AstNode {
    readonly $container: ElementView;
    readonly $type: 'ElementViewRef';
    view: Reference<ElementView>;
}
declare const ElementViewRef = "ElementViewRef";
interface Expressions extends AstNode {
    readonly $container: DeploymentViewRulePredicate | DynamicViewIncludePredicate | Expressions | ViewRulePredicate;
    readonly $type: 'Expressions';
    prev?: Expressions;
    value: ExpressionV2;
}
declare const Expressions = "Expressions";
interface ExtendDeployment extends AstNode {
    readonly $container: ModelDeployments;
    readonly $type: 'ExtendDeployment';
    body: ExtendDeploymentBody;
    deploymentNode: StrictFqnRef;
}
declare const ExtendDeployment = "ExtendDeployment";
interface ExtendDeploymentBody extends AstNode {
    readonly $container: ExtendDeployment;
    readonly $type: 'ExtendDeploymentBody';
    elements: Array<DeployedInstance | DeploymentNode | DeploymentRelation>;
    props: Array<ExtendElementProperty>;
    tags?: Tags;
}
declare const ExtendDeploymentBody = "ExtendDeploymentBody";
interface ExtendElement extends AstNode {
    readonly $container: Model;
    readonly $type: 'ExtendElement';
    body: ExtendElementBody;
    element: StrictFqnElementRef;
}
declare const ExtendElement = "ExtendElement";
interface ExtendElementBody extends AstNode {
    readonly $container: ExtendElement;
    readonly $type: 'ExtendElementBody';
    elements: Array<Element | Relation>;
    props: Array<ExtendElementProperty>;
    tags?: Tags;
}
declare const ExtendElementBody = "ExtendElementBody";
interface ExtendRelation extends AstNode {
    readonly $container: Model;
    readonly $type: 'ExtendRelation';
    body: ExtendRelationBody;
    dotKind?: RelationKindDotRef;
    kind?: Reference<RelationshipKind>;
    source: FqnRef;
    target: FqnRef;
    title?: string;
}
declare const ExtendRelation = "ExtendRelation";
interface ExtendRelationBody extends AstNode {
    readonly $container: ExtendRelation;
    readonly $type: 'ExtendRelationBody';
    props: Array<ExtendRelationProperty>;
    tags?: Tags;
}
declare const ExtendRelationBody = "ExtendRelationBody";
interface FqnExpressions extends AstNode {
    readonly $container: DeploymentViewRuleStyle | FqnExpressions | GlobalStyle | ViewRuleRank | ViewRuleStyle;
    readonly $type: 'FqnExpressions';
    prev?: FqnExpressions;
    value: FqnExpr;
}
declare const FqnExpressions = "FqnExpressions";
interface FqnExprWhere extends AstNode {
    readonly $container: Expressions | FqnExprWith;
    readonly $type: 'FqnExprWhere';
    subject: FqnExpr;
    where?: WhereElementExpression;
}
declare const FqnExprWhere = "FqnExprWhere";
interface FqnExprWith extends AstNode {
    readonly $container: Expressions;
    readonly $type: 'FqnExprWith';
    custom?: CustomElementProperties;
    subject: FqnExprOrWhere;
}
declare const FqnExprWith = "FqnExprWith";
interface FqnRef extends AstNode {
    readonly $container: DeploymentRelation | ElementRef | ExtendRelation | FqnRef | FqnRefExpr | Relation;
    readonly $type: 'FqnRef';
    parent?: FqnRef;
    value: Reference<Referenceable>;
}
declare const FqnRef = "FqnRef";
interface FqnRefExpr extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'FqnRefExpr';
    ref: FqnRef;
    selector?: string;
}
declare const FqnRefExpr = "FqnRefExpr";
interface GlobalDynamicPredicateGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalDynamicPredicateGroup';
    name: string;
    predicates: Array<DynamicViewIncludePredicate>;
}
declare const GlobalDynamicPredicateGroup = "GlobalDynamicPredicateGroup";
interface GlobalPredicateGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalPredicateGroup';
    name: string;
    predicates: Array<ViewRulePredicate>;
}
declare const GlobalPredicateGroup = "GlobalPredicateGroup";
interface Globals extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'Globals';
    name: 'global';
    predicates: Array<GlobalDynamicPredicateGroup | GlobalPredicateGroup>;
    styles: Array<GlobalStyle | GlobalStyleGroup>;
}
declare const Globals = "Globals";
interface GlobalStyle extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalStyle';
    id: GlobalStyleId;
    props: Array<NotationProperty | StyleProperty>;
    targets: FqnExpressions;
}
declare const GlobalStyle = "GlobalStyle";
interface GlobalStyleGroup extends AstNode {
    readonly $container: Globals;
    readonly $type: 'GlobalStyleGroup';
    id: GlobalStyleId;
    styles: Array<ViewRuleStyle>;
}
declare const GlobalStyleGroup = "GlobalStyleGroup";
interface GlobalStyleId extends AstNode {
    readonly $container: GlobalStyle | GlobalStyleGroup;
    readonly $type: 'GlobalStyleId';
    name: string;
}
declare const GlobalStyleId = "GlobalStyleId";
interface HexColor extends AstNode {
    readonly $container: SpecificationColor | SpecificationTag;
    readonly $type: 'HexColor';
    hex: number | string;
}
declare const HexColor = "HexColor";
interface IconProperty extends AstNode {
    readonly $container: CustomElementProperties | DeployedInstanceBody | DeploymentNodeBody | DeploymentViewRuleStyle | ElementBody | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'IconProperty';
    key: 'icon';
    libicon?: Reference<LibIcon>;
    value?: 'none' | Uri;
}
declare const IconProperty = "IconProperty";
interface Imported extends AstNode {
    readonly $container: Imported | ImportsFromPoject;
    readonly $type: 'Imported';
    imported: Reference<Element>;
    prev?: Imported;
}
declare const Imported = "Imported";
interface ImportsFromPoject extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ImportsFromPoject';
    imports: Imported;
    project: string;
}
declare const ImportsFromPoject = "ImportsFromPoject";
interface IncomingRelationExpr extends AstNode {
    readonly $container: Expressions | InOutRelationExpr | RelationExprWhere | RelationExprWith;
    readonly $type: 'IncomingRelationExpr';
    to: FqnExpr;
}
declare const IncomingRelationExpr = "IncomingRelationExpr";
interface InOutRelationExpr extends AstNode {
    readonly $container: Expressions | RelationExprWhere | RelationExprWith;
    readonly $type: 'InOutRelationExpr';
    inout: IncomingRelationExpr;
}
declare const InOutRelationExpr = "InOutRelationExpr";
interface LibIcon extends AstNode {
    readonly $container: LikeC4Lib;
    readonly $type: 'LibIcon';
    name: IconId;
}
declare const LibIcon = "LibIcon";
interface LikeC4Grammar extends AstNode {
    readonly $type: 'LikeC4Grammar';
    deployments: Array<ModelDeployments>;
    globals: Array<Globals>;
    imports: Array<ImportsFromPoject>;
    likec4lib: Array<LikeC4Lib>;
    models: Array<Model>;
    specifications: Array<SpecificationRule>;
    views: Array<ModelViews>;
}
declare const LikeC4Grammar = "LikeC4Grammar";
interface LikeC4Lib extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'LikeC4Lib';
    icons: Array<LibIcon>;
}
declare const LikeC4Lib = "LikeC4Lib";
interface LineProperty extends AstNode {
    readonly $container: CustomRelationProperties | RelationStyleProperty | SpecificationRelationshipKind;
    readonly $type: 'LineProperty';
    key: 'line';
    value: LineOptions;
}
declare const LineProperty = "LineProperty";
interface LinkProperty extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | DeploymentRelationBody | DeploymentViewBody | DynamicViewBody | ElementBody | ElementViewBody | ExtendDeploymentBody | ExtendElementBody | ExtendRelationBody | RelationBody | SpecificationDeploymentNodeKind | SpecificationElementKind;
    readonly $type: 'LinkProperty';
    key: 'link';
    title?: string;
    value: Uri;
}
declare const LinkProperty = "LinkProperty";
interface MarkdownOrString extends AstNode {
    readonly $container: ElementStringProperty | MetadataArray | MetadataAttribute | NotationProperty | NotesProperty | RelationStringProperty | SpecificationElementStringProperty | SpecificationRelationshipStringProperty | ViewStringProperty;
    readonly $type: 'MarkdownOrString';
    markdown?: string;
    text?: string;
}
declare const MarkdownOrString = "MarkdownOrString";
interface MetadataArray extends AstNode {
    readonly $container: MetadataAttribute;
    readonly $type: 'MetadataArray';
    values: Array<MarkdownOrString>;
}
declare const MetadataArray = "MetadataArray";
interface MetadataAttribute extends AstNode {
    readonly $container: MetadataBody;
    readonly $type: 'MetadataAttribute';
    key: string;
    value: MetadataValue;
}
declare const MetadataAttribute = "MetadataAttribute";
interface MetadataBody extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | DeploymentRelationBody | ElementBody | ExtendDeploymentBody | ExtendElementBody | ExtendRelationBody | RelationBody;
    readonly $type: 'MetadataBody';
    props: Array<MetadataAttribute>;
}
declare const MetadataBody = "MetadataBody";
interface Model extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'Model';
    elements: Array<Element | ExtendElement | ExtendRelation | Relation>;
    name: 'model';
}
declare const Model = "Model";
interface ModelDeployments extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ModelDeployments';
    elements: Array<DeploymentNode | DeploymentRelation | ExtendDeployment>;
    name: 'deployment';
}
declare const ModelDeployments = "ModelDeployments";
interface ModelViews extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'ModelViews';
    folder?: string;
    name: 'views';
    styles: Array<ViewRuleStyleOrGlobalRef>;
    views: Array<LikeC4View>;
}
declare const ModelViews = "ModelViews";
interface MultipleProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'MultipleProperty';
    key: 'multiple';
    value: boolean;
}
declare const MultipleProperty = "MultipleProperty";
interface NavigateToProperty extends AstNode {
    readonly $container: CustomElementProperties;
    readonly $type: 'NavigateToProperty';
    key: 'navigateTo';
    value: ViewRef;
}
declare const NavigateToProperty = "NavigateToProperty";
interface NotationProperty extends AstNode {
    readonly $container: CustomElementProperties | CustomRelationProperties | DeploymentViewRuleStyle | GlobalStyle | ViewRuleStyle;
    readonly $type: 'NotationProperty';
    key: 'notation';
    value: MarkdownOrString;
}
declare const NotationProperty = "NotationProperty";
interface NotesProperty extends AstNode {
    readonly $container: CustomRelationProperties;
    readonly $type: 'NotesProperty';
    key: 'notes';
    value: MarkdownOrString;
}
declare const NotesProperty = "NotesProperty";
interface OpacityProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleGroup | ViewRuleStyle;
    readonly $type: 'OpacityProperty';
    key: 'opacity';
    value: string;
}
declare const OpacityProperty = "OpacityProperty";
interface OutgoingRelationExpr extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | RelationExprWhere | RelationExprWith;
    readonly $type: 'OutgoingRelationExpr';
    dotKind?: RelationKindDotRef;
    from: FqnExpr;
    isBidirectional: boolean;
    kind?: Reference<RelationshipKind>;
}
declare const OutgoingRelationExpr = "OutgoingRelationExpr";
interface PaddingSizeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'PaddingSizeProperty';
    key: 'padding';
    value: SizeValue;
}
declare const PaddingSizeProperty = "PaddingSizeProperty";
interface Relation extends AstNode {
    readonly $container: ElementBody | ExtendElementBody | Model;
    readonly $type: 'Relation';
    body?: RelationBody;
    description?: string;
    dotKind?: RelationKindDotRef;
    kind?: Reference<RelationshipKind>;
    source?: FqnRef;
    tags?: Tags;
    target: FqnRef;
    technology?: string;
    title?: string;
}
declare const Relation = "Relation";
interface RelationBody extends AstNode {
    readonly $container: Relation;
    readonly $type: 'RelationBody';
    props: Array<RelationProperty>;
    tags?: Tags;
}
declare const RelationBody = "RelationBody";
interface RelationExprWhere extends AstNode {
    readonly $container: Expressions | RelationExprWith;
    readonly $type: 'RelationExprWhere';
    subject: RelationExpr;
    where?: WhereRelationExpression;
}
declare const RelationExprWhere = "RelationExprWhere";
interface RelationExprWith extends AstNode {
    readonly $container: Expressions;
    readonly $type: 'RelationExprWith';
    custom?: CustomRelationProperties;
    subject: RelationExprOrWhere;
}
declare const RelationExprWith = "RelationExprWith";
interface RelationKindDotRef extends AstNode {
    readonly $container: AbstractDynamicStep | DeploymentRelation | ExtendRelation | OutgoingRelationExpr | Relation;
    readonly $type: 'RelationKindDotRef';
    kind: Reference<RelationshipKind>;
}
declare const RelationKindDotRef = "RelationKindDotRef";
interface RelationNavigateToProperty extends AstNode {
    readonly $container: CustomRelationProperties | DeploymentRelationBody | RelationBody;
    readonly $type: 'RelationNavigateToProperty';
    key: 'navigateTo';
    value: DynamicViewRef;
}
declare const RelationNavigateToProperty = "RelationNavigateToProperty";
interface RelationshipKind extends AstNode {
    readonly $container: SpecificationRelationshipKind;
    readonly $type: 'RelationshipKind';
    name: Id;
}
declare const RelationshipKind = "RelationshipKind";
interface RelationStringProperty extends AstNode {
    readonly $container: CustomRelationProperties | DeploymentRelationBody | RelationBody;
    readonly $type: 'RelationStringProperty';
    key: 'description' | 'technology' | 'title';
    value: MarkdownOrString;
}
declare const RelationStringProperty = "RelationStringProperty";
interface RelationStyleProperty extends AstNode {
    readonly $container: DeploymentRelationBody | RelationBody;
    readonly $type: 'RelationStyleProperty';
    key: 'style';
    props: Array<RelationshipStyleProperty>;
}
declare const RelationStyleProperty = "RelationStyleProperty";
interface RGBAColor extends AstNode {
    readonly $container: SpecificationColor | SpecificationTag;
    readonly $type: 'RGBAColor';
    alpha?: number | string;
    blue: number;
    green: number;
    red: number;
}
declare const RGBAColor = "RGBAColor";
interface ShapeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'ShapeProperty';
    key: 'shape';
    value: ElementShape;
}
declare const ShapeProperty = "ShapeProperty";
interface ShapeSizeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'ShapeSizeProperty';
    key: 'size';
    value: SizeValue;
}
declare const ShapeSizeProperty = "ShapeSizeProperty";
interface SpecificationColor extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationColor';
    color: ColorLiteral;
    name: CustomColor;
}
declare const SpecificationColor = "SpecificationColor";
interface SpecificationDeploymentNodeKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationDeploymentNodeKind';
    kind: DeploymentNodeKind;
    props: Array<ElementStyleProperty | LinkProperty | SpecificationElementStringProperty>;
    tags?: Tags;
}
declare const SpecificationDeploymentNodeKind = "SpecificationDeploymentNodeKind";
interface SpecificationElementKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationElementKind';
    kind: ElementKind;
    props: Array<ElementStyleProperty | LinkProperty | SpecificationElementStringProperty>;
    tags?: Tags;
}
declare const SpecificationElementKind = "SpecificationElementKind";
interface SpecificationElementStringProperty extends AstNode {
    readonly $container: SpecificationDeploymentNodeKind | SpecificationElementKind;
    readonly $type: 'SpecificationElementStringProperty';
    key: 'description' | 'notation' | 'summary' | 'technology' | 'title';
    value: MarkdownOrString;
}
declare const SpecificationElementStringProperty = "SpecificationElementStringProperty";
interface SpecificationRelationshipKind extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationRelationshipKind';
    kind: RelationshipKind;
    props: Array<RelationshipStyleProperty | SpecificationRelationshipStringProperty>;
}
declare const SpecificationRelationshipKind = "SpecificationRelationshipKind";
interface SpecificationRelationshipStringProperty extends AstNode {
    readonly $container: SpecificationRelationshipKind;
    readonly $type: 'SpecificationRelationshipStringProperty';
    key: 'notation' | 'technology';
    value: MarkdownOrString;
}
declare const SpecificationRelationshipStringProperty = "SpecificationRelationshipStringProperty";
interface SpecificationRule extends AstNode {
    readonly $container: LikeC4Grammar;
    readonly $type: 'SpecificationRule';
    colors: Array<SpecificationColor>;
    deploymentNodes: Array<SpecificationDeploymentNodeKind>;
    elements: Array<SpecificationElementKind>;
    name: 'specification';
    relationships: Array<SpecificationRelationshipKind>;
    tags: Array<SpecificationTag>;
}
declare const SpecificationRule = "SpecificationRule";
interface SpecificationTag extends AstNode {
    readonly $container: SpecificationRule;
    readonly $type: 'SpecificationTag';
    color?: ColorLiteral;
    tag: Tag;
}
declare const SpecificationTag = "SpecificationTag";
interface StrictFqnElementRef extends AstNode {
    readonly $container: ExtendElement | StrictFqnElementRef;
    readonly $type: 'StrictFqnElementRef';
    el: Reference<Element>;
    parent?: StrictFqnElementRef;
}
declare const StrictFqnElementRef = "StrictFqnElementRef";
interface StrictFqnRef extends AstNode {
    readonly $container: ExtendDeployment | StrictFqnRef;
    readonly $type: 'StrictFqnRef';
    parent?: StrictFqnRef;
    value: Reference<Referenceable>;
}
declare const StrictFqnRef = "StrictFqnRef";
interface Tag extends AstNode {
    readonly $container: SpecificationTag;
    readonly $type: 'Tag';
    name: Id;
}
declare const Tag = "Tag";
interface TagRef extends AstNode {
    readonly $container: ElementTagExpression | Tags | WhereElementTag | WhereRelationParticipantTag | WhereRelationTag;
    readonly $type: 'TagRef';
    tag: Reference<Tag>;
}
declare const TagRef = "TagRef";
interface Tags extends AstNode {
    readonly $container: DeployedInstanceBody | DeploymentNodeBody | DeploymentRelation | DeploymentRelationBody | DeploymentViewBody | DynamicViewBody | ElementBody | ElementViewBody | ExtendDeploymentBody | ExtendElementBody | ExtendRelationBody | Relation | RelationBody | SpecificationDeploymentNodeKind | SpecificationElementKind | Tags;
    readonly $type: 'Tags';
    prev?: Tags;
    values: Array<TagRef>;
}
declare const Tags = "Tags";
interface TextSizeProperty extends AstNode {
    readonly $container: CustomElementProperties | DeploymentViewRuleStyle | ElementStyleProperty | GlobalStyle | ViewRuleStyle;
    readonly $type: 'TextSizeProperty';
    key: 'textSize';
    value: SizeValue;
}
declare const TextSizeProperty = "TextSizeProperty";
interface ViewRef extends AstNode {
    readonly $container: NavigateToProperty;
    readonly $type: 'ViewRef';
    view: Reference<LikeC4View>;
}
declare const ViewRef = "ViewRef";
interface ViewRuleAutoLayout extends AstNode {
    readonly $container: DeploymentViewBody | DynamicViewBody | ElementViewBody;
    readonly $type: 'ViewRuleAutoLayout';
    direction: ViewLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare const ViewRuleAutoLayout = "ViewRuleAutoLayout";
interface ViewRuleGlobalPredicateRef extends AstNode {
    readonly $container: ElementViewBody;
    readonly $type: 'ViewRuleGlobalPredicateRef';
    predicate: Reference<GlobalPredicateGroup>;
}
declare const ViewRuleGlobalPredicateRef = "ViewRuleGlobalPredicateRef";
interface ViewRuleGlobalStyle extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody | ModelViews;
    readonly $type: 'ViewRuleGlobalStyle';
    style: Reference<GlobalStyleId>;
}
declare const ViewRuleGlobalStyle = "ViewRuleGlobalStyle";
interface ViewRuleGroup extends AstNode {
    readonly $container: ElementViewBody | ViewRuleGroup;
    readonly $type: 'ViewRuleGroup';
    groupRules: Array<ViewRuleGroup | ViewRulePredicate>;
    props: Array<BorderProperty | ColorProperty | OpacityProperty>;
    title?: string;
}
declare const ViewRuleGroup = "ViewRuleGroup";
interface ViewRulePredicate extends AstNode {
    readonly $container: ElementViewBody | GlobalPredicateGroup | ViewRuleGroup;
    readonly $type: 'ViewRulePredicate';
    exprs: Expressions;
    isInclude: boolean;
}
declare const ViewRulePredicate = "ViewRulePredicate";
interface ViewRuleRank extends AstNode {
    readonly $container: ElementViewBody;
    readonly $type: 'ViewRuleRank';
    targets: FqnExpressions;
    value?: RankValue;
}
declare const ViewRuleRank = "ViewRuleRank";
interface ViewRuleStyle extends AstNode {
    readonly $container: DynamicViewBody | ElementViewBody | GlobalStyleGroup | ModelViews;
    readonly $type: 'ViewRuleStyle';
    props: Array<NotationProperty | StyleProperty>;
    targets: FqnExpressions;
}
declare const ViewRuleStyle = "ViewRuleStyle";
interface ViewStringProperty extends AstNode {
    readonly $container: DeploymentViewBody | DynamicViewBody | ElementViewBody;
    readonly $type: 'ViewStringProperty';
    key: 'description' | 'title';
    value: MarkdownOrString;
}
declare const ViewStringProperty = "ViewStringProperty";
interface WhereBinaryExpression extends AstNode {
    readonly $container: FqnExprWhere | RelationExprWhere | WhereBinaryExpression | WhereElementNegation | WhereRelationNegation;
    readonly $type: 'WhereBinaryExpression';
    left: WhereElementExpression | WhereRelationExpression;
    operator: 'and' | 'or';
    right: WhereElementExpression | WhereRelationExpression;
}
declare const WhereBinaryExpression = "WhereBinaryExpression";
interface WhereElementKind extends AstNode {
    readonly $container: FqnExprWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementKind';
    not: boolean;
    operator: 'is' | string;
    value: Reference<DeploymentNodeOrElementKind>;
}
declare const WhereElementKind = "WhereElementKind";
interface WhereElementNegation extends AstNode {
    readonly $container: FqnExprWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementNegation';
    value: WhereElementExpression;
}
declare const WhereElementNegation = "WhereElementNegation";
interface WhereElementTag extends AstNode {
    readonly $container: FqnExprWhere | WhereBinaryExpression | WhereElementNegation;
    readonly $type: 'WhereElementTag';
    not: boolean;
    operator: 'is' | string;
    value: TagRef;
}
declare const WhereElementTag = "WhereElementTag";
interface WhereRelationKind extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationKind';
    not: boolean;
    operator: 'is' | string;
    value: Reference<RelationshipKind>;
}
declare const WhereRelationKind = "WhereRelationKind";
interface WhereRelationNegation extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationNegation';
    value: WhereRelationExpression;
}
declare const WhereRelationNegation = "WhereRelationNegation";
interface WhereRelationParticipantKind extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationParticipantKind';
    not: boolean;
    operator: 'is' | string;
    participant: Participant;
    value: Reference<DeploymentNodeOrElementKind>;
}
declare const WhereRelationParticipantKind = "WhereRelationParticipantKind";
interface WhereRelationParticipantTag extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationParticipantTag';
    not: boolean;
    operator: 'is' | string;
    participant: Participant;
    value: TagRef;
}
declare const WhereRelationParticipantTag = "WhereRelationParticipantTag";
interface WhereRelationTag extends AstNode {
    readonly $container: RelationExprWhere | WhereBinaryExpression | WhereRelationNegation;
    readonly $type: 'WhereRelationTag';
    not: boolean;
    operator: 'is' | string;
    value: TagRef;
}
declare const WhereRelationTag = "WhereRelationTag";
interface WildcardExpression extends AstNode {
    readonly $container: DirectedRelationExpr | Expressions | FqnExprWhere | FqnExprWith | FqnExpressions | IncomingRelationExpr | OutgoingRelationExpr;
    readonly $type: 'WildcardExpression';
    isWildcard: boolean;
}
declare const WildcardExpression = "WildcardExpression";
interface DynamicStepChain extends AbstractDynamicStep {
    readonly $container: DynamicStepChain | DynamicViewBody | DynamicViewParallelSteps;
    readonly $type: 'DynamicStepChain';
    source: DynamicStepChain | DynamicStepSingle;
}
declare const DynamicStepChain = "DynamicStepChain";
interface DynamicStepSingle extends AbstractDynamicStep {
    readonly $container: DynamicStepChain | DynamicViewBody | DynamicViewParallelSteps;
    readonly $type: 'DynamicStepSingle';
    isBackward: boolean;
    source: ElementRef;
}
declare const DynamicStepSingle = "DynamicStepSingle";
type LikeC4AstType = {
    AbstractDynamicStep: AbstractDynamicStep;
    AnyProperty: AnyProperty;
    ArrowProperty: ArrowProperty;
    BorderProperty: BorderProperty;
    ColorLiteral: ColorLiteral;
    ColorProperty: ColorProperty;
    CustomColor: CustomColor;
    CustomElementProperties: CustomElementProperties;
    CustomRelationProperties: CustomRelationProperties;
    DeployedInstance: DeployedInstance;
    DeployedInstanceBody: DeployedInstanceBody;
    DeploymentElement: DeploymentElement;
    DeploymentNode: DeploymentNode;
    DeploymentNodeBody: DeploymentNodeBody;
    DeploymentNodeKind: DeploymentNodeKind;
    DeploymentNodeOrElementKind: DeploymentNodeOrElementKind;
    DeploymentRelation: DeploymentRelation;
    DeploymentRelationBody: DeploymentRelationBody;
    DeploymentView: DeploymentView;
    DeploymentViewBody: DeploymentViewBody;
    DeploymentViewRule: DeploymentViewRule;
    DeploymentViewRulePredicate: DeploymentViewRulePredicate;
    DeploymentViewRuleStyle: DeploymentViewRuleStyle;
    DirectedRelationExpr: DirectedRelationExpr;
    DynamicStepChain: DynamicStepChain;
    DynamicStepSingle: DynamicStepSingle;
    DynamicView: DynamicView;
    DynamicViewBody: DynamicViewBody;
    DynamicViewDisplayVariantProperty: DynamicViewDisplayVariantProperty;
    DynamicViewGlobalPredicateRef: DynamicViewGlobalPredicateRef;
    DynamicViewIncludePredicate: DynamicViewIncludePredicate;
    DynamicViewParallelSteps: DynamicViewParallelSteps;
    DynamicViewProperty: DynamicViewProperty;
    DynamicViewRef: DynamicViewRef;
    DynamicViewRule: DynamicViewRule;
    DynamicViewStep: DynamicViewStep;
    Element: Element;
    ElementBody: ElementBody;
    ElementKind: ElementKind;
    ElementKindExpression: ElementKindExpression;
    ElementProperty: ElementProperty;
    ElementRef: ElementRef;
    ElementStringProperty: ElementStringProperty;
    ElementStyleProperty: ElementStyleProperty;
    ElementTagExpression: ElementTagExpression;
    ElementView: ElementView;
    ElementViewBody: ElementViewBody;
    ElementViewRef: ElementViewRef;
    ExpressionV2: ExpressionV2;
    Expressions: Expressions;
    ExtendDeployment: ExtendDeployment;
    ExtendDeploymentBody: ExtendDeploymentBody;
    ExtendElement: ExtendElement;
    ExtendElementBody: ExtendElementBody;
    ExtendElementProperty: ExtendElementProperty;
    ExtendRelation: ExtendRelation;
    ExtendRelationBody: ExtendRelationBody;
    ExtendRelationProperty: ExtendRelationProperty;
    FqnExpr: FqnExpr;
    FqnExprOrWhere: FqnExprOrWhere;
    FqnExprOrWith: FqnExprOrWith;
    FqnExprWhere: FqnExprWhere;
    FqnExprWith: FqnExprWith;
    FqnExpressions: FqnExpressions;
    FqnRef: FqnRef;
    FqnRefExpr: FqnRefExpr;
    FqnReferenceable: FqnReferenceable;
    GlobalDynamicPredicateGroup: GlobalDynamicPredicateGroup;
    GlobalPredicateGroup: GlobalPredicateGroup;
    GlobalStyle: GlobalStyle;
    GlobalStyleGroup: GlobalStyleGroup;
    GlobalStyleId: GlobalStyleId;
    Globals: Globals;
    HexColor: HexColor;
    IconProperty: IconProperty;
    Imported: Imported;
    ImportsFromPoject: ImportsFromPoject;
    InOutRelationExpr: InOutRelationExpr;
    IncomingRelationExpr: IncomingRelationExpr;
    LibIcon: LibIcon;
    LikeC4Grammar: LikeC4Grammar;
    LikeC4Lib: LikeC4Lib;
    LikeC4View: LikeC4View;
    LineProperty: LineProperty;
    LinkProperty: LinkProperty;
    MarkdownOrString: MarkdownOrString;
    MetadataArray: MetadataArray;
    MetadataAttribute: MetadataAttribute;
    MetadataBody: MetadataBody;
    MetadataProperty: MetadataProperty;
    MetadataValue: MetadataValue;
    Model: Model;
    ModelDeployments: ModelDeployments;
    ModelReferenceable: ModelReferenceable;
    ModelViews: ModelViews;
    MultipleProperty: MultipleProperty;
    NavigateToProperty: NavigateToProperty;
    NotationProperty: NotationProperty;
    NotesProperty: NotesProperty;
    OpacityProperty: OpacityProperty;
    OutgoingRelationExpr: OutgoingRelationExpr;
    PaddingSizeProperty: PaddingSizeProperty;
    RGBAColor: RGBAColor;
    Referenceable: Referenceable;
    Relation: Relation;
    RelationBody: RelationBody;
    RelationExpr: RelationExpr;
    RelationExprOrWhere: RelationExprOrWhere;
    RelationExprOrWith: RelationExprOrWith;
    RelationExprWhere: RelationExprWhere;
    RelationExprWith: RelationExprWith;
    RelationKindDotRef: RelationKindDotRef;
    RelationNavigateToProperty: RelationNavigateToProperty;
    RelationProperty: RelationProperty;
    RelationStringProperty: RelationStringProperty;
    RelationStyleProperty: RelationStyleProperty;
    RelationshipKind: RelationshipKind;
    RelationshipStyleProperty: RelationshipStyleProperty;
    ShapeProperty: ShapeProperty;
    ShapeSizeProperty: ShapeSizeProperty;
    SizeProperty: SizeProperty;
    SpecificationColor: SpecificationColor;
    SpecificationDeploymentNodeKind: SpecificationDeploymentNodeKind;
    SpecificationElementKind: SpecificationElementKind;
    SpecificationElementStringProperty: SpecificationElementStringProperty;
    SpecificationRelationshipKind: SpecificationRelationshipKind;
    SpecificationRelationshipStringProperty: SpecificationRelationshipStringProperty;
    SpecificationRule: SpecificationRule;
    SpecificationTag: SpecificationTag;
    StrictFqnElementRef: StrictFqnElementRef;
    StrictFqnRef: StrictFqnRef;
    StringProperty: StringProperty;
    StyleProperty: StyleProperty;
    Tag: Tag;
    TagRef: TagRef;
    Tags: Tags;
    TextSizeProperty: TextSizeProperty;
    ViewProperty: ViewProperty;
    ViewRef: ViewRef;
    ViewRule: ViewRule;
    ViewRuleAutoLayout: ViewRuleAutoLayout;
    ViewRuleGlobalPredicateRef: ViewRuleGlobalPredicateRef;
    ViewRuleGlobalStyle: ViewRuleGlobalStyle;
    ViewRuleGroup: ViewRuleGroup;
    ViewRulePredicate: ViewRulePredicate;
    ViewRuleRank: ViewRuleRank;
    ViewRuleStyle: ViewRuleStyle;
    ViewRuleStyleOrGlobalRef: ViewRuleStyleOrGlobalRef;
    ViewStringProperty: ViewStringProperty;
    WhereBinaryExpression: WhereBinaryExpression;
    WhereElement: WhereElement;
    WhereElementExpression: WhereElementExpression;
    WhereElementKind: WhereElementKind;
    WhereElementNegation: WhereElementNegation;
    WhereElementTag: WhereElementTag;
    WhereExpression: WhereExpression;
    WhereKindEqual: WhereKindEqual;
    WhereRelation: WhereRelation;
    WhereRelationExpression: WhereRelationExpression;
    WhereRelationKind: WhereRelationKind;
    WhereRelationNegation: WhereRelationNegation;
    WhereRelationParticipantKind: WhereRelationParticipantKind;
    WhereRelationParticipantTag: WhereRelationParticipantTag;
    WhereRelationTag: WhereRelationTag;
    WhereTagEqual: WhereTagEqual;
    WildcardExpression: WildcardExpression;
};

declare class LikeC4DocumentValidator extends DefaultDocumentValidator {
    protected services: LikeC4Services;
    constructor(services: LikeC4Services);
    /**
     * If the document is excluded, then we skip validation and return an empty array of diagnostics.
     */
    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken$1): Promise<Diagnostic[]>;
}

type Guard<N extends AstNode> = (n: AstNode) => n is N;
type Guarded<G> = G extends Guard<infer N> ? N : never;
declare const isValidatableAstNode: (n: AstNode) => n is Element | DeployedInstance | DeploymentNode | Tags | ElementKindExpression | ElementTagExpression | FqnRefExpr | WildcardExpression | FqnExprWhere | FqnExprWith | DirectedRelationExpr | InOutRelationExpr | IncomingRelationExpr | OutgoingRelationExpr | RelationExprWhere | RelationExprWith | ImportsFromPoject | Imported | Globals | GlobalPredicateGroup | GlobalDynamicPredicateGroup | GlobalStyle | GlobalStyleGroup | DeploymentViewRulePredicate | DynamicViewIncludePredicate | ViewRulePredicate | DeploymentView | DynamicView | ViewRuleGroup | ElementView | DeploymentViewRuleStyle | ViewRuleRank | ViewRuleStyle | DynamicViewParallelSteps | DynamicStepChain | DynamicStepSingle | ViewRuleAutoLayout | LinkProperty | ViewStringProperty | SpecificationDeploymentNodeKind | SpecificationElementKind | ExtendDeployment | DeploymentRelation | ExtendElement | ExtendRelation | Relation | SpecificationRule | BorderProperty | ColorProperty | IconProperty | MultipleProperty | OpacityProperty | PaddingSizeProperty | ShapeProperty | ShapeSizeProperty | TextSizeProperty | ElementStyleProperty | SpecificationRelationshipKind | ViewRuleGlobalPredicateRef | ViewRuleGlobalStyle | DynamicViewGlobalPredicateRef | ArrowProperty | LineProperty | DynamicViewDisplayVariantProperty | MetadataBody | ElementStringProperty | MetadataAttribute | NotationProperty | NotesProperty | RelationStringProperty | SpecificationElementStringProperty | SpecificationRelationshipStringProperty | NavigateToProperty | ElementRef | SpecificationTag | SpecificationColor | HexColor | RGBAColor;
type ValidatableAstNode = Guarded<typeof isValidatableAstNode>;
declare function checksFromDiagnostics(doc: LikeC4LangiumDocument): {
    isValid: (n: ValidatableAstNode) => boolean;
    invalidNodes: WeakSet<object>;
};
type ChecksFromDiagnostics = ReturnType<typeof checksFromDiagnostics>;
type IsValidFn = ChecksFromDiagnostics['isValid'];

declare module 'langium' {
    interface LangiumDocument {
        likec4ProjectId?: _likec4_core.ProjectId;
    }
    interface AstNodeDescription {
        likec4ProjectId?: _likec4_core.ProjectId;
    }
}
declare const idattr: unique symbol;
declare module './generated/ast' {
    interface Element {
        [idattr]?: _likec4_core.Fqn | undefined;
    }
    interface ElementView {
        [idattr]?: _likec4_core.ViewId | undefined;
    }
    interface DynamicView {
        [idattr]?: _likec4_core.ViewId | undefined;
    }
    interface DeploymentView {
        [idattr]?: _likec4_core.ViewId | undefined;
    }
    interface DeploymentNode {
        [idattr]?: _likec4_core.Fqn | undefined;
    }
    interface DeployedInstance {
        [idattr]?: _likec4_core.Fqn | undefined;
    }
}
type ParsedElementStyle = {
    shape?: _likec4_core.ElementShape;
    icon?: _likec4_core.IconUrl;
    color?: _likec4_core.Color;
    border?: _likec4_core.BorderStyle;
    opacity?: number;
    multiple?: boolean;
    size?: _likec4_core.ShapeSize;
    padding?: _likec4_core.SpacingSize;
    textSize?: _likec4_core.TextSize;
};
interface ParsedAstSpecification {
    tags: Record<_likec4_core.Tag, {
        astPath: string;
        color?: _likec4_core.ColorLiteral;
    }>;
    elements: Record<_likec4_core.ElementKind, _likec4_core.ElementSpecification>;
    relationships: Record<_likec4_core.RelationshipKind, {
        technology?: string;
        notation?: string;
        color?: _likec4_core.Color;
        line?: _likec4_core.RelationshipLineType;
        head?: _likec4_core.RelationshipArrowType;
        tail?: _likec4_core.RelationshipArrowType;
    }>;
    colors: Record<_likec4_core.CustomColor, {
        color: _likec4_core.ColorLiteral;
    }>;
    deployments: Record<_likec4_core.DeploymentKind, _likec4_core.ElementSpecification>;
}
interface ParsedAstElement {
    id: _likec4_core.Fqn;
    astPath: string;
    kind: _likec4_core.ElementKind;
    title: string;
    summary?: _likec4_core.MarkdownOrString;
    description?: _likec4_core.MarkdownOrString;
    technology?: string;
    tags?: _likec4_core.NonEmptyArray<_likec4_core.Tag>;
    links?: _likec4_core.NonEmptyArray<_likec4_core.Link>;
    style: ParsedElementStyle;
    metadata?: {
        [key: string]: string | string[];
    };
}
interface ParsedAstExtend {
    id: _likec4_core.Fqn;
    astPath: string;
    tags?: _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
    links?: _likec4_core.NonEmptyArray<_likec4_core.Link> | null;
    metadata?: {
        [key: string]: string | string[];
    };
}
interface ParsedAstExtendRelation {
    id: _likec4_core.RelationId;
    astPath: string;
    tags?: _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
    links?: _likec4_core.NonEmptyArray<_likec4_core.Link> | null;
    metadata?: {
        [key: string]: string | string[];
    };
}
interface ParsedAstRelation {
    id: _likec4_core.RelationId;
    astPath: string;
    source: _likec4_core.FqnRef.ModelRef;
    target: _likec4_core.FqnRef.ModelRef;
    kind?: _likec4_core.RelationshipKind;
    tags?: _likec4_core.NonEmptyArray<_likec4_core.Tag>;
    title: string;
    description?: _likec4_core.MarkdownOrString;
    technology?: string;
    color?: _likec4_core.Color;
    line?: _likec4_core.RelationshipLineType;
    head?: _likec4_core.RelationshipArrowType;
    tail?: _likec4_core.RelationshipArrowType;
    links?: _likec4_core.NonEmptyArray<_likec4_core.Link>;
    navigateTo?: _likec4_core.ViewId;
    metadata?: {
        [key: string]: string | string[];
    };
}
type ParsedAstDeployment = Simplify<MergeExclusive<ParsedAstDeployment.Node, ParsedAstDeployment.Instance>>;
declare namespace ParsedAstDeployment {
    type Node = _likec4_core.DeploymentNode;
    type Instance = Omit<_likec4_core.DeployedInstance, 'element'> & {
        readonly element: _likec4_core.FqnRef.ModelRef;
    };
}
type ParsedAstDeploymentRelation = _likec4_core.DeploymentRelationship & {
    astPath: string;
};
type ParsedAstGlobals = Writable<_likec4_core.ModelGlobals>;
interface ParsedAstElementView {
    [_likec4_core._type]: 'element';
    id: _likec4_core.ViewId;
    viewOf?: _likec4_core.Fqn;
    extends?: _likec4_core.ViewId;
    astPath: string;
    title: string | null;
    description: _likec4_core.MarkdownOrString | null;
    tags: _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
    links: _likec4_core.NonEmptyArray<_likec4_core.Link> | null;
    rules: _likec4_core.ElementViewRule[];
    manualLayout?: _likec4_core.ViewManualLayout;
}
interface ParsedAstDynamicView {
    [_likec4_core._type]: 'dynamic';
    id: _likec4_core.ViewId;
    astPath: string;
    title: string | null;
    description: _likec4_core.MarkdownOrString | null;
    tags: _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
    links: _likec4_core.NonEmptyArray<_likec4_core.Link> | null;
    steps: _likec4_core.DynamicViewStep[];
    rules: Array<_likec4_core.DynamicViewRule>;
    variant: _likec4_core.DynamicViewDisplayVariant | undefined;
    manualLayout?: _likec4_core.ViewManualLayout;
}
interface ParsedAstDeploymentView {
    [_likec4_core._type]: 'deployment';
    id: _likec4_core.ViewId;
    astPath: string;
    title: string | null;
    description: _likec4_core.MarkdownOrString | null;
    tags: _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
    links: _likec4_core.NonEmptyArray<_likec4_core.Link> | null;
    rules: Array<_likec4_core.DeploymentViewRule>;
    manualLayout?: _likec4_core.ViewManualLayout;
}
type ParsedAstView = ParsedAstElementView | ParsedAstDynamicView | ParsedAstDeploymentView;
interface AstNodeDescriptionWithFqn extends AstNodeDescription {
    likec4ProjectId: _likec4_core.ProjectId;
    id: _likec4_core.Fqn;
}
type LikeC4AstNode = ValueOf$1<ConditionalPick<LikeC4AstType, AstNode>>;
type LikeC4DocumentDiagnostic = Diagnostic & DiagnosticInfo<LikeC4AstNode>;
interface LikeC4DocumentProps {
    diagnostics?: Array<LikeC4DocumentDiagnostic>;
    c4Specification?: ParsedAstSpecification;
    c4Elements?: ParsedAstElement[];
    c4ExtendElements?: ParsedAstExtend[];
    c4ExtendDeployments?: ParsedAstExtend[];
    c4ExtendRelations?: ParsedAstExtendRelation[];
    c4Relations?: ParsedAstRelation[];
    c4Globals?: ParsedAstGlobals;
    c4Views?: ParsedAstView[];
    c4Deployments?: ParsedAstDeployment[];
    c4DeploymentRelations?: ParsedAstDeploymentRelation[];
    c4Imports?: MultiMap$1<_likec4_core.ProjectId, _likec4_core.Fqn, Set<_likec4_core.Fqn>>;
}
type LikeC4GrammarDocument = Omit<LangiumDocument<LikeC4Grammar>, 'diagnostics'>;
interface LikeC4LangiumDocument extends LikeC4GrammarDocument, LikeC4DocumentProps {
    likec4ProjectId: _likec4_core.ProjectId;
}
interface ParsedLikeC4LangiumDocument extends LikeC4GrammarDocument, Required<LikeC4DocumentProps> {
    likec4ProjectId: _likec4_core.ProjectId;
}

declare class LikeC4NameProvider extends DefaultNameProvider {
    protected services: LikeC4Services;
    constructor(services: LikeC4Services);
    getNameStrict(node: AstNode): string;
    getName(node: AstNode): string | undefined;
    getNameNode(node: AstNode): CstNode | undefined;
}

type ElementsContainer = Model | ElementBody | ExtendElementBody;
type DeploymentsContainer = ModelDeployments | DeploymentNodeBody | ExtendDeploymentBody | DeployedInstanceBody;
declare class LikeC4ScopeComputation extends DefaultScopeComputation {
    constructor(services: LikeC4Services);
    computeExports(document: LikeC4LangiumDocument, _cancelToken?: CancellationToken$1): Promise<AstNodeDescription[]>;
    private exportViews;
    private exportGlobals;
    private exportModel;
    private exportLibrary;
    private exportSpecification;
    private exportDeployments;
    computeLocalScopes(document: LikeC4LangiumDocument, _cancelToken?: CancellationToken$1): Promise<PrecomputedScopes>;
    protected processContainer(container: ElementsContainer, scopes: PrecomputedScopes, document: LikeC4LangiumDocument): AstNodeDescription[];
    protected processDeployments(container: DeploymentsContainer, scopes: PrecomputedScopes, document: LikeC4LangiumDocument): AstNodeDescription[];
}

declare class IndexManager extends DefaultIndexManager {
    protected services: LikeC4SharedServices;
    constructor(services: LikeC4SharedServices);
    updateContent(document: LangiumDocument, cancelToken?: CancellationToken$1): Promise<void>;
    projectElements(projectId: ProjectId, nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;
}

declare class LangiumDocuments extends DefaultLangiumDocuments {
    protected services: LikeC4SharedServices;
    constructor(services: LikeC4SharedServices);
    addDocument(document: LangiumDocument): void;
    getDocument(uri: URI$1): LikeC4LangiumDocument | undefined;
    /**
     * Returns all known documents, without any filtering.
     */
    get allKnownDocuments(): Stream<LangiumDocument>;
    get all(): Stream<LikeC4LangiumDocument>;
    /**
     * Returns all documents, excluding built-in documents and documents excluded by ProjectsManager.
     */
    get allExcludingBuiltin(): Stream<LikeC4LangiumDocument>;
    /**
     * Returns all documents for a project, including both project documents and documents included by the project.
     */
    projectDocuments(projectId: ProjectId): Stream<LikeC4LangiumDocument>;
    groupedByProject(): Record<ProjectId, NonEmptyArray<LikeC4LangiumDocument>>;
    /**
     * Reset the project IDs of all documents.
     */
    resetProjectIds(): void;
}

/**
 * A tagged string that represents a project folder URI
 * Always has trailing slash.
 */
type ProjectFolder = Tagged<string, 'ProjectFolder'>;
declare function ProjectFolder(folder: URI$1 | string): ProjectFolder;
interface ProjectData {
    id: scalar.ProjectId;
    config: LikeC4ProjectConfig;
    folder: ProjectFolder;
    folderUri: URI$1;
    exclude?: picomatch.Matcher;
    /**
     * Resolved include paths with both URI and folder string representations.
     * These are additional directories that are part of this project.
     */
    includePaths?: NonEmptyArray<{
        uri: URI$1;
        folder: ProjectFolder;
    }>;
    /**
     * Normalized include configuration (paths, maxDepth, fileThreshold).
     */
    includeConfig: IncludeConfig;
}
interface Project {
    id: scalar.ProjectId;
    folderUri: URI$1;
    config: LikeC4ProjectConfig;
    /**
     * Resolved include paths as URIs (if configured).
     */
    includePaths?: NonEmptyReadonlyArray<URI$1>;
}
declare class ProjectsManager {
    #private;
    protected services: LikeC4SharedServices;
    /**
     * The global project ID used for all documents
     * that are not part of a specific project.
     */
    static readonly DefaultProjectId: ProjectId$1<string>;
    constructor(services: LikeC4SharedServices);
    /**
     * Returns:
     *  - configured default project ID if set
     *  - the default project ID if there are no projects.
     *  - the ID of the only project
     *  - undefined if there are multiple projects.
     */
    get defaultProjectId(): scalar.ProjectId | undefined;
    set defaultProjectId(id: string | scalar.ProjectId | undefined);
    get default(): ProjectData;
    get all(): NonEmptyReadonlyArray<scalar.ProjectId>;
    getProject(arg: scalar.ProjectId | LangiumDocument): Project;
    /**
     * Returns all projects that include the specified folder, or inside the folder.
     */
    findAllProjectsByFolder(folder: URI$1 | string): ProjectData[];
    /**
     * Validates and ensures the project ID.
     * If no project ID is specified, returns default project ID
     * If there are multiple projects and default project is not set, throws an error
     */
    ensureProjectId(projectId?: scalar.ProjectId | undefined): scalar.ProjectId;
    /**
     * Validates and ensures the project.
     */
    ensureProject(projectId?: scalar.ProjectId | undefined): Project;
    hasMultipleProjects(): boolean;
    /**
     * Checks if the specified document should be excluded from processing.
     */
    isExcluded(document: LangiumDocument | URI$1 | string): boolean;
    /**
     * Checks if the specified document is included by the project:
     * - if the document belongs to the project and is not excluded
     * - if the document is included by the project
     */
    isIncluded(projectId: ProjectId$1, document: LangiumDocument | URI$1 | string): boolean;
    /**
     * Checks if it is a config file and it is not excluded by default exclude pattern
     *
     * @param entry The file system entry to check
     */
    isConfigFile(entry: URI$1): boolean;
    /**
     * Registers likec4 project by config file.
     */
    registerConfigFile(configFile: URI$1, cancelToken?: CancellationToken$1): Promise<ProjectData>;
    /**
     * Registers (or reloads) likec4 project by config file or config object.
     * If there is some project registered at same folder, it will be reloaded.
     */
    registerProject(opts: {
        config: LikeC4ProjectConfig | LikeC4ProjectConfigInput;
        folderUri: URI$1 | string;
    }, cancelToken?: CancellationToken$1): Promise<ProjectData>;
    /**
     * Determines which project the given document belongs to.
     * If the document does not belong to any project, returns the default project ID.
     */
    belongsTo(document: LangiumDocument | URI$1 | string): scalar.ProjectId;
    reloadProjects(cancelToken?: CancellationToken$1): Promise<void>;
    protected _reloadProjects(cancelToken?: CancellationToken$1): Promise<void>;
    protected uniqueProjectId(name: string): scalar.ProjectId;
    protected reset(): void;
    rebuidProject(projectId: ProjectId$1, cancelToken?: CancellationToken$1): Promise<void>;
    protected findProjectForDocument(documentUri: string): ProjectData;
    protected get mappingsToProject(): WorkspaceCache<string, ProjectData>;
    /**
     * The mapping between documents and projects they belong to.
     * Lazy-created due to initialization order of the LanguageServer
     */
    protected get documentBelongsTo(): WorkspaceCache<LangiumDocument, ProjectData>;
    /**
     * Returns all include paths from all projects.
     * Used by WorkspaceManager to scan additional directories for C4 files.
     */
    getAllIncludePaths(): Array<{
        projectId: scalar.ProjectId;
        includePath: URI$1;
        includeConfig: IncludeConfig;
    }>;
    private getWorkspaceFolder;
}

declare class LikeC4WorkspaceManager extends DefaultWorkspaceManager {
    private services;
    protected readonly documentFactory: LangiumDocumentFactory;
    protected readonly fileSystemProvider: FileSystemProvider;
    initialBuildOptions: BuildOptions;
    constructor(services: LikeC4SharedServices);
    /**
     * First load all project config files, then load all documents in the workspace.
     */
    protected performStartup(folders: WorkspaceFolder[]): Promise<LangiumDocument[]>;
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    protected loadAdditionalDocuments(folders: WorkspaceFolder[], collector: (document: LangiumDocument) => void): Promise<void>;
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, selector: FileSelector): boolean;
    workspace(): WorkspaceFolder | null;
    rebuildAll(cancelToken?: CancellationToken$1): Promise<void>;
    get workspaceUri(): URI$1;
    get workspaceURL(): URL;
}

declare class LikeC4ScopeProvider extends DefaultScopeProvider {
    protected deploymentsIndex: DeploymentsIndex;
    protected fqnIndex: FqnIndex;
    protected readonly indexManager: IndexManager;
    constructor(services: LikeC4Services);
    getScope(context: ReferenceInfo): Scope;
    protected genUniqueDescedants(element: Element | DeploymentNode | undefined): Generator<AstNodeDescriptionWithFqn, void, any>;
    protected genScopeExtendElement({ element }: ExtendElement): Generator<AstNodeDescription>;
    protected genScopeElementView({ viewOf, extends: ext }: ElementView): Generator<AstNodeDescription>;
    protected getScopeForStrictFqnRef(projectId: ProjectId, container: StrictFqnRef, context: ReferenceInfo): Scope;
    protected genScopeExtendDeployment({ deploymentNode }: ExtendDeployment): Generator<AstNodeDescription>;
    protected streamForFqnRef(projectId: ProjectId, container: FqnRef, context: ReferenceInfo): Stream<AstNodeDescription>;
    protected genScopeForParentlessFqnRef(projectId: ProjectId, container: FqnRef, context: ReferenceInfo): Generator<AstNodeDescription>;
    /**
     * Computes the scope for a given reference context.
     *
     * @param context - The reference information containing the context for which the scope is being computed.
     * @param referenceType - The type of reference being resolved. Defaults to the reference type derived from the context.
     * @returns A scope containing the relevant AST node descriptions for the given reference context.
     *
     * This method first checks if there are precomputed scopes available in the document. If not, it falls back to the global scope.
     * It then iterates through the container hierarchy, collecting relevant scopes based on the reference type and container type.
     * Finally, it combines the collected scopes with the global scope to produce the final scope.
     */
    protected computeScope(projectId: ProjectId, context: ReferenceInfo, referenceType?: string): Generator<AstNodeDescription>;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getProjectScope(projectId: ProjectId, referenceType: string, context: ReferenceInfo): Scope;
    /**
     * Create a global scope filtered for the given reference type.
     */
    protected getGlobalScope(referenceType: string, context: ReferenceInfo): Scope;
}

declare abstract class ADisposable implements Disposable$1 {
    protected toDispose: Disposable$1[];
    protected isDisposed: boolean;
    onDispose(...disposable: Disposable$1[]): void;
    dispose(): void;
    protected throwIfDisposed(): void;
}

declare class FqnIndex<AstNd = Element> extends ADisposable {
    protected services: LikeC4Services;
    protected projects: ProjectsManager;
    protected langiumDocuments: LangiumDocuments;
    protected documentCache: DefaultWeakMap<LikeC4LangiumDocument, DocumentFqnIndex>;
    protected workspaceCache: WorkspaceCache<string, AstNodeDescriptionWithFqn[]>;
    constructor(services: LikeC4Services);
    private documents;
    get(document: LikeC4LangiumDocument): DocumentFqnIndex;
    resolve(reference: Referenceable): Fqn$1;
    getFqn(el: AstNd): Fqn$1;
    byFqn(projectId: ProjectId$1, fqn: Fqn$1): Stream<AstNodeDescriptionWithFqn>;
    rootElements(projectId: ProjectId$1): Stream<AstNodeDescriptionWithFqn>;
    directChildrenOf(projectId: ProjectId$1, parent: Fqn$1): Stream<AstNodeDescriptionWithFqn>;
    /**
     * Returns descedant elements with unique names in the scope
     */
    uniqueDescedants(projectId: ProjectId$1, parent: Fqn$1): Stream<AstNodeDescriptionWithFqn>;
    protected createDocumentIndex(document: LikeC4LangiumDocument): DocumentFqnIndex;
}
declare class DocumentFqnIndex {
    private _rootElements;
    /**
     * direct children of elements
     */
    private _children;
    /**
     * All descendants of an element (unique by name)
     */
    private _descendants;
    /**
     * All elements by FQN
     */
    private _byfqn;
    readonly projectId: ProjectId$1;
    static readonly EMPTY: DocumentFqnIndex;
    constructor(_rootElements: Array<AstNodeDescriptionWithFqn>, 
    /**
     * direct children of elements
     */
    _children: MultiMap$1<Fqn$1, AstNodeDescriptionWithFqn>, 
    /**
     * All descendants of an element (unique by name)
     */
    _descendants: MultiMap$1<Fqn$1, AstNodeDescriptionWithFqn>, 
    /**
     * All elements by FQN
     */
    _byfqn: MultiMap$1<Fqn$1, AstNodeDescriptionWithFqn>, projectId: ProjectId$1);
    rootElements(): readonly AstNodeDescriptionWithFqn[];
    byFqn(fqn: Fqn$1): readonly AstNodeDescriptionWithFqn[];
    children(parent: Fqn$1): readonly AstNodeDescriptionWithFqn[];
    descendants(nodeName: Fqn$1): readonly AstNodeDescriptionWithFqn[];
}

declare class DeploymentsIndex extends FqnIndex<DeploymentElement> {
    protected services: LikeC4Services;
    protected Names: LikeC4NameProvider;
    constructor(services: LikeC4Services);
    protected createDocumentIndex(document: LikeC4LangiumDocument): DocumentFqnIndex;
}

type ModelParsedListener = (docs: URI$1[]) => void;
interface LikeC4ModelBuilder extends Disposable$1 {
    parseModel(projectId?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<LikeC4Model<UnknownParsed> | null>;
    unsafeSyncComputeModel(projectId: ProjectId): LikeC4Model<UnknownComputed>;
    computeModel(projectId?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<LikeC4Model<UnknownComputed>>;
    onModelParsed(callback: ModelParsedListener): Disposable$1;
    clearCache(): void;
}

type ViewLocateResult = {
    doc: ParsedLikeC4LangiumDocument;
    view: ParsedAstView;
    viewAst: LikeC4View;
};
declare class LikeC4ModelLocator {
    private services;
    private fqnIndex;
    private deploymentsIndex;
    private langiumDocuments;
    private parser;
    private projects;
    constructor(services: LikeC4Services);
    private documents;
    getParsedElement(...args: [Element] | [_likec4_core.Fqn] | [_likec4_core.Fqn, _likec4_core.ProjectId]): ParsedAstElement | null;
    locateElement(fqn: _likec4_core.Fqn, projectId?: _likec4_core.ProjectId | undefined): Location | null;
    locateDeploymentElement(deploymentFqn: _likec4_core.DeploymentFqn, projectId?: _likec4_core.ProjectId | undefined): Location | null;
    locateRelation(relationId: _likec4_core.RelationId, projectId?: _likec4_core.ProjectId): Location | null;
    locateViewAst(viewId: _likec4_core.ViewId, projectId?: _likec4_core.ProjectId | undefined): null | ViewLocateResult;
    locateView(viewId: _likec4_core.ViewId, projectId?: _likec4_core.ProjectId): Location | null;
    locateDocumentTags(documentUri: URI$1, cancelToken?: CancellationToken$1): Promise<Array<{
        name: string;
        color: string;
        range: Range$1;
        isSpecification: boolean;
    }>>;
    locateDynamicViewStep(params: {
        view: _likec4_core.ViewId;
        astPath: string;
        projectId?: _likec4_core.ProjectId | undefined;
    }): Location | null;
}

declare class BaseParser {
    readonly services: LikeC4Services;
    readonly doc: ParsedLikeC4LangiumDocument;
    isValid: IsValidFn;
    constructor(services: LikeC4Services, doc: ParsedLikeC4LangiumDocument);
    get project(): Project;
    resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
    getAstNodePath(node: AstNode): string;
    getMetadata(metadataAstNode: MetadataProperty | undefined): {
        [key: string]: string | string[];
    } | undefined;
    parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
    convertTags<E extends {
        tags?: Tags;
    }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
    parseTags<E extends {
        tags?: Tags;
    }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
    convertLinks(source?: LinkProperty['$container']): _likec4_core.Link[] | undefined;
    parseLinks(source?: LinkProperty['$container']): _likec4_core.Link[] | undefined;
    parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
    parseImageAlias(value: string): string | undefined;
    parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
    parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
    parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
    /**
     * Parse base properties: title, description and technology
     *
     * @param props - body properties (inside '{...}')
     * @param override - optional, inline properties (right on the node)
     *                   have higher priority and override body properties
     */
    parseBaseProps(props: {
        title?: MarkdownOrString | undefined;
        summary?: MarkdownOrString | undefined;
        description?: MarkdownOrString | undefined;
        technology?: MarkdownOrString | undefined;
    }, override?: {
        title?: string | undefined;
        summary?: string | undefined;
        description?: string | undefined;
        technology?: string | undefined;
    }): {
        title?: string;
        summary?: _likec4_core.MarkdownOrString;
        description?: _likec4_core.MarkdownOrString;
        technology?: string;
    };
}

declare const DocumentParserFromMixins: {
    new (...args: any[]): {
        parseGlobals(): void;
        parseAndStoreGlobalPredicateGroupOrDynamic(astRule: GlobalPredicateGroup | GlobalDynamicPredicateGroup, id: _likec4_core.GlobalPredicateId, c4Globals: ParsedAstGlobals): void;
        parseGlobalPredicateGroup(astRule: GlobalPredicateGroup): _likec4_core.ElementViewPredicate[];
        parseGlobalDynamicPredicateGroup(astRule: GlobalDynamicPredicateGroup): _likec4_core.DynamicViewIncludeRule[];
        parseGlobalStyleOrGroup(astRule: GlobalStyle | GlobalStyleGroup): _likec4_core.ElementViewRuleStyle[];
        parseViews(): void;
        parseElementView(astNode: ElementView, additionalStyles: (_likec4_core.ElementViewRuleStyle<_likec4_core.Any> | _likec4_core.ViewRuleGlobalStyle)[]): ParsedAstElementView;
        parseElementViewRule(astRule: ViewRule): _likec4_core.ElementViewRule;
        parseViewRulePredicate(astNode: ViewRulePredicate): _likec4_core.ElementViewPredicate;
        parseViewRuleGlobalPredicateRef(astRule: ViewRuleGlobalPredicateRef | DynamicViewGlobalPredicateRef): _likec4_core.ViewRuleGlobalPredicateRef;
        parseViewRuleStyleOrGlobalRef(astRule: ViewRuleStyleOrGlobalRef): _likec4_core.ElementViewRuleStyle<_likec4_core.Any> | _likec4_core.ViewRuleGlobalStyle;
        parseViewRuleGroup(astNode: ViewRuleGroup): _likec4_core.ElementViewRuleGroup;
        parseViewRuleRank(astRule: ViewRuleRank): _likec4_core.ElementViewRuleRank;
        parseViewRuleStyle(astRule: ViewRuleStyle | GlobalStyle): _likec4_core.ElementViewRuleStyle;
        parseViewRuleGlobalStyle(astRule: ViewRuleGlobalStyle): _likec4_core.ViewRuleGlobalStyle;
        parseDynamicElementView(astNode: DynamicView, additionalStyles: (_likec4_core.ElementViewRuleStyle<_likec4_core.Any> | _likec4_core.ViewRuleGlobalStyle)[]): ParsedAstDynamicView;
        parseDynamicViewRule(astRule: DynamicViewRule): _likec4_core.DynamicViewRule;
        parseDynamicViewIncludePredicate(astRule: DynamicViewIncludePredicate): _likec4_core.DynamicViewIncludeRule;
        parseDynamicParallelSteps(node: DynamicViewParallelSteps): _likec4_core.DynamicStepsParallel;
        parseDynamicStep(node: DynamicViewStep): _likec4_core.DynamicStep | _likec4_core.DynamicStepsSeries;
        recursiveParseDynamicStepChain(node: DynamicStepChain, callstack?: Array<[source: _likec4_core.Fqn, target: _likec4_core.Fqn]>): _likec4_core.DynamicStep[];
        parseDynamicStepSingle(node: DynamicStepSingle): _likec4_core.DynamicStep;
        parseAbstractDynamicStep(astnode: AbstractDynamicStep): type_fest.Writable<type_fest.Except<_likec4_core.DynamicStep, "source", {
            requireExactProps: true;
        }>>;
        parsePredicate(astNode: ExpressionV2): _likec4_core.ModelExpression;
        parseElementPredicate(astNode: FqnExprOrWith): _likec4_core.ModelFqnExpr.Any;
        parseElementPredicateOrWhere(astNode: FqnExprOrWhere): _likec4_core.ModelFqnExpr.OrWhere;
        parseElementExpression(astNode: FqnExpr): _likec4_core.ModelFqnExpr;
        parseElementPredicateWhere(astNode: FqnExprWhere): _likec4_core.ModelFqnExpr.Where;
        parseElementPredicateWith(astNode: FqnExprWith): _likec4_core.ModelFqnExpr.Custom;
        parseRelationPredicate(astNode: RelationExprOrWith): _likec4_core.ModelRelationExpr.Any;
        parseRelationPredicateOrWhere(astNode: RelationExprOrWhere): _likec4_core.ModelRelationExpr.OrWhere;
        parseRelationPredicateWhere(astNode: RelationExprWhere): _likec4_core.ModelRelationExpr.Where;
        parseRelationPredicateWith(astNode: RelationExprWith): _likec4_core.ModelRelationExpr.Custom;
        parseRelationExpression(astNode: RelationExpr): _likec4_core.ModelRelationExpr;
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
        parseDeploymentView(astNode: DeploymentView): ParsedAstDeploymentView;
        parseDeploymentViewRule(astRule: DeploymentViewRule): _likec4_core.DeploymentViewRule;
        parseDeploymentViewRulePredicate(astRule: DeploymentViewRulePredicate): _likec4_core.DeploymentViewPredicate;
        parseDeploymentViewRuleStyle(astRule: DeploymentViewRuleStyle): _likec4_core.DeploymentViewRuleStyle;
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): _likec4_core.FqnRef;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
    };
} & {
    new (...args: any[]): {
        parseViews(): void;
        parseElementView(astNode: ElementView, additionalStyles: (_likec4_core.ElementViewRuleStyle<_likec4_core.Any> | _likec4_core.ViewRuleGlobalStyle)[]): ParsedAstElementView;
        parseElementViewRule(astRule: ViewRule): _likec4_core.ElementViewRule;
        parseViewRulePredicate(astNode: ViewRulePredicate): _likec4_core.ElementViewPredicate;
        parseViewRuleGlobalPredicateRef(astRule: ViewRuleGlobalPredicateRef | DynamicViewGlobalPredicateRef): _likec4_core.ViewRuleGlobalPredicateRef;
        parseViewRuleStyleOrGlobalRef(astRule: ViewRuleStyleOrGlobalRef): _likec4_core.ElementViewRuleStyle<_likec4_core.Any> | _likec4_core.ViewRuleGlobalStyle;
        parseViewRuleGroup(astNode: ViewRuleGroup): _likec4_core.ElementViewRuleGroup;
        parseViewRuleRank(astRule: ViewRuleRank): _likec4_core.ElementViewRuleRank;
        parseViewRuleStyle(astRule: ViewRuleStyle | GlobalStyle): _likec4_core.ElementViewRuleStyle;
        parseViewRuleGlobalStyle(astRule: ViewRuleGlobalStyle): _likec4_core.ViewRuleGlobalStyle;
        parseDynamicElementView(astNode: DynamicView, additionalStyles: (_likec4_core.ElementViewRuleStyle<_likec4_core.Any> | _likec4_core.ViewRuleGlobalStyle)[]): ParsedAstDynamicView;
        parseDynamicViewRule(astRule: DynamicViewRule): _likec4_core.DynamicViewRule;
        parseDynamicViewIncludePredicate(astRule: DynamicViewIncludePredicate): _likec4_core.DynamicViewIncludeRule;
        parseDynamicParallelSteps(node: DynamicViewParallelSteps): _likec4_core.DynamicStepsParallel;
        parseDynamicStep(node: DynamicViewStep): _likec4_core.DynamicStep | _likec4_core.DynamicStepsSeries;
        recursiveParseDynamicStepChain(node: DynamicStepChain, callstack?: Array<[source: _likec4_core.Fqn, target: _likec4_core.Fqn]>): _likec4_core.DynamicStep[];
        parseDynamicStepSingle(node: DynamicStepSingle): _likec4_core.DynamicStep;
        parseAbstractDynamicStep(astnode: AbstractDynamicStep): type_fest.Writable<type_fest.Except<_likec4_core.DynamicStep, "source", {
            requireExactProps: true;
        }>>;
        parsePredicate(astNode: ExpressionV2): _likec4_core.ModelExpression;
        parseElementPredicate(astNode: FqnExprOrWith): _likec4_core.ModelFqnExpr.Any;
        parseElementPredicateOrWhere(astNode: FqnExprOrWhere): _likec4_core.ModelFqnExpr.OrWhere;
        parseElementExpression(astNode: FqnExpr): _likec4_core.ModelFqnExpr;
        parseElementPredicateWhere(astNode: FqnExprWhere): _likec4_core.ModelFqnExpr.Where;
        parseElementPredicateWith(astNode: FqnExprWith): _likec4_core.ModelFqnExpr.Custom;
        parseRelationPredicate(astNode: RelationExprOrWith): _likec4_core.ModelRelationExpr.Any;
        parseRelationPredicateOrWhere(astNode: RelationExprOrWhere): _likec4_core.ModelRelationExpr.OrWhere;
        parseRelationPredicateWhere(astNode: RelationExprWhere): _likec4_core.ModelRelationExpr.Where;
        parseRelationPredicateWith(astNode: RelationExprWith): _likec4_core.ModelRelationExpr.Custom;
        parseRelationExpression(astNode: RelationExpr): _likec4_core.ModelRelationExpr;
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
        parseDeploymentView(astNode: DeploymentView): ParsedAstDeploymentView;
        parseDeploymentViewRule(astRule: DeploymentViewRule): _likec4_core.DeploymentViewRule;
        parseDeploymentViewRulePredicate(astRule: DeploymentViewRulePredicate): _likec4_core.DeploymentViewPredicate;
        parseDeploymentViewRuleStyle(astRule: DeploymentViewRuleStyle): _likec4_core.DeploymentViewRuleStyle;
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): _likec4_core.FqnRef;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
    };
} & {
    new (...args: any[]): {
        parseSpecification(): void;
        parseElementSpecificationNode(specAst: SpecificationElementKind): {
            [key: _likec4_core.ElementKind<string>]: _likec4_core.ElementSpecification;
        };
        parseElementSpecificationNode(specAst: SpecificationDeploymentNodeKind): {
            [key: _likec4_core.DeploymentKind<string>]: _likec4_core.ElementSpecification;
        };
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
    };
} & {
    new (...args: any[]): {
        parsePredicate(astNode: ExpressionV2): _likec4_core.ModelExpression;
        parseElementPredicate(astNode: FqnExprOrWith): _likec4_core.ModelFqnExpr.Any;
        parseElementPredicateOrWhere(astNode: FqnExprOrWhere): _likec4_core.ModelFqnExpr.OrWhere;
        parseElementExpression(astNode: FqnExpr): _likec4_core.ModelFqnExpr;
        parseElementPredicateWhere(astNode: FqnExprWhere): _likec4_core.ModelFqnExpr.Where;
        parseElementPredicateWith(astNode: FqnExprWith): _likec4_core.ModelFqnExpr.Custom;
        parseRelationPredicate(astNode: RelationExprOrWith): _likec4_core.ModelRelationExpr.Any;
        parseRelationPredicateOrWhere(astNode: RelationExprOrWhere): _likec4_core.ModelRelationExpr.OrWhere;
        parseRelationPredicateWhere(astNode: RelationExprWhere): _likec4_core.ModelRelationExpr.Where;
        parseRelationPredicateWith(astNode: RelationExprWith): _likec4_core.ModelRelationExpr.Custom;
        parseRelationExpression(astNode: RelationExpr): _likec4_core.ModelRelationExpr;
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
    };
} & {
    new (...args: any[]): {
        parseDeploymentView(astNode: DeploymentView): ParsedAstDeploymentView;
        parseDeploymentViewRule(astRule: DeploymentViewRule): _likec4_core.DeploymentViewRule;
        parseDeploymentViewRulePredicate(astRule: DeploymentViewRulePredicate): _likec4_core.DeploymentViewPredicate;
        parseDeploymentViewRuleStyle(astRule: DeploymentViewRuleStyle): _likec4_core.DeploymentViewRuleStyle;
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): _likec4_core.FqnRef;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
    };
} & {
    new (...args: any[]): {
        parseDeployment(): void;
        parseDeploymentNode(astNode: DeploymentNode): ParsedAstDeployment.Node;
        parseDeployedInstance(astNode: DeployedInstance): ParsedAstDeployment.Instance;
        parseExtendDeployment(astNode: ExtendDeployment): ParsedAstExtend | null;
        _resolveDeploymentRelationSource(node: DeploymentRelation): _likec4_core.FqnRef;
        parseDeploymentRelation(astNode: DeploymentRelation): ParsedAstDeploymentRelation;
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
    };
} & {
    new (...args: any[]): {
        parseModel(): void;
        parseElement(astNode: Element): ParsedAstElement;
        parseExtendElement(astNode: ExtendElement): ParsedAstExtend | null;
        parseExtendRelation(astNode: ExtendRelation): ParsedAstExtendRelation | null;
        _resolveRelationSource(node: Relation): _likec4_core.FqnRef.ModelRef | _likec4_core.FqnRef.ImportRef;
        parseRelation(astNode: Relation): ParsedAstRelation;
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
    };
} & {
    new (...args: any[]): {
        parseImports(): void;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
    };
} & {
    new (...args: any[]): {
        parseFqnRef(astNode: FqnRef): _likec4_core.FqnRef;
        parseExpressionV2(astNode: ExpressionV2): _likec4_core.Expression;
        parseFqnExprOrWith(astNode: FqnExprOrWith): _likec4_core.FqnExpr.Any;
        parseFqnExprWith(astNode: FqnExprWith): _likec4_core.FqnExpr.Custom;
        parseFqnExprOrWhere(astNode: FqnExprOrWhere): _likec4_core.FqnExpr.OrWhere;
        parseFqnExprWhere(astNode: FqnExprWhere): _likec4_core.FqnExpr.Where;
        parseFqnExpr(astNode: FqnExpr): _likec4_core.FqnExpr;
        parseFqnRefExpr(astNode: FqnRefExpr): _likec4_core.FqnExpr.NonWildcard;
        parseFqnExpressions(astNode: FqnExpressions): _likec4_core.FqnExpr[];
        parseRelationExprOrWith(astNode: RelationExprOrWith): _likec4_core.RelationExpr.Any;
        parseRelationExprWith(astNode: RelationExprWith): _likec4_core.RelationExpr.Custom;
        parseCustomRelationProperties(custom: CustomRelationProperties | undefined): type_fest.Except<_likec4_core.RelationExpr.Custom["customRelation"], "expr">;
        parseRelationExprOrWhere(astNode: RelationExprOrWhere): _likec4_core.RelationExpr.OrWhere;
        parseRelationExprWhere(astNode: RelationExprWhere): _likec4_core.RelationExpr.Where;
        parseRelationExpr(astNode: RelationExpr): _likec4_core.RelationExpr.OrWhere;
        parseInlineKindCondition(astNode: OutgoingRelationExpr): _likec4_core.WhereOperator | null;
        wrapInWhere(expr: _likec4_core.RelationExpr, condition: _likec4_core.WhereOperator | null): _likec4_core.RelationExpr.OrWhere;
        isValid: IsValidFn;
        readonly services: LikeC4Services;
        readonly doc: ParsedLikeC4LangiumDocument;
        get project(): Project;
        resolveFqn(node: FqnReferenceable): _likec4_core.Fqn;
        getAstNodePath(node: AstNode): string;
        getMetadata(metadataAstNode: MetadataProperty | undefined): {
            [key: string]: string | string[];
        } | undefined;
        parseMarkdownOrString(markdownOrString: MarkdownOrString | undefined): _likec4_core.MarkdownOrString | undefined;
        convertTags<E extends {
            tags?: Tags;
        }>(withTags?: E | undefined): _likec4_core.NonEmptyArray<_likec4_core.Tag<string>> | null;
        parseTags<E extends {
            tags?: Tags;
        }>(withTags?: E): _likec4_core.NonEmptyArray<_likec4_core.Tag> | null;
        convertLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseLinks(source?: LinkProperty["$container"]): _likec4_core.Link[] | undefined;
        parseIconProperty(prop: IconProperty | undefined): _likec4_core.IconUrl | undefined;
        parseImageAlias(value: string): string | undefined;
        parseColorLiteral(astNode: ColorLiteral): _likec4_core.ColorLiteral | undefined;
        parseElementStyle(elementProps: Array<ElementProperty> | ElementStyleProperty | undefined): ParsedElementStyle;
        parseStyleProps(styleProps: Array<StyleProperty> | undefined): ParsedElementStyle;
        parseBaseProps(props: {
            title?: MarkdownOrString | undefined;
            summary?: MarkdownOrString | undefined;
            description?: MarkdownOrString | undefined;
            technology?: MarkdownOrString | undefined;
        }, override?: {
            title?: string | undefined;
            summary?: string | undefined;
            description?: string | undefined;
            technology?: string | undefined;
        }): {
            title?: string;
            summary?: _likec4_core.MarkdownOrString;
            description?: _likec4_core.MarkdownOrString;
            technology?: string;
        };
    };
} & typeof BaseParser;
declare class DocumentParser extends DocumentParserFromMixins {
}
declare class LikeC4ModelParser {
    private services;
    protected cachedParsers: DefaultWeakMap<LangiumDocument<AstNode>, DocumentParser>;
    constructor(services: LikeC4Services);
    documents(projectId: ProjectId): Stream<ParsedLikeC4LangiumDocument>;
    parse(doc: LangiumDocument): ParsedLikeC4LangiumDocument;
    forDocument(doc: LangiumDocument): DocumentParser;
    private createParser;
}

declare class LikeC4ValueConverter extends DefaultValueConverter {
    protected runConverter(rule: any, input: string, cstNode: CstNode): ValueType;
}

/**
 * When server requests to open a likec4 preview panel
 * (available only in the editor).
 * (not the best place, but seems to be working)
 */
declare namespace DidRequestOpenViewNotification {
    type Params = {
        viewId: ViewId;
        projectId: ProjectId;
    };
    const type: NotificationType<Params>;
    type Type = typeof type;
}
/**
 * Request to locate an element, relation, deployment or view.
 * If LSP has multiple projects, the projectId is required.
 */
declare namespace Locate {
    type Params = 
    /**
     * Locate an element by its fqn
     */
    {
        element: Fqn;
        projectId?: string | undefined;
        property?: string;
    }
    /**
     * Locate a relation by its id
     */
     | {
        projectId?: string | undefined;
        relation: RelationId;
    }
    /**
     * Locate a deployment by its fqn
     */
     | {
        deployment: DeploymentFqn;
        projectId?: string | undefined;
        property?: string;
    }
    /**
     * Locate a step in a dynamic view by its astPath
     */
     | {
        view: ViewId;
        astPath: string;
        projectId?: string | undefined;
    }
    /**
     * Locate a view by its id
     */
     | {
        view: ViewId;
        projectId?: string | undefined;
    };
    type Res = Location | null;
    const req: RequestType<Params, Res, void>;
    type Req = typeof req;
}
/**
 * Request to change the view
 * If LSP has multiple projects, the projectId is required.
 */
declare namespace ChangeView {
    type Params = {
        viewId: ViewId;
        change: ViewChange;
        projectId?: string | undefined;
    };
    type Res = {
        success: true;
        location: Location | null;
    } | {
        success: false;
        location?: Location | null;
        error: string;
    };
    const req: RequestType<Params, Res, void>;
    type Req = typeof req;
}

declare class LikeC4ModelChanges {
    private services;
    private locator;
    constructor(services: LikeC4Services);
    applyChange(changeView: ChangeView.Params): Promise<ChangeView.Res>;
    protected convertToTextEdit({ lookup, change }: {
        lookup: ViewLocateResult;
        change: Exclude<ViewChange, ViewChange.SaveViewSnapshot | ViewChange.ResetManualLayout>;
    }): {
        modifiedRange: Range$1;
        edits: TextEdit$1[];
    };
}

type GraphvizOut = {
    readonly dot: string;
    readonly diagram: LayoutedView;
};
type GraphvizSvgOut = {
    readonly id: ViewId;
    readonly dot: string;
    readonly svg: string;
};
type LayoutViewParams = {
    viewId: ViewId;
    /**
     * Type of layout to apply
     * - 'manual' - applies manual layout if any
     * - 'auto' - returns latest version with drifts from manual layout if any
     * - undefined - returns latest layout as is
     */
    layoutType?: LayoutType | undefined;
    projectId?: ProjectId | undefined;
    cancelToken?: CancellationToken$1 | undefined;
};
interface LikeC4Views {
    readonly layouter: GraphvizLayouter;
    /**
     * Returns computed views (i.e. views with predicates computed)
     */
    computedViews(projectId?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<ComputedView[]>;
    /**
     * Layouts all views (ignoring any manual snapshots)
     */
    layoutAllViews(projectId?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<GraphvizOut[]>;
    /**
     * Layouts a view.
     * If layoutType is 'manual' - applies manual layout if any.
     * If layoutType is 'auto' - returns latest version with drifts from manual layout if any
     * If not specified - returns latest layout as is
     *
     * If view not found in model, but there is a snapshot - it will be returned (with empty DOT)
     */
    layoutView(params: LayoutViewParams): Promise<GraphvizOut | null>;
    /**
     * Returns diagrams.
     * If diagram has manual layout, it will be used.
     */
    diagrams(projectId?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<Array<DiagramView>>;
    /**
     * Returns all layouted views as Graphviz output (i.e. views with layout computed)
     */
    viewsAsGraphvizOut(projectId?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<Array<GraphvizSvgOut>>;
    /**
     * Open view in the preview panel.
     * (works only if running as a vscode extension)
     */
    openView(viewId: ViewId, projectId?: ProjectId | undefined): Promise<void>;
}

interface LikeC4LanguageServices {
    readonly views: LikeC4Views;
    readonly builder: LikeC4ModelBuilder;
    readonly workspaceUri: URI$1;
    readonly projectsManager: ProjectsManager;
    readonly editor: LikeC4ModelChanges;
    /**
     * Returns all projects with relevant documents
     */
    projects(): NonEmptyArray<{
        id: ProjectId;
        folder: URI$1;
        title: string;
        documents: ReadonlyArray<URI$1>;
        config: Readonly<LikeC4ProjectConfig>;
    }>;
    /**
     * Returns project by ID, returns default project if no ID is specified
     */
    project(projectId?: ProjectId): {
        id: ProjectId;
        folder: URI$1;
        title: string;
        documents: ReadonlyArray<URI$1>;
        config: Readonly<LikeC4ProjectConfig>;
    };
    /**
     * Computes and layouts projects overview - a special diagram
     * that shows all projects and their relationships
     */
    projectsOverview(cancelToken?: CancellationToken$1): Promise<LayoutedProjectsView>;
    /**
     * Returns {@link LikeC4Model} of the specified project, with computed views {@link ComputedView}
     * Not ready for rendering, but enough to traverse model. Much faster than {@link layoutedModel}
     *
     * If no {@link project} is specified, returns for default project
     */
    computedModel(project?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<LikeC4Model<UnknownComputed>>;
    /**
     * Returns {@link LikeC4Model} of the specified project, with layouted views {@link LayoutedView}
     * Ready for rendering. Applies manual layouts if available.
     *
     * If no {@link project} is specified, returns for default project
     */
    layoutedModel(project?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<LikeC4Model<UnknownLayouted>>;
    /**
     * Returns diagrams (i.e. layouted views {@link LayoutedView}) for the specified project
     * Applies manual layouts if available.
     *
     * If no {@link project} is specified, returns diagrams for default project
     */
    diagrams(project?: ProjectId | undefined, cancelToken?: CancellationToken$1): Promise<LayoutedView[]>;
    getErrors(): Array<{
        message: string;
        line: number;
        range: Range$1;
        sourceFsPath: string;
    }>;
    /**
     * Returns the location of the specified element, relation, view or deployment element
     */
    locate(params: Locate.Params): Locate.Res;
    dispose(): Promise<void>;
}

declare class LikeC4CodeLensProvider implements CodeLensProvider {
    private services;
    constructor(services: LikeC4Services);
    provideCodeLens(doc: LangiumDocument, _params: CodeLensParams, cancelToken?: CancellationToken$1): Promise<CodeLens[] | undefined>;
}

declare class LikeC4CompletionProvider extends DefaultCompletionProvider {
    protected services: LikeC4Services;
    constructor(services: LikeC4Services);
    readonly completionOptions: {
        triggerCharacters: string[];
    };
    protected completionFor(context: CompletionContext, next: NextFeature, acceptor: CompletionAcceptor): MaybePromise<void>;
    protected completionForKeyword(context: CompletionContext, keyword: Keyword, acceptor: CompletionAcceptor): MaybePromise<void>;
    protected completionForImportedProject(context: CompletionContext, acceptor: CompletionAcceptor): void;
}

declare class LikeC4DocumentHighlightProvider extends DefaultDocumentHighlightProvider {
    /**
     * Override this method to determine the highlight kind of the given reference.
     */
    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight;
}

declare class LikeC4DocumentLinkProvider implements DocumentLinkProvider {
    private services;
    constructor(services: LikeC4Services);
    getDocumentLinks(doc: LangiumDocument, _params: DocumentLinkParams, _cancelToken?: CancellationToken$1): Promise<DocumentLink[]>;
    resolveLink(doc: LangiumDocument, link: string): string;
    relativeLink(doc: LangiumDocument, link: string): string | null;
}

declare class LikeC4DocumentSymbolProvider implements DocumentSymbolProvider {
    private services;
    protected readonly nodeKindProvider: NodeKindProvider$1;
    protected readonly nameProvider: LikeC4NameProvider;
    protected readonly parser: LikeC4ModelParser;
    protected readonly locator: LikeC4ModelLocator;
    constructor(services: LikeC4Services);
    getSymbols(doc: LangiumDocument, _params: DocumentSymbolParams, cancelToken?: CancellationToken$1): Promise<DocumentSymbol[]>;
    protected getLikec4LibSymbol(astLib: LikeC4Lib): DocumentSymbol[];
    protected getSpecSymbol(astSpec: SpecificationRule): DocumentSymbol[];
    protected getModelSymbol(astModel: Model): DocumentSymbol[];
    protected getDeploymentModelSymbol(astModel: ModelDeployments): DocumentSymbol[];
    protected getElementsSymbol(el: Element | Relation | ExtendElement): DocumentSymbol[];
    protected getExtendElementSymbol(astElement: ExtendElement): DocumentSymbol[];
    protected getElementSymbol(astElement: Element): DocumentSymbol[];
    protected getModelViewsSymbol(astViews: ModelViews): DocumentSymbol[];
    protected getKindSymbol(astKind: SpecificationElementKind | SpecificationRelationshipKind): DocumentSymbol | null;
    protected getTagSymbol(astTag: SpecificationTag): DocumentSymbol | null;
    protected getLibIconSymbol(astTag: LibIcon): DocumentSymbol | null;
    protected getViewSymbol(astView: LikeC4View): DocumentSymbol[];
    protected getDeploymentElementSymbol(el: DeploymentElement | DeploymentRelation | ExtendDeployment): DocumentSymbol[];
    protected getDeploymentNodeSymbol(astElement: DeploymentNode): DocumentSymbol[];
    protected getDeployedInstanceSymbol(astElement: DeployedInstance): DocumentSymbol[];
    protected symbolKind(node: AstNode): SymbolKind;
}

declare class LikeC4HoverProvider extends AstNodeHoverProvider {
    private parser;
    private locator;
    constructor(services: LikeC4Services);
    protected getAstNodeHoverContent(node: AstNode): MaybePromise<Hover | undefined>;
}

type CommandOrCodeAction = Command | CodeAction;
declare class LikeC4CodeActionProvider implements CodeActionProvider {
    /**
     * Handle a code action request.
     *
     * @throws `OperationCancelled` if cancellation is detected during execution
     * @throws `ResponseError` if an error is detected that should be sent as response to the client
     */
    getCodeActions(document: LangiumDocument, params: CodeActionParams): CommandOrCodeAction[] | undefined;
}

declare class LikeC4SemanticTokenProvider extends AbstractSemanticTokenProvider {
    protected services: LikeC4Services;
    private rules;
    constructor(services: LikeC4Services);
    protected initRules(): void;
    semanticHighlight(document: LangiumDocument, params: SemanticTokensParams, cancelToken?: CancellationToken$1): Promise<SemanticTokens>;
    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken$1): Promise<SemanticTokens>;
    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken$1): Promise<SemanticTokens | SemanticTokensDelta>;
    protected ensureState(document: LangiumDocument, cancelToken: CancellationToken$1): Promise<void>;
    protected highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';
    private highlightNameAndKind;
    private highlightView;
    private mark;
}

type Primitive$2 = string | number | symbol | bigint | boolean | null | undefined;

declare namespace util {
    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;
    export type isAny<T> = 0 extends 1 & T ? true : false;
    export const assertEqual: <A, B>(_: AssertEqual<A, B>) => void;
    export function assertIs<T>(_arg: T): void;
    export function assertNever(_x: never): never;
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
    export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;
    export type InexactPartial<T> = {
        [k in keyof T]?: T[k] | undefined;
    };
    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };
    export const getValidEnumValues: (obj: any) => any[];
    export const objectValues: (obj: any) => any[];
    export const objectKeys: ObjectConstructor["keys"];
    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;
    export type identity<T> = objectUtil.identity<T>;
    export type flatten<T> = objectUtil.flatten<T>;
    export type noUndefined<T> = T extends undefined ? never : T;
    export const isInteger: NumberConstructor["isInteger"];
    export function joinValues<T extends any[]>(array: T, separator?: string): string;
    export const jsonStringifyReplacer: (_: string, value: any) => any;
    export {  };
}
declare namespace objectUtil {
    export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {
        [k in Exclude<keyof U, keyof V>]: U[k];
    } & V;
    type optionalKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? k : never;
    }[keyof T];
    type requiredKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? never : k;
    }[keyof T];
    export type addQuestionMarks<T extends object, _O = any> = {
        [K in requiredKeys<T>]: T[K];
    } & {
        [K in optionalKeys<T>]?: T[K];
    } & {
        [k in keyof T]?: unknown;
    };
    export type identity<T> = T;
    export type flatten<T> = identity<{
        [k in keyof T]: T[k];
    }>;
    export type noNeverKeys<T> = {
        [k in keyof T]: [T[k]] extends [never] ? never : k;
    }[keyof T];
    export type noNever<T> = identity<{
        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
    }>;
    export const mergeShapes: <U, T>(first: U, second: T) => T & U;
    export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {
        [K in keyof A as K extends keyof B ? never : K]: A[K];
    } & {
        [K in keyof B]: B[K];
    };
    export {  };
}
declare const ZodParsedType: {
    string: "string";
    nan: "nan";
    number: "number";
    integer: "integer";
    float: "float";
    boolean: "boolean";
    date: "date";
    bigint: "bigint";
    symbol: "symbol";
    function: "function";
    undefined: "undefined";
    null: "null";
    array: "array";
    object: "object";
    unknown: "unknown";
    promise: "promise";
    void: "void";
    never: "never";
    map: "map";
    set: "set";
};
type ZodParsedType = keyof typeof ZodParsedType;

type allKeys<T> = T extends any ? keyof T : never;
type typeToFlattenedError<T, U = string> = {
    formErrors: U[];
    fieldErrors: {
        [P in allKeys<T>]?: U[];
    };
};
declare const ZodIssueCode: {
    invalid_type: "invalid_type";
    invalid_literal: "invalid_literal";
    custom: "custom";
    invalid_union: "invalid_union";
    invalid_union_discriminator: "invalid_union_discriminator";
    invalid_enum_value: "invalid_enum_value";
    unrecognized_keys: "unrecognized_keys";
    invalid_arguments: "invalid_arguments";
    invalid_return_type: "invalid_return_type";
    invalid_date: "invalid_date";
    invalid_string: "invalid_string";
    too_small: "too_small";
    too_big: "too_big";
    invalid_intersection_types: "invalid_intersection_types";
    not_multiple_of: "not_multiple_of";
    not_finite: "not_finite";
};
type ZodIssueCode = keyof typeof ZodIssueCode;
type ZodIssueBase = {
    path: (string | number)[];
    message?: string | undefined;
};
interface ZodInvalidTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_type;
    expected: ZodParsedType;
    received: ZodParsedType;
}
interface ZodInvalidLiteralIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_literal;
    expected: unknown;
    received: unknown;
}
interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.unrecognized_keys;
    keys: string[];
}
interface ZodInvalidUnionIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union;
    unionErrors: ZodError$1[];
}
interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union_discriminator;
    options: Primitive$2[];
}
interface ZodInvalidEnumValueIssue extends ZodIssueBase {
    received: string | number;
    code: typeof ZodIssueCode.invalid_enum_value;
    options: (string | number)[];
}
interface ZodInvalidArgumentsIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_arguments;
    argumentsError: ZodError$1;
}
interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_return_type;
    returnTypeError: ZodError$1;
}
interface ZodInvalidDateIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_date;
}
type StringValidation = "email" | "url" | "emoji" | "uuid" | "nanoid" | "regex" | "cuid" | "cuid2" | "ulid" | "datetime" | "date" | "time" | "duration" | "ip" | "cidr" | "base64" | "jwt" | "base64url" | {
    includes: string;
    position?: number | undefined;
} | {
    startsWith: string;
} | {
    endsWith: string;
};
interface ZodInvalidStringIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_string;
    validation: StringValidation;
}
interface ZodTooSmallIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_small;
    minimum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
interface ZodTooBigIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_big;
    maximum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_intersection_types;
}
interface ZodNotMultipleOfIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_multiple_of;
    multipleOf: number | bigint;
}
interface ZodNotFiniteIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_finite;
}
interface ZodCustomIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params?: {
        [k: string]: any;
    };
}
type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;
type ZodIssue = ZodIssueOptionalMessage & {
    fatal?: boolean | undefined;
    message: string;
};
type recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : T extends any[] ? {
    [k: number]: ZodFormattedError<T[number]>;
} : T extends object ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : unknown;
type ZodFormattedError<T, U = string> = {
    _errors: U[];
} & recursiveZodFormattedError<NonNullable<T>>;
declare class ZodError$1<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
    constructor(issues: ZodIssue[]);
    format(): ZodFormattedError<T>;
    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;
    static create: (issues: ZodIssue[]) => ZodError$1<any>;
    static assert(value: unknown): asserts value is ZodError$1;
    toString(): string;
    get message(): string;
    get isEmpty(): boolean;
    addIssue: (sub: ZodIssue) => void;
    addIssues: (subs?: ZodIssue[]) => void;
    flatten(): typeToFlattenedError<T>;
    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;
    get formErrors(): typeToFlattenedError<T, string>;
}
type stripPath<T extends object> = T extends any ? util.OmitKeys<T, "path"> : never;
type IssueData = stripPath<ZodIssueOptionalMessage> & {
    path?: (string | number)[];
    fatal?: boolean | undefined;
};
type ErrorMapCtx = {
    defaultError: string;
    data: any;
};
type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {
    message: string;
};

type ParseParams = {
    path: (string | number)[];
    errorMap: ZodErrorMap;
    async: boolean;
};
type ParsePathComponent = string | number;
type ParsePath = ParsePathComponent[];
interface ParseContext$1 {
    readonly common: {
        readonly issues: ZodIssue[];
        readonly contextualErrorMap?: ZodErrorMap | undefined;
        readonly async: boolean;
    };
    readonly path: ParsePath;
    readonly schemaErrorMap?: ZodErrorMap | undefined;
    readonly parent: ParseContext$1 | null;
    readonly data: any;
    readonly parsedType: ZodParsedType;
}
type ParseInput = {
    data: any;
    path: (string | number)[];
    parent: ParseContext$1;
};
declare class ParseStatus {
    value: "aborted" | "dirty" | "valid";
    dirty(): void;
    abort(): void;
    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;
    static mergeObjectAsync(status: ParseStatus, pairs: {
        key: ParseReturnType<any>;
        value: ParseReturnType<any>;
    }[]): Promise<SyncParseReturnType<any>>;
    static mergeObjectSync(status: ParseStatus, pairs: {
        key: SyncParseReturnType<any>;
        value: SyncParseReturnType<any>;
        alwaysSet?: boolean;
    }[]): SyncParseReturnType;
}
type INVALID = {
    status: "aborted";
};
declare const INVALID: INVALID;
type DIRTY<T> = {
    status: "dirty";
    value: T;
};
declare const DIRTY: <T>(value: T) => DIRTY<T>;
type OK<T> = {
    status: "valid";
    value: T;
};
declare const OK: <T>(value: T) => OK<T>;
type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;

declare namespace enumUtil {
    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;
    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;
    type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;
    type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;
    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
    export {  };
}

declare namespace errorUtil {
    type ErrMessage = string | {
        message?: string | undefined;
    };
    const errToObj: (message?: ErrMessage) => {
        message?: string | undefined;
    };
    const toString: (message?: ErrMessage) => string | undefined;
}

declare namespace partialUtil {
    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject$1<ZodRawShape> ? ZodObject$1<{
        [k in keyof T["shape"]]: ZodOptional$1<DeepPartial<T["shape"][k]>>;
    }, T["_def"]["unknownKeys"], T["_def"]["catchall"]> : T extends ZodArray$1<infer Type, infer Card> ? ZodArray$1<DeepPartial<Type>, Card> : T extends ZodOptional$1<infer Type> ? ZodOptional$1<DeepPartial<Type>> : T extends ZodNullable$1<infer Type> ? ZodNullable$1<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;
    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;
}

/**
 * The Standard Schema interface.
 */
type StandardSchemaV1$1<Input = unknown, Output = Input> = {
    /**
     * The Standard Schema properties.
     */
    readonly "~standard": StandardSchemaV1$1.Props<Input, Output>;
};
declare namespace StandardSchemaV1$1 {
    /**
     * The Standard Schema properties interface.
     */
    export interface Props<Input = unknown, Output = Input> {
        /**
         * The version number of the standard.
         */
        readonly version: 1;
        /**
         * The vendor name of the schema library.
         */
        readonly vendor: string;
        /**
         * Validates unknown input values.
         */
        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
        /**
         * Inferred types associated with the schema.
         */
        readonly types?: Types<Input, Output> | undefined;
    }
    /**
     * The result interface of the validate function.
     */
    export type Result<Output> = SuccessResult<Output> | FailureResult;
    /**
     * The result interface if validation succeeds.
     */
    export interface SuccessResult<Output> {
        /**
         * The typed output value.
         */
        readonly value: Output;
        /**
         * The non-existent issues.
         */
        readonly issues?: undefined;
    }
    /**
     * The result interface if validation fails.
     */
    export interface FailureResult {
        /**
         * The issues of failed validation.
         */
        readonly issues: ReadonlyArray<Issue>;
    }
    /**
     * The issue interface of the failure output.
     */
    export interface Issue {
        /**
         * The error message of the issue.
         */
        readonly message: string;
        /**
         * The path of the issue, if any.
         */
        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
    }
    /**
     * The path segment interface of the issue.
     */
    export interface PathSegment {
        /**
         * The key representing a path segment.
         */
        readonly key: PropertyKey;
    }
    /**
     * The Standard Schema types interface.
     */
    export interface Types<Input = unknown, Output = Input> {
        /**
         * The input type of the schema.
         */
        readonly input: Input;
        /**
         * The output type of the schema.
         */
        readonly output: Output;
    }
    /**
     * Infers the input type of a Standard Schema.
     */
    export type InferInput<Schema extends StandardSchemaV1$1> = NonNullable<Schema["~standard"]["types"]>["input"];
    /**
     * Infers the output type of a Standard Schema.
     */
    export type InferOutput<Schema extends StandardSchemaV1$1> = NonNullable<Schema["~standard"]["types"]>["output"];
    export {  };
}

interface RefinementCtx$1 {
    addIssue: (arg: IssueData) => void;
    path: (string | number)[];
}
type ZodRawShape = {
    [k: string]: ZodTypeAny;
};
type ZodTypeAny = ZodType$1<any, any, any>;
type TypeOf<T extends ZodType$1<any, any, any>> = T["_output"];
type input$1<T extends ZodType$1<any, any, any>> = T["_input"];
type output$1<T extends ZodType$1<any, any, any>> = T["_output"];

type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
interface ZodTypeDef {
    errorMap?: ZodErrorMap | undefined;
    description?: string | undefined;
}
type RawCreateParams = {
    errorMap?: ZodErrorMap | undefined;
    invalid_type_error?: string | undefined;
    required_error?: string | undefined;
    message?: string | undefined;
    description?: string | undefined;
} | undefined;
type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
    error?: never;
};
type SafeParseError<Input> = {
    success: false;
    error: ZodError$1<Input>;
    data?: never;
};
type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
declare abstract class ZodType$1<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
    readonly _type: Output;
    readonly _output: Output;
    readonly _input: Input;
    readonly _def: Def;
    get description(): string | undefined;
    "~standard": StandardSchemaV1$1.Props<Input, Output>;
    abstract _parse(input: ParseInput): ParseReturnType<Output>;
    _getType(input: ParseInput): string;
    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext$1 | undefined): ParseContext$1;
    _processInputParams(input: ParseInput): {
        status: ParseStatus;
        ctx: ParseContext$1;
    };
    _parseSync(input: ParseInput): SyncParseReturnType<Output>;
    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;
    parse(data: unknown, params?: util.InexactPartial<ParseParams>): Output;
    safeParse(data: unknown, params?: util.InexactPartial<ParseParams>): SafeParseReturnType<Input, Output>;
    "~validate"(data: unknown): StandardSchemaV1$1.Result<Output> | Promise<StandardSchemaV1$1.Result<Output>>;
    parseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<Output>;
    safeParseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
    /** Alias of safeParseAsync */
    spa: (data: unknown, params?: util.InexactPartial<ParseParams>) => Promise<SafeParseReturnType<Input, Output>>;
    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;
    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx$1) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx$1) => IssueData)): ZodEffects<this, Output, Input>;
    _refinement(refinement: RefinementEffect<Output>["refinement"]): ZodEffects<this, Output, Input>;
    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx$1) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx$1) => void): ZodEffects<this, Output, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx$1) => Promise<void>): ZodEffects<this, Output, Input>;
    constructor(def: Def);
    optional(): ZodOptional$1<this>;
    nullable(): ZodNullable$1<this>;
    nullish(): ZodOptional$1<ZodNullable$1<this>>;
    array(): ZodArray$1<this>;
    promise(): ZodPromise<this>;
    or<T extends ZodTypeAny>(option: T): ZodUnion$1<[this, T]>;
    and<T extends ZodTypeAny>(incoming: T): ZodIntersection$1<this, T>;
    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx$1) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;
    default(def: util.noUndefined<Input>): ZodDefault$1<this>;
    default(def: () => util.noUndefined<Input>): ZodDefault$1<this>;
    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;
    catch(def: Output): ZodCatch$1<this>;
    catch(def: (ctx: {
        error: ZodError$1;
        input: Input;
    }) => Output): ZodCatch$1<this>;
    describe(description: string): this;
    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;
    readonly(): ZodReadonly$1<this>;
    isOptional(): boolean;
    isNullable(): boolean;
}
interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodArray;
    exactLength: {
        value: number;
        message?: string | undefined;
    } | null;
    minLength: {
        value: number;
        message?: string | undefined;
    } | null;
    maxLength: {
        value: number;
        message?: string | undefined;
    } | null;
}
type ArrayCardinality = "many" | "atleastone";
type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> = Cardinality extends "atleastone" ? [T["_output"], ...T["_output"][]] : T["_output"][];
declare class ZodArray$1<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> extends ZodType$1<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends "atleastone" ? [T["_input"], ...T["_input"][]] : T["_input"][]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get element(): T;
    min(minLength: number, message?: errorUtil.ErrMessage): this;
    max(maxLength: number, message?: errorUtil.ErrMessage): this;
    length(len: number, message?: errorUtil.ErrMessage): this;
    nonempty(message?: errorUtil.ErrMessage): ZodArray$1<T, "atleastone">;
    static create: <El extends ZodTypeAny>(schema: El, params?: RawCreateParams) => ZodArray$1<El>;
}
type UnknownKeysParam = "passthrough" | "strict" | "strip";
interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodObject;
    shape: () => T;
    catchall: Catchall;
    unknownKeys: UnknownKeys;
}
type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>> & CatchallOutput<Catchall> & PassthroughType<UnknownKeys>;
type baseObjectOutputType<Shape extends ZodRawShape> = {
    [k in keyof Shape]: Shape[k]["_output"];
};
type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<baseObjectInputType<Shape>> & CatchallInput<Catchall> & PassthroughType<UnknownKeys>;
type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
}>;
type CatchallOutput<T extends ZodType$1> = ZodType$1 extends T ? unknown : {
    [k: string]: T["_output"];
};
type CatchallInput<T extends ZodType$1> = ZodType$1 extends T ? unknown : {
    [k: string]: T["_input"];
};
type PassthroughType<T extends UnknownKeysParam> = T extends "passthrough" ? {
    [k: string]: unknown;
} : unknown;
type deoptional<T extends ZodTypeAny> = T extends ZodOptional$1<infer U> ? deoptional<U> : T extends ZodNullable$1<infer U> ? ZodNullable$1<deoptional<U>> : T;
declare class ZodObject$1<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall, UnknownKeys>, Input = objectInputType<T, Catchall, UnknownKeys>> extends ZodType$1<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
    private _cached;
    _getCached(): {
        shape: T;
        keys: string[];
    };
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get shape(): T;
    strict(message?: errorUtil.ErrMessage): ZodObject$1<T, "strict", Catchall>;
    strip(): ZodObject$1<T, "strip", Catchall>;
    passthrough(): ZodObject$1<T, "passthrough", Catchall>;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    nonstrict: () => ZodObject$1<T, "passthrough", Catchall>;
    extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject$1<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * @deprecated Use `.extend` instead
     *  */
    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject$1<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge<Incoming extends AnyZodObject, Augmentation extends Incoming["shape"]>(merging: Incoming): ZodObject$1<objectUtil.extendShape<T, Augmentation>, Incoming["_def"]["unknownKeys"], Incoming["_def"]["catchall"]>;
    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject$1<T & {
        [k in Key]: Schema;
    }, UnknownKeys, Catchall>;
    catchall<Index extends ZodTypeAny>(index: Index): ZodObject$1<T, UnknownKeys, Index>;
    pick<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject$1<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
    omit<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject$1<Omit<T, keyof Mask>, UnknownKeys, Catchall>;
    /**
     * @deprecated
     */
    deepPartial(): partialUtil.DeepPartial<this>;
    partial(): ZodObject$1<{
        [k in keyof T]: ZodOptional$1<T[k]>;
    }, UnknownKeys, Catchall>;
    partial<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject$1<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional$1<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    required(): ZodObject$1<{
        [k in keyof T]: deoptional<T[k]>;
    }, UnknownKeys, Catchall>;
    required<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject$1<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    keyof(): ZodEnum$1<enumUtil.UnionToTupleString<keyof T>>;
    static create: <Shape extends ZodRawShape>(shape: Shape, params?: RawCreateParams) => ZodObject$1<Shape, "strip", ZodTypeAny, objectOutputType<Shape, ZodTypeAny, "strip">, objectInputType<Shape, ZodTypeAny, "strip">>;
    static strictCreate: <Shape extends ZodRawShape>(shape: Shape, params?: RawCreateParams) => ZodObject$1<Shape, "strict">;
    static lazycreate: <Shape extends ZodRawShape>(shape: () => Shape, params?: RawCreateParams) => ZodObject$1<Shape, "strip">;
}
type AnyZodObject = ZodObject$1<any, any, any>;
type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;
interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>> extends ZodTypeDef {
    options: T;
    typeName: ZodFirstPartyTypeKind.ZodUnion;
}
declare class ZodUnion$1<T extends ZodUnionOptions> extends ZodType$1<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    static create: <Options extends Readonly<[ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>>(types: Options, params?: RawCreateParams) => ZodUnion$1<Options>;
}
interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    left: T;
    right: U;
    typeName: ZodFirstPartyTypeKind.ZodIntersection;
}
declare class ZodIntersection$1<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType$1<T["_output"] & U["_output"], ZodIntersectionDef<T, U>, T["_input"] & U["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <TSchema extends ZodTypeAny, USchema extends ZodTypeAny>(left: TSchema, right: USchema, params?: RawCreateParams) => ZodIntersection$1<TSchema, USchema>;
}
type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
type AssertArray<T> = T extends any[] ? T : never;
type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType$1<any, any, any> ? T[k]["_output"] : never;
}>;
type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]] : OutputTypeOfTuple<T>;
type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType$1<any, any, any> ? T[k]["_input"] : never;
}>;
type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest["_input"][]] : InputTypeOfTuple<T>;
interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
    items: T;
    rest: Rest;
    typeName: ZodFirstPartyTypeKind.ZodTuple;
}
declare class ZodTuple<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodType$1<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get items(): T;
    rest<RestSchema extends ZodTypeAny>(rest: RestSchema): ZodTuple<T, RestSchema>;
    static create: <Items extends [ZodTypeAny, ...ZodTypeAny[]] | []>(schemas: Items, params?: RawCreateParams) => ZodTuple<Items, null>;
}
type EnumValues<T extends string = string> = readonly [T, ...T[]];
type Values<T extends EnumValues> = {
    [k in T[number]]: k;
};
interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodEnum;
}
type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
type FilterEnum<Values, ToExclude> = Values extends [] ? [] : Values extends [infer Head, ...infer Rest] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [Head, ...FilterEnum<Rest, ToExclude>] : never;
type typecast<A, T> = A extends T ? A : never;
declare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum$1<Writeable<T>>;
declare function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum$1<T>;
declare class ZodEnum$1<T extends [string, ...string[]]> extends ZodType$1<T[number], ZodEnumDef<T>, T[number]> {
    _cache: Set<T[number]> | undefined;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    get enum(): Values<T>;
    get Values(): Values<T>;
    get Enum(): Values<T>;
    extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract, newDef?: RawCreateParams): ZodEnum$1<Writeable<ToExtract>>;
    exclude<ToExclude extends readonly [T[number], ...T[number][]]>(values: ToExclude, newDef?: RawCreateParams): ZodEnum$1<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>>;
    static create: typeof createZodEnum;
}
interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodPromise;
}
declare class ZodPromise<T extends ZodTypeAny> extends ZodType$1<Promise<T["_output"]>, ZodPromiseDef<T>, Promise<T["_input"]>> {
    unwrap(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <Inner extends ZodTypeAny>(schema: Inner, params?: RawCreateParams) => ZodPromise<Inner>;
}
type RefinementEffect<T> = {
    type: "refinement";
    refinement: (arg: T, ctx: RefinementCtx$1) => any;
};
type TransformEffect<T> = {
    type: "transform";
    transform: (arg: T, ctx: RefinementCtx$1) => any;
};
type PreprocessEffect<T> = {
    type: "preprocess";
    transform: (arg: T, ctx: RefinementCtx$1) => any;
};
type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;
interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    schema: T;
    typeName: ZodFirstPartyTypeKind.ZodEffects;
    effect: Effect<any>;
}
declare class ZodEffects<T extends ZodTypeAny, Output = output$1<T>, Input = input$1<T>> extends ZodType$1<Output, ZodEffectsDef<T>, Input> {
    innerType(): T;
    sourceType(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx$1) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
}

interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodOptional;
}
declare class ZodOptional$1<T extends ZodTypeAny> extends ZodType$1<T["_output"] | undefined, ZodOptionalDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams) => ZodOptional$1<Inner>;
}
interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodNullable;
}
declare class ZodNullable$1<T extends ZodTypeAny> extends ZodType$1<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams) => ZodNullable$1<Inner>;
}
interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    defaultValue: () => util.noUndefined<T["_input"]>;
    typeName: ZodFirstPartyTypeKind.ZodDefault;
}
declare class ZodDefault$1<T extends ZodTypeAny> extends ZodType$1<util.noUndefined<T["_output"]>, ZodDefaultDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeDefault(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params: RawCreateParams & {
        default: Inner["_input"] | (() => util.noUndefined<Inner["_input"]>);
    }) => ZodDefault$1<Inner>;
}
interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    catchValue: (ctx: {
        error: ZodError$1;
        input: unknown;
    }) => T["_input"];
    typeName: ZodFirstPartyTypeKind.ZodCatch;
}
declare class ZodCatch$1<T extends ZodTypeAny> extends ZodType$1<T["_output"], ZodCatchDef<T>, unknown> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeCatch(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params: RawCreateParams & {
        catch: Inner["_output"] | (() => Inner["_output"]);
    }) => ZodCatch$1<Inner>;
}
interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodBranded;
}
declare const BRAND: unique symbol;
type BRAND<T extends string | number | symbol> = {
    [BRAND]: {
        [k in T]: true;
    };
};
declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType$1<T["_output"] & BRAND<B>, ZodBrandedDef<T>, T["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    unwrap(): T;
}
interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {
    in: A;
    out: B;
    typeName: ZodFirstPartyTypeKind.ZodPipeline;
}
declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType$1<B["_output"], ZodPipelineDef<A, B>, A["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    static create<ASchema extends ZodTypeAny, BSchema extends ZodTypeAny>(a: ASchema, b: BSchema): ZodPipeline<ASchema, BSchema>;
}
type BuiltIn$1 = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
    readonly [Symbol.toStringTag]: string;
} | Date | Error | Generator | Promise<unknown> | RegExp;
type MakeReadonly$1<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn$1 ? T : Readonly<T>;
interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodReadonly;
}
declare class ZodReadonly$1<T extends ZodTypeAny> extends ZodType$1<MakeReadonly$1<T["_output"]>, ZodReadonlyDef<T>, MakeReadonly$1<T["_input"]>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams) => ZodReadonly$1<Inner>;
    unwrap(): T;
}
declare enum ZodFirstPartyTypeKind {
    ZodString = "ZodString",
    ZodNumber = "ZodNumber",
    ZodNaN = "ZodNaN",
    ZodBigInt = "ZodBigInt",
    ZodBoolean = "ZodBoolean",
    ZodDate = "ZodDate",
    ZodSymbol = "ZodSymbol",
    ZodUndefined = "ZodUndefined",
    ZodNull = "ZodNull",
    ZodAny = "ZodAny",
    ZodUnknown = "ZodUnknown",
    ZodNever = "ZodNever",
    ZodVoid = "ZodVoid",
    ZodArray = "ZodArray",
    ZodObject = "ZodObject",
    ZodUnion = "ZodUnion",
    ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    ZodIntersection = "ZodIntersection",
    ZodTuple = "ZodTuple",
    ZodRecord = "ZodRecord",
    ZodMap = "ZodMap",
    ZodSet = "ZodSet",
    ZodFunction = "ZodFunction",
    ZodLazy = "ZodLazy",
    ZodLiteral = "ZodLiteral",
    ZodEnum = "ZodEnum",
    ZodEffects = "ZodEffects",
    ZodNativeEnum = "ZodNativeEnum",
    ZodOptional = "ZodOptional",
    ZodNullable = "ZodNullable",
    ZodDefault = "ZodDefault",
    ZodCatch = "ZodCatch",
    ZodPromise = "ZodPromise",
    ZodBranded = "ZodBranded",
    ZodPipeline = "ZodPipeline",
    ZodReadonly = "ZodReadonly"
}

/** The Standard Schema interface. */
interface StandardSchemaV1<Input = unknown, Output = Input> {
    /** The Standard Schema properties. */
    readonly "~standard": StandardSchemaV1.Props<Input, Output>;
}
declare namespace StandardSchemaV1 {
    /** The Standard Schema properties interface. */
    interface Props<Input = unknown, Output = Input> {
        /** The version number of the standard. */
        readonly version: 1;
        /** The vendor name of the schema library. */
        readonly vendor: string;
        /** Validates unknown input values. */
        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
        /** Inferred types associated with the schema. */
        readonly types?: Types<Input, Output> | undefined;
    }
    /** The result interface of the validate function. */
    type Result<Output> = SuccessResult<Output> | FailureResult;
    /** The result interface if validation succeeds. */
    interface SuccessResult<Output> {
        /** The typed output value. */
        readonly value: Output;
        /** The non-existent issues. */
        readonly issues?: undefined;
    }
    /** The result interface if validation fails. */
    interface FailureResult {
        /** The issues of failed validation. */
        readonly issues: ReadonlyArray<Issue>;
    }
    /** The issue interface of the failure output. */
    interface Issue {
        /** The error message of the issue. */
        readonly message: string;
        /** The path of the issue, if any. */
        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
    }
    /** The path segment interface of the issue. */
    interface PathSegment {
        /** The key representing a path segment. */
        readonly key: PropertyKey;
    }
    /** The Standard Schema types interface. */
    interface Types<Input = unknown, Output = Input> {
        /** The input type of the schema. */
        readonly input: Input;
        /** The output type of the schema. */
        readonly output: Output;
    }
    /** Infers the input type of a Standard Schema. */
    type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["input"];
    /** Infers the output type of a Standard Schema. */
    type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["output"];
}

type JWTAlgorithm = "HS256" | "HS384" | "HS512" | "RS256" | "RS384" | "RS512" | "ES256" | "ES384" | "ES512" | "PS256" | "PS384" | "PS512" | "EdDSA" | (string & {});
type IsAny<T> = 0 extends 1 & T ? true : false;
type Omit$1<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
type MakePartial<T, K extends keyof T> = Omit$1<T, K> & InexactPartial<Pick<T, K>>;
type NoUndefined<T> = T extends undefined ? never : T;
type Whatever = {} | undefined | null;
type LoosePartial<T extends object> = InexactPartial<T> & {
    [k: string]: unknown;
};
type Mask$1<Keys extends PropertyKey> = {
    [K in Keys]?: true;
};
type InexactPartial<T> = {
    [P in keyof T]?: T[P] | undefined;
};
type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
    readonly [Symbol.toStringTag]: string;
} | Date | Error | Generator | Promise<unknown> | RegExp;
type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;
type SomeObject = Record<PropertyKey, any>;
type Identity<T> = T;
type Flatten$1<T> = Identity<{
    [k in keyof T]: T[k];
}>;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
type Extend<A extends SomeObject, B extends SomeObject> = Flatten$1<keyof A & keyof B extends never ? A & B : {
    [K in keyof A as K extends keyof B ? never : K]: A[K];
} & {
    [K in keyof B]: B[K];
}>;
type AnyFunc = (...args: any[]) => any;
type MaybeAsync<T> = T | Promise<T>;
type EnumValue = string | number;
type EnumLike = Readonly<Record<string, EnumValue>>;
type ToEnum<T extends EnumValue> = Flatten$1<{
    [k in T]: k;
}>;
type Literal = string | number | bigint | boolean | null | undefined;
type Primitive$1 = string | number | symbol | bigint | boolean | null | undefined;
type HasLength = {
    length: number;
};
type Numeric = number | bigint | Date;
type PropValues = Record<string, Set<Primitive$1>>;
type PrimitiveSet = Set<Primitive$1>;
type EmptyToNever<T> = keyof T extends never ? never : T;
declare abstract class Class {
    constructor(..._args: any[]);
}

declare const version: {
    readonly major: 4;
    readonly minor: 0;
    readonly patch: number;
};

interface ParseContext<T extends $ZodIssueBase = never> {
    /** Customize error messages. */
    readonly error?: $ZodErrorMap<T>;
    /** Include the `input` field in issue objects. Default `false`. */
    readonly reportInput?: boolean;
    /** Skip eval-based fast path. Default `false`. */
    readonly jitless?: boolean;
}
/** @internal */
interface ParseContextInternal<T extends $ZodIssueBase = never> extends ParseContext<T> {
    readonly async?: boolean | undefined;
}
interface ParsePayload<T = unknown> {
    value: T;
    issues: $ZodRawIssue[];
}
type CheckFn<T> = (input: ParsePayload<T>) => MaybeAsync<void>;
interface $ZodTypeDef {
    type: "string" | "number" | "int" | "boolean" | "bigint" | "symbol" | "null" | "undefined" | "void" | "never" | "any" | "unknown" | "date" | "object" | "record" | "file" | "array" | "tuple" | "union" | "intersection" | "map" | "set" | "enum" | "literal" | "nullable" | "optional" | "nonoptional" | "success" | "transform" | "default" | "prefault" | "catch" | "nan" | "pipe" | "readonly" | "template_literal" | "promise" | "lazy" | "custom";
    error?: $ZodErrorMap<never> | undefined;
    checks?: $ZodCheck<never>[];
}
interface _$ZodTypeInternals {
    /** The `@zod/core` version of this schema */
    version: typeof version;
    /** Schema definition. */
    def: $ZodTypeDef;
    /** @internal Randomly generated ID for this schema. */
    /** @internal List of deferred initializers. */
    deferred: AnyFunc[] | undefined;
    /** @internal Parses input and runs all checks (refinements). */
    run(payload: ParsePayload<any>, ctx: ParseContextInternal): MaybeAsync<ParsePayload>;
    /** @internal Parses input, doesn't run checks. */
    parse(payload: ParsePayload<any>, ctx: ParseContextInternal): MaybeAsync<ParsePayload>;
    /** @internal  Stores identifiers for the set of traits implemented by this schema. */
    traits: Set<string>;
    /** @internal Indicates that a schema output type should be considered optional inside objects.
     * @default Required
     */
    /** @internal */
    optin?: "optional" | undefined;
    /** @internal */
    optout?: "optional" | undefined;
    /** @internal The set of literal values that will pass validation. Must be an exhaustive set. Used to determine optionality in z.record().
     *
     * Defined on: enum, const, literal, null, undefined
     * Passthrough: optional, nullable, branded, default, catch, pipe
     * Todo: unions?
     */
    values?: PrimitiveSet | undefined;
    /** @internal A set of literal discriminators used for the fast path in discriminated unions. */
    propValues?: PropValues | undefined;
    /** @internal This flag indicates that a schema validation can be represented with a regular expression. Used to determine allowable schemas in z.templateLiteral(). */
    pattern: RegExp | undefined;
    /** @internal The constructor function of this schema. */
    constr: new (def: any) => $ZodType;
    /** @internal A catchall object for bag metadata related to this schema. Commonly modified by checks using `onattach`. */
    bag: Record<string, unknown>;
    /** @internal The set of issues this schema might throw during type checking. */
    isst: $ZodIssueBase;
    /** An optional method used to override `toJSONSchema` logic. */
    toJSONSchema?: () => unknown;
    /** @internal The parent of this schema. Only set during certain clone operations. */
    parent?: $ZodType | undefined;
}
/** @internal */
interface $ZodTypeInternals<out O = unknown, out I = unknown> extends _$ZodTypeInternals {
    /** @internal The inferred output type */
    output: O;
    /** @internal The inferred input type */
    input: I;
}
type $ZodStandardSchema<T> = StandardSchemaV1.Props<input<T>, output<T>>;
type SomeType = {
    _zod: _$ZodTypeInternals;
};
interface $ZodType<O = unknown, I = unknown, Internals extends $ZodTypeInternals<O, I> = $ZodTypeInternals<O, I>> {
    _zod: Internals;
    "~standard": $ZodStandardSchema<this>;
}
declare const $ZodType: $constructor<$ZodType>;

interface $ZodStringDef extends $ZodTypeDef {
    type: "string";
    coerce?: boolean;
    checks?: $ZodCheck<string>[];
}
interface $ZodStringInternals<Input> extends $ZodTypeInternals<string, Input> {
    def: $ZodStringDef;
    /** @deprecated Internal API, use with caution (not deprecated) */
    pattern: RegExp;
    /** @deprecated Internal API, use with caution (not deprecated) */
    isst: $ZodIssueInvalidType;
    bag: LoosePartial<{
        minimum: number;
        maximum: number;
        patterns: Set<RegExp>;
        format: string;
        contentEncoding: string;
    }>;
}
interface $ZodStringFormatDef<Format extends string = string> extends $ZodStringDef, $ZodCheckStringFormatDef<Format> {
}
interface $ZodStringFormatInternals<Format extends string = string> extends $ZodStringInternals<string>, $ZodCheckStringFormatInternals {
    def: $ZodStringFormatDef<Format>;
}
interface $ZodStringFormat<Format extends string = string> extends $ZodType {
    _zod: $ZodStringFormatInternals<Format>;
}
declare const $ZodStringFormat: $constructor<$ZodStringFormat>;
interface $ZodGUIDInternals extends $ZodStringFormatInternals<"guid"> {
}
interface $ZodGUID extends $ZodType {
    _zod: $ZodGUIDInternals;
}
declare const $ZodGUID: $constructor<$ZodGUID>;
interface $ZodUUIDDef extends $ZodStringFormatDef<"uuid"> {
    version?: "v1" | "v2" | "v3" | "v4" | "v5" | "v6" | "v7" | "v8";
}
interface $ZodUUIDInternals extends $ZodStringFormatInternals<"uuid"> {
    def: $ZodUUIDDef;
}
interface $ZodUUID extends $ZodType {
    _zod: $ZodUUIDInternals;
}
declare const $ZodUUID: $constructor<$ZodUUID>;
interface $ZodEmailInternals extends $ZodStringFormatInternals<"email"> {
}
interface $ZodEmail extends $ZodType {
    _zod: $ZodEmailInternals;
}
declare const $ZodEmail: $constructor<$ZodEmail>;
interface $ZodURLDef extends $ZodStringFormatDef<"url"> {
    hostname?: RegExp | undefined;
    protocol?: RegExp | undefined;
}
interface $ZodURLInternals extends $ZodStringFormatInternals<"url"> {
    def: $ZodURLDef;
}
interface $ZodURL extends $ZodType {
    _zod: $ZodURLInternals;
}
declare const $ZodURL: $constructor<$ZodURL>;
interface $ZodEmojiInternals extends $ZodStringFormatInternals<"emoji"> {
}
interface $ZodEmoji extends $ZodType {
    _zod: $ZodEmojiInternals;
}
declare const $ZodEmoji: $constructor<$ZodEmoji>;
interface $ZodNanoIDInternals extends $ZodStringFormatInternals<"nanoid"> {
}
interface $ZodNanoID extends $ZodType {
    _zod: $ZodNanoIDInternals;
}
declare const $ZodNanoID: $constructor<$ZodNanoID>;
interface $ZodCUIDInternals extends $ZodStringFormatInternals<"cuid"> {
}
interface $ZodCUID extends $ZodType {
    _zod: $ZodCUIDInternals;
}
declare const $ZodCUID: $constructor<$ZodCUID>;
interface $ZodCUID2Internals extends $ZodStringFormatInternals<"cuid2"> {
}
interface $ZodCUID2 extends $ZodType {
    _zod: $ZodCUID2Internals;
}
declare const $ZodCUID2: $constructor<$ZodCUID2>;
interface $ZodULIDInternals extends $ZodStringFormatInternals<"ulid"> {
}
interface $ZodULID extends $ZodType {
    _zod: $ZodULIDInternals;
}
declare const $ZodULID: $constructor<$ZodULID>;
interface $ZodXIDInternals extends $ZodStringFormatInternals<"xid"> {
}
interface $ZodXID extends $ZodType {
    _zod: $ZodXIDInternals;
}
declare const $ZodXID: $constructor<$ZodXID>;
interface $ZodKSUIDInternals extends $ZodStringFormatInternals<"ksuid"> {
}
interface $ZodKSUID extends $ZodType {
    _zod: $ZodKSUIDInternals;
}
declare const $ZodKSUID: $constructor<$ZodKSUID>;
interface $ZodISODateTimeDef extends $ZodStringFormatDef<"datetime"> {
    precision: number | null;
    offset: boolean;
    local: boolean;
}
interface $ZodISODateTimeInternals extends $ZodStringFormatInternals {
    def: $ZodISODateTimeDef;
}
interface $ZodISODateTime extends $ZodType {
    _zod: $ZodISODateTimeInternals;
}
declare const $ZodISODateTime: $constructor<$ZodISODateTime>;
interface $ZodISODateInternals extends $ZodStringFormatInternals<"date"> {
}
interface $ZodISODate extends $ZodType {
    _zod: $ZodISODateInternals;
}
declare const $ZodISODate: $constructor<$ZodISODate>;
interface $ZodISOTimeDef extends $ZodStringFormatDef<"time"> {
    precision?: number | null;
}
interface $ZodISOTimeInternals extends $ZodStringFormatInternals<"time"> {
    def: $ZodISOTimeDef;
}
interface $ZodISOTime extends $ZodType {
    _zod: $ZodISOTimeInternals;
}
declare const $ZodISOTime: $constructor<$ZodISOTime>;
interface $ZodISODurationInternals extends $ZodStringFormatInternals<"duration"> {
}
interface $ZodISODuration extends $ZodType {
    _zod: $ZodISODurationInternals;
}
declare const $ZodISODuration: $constructor<$ZodISODuration>;
interface $ZodIPv4Def extends $ZodStringFormatDef<"ipv4"> {
    version?: "v4";
}
interface $ZodIPv4Internals extends $ZodStringFormatInternals<"ipv4"> {
    def: $ZodIPv4Def;
}
interface $ZodIPv4 extends $ZodType {
    _zod: $ZodIPv4Internals;
}
declare const $ZodIPv4: $constructor<$ZodIPv4>;
interface $ZodIPv6Def extends $ZodStringFormatDef<"ipv6"> {
    version?: "v6";
}
interface $ZodIPv6Internals extends $ZodStringFormatInternals<"ipv6"> {
    def: $ZodIPv6Def;
}
interface $ZodIPv6 extends $ZodType {
    _zod: $ZodIPv6Internals;
}
declare const $ZodIPv6: $constructor<$ZodIPv6>;
interface $ZodCIDRv4Def extends $ZodStringFormatDef<"cidrv4"> {
    version?: "v4";
}
interface $ZodCIDRv4Internals extends $ZodStringFormatInternals<"cidrv4"> {
    def: $ZodCIDRv4Def;
}
interface $ZodCIDRv4 extends $ZodType {
    _zod: $ZodCIDRv4Internals;
}
declare const $ZodCIDRv4: $constructor<$ZodCIDRv4>;
interface $ZodCIDRv6Def extends $ZodStringFormatDef<"cidrv6"> {
    version?: "v6";
}
interface $ZodCIDRv6Internals extends $ZodStringFormatInternals<"cidrv6"> {
    def: $ZodCIDRv6Def;
}
interface $ZodCIDRv6 extends $ZodType {
    _zod: $ZodCIDRv6Internals;
}
declare const $ZodCIDRv6: $constructor<$ZodCIDRv6>;
interface $ZodBase64Internals extends $ZodStringFormatInternals<"base64"> {
}
interface $ZodBase64 extends $ZodType {
    _zod: $ZodBase64Internals;
}
declare const $ZodBase64: $constructor<$ZodBase64>;
interface $ZodBase64URLInternals extends $ZodStringFormatInternals<"base64url"> {
}
interface $ZodBase64URL extends $ZodType {
    _zod: $ZodBase64URLInternals;
}
declare const $ZodBase64URL: $constructor<$ZodBase64URL>;
interface $ZodE164Internals extends $ZodStringFormatInternals<"e164"> {
}
interface $ZodE164 extends $ZodType {
    _zod: $ZodE164Internals;
}
declare const $ZodE164: $constructor<$ZodE164>;
interface $ZodJWTDef extends $ZodStringFormatDef<"jwt"> {
    alg?: JWTAlgorithm | undefined;
}
interface $ZodJWTInternals extends $ZodStringFormatInternals<"jwt"> {
    def: $ZodJWTDef;
}
interface $ZodJWT extends $ZodType {
    _zod: $ZodJWTInternals;
}
declare const $ZodJWT: $constructor<$ZodJWT>;
interface $ZodNumberDef extends $ZodTypeDef {
    type: "number";
    coerce?: boolean;
}
interface $ZodNumberInternals<Input = unknown> extends $ZodTypeInternals<number, Input> {
    def: $ZodNumberDef;
    /** @deprecated Internal API, use with caution (not deprecated) */
    pattern: RegExp;
    /** @deprecated Internal API, use with caution (not deprecated) */
    isst: $ZodIssueInvalidType;
    bag: LoosePartial<{
        minimum: number;
        maximum: number;
        exclusiveMinimum: number;
        exclusiveMaximum: number;
        format: string;
        pattern: RegExp;
    }>;
}
interface $ZodBooleanDef extends $ZodTypeDef {
    type: "boolean";
    coerce?: boolean;
    checks?: $ZodCheck<boolean>[];
}
interface $ZodBooleanInternals<T = unknown> extends $ZodTypeInternals<boolean, T> {
    pattern: RegExp;
    def: $ZodBooleanDef;
    isst: $ZodIssueInvalidType;
}
interface $ZodNullDef extends $ZodTypeDef {
    type: "null";
}
interface $ZodNullInternals extends $ZodTypeInternals<null, null> {
    pattern: RegExp;
    def: $ZodNullDef;
    values: PrimitiveSet;
    isst: $ZodIssueInvalidType;
}
interface $ZodUnknownDef extends $ZodTypeDef {
    type: "unknown";
}
interface $ZodUnknownInternals extends $ZodTypeInternals<unknown, unknown> {
    def: $ZodUnknownDef;
    isst: never;
}
interface $ZodArrayDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "array";
    element: T;
}
interface $ZodArrayInternals<T extends SomeType = $ZodType> extends _$ZodTypeInternals {
    def: $ZodArrayDef<T>;
    isst: $ZodIssueInvalidType;
    output: output<T>[];
    input: input<T>[];
}
interface $ZodArray<T extends SomeType = $ZodType> extends $ZodType<any, any, $ZodArrayInternals<T>> {
}
declare const $ZodArray: $constructor<$ZodArray>;
type OptionalOutSchema = {
    _zod: {
        optout: "optional";
    };
};
type OptionalInSchema = {
    _zod: {
        optin: "optional";
    };
};
type $InferObjectOutput<T extends $ZodLooseShape, Extra extends Record<string, unknown>> = string extends keyof T ? IsAny<T[keyof T]> extends true ? Record<string, unknown> : Record<string, output<T[keyof T]>> : keyof (T & Extra) extends never ? Record<string, never> : Prettify<{
    -readonly [k in keyof T as T[k] extends OptionalOutSchema ? never : k]: T[k]["_zod"]["output"];
} & {
    -readonly [k in keyof T as T[k] extends OptionalOutSchema ? k : never]?: T[k]["_zod"]["output"];
} & Extra>;
type $InferObjectInput<T extends $ZodLooseShape, Extra extends Record<string, unknown>> = string extends keyof T ? IsAny<T[keyof T]> extends true ? Record<string, unknown> : Record<string, input<T[keyof T]>> : keyof (T & Extra) extends never ? Record<string, never> : Prettify<{
    -readonly [k in keyof T as T[k] extends OptionalInSchema ? never : k]: T[k]["_zod"]["input"];
} & {
    -readonly [k in keyof T as T[k] extends OptionalInSchema ? k : never]?: T[k]["_zod"]["input"];
} & Extra>;
type $ZodObjectConfig = {
    out: Record<string, unknown>;
    in: Record<string, unknown>;
};
type $loose = {
    out: Record<string, unknown>;
    in: Record<string, unknown>;
};
type $strict = {
    out: {};
    in: {};
};
type $strip = {
    out: {};
    in: {};
};
type $catchall<T extends SomeType> = {
    out: {
        [k: string]: output<T>;
    };
    in: {
        [k: string]: input<T>;
    };
};
type $ZodShape = Readonly<{
    [k: string]: $ZodType;
}>;
interface $ZodObjectDef<Shape extends $ZodShape = $ZodShape> extends $ZodTypeDef {
    type: "object";
    shape: Shape;
    catchall?: $ZodType | undefined;
}
interface $ZodObjectInternals<
/** @ts-ignore Cast variance */
out Shape extends Readonly<$ZodShape> = Readonly<$ZodShape>, out Config extends $ZodObjectConfig = $ZodObjectConfig> extends _$ZodTypeInternals {
    def: $ZodObjectDef<Shape>;
    config: Config;
    isst: $ZodIssueInvalidType | $ZodIssueUnrecognizedKeys;
    propValues: PropValues;
    output: $InferObjectOutput<Shape, Config["out"]>;
    input: $InferObjectInput<Shape, Config["in"]>;
}
type $ZodLooseShape = Record<string, any>;
interface $ZodObject<
/** @ts-ignore Cast variance */
out Shape extends Readonly<$ZodShape> = Readonly<$ZodShape>, out Params extends $ZodObjectConfig = $ZodObjectConfig> extends $ZodType<any, any, $ZodObjectInternals<Shape, Params>> {
    "~standard": $ZodStandardSchema<this>;
}
declare const $ZodObject: $constructor<$ZodObject>;
type $InferUnionOutput<T extends SomeType> = T extends any ? output<T> : never;
type $InferUnionInput<T extends SomeType> = T extends any ? input<T> : never;
interface $ZodUnionDef<Options extends readonly SomeType[] = readonly $ZodType[]> extends $ZodTypeDef {
    type: "union";
    options: Options;
}
type IsOptionalIn<T extends SomeType> = T extends OptionalInSchema ? true : false;
type IsOptionalOut<T extends SomeType> = T extends OptionalOutSchema ? true : false;
interface $ZodUnionInternals<T extends readonly SomeType[] = readonly $ZodType[]> extends _$ZodTypeInternals {
    def: $ZodUnionDef<T>;
    isst: $ZodIssueInvalidUnion;
    pattern: T[number]["_zod"]["pattern"];
    values: T[number]["_zod"]["values"];
    output: $InferUnionOutput<T[number]>;
    input: $InferUnionInput<T[number]>;
    optin: IsOptionalIn<T[number]> extends false ? "optional" | undefined : "optional";
    optout: IsOptionalOut<T[number]> extends false ? "optional" | undefined : "optional";
}
interface $ZodUnion<T extends readonly SomeType[] = readonly $ZodType[]> extends $ZodType<any, any, $ZodUnionInternals<T>> {
    _zod: $ZodUnionInternals<T>;
}
declare const $ZodUnion: $constructor<$ZodUnion>;
interface $ZodDiscriminatedUnionDef<Options extends readonly SomeType[] = readonly $ZodType[]> extends $ZodUnionDef<Options> {
    discriminator: string;
    unionFallback?: boolean;
}
interface $ZodDiscriminatedUnionInternals<Options extends readonly SomeType[] = readonly $ZodType[]> extends $ZodUnionInternals<Options> {
    def: $ZodDiscriminatedUnionDef<Options>;
    propValues: PropValues;
}
interface $ZodDiscriminatedUnion<T extends readonly SomeType[] = readonly $ZodType[]> extends $ZodType {
    _zod: $ZodDiscriminatedUnionInternals<T>;
}
declare const $ZodDiscriminatedUnion: $constructor<$ZodDiscriminatedUnion>;
interface $ZodIntersectionDef<Left extends SomeType = $ZodType, Right extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "intersection";
    left: Left;
    right: Right;
}
interface $ZodIntersectionInternals<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodTypeInternals<output<A> & output<B>, input<A> & input<B>> {
    def: $ZodIntersectionDef<A, B>;
    isst: never;
    optin: A["_zod"]["optin"] | B["_zod"]["optin"];
    optout: A["_zod"]["optout"] | B["_zod"]["optout"];
}
interface $ZodIntersection<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodIntersectionInternals<A, B>;
}
declare const $ZodIntersection: $constructor<$ZodIntersection>;
type $ZodRecordKey = $ZodType<string | number | symbol, string | number | symbol>;
interface $ZodRecordDef<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "record";
    keyType: Key;
    valueType: Value;
}
type $InferZodRecordOutput<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> = Key extends $partial ? Partial<Record<output<Key>, output<Value>>> : Record<output<Key>, output<Value>>;
type $InferZodRecordInput<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> = Key extends $partial ? Partial<Record<input<Key>, input<Value>>> : Record<input<Key>, input<Value>>;
interface $ZodRecordInternals<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> extends $ZodTypeInternals<$InferZodRecordOutput<Key, Value>, $InferZodRecordInput<Key, Value>> {
    def: $ZodRecordDef<Key, Value>;
    isst: $ZodIssueInvalidType | $ZodIssueInvalidKey<Record<PropertyKey, unknown>>;
    optin?: "optional" | undefined;
    optout?: "optional" | undefined;
}
type $partial = {
    "~~partial": true;
};
interface $ZodRecord<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodRecordInternals<Key, Value>;
}
declare const $ZodRecord: $constructor<$ZodRecord>;
type $InferEnumOutput<T extends EnumLike> = T[keyof T] & {};
type $InferEnumInput<T extends EnumLike> = T[keyof T] & {};
interface $ZodEnumDef<T extends EnumLike = EnumLike> extends $ZodTypeDef {
    type: "enum";
    entries: T;
}
interface $ZodEnumInternals<
/** @ts-ignore Cast variance */
out T extends EnumLike = EnumLike> extends $ZodTypeInternals<$InferEnumOutput<T>, $InferEnumInput<T>> {
    def: $ZodEnumDef<T>;
    /** @deprecated Internal API, use with caution (not deprecated) */
    values: PrimitiveSet;
    /** @deprecated Internal API, use with caution (not deprecated) */
    pattern: RegExp;
    isst: $ZodIssueInvalidValue;
}
interface $ZodEnum<T extends EnumLike = EnumLike> extends $ZodType {
    _zod: $ZodEnumInternals<T>;
}
declare const $ZodEnum: $constructor<$ZodEnum>;
interface $ZodLiteralDef<T extends Literal> extends $ZodTypeDef {
    type: "literal";
    values: T[];
}
interface $ZodLiteralInternals<T extends Literal = Literal> extends $ZodTypeInternals<T, T> {
    def: $ZodLiteralDef<T>;
    values: Set<T>;
    pattern: RegExp;
    isst: $ZodIssueInvalidValue;
}
interface $ZodLiteral<T extends Literal = Literal> extends $ZodType {
    _zod: $ZodLiteralInternals<T>;
}
declare const $ZodLiteral: $constructor<$ZodLiteral>;
declare global {
    interface File {
    }
}
interface $ZodTransformDef extends $ZodTypeDef {
    type: "transform";
    transform: (input: unknown, payload: ParsePayload<unknown>) => MaybeAsync<unknown>;
}
interface $ZodTransformInternals<O = unknown, I = unknown> extends $ZodTypeInternals<O, I> {
    def: $ZodTransformDef;
    isst: never;
}
interface $ZodTransform<O = unknown, I = unknown> extends $ZodType {
    _zod: $ZodTransformInternals<O, I>;
}
declare const $ZodTransform: $constructor<$ZodTransform>;
interface $ZodOptionalDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "optional";
    innerType: T;
}
interface $ZodOptionalInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<output<T> | undefined, input<T> | undefined> {
    def: $ZodOptionalDef<T>;
    optin: "optional";
    optout: "optional";
    isst: never;
    values: T["_zod"]["values"];
    pattern: T["_zod"]["pattern"];
}
interface $ZodOptional<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodOptionalInternals<T>;
}
declare const $ZodOptional: $constructor<$ZodOptional>;
interface $ZodNullableDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "nullable";
    innerType: T;
}
interface $ZodNullableInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<output<T> | null, input<T> | null> {
    def: $ZodNullableDef<T>;
    optin: T["_zod"]["optin"];
    optout: T["_zod"]["optout"];
    isst: never;
    values: T["_zod"]["values"];
    pattern: T["_zod"]["pattern"];
}
interface $ZodNullable<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodNullableInternals<T>;
}
declare const $ZodNullable: $constructor<$ZodNullable>;
interface $ZodDefaultDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "default";
    innerType: T;
    /** The default value. May be a getter. */
    defaultValue: NoUndefined<output<T>>;
}
interface $ZodDefaultInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<NoUndefined<output<T>>, input<T> | undefined> {
    def: $ZodDefaultDef<T>;
    optin: "optional";
    optout?: "optional" | undefined;
    isst: never;
    values: T["_zod"]["values"];
}
interface $ZodDefault<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodDefaultInternals<T>;
}
declare const $ZodDefault: $constructor<$ZodDefault>;
interface $ZodPrefaultDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "prefault";
    innerType: T;
    /** The default value. May be a getter. */
    defaultValue: input<T>;
}
interface $ZodPrefaultInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<NoUndefined<output<T>>, input<T> | undefined> {
    def: $ZodPrefaultDef<T>;
    optin: "optional";
    optout?: "optional" | undefined;
    isst: never;
    values: T["_zod"]["values"];
}
interface $ZodPrefault<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodPrefaultInternals<T>;
}
declare const $ZodPrefault: $constructor<$ZodPrefault>;
interface $ZodNonOptionalDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "nonoptional";
    innerType: T;
}
interface $ZodNonOptionalInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<NoUndefined<output<T>>, NoUndefined<input<T>>> {
    def: $ZodNonOptionalDef<T>;
    isst: $ZodIssueInvalidType;
    values: T["_zod"]["values"];
    optin: "optional" | undefined;
    optout: "optional" | undefined;
}
interface $ZodNonOptional<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodNonOptionalInternals<T>;
}
declare const $ZodNonOptional: $constructor<$ZodNonOptional>;
interface $ZodCatchCtx extends ParsePayload {
    /** @deprecated Use `ctx.issues` */
    error: {
        issues: $ZodIssue[];
    };
    /** @deprecated Use `ctx.value` */
    input: unknown;
}
interface $ZodCatchDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "catch";
    innerType: T;
    catchValue: (ctx: $ZodCatchCtx) => unknown;
}
interface $ZodCatchInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<output<T>, input<T> | Whatever> {
    def: $ZodCatchDef<T>;
    optin: T["_zod"]["optin"];
    optout: T["_zod"]["optout"];
    isst: never;
    values: T["_zod"]["values"];
}
interface $ZodCatch<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodCatchInternals<T>;
}
declare const $ZodCatch: $constructor<$ZodCatch>;
interface $ZodPipeDef<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "pipe";
    in: A;
    out: B;
}
interface $ZodPipeInternals<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodTypeInternals<output<B>, input<A>> {
    def: $ZodPipeDef<A, B>;
    isst: never;
    values: A["_zod"]["values"];
    optin: A["_zod"]["optin"];
    optout: B["_zod"]["optout"];
}
interface $ZodPipe<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodPipeInternals<A, B>;
}
declare const $ZodPipe: $constructor<$ZodPipe>;
interface $ZodReadonlyDef<T extends SomeType = $ZodType> extends $ZodTypeDef {
    type: "readonly";
    innerType: T;
}
interface $ZodReadonlyInternals<T extends SomeType = $ZodType> extends $ZodTypeInternals<MakeReadonly<output<T>>, MakeReadonly<input<T>>> {
    def: $ZodReadonlyDef<T>;
    optin: T["_zod"]["optin"];
    optout: T["_zod"]["optout"];
    isst: never;
    propValues: T["_zod"]["propValues"];
    values: T["_zod"]["values"];
}
interface $ZodReadonly<T extends SomeType = $ZodType> extends $ZodType {
    _zod: $ZodReadonlyInternals<T>;
}
declare const $ZodReadonly: $constructor<$ZodReadonly>;
interface $ZodCustomDef<O = unknown> extends $ZodTypeDef, $ZodCheckDef {
    type: "custom";
    check: "custom";
    path?: PropertyKey[] | undefined;
    error?: $ZodErrorMap | undefined;
    params?: Record<string, any> | undefined;
    fn: (arg: O) => unknown;
}
interface $ZodCustomInternals<O = unknown, I = unknown> extends $ZodTypeInternals<O, I>, $ZodCheckInternals<O> {
    def: $ZodCustomDef;
    issc: $ZodIssue;
    isst: never;
    bag: LoosePartial<{
        Class: typeof Class;
    }>;
}
interface $ZodCustom<O = unknown, I = unknown> extends $ZodType {
    _zod: $ZodCustomInternals<O, I>;
}
declare const $ZodCustom: $constructor<$ZodCustom>;

interface $ZodCheckDef {
    check: string;
    error?: $ZodErrorMap<never> | undefined;
    /** If true, no later checks will be executed if this check fails. Default `false`. */
    abort?: boolean | undefined;
    /** If provided, this check will only be executed if the function returns `true`. Defaults to `payload => z.util.isAborted(payload)`. */
    when?: ((payload: ParsePayload) => boolean) | undefined;
}
interface $ZodCheckInternals<T> {
    def: $ZodCheckDef;
    /** The set of issues this check might throw. */
    issc?: $ZodIssueBase;
    check(payload: ParsePayload<T>): MaybeAsync<void>;
    onattach: ((schema: $ZodType) => void)[];
}
interface $ZodCheck<in T = never> {
    _zod: $ZodCheckInternals<T>;
}
declare const $ZodCheck: $constructor<$ZodCheck<any>>;
interface $ZodCheckLessThanDef extends $ZodCheckDef {
    check: "less_than";
    value: Numeric;
    inclusive: boolean;
}
interface $ZodCheckLessThanInternals<T extends Numeric = Numeric> extends $ZodCheckInternals<T> {
    def: $ZodCheckLessThanDef;
    issc: $ZodIssueTooBig<T>;
}
interface $ZodCheckLessThan<T extends Numeric = Numeric> extends $ZodCheck<T> {
    _zod: $ZodCheckLessThanInternals<T>;
}
declare const $ZodCheckLessThan: $constructor<$ZodCheckLessThan>;
interface $ZodCheckGreaterThanDef extends $ZodCheckDef {
    check: "greater_than";
    value: Numeric;
    inclusive: boolean;
}
interface $ZodCheckGreaterThanInternals<T extends Numeric = Numeric> extends $ZodCheckInternals<T> {
    def: $ZodCheckGreaterThanDef;
    issc: $ZodIssueTooSmall<T>;
}
interface $ZodCheckGreaterThan<T extends Numeric = Numeric> extends $ZodCheck<T> {
    _zod: $ZodCheckGreaterThanInternals<T>;
}
declare const $ZodCheckGreaterThan: $constructor<$ZodCheckGreaterThan>;
interface $ZodCheckMultipleOfDef<T extends number | bigint = number | bigint> extends $ZodCheckDef {
    check: "multiple_of";
    value: T;
}
interface $ZodCheckMultipleOfInternals<T extends number | bigint = number | bigint> extends $ZodCheckInternals<T> {
    def: $ZodCheckMultipleOfDef<T>;
    issc: $ZodIssueNotMultipleOf;
}
interface $ZodCheckMultipleOf<T extends number | bigint = number | bigint> extends $ZodCheck<T> {
    _zod: $ZodCheckMultipleOfInternals<T>;
}
declare const $ZodCheckMultipleOf: $constructor<$ZodCheckMultipleOf<number | bigint>>;
type $ZodNumberFormats = "int32" | "uint32" | "float32" | "float64" | "safeint";
interface $ZodCheckNumberFormatDef extends $ZodCheckDef {
    check: "number_format";
    format: $ZodNumberFormats;
}
interface $ZodCheckNumberFormatInternals extends $ZodCheckInternals<number> {
    def: $ZodCheckNumberFormatDef;
    issc: $ZodIssueInvalidType | $ZodIssueTooBig<"number"> | $ZodIssueTooSmall<"number">;
}
interface $ZodCheckNumberFormat extends $ZodCheck<number> {
    _zod: $ZodCheckNumberFormatInternals;
}
declare const $ZodCheckNumberFormat: $constructor<$ZodCheckNumberFormat>;
interface $ZodCheckMaxLengthDef extends $ZodCheckDef {
    check: "max_length";
    maximum: number;
}
interface $ZodCheckMaxLengthInternals<T extends HasLength = HasLength> extends $ZodCheckInternals<T> {
    def: $ZodCheckMaxLengthDef;
    issc: $ZodIssueTooBig<T>;
}
interface $ZodCheckMaxLength<T extends HasLength = HasLength> extends $ZodCheck<T> {
    _zod: $ZodCheckMaxLengthInternals<T>;
}
declare const $ZodCheckMaxLength: $constructor<$ZodCheckMaxLength>;
interface $ZodCheckMinLengthDef extends $ZodCheckDef {
    check: "min_length";
    minimum: number;
}
interface $ZodCheckMinLengthInternals<T extends HasLength = HasLength> extends $ZodCheckInternals<T> {
    def: $ZodCheckMinLengthDef;
    issc: $ZodIssueTooSmall<T>;
}
interface $ZodCheckMinLength<T extends HasLength = HasLength> extends $ZodCheck<T> {
    _zod: $ZodCheckMinLengthInternals<T>;
}
declare const $ZodCheckMinLength: $constructor<$ZodCheckMinLength>;
interface $ZodCheckLengthEqualsDef extends $ZodCheckDef {
    check: "length_equals";
    length: number;
}
interface $ZodCheckLengthEqualsInternals<T extends HasLength = HasLength> extends $ZodCheckInternals<T> {
    def: $ZodCheckLengthEqualsDef;
    issc: $ZodIssueTooBig<T> | $ZodIssueTooSmall<T>;
}
interface $ZodCheckLengthEquals<T extends HasLength = HasLength> extends $ZodCheck<T> {
    _zod: $ZodCheckLengthEqualsInternals<T>;
}
declare const $ZodCheckLengthEquals: $constructor<$ZodCheckLengthEquals>;
type $ZodStringFormats = "email" | "url" | "emoji" | "uuid" | "guid" | "nanoid" | "cuid" | "cuid2" | "ulid" | "xid" | "ksuid" | "datetime" | "date" | "time" | "duration" | "ipv4" | "ipv6" | "cidrv4" | "cidrv6" | "base64" | "base64url" | "json_string" | "e164" | "lowercase" | "uppercase" | "regex" | "jwt" | "starts_with" | "ends_with" | "includes";
interface $ZodCheckStringFormatDef<Format extends string = string> extends $ZodCheckDef {
    check: "string_format";
    format: Format;
    pattern?: RegExp | undefined;
}
interface $ZodCheckStringFormatInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckStringFormatDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckRegexDef extends $ZodCheckStringFormatDef {
    format: "regex";
    pattern: RegExp;
}
interface $ZodCheckRegexInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckRegexDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckRegex extends $ZodCheck<string> {
    _zod: $ZodCheckRegexInternals;
}
declare const $ZodCheckRegex: $constructor<$ZodCheckRegex>;
interface $ZodCheckLowerCaseDef extends $ZodCheckStringFormatDef<"lowercase"> {
}
interface $ZodCheckLowerCaseInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckLowerCaseDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckLowerCase extends $ZodCheck<string> {
    _zod: $ZodCheckLowerCaseInternals;
}
declare const $ZodCheckLowerCase: $constructor<$ZodCheckLowerCase>;
interface $ZodCheckUpperCaseDef extends $ZodCheckStringFormatDef<"uppercase"> {
}
interface $ZodCheckUpperCaseInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckUpperCaseDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckUpperCase extends $ZodCheck<string> {
    _zod: $ZodCheckUpperCaseInternals;
}
declare const $ZodCheckUpperCase: $constructor<$ZodCheckUpperCase>;
interface $ZodCheckIncludesDef extends $ZodCheckStringFormatDef<"includes"> {
    includes: string;
    position?: number | undefined;
}
interface $ZodCheckIncludesInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckIncludesDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckIncludes extends $ZodCheck<string> {
    _zod: $ZodCheckIncludesInternals;
}
declare const $ZodCheckIncludes: $constructor<$ZodCheckIncludes>;
interface $ZodCheckStartsWithDef extends $ZodCheckStringFormatDef<"starts_with"> {
    prefix: string;
}
interface $ZodCheckStartsWithInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckStartsWithDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckStartsWith extends $ZodCheck<string> {
    _zod: $ZodCheckStartsWithInternals;
}
declare const $ZodCheckStartsWith: $constructor<$ZodCheckStartsWith>;
interface $ZodCheckEndsWithDef extends $ZodCheckStringFormatDef<"ends_with"> {
    suffix: string;
}
interface $ZodCheckEndsWithInternals extends $ZodCheckInternals<string> {
    def: $ZodCheckEndsWithDef;
    issc: $ZodIssueInvalidStringFormat;
}
interface $ZodCheckEndsWith extends $ZodCheckInternals<string> {
    _zod: $ZodCheckEndsWithInternals;
}
declare const $ZodCheckEndsWith: $constructor<$ZodCheckEndsWith>;

interface $ZodIssueBase {
    readonly code?: string;
    readonly input?: unknown;
    readonly path: PropertyKey[];
    readonly message: string;
}
interface $ZodIssueInvalidType<Input = unknown> extends $ZodIssueBase {
    readonly code: "invalid_type";
    readonly expected: $ZodType["_zod"]["def"]["type"];
    readonly input: Input;
}
interface $ZodIssueTooBig<Input = unknown> extends $ZodIssueBase {
    readonly code: "too_big";
    readonly origin: "number" | "int" | "bigint" | "date" | "string" | "array" | "set" | "file" | (string & {});
    readonly maximum: number | bigint;
    readonly inclusive?: boolean;
    readonly exact?: boolean;
    readonly input: Input;
}
interface $ZodIssueTooSmall<Input = unknown> extends $ZodIssueBase {
    readonly code: "too_small";
    readonly origin: "number" | "int" | "bigint" | "date" | "string" | "array" | "set" | "file" | (string & {});
    readonly minimum: number | bigint;
    /** True if the allowable range includes the minimum */
    readonly inclusive?: boolean;
    /** True if the allowed value is fixed (e.g.` z.length(5)`), not a range (`z.minLength(5)`) */
    readonly exact?: boolean;
    readonly input: Input;
}
interface $ZodIssueInvalidStringFormat extends $ZodIssueBase {
    readonly code: "invalid_format";
    readonly format: $ZodStringFormats | (string & {});
    readonly pattern?: string;
    readonly input: string;
}
interface $ZodIssueNotMultipleOf<Input extends number | bigint = number | bigint> extends $ZodIssueBase {
    readonly code: "not_multiple_of";
    readonly divisor: number;
    readonly input: Input;
}
interface $ZodIssueUnrecognizedKeys extends $ZodIssueBase {
    readonly code: "unrecognized_keys";
    readonly keys: string[];
    readonly input: Record<string, unknown>;
}
interface $ZodIssueInvalidUnion extends $ZodIssueBase {
    readonly code: "invalid_union";
    readonly errors: $ZodIssue[][];
    readonly input: unknown;
}
interface $ZodIssueInvalidKey<Input = unknown> extends $ZodIssueBase {
    readonly code: "invalid_key";
    readonly origin: "map" | "record";
    readonly issues: $ZodIssue[];
    readonly input: Input;
}
interface $ZodIssueInvalidElement<Input = unknown> extends $ZodIssueBase {
    readonly code: "invalid_element";
    readonly origin: "map" | "set";
    readonly key: unknown;
    readonly issues: $ZodIssue[];
    readonly input: Input;
}
interface $ZodIssueInvalidValue<Input = unknown> extends $ZodIssueBase {
    readonly code: "invalid_value";
    readonly values: Primitive$1[];
    readonly input: Input;
}
interface $ZodIssueCustom extends $ZodIssueBase {
    readonly code: "custom";
    readonly params?: Record<string, any> | undefined;
    readonly input: unknown;
}
type $ZodIssue = $ZodIssueInvalidType | $ZodIssueTooBig | $ZodIssueTooSmall | $ZodIssueInvalidStringFormat | $ZodIssueNotMultipleOf | $ZodIssueUnrecognizedKeys | $ZodIssueInvalidUnion | $ZodIssueInvalidKey | $ZodIssueInvalidElement | $ZodIssueInvalidValue | $ZodIssueCustom;
type $ZodRawIssue<T extends $ZodIssueBase = $ZodIssue> = T extends any ? RawIssue<T> : never;
type RawIssue<T extends $ZodIssueBase> = Flatten$1<MakePartial<T, "message" | "path"> & {
    /** The input data */
    readonly input?: unknown;
    /** The schema or check that originated this issue. */
    readonly inst?: $ZodType | $ZodCheck;
    /** @deprecated Internal use only. If `true`, Zod will continue executing validation despite this issue. */
    readonly continue?: boolean | undefined;
} & Record<string, any>>;
interface $ZodErrorMap<T extends $ZodIssueBase = $ZodIssue> {
    (issue: $ZodRawIssue<T>): {
        message: string;
    } | string | undefined | null;
}
interface $ZodError<T = unknown> extends Error {
    type: T;
    issues: $ZodIssue[];
    _zod: {
        output: T;
        def: $ZodIssue[];
    };
    stack?: string;
    name: string;
}
declare const $ZodError: $constructor<$ZodError>;
type $ZodFlattenedError<T, U = string> = _FlattenedError<T, U>;
type _FlattenedError<T, U = string> = {
    formErrors: U[];
    fieldErrors: {
        [P in keyof T]?: U[];
    };
};
type _ZodFormattedError<T, U = string> = T extends [any, ...any[]] ? {
    [K in keyof T]?: $ZodFormattedError<T[K], U>;
} : T extends any[] ? {
    [k: number]: $ZodFormattedError<T[number], U>;
} : T extends object ? Flatten$1<{
    [K in keyof T]?: $ZodFormattedError<T[K], U>;
}> : any;
type $ZodFormattedError<T, U = string> = {
    _errors: U[];
} & Flatten$1<_ZodFormattedError<T, U>>;

type ZodTrait = {
    _zod: {
        def: any;
        [k: string]: any;
    };
};
interface $constructor<T extends ZodTrait, D = T["_zod"]["def"]> {
    new (def: D): T;
    init(inst: T, def: D): asserts inst is T;
}
declare function $constructor<T extends ZodTrait, D = T["_zod"]["def"]>(name: string, initializer: (inst: T, def: D) => void, params?: {
    Parent?: typeof Class;
}): $constructor<T, D>;
declare const $brand: unique symbol;
type $brand<T extends string | number | symbol = string | number | symbol> = {
    [$brand]: {
        [k in T]: true;
    };
};
type $ZodBranded<T extends SomeType, Brand extends string | number | symbol> = T & Record<"_zod", Record<"output", output<T> & $brand<Brand>>>;
type input<T> = T extends {
    _zod: {
        input: any;
    };
} ? Required<T["_zod"]>["input"] : unknown;
type output<T> = T extends {
    _zod: {
        output: any;
    };
} ? Required<T["_zod"]>["output"] : unknown;

declare const $output: unique symbol;
type $output = typeof $output;
declare const $input: unique symbol;
type $input = typeof $input;
type $replace<Meta, S extends $ZodType> = Meta extends $output ? output<S> : Meta extends $input ? input<S> : Meta extends (infer M)[] ? $replace<M, S>[] : Meta extends (...args: infer P) => infer R ? (...args: {
    [K in keyof P]: $replace<P[K], S>;
}) => $replace<R, S> : Meta extends object ? {
    [K in keyof Meta]: $replace<Meta[K], S>;
} : Meta;
type MetadataType = Record<string, unknown> | undefined;
declare class $ZodRegistry<Meta extends MetadataType = MetadataType, Schema extends $ZodType = $ZodType> {
    _meta: Meta;
    _schema: Schema;
    _map: Map<Schema, $replace<Meta, Schema>>;
    _idmap: Map<string, Schema>;
    add<S extends Schema>(schema: S, ..._meta: undefined extends Meta ? [$replace<Meta, S>?] : [$replace<Meta, S>]): this;
    clear(): this;
    remove(schema: Schema): this;
    get<S extends Schema>(schema: S): $replace<Meta, S> | undefined;
    has(schema: Schema): boolean;
}
interface JSONSchemaMeta {
    id?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    deprecated?: boolean | undefined;
    [k: string]: unknown;
}
interface GlobalMeta extends JSONSchemaMeta {
}

type Params<T extends $ZodType | $ZodCheck, IssueTypes extends $ZodIssueBase, OmitKeys extends keyof T["_zod"]["def"] = never> = Flatten$1<Partial<EmptyToNever<Omit<T["_zod"]["def"], OmitKeys> & ([IssueTypes] extends [never] ? {} : {
    error?: string | $ZodErrorMap<IssueTypes> | undefined;
    /** @deprecated This parameter is deprecated. Use `error` instead. */
    message?: string | undefined;
})>>>;
type TypeParams<T extends $ZodType = $ZodType & {
    _isst: never;
}, AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "checks" | "error"> = never> = Params<T, NonNullable<T["_zod"]["isst"]>, "type" | "checks" | "error" | AlsoOmit>;
type CheckParams<T extends $ZodCheck = $ZodCheck, // & { _issc: never },
AlsoOmit extends Exclude<keyof T["_zod"]["def"], "check" | "error"> = never> = Params<T, NonNullable<T["_zod"]["issc"]>, "check" | "error" | AlsoOmit>;
type CheckStringFormatParams<T extends $ZodStringFormat = $ZodStringFormat, AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "coerce" | "checks" | "error" | "check" | "format"> = never> = Params<T, NonNullable<T["_zod"]["issc"]>, "type" | "coerce" | "checks" | "error" | "check" | "format" | AlsoOmit>;
type CheckTypeParams<T extends $ZodType & $ZodCheck = $ZodType & $ZodCheck, AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "checks" | "error" | "check"> = never> = Params<T, NonNullable<T["_zod"]["isst"] | T["_zod"]["issc"]>, "type" | "checks" | "error" | "check" | AlsoOmit>;
type $ZodCheckEmailParams = CheckStringFormatParams<$ZodEmail>;
type $ZodCheckGUIDParams = CheckStringFormatParams<$ZodGUID, "pattern">;
type $ZodCheckUUIDParams = CheckStringFormatParams<$ZodUUID, "pattern">;
type $ZodCheckURLParams = CheckStringFormatParams<$ZodURL>;
type $ZodCheckEmojiParams = CheckStringFormatParams<$ZodEmoji>;
type $ZodCheckNanoIDParams = CheckStringFormatParams<$ZodNanoID>;
type $ZodCheckCUIDParams = CheckStringFormatParams<$ZodCUID>;
type $ZodCheckCUID2Params = CheckStringFormatParams<$ZodCUID2>;
type $ZodCheckULIDParams = CheckStringFormatParams<$ZodULID>;
type $ZodCheckXIDParams = CheckStringFormatParams<$ZodXID>;
type $ZodCheckKSUIDParams = CheckStringFormatParams<$ZodKSUID>;
type $ZodCheckIPv4Params = CheckStringFormatParams<$ZodIPv4, "pattern">;
type $ZodCheckIPv6Params = CheckStringFormatParams<$ZodIPv6, "pattern">;
type $ZodCheckCIDRv4Params = CheckStringFormatParams<$ZodCIDRv4, "pattern">;
type $ZodCheckCIDRv6Params = CheckStringFormatParams<$ZodCIDRv6, "pattern">;
type $ZodCheckBase64Params = CheckStringFormatParams<$ZodBase64, "pattern">;
type $ZodCheckBase64URLParams = CheckStringFormatParams<$ZodBase64URL, "pattern">;
type $ZodCheckE164Params = CheckStringFormatParams<$ZodE164>;
type $ZodCheckJWTParams = CheckStringFormatParams<$ZodJWT, "pattern">;
type $ZodCheckISODateTimeParams = CheckStringFormatParams<$ZodISODateTime, "pattern">;
type $ZodCheckISODateParams = CheckStringFormatParams<$ZodISODate, "pattern">;
type $ZodCheckISOTimeParams = CheckStringFormatParams<$ZodISOTime, "pattern">;
type $ZodCheckISODurationParams = CheckStringFormatParams<$ZodISODuration>;
type $ZodCheckNumberFormatParams = CheckParams<$ZodCheckNumberFormat, "format">;
type $ZodCheckLessThanParams = CheckParams<$ZodCheckLessThan, "inclusive" | "value">;
type $ZodCheckGreaterThanParams = CheckParams<$ZodCheckGreaterThan, "inclusive" | "value">;
type $ZodCheckMultipleOfParams = CheckParams<$ZodCheckMultipleOf, "value">;
type $ZodCheckMaxLengthParams = CheckParams<$ZodCheckMaxLength, "maximum">;
type $ZodCheckMinLengthParams = CheckParams<$ZodCheckMinLength, "minimum">;
type $ZodCheckLengthEqualsParams = CheckParams<$ZodCheckLengthEquals, "length">;
type $ZodCheckRegexParams = CheckParams<$ZodCheckRegex, "format" | "pattern">;
type $ZodCheckLowerCaseParams = CheckParams<$ZodCheckLowerCase, "format">;
type $ZodCheckUpperCaseParams = CheckParams<$ZodCheckUpperCase, "format">;
type $ZodCheckIncludesParams = CheckParams<$ZodCheckIncludes, "includes" | "format" | "pattern">;
type $ZodCheckStartsWithParams = CheckParams<$ZodCheckStartsWith, "prefix" | "format" | "pattern">;
type $ZodCheckEndsWithParams = CheckParams<$ZodCheckEndsWith, "suffix" | "format" | "pattern">;
type $ZodEnumParams = TypeParams<$ZodEnum, "entries">;
type $ZodNonOptionalParams = TypeParams<$ZodNonOptional, "innerType">;
type $ZodCustomParams = CheckTypeParams<$ZodCustom, "fn">;

type AnySchema = ZodTypeAny | $ZodType;
type AnyObjectSchema = AnyZodObject | $ZodObject | AnySchema;
type ZodRawShapeCompat = Record<string, AnySchema>;
type SchemaOutput<S> = S extends ZodTypeAny ? TypeOf<S> : S extends $ZodType ? output<S> : never;
/**
 * Infers the output type from a ZodRawShapeCompat (raw shape object).
 * Maps over each key in the shape and infers the output type from each schema.
 */
type ShapeOutput<Shape extends ZodRawShapeCompat> = {
    [K in keyof Shape]: SchemaOutput<Shape[K]>;
};

/** An Error-like class used to store Zod validation issues.  */
interface ZodError<T = unknown> extends $ZodError<T> {
    /** @deprecated Use the `z.treeifyError(err)` function instead. */
    format(): $ZodFormattedError<T>;
    format<U>(mapper: (issue: $ZodIssue) => U): $ZodFormattedError<T, U>;
    /** @deprecated Use the `z.treeifyError(err)` function instead. */
    flatten(): $ZodFlattenedError<T>;
    flatten<U>(mapper: (issue: $ZodIssue) => U): $ZodFlattenedError<T, U>;
    /** @deprecated Push directly to `.issues` instead. */
    addIssue(issue: $ZodIssue): void;
    /** @deprecated Push directly to `.issues` instead. */
    addIssues(issues: $ZodIssue[]): void;
    /** @deprecated Check `err.issues.length === 0` instead. */
    isEmpty: boolean;
}
declare const ZodError: $constructor<ZodError>;

type ZodSafeParseResult<T> = ZodSafeParseSuccess<T> | ZodSafeParseError<T>;
type ZodSafeParseSuccess<T> = {
    success: true;
    data: T;
    error?: never;
};
type ZodSafeParseError<T> = {
    success: false;
    data?: never;
    error: ZodError<T>;
};

interface RefinementCtx<T = unknown> extends ParsePayload<T> {
    addIssue(arg: string | $ZodRawIssue | Partial<$ZodIssueCustom>): void;
}
interface _ZodType<out Internals extends $ZodTypeInternals = $ZodTypeInternals> extends ZodType<any, any, Internals> {
}
interface ZodType<out Output = unknown, out Input = unknown, out Internals extends $ZodTypeInternals<Output, Input> = $ZodTypeInternals<Output, Input>> extends $ZodType<Output, Input, Internals> {
    def: Internals["def"];
    type: Internals["def"]["type"];
    /** @deprecated Use `.def` instead. */
    _def: Internals["def"];
    /** @deprecated Use `z.output<typeof schema>` instead. */
    _output: Internals["output"];
    /** @deprecated Use `z.input<typeof schema>` instead. */
    _input: Internals["input"];
    check(...checks: (CheckFn<output<this>> | $ZodCheck<output<this>>)[]): this;
    clone(def?: Internals["def"], params?: {
        parent: boolean;
    }): this;
    register<R extends $ZodRegistry>(registry: R, ...meta: this extends R["_schema"] ? undefined extends R["_meta"] ? [$replace<R["_meta"], this>?] : [$replace<R["_meta"], this>] : ["Incompatible schema"]): this;
    brand<T extends PropertyKey = PropertyKey>(value?: T): PropertyKey extends T ? this : $ZodBranded<this, T>;
    parse(data: unknown, params?: ParseContext<$ZodIssue>): output<this>;
    safeParse(data: unknown, params?: ParseContext<$ZodIssue>): ZodSafeParseResult<output<this>>;
    parseAsync(data: unknown, params?: ParseContext<$ZodIssue>): Promise<output<this>>;
    safeParseAsync(data: unknown, params?: ParseContext<$ZodIssue>): Promise<ZodSafeParseResult<output<this>>>;
    spa: (data: unknown, params?: ParseContext<$ZodIssue>) => Promise<ZodSafeParseResult<output<this>>>;
    refine(check: (arg: output<this>) => unknown | Promise<unknown>, params?: string | $ZodCustomParams): this;
    /** @deprecated Use `.check()` instead. */
    superRefine(refinement: (arg: output<this>, ctx: RefinementCtx<output<this>>) => void | Promise<void>): this;
    overwrite(fn: (x: output<this>) => output<this>): this;
    optional(): ZodOptional<this>;
    nonoptional(params?: string | $ZodNonOptionalParams): ZodNonOptional<this>;
    nullable(): ZodNullable<this>;
    nullish(): ZodOptional<ZodNullable<this>>;
    default(def: output<this>): ZodDefault<this>;
    default(def: () => NoUndefined<output<this>>): ZodDefault<this>;
    prefault(def: () => input<this>): ZodPrefault<this>;
    prefault(def: input<this>): ZodPrefault<this>;
    array(): ZodArray<this>;
    or<T extends SomeType>(option: T): ZodUnion<[this, T]>;
    and<T extends SomeType>(incoming: T): ZodIntersection<this, T>;
    transform<NewOut>(transform: (arg: output<this>, ctx: RefinementCtx<output<this>>) => NewOut | Promise<NewOut>): ZodPipe<this, ZodTransform<Awaited<NewOut>, output<this>>>;
    catch(def: output<this>): ZodCatch<this>;
    catch(def: (ctx: $ZodCatchCtx) => output<this>): ZodCatch<this>;
    pipe<T extends $ZodType<any, output<this>>>(target: T | $ZodType<any, output<this>>): ZodPipe<this, T>;
    readonly(): ZodReadonly<this>;
    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified description */
    describe(description: string): this;
    description?: string;
    /** Returns the metadata associated with this instance in `z.globalRegistry` */
    meta(): $replace<GlobalMeta, this> | undefined;
    /** Returns a new instance that has been registered in `z.globalRegistry` with the specified metadata */
    meta(data: $replace<GlobalMeta, this>): this;
    /** @deprecated Try safe-parsing `undefined` (this is what `isOptional` does internally):
     *
     * ```ts
     * const schema = z.string().optional();
     * const isOptional = schema.safeParse(undefined).success; // true
     * ```
     */
    isOptional(): boolean;
    /**
     * @deprecated Try safe-parsing `null` (this is what `isNullable` does internally):
     *
     * ```ts
     * const schema = z.string().nullable();
     * const isNullable = schema.safeParse(null).success; // true
     * ```
     */
    isNullable(): boolean;
}
declare const ZodType: $constructor<ZodType>;
interface _ZodString<T extends $ZodStringInternals<unknown> = $ZodStringInternals<unknown>> extends _ZodType<T> {
    format: string | null;
    minLength: number | null;
    maxLength: number | null;
    regex(regex: RegExp, params?: string | $ZodCheckRegexParams): this;
    includes(value: string, params?: $ZodCheckIncludesParams): this;
    startsWith(value: string, params?: string | $ZodCheckStartsWithParams): this;
    endsWith(value: string, params?: string | $ZodCheckEndsWithParams): this;
    min(minLength: number, params?: string | $ZodCheckMinLengthParams): this;
    max(maxLength: number, params?: string | $ZodCheckMaxLengthParams): this;
    length(len: number, params?: string | $ZodCheckLengthEqualsParams): this;
    nonempty(params?: string | $ZodCheckMinLengthParams): this;
    lowercase(params?: string | $ZodCheckLowerCaseParams): this;
    uppercase(params?: string | $ZodCheckUpperCaseParams): this;
    trim(): this;
    normalize(form?: "NFC" | "NFD" | "NFKC" | "NFKD" | (string & {})): this;
    toLowerCase(): this;
    toUpperCase(): this;
}
/** @internal */
declare const _ZodString: $constructor<_ZodString>;
interface ZodString extends _ZodString<$ZodStringInternals<string>> {
    /** @deprecated Use `z.email()` instead. */
    email(params?: string | $ZodCheckEmailParams): this;
    /** @deprecated Use `z.url()` instead. */
    url(params?: string | $ZodCheckURLParams): this;
    /** @deprecated Use `z.jwt()` instead. */
    jwt(params?: string | $ZodCheckJWTParams): this;
    /** @deprecated Use `z.emoji()` instead. */
    emoji(params?: string | $ZodCheckEmojiParams): this;
    /** @deprecated Use `z.guid()` instead. */
    guid(params?: string | $ZodCheckGUIDParams): this;
    /** @deprecated Use `z.uuid()` instead. */
    uuid(params?: string | $ZodCheckUUIDParams): this;
    /** @deprecated Use `z.uuid()` instead. */
    uuidv4(params?: string | $ZodCheckUUIDParams): this;
    /** @deprecated Use `z.uuid()` instead. */
    uuidv6(params?: string | $ZodCheckUUIDParams): this;
    /** @deprecated Use `z.uuid()` instead. */
    uuidv7(params?: string | $ZodCheckUUIDParams): this;
    /** @deprecated Use `z.nanoid()` instead. */
    nanoid(params?: string | $ZodCheckNanoIDParams): this;
    /** @deprecated Use `z.guid()` instead. */
    guid(params?: string | $ZodCheckGUIDParams): this;
    /** @deprecated Use `z.cuid()` instead. */
    cuid(params?: string | $ZodCheckCUIDParams): this;
    /** @deprecated Use `z.cuid2()` instead. */
    cuid2(params?: string | $ZodCheckCUID2Params): this;
    /** @deprecated Use `z.ulid()` instead. */
    ulid(params?: string | $ZodCheckULIDParams): this;
    /** @deprecated Use `z.base64()` instead. */
    base64(params?: string | $ZodCheckBase64Params): this;
    /** @deprecated Use `z.base64url()` instead. */
    base64url(params?: string | $ZodCheckBase64URLParams): this;
    /** @deprecated Use `z.xid()` instead. */
    xid(params?: string | $ZodCheckXIDParams): this;
    /** @deprecated Use `z.ksuid()` instead. */
    ksuid(params?: string | $ZodCheckKSUIDParams): this;
    /** @deprecated Use `z.ipv4()` instead. */
    ipv4(params?: string | $ZodCheckIPv4Params): this;
    /** @deprecated Use `z.ipv6()` instead. */
    ipv6(params?: string | $ZodCheckIPv6Params): this;
    /** @deprecated Use `z.cidrv4()` instead. */
    cidrv4(params?: string | $ZodCheckCIDRv4Params): this;
    /** @deprecated Use `z.cidrv6()` instead. */
    cidrv6(params?: string | $ZodCheckCIDRv6Params): this;
    /** @deprecated Use `z.e164()` instead. */
    e164(params?: string | $ZodCheckE164Params): this;
    /** @deprecated Use `z.iso.datetime()` instead. */
    datetime(params?: string | $ZodCheckISODateTimeParams): this;
    /** @deprecated Use `z.iso.date()` instead. */
    date(params?: string | $ZodCheckISODateParams): this;
    /** @deprecated Use `z.iso.time()` instead. */
    time(params?: string | $ZodCheckISOTimeParams): this;
    /** @deprecated Use `z.iso.duration()` instead. */
    duration(params?: string | $ZodCheckISODurationParams): this;
}
declare const ZodString: $constructor<ZodString>;
interface ZodStringFormat<Format extends string = string> extends _ZodString<$ZodStringFormatInternals<Format>> {
}
declare const ZodStringFormat: $constructor<ZodStringFormat>;
interface _ZodNumber<Internals extends $ZodNumberInternals = $ZodNumberInternals> extends _ZodType<Internals> {
    gt(value: number, params?: string | $ZodCheckGreaterThanParams): this;
    /** Identical to .min() */
    gte(value: number, params?: string | $ZodCheckGreaterThanParams): this;
    min(value: number, params?: string | $ZodCheckGreaterThanParams): this;
    lt(value: number, params?: string | $ZodCheckLessThanParams): this;
    /** Identical to .max() */
    lte(value: number, params?: string | $ZodCheckLessThanParams): this;
    max(value: number, params?: string | $ZodCheckLessThanParams): this;
    /** Consider `z.int()` instead. This API is considered *legacy*; it will never be removed but a better alternative exists. */
    int(params?: string | $ZodCheckNumberFormatParams): this;
    /** @deprecated This is now identical to `.int()`. Only numbers in the safe integer range are accepted. */
    safe(params?: string | $ZodCheckNumberFormatParams): this;
    positive(params?: string | $ZodCheckGreaterThanParams): this;
    nonnegative(params?: string | $ZodCheckGreaterThanParams): this;
    negative(params?: string | $ZodCheckLessThanParams): this;
    nonpositive(params?: string | $ZodCheckLessThanParams): this;
    multipleOf(value: number, params?: string | $ZodCheckMultipleOfParams): this;
    /** @deprecated Use `.multipleOf()` instead. */
    step(value: number, params?: string | $ZodCheckMultipleOfParams): this;
    /** @deprecated In v4 and later, z.number() does not allow infinite values by default. This is a no-op. */
    finite(params?: unknown): this;
    minValue: number | null;
    maxValue: number | null;
    /** @deprecated Check the `format` property instead.  */
    isInt: boolean;
    /** @deprecated Number schemas no longer accept infinite values, so this always returns `true`. */
    isFinite: boolean;
    format: string | null;
}
interface ZodNumber extends _ZodNumber<$ZodNumberInternals<number>> {
}
declare const ZodNumber: $constructor<ZodNumber>;
interface _ZodBoolean<T extends $ZodBooleanInternals = $ZodBooleanInternals> extends _ZodType<T> {
}
interface ZodBoolean extends _ZodBoolean<$ZodBooleanInternals<boolean>> {
}
declare const ZodBoolean: $constructor<ZodBoolean>;
interface ZodNull extends _ZodType<$ZodNullInternals> {
}
declare const ZodNull: $constructor<ZodNull>;
interface ZodUnknown extends _ZodType<$ZodUnknownInternals> {
}
declare const ZodUnknown: $constructor<ZodUnknown>;
interface ZodArray<T extends SomeType = $ZodType> extends _ZodType<$ZodArrayInternals<T>>, $ZodArray<T> {
    element: T;
    min(minLength: number, params?: string | $ZodCheckMinLengthParams): this;
    nonempty(params?: string | $ZodCheckMinLengthParams): this;
    max(maxLength: number, params?: string | $ZodCheckMaxLengthParams): this;
    length(len: number, params?: string | $ZodCheckLengthEqualsParams): this;
    unwrap(): T;
}
declare const ZodArray: $constructor<ZodArray>;
interface ZodObject<
/** @ts-ignore Cast variance */
out Shape extends $ZodShape = $ZodLooseShape, out Config extends $ZodObjectConfig = $strip> extends _ZodType<$ZodObjectInternals<Shape, Config>>, $ZodObject<Shape, Config> {
    shape: Shape;
    keyof(): ZodEnum<ToEnum<keyof Shape & string>>;
    /** Define a schema to validate all unrecognized keys. This overrides the existing strict/loose behavior. */
    catchall<T extends SomeType>(schema: T): ZodObject<Shape, $catchall<T>>;
    /** @deprecated Use `z.looseObject()` or `.loose()` instead. */
    passthrough(): ZodObject<Shape, $loose>;
    /** Consider `z.looseObject(A.shape)` instead */
    loose(): ZodObject<Shape, $loose>;
    /** Consider `z.strictObject(A.shape)` instead */
    strict(): ZodObject<Shape, $strict>;
    /** This is the default behavior. This method call is likely unnecessary. */
    strip(): ZodObject<Shape, $strip>;
    extend<U extends $ZodLooseShape & Partial<Record<keyof Shape, SomeType>>>(shape: U): ZodObject<Extend<Shape, U>, Config>;
    /**
     * @deprecated Use spread syntax and the `.shape` property to combine two object schemas:
     *
     * ```ts
     * const A = z.object({ a: z.string() });
     * const B = z.object({ b: z.number() });
     *
     * const C = z.object({
     *    ...A.shape,
     *    ...B.shape
     * });
     * ```
     */
    merge<U extends ZodObject>(other: U): ZodObject<Extend<Shape, U["shape"]>, U["_zod"]["config"]>;
    pick<M extends Mask$1<keyof Shape>>(mask: M): ZodObject<Flatten$1<Pick<Shape, Extract<keyof Shape, keyof M>>>, Config>;
    omit<M extends Mask$1<keyof Shape>>(mask: M): ZodObject<Flatten$1<Omit<Shape, Extract<keyof Shape, keyof M>>>, Config>;
    partial(): ZodObject<{
        [k in keyof Shape]: ZodOptional<Shape[k]>;
    }, Config>;
    partial<M extends Mask$1<keyof Shape>>(mask: M): ZodObject<{
        [k in keyof Shape]: k extends keyof M ? ZodOptional<Shape[k]> : Shape[k];
    }, Config>;
    required(): ZodObject<{
        [k in keyof Shape]: ZodNonOptional<Shape[k]>;
    }, Config>;
    required<M extends Mask$1<keyof Shape>>(mask: M): ZodObject<{
        [k in keyof Shape]: k extends keyof M ? ZodNonOptional<Shape[k]> : Shape[k];
    }, Config>;
}
declare const ZodObject: $constructor<ZodObject>;
interface ZodUnion<T extends readonly SomeType[] = readonly $ZodType[]> extends _ZodType<$ZodUnionInternals<T>>, $ZodUnion<T> {
    options: T;
}
declare const ZodUnion: $constructor<ZodUnion>;
interface ZodDiscriminatedUnion<Options extends readonly SomeType[] = readonly $ZodType[]> extends ZodUnion<Options>, $ZodDiscriminatedUnion<Options> {
    _zod: $ZodDiscriminatedUnionInternals<Options>;
}
declare const ZodDiscriminatedUnion: $constructor<ZodDiscriminatedUnion>;
interface ZodIntersection<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends _ZodType<$ZodIntersectionInternals<A, B>>, $ZodIntersection<A, B> {
}
declare const ZodIntersection: $constructor<ZodIntersection>;
interface ZodRecord<Key extends $ZodRecordKey = $ZodRecordKey, Value extends SomeType = $ZodType> extends _ZodType<$ZodRecordInternals<Key, Value>>, $ZodRecord<Key, Value> {
    keyType: Key;
    valueType: Value;
}
declare const ZodRecord: $constructor<ZodRecord>;
interface ZodEnum<
/** @ts-ignore Cast variance */
out T extends EnumLike = EnumLike> extends _ZodType<$ZodEnumInternals<T>>, $ZodEnum<T> {
    enum: T;
    options: Array<T[keyof T]>;
    extract<const U extends readonly (keyof T)[]>(values: U, params?: string | $ZodEnumParams): ZodEnum<Flatten$1<Pick<T, U[number]>>>;
    exclude<const U extends readonly (keyof T)[]>(values: U, params?: string | $ZodEnumParams): ZodEnum<Flatten$1<Omit<T, U[number]>>>;
}
declare const ZodEnum: $constructor<ZodEnum>;
interface ZodLiteral<T extends Literal = Literal> extends _ZodType<$ZodLiteralInternals<T>>, $ZodLiteral<T> {
    values: Set<T>;
    /** @legacy Use `.values` instead. Accessing this property will throw an error if the literal accepts multiple values. */
    value: T;
}
declare const ZodLiteral: $constructor<ZodLiteral>;
interface ZodTransform<O = unknown, I = unknown> extends _ZodType<$ZodTransformInternals<O, I>>, $ZodTransform<O, I> {
}
declare const ZodTransform: $constructor<ZodTransform>;
interface ZodOptional<T extends SomeType = $ZodType> extends _ZodType<$ZodOptionalInternals<T>>, $ZodOptional<T> {
    unwrap(): T;
}
declare const ZodOptional: $constructor<ZodOptional>;
interface ZodNullable<T extends SomeType = $ZodType> extends _ZodType<$ZodNullableInternals<T>>, $ZodNullable<T> {
    unwrap(): T;
}
declare const ZodNullable: $constructor<ZodNullable>;
interface ZodDefault<T extends SomeType = $ZodType> extends _ZodType<$ZodDefaultInternals<T>>, $ZodDefault<T> {
    unwrap(): T;
    /** @deprecated Use `.unwrap()` instead. */
    removeDefault(): T;
}
declare const ZodDefault: $constructor<ZodDefault>;
interface ZodPrefault<T extends SomeType = $ZodType> extends _ZodType<$ZodPrefaultInternals<T>>, $ZodPrefault<T> {
    unwrap(): T;
}
declare const ZodPrefault: $constructor<ZodPrefault>;
interface ZodNonOptional<T extends SomeType = $ZodType> extends _ZodType<$ZodNonOptionalInternals<T>>, $ZodNonOptional<T> {
    unwrap(): T;
}
declare const ZodNonOptional: $constructor<ZodNonOptional>;
interface ZodCatch<T extends SomeType = $ZodType> extends _ZodType<$ZodCatchInternals<T>>, $ZodCatch<T> {
    unwrap(): T;
    /** @deprecated Use `.unwrap()` instead. */
    removeCatch(): T;
}
declare const ZodCatch: $constructor<ZodCatch>;
interface ZodPipe<A extends SomeType = $ZodType, B extends SomeType = $ZodType> extends _ZodType<$ZodPipeInternals<A, B>>, $ZodPipe<A, B> {
    in: A;
    out: B;
}
declare const ZodPipe: $constructor<ZodPipe>;
interface ZodReadonly<T extends SomeType = $ZodType> extends _ZodType<$ZodReadonlyInternals<T>>, $ZodReadonly<T> {
}
declare const ZodReadonly: $constructor<ZodReadonly>;
interface ZodCustom<O = unknown, I = unknown> extends _ZodType<$ZodCustomInternals<O, I>>, $ZodCustom<O, I> {
}
declare const ZodCustom: $constructor<ZodCustom>;

interface ZodISODateTime extends ZodStringFormat {
    _zod: $ZodISODateTimeInternals;
}
declare const ZodISODateTime: $constructor<ZodISODateTime>;

/**
 * Information about a validated access token, provided to request handlers.
 */
interface AuthInfo {
    /**
     * The access token.
     */
    token: string;
    /**
     * The client ID associated with this token.
     */
    clientId: string;
    /**
     * Scopes associated with this token.
     */
    scopes: string[];
    /**
     * When the token expires (in seconds since epoch).
     */
    expiresAt?: number;
    /**
     * The RFC 8707 resource server identifier for which this token is valid.
     * If set, this MUST match the MCP server's resource identifier (minus hash fragment).
     */
    resource?: URL;
    /**
     * Additional data associated with the token.
     * This field should be used for any additional data that needs to be attached to the auth info.
     */
    extra?: Record<string, unknown>;
}

/**
 * Task creation parameters, used to ask that the server create a task to represent a request.
 */
declare const TaskCreationParamsSchema: ZodObject<{
    /**
     * Time in milliseconds to keep task results available after completion.
     * If null, the task has unlimited lifetime until manually cleaned up.
     */
    ttl: ZodOptional<ZodUnion<readonly [ZodNumber, ZodNull]>>;
    /**
     * Time in milliseconds to wait between task status requests.
     */
    pollInterval: ZodOptional<ZodNumber>;
}, $loose>;
/**
 * Metadata for associating messages with a task.
 * Include this in the `_meta` field under the key `io.modelcontextprotocol/related-task`.
 */
declare const RelatedTaskMetadataSchema: ZodObject<{
    taskId: ZodString;
}, $strip>;
declare const RequestMetaSchema: ZodObject<{
    /**
     * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
     */
    progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
    /**
     * If specified, this request is related to the provided task.
     */
    "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
        taskId: ZodString;
    }, $strip>>;
}, $loose>;
declare const RequestSchema: ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>>;
}, $strip>;
declare const NotificationSchema: ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>>;
}, $strip>;
declare const ResultSchema: ZodObject<{
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
}, $loose>;
/**
 * A uniquely identifying ID for a request in JSON-RPC.
 */
declare const RequestIdSchema: ZodUnion<readonly [ZodString, ZodNumber]>;
/**
 * A request that expects a response.
 */
declare const JSONRPCRequestSchema: ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>>;
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<readonly [ZodString, ZodNumber]>;
}, $strict>;
/**
 * A notification which does not expect a response.
 */
declare const JSONRPCNotificationSchema: ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>>;
    jsonrpc: ZodLiteral<"2.0">;
}, $strict>;
/**
 * A successful (non-error) response to a request.
 */
declare const JSONRPCResultResponseSchema: ZodObject<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<readonly [ZodString, ZodNumber]>;
    result: ZodObject<{
        /**
         * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
         * for notes on _meta usage.
         */
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>;
}, $strict>;
/**
 * A response to a request that indicates an error occurred.
 */
declare const JSONRPCErrorResponseSchema: ZodObject<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
    error: ZodObject<{
        code: ZodNumber;
        message: ZodString;
        data: ZodOptional<ZodUnknown>;
    }, $strip>;
}, $strict>;
declare const JSONRPCMessageSchema: ZodUnion<readonly [ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>>;
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<readonly [ZodString, ZodNumber]>;
}, $strict>, ZodObject<{
    method: ZodString;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>>;
    jsonrpc: ZodLiteral<"2.0">;
}, $strict>, ZodObject<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodUnion<readonly [ZodString, ZodNumber]>;
    result: ZodObject<{
        /**
         * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
         * for notes on _meta usage.
         */
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $loose>;
}, $strict>, ZodObject<{
    jsonrpc: ZodLiteral<"2.0">;
    id: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
    error: ZodObject<{
        code: ZodNumber;
        message: ZodString;
        data: ZodOptional<ZodUnknown>;
    }, $strip>;
}, $strict>]>;
/**
 * Describes the name and version of an MCP implementation.
 */
declare const ImplementationSchema: ZodObject<{
    version: ZodString;
    websiteUrl: ZodOptional<ZodString>;
    description: ZodOptional<ZodString>;
    icons: ZodOptional<ZodArray<ZodObject<{
        src: ZodString;
        mimeType: ZodOptional<ZodString>;
        sizes: ZodOptional<ZodArray<ZodString>>;
        theme: ZodOptional<ZodEnum<{
            light: "light";
            dark: "dark";
        }>>;
    }, $strip>>>;
    name: ZodString;
    title: ZodOptional<ZodString>;
}, $strip>;
/**
 * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
 */
declare const ClientCapabilitiesSchema: ZodObject<{
    experimental: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
    sampling: ZodOptional<ZodObject<{
        context: ZodOptional<ZodCustom<object, object>>;
        tools: ZodOptional<ZodCustom<object, object>>;
    }, $strip>>;
    elicitation: ZodOptional<ZodPipe<ZodTransform<unknown, unknown>, ZodIntersection<ZodObject<{
        form: ZodOptional<ZodIntersection<ZodObject<{
            applyDefaults: ZodOptional<ZodBoolean>;
        }, $strip>, ZodRecord<ZodString, ZodUnknown>>>;
        url: ZodOptional<ZodCustom<object, object>>;
    }, $strip>, ZodOptional<ZodRecord<ZodString, ZodUnknown>>>>>;
    roots: ZodOptional<ZodObject<{
        listChanged: ZodOptional<ZodBoolean>;
    }, $strip>>;
    tasks: ZodOptional<ZodObject<{
        /**
         * Present if the client supports listing tasks.
         */
        list: ZodOptional<ZodCustom<object, object>>;
        /**
         * Present if the client supports cancelling tasks.
         */
        cancel: ZodOptional<ZodCustom<object, object>>;
        /**
         * Capabilities for task creation on specific request types.
         */
        requests: ZodOptional<ZodObject<{
            /**
             * Task support for sampling requests.
             */
            sampling: ZodOptional<ZodObject<{
                createMessage: ZodOptional<ZodCustom<object, object>>;
            }, $loose>>;
            /**
             * Task support for elicitation requests.
             */
            elicitation: ZodOptional<ZodObject<{
                create: ZodOptional<ZodCustom<object, object>>;
            }, $loose>>;
        }, $loose>>;
    }, $loose>>;
}, $strip>;
/**
 * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
 */
declare const ServerCapabilitiesSchema: ZodObject<{
    experimental: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
    logging: ZodOptional<ZodCustom<object, object>>;
    completions: ZodOptional<ZodCustom<object, object>>;
    prompts: ZodOptional<ZodObject<{
        listChanged: ZodOptional<ZodBoolean>;
    }, $strip>>;
    resources: ZodOptional<ZodObject<{
        subscribe: ZodOptional<ZodBoolean>;
        listChanged: ZodOptional<ZodBoolean>;
    }, $strip>>;
    tools: ZodOptional<ZodObject<{
        listChanged: ZodOptional<ZodBoolean>;
    }, $strip>>;
    tasks: ZodOptional<ZodObject<{
        /**
         * Present if the server supports listing tasks.
         */
        list: ZodOptional<ZodCustom<object, object>>;
        /**
         * Present if the server supports cancelling tasks.
         */
        cancel: ZodOptional<ZodCustom<object, object>>;
        /**
         * Capabilities for task creation on specific request types.
         */
        requests: ZodOptional<ZodObject<{
            /**
             * Task support for tool requests.
             */
            tools: ZodOptional<ZodObject<{
                call: ZodOptional<ZodCustom<object, object>>;
            }, $loose>>;
        }, $loose>>;
    }, $loose>>;
}, $strip>;
declare const ProgressSchema: ZodObject<{
    progress: ZodNumber;
    total: ZodOptional<ZodNumber>;
    message: ZodOptional<ZodString>;
}, $strip>;
/**
 * A pollable state object associated with a request.
 */
declare const TaskSchema: ZodObject<{
    taskId: ZodString;
    status: ZodEnum<{
        working: "working";
        input_required: "input_required";
        completed: "completed";
        failed: "failed";
        cancelled: "cancelled";
    }>;
    ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
    createdAt: ZodString;
    lastUpdatedAt: ZodString;
    pollInterval: ZodOptional<ZodNumber>;
    statusMessage: ZodOptional<ZodString>;
}, $strip>;
/**
 * Result returned when a task is created, containing the task data wrapped in a task field.
 */
declare const CreateTaskResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    task: ZodObject<{
        taskId: ZodString;
        status: ZodEnum<{
            working: "working";
            input_required: "input_required";
            completed: "completed";
            failed: "failed";
            cancelled: "cancelled";
        }>;
        ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
        createdAt: ZodString;
        lastUpdatedAt: ZodString;
        pollInterval: ZodOptional<ZodNumber>;
        statusMessage: ZodOptional<ZodString>;
    }, $strip>;
}, $loose>;
/**
 * A request to get the state of a specific task.
 */
declare const GetTaskRequestSchema: ZodObject<{
    method: ZodLiteral<"tasks/get">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        taskId: ZodString;
    }, $strip>;
}, $strip>;
/**
 * The response to a tasks/get request.
 */
declare const GetTaskResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    taskId: ZodString;
    status: ZodEnum<{
        working: "working";
        input_required: "input_required";
        completed: "completed";
        failed: "failed";
        cancelled: "cancelled";
    }>;
    ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
    createdAt: ZodString;
    lastUpdatedAt: ZodString;
    pollInterval: ZodOptional<ZodNumber>;
    statusMessage: ZodOptional<ZodString>;
}, $strip>;
/**
 * A request to get the result of a specific task.
 */
declare const GetTaskPayloadRequestSchema: ZodObject<{
    method: ZodLiteral<"tasks/result">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        taskId: ZodString;
    }, $strip>;
}, $strip>;
/**
 * The response to a tasks/list request.
 */
declare const ListTasksResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    tasks: ZodArray<ZodObject<{
        taskId: ZodString;
        status: ZodEnum<{
            working: "working";
            input_required: "input_required";
            completed: "completed";
            failed: "failed";
            cancelled: "cancelled";
        }>;
        ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
        createdAt: ZodString;
        lastUpdatedAt: ZodString;
        pollInterval: ZodOptional<ZodNumber>;
        statusMessage: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>;
/**
 * The response to a tasks/cancel request.
 */
declare const CancelTaskResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    taskId: ZodString;
    status: ZodEnum<{
        working: "working";
        input_required: "input_required";
        completed: "completed";
        failed: "failed";
        cancelled: "cancelled";
    }>;
    ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
    createdAt: ZodString;
    lastUpdatedAt: ZodString;
    pollInterval: ZodOptional<ZodNumber>;
    statusMessage: ZodOptional<ZodString>;
}, $strip>;
/**
 * A known resource that the server is capable of reading.
 */
declare const ResourceSchema: ZodObject<{
    uri: ZodString;
    description: ZodOptional<ZodString>;
    mimeType: ZodOptional<ZodString>;
    annotations: ZodOptional<ZodObject<{
        audience: ZodOptional<ZodArray<ZodEnum<{
            user: "user";
            assistant: "assistant";
        }>>>;
        priority: ZodOptional<ZodNumber>;
        lastModified: ZodOptional<ZodISODateTime>;
    }, $strip>>;
    _meta: ZodOptional<ZodObject<{}, $loose>>;
    icons: ZodOptional<ZodArray<ZodObject<{
        src: ZodString;
        mimeType: ZodOptional<ZodString>;
        sizes: ZodOptional<ZodArray<ZodString>>;
        theme: ZodOptional<ZodEnum<{
            light: "light";
            dark: "dark";
        }>>;
    }, $strip>>>;
    name: ZodString;
    title: ZodOptional<ZodString>;
}, $strip>;
/**
 * The server's response to a resources/list request from the client.
 */
declare const ListResourcesResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    resources: ZodArray<ZodObject<{
        uri: ZodString;
        description: ZodOptional<ZodString>;
        mimeType: ZodOptional<ZodString>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodObject<{}, $loose>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>;
/**
 * The server's response to a resources/read request from the client.
 */
declare const ReadResourceResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    contents: ZodArray<ZodUnion<readonly [ZodObject<{
        uri: ZodString;
        mimeType: ZodOptional<ZodString>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        text: ZodString;
    }, $strip>, ZodObject<{
        uri: ZodString;
        mimeType: ZodOptional<ZodString>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        blob: ZodString;
    }, $strip>]>>;
}, $loose>;
/**
 * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
 */
declare const ResourceUpdatedNotificationSchema: ZodObject<{
    method: ZodLiteral<"notifications/resources/updated">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        uri: ZodString;
    }, $strip>;
}, $strip>;
/**
 * The server's response to a prompts/get request from the client.
 */
declare const GetPromptResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<{
            user: "user";
            assistant: "assistant";
        }>;
        content: ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            uri: ZodString;
            description: ZodOptional<ZodString>;
            mimeType: ZodOptional<ZodString>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodObject<{}, $loose>>;
            icons: ZodOptional<ZodArray<ZodObject<{
                src: ZodString;
                mimeType: ZodOptional<ZodString>;
                sizes: ZodOptional<ZodArray<ZodString>>;
                theme: ZodOptional<ZodEnum<{
                    light: "light";
                    dark: "dark";
                }>>;
            }, $strip>>>;
            name: ZodString;
            title: ZodOptional<ZodString>;
            type: ZodLiteral<"resource_link">;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<readonly [ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                text: ZodString;
            }, $strip>, ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                blob: ZodString;
            }, $strip>]>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>]>;
    }, $strip>>;
}, $loose>;
/**
 * Additional properties describing a Tool to clients.
 *
 * NOTE: all properties in ToolAnnotations are **hints**.
 * They are not guaranteed to provide a faithful description of
 * tool behavior (including descriptive properties like `title`).
 *
 * Clients should never make tool use decisions based on ToolAnnotations
 * received from untrusted servers.
 */
declare const ToolAnnotationsSchema: ZodObject<{
    title: ZodOptional<ZodString>;
    readOnlyHint: ZodOptional<ZodBoolean>;
    destructiveHint: ZodOptional<ZodBoolean>;
    idempotentHint: ZodOptional<ZodBoolean>;
    openWorldHint: ZodOptional<ZodBoolean>;
}, $strip>;
/**
 * Execution-related properties for a tool.
 */
declare const ToolExecutionSchema: ZodObject<{
    taskSupport: ZodOptional<ZodEnum<{
        optional: "optional";
        required: "required";
        forbidden: "forbidden";
    }>>;
}, $strip>;
/**
 * Definition for a tool the client can call.
 */
declare const ToolSchema: ZodObject<{
    description: ZodOptional<ZodString>;
    inputSchema: ZodObject<{
        type: ZodLiteral<"object">;
        properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
        required: ZodOptional<ZodArray<ZodString>>;
    }, $catchall<ZodUnknown>>;
    outputSchema: ZodOptional<ZodObject<{
        type: ZodLiteral<"object">;
        properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
        required: ZodOptional<ZodArray<ZodString>>;
    }, $catchall<ZodUnknown>>>;
    annotations: ZodOptional<ZodObject<{
        title: ZodOptional<ZodString>;
        readOnlyHint: ZodOptional<ZodBoolean>;
        destructiveHint: ZodOptional<ZodBoolean>;
        idempotentHint: ZodOptional<ZodBoolean>;
        openWorldHint: ZodOptional<ZodBoolean>;
    }, $strip>>;
    execution: ZodOptional<ZodObject<{
        taskSupport: ZodOptional<ZodEnum<{
            optional: "optional";
            required: "required";
            forbidden: "forbidden";
        }>>;
    }, $strip>>;
    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    icons: ZodOptional<ZodArray<ZodObject<{
        src: ZodString;
        mimeType: ZodOptional<ZodString>;
        sizes: ZodOptional<ZodArray<ZodString>>;
        theme: ZodOptional<ZodEnum<{
            light: "light";
            dark: "dark";
        }>>;
    }, $strip>>>;
    name: ZodString;
    title: ZodOptional<ZodString>;
}, $strip>;
/**
 * The server's response to a tool call.
 */
declare const CallToolResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
        type: ZodLiteral<"text">;
        text: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"image">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"audio">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        uri: ZodString;
        description: ZodOptional<ZodString>;
        mimeType: ZodOptional<ZodString>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodObject<{}, $loose>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
        type: ZodLiteral<"resource_link">;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<readonly [ZodObject<{
            uri: ZodString;
            mimeType: ZodOptional<ZodString>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            text: ZodString;
        }, $strip>, ZodObject<{
            uri: ZodString;
            mimeType: ZodOptional<ZodString>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            blob: ZodString;
        }, $strip>]>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>]>>>;
    structuredContent: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    isError: ZodOptional<ZodBoolean>;
}, $loose>;
/**
 * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
 */
declare const LoggingMessageNotificationSchema: ZodObject<{
    method: ZodLiteral<"notifications/message">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        level: ZodEnum<{
            error: "error";
            debug: "debug";
            info: "info";
            notice: "notice";
            warning: "warning";
            critical: "critical";
            alert: "alert";
            emergency: "emergency";
        }>;
        logger: ZodOptional<ZodString>;
        data: ZodUnknown;
    }, $strip>;
}, $strip>;
/**
 * Parameters for a `sampling/createMessage` request.
 */
declare const CreateMessageRequestParamsSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    task: ZodOptional<ZodObject<{
        ttl: ZodOptional<ZodNumber>;
    }, $strip>>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<{
            user: "user";
            assistant: "assistant";
        }>;
        content: ZodUnion<readonly [ZodDiscriminatedUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"tool_use">;
            name: ZodString;
            id: ZodString;
            input: ZodRecord<ZodString, ZodUnknown>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"tool_result">;
            toolUseId: ZodString;
            content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
                type: ZodLiteral<"text">;
                text: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"image">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"audio">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                uri: ZodString;
                description: ZodOptional<ZodString>;
                mimeType: ZodOptional<ZodString>;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodObject<{}, $loose>>;
                icons: ZodOptional<ZodArray<ZodObject<{
                    src: ZodString;
                    mimeType: ZodOptional<ZodString>;
                    sizes: ZodOptional<ZodArray<ZodString>>;
                    theme: ZodOptional<ZodEnum<{
                        light: "light";
                        dark: "dark";
                    }>>;
                }, $strip>>>;
                name: ZodString;
                title: ZodOptional<ZodString>;
                type: ZodLiteral<"resource_link">;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"resource">;
                resource: ZodUnion<readonly [ZodObject<{
                    uri: ZodString;
                    mimeType: ZodOptional<ZodString>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                    text: ZodString;
                }, $strip>, ZodObject<{
                    uri: ZodString;
                    mimeType: ZodOptional<ZodString>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                    blob: ZodString;
                }, $strip>]>;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>]>>>;
            structuredContent: ZodOptional<ZodObject<{}, $loose>>;
            isError: ZodOptional<ZodBoolean>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>]>, ZodArray<ZodDiscriminatedUnion<[ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"tool_use">;
            name: ZodString;
            id: ZodString;
            input: ZodRecord<ZodString, ZodUnknown>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"tool_result">;
            toolUseId: ZodString;
            content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
                type: ZodLiteral<"text">;
                text: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"image">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"audio">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                uri: ZodString;
                description: ZodOptional<ZodString>;
                mimeType: ZodOptional<ZodString>;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodObject<{}, $loose>>;
                icons: ZodOptional<ZodArray<ZodObject<{
                    src: ZodString;
                    mimeType: ZodOptional<ZodString>;
                    sizes: ZodOptional<ZodArray<ZodString>>;
                    theme: ZodOptional<ZodEnum<{
                        light: "light";
                        dark: "dark";
                    }>>;
                }, $strip>>>;
                name: ZodString;
                title: ZodOptional<ZodString>;
                type: ZodLiteral<"resource_link">;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"resource">;
                resource: ZodUnion<readonly [ZodObject<{
                    uri: ZodString;
                    mimeType: ZodOptional<ZodString>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                    text: ZodString;
                }, $strip>, ZodObject<{
                    uri: ZodString;
                    mimeType: ZodOptional<ZodString>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                    blob: ZodString;
                }, $strip>]>;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>]>>>;
            structuredContent: ZodOptional<ZodObject<{}, $loose>>;
            isError: ZodOptional<ZodBoolean>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>]>>]>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>>;
    modelPreferences: ZodOptional<ZodObject<{
        hints: ZodOptional<ZodArray<ZodObject<{
            name: ZodOptional<ZodString>;
        }, $strip>>>;
        costPriority: ZodOptional<ZodNumber>;
        speedPriority: ZodOptional<ZodNumber>;
        intelligencePriority: ZodOptional<ZodNumber>;
    }, $strip>>;
    systemPrompt: ZodOptional<ZodString>;
    includeContext: ZodOptional<ZodEnum<{
        none: "none";
        thisServer: "thisServer";
        allServers: "allServers";
    }>>;
    temperature: ZodOptional<ZodNumber>;
    maxTokens: ZodNumber;
    stopSequences: ZodOptional<ZodArray<ZodString>>;
    metadata: ZodOptional<ZodCustom<object, object>>;
    tools: ZodOptional<ZodArray<ZodObject<{
        description: ZodOptional<ZodString>;
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
            required: ZodOptional<ZodArray<ZodString>>;
        }, $catchall<ZodUnknown>>;
        outputSchema: ZodOptional<ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
            required: ZodOptional<ZodArray<ZodString>>;
        }, $catchall<ZodUnknown>>>;
        annotations: ZodOptional<ZodObject<{
            title: ZodOptional<ZodString>;
            readOnlyHint: ZodOptional<ZodBoolean>;
            destructiveHint: ZodOptional<ZodBoolean>;
            idempotentHint: ZodOptional<ZodBoolean>;
            openWorldHint: ZodOptional<ZodBoolean>;
        }, $strip>>;
        execution: ZodOptional<ZodObject<{
            taskSupport: ZodOptional<ZodEnum<{
                optional: "optional";
                required: "required";
                forbidden: "forbidden";
            }>>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>>>;
    toolChoice: ZodOptional<ZodObject<{
        mode: ZodOptional<ZodEnum<{
            required: "required";
            auto: "auto";
            none: "none";
        }>>;
    }, $strip>>;
}, $strip>;
/**
 * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
 */
declare const CreateMessageRequestSchema: ZodObject<{
    method: ZodLiteral<"sampling/createMessage">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        task: ZodOptional<ZodObject<{
            ttl: ZodOptional<ZodNumber>;
        }, $strip>>;
        messages: ZodArray<ZodObject<{
            role: ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>;
            content: ZodUnion<readonly [ZodDiscriminatedUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                text: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"image">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"audio">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_use">;
                name: ZodString;
                id: ZodString;
                input: ZodRecord<ZodString, ZodUnknown>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_result">;
                toolUseId: ZodString;
                content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
                    type: ZodLiteral<"text">;
                    text: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"image">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"audio">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    uri: ZodString;
                    description: ZodOptional<ZodString>;
                    mimeType: ZodOptional<ZodString>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodObject<{}, $loose>>;
                    icons: ZodOptional<ZodArray<ZodObject<{
                        src: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        sizes: ZodOptional<ZodArray<ZodString>>;
                        theme: ZodOptional<ZodEnum<{
                            light: "light";
                            dark: "dark";
                        }>>;
                    }, $strip>>>;
                    name: ZodString;
                    title: ZodOptional<ZodString>;
                    type: ZodLiteral<"resource_link">;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"resource">;
                    resource: ZodUnion<readonly [ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        text: ZodString;
                    }, $strip>, ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        blob: ZodString;
                    }, $strip>]>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>]>>>;
                structuredContent: ZodOptional<ZodObject<{}, $loose>>;
                isError: ZodOptional<ZodBoolean>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>]>, ZodArray<ZodDiscriminatedUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                text: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"image">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"audio">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_use">;
                name: ZodString;
                id: ZodString;
                input: ZodRecord<ZodString, ZodUnknown>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_result">;
                toolUseId: ZodString;
                content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
                    type: ZodLiteral<"text">;
                    text: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"image">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"audio">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    uri: ZodString;
                    description: ZodOptional<ZodString>;
                    mimeType: ZodOptional<ZodString>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodObject<{}, $loose>>;
                    icons: ZodOptional<ZodArray<ZodObject<{
                        src: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        sizes: ZodOptional<ZodArray<ZodString>>;
                        theme: ZodOptional<ZodEnum<{
                            light: "light";
                            dark: "dark";
                        }>>;
                    }, $strip>>>;
                    name: ZodString;
                    title: ZodOptional<ZodString>;
                    type: ZodLiteral<"resource_link">;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"resource">;
                    resource: ZodUnion<readonly [ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        text: ZodString;
                    }, $strip>, ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        blob: ZodString;
                    }, $strip>]>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>]>>>;
                structuredContent: ZodOptional<ZodObject<{}, $loose>>;
                isError: ZodOptional<ZodBoolean>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>]>>]>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>>;
        modelPreferences: ZodOptional<ZodObject<{
            hints: ZodOptional<ZodArray<ZodObject<{
                name: ZodOptional<ZodString>;
            }, $strip>>>;
            costPriority: ZodOptional<ZodNumber>;
            speedPriority: ZodOptional<ZodNumber>;
            intelligencePriority: ZodOptional<ZodNumber>;
        }, $strip>>;
        systemPrompt: ZodOptional<ZodString>;
        includeContext: ZodOptional<ZodEnum<{
            none: "none";
            thisServer: "thisServer";
            allServers: "allServers";
        }>>;
        temperature: ZodOptional<ZodNumber>;
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString>>;
        metadata: ZodOptional<ZodCustom<object, object>>;
        tools: ZodOptional<ZodArray<ZodObject<{
            description: ZodOptional<ZodString>;
            inputSchema: ZodObject<{
                type: ZodLiteral<"object">;
                properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
                required: ZodOptional<ZodArray<ZodString>>;
            }, $catchall<ZodUnknown>>;
            outputSchema: ZodOptional<ZodObject<{
                type: ZodLiteral<"object">;
                properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
                required: ZodOptional<ZodArray<ZodString>>;
            }, $catchall<ZodUnknown>>>;
            annotations: ZodOptional<ZodObject<{
                title: ZodOptional<ZodString>;
                readOnlyHint: ZodOptional<ZodBoolean>;
                destructiveHint: ZodOptional<ZodBoolean>;
                idempotentHint: ZodOptional<ZodBoolean>;
                openWorldHint: ZodOptional<ZodBoolean>;
            }, $strip>>;
            execution: ZodOptional<ZodObject<{
                taskSupport: ZodOptional<ZodEnum<{
                    optional: "optional";
                    required: "required";
                    forbidden: "forbidden";
                }>>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            icons: ZodOptional<ZodArray<ZodObject<{
                src: ZodString;
                mimeType: ZodOptional<ZodString>;
                sizes: ZodOptional<ZodArray<ZodString>>;
                theme: ZodOptional<ZodEnum<{
                    light: "light";
                    dark: "dark";
                }>>;
            }, $strip>>>;
            name: ZodString;
            title: ZodOptional<ZodString>;
        }, $strip>>>;
        toolChoice: ZodOptional<ZodObject<{
            mode: ZodOptional<ZodEnum<{
                required: "required";
                auto: "auto";
                none: "none";
            }>>;
        }, $strip>>;
    }, $strip>;
}, $strip>;
/**
 * The client's response to a sampling/create_message request from the server.
 * This is the backwards-compatible version that returns single content (no arrays).
 * Used when the request does not include tools.
 */
declare const CreateMessageResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    model: ZodString;
    stopReason: ZodOptional<ZodUnion<[ZodEnum<{
        maxTokens: "maxTokens";
        endTurn: "endTurn";
        stopSequence: "stopSequence";
    }>, ZodString]>>;
    role: ZodEnum<{
        user: "user";
        assistant: "assistant";
    }>;
    content: ZodDiscriminatedUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        text: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"image">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"audio">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>]>;
}, $loose>;
/**
 * The client's response to a sampling/create_message request when tools were provided.
 * This version supports array content for tool use flows.
 */
declare const CreateMessageResultWithToolsSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    model: ZodString;
    stopReason: ZodOptional<ZodUnion<[ZodEnum<{
        maxTokens: "maxTokens";
        endTurn: "endTurn";
        stopSequence: "stopSequence";
        toolUse: "toolUse";
    }>, ZodString]>>;
    role: ZodEnum<{
        user: "user";
        assistant: "assistant";
    }>;
    content: ZodUnion<readonly [ZodDiscriminatedUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        text: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"image">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"audio">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"tool_use">;
        name: ZodString;
        id: ZodString;
        input: ZodRecord<ZodString, ZodUnknown>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"tool_result">;
        toolUseId: ZodString;
        content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            uri: ZodString;
            description: ZodOptional<ZodString>;
            mimeType: ZodOptional<ZodString>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodObject<{}, $loose>>;
            icons: ZodOptional<ZodArray<ZodObject<{
                src: ZodString;
                mimeType: ZodOptional<ZodString>;
                sizes: ZodOptional<ZodArray<ZodString>>;
                theme: ZodOptional<ZodEnum<{
                    light: "light";
                    dark: "dark";
                }>>;
            }, $strip>>>;
            name: ZodString;
            title: ZodOptional<ZodString>;
            type: ZodLiteral<"resource_link">;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<readonly [ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                text: ZodString;
            }, $strip>, ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                blob: ZodString;
            }, $strip>]>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>]>>>;
        structuredContent: ZodOptional<ZodObject<{}, $loose>>;
        isError: ZodOptional<ZodBoolean>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>]>, ZodArray<ZodDiscriminatedUnion<[ZodObject<{
        type: ZodLiteral<"text">;
        text: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"image">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"audio">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"tool_use">;
        name: ZodString;
        id: ZodString;
        input: ZodRecord<ZodString, ZodUnknown>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"tool_result">;
        toolUseId: ZodString;
        content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            uri: ZodString;
            description: ZodOptional<ZodString>;
            mimeType: ZodOptional<ZodString>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodObject<{}, $loose>>;
            icons: ZodOptional<ZodArray<ZodObject<{
                src: ZodString;
                mimeType: ZodOptional<ZodString>;
                sizes: ZodOptional<ZodArray<ZodString>>;
                theme: ZodOptional<ZodEnum<{
                    light: "light";
                    dark: "dark";
                }>>;
            }, $strip>>>;
            name: ZodString;
            title: ZodOptional<ZodString>;
            type: ZodLiteral<"resource_link">;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<readonly [ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                text: ZodString;
            }, $strip>, ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                blob: ZodString;
            }, $strip>]>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>]>>>;
        structuredContent: ZodOptional<ZodObject<{}, $loose>>;
        isError: ZodOptional<ZodBoolean>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>]>>]>;
}, $loose>;
/**
 * Parameters for an `elicitation/create` request for form-based elicitation.
 */
declare const ElicitRequestFormParamsSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    task: ZodOptional<ZodObject<{
        ttl: ZodOptional<ZodNumber>;
    }, $strip>>;
    mode: ZodOptional<ZodLiteral<"form">>;
    message: ZodString;
    requestedSchema: ZodObject<{
        type: ZodLiteral<"object">;
        properties: ZodRecord<ZodString, ZodUnion<readonly [ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"string">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            enum: ZodArray<ZodString>;
            enumNames: ZodOptional<ZodArray<ZodString>>;
            default: ZodOptional<ZodString>;
        }, $strip>, ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"string">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            enum: ZodArray<ZodString>;
            default: ZodOptional<ZodString>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"string">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            oneOf: ZodArray<ZodObject<{
                const: ZodString;
                title: ZodString;
            }, $strip>>;
            default: ZodOptional<ZodString>;
        }, $strip>]>, ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"array">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            minItems: ZodOptional<ZodNumber>;
            maxItems: ZodOptional<ZodNumber>;
            items: ZodObject<{
                type: ZodLiteral<"string">;
                enum: ZodArray<ZodString>;
            }, $strip>;
            default: ZodOptional<ZodArray<ZodString>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"array">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            minItems: ZodOptional<ZodNumber>;
            maxItems: ZodOptional<ZodNumber>;
            items: ZodObject<{
                anyOf: ZodArray<ZodObject<{
                    const: ZodString;
                    title: ZodString;
                }, $strip>>;
            }, $strip>;
            default: ZodOptional<ZodArray<ZodString>>;
        }, $strip>]>]>, ZodObject<{
            type: ZodLiteral<"boolean">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            default: ZodOptional<ZodBoolean>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"string">;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            minLength: ZodOptional<ZodNumber>;
            maxLength: ZodOptional<ZodNumber>;
            format: ZodOptional<ZodEnum<{
                date: "date";
                uri: "uri";
                email: "email";
                "date-time": "date-time";
            }>>;
            default: ZodOptional<ZodString>;
        }, $strip>, ZodObject<{
            type: ZodEnum<{
                number: "number";
                integer: "integer";
            }>;
            title: ZodOptional<ZodString>;
            description: ZodOptional<ZodString>;
            minimum: ZodOptional<ZodNumber>;
            maximum: ZodOptional<ZodNumber>;
            default: ZodOptional<ZodNumber>;
        }, $strip>]>>;
        required: ZodOptional<ZodArray<ZodString>>;
    }, $strip>;
}, $strip>;
/**
 * Parameters for an `elicitation/create` request for URL-based elicitation.
 */
declare const ElicitRequestURLParamsSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    task: ZodOptional<ZodObject<{
        ttl: ZodOptional<ZodNumber>;
    }, $strip>>;
    mode: ZodLiteral<"url">;
    message: ZodString;
    elicitationId: ZodString;
    url: ZodString;
}, $strip>;
/**
 * The client's response to an elicitation/create request from the server.
 */
declare const ElicitResultSchema: ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    action: ZodEnum<{
        cancel: "cancel";
        accept: "accept";
        decline: "decline";
    }>;
    content: ZodPipe<ZodTransform<{} | undefined, unknown>, ZodOptional<ZodRecord<ZodString, ZodUnion<readonly [ZodString, ZodNumber, ZodBoolean, ZodArray<ZodString>]>>>>;
}, $loose>;
/**
 * Sent from the server to request a list of root URIs from the client.
 */
declare const ListRootsRequestSchema: ZodObject<{
    method: ZodLiteral<"roots/list">;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>>;
}, $strip>;
declare const ServerRequestSchema: ZodUnion<readonly [ZodObject<{
    method: ZodLiteral<"ping">;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"sampling/createMessage">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        task: ZodOptional<ZodObject<{
            ttl: ZodOptional<ZodNumber>;
        }, $strip>>;
        messages: ZodArray<ZodObject<{
            role: ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>;
            content: ZodUnion<readonly [ZodDiscriminatedUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                text: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"image">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"audio">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_use">;
                name: ZodString;
                id: ZodString;
                input: ZodRecord<ZodString, ZodUnknown>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_result">;
                toolUseId: ZodString;
                content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
                    type: ZodLiteral<"text">;
                    text: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"image">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"audio">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    uri: ZodString;
                    description: ZodOptional<ZodString>;
                    mimeType: ZodOptional<ZodString>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodObject<{}, $loose>>;
                    icons: ZodOptional<ZodArray<ZodObject<{
                        src: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        sizes: ZodOptional<ZodArray<ZodString>>;
                        theme: ZodOptional<ZodEnum<{
                            light: "light";
                            dark: "dark";
                        }>>;
                    }, $strip>>>;
                    name: ZodString;
                    title: ZodOptional<ZodString>;
                    type: ZodLiteral<"resource_link">;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"resource">;
                    resource: ZodUnion<readonly [ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        text: ZodString;
                    }, $strip>, ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        blob: ZodString;
                    }, $strip>]>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>]>>>;
                structuredContent: ZodOptional<ZodObject<{}, $loose>>;
                isError: ZodOptional<ZodBoolean>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>]>, ZodArray<ZodDiscriminatedUnion<[ZodObject<{
                type: ZodLiteral<"text">;
                text: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"image">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"audio">;
                data: ZodString;
                mimeType: ZodString;
                annotations: ZodOptional<ZodObject<{
                    audience: ZodOptional<ZodArray<ZodEnum<{
                        user: "user";
                        assistant: "assistant";
                    }>>>;
                    priority: ZodOptional<ZodNumber>;
                    lastModified: ZodOptional<ZodISODateTime>;
                }, $strip>>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_use">;
                name: ZodString;
                id: ZodString;
                input: ZodRecord<ZodString, ZodUnknown>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"tool_result">;
                toolUseId: ZodString;
                content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
                    type: ZodLiteral<"text">;
                    text: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"image">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"audio">;
                    data: ZodString;
                    mimeType: ZodString;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>, ZodObject<{
                    uri: ZodString;
                    description: ZodOptional<ZodString>;
                    mimeType: ZodOptional<ZodString>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodObject<{}, $loose>>;
                    icons: ZodOptional<ZodArray<ZodObject<{
                        src: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        sizes: ZodOptional<ZodArray<ZodString>>;
                        theme: ZodOptional<ZodEnum<{
                            light: "light";
                            dark: "dark";
                        }>>;
                    }, $strip>>>;
                    name: ZodString;
                    title: ZodOptional<ZodString>;
                    type: ZodLiteral<"resource_link">;
                }, $strip>, ZodObject<{
                    type: ZodLiteral<"resource">;
                    resource: ZodUnion<readonly [ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        text: ZodString;
                    }, $strip>, ZodObject<{
                        uri: ZodString;
                        mimeType: ZodOptional<ZodString>;
                        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                        blob: ZodString;
                    }, $strip>]>;
                    annotations: ZodOptional<ZodObject<{
                        audience: ZodOptional<ZodArray<ZodEnum<{
                            user: "user";
                            assistant: "assistant";
                        }>>>;
                        priority: ZodOptional<ZodNumber>;
                        lastModified: ZodOptional<ZodISODateTime>;
                    }, $strip>>;
                    _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                }, $strip>]>>>;
                structuredContent: ZodOptional<ZodObject<{}, $loose>>;
                isError: ZodOptional<ZodBoolean>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            }, $strip>]>>]>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>>;
        modelPreferences: ZodOptional<ZodObject<{
            hints: ZodOptional<ZodArray<ZodObject<{
                name: ZodOptional<ZodString>;
            }, $strip>>>;
            costPriority: ZodOptional<ZodNumber>;
            speedPriority: ZodOptional<ZodNumber>;
            intelligencePriority: ZodOptional<ZodNumber>;
        }, $strip>>;
        systemPrompt: ZodOptional<ZodString>;
        includeContext: ZodOptional<ZodEnum<{
            none: "none";
            thisServer: "thisServer";
            allServers: "allServers";
        }>>;
        temperature: ZodOptional<ZodNumber>;
        maxTokens: ZodNumber;
        stopSequences: ZodOptional<ZodArray<ZodString>>;
        metadata: ZodOptional<ZodCustom<object, object>>;
        tools: ZodOptional<ZodArray<ZodObject<{
            description: ZodOptional<ZodString>;
            inputSchema: ZodObject<{
                type: ZodLiteral<"object">;
                properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
                required: ZodOptional<ZodArray<ZodString>>;
            }, $catchall<ZodUnknown>>;
            outputSchema: ZodOptional<ZodObject<{
                type: ZodLiteral<"object">;
                properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
                required: ZodOptional<ZodArray<ZodString>>;
            }, $catchall<ZodUnknown>>>;
            annotations: ZodOptional<ZodObject<{
                title: ZodOptional<ZodString>;
                readOnlyHint: ZodOptional<ZodBoolean>;
                destructiveHint: ZodOptional<ZodBoolean>;
                idempotentHint: ZodOptional<ZodBoolean>;
                openWorldHint: ZodOptional<ZodBoolean>;
            }, $strip>>;
            execution: ZodOptional<ZodObject<{
                taskSupport: ZodOptional<ZodEnum<{
                    optional: "optional";
                    required: "required";
                    forbidden: "forbidden";
                }>>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            icons: ZodOptional<ZodArray<ZodObject<{
                src: ZodString;
                mimeType: ZodOptional<ZodString>;
                sizes: ZodOptional<ZodArray<ZodString>>;
                theme: ZodOptional<ZodEnum<{
                    light: "light";
                    dark: "dark";
                }>>;
            }, $strip>>>;
            name: ZodString;
            title: ZodOptional<ZodString>;
        }, $strip>>>;
        toolChoice: ZodOptional<ZodObject<{
            mode: ZodOptional<ZodEnum<{
                required: "required";
                auto: "auto";
                none: "none";
            }>>;
        }, $strip>>;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"elicitation/create">;
    params: ZodUnion<readonly [ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        task: ZodOptional<ZodObject<{
            ttl: ZodOptional<ZodNumber>;
        }, $strip>>;
        mode: ZodOptional<ZodLiteral<"form">>;
        message: ZodString;
        requestedSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodRecord<ZodString, ZodUnion<readonly [ZodUnion<readonly [ZodObject<{
                type: ZodLiteral<"string">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                enum: ZodArray<ZodString>;
                enumNames: ZodOptional<ZodArray<ZodString>>;
                default: ZodOptional<ZodString>;
            }, $strip>, ZodUnion<readonly [ZodObject<{
                type: ZodLiteral<"string">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                enum: ZodArray<ZodString>;
                default: ZodOptional<ZodString>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"string">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                oneOf: ZodArray<ZodObject<{
                    const: ZodString;
                    title: ZodString;
                }, $strip>>;
                default: ZodOptional<ZodString>;
            }, $strip>]>, ZodUnion<readonly [ZodObject<{
                type: ZodLiteral<"array">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                minItems: ZodOptional<ZodNumber>;
                maxItems: ZodOptional<ZodNumber>;
                items: ZodObject<{
                    type: ZodLiteral<"string">;
                    enum: ZodArray<ZodString>;
                }, $strip>;
                default: ZodOptional<ZodArray<ZodString>>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"array">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                minItems: ZodOptional<ZodNumber>;
                maxItems: ZodOptional<ZodNumber>;
                items: ZodObject<{
                    anyOf: ZodArray<ZodObject<{
                        const: ZodString;
                        title: ZodString;
                    }, $strip>>;
                }, $strip>;
                default: ZodOptional<ZodArray<ZodString>>;
            }, $strip>]>]>, ZodObject<{
                type: ZodLiteral<"boolean">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                default: ZodOptional<ZodBoolean>;
            }, $strip>, ZodObject<{
                type: ZodLiteral<"string">;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                minLength: ZodOptional<ZodNumber>;
                maxLength: ZodOptional<ZodNumber>;
                format: ZodOptional<ZodEnum<{
                    date: "date";
                    uri: "uri";
                    email: "email";
                    "date-time": "date-time";
                }>>;
                default: ZodOptional<ZodString>;
            }, $strip>, ZodObject<{
                type: ZodEnum<{
                    number: "number";
                    integer: "integer";
                }>;
                title: ZodOptional<ZodString>;
                description: ZodOptional<ZodString>;
                minimum: ZodOptional<ZodNumber>;
                maximum: ZodOptional<ZodNumber>;
                default: ZodOptional<ZodNumber>;
            }, $strip>]>>;
            required: ZodOptional<ZodArray<ZodString>>;
        }, $strip>;
    }, $strip>, ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        task: ZodOptional<ZodObject<{
            ttl: ZodOptional<ZodNumber>;
        }, $strip>>;
        mode: ZodLiteral<"url">;
        message: ZodString;
        elicitationId: ZodString;
        url: ZodString;
    }, $strip>]>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"roots/list">;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"tasks/get">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        taskId: ZodString;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"tasks/result">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        taskId: ZodString;
    }, $strip>;
}, $strip>, ZodObject<{
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        cursor: ZodOptional<ZodString>;
    }, $strip>>;
    method: ZodLiteral<"tasks/list">;
}, $strip>, ZodObject<{
    method: ZodLiteral<"tasks/cancel">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        taskId: ZodString;
    }, $strip>;
}, $strip>]>;
declare const ServerNotificationSchema: ZodUnion<readonly [ZodObject<{
    method: ZodLiteral<"notifications/cancelled">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        requestId: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        reason: ZodOptional<ZodString>;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/progress">;
    params: ZodObject<{
        progressToken: ZodUnion<readonly [ZodString, ZodNumber]>;
        progress: ZodNumber;
        total: ZodOptional<ZodNumber>;
        message: ZodOptional<ZodString>;
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/message">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        level: ZodEnum<{
            error: "error";
            debug: "debug";
            info: "info";
            notice: "notice";
            warning: "warning";
            critical: "critical";
            alert: "alert";
            emergency: "emergency";
        }>;
        logger: ZodOptional<ZodString>;
        data: ZodUnknown;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/resources/updated">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        uri: ZodString;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/resources/list_changed">;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/tools/list_changed">;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/prompts/list_changed">;
    params: ZodOptional<ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
    }, $strip>>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/tasks/status">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        taskId: ZodString;
        status: ZodEnum<{
            working: "working";
            input_required: "input_required";
            completed: "completed";
            failed: "failed";
            cancelled: "cancelled";
        }>;
        ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
        createdAt: ZodString;
        lastUpdatedAt: ZodString;
        pollInterval: ZodOptional<ZodNumber>;
        statusMessage: ZodOptional<ZodString>;
    }, $strip>;
}, $strip>, ZodObject<{
    method: ZodLiteral<"notifications/elicitation/complete">;
    params: ZodObject<{
        _meta: ZodOptional<ZodObject<{
            /**
             * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
             */
            progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
            /**
             * If specified, this request is related to the provided task.
             */
            "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
                taskId: ZodString;
            }, $strip>>;
        }, $loose>>;
        elicitationId: ZodString;
    }, $strip>;
}, $strip>]>;
declare const ServerResultSchema: ZodUnion<readonly [ZodObject<{
    /**
     * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
     * for notes on _meta usage.
     */
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
}, $strict>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    protocolVersion: ZodString;
    capabilities: ZodObject<{
        experimental: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
        logging: ZodOptional<ZodCustom<object, object>>;
        completions: ZodOptional<ZodCustom<object, object>>;
        prompts: ZodOptional<ZodObject<{
            listChanged: ZodOptional<ZodBoolean>;
        }, $strip>>;
        resources: ZodOptional<ZodObject<{
            subscribe: ZodOptional<ZodBoolean>;
            listChanged: ZodOptional<ZodBoolean>;
        }, $strip>>;
        tools: ZodOptional<ZodObject<{
            listChanged: ZodOptional<ZodBoolean>;
        }, $strip>>;
        tasks: ZodOptional<ZodObject<{
            /**
             * Present if the server supports listing tasks.
             */
            list: ZodOptional<ZodCustom<object, object>>;
            /**
             * Present if the server supports cancelling tasks.
             */
            cancel: ZodOptional<ZodCustom<object, object>>;
            /**
             * Capabilities for task creation on specific request types.
             */
            requests: ZodOptional<ZodObject<{
                /**
                 * Task support for tool requests.
                 */
                tools: ZodOptional<ZodObject<{
                    call: ZodOptional<ZodCustom<object, object>>;
                }, $loose>>;
            }, $loose>>;
        }, $loose>>;
    }, $strip>;
    serverInfo: ZodObject<{
        version: ZodString;
        websiteUrl: ZodOptional<ZodString>;
        description: ZodOptional<ZodString>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>;
    instructions: ZodOptional<ZodString>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    completion: ZodObject<{
        /**
         * An array of completion values. Must not exceed 100 items.
         */
        values: ZodArray<ZodString>;
        /**
         * The total number of completion options available. This can exceed the number of values actually sent in the response.
         */
        total: ZodOptional<ZodNumber>;
        /**
         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
         */
        hasMore: ZodOptional<ZodBoolean>;
    }, $loose>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    description: ZodOptional<ZodString>;
    messages: ZodArray<ZodObject<{
        role: ZodEnum<{
            user: "user";
            assistant: "assistant";
        }>;
        content: ZodUnion<readonly [ZodObject<{
            type: ZodLiteral<"text">;
            text: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"image">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"audio">;
            data: ZodString;
            mimeType: ZodString;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>, ZodObject<{
            uri: ZodString;
            description: ZodOptional<ZodString>;
            mimeType: ZodOptional<ZodString>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodObject<{}, $loose>>;
            icons: ZodOptional<ZodArray<ZodObject<{
                src: ZodString;
                mimeType: ZodOptional<ZodString>;
                sizes: ZodOptional<ZodArray<ZodString>>;
                theme: ZodOptional<ZodEnum<{
                    light: "light";
                    dark: "dark";
                }>>;
            }, $strip>>>;
            name: ZodString;
            title: ZodOptional<ZodString>;
            type: ZodLiteral<"resource_link">;
        }, $strip>, ZodObject<{
            type: ZodLiteral<"resource">;
            resource: ZodUnion<readonly [ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                text: ZodString;
            }, $strip>, ZodObject<{
                uri: ZodString;
                mimeType: ZodOptional<ZodString>;
                _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
                blob: ZodString;
            }, $strip>]>;
            annotations: ZodOptional<ZodObject<{
                audience: ZodOptional<ZodArray<ZodEnum<{
                    user: "user";
                    assistant: "assistant";
                }>>>;
                priority: ZodOptional<ZodNumber>;
                lastModified: ZodOptional<ZodISODateTime>;
            }, $strip>>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        }, $strip>]>;
    }, $strip>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    prompts: ZodArray<ZodObject<{
        description: ZodOptional<ZodString>;
        arguments: ZodOptional<ZodArray<ZodObject<{
            name: ZodString;
            description: ZodOptional<ZodString>;
            required: ZodOptional<ZodBoolean>;
        }, $strip>>>;
        _meta: ZodOptional<ZodObject<{}, $loose>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    resources: ZodArray<ZodObject<{
        uri: ZodString;
        description: ZodOptional<ZodString>;
        mimeType: ZodOptional<ZodString>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodObject<{}, $loose>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    resourceTemplates: ZodArray<ZodObject<{
        uriTemplate: ZodString;
        description: ZodOptional<ZodString>;
        mimeType: ZodOptional<ZodString>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodObject<{}, $loose>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    contents: ZodArray<ZodUnion<readonly [ZodObject<{
        uri: ZodString;
        mimeType: ZodOptional<ZodString>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        text: ZodString;
    }, $strip>, ZodObject<{
        uri: ZodString;
        mimeType: ZodOptional<ZodString>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        blob: ZodString;
    }, $strip>]>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    content: ZodDefault<ZodArray<ZodUnion<readonly [ZodObject<{
        type: ZodLiteral<"text">;
        text: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"image">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"audio">;
        data: ZodString;
        mimeType: ZodString;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>, ZodObject<{
        uri: ZodString;
        description: ZodOptional<ZodString>;
        mimeType: ZodOptional<ZodString>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodObject<{}, $loose>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
        type: ZodLiteral<"resource_link">;
    }, $strip>, ZodObject<{
        type: ZodLiteral<"resource">;
        resource: ZodUnion<readonly [ZodObject<{
            uri: ZodString;
            mimeType: ZodOptional<ZodString>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            text: ZodString;
        }, $strip>, ZodObject<{
            uri: ZodString;
            mimeType: ZodOptional<ZodString>;
            _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
            blob: ZodString;
        }, $strip>]>;
        annotations: ZodOptional<ZodObject<{
            audience: ZodOptional<ZodArray<ZodEnum<{
                user: "user";
                assistant: "assistant";
            }>>>;
            priority: ZodOptional<ZodNumber>;
            lastModified: ZodOptional<ZodISODateTime>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    }, $strip>]>>>;
    structuredContent: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
    isError: ZodOptional<ZodBoolean>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    tools: ZodArray<ZodObject<{
        description: ZodOptional<ZodString>;
        inputSchema: ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
            required: ZodOptional<ZodArray<ZodString>>;
        }, $catchall<ZodUnknown>>;
        outputSchema: ZodOptional<ZodObject<{
            type: ZodLiteral<"object">;
            properties: ZodOptional<ZodRecord<ZodString, ZodCustom<object, object>>>;
            required: ZodOptional<ZodArray<ZodString>>;
        }, $catchall<ZodUnknown>>>;
        annotations: ZodOptional<ZodObject<{
            title: ZodOptional<ZodString>;
            readOnlyHint: ZodOptional<ZodBoolean>;
            destructiveHint: ZodOptional<ZodBoolean>;
            idempotentHint: ZodOptional<ZodBoolean>;
            openWorldHint: ZodOptional<ZodBoolean>;
        }, $strip>>;
        execution: ZodOptional<ZodObject<{
            taskSupport: ZodOptional<ZodEnum<{
                optional: "optional";
                required: "required";
                forbidden: "forbidden";
            }>>;
        }, $strip>>;
        _meta: ZodOptional<ZodRecord<ZodString, ZodUnknown>>;
        icons: ZodOptional<ZodArray<ZodObject<{
            src: ZodString;
            mimeType: ZodOptional<ZodString>;
            sizes: ZodOptional<ZodArray<ZodString>>;
            theme: ZodOptional<ZodEnum<{
                light: "light";
                dark: "dark";
            }>>;
        }, $strip>>>;
        name: ZodString;
        title: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    taskId: ZodString;
    status: ZodEnum<{
        working: "working";
        input_required: "input_required";
        completed: "completed";
        failed: "failed";
        cancelled: "cancelled";
    }>;
    ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
    createdAt: ZodString;
    lastUpdatedAt: ZodString;
    pollInterval: ZodOptional<ZodNumber>;
    statusMessage: ZodOptional<ZodString>;
}, $strip>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    nextCursor: ZodOptional<ZodString>;
    tasks: ZodArray<ZodObject<{
        taskId: ZodString;
        status: ZodEnum<{
            working: "working";
            input_required: "input_required";
            completed: "completed";
            failed: "failed";
            cancelled: "cancelled";
        }>;
        ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
        createdAt: ZodString;
        lastUpdatedAt: ZodString;
        pollInterval: ZodOptional<ZodNumber>;
        statusMessage: ZodOptional<ZodString>;
    }, $strip>>;
}, $loose>, ZodObject<{
    _meta: ZodOptional<ZodObject<{
        /**
         * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
         */
        progressToken: ZodOptional<ZodUnion<readonly [ZodString, ZodNumber]>>;
        /**
         * If specified, this request is related to the provided task.
         */
        "io.modelcontextprotocol/related-task": ZodOptional<ZodObject<{
            taskId: ZodString;
        }, $strip>>;
    }, $loose>>;
    task: ZodObject<{
        taskId: ZodString;
        status: ZodEnum<{
            working: "working";
            input_required: "input_required";
            completed: "completed";
            failed: "failed";
            cancelled: "cancelled";
        }>;
        ttl: ZodUnion<readonly [ZodNumber, ZodNull]>;
        createdAt: ZodString;
        lastUpdatedAt: ZodString;
        pollInterval: ZodOptional<ZodNumber>;
        statusMessage: ZodOptional<ZodString>;
    }, $strip>;
}, $loose>]>;
declare class McpError extends Error {
    readonly code: number;
    readonly data?: unknown;
    constructor(code: number, message: string, data?: unknown);
    /**
     * Factory method to create the appropriate error type based on the error code and data
     */
    static fromError(code: number, message: string, data?: unknown): McpError;
}
type Primitive = string | number | boolean | bigint | null | undefined;
type Flatten<T> = T extends Primitive ? T : T extends Array<infer U> ? Array<Flatten<U>> : T extends Set<infer U> ? Set<Flatten<U>> : T extends Map<infer K, infer V> ? Map<Flatten<K>, Flatten<V>> : T extends object ? {
    [K in keyof T]: Flatten<T[K]>;
} : T;
type Infer<Schema extends ZodType> = Flatten<output<Schema>>;
/**
 * Headers that are compatible with both Node.js and the browser.
 */
type IsomorphicHeaders = Record<string, string | string[] | undefined>;
/**
 * Information about the incoming request.
 */
interface RequestInfo {
    /**
     * The headers of the request.
     */
    headers: IsomorphicHeaders;
}
/**
 * Extra information about a message.
 */
interface MessageExtraInfo {
    /**
     * The request information.
     */
    requestInfo?: RequestInfo;
    /**
     * The authentication information.
     */
    authInfo?: AuthInfo;
    /**
     * Callback to close the SSE stream for this request, triggering client reconnection.
     * Only available when using StreamableHTTPServerTransport with eventStore configured.
     */
    closeSSEStream?: () => void;
    /**
     * Callback to close the standalone GET SSE stream, triggering client reconnection.
     * Only available when using StreamableHTTPServerTransport with eventStore configured.
     */
    closeStandaloneSSEStream?: () => void;
}
type Request = Infer<typeof RequestSchema>;
type RequestMeta = Infer<typeof RequestMetaSchema>;
type Notification = Infer<typeof NotificationSchema>;
type Result = Infer<typeof ResultSchema>;
type RequestId = Infer<typeof RequestIdSchema>;
type JSONRPCRequest = Infer<typeof JSONRPCRequestSchema>;
type JSONRPCNotification = Infer<typeof JSONRPCNotificationSchema>;
type JSONRPCErrorResponse = Infer<typeof JSONRPCErrorResponseSchema>;
type JSONRPCResultResponse = Infer<typeof JSONRPCResultResponseSchema>;
type JSONRPCMessage = Infer<typeof JSONRPCMessageSchema>;
type Implementation = Infer<typeof ImplementationSchema>;
type ClientCapabilities = Infer<typeof ClientCapabilitiesSchema>;
type ServerCapabilities = Infer<typeof ServerCapabilitiesSchema>;
type Progress = Infer<typeof ProgressSchema>;
type Task = Infer<typeof TaskSchema>;
type TaskCreationParams = Infer<typeof TaskCreationParamsSchema>;
type RelatedTaskMetadata = Infer<typeof RelatedTaskMetadataSchema>;
type CreateTaskResult = Infer<typeof CreateTaskResultSchema>;
type GetTaskRequest = Infer<typeof GetTaskRequestSchema>;
type GetTaskResult = Infer<typeof GetTaskResultSchema>;
type GetTaskPayloadRequest = Infer<typeof GetTaskPayloadRequestSchema>;
type ListTasksResult = Infer<typeof ListTasksResultSchema>;
type CancelTaskResult = Infer<typeof CancelTaskResultSchema>;
type Resource = Infer<typeof ResourceSchema>;
type ListResourcesResult = Infer<typeof ListResourcesResultSchema>;
type ReadResourceResult = Infer<typeof ReadResourceResultSchema>;
type ResourceUpdatedNotification = Infer<typeof ResourceUpdatedNotificationSchema>;
type GetPromptResult = Infer<typeof GetPromptResultSchema>;
type ToolAnnotations = Infer<typeof ToolAnnotationsSchema>;
type ToolExecution = Infer<typeof ToolExecutionSchema>;
type Tool = Infer<typeof ToolSchema>;
type CallToolResult = Infer<typeof CallToolResultSchema>;
type LoggingMessageNotification = Infer<typeof LoggingMessageNotificationSchema>;
type CreateMessageRequestParams = Infer<typeof CreateMessageRequestParamsSchema>;
type CreateMessageRequest = Infer<typeof CreateMessageRequestSchema>;
type CreateMessageResult = Infer<typeof CreateMessageResultSchema>;
type CreateMessageResultWithTools = Infer<typeof CreateMessageResultWithToolsSchema>;
/**
 * CreateMessageRequestParams without tools - for backwards-compatible overload.
 * Excludes tools/toolChoice to indicate they should not be provided.
 */
type CreateMessageRequestParamsBase = Omit<CreateMessageRequestParams, 'tools' | 'toolChoice'>;
/**
 * CreateMessageRequestParams with required tools - for tool-enabled overload.
 */
interface CreateMessageRequestParamsWithTools extends CreateMessageRequestParams {
    tools: Tool[];
}
type ElicitRequestFormParams = Infer<typeof ElicitRequestFormParamsSchema>;
type ElicitRequestURLParams = Infer<typeof ElicitRequestURLParamsSchema>;
type ElicitResult = Infer<typeof ElicitResultSchema>;
type ListRootsRequest = Infer<typeof ListRootsRequestSchema>;
type ServerRequest = Infer<typeof ServerRequestSchema>;
type ServerNotification = Infer<typeof ServerNotificationSchema>;
type ServerResult = Infer<typeof ServerResultSchema>;

/**
 * Options for sending a JSON-RPC message.
 */
type TransportSendOptions = {
    /**
     * If present, `relatedRequestId` is used to indicate to the transport which incoming request to associate this outgoing message with.
     */
    relatedRequestId?: RequestId;
    /**
     * The resumption token used to continue long-running requests that were interrupted.
     *
     * This allows clients to reconnect and continue from where they left off, if supported by the transport.
     */
    resumptionToken?: string;
    /**
     * A callback that is invoked when the resumption token changes, if supported by the transport.
     *
     * This allows clients to persist the latest token for potential reconnection.
     */
    onresumptiontoken?: (token: string) => void;
};
/**
 * Describes the minimal contract for an MCP transport that a client or server can communicate over.
 */
interface Transport {
    /**
     * Starts processing messages on the transport, including any connection steps that might need to be taken.
     *
     * This method should only be called after callbacks are installed, or else messages may be lost.
     *
     * NOTE: This method should not be called explicitly when using Client, Server, or Protocol classes, as they will implicitly call start().
     */
    start(): Promise<void>;
    /**
     * Sends a JSON-RPC message (request or response).
     *
     * If present, `relatedRequestId` is used to indicate to the transport which incoming request to associate this outgoing message with.
     */
    send(message: JSONRPCMessage, options?: TransportSendOptions): Promise<void>;
    /**
     * Closes the connection.
     */
    close(): Promise<void>;
    /**
     * Callback for when the connection is closed for any reason.
     *
     * This should be invoked when close() is called as well.
     */
    onclose?: () => void;
    /**
     * Callback for when an error occurs.
     *
     * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.
     */
    onerror?: (error: Error) => void;
    /**
     * Callback for when a message (request or response) is received over the connection.
     *
     * Includes the requestInfo and authInfo if the transport is authenticated.
     *
     * The requestInfo can be used to get the original request information (headers, etc.)
     */
    onmessage?: <T extends JSONRPCMessage>(message: T, extra?: MessageExtraInfo) => void;
    /**
     * The session ID generated for this connection.
     */
    sessionId?: string;
    /**
     * Sets the protocol version used for the connection (called when the initialize response is received).
     */
    setProtocolVersion?: (version: string) => void;
}

/**
 * Experimental task interfaces for MCP SDK.
 * WARNING: These APIs are experimental and may change without notice.
 */

/**
 * Extended handler extra with task store for task creation.
 * @experimental
 */
interface CreateTaskRequestHandlerExtra extends RequestHandlerExtra<ServerRequest, ServerNotification> {
    taskStore: RequestTaskStore;
}
/**
 * Extended handler extra with task ID and store for task operations.
 * @experimental
 */
interface TaskRequestHandlerExtra extends RequestHandlerExtra<ServerRequest, ServerNotification> {
    taskId: string;
    taskStore: RequestTaskStore;
}
/**
 * Base callback type for tool handlers.
 * @experimental
 */
type BaseToolCallback$1<SendResultT extends Result, ExtraT extends RequestHandlerExtra<ServerRequest, ServerNotification>, Args extends undefined | ZodRawShapeCompat | AnySchema = undefined> = Args extends ZodRawShapeCompat ? (args: ShapeOutput<Args>, extra: ExtraT) => SendResultT | Promise<SendResultT> : Args extends AnySchema ? (args: unknown, extra: ExtraT) => SendResultT | Promise<SendResultT> : (extra: ExtraT) => SendResultT | Promise<SendResultT>;
/**
 * Handler for creating a task.
 * @experimental
 */
type CreateTaskRequestHandler<SendResultT extends Result, Args extends undefined | ZodRawShapeCompat | AnySchema = undefined> = BaseToolCallback$1<SendResultT, CreateTaskRequestHandlerExtra, Args>;
/**
 * Handler for task operations (get, getResult).
 * @experimental
 */
type TaskRequestHandler<SendResultT extends Result, Args extends undefined | ZodRawShapeCompat | AnySchema = undefined> = BaseToolCallback$1<SendResultT, TaskRequestHandlerExtra, Args>;
/**
 * Interface for task-based tool handlers.
 * @experimental
 */
interface ToolTaskHandler<Args extends undefined | ZodRawShapeCompat | AnySchema = undefined> {
    createTask: CreateTaskRequestHandler<CreateTaskResult, Args>;
    getTask: TaskRequestHandler<GetTaskResult, Args>;
    getTaskResult: TaskRequestHandler<CallToolResult, Args>;
}
/**
 * Task-specific execution configuration.
 * taskSupport cannot be 'forbidden' for task-based tools.
 * @experimental
 */
type TaskToolExecution<TaskSupport = ToolExecution['taskSupport']> = Omit<ToolExecution, 'taskSupport'> & {
    taskSupport: TaskSupport extends 'forbidden' | undefined ? never : TaskSupport;
};
/**
 * Represents a message queued for side-channel delivery via tasks/result.
 *
 * This is a serializable data structure that can be stored in external systems.
 * All fields are JSON-serializable.
 */
type QueuedMessage = QueuedRequest | QueuedNotification | QueuedResponse | QueuedError;
interface BaseQueuedMessage {
    /** Type of message */
    type: string;
    /** When the message was queued (milliseconds since epoch) */
    timestamp: number;
}
interface QueuedRequest extends BaseQueuedMessage {
    type: 'request';
    /** The actual JSONRPC request */
    message: JSONRPCRequest;
}
interface QueuedNotification extends BaseQueuedMessage {
    type: 'notification';
    /** The actual JSONRPC notification */
    message: JSONRPCNotification;
}
interface QueuedResponse extends BaseQueuedMessage {
    type: 'response';
    /** The actual JSONRPC response */
    message: JSONRPCResultResponse;
}
interface QueuedError extends BaseQueuedMessage {
    type: 'error';
    /** The actual JSONRPC error */
    message: JSONRPCErrorResponse;
}
/**
 * Interface for managing per-task FIFO message queues.
 *
 * Similar to TaskStore, this allows pluggable queue implementations
 * (in-memory, Redis, other distributed queues, etc.).
 *
 * Each method accepts taskId and optional sessionId parameters to enable
 * a single queue instance to manage messages for multiple tasks, with
 * isolation based on task ID and session ID.
 *
 * All methods are async to support external storage implementations.
 * All data in QueuedMessage must be JSON-serializable.
 *
 * @experimental
 */
interface TaskMessageQueue {
    /**
     * Adds a message to the end of the queue for a specific task.
     * Atomically checks queue size and throws if maxSize would be exceeded.
     * @param taskId The task identifier
     * @param message The message to enqueue
     * @param sessionId Optional session ID for binding the operation to a specific session
     * @param maxSize Optional maximum queue size - if specified and queue is full, throws an error
     * @throws Error if maxSize is specified and would be exceeded
     */
    enqueue(taskId: string, message: QueuedMessage, sessionId?: string, maxSize?: number): Promise<void>;
    /**
     * Removes and returns the first message from the queue for a specific task.
     * @param taskId The task identifier
     * @param sessionId Optional session ID for binding the query to a specific session
     * @returns The first message, or undefined if the queue is empty
     */
    dequeue(taskId: string, sessionId?: string): Promise<QueuedMessage | undefined>;
    /**
     * Removes and returns all messages from the queue for a specific task.
     * Used when tasks are cancelled or failed to clean up pending messages.
     * @param taskId The task identifier
     * @param sessionId Optional session ID for binding the query to a specific session
     * @returns Array of all messages that were in the queue
     */
    dequeueAll(taskId: string, sessionId?: string): Promise<QueuedMessage[]>;
}
/**
 * Task creation options.
 * @experimental
 */
interface CreateTaskOptions {
    /**
     * Time in milliseconds to keep task results available after completion.
     * If null, the task has unlimited lifetime until manually cleaned up.
     */
    ttl?: number | null;
    /**
     * Time in milliseconds to wait between task status requests.
     */
    pollInterval?: number;
    /**
     * Additional context to pass to the task store.
     */
    context?: Record<string, unknown>;
}
/**
 * Interface for storing and retrieving task state and results.
 *
 * Similar to Transport, this allows pluggable task storage implementations
 * (in-memory, database, distributed cache, etc.).
 *
 * @experimental
 */
interface TaskStore {
    /**
     * Creates a new task with the given creation parameters and original request.
     * The implementation must generate a unique taskId and createdAt timestamp.
     *
     * TTL Management:
     * - The implementation receives the TTL suggested by the requestor via taskParams.ttl
     * - The implementation MAY override the requested TTL (e.g., to enforce limits)
     * - The actual TTL used MUST be returned in the Task object
     * - Null TTL indicates unlimited task lifetime (no automatic cleanup)
     * - Cleanup SHOULD occur automatically after TTL expires, regardless of task status
     *
     * @param taskParams - The task creation parameters from the request (ttl, pollInterval)
     * @param requestId - The JSON-RPC request ID
     * @param request - The original request that triggered task creation
     * @param sessionId - Optional session ID for binding the task to a specific session
     * @returns The created task object
     */
    createTask(taskParams: CreateTaskOptions, requestId: RequestId, request: Request, sessionId?: string): Promise<Task>;
    /**
     * Gets the current status of a task.
     *
     * @param taskId - The task identifier
     * @param sessionId - Optional session ID for binding the query to a specific session
     * @returns The task object, or null if it does not exist
     */
    getTask(taskId: string, sessionId?: string): Promise<Task | null>;
    /**
     * Stores the result of a task and sets its final status.
     *
     * @param taskId - The task identifier
     * @param status - The final status: 'completed' for success, 'failed' for errors
     * @param result - The result to store
     * @param sessionId - Optional session ID for binding the operation to a specific session
     */
    storeTaskResult(taskId: string, status: 'completed' | 'failed', result: Result, sessionId?: string): Promise<void>;
    /**
     * Retrieves the stored result of a task.
     *
     * @param taskId - The task identifier
     * @param sessionId - Optional session ID for binding the query to a specific session
     * @returns The stored result
     */
    getTaskResult(taskId: string, sessionId?: string): Promise<Result>;
    /**
     * Updates a task's status (e.g., to 'cancelled', 'failed', 'completed').
     *
     * @param taskId - The task identifier
     * @param status - The new status
     * @param statusMessage - Optional diagnostic message for failed tasks or other status information
     * @param sessionId - Optional session ID for binding the operation to a specific session
     */
    updateTaskStatus(taskId: string, status: Task['status'], statusMessage?: string, sessionId?: string): Promise<void>;
    /**
     * Lists tasks, optionally starting from a pagination cursor.
     *
     * @param cursor - Optional cursor for pagination
     * @param sessionId - Optional session ID for binding the query to a specific session
     * @returns An object containing the tasks array and an optional nextCursor
     */
    listTasks(cursor?: string, sessionId?: string): Promise<{
        tasks: Task[];
        nextCursor?: string;
    }>;
}

/**
 * Base message type
 */
interface BaseResponseMessage {
    type: string;
}
/**
 * Task status update message
 */
interface TaskStatusMessage extends BaseResponseMessage {
    type: 'taskStatus';
    task: Task;
}
/**
 * Task created message (first message for task-augmented requests)
 */
interface TaskCreatedMessage extends BaseResponseMessage {
    type: 'taskCreated';
    task: Task;
}
/**
 * Final result message (terminal)
 */
interface ResultMessage<T extends Result> extends BaseResponseMessage {
    type: 'result';
    result: T;
}
/**
 * Error message (terminal)
 */
interface ErrorMessage extends BaseResponseMessage {
    type: 'error';
    error: McpError;
}
/**
 * Union type representing all possible messages that can be yielded during request processing.
 * Note: Progress notifications are handled through the existing onprogress callback mechanism.
 * Side-channeled messages (server requests/notifications) are handled through registered handlers.
 */
type ResponseMessage<T extends Result> = TaskStatusMessage | TaskCreatedMessage | ResultMessage<T> | ErrorMessage;

/**
 * Callback for progress notifications.
 */
type ProgressCallback = (progress: Progress) => void;
/**
 * Additional initialization options.
 */
type ProtocolOptions = {
    /**
     * Whether to restrict emitted requests to only those that the remote side has indicated that they can handle, through their advertised capabilities.
     *
     * Note that this DOES NOT affect checking of _local_ side capabilities, as it is considered a logic error to mis-specify those.
     *
     * Currently this defaults to false, for backwards compatibility with SDK versions that did not advertise capabilities correctly. In future, this will default to true.
     */
    enforceStrictCapabilities?: boolean;
    /**
     * An array of notification method names that should be automatically debounced.
     * Any notifications with a method in this list will be coalesced if they
     * occur in the same tick of the event loop.
     * e.g., ['notifications/tools/list_changed']
     */
    debouncedNotificationMethods?: string[];
    /**
     * Optional task storage implementation. If provided, enables task-related request handlers
     * and provides task storage capabilities to request handlers.
     */
    taskStore?: TaskStore;
    /**
     * Optional task message queue implementation for managing server-initiated messages
     * that will be delivered through the tasks/result response stream.
     */
    taskMessageQueue?: TaskMessageQueue;
    /**
     * Default polling interval (in milliseconds) for task status checks when no pollInterval
     * is provided by the server. Defaults to 5000ms if not specified.
     */
    defaultTaskPollInterval?: number;
    /**
     * Maximum number of messages that can be queued per task for side-channel delivery.
     * If undefined, the queue size is unbounded.
     * When the limit is exceeded, the TaskMessageQueue implementation's enqueue() method
     * will throw an error. It's the implementation's responsibility to handle overflow
     * appropriately (e.g., by failing the task, dropping messages, etc.).
     */
    maxTaskQueueSize?: number;
};
/**
 * Options that can be given per request.
 */
type RequestOptions = {
    /**
     * If set, requests progress notifications from the remote end (if supported). When progress notifications are received, this callback will be invoked.
     *
     * For task-augmented requests: progress notifications continue after CreateTaskResult is returned and stop automatically when the task reaches a terminal status.
     */
    onprogress?: ProgressCallback;
    /**
     * Can be used to cancel an in-flight request. This will cause an AbortError to be raised from request().
     */
    signal?: AbortSignal;
    /**
     * A timeout (in milliseconds) for this request. If exceeded, an McpError with code `RequestTimeout` will be raised from request().
     *
     * If not specified, `DEFAULT_REQUEST_TIMEOUT_MSEC` will be used as the timeout.
     */
    timeout?: number;
    /**
     * If true, receiving a progress notification will reset the request timeout.
     * This is useful for long-running operations that send periodic progress updates.
     * Default: false
     */
    resetTimeoutOnProgress?: boolean;
    /**
     * Maximum total time (in milliseconds) to wait for a response.
     * If exceeded, an McpError with code `RequestTimeout` will be raised, regardless of progress notifications.
     * If not specified, there is no maximum total timeout.
     */
    maxTotalTimeout?: number;
    /**
     * If provided, augments the request with task creation parameters to enable call-now, fetch-later execution patterns.
     */
    task?: TaskCreationParams;
    /**
     * If provided, associates this request with a related task.
     */
    relatedTask?: RelatedTaskMetadata;
} & TransportSendOptions;
/**
 * Options that can be given per notification.
 */
type NotificationOptions = {
    /**
     * May be used to indicate to the transport which incoming request to associate this outgoing notification with.
     */
    relatedRequestId?: RequestId;
    /**
     * If provided, associates this notification with a related task.
     */
    relatedTask?: RelatedTaskMetadata;
};
/**
 * Options that can be given per request.
 */
type TaskRequestOptions = Omit<RequestOptions, 'relatedTask'>;
/**
 * Request-scoped TaskStore interface.
 */
interface RequestTaskStore {
    /**
     * Creates a new task with the given creation parameters.
     * The implementation generates a unique taskId and createdAt timestamp.
     *
     * @param taskParams - The task creation parameters from the request
     * @returns The created task object
     */
    createTask(taskParams: CreateTaskOptions): Promise<Task>;
    /**
     * Gets the current status of a task.
     *
     * @param taskId - The task identifier
     * @returns The task object
     * @throws If the task does not exist
     */
    getTask(taskId: string): Promise<Task>;
    /**
     * Stores the result of a task and sets its final status.
     *
     * @param taskId - The task identifier
     * @param status - The final status: 'completed' for success, 'failed' for errors
     * @param result - The result to store
     */
    storeTaskResult(taskId: string, status: 'completed' | 'failed', result: Result): Promise<void>;
    /**
     * Retrieves the stored result of a task.
     *
     * @param taskId - The task identifier
     * @returns The stored result
     */
    getTaskResult(taskId: string): Promise<Result>;
    /**
     * Updates a task's status (e.g., to 'cancelled', 'failed', 'completed').
     *
     * @param taskId - The task identifier
     * @param status - The new status
     * @param statusMessage - Optional diagnostic message for failed tasks or other status information
     */
    updateTaskStatus(taskId: string, status: Task['status'], statusMessage?: string): Promise<void>;
    /**
     * Lists tasks, optionally starting from a pagination cursor.
     *
     * @param cursor - Optional cursor for pagination
     * @returns An object containing the tasks array and an optional nextCursor
     */
    listTasks(cursor?: string): Promise<{
        tasks: Task[];
        nextCursor?: string;
    }>;
}
/**
 * Extra data given to request handlers.
 */
type RequestHandlerExtra<SendRequestT extends Request, SendNotificationT extends Notification> = {
    /**
     * An abort signal used to communicate if the request was cancelled from the sender's side.
     */
    signal: AbortSignal;
    /**
     * Information about a validated access token, provided to request handlers.
     */
    authInfo?: AuthInfo;
    /**
     * The session ID from the transport, if available.
     */
    sessionId?: string;
    /**
     * Metadata from the original request.
     */
    _meta?: RequestMeta;
    /**
     * The JSON-RPC ID of the request being handled.
     * This can be useful for tracking or logging purposes.
     */
    requestId: RequestId;
    taskId?: string;
    taskStore?: RequestTaskStore;
    taskRequestedTtl?: number | null;
    /**
     * The original HTTP request.
     */
    requestInfo?: RequestInfo;
    /**
     * Sends a notification that relates to the current request being handled.
     *
     * This is used by certain transports to correctly associate related messages.
     */
    sendNotification: (notification: SendNotificationT) => Promise<void>;
    /**
     * Sends a request that relates to the current request being handled.
     *
     * This is used by certain transports to correctly associate related messages.
     */
    sendRequest: <U extends AnySchema>(request: SendRequestT, resultSchema: U, options?: TaskRequestOptions) => Promise<SchemaOutput<U>>;
    /**
     * Closes the SSE stream for this request, triggering client reconnection.
     * Only available when using StreamableHTTPServerTransport with eventStore configured.
     * Use this to implement polling behavior during long-running operations.
     */
    closeSSEStream?: () => void;
    /**
     * Closes the standalone GET SSE stream, triggering client reconnection.
     * Only available when using StreamableHTTPServerTransport with eventStore configured.
     * Use this to implement polling behavior for server-initiated notifications.
     */
    closeStandaloneSSEStream?: () => void;
};
/**
 * Implements MCP protocol framing on top of a pluggable transport, including
 * features like request/response linking, notifications, and progress.
 */
declare abstract class Protocol<SendRequestT extends Request, SendNotificationT extends Notification, SendResultT extends Result> {
    private _options?;
    private _transport?;
    private _requestMessageId;
    private _requestHandlers;
    private _requestHandlerAbortControllers;
    private _notificationHandlers;
    private _responseHandlers;
    private _progressHandlers;
    private _timeoutInfo;
    private _pendingDebouncedNotifications;
    private _taskProgressTokens;
    private _taskStore?;
    private _taskMessageQueue?;
    private _requestResolvers;
    /**
     * Callback for when the connection is closed for any reason.
     *
     * This is invoked when close() is called as well.
     */
    onclose?: () => void;
    /**
     * Callback for when an error occurs.
     *
     * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.
     */
    onerror?: (error: Error) => void;
    /**
     * A handler to invoke for any request types that do not have their own handler installed.
     */
    fallbackRequestHandler?: (request: JSONRPCRequest, extra: RequestHandlerExtra<SendRequestT, SendNotificationT>) => Promise<SendResultT>;
    /**
     * A handler to invoke for any notification types that do not have their own handler installed.
     */
    fallbackNotificationHandler?: (notification: Notification) => Promise<void>;
    constructor(_options?: ProtocolOptions | undefined);
    private _oncancel;
    private _setupTimeout;
    private _resetTimeout;
    private _cleanupTimeout;
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    connect(transport: Transport): Promise<void>;
    private _onclose;
    private _onerror;
    private _onnotification;
    private _onrequest;
    private _onprogress;
    private _onresponse;
    get transport(): Transport | undefined;
    /**
     * Closes the connection.
     */
    close(): Promise<void>;
    /**
     * A method to check if a capability is supported by the remote side, for the given method to be called.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertCapabilityForMethod(method: SendRequestT['method']): void;
    /**
     * A method to check if a notification is supported by the local side, for the given method to be sent.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertNotificationCapability(method: SendNotificationT['method']): void;
    /**
     * A method to check if a request handler is supported by the local side, for the given method to be handled.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertRequestHandlerCapability(method: string): void;
    /**
     * A method to check if task creation is supported for the given request method.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertTaskCapability(method: string): void;
    /**
     * A method to check if task handler is supported by the local side, for the given method to be handled.
     *
     * This should be implemented by subclasses.
     */
    protected abstract assertTaskHandlerCapability(method: string): void;
    /**
     * Sends a request and returns an AsyncGenerator that yields response messages.
     * The generator is guaranteed to end with either a 'result' or 'error' message.
     *
     * @example
     * ```typescript
     * const stream = protocol.requestStream(request, resultSchema, options);
     * for await (const message of stream) {
     *   switch (message.type) {
     *     case 'taskCreated':
     *       console.log('Task created:', message.task.taskId);
     *       break;
     *     case 'taskStatus':
     *       console.log('Task status:', message.task.status);
     *       break;
     *     case 'result':
     *       console.log('Final result:', message.result);
     *       break;
     *     case 'error':
     *       console.error('Error:', message.error);
     *       break;
     *   }
     * }
     * ```
     *
     * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
     */
    protected requestStream<T extends AnySchema>(request: SendRequestT, resultSchema: T, options?: RequestOptions): AsyncGenerator<ResponseMessage<SchemaOutput<T>>, void, void>;
    /**
     * Sends a request and waits for a response.
     *
     * Do not use this method to emit notifications! Use notification() instead.
     */
    request<T extends AnySchema>(request: SendRequestT, resultSchema: T, options?: RequestOptions): Promise<SchemaOutput<T>>;
    /**
     * Gets the current status of a task.
     *
     * @experimental Use `client.experimental.tasks.getTask()` to access this method.
     */
    protected getTask(params: GetTaskRequest['params'], options?: RequestOptions): Promise<GetTaskResult>;
    /**
     * Retrieves the result of a completed task.
     *
     * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
     */
    protected getTaskResult<T extends AnySchema>(params: GetTaskPayloadRequest['params'], resultSchema: T, options?: RequestOptions): Promise<SchemaOutput<T>>;
    /**
     * Lists tasks, optionally starting from a pagination cursor.
     *
     * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
     */
    protected listTasks(params?: {
        cursor?: string;
    }, options?: RequestOptions): Promise<SchemaOutput<typeof ListTasksResultSchema>>;
    /**
     * Cancels a specific task.
     *
     * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
     */
    protected cancelTask(params: {
        taskId: string;
    }, options?: RequestOptions): Promise<SchemaOutput<typeof CancelTaskResultSchema>>;
    /**
     * Emits a notification, which is a one-way message that does not expect a response.
     */
    notification(notification: SendNotificationT, options?: NotificationOptions): Promise<void>;
    /**
     * Registers a handler to invoke when this protocol object receives a request with the given method.
     *
     * Note that this will replace any previous request handler for the same method.
     */
    setRequestHandler<T extends AnyObjectSchema>(requestSchema: T, handler: (request: SchemaOutput<T>, extra: RequestHandlerExtra<SendRequestT, SendNotificationT>) => SendResultT | Promise<SendResultT>): void;
    /**
     * Removes the request handler for the given method.
     */
    removeRequestHandler(method: string): void;
    /**
     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
     */
    assertCanSetRequestHandler(method: string): void;
    /**
     * Registers a handler to invoke when this protocol object receives a notification with the given method.
     *
     * Note that this will replace any previous notification handler for the same method.
     */
    setNotificationHandler<T extends AnyObjectSchema>(notificationSchema: T, handler: (notification: SchemaOutput<T>) => void | Promise<void>): void;
    /**
     * Removes the notification handler for the given method.
     */
    removeNotificationHandler(method: string): void;
    /**
     * Cleans up the progress handler associated with a task.
     * This should be called when a task reaches a terminal status.
     */
    private _cleanupTaskProgressHandler;
    /**
     * Enqueues a task-related message for side-channel delivery via tasks/result.
     * @param taskId The task ID to associate the message with
     * @param message The message to enqueue
     * @param sessionId Optional session ID for binding the operation to a specific session
     * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
     *
     * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
     * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
     * simply propagates the error.
     */
    private _enqueueTaskMessage;
    /**
     * Clears the message queue for a task and rejects any pending request resolvers.
     * @param taskId The task ID whose queue should be cleared
     * @param sessionId Optional session ID for binding the operation to a specific session
     */
    private _clearTaskQueue;
    /**
     * Waits for a task update (new messages or status change) with abort signal support.
     * Uses polling to check for updates at the task's configured poll interval.
     * @param taskId The task ID to wait for
     * @param signal Abort signal to cancel the wait
     * @returns Promise that resolves when an update occurs or rejects if aborted
     */
    private _waitForTaskUpdate;
    private requestTaskStore;
}

type MaybeReadonlyArray<T> = Array<T> | ReadonlyArray<T>;
type ValueOf<T> = T[keyof T];
/**
 * JSON Schema [Draft 2020-12](https://json-schema.org/draft/2020-12/json-schema-validation.html)
 */
type JSONSchema<Value = any, SchemaType = Value extends boolean ? "boolean" : Value extends null ? "null" : Value extends number ? "number" | "integer" : Value extends string ? "string" : Value extends unknown[] ? "array" : Value extends Record<string | number, unknown> ? "object" : JSONSchema.TypeValue> = boolean | {
    /**
     * Using JSON Pointer fragments requires knowledge of the structure of the
     * schema. When writing schema documents with the intention to provide
     * re-usable schemas, it may be preferable to use a plain name fragment
     * that is not tied to any particular structural location.  This allows a
     * subschema to be relocated without requiring JSON Pointer references to
     * be updated.
     *
     * The `$anchor` keyword is used to specify such a fragment.  It is an
     * identifier keyword that can only be used to create plain name fragments.
     *
     * If present, the value of this keyword MUST be a string, which MUST start
     * with a letter `[A-Za-z]`, followed by any number of letters, digits
     * `[0-9]`, hyphens `-`, underscores `_`, colons `:`,
     * or periods `.`.
     *
     * Note that the anchor string does not include the `#` character,
     * as it is not a URI-reference.  An `{"$anchor": "foo"}` becomes the
     * fragment `#foo` when used in a URI.
     *
     * The base URI to which the resulting fragment is appended is determined
     * by the `$id` keyword as explained in the previous section.
     * Two `$anchor` keywords in the same schema document MAY have the same
     * value if they apply to different base URIs, as the resulting full URIs
     * will be distinct.  However, the effect of two `$anchor` keywords
     * with the same value and the same base URI is undefined.  Implementations
     * MAY raise an error if such usage is detected.
     */
    $anchor?: string;
    /**
     * This keyword reserves a location for comments from schema authors to
     * readers or maintainers of the schema.
     *
     * The value of this keyword MUST be a string. Implementations MUST NOT
     * present this string to end users.  Tools for editing schemas SHOULD
     * support displaying and editing this keyword.  The value of this keyword
     * MAY be used in debug or error output which is intended for developers
     * making use of schemas.
     *
     * Schema vocabularies SHOULD allow `$comment` within any object
     * containing vocabulary keywords.  Implementations MAY assume `$comment`
     * is allowed unless the vocabulary specifically forbids it.  Vocabularies
     * MUST NOT specify any effect of `$comment` beyond what is described in
     * this specification.
     *
     * Tools that translate other media types or programming languages
     * to and from `application/schema+json` MAY choose to convert that media
     * type or programming language's native comments to or from `$comment`
     * values. The behavior of such translation when both native comments and
     * `$comment` properties are present is implementation-dependent.
     *
     * Implementations MAY strip `$comment` values at any point during
     * processing. In particular, this allows for shortening schemas when the
     * size of deployed schemas is a concern.
     *
     * Implementations MUST NOT take any other action based on the presence,
     * absence, or contents of `$comment` properties.  In particular, the
     * value of `$comment` MUST NOT be collected as an annotation result.
     */
    $comment?: string;
    /**
     * The `$defs` keyword reserves a location for schema authors to inline
     * re-usable JSON Schemas into a more general schema. The keyword does not
     * directly affect the validation result.
     *
     * This keyword's value MUST be an object. Each member value of this object
     * MUST be a valid JSON Schema.
     */
    $defs?: Record<string, JSONSchema>;
    /**
     * "The `$dynamicAnchor` indicates that the fragment is an extension
     * point when used with the `$dynamicRef` keyword. This low-level,
     * advanced feature makes it easier to extend recursive schemas such as the
     * meta-schemas, without imposing any particular semantics on that
     * extension. See `$dynamicRef` for more details.
     */
    $dynamicAnchor?: string;
    /**
     * The `$dynamicRef` keyword is an applicator that allows for deferring
     * the full resolution until runtime, at which point it is resolved each
     * time it is encountered while evaluating an instance.
     *
     * Together with `$dynamicAnchor`, `$dynamicRef` implements a
     * cooperative extension mechanism that is primarily useful with recursive
     * schemas (schemas that reference themselves).  Both the extension point
     * and the runtime-determined extension target are defined with
     * `$dynamicAnchor`, and only exhibit runtime dynamic behavior when
     * referenced with `$dynamicRef`.
     *
     * The value of the `$dynamicRef` property MUST be a string which is
     * a URI-Reference.  Resolved against the current URI base, it produces
     * the URI used as the starting point for runtime resolution.  This initial
     * resolution is safe to perform on schema load.
     *
     * If the initially resolved starting point URI includes a fragment that
     * was created by the `$dynamicAnchor` keyword, the initial URI MUST be
     * replaced by the URI (including the fragment) for the outermost schema
     * resource in the [dynamic scope][scopes] that defines
     * an identically named fragment with `$dynamicAnchor`.
     *
     * Otherwise, its behavior is identical to `$ref`, and no runtime
     * resolution is needed.
     *
     * [scopes]: https://json-schema.org/draft/2020-12/json-schema-core.html#scopes
     *
     * @format "uri-reference"
     */
    $dynamicRef?: string;
    /**
     * The `$id` keyword identifies a schema resource with its
     * [canonical][[RFC6596]] URI.
     *
     * Note that this URI is an identifier and not necessarily a network
     * locator. In the case of a network-addressable URL, a schema need not be
     * downloadable from its canonical URI.
     *
     * If present, the value for this keyword MUST be a string, and MUST
     * represent a valid [URI-reference][RFC3986].  This URI-reference SHOULD
     * be normalized, and MUST resolve to an [absolute-URI][RFC3986] (without a
     * fragment).  Therefore, `$id` MUST NOT contain a non-empty fragment,
     * and SHOULD NOT contain an empty fragment.
     *
     * Since an empty fragment in the context of the
     * `application/schema+json` media type refers to the same resource as
     * the base URI without a fragment, an implementation MAY normalize a URI
     * ending with an empty fragment by removing the fragment.  However, schema
     * authors SHOULD NOT rely on this behavior across implementations.
     *
     * This URI also serves as the base URI for relative URI-references in
     * keywords within the schema resource, in accordance with
     * [RFC 3986][RFC3986] section 5.1.1 regarding base URIs embedded in
     * content.
     *
     * The presence of `$id` in a subschema indicates that the subschema
     * constitutes a distinct schema resource within a single schema document.
     * Furthermore, in accordance with [RFC 3986][RFC3986] section 5.1.2
     * regarding encapsulating entities, if an `$id` in a subschema is a
     * relative URI-reference, the base URI for resolving that reference is the
     * URI of the parent schema resource.
     *
     * If no parent schema object explicitly identifies itself as a resource
     * with `$id`, the base URI is that of the entire document.
     *
     * The root schema of a JSON Schema document SHOULD contain an `$id`
     * keyword with an [absolute-URI][RFC3986] (containing a scheme, but no
     * fragment).
     *
     * [RFC6596]: https://datatracker.ietf.org/doc/html/rfc6596
     * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986
     *
     * @format "uri-reference"
     */
    $id?: string;
    /**
     * The `$ref` keyword is an applicator that is used to reference a
     * statically identified schema. Its results are the results of the
     * referenced schema. Other keywords can appear alongside of `$ref` in
     * the same schema object.
     *
     * The value of the `$ref` property MUST be a string which is a
     * URI-Reference. Resolved against the current URI base, it produces the
     * URI of the schema to apply.
     *
     * @format "uri-reference"
     */
    $ref?: string;
    /**
     * The `$schema` keyword is both used as a JSON Schema dialect identifier
     * and as the identifier of a resource which is itself a JSON Schema, which
     * describes the set of valid schemas written for this particular dialect.
     *
     * The value of this keyword MUST be a [URI][RFC3986] (containing a scheme)
     * and this URI MUST be normalized. The current schema MUST be valid
     * against the meta-schema identified by this URI.
     *
     * If this URI identifies a retrievable resource, that resource SHOULD be
     * of media type `application/schema+json`.
     *
     * The `$schema` keyword SHOULD be used in the document root schema
     * object, and MAY be used in the root schema objects of embedded schema
     * resources. It MUST NOT appear in non-resource root schema objects.  If
     * absent from the document root schema, the resulting behavior is
     * implementation-defined.
     *
     * Values for this property are defined elsewhere in this and other
     * documents, and by other parties.
     *
     * [RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986
     *
     * @format "uri"
     */
    $schema?: string;
    /**
     * The `$vocabulary` keyword is used in meta-schemas to identify the
     * vocabularies available for use in schemas described by that meta-schema.
     * It is also used to indicate whether each vocabulary is required or
     * optional, in the sense that an implementation MUST understand the
     * required vocabularies in order to successfully process the schema.
     * Together, this information forms a dialect. Any vocabulary that is
     * understood by the implementation MUST be processed in a manner
     * consistent with the semantic definitions contained within the
     * vocabulary.
     *
     * The value of this keyword MUST be an object.  The property names in the
     * object MUST be URIs (containing a scheme) and this URI MUST be
     * normalized. Each URI that appears as a property name identifies a
     * specific set of keywords and their semantics.
     *
     * The URI MAY be a URL, but the nature of the retrievable resource is
     * currently undefined, and reserved for future use.  Vocabulary authors
     * MAY use the URL of the vocabulary specification, in a human-readable
     * media type such as `text/html` or `text/plain`, as the vocabulary
     * URI.
     *
     * The values of the object properties MUST be booleans. If the value is
     * `true`, then implementations that do not recognize the vocabulary MUST
     * refuse to process any schemas that declare this meta-schema with
     * `$schema`.  If the value is `false`, implementations that do not
     * recognize the vocabulary SHOULD proceed with processing such schemas.
     * The value has no impact if the implementation understands the
     * vocabulary.
     *
     * Unrecognized keywords SHOULD be ignored.  This remains the case for
     * keywords defined by unrecognized vocabularies.  It is not currently
     * possible to distinguish between unrecognized keywords that are defined
     * in vocabularies from those that are not part of any vocabulary.
     *
     * The `$vocabulary` keyword SHOULD be used in the root schema of any
     * schema document intended for use as a meta-schema.  It MUST NOT appear
     * in subschemas.
     *
     * The `$vocabulary` keyword MUST be ignored in schema documents that are
     * not being processed as a meta-schema.
     */
    $vocabulary?: Record<string, string>;
    /**
     * @deprecated `additionalItems` has been deprecated in favor of `prefixItems`
     * paired with `items`.
     */
    additionalItems?: JSONSchema;
    /**
     * The value of `additionalProperties` MUST be a valid JSON Schema.
     *
     * The behavior of this keyword depends on the presence and annotation
     * results of `properties` and `patternProperties` within the same
     * schema object. Validation with `additionalProperties` applies only to
     * the child values of instance names that do not appear in the annotation
     * results of either `properties` or `patternProperties`.
     *
     * For all such properties, validation succeeds if the child instance
     * validates against the `additionalProperties` schema.
     *
     * The annotation result of this keyword is the set of instance property
     * names validated by this keyword's subschema. Annotation results for
     * `additionalProperties` keywords from multiple schemas applied to the
     * same instance location are combined by taking the union of the sets.
     *
     * Omitting this keyword has the same assertion behavior as an empty
     * schema.
     *
     * Implementations MAY choose to implement or optimize this keyword in
     * another way that produces the same effect, such as by directly checking
     * the names in `properties` and the patterns in `patternProperties`
     * against the instance property set.
     */
    additionalProperties?: JSONSchema;
    /**
     * This keyword's value MUST be a non-empty array. Each item of the array
     * MUST be a valid JSON Schema.
     *
     * An instance validates successfully against this keyword if it validates
     * successfully against all schemas defined by this keyword's value.
     */
    allOf?: MaybeReadonlyArray<JSONSchema<Value, SchemaType>>;
    /**
     * This keyword's value MUST be a non-empty array. Each item of the array
     * MUST be a valid JSON Schema.
     *
     * An instance validates successfully against this keyword if it validates
     * successfully against at least one schema defined by this keyword's
     * value.
     */
    anyOf?: MaybeReadonlyArray<JSONSchema<Value, SchemaType>>;
    /**
     * An instance validates successfully against this keyword if its value is
     * equal to the value of the keyword.
     *
     * Use of this keyword is functionally equivalent to the `enum` keyword
     * with a single value.
     */
    const?: Value;
    /**
     * The value of this keyword MUST be a valid JSON Schema.
     *
     * An array instance is valid against `contains` if at least one of its
     * elements is valid against the given schema. The subschema MUST be
     * applied to every array element even after the first match has been
     * found, in order to collect annotations for use by other keywords.
     * This is to ensure that all possible annotations are collected.
     *
     * Logically, the validation result of applying the value subschema to each
     * item in the array MUST be OR'ed with `false`, resulting in an overall
     * validation result.
     *
     * This keyword produces an annotation value which is an array of the
     * indexes to which this keyword validates successfully when applying its
     * subschema, in ascending order. The value MAY be a boolean `true` if
     * the subschema validates successfully when applied to every index of the
     * instance. The annotation MUST be present if the instance array to which
     * this keyword's schema applies is empty.
     */
    contains?: JSONSchema<Value, SchemaType>;
    /**
     * If the instance value is a string, this property defines that the
     * string SHOULD be interpreted as binary data and decoded using the
     * encoding named by this property. [RFC 2045, Sec 6.1][RFC2045] lists the
     * possible values for this property.
     *
     * The value of this property SHOULD be ignored if the instance described
     * is not a string.
     *
     * If this keyword is absent, but `contentMediaType` is present, this
     * indicates that the media type could be encoded into `UTF-8` like any
     * other JSON string value, and does not require additional decoding.
     *
     * The value of this property MUST be a string.
     *
     * [RFC2045]: https://datatracker.ietf.org/doc/html/rfc2045#section-6.1
     */
    contentEncoding?: "7bit" | "8bit" | "base64" | "binary" | "ietf-token" | "quoted-printable" | "x-token";
    /**
     * If the instance is a string, this property indicates the media type
     * of the contents of the string.  If `contentEncoding` is present,
     * this property describes the decoded string.
     *
     * The value of this property must be a media type, as defined by
     * [RFC 2046][RFC2046]. This property defines the media type of instances
     * which this schema defines.
     *
     * The value of this property SHOULD be ignored if the instance described
     * is not a string.
     *
     * If the `contentEncoding` property is not present, but the instance
     * value is a string, then the value of this property SHOULD specify a text
     * document type, and the character set SHOULD be the character set into
     * which the JSON string value was decoded (for which the default is
     * Unicode).
     *
     * [RFC2046]: https://datatracker.ietf.org/doc/html/rfc2046
     */
    contentMediaType?: string;
    /**
     * If the instance is a string, and if `contentMediaType` is present,
     * this property contains a schema which describes the structure of the
     * string.
     *
     * This keyword MAY be used with any media type that can be mapped into
     * JSON Schema's data model.
     *
     * The value of this property MUST be a valid JSON schema. It SHOULD be
     * ignored if `contentMediaType` is not present.
     */
    contentSchema?: JSONSchema<Value, SchemaType>;
    /**
     * This keyword can be used to supply a default JSON value associated with
     * a particular schema. It is RECOMMENDED that a `default` value be valid
     * against the associated schema.
     */
    default?: Value;
    /**
     * @deprecated `definitions` has been renamed to `$defs`.
     */
    definitions?: Record<string, JSONSchema>;
    /**
     * @deprecated `dependencies` has been split into two keywords:
     * `dependentSchemas` and `dependentRequired`.
     */
    dependencies?: Record<string, MaybeReadonlyArray<string> | JSONSchema>;
    /**
     * The value of this keyword MUST be an object.  Properties in
     * this object, if any, MUST be arrays.  Elements in each array,
     * if any, MUST be strings, and MUST be unique.
     *
     * This keyword specifies properties that are required if a specific
     * other property is present.  Their requirement is dependent on the
     * presence of the other property.
     *
     * Validation succeeds if, for each name that appears in both
     * the instance and as a name within this keyword's value, every
     * item in the corresponding array is also the name of a property
     * in the instance.
     *
     * Omitting this keyword has the same behavior as an empty object.
     */
    dependentRequired?: Record<string, MaybeReadonlyArray<string>>;
    /**
     * This keyword specifies subschemas that are evaluated if the instance is
     * an object and contains a certain property.
     *
     * This keyword's value MUST be an object. Each value in the object MUST be
     * a valid JSON Schema.
     *
     * If the object key is a property in the instance, the entire instance
     * must validate against the subschema. Its use is dependent on the
     * presence of the property.
     *
     * Omitting this keyword has the same behavior as an empty object.
     */
    dependentSchemas?: Record<string, JSONSchema>;
    /**
     * The value of this keyword MUST be a boolean.  When multiple occurrences
     * of this keyword are applicable to a single sub-instance, applications
     * SHOULD consider the instance location to be deprecated if any occurrence
     * specifies a `true` value.
     *
     * If `deprecated` has a value of boolean `true`, it indicates that
     * applications SHOULD refrain from usage of the declared property. It MAY
     * mean the property is going to be removed in the future.
     *
     * A root schema containing `deprecated` with a value of `true`
     * indicates that the entire resource being described MAY be removed in the
     * future.
     *
     * The `deprecated` keyword applies to each instance location to which
     * the schema object containing the keyword successfully applies.  This can
     * result in scenarios where every array item or object property is
     * deprecated even though the containing array or object is not.
     *
     * Omitting this keyword has the same behavior as a value of `false`.
     */
    deprecated?: boolean;
    /**
     * Can be used to decorate a user interface with explanation or information
     * about the data produced.
     */
    description?: string;
    /**
     * This keyword's value MUST be a valid JSON Schema.
     *
     * When `if` is present, and the instance fails to validate against its
     * subschema, then validation succeeds against this keyword if the instance
     * successfully validates against this keyword's subschema.
     *
     * This keyword has no effect when `if` is absent, or when the instance
     * successfully validates against its subschema. Implementations MUST NOT
     * evaluate the instance against this keyword, for either validation or
     * annotation collection purposes, in such cases.
     */
    else?: JSONSchema<Value, SchemaType>;
    /**
     * The value of this keyword MUST be an array. This array SHOULD have at
     * least one element. Elements in the array SHOULD be unique.
     *
     * An instance validates successfully against this keyword if its value is
     * equal to one of the elements in this keyword's array value.
     *
     * Elements in the array might be of any type, including `null`.
     */
    enum?: MaybeReadonlyArray<Value>;
    /**
     * The value of this keyword MUST be an array. When multiple occurrences of
     * this keyword are applicable to a single sub-instance, implementations
     * MUST provide a flat array of all values rather than an array of arrays.
     *
     * This keyword can be used to provide sample JSON values associated with a
     * particular schema, for the purpose of illustrating usage. It is
     * RECOMMENDED that these values be valid against the associated schema.
     *
     * Implementations MAY use the value(s) of `default`, if present, as an
     * additional example. If `examples` is absent, `default` MAY still be
     * used in this manner.
     */
    examples?: MaybeReadonlyArray<Value>;
    /**
     * The value of `exclusiveMaximum` MUST be a number, representing an
     * exclusive upper limit for a numeric instance.
     *
     * If the instance is a number, then the instance is valid only if it has a
     * value strictly less than (not equal to) `exclusiveMaximum`.
     */
    exclusiveMaximum?: number;
    /**
     * The value of `exclusiveMinimum` MUST be a number, representing an
     * exclusive lower limit for a numeric instance.
     *
     * If the instance is a number, then the instance is valid only if it has a
     * value strictly greater than (not equal to) `exclusiveMinimum`.
     */
    exclusiveMinimum?: number;
    /**
     * Implementations MAY treat `format` as an assertion in addition to an
     * annotation, and attempt to validate the value's conformance to the
     * specified semantics.
     *
     * The value of this keyword is called a format attribute. It MUST be a
     * string. A format attribute can generally only validate a given set
     * of instance types. If the type of the instance to validate is not in
     * this set, validation for this format attribute and instance SHOULD
     * succeed. Format attributes are most often applied to strings, but can
     * be specified to apply to any type.
     *
     * Implementations MAY support custom format attributes. Save for agreement
     * between parties, schema authors SHALL NOT expect a peer implementation
     * to support such custom format attributes.  An implementation MUST NOT
     * fail validation or cease processing due to an unknown format attribute.
     * When treating `format` as an annotation, implementations SHOULD
     * collect both known and unknown format attribute values.
     */
    format?: string;
    /**
     * This keyword's value MUST be a valid JSON Schema.
     *
     * This validation outcome of this keyword's subschema has no direct effect
     * on the overall validation result. Rather, it controls which of the
     * `then` or `else` keywords are evaluated.
     *
     * Instances that successfully validate against this keyword's subschema
     * MUST also be valid against the subschema value of the `then` keyword,
     * if present.
     *
     * Instances that fail to validate against this keyword's subschema MUST
     * also be valid against the subschema value of the `else` keyword, if
     * present.
     *
     * If annotations are being collected, they are collected
     * from this keyword's subschema in the usual way, including when the
     * keyword is present without either `then` or `else`.
     */
    if?: JSONSchema<Value, SchemaType>;
    /**
     * The value of `items` MUST be a valid JSON Schema.
     *
     * This keyword applies its subschema to all instance elements at indexes
     * greater than the length of the `prefixItems` array in the same schema
     * object, as reported by the annotation result of that `prefixItems`
     * keyword.  If no such annotation result exists, `items` applies its
     * subschema to all instance array elements.
     *
     * Note that the behavior of `items` without `prefixItems` is identical
     * to that of the schema form of `items` in prior drafts.
     *
     * When `prefixItems` is present, the behavior of `items` is identical
     * to the former `additionalItems` keyword.
     *
     * If the `items` subschema is applied to any positions within the
     * instance array, it produces an annotation result of boolean `true`,
     * indicating that all remaining array elements have been evaluated against
     * this keyword's subschema.
     *
     * Omitting this keyword has the same assertion behavior as an empty
     * schema.
     *
     * Implementations MAY choose to implement or optimize this keyword
     * in another way that produces the same effect, such as by directly
     * checking for the presence and size of a `prefixItems` array.
     */
    items?: JSONSchema;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * If `contains` is not present within the same schema object, then this
     * keyword has no effect.
     *
     * An instance array is valid against `maxContains` in two ways,
     * depending on the form of the annotation result of an adjacent
     * `contains` keyword. The first way is if the annotation result is an
     * array and the length of that array is less than or equal to the
     * `maxContains` value. The second way is if the annotation result is a
     * boolean `true` and the instance array length is less than or equal to
     * the `maxContains` value.
     */
    maxContains?: number;
    /**
     * The value of `maximum` MUST be a number, representing an inclusive
     * upper limit for a numeric instance.
     *
     * If the instance is a number, then this keyword validates only if the
     * instance is less than or exactly equal to `maximum`.
     */
    maximum?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * An array instance is valid against `maxItems` if its size is less
     * than, or equal to, the value of this keyword.
     *
     * @minimum 0
     */
    maxItems?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * A string instance is valid against this keyword if its length is less
     * than, or equal to, the value of this keyword.
     *
     * The length of a string instance is defined as the number of its
     * characters as defined by [RFC 8259][RFC8259].
     *
     * [RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259
     *
     * @minimum 0
     */
    maxLength?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * An object instance is valid against `maxProperties` if its number of
     * `properties` is less than, or equal to, the value of this keyword.
     *
     * @minimum 0
     */
    maxProperties?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * If `contains` is not present within the same schema object, then this
     * keyword has no effect.
     *
     * An instance array is valid against `minContains` in two ways,
     * depending on the form of the annotation result of an adjacent
     * `contains` keyword. The first way is if the annotation result is an
     * array and the length of that array is greater than or equal to the
     * `minContains` value. The second way is if the annotation result is a
     * boolean `true` and the instance array length is greater than or equal
     * to the `minContains` value.
     *
     * A value of `0` is allowed, but is only useful for setting a range
     * of occurrences from `0` to the value of `maxContains`.  A value of
     * `0` with no `maxContains` causes `contains` to always pass
     * validation.
     *
     * Omitting this keyword has the same behavior as a value of `1`.
     *
     * @default 1
     */
    minContains?: number;
    /**
     * The value of `minimum` MUST be a number, representing an inclusive
     * lower limit for a numeric instance.
     *
     * If the instance is a number, then this keyword validates only if the
     * instance is greater than or exactly equal to `minimum`.
     */
    minimum?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * An array instance is valid against `minItems` if its size is greater
     * than, or equal to, the value of this keyword.
     *
     * Omitting this keyword has the same behavior as a value of `0`.
     *
     * @default 0
     * @minimum 0
     */
    minItems?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * A string instance is valid against this keyword if its length is greater
     * than, or equal to, the value of this keyword.
     *
     * The length of a string instance is defined as the number of its
     * characters as defined by [RFC 8259][RFC8259].
     *
     * Omitting this keyword has the same behavior as a value of `0`.
     *
     * [RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259
     *
     * @default 0
     * @minimum 0
     */
    minLength?: number;
    /**
     * The value of this keyword MUST be a non-negative integer.
     *
     * An object instance is valid against `minProperties` if its number of
     * `properties` is greater than, or equal to, the value of this keyword.
     *
     * Omitting this keyword has the same behavior as a value of `0`.
     *
     * @default 0
     * @minimum 0
     */
    minProperties?: number;
    /**
     * The value of `multipleOf` MUST be a number, strictly greater than
     * `0`.
     *
     * A numeric instance is valid only if division by this keyword's value
     * results in an integer.
     *
     * @exclusiveMinimum 0
     */
    multipleOf?: number;
    /**
     * This keyword's value MUST be a valid JSON Schema.
     *
     * An instance is valid against this keyword if it fails to validate
     * successfully against the schema defined by this keyword.
     */
    not?: JSONSchema<Value, SchemaType>;
    /**
     * This keyword's value MUST be a non-empty array. Each item of the array
     * MUST be a valid JSON Schema.
     *
     * An instance validates successfully against this keyword if it validates
     * successfully against exactly one schema defined by this keyword's value.
     */
    oneOf?: MaybeReadonlyArray<JSONSchema<Value, SchemaType>>;
    /**
     * The value of this keyword MUST be a string. This string SHOULD be a
     * valid regular expression, according to the [ECMA-262][ecma262] regular
     * expression dialect.
     *
     * A string instance is considered valid if the regular expression matches
     * the instance successfully. Recall: regular expressions are not
     * implicitly anchored.
     *
     * [ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/
     *
     * @format "regex"
     */
    pattern?: string;
    /**
     * The value of `patternProperties` MUST be an object. Each property name
     * of this object SHOULD be a valid regular expression, according to the
     * [ECMA-262][ecma262] regular expression dialect. Each property value of
     * this object MUST be a valid JSON Schema.
     *
     * Validation succeeds if, for each instance name that matches any regular
     * expressions that appear as a property name in this keyword's value,
     * the child instance for that name successfully validates against each
     * schema that corresponds to a matching regular expression.
     *
     * The annotation result of this keyword is the set of instance property
     * names matched by this keyword. Omitting this keyword has the same
     * assertion behavior as an empty object.
     *
     * [ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/
     */
    patternProperties?: Record<string, JSONSchema>;
    /**
     * The value of `prefixItems` MUST be a non-empty array of valid JSON
     * Schemas.
     *
     * Validation succeeds if each element of the instance validates against
     * the schema at the same position, if any.  This keyword does not
     * constrain the length of the array.  If the array is longer than this
     * keyword's value, this keyword validates only the prefix of matching
     * length.
     *
     * This keyword produces an annotation value which is the largest index to
     * which this keyword applied a subschema.  The value MAY be a boolean
     * `true` if a subschema was applied to every index of the instance, such
     * as is produced by the `items` keyword.
     * This annotation affects the behavior of `items` and
     * `unevaluatedItems`.
     *
     * Omitting this keyword has the same assertion behavior as an empty array.
     */
    prefixItems?: MaybeReadonlyArray<JSONSchema> | JSONSchema;
    /**
     * The value of `properties` MUST be an object. Each value of this object
     * MUST be a valid JSON Schema.
     *
     * Validation succeeds if, for each name that appears in both the instance
     * and as a name within this keyword's value, the child instance for that
     * name successfully validates against the corresponding schema.
     *
     * The annotation result of this keyword is the set of instance property
     * names matched by this keyword.
     *
     * Omitting this keyword has the same assertion behavior as an empty
     * object.
     */
    properties?: Record<string, JSONSchema>;
    /**
     * The value of `propertyNames` MUST be a valid JSON Schema.
     *
     * If the instance is an object, this keyword validates if every property
     * name in the instance validates against the provided schema.
     * Note the property name that the schema is testing will always be a
     * string.
     *
     * Omitting this keyword has the same behavior as an empty schema.
     */
    propertyNames?: JSONSchema;
    /**
     * The value of this keyword MUST be a boolean. When multiple occurrences
     * of this keyword are applicable to a single sub-instance, the resulting
     * value MUST be `true` if any occurrence specifies a `true` value, and
     * MUST be `false` otherwise.
     *
     * If `readOnly` has a value of boolean `true`, it indicates that the
     * value of the instance is managed exclusively by the owning authority,
     * and attempts by an application to modify the value of this property are
     * expected to be ignored or rejected by that owning authority.
     *
     * An instance document that is marked as `readOnly` for the entire
     * document MAY be ignored if sent to the owning authority, or MAY result
     * in an error, at the authority's discretion.
     *
     * For example, `readOnly` would be used to mark a database-generated
     * serial number as read-only.
     *
     * This keyword can be used to assist in user interface instance
     * generation.
     *
     * @default false
     */
    readOnly?: boolean;
    /**
     * The value of this keyword MUST be an array. Elements of this array, if
     * any, MUST be strings, and MUST be unique.
     *
     * An object instance is valid against this keyword if every item in the
     * array is the name of a property in the instance.
     *
     * Omitting this keyword has the same behavior as an empty array.
     */
    required?: MaybeReadonlyArray<string>;
    /**
     * This keyword's value MUST be a valid JSON Schema.
     *
     * When `if` is present, and the instance successfully validates against
     * its subschema, then validation succeeds against this keyword if the
     * instance also successfully validates against this keyword's subschema.
     *
     * This keyword has no effect when `if` is absent, or when the instance
     * fails to validate against its subschema. Implementations MUST NOT
     * evaluate the instance against this keyword, for either validation or
     * annotation collection purposes, in such cases.
     */
    then?: JSONSchema<Value, SchemaType>;
    /**
     * Can be used to decorate a user interface with a short label about the
     * data produced.
     */
    title?: string;
    /**
     * The value of this keyword MUST be either a string or an array. If it is
     * an array, elements of the array MUST be strings and MUST be unique.
     *
     * String values MUST be one of the six primitive types (`"null"`,
     * `"boolean"`, `"object"`, `"array"`, `"number"`, or
     * `"string"`), or `"integer"` which matches any number with a zero
     * fractional part.
     *
     * An instance validates if and only if the instance is in any of the sets
     * listed for this keyword.
     */
    type?: SchemaType;
    /**
     * The value of `unevaluatedItems` MUST be a valid JSON Schema.
     *
     * The behavior of this keyword depends on the annotation results of
     * adjacent keywords that apply to the instance location being validated.
     * Specifically, the annotations from `prefixItems`, `items`, and
     * `contains`, which can come from those keywords when they are adjacent
     * to the `unevaluatedItems` keyword. Those three annotations, as well as
     * `unevaluatedItems`, can also result from any and all adjacent
     * [in-place applicator][in-place-applicator] keywords.
     *
     * If no relevant annotations are present, the `unevaluatedItems`
     * subschema MUST be applied to all locations in the array.
     * If a boolean `true` value is present from any of the relevant
     * annotations, `unevaluatedItems` MUST be ignored.  Otherwise, the
     * subschema MUST be applied to any index greater than the largest
     * annotation value for `prefixItems`, which does not appear in any
     * annotation value for `contains`.
     *
     * This means that `prefixItems`, `items`, `contains`, and all
     * in-place applicators MUST be evaluated before this keyword can be
     * evaluated. Authors of extension keywords MUST NOT define an in-place
     * applicator that would need to be evaluated after this keyword.
     *
     * If the `unevaluatedItems` subschema is applied to any positions within
     * the instance array, it produces an annotation result of boolean
     * `true`, analogous to the behavior of `items`.
     *
     * Omitting this keyword has the same assertion behavior as an empty
     * schema.
     *
     * [in-place-applicator]: https://json-schema.org/draft/2020-12/json-schema-core.html#in-place
     */
    unevaluatedItems?: JSONSchema;
    /**
     * The value of `unevaluatedProperties` MUST be a valid JSON Schema.
     *
     * The behavior of this keyword depends on the annotation results of
     * adjacent keywords that apply to the instance location being validated.
     * Specifically, the annotations from `properties`,
     * `patternProperties`, and `additionalProperties`, which can come from
     * those keywords when they are adjacent to the `unevaluatedProperties`
     * keyword.  Those three annotations, as well as `unevaluatedProperties`,
     * can also result from any and all adjacent
     * [in-place applicator][in-place-applicator] keywords.
     *
     * Validation with `unevaluatedProperties` applies only to the child
     * values of instance names that do not appear in the `properties`,
     * `patternProperties`, `additionalProperties`, or
     * `unevaluatedProperties` annotation results that apply to the
     * instance location being validated.
     *
     * For all such properties, validation succeeds if the child instance
     * validates against the "unevaluatedProperties" schema.
     *
     * This means that `properties`, `patternProperties`,
     * `additionalProperties`, and all in-place applicators MUST be evaluated
     * before this keyword can be evaluated.  Authors of extension keywords
     * MUST NOT define an in-place applicator that would need to be evaluated
     * after this keyword.
     *
     * The annotation result of this keyword is the set of instance property
     * names validated by this keyword's subschema.
     *
     * Omitting this keyword has the same assertion behavior as an empty
     * schema.
     *
     * [in-place-applicator]: https://json-schema.org/draft/2020-12/json-schema-core.html#in-place
     */
    unevaluatedProperties?: JSONSchema;
    /**
     * The value of this keyword MUST be a boolean.
     *
     * If this keyword has boolean value `false`, the instance validates
     * successfully. If it has boolean value `true`, the instance validates
     * successfully if all of its elements are unique.
     *
     * Omitting this keyword has the same behavior as a value of `false`.
     *
     * @default false
     */
    uniqueItems?: boolean;
    /**
     * The value of this keyword MUST be a boolean. When multiple occurrences
     * of this keyword is applicable to a single sub-instance, the resulting
     * value MUST be `true` if any occurrence specifies a `true` value, and
     * MUST be `false` otherwise.
     *
     * If `writeOnly` has a value of boolean `true`, it indicates that the
     * value is never present when the instance is retrieved from the owning
     * authority. It can be present when sent to the owning authority to update
     * or create the document (or the resource it represents), but it will not
     * be included in any updated or newly created version of the instance.
     *
     * An instance document that is marked as `writeOnly` for the entire
     * document MAY be returned as a blank document of some sort, or MAY
     * produce an error upon retrieval, or have the retrieval request ignored,
     * at the authority's discretion.
     *
     * For example, `writeOnly` would be used to mark a password input field.
     *
     * These keywords can be used to assist in user interface instance
     * generation. In particular, an application MAY choose to use a widget
     * that hides input values as they are typed for write-only fields.
     *
     * @default false
     */
    writeOnly?: boolean;
};
declare namespace JSONSchema {
    type TypeValue = ValueOf<TypeName> | TypeName | Array<ValueOf<TypeName> | TypeName> | ReadonlyArray<ValueOf<TypeName> | TypeName>;
    /**
     * JSON Schema interface
     */
    type Interface<Value = any, SchemaType extends TypeValue = TypeValue> = Exclude<JSONSchema<Value, SchemaType>, boolean>;
    type Array<T = any> = Pick<Interface<T, "array">, KeywordByType.Any | KeywordByType.Array>;
    type Boolean = Pick<Interface<boolean, "boolean">, KeywordByType.Any>;
    type Integer = Pick<Interface<number, "integer">, KeywordByType.Any | KeywordByType.Number>;
    type Number = Pick<Interface<number, "number">, KeywordByType.Any | KeywordByType.Number>;
    type Null = Pick<Interface<null, "null">, KeywordByType.Any>;
    type Object<T = any> = Pick<Interface<T, "object">, KeywordByType.Any | KeywordByType.Object>;
    type String = Pick<Interface<string, "string">, KeywordByType.Any | KeywordByType.String>;
}
declare namespace KeywordByType {
    type Any = "$anchor" | "$comment" | "$defs" | "$dynamicAnchor" | "$dynamicRef" | "$id" | "$ref" | "$schema" | "$vocabulary" | "allOf" | "anyOf" | "const" | "default" | "definitions" | "deprecated" | "description" | "else" | "enum" | "examples" | "format" | "if" | "not" | "oneOf" | "readOnly" | "then" | "title" | "type" | "writeOnly";
    type Array = "additionalItems" | "contains" | "items" | "maxContains" | "maxItems" | "minContains" | "minItems" | "prefixItems" | "unevaluatedItems" | "uniqueItems";
    type Number = "exclusiveMaximum" | "exclusiveMinimum" | "maximum" | "minimum" | "multipleOf";
    type Object = "additionalProperties" | "dependencies" | "dependentRequired" | "dependentSchemas" | "maxProperties" | "minProperties" | "patternProperties" | "properties" | "propertyNames" | "required" | "unevaluatedProperties";
    type String = "contentEncoding" | "contentMediaType" | "contentSchema" | "maxLength" | "minLength" | "pattern";
}
/**
 * Enum consisting of simple type names for the `type` keyword
 */
declare enum TypeName {
    /**
     * Value MUST be an array.
     */
    Array = "array",
    /**
     * Value MUST be a boolean.
     */
    Boolean = "boolean",
    /**
     * Value MUST be an integer, no floating point numbers are allowed. This is a
     * subset of the number type.
     */
    Integer = "integer",
    /**
     * Value MUST be null. Note this is mainly for purpose of being able use union
     * types to define nullability. If this type is not included in a union, null
     * values are not allowed (the primitives listed above do not allow nulls on
     * their own).
     */
    Null = "null",
    /**
     * Value MUST be a number, floating point numbers are allowed.
     */
    Number = "number",
    /**
     * Value MUST be an object.
     */
    Object = "object",
    /**
     * Value MUST be a string.
     */
    String = "string"
}

/**
 * JSON Schema type definition (JSON Schema Draft 2020-12)
 *
 * This uses the object form of JSON Schema (excluding boolean schemas).
 * While `true` and `false` are valid JSON Schemas, this SDK uses the
 * object form for practical type safety.
 *
 * Re-exported from json-schema-typed for convenience.
 * @see https://json-schema.org/draft/2020-12/json-schema-core.html
 */
type JsonSchemaType = JSONSchema.Interface;
/**
 * Result of a JSON Schema validation operation
 */
type JsonSchemaValidatorResult<T> = {
    valid: true;
    data: T;
    errorMessage: undefined;
} | {
    valid: false;
    data: undefined;
    errorMessage: string;
};
/**
 * A validator function that validates data against a JSON Schema
 */
type JsonSchemaValidator<T> = (input: unknown) => JsonSchemaValidatorResult<T>;
/**
 * Provider interface for creating validators from JSON Schemas
 *
 * This is the main extension point for custom validator implementations.
 * Implementations should:
 * - Support JSON Schema Draft 2020-12 (or be compatible with it)
 * - Return validator functions that can be called multiple times
 * - Handle schema compilation/caching internally
 * - Provide clear error messages on validation failure
 *
 * @example
 * ```typescript
 * class MyValidatorProvider implements jsonSchemaValidator {
 *   getValidator<T>(schema: JsonSchemaType<T>): JsonSchemaValidator<T> {
 *     // Compile/cache validator from schema
 *     return (input: unknown) => {
 *       // Validate input against schema
 *       if (valid) {
 *         return { valid: true, data: input as T, errorMessage: undefined };
 *       } else {
 *         return { valid: false, data: undefined, errorMessage: 'Error details' };
 *       }
 *     };
 *   }
 * }
 * ```
 */
interface jsonSchemaValidator {
    /**
     * Create a validator for the given JSON Schema
     *
     * @param schema - Standard JSON Schema object
     * @returns A validator function that can be called multiple times
     */
    getValidator<T>(schema: JsonSchemaType): JsonSchemaValidator<T>;
}

/**
 * Experimental server task features for MCP SDK.
 * WARNING: These APIs are experimental and may change without notice.
 *
 * @experimental
 */

/**
 * Experimental task features for low-level MCP servers.
 *
 * Access via `server.experimental.tasks`:
 * ```typescript
 * const stream = server.experimental.tasks.requestStream(request, schema, options);
 * ```
 *
 * For high-level server usage with task-based tools, use `McpServer.experimental.tasks` instead.
 *
 * @experimental
 */
declare class ExperimentalServerTasks<RequestT extends Request = Request, NotificationT extends Notification = Notification, ResultT extends Result = Result> {
    private readonly _server;
    constructor(_server: Server<RequestT, NotificationT, ResultT>);
    /**
     * Sends a request and returns an AsyncGenerator that yields response messages.
     * The generator is guaranteed to end with either a 'result' or 'error' message.
     *
     * This method provides streaming access to request processing, allowing you to
     * observe intermediate task status updates for task-augmented requests.
     *
     * @param request - The request to send
     * @param resultSchema - Zod schema for validating the result
     * @param options - Optional request options (timeout, signal, task creation params, etc.)
     * @returns AsyncGenerator that yields ResponseMessage objects
     *
     * @experimental
     */
    requestStream<T extends AnySchema>(request: ServerRequest | RequestT, resultSchema: T, options?: RequestOptions): AsyncGenerator<ResponseMessage<SchemaOutput<T>>, void, void>;
    /**
     * Gets the current status of a task.
     *
     * @param taskId - The task identifier
     * @param options - Optional request options
     * @returns The task status
     *
     * @experimental
     */
    getTask(taskId: string, options?: RequestOptions): Promise<GetTaskResult>;
    /**
     * Retrieves the result of a completed task.
     *
     * @param taskId - The task identifier
     * @param resultSchema - Zod schema for validating the result
     * @param options - Optional request options
     * @returns The task result
     *
     * @experimental
     */
    getTaskResult<T extends AnySchema>(taskId: string, resultSchema?: T, options?: RequestOptions): Promise<SchemaOutput<T>>;
    /**
     * Lists tasks with optional pagination.
     *
     * @param cursor - Optional pagination cursor
     * @param options - Optional request options
     * @returns List of tasks with optional next cursor
     *
     * @experimental
     */
    listTasks(cursor?: string, options?: RequestOptions): Promise<ListTasksResult>;
    /**
     * Cancels a running task.
     *
     * @param taskId - The task identifier
     * @param options - Optional request options
     *
     * @experimental
     */
    cancelTask(taskId: string, options?: RequestOptions): Promise<CancelTaskResult>;
}

type ServerOptions = ProtocolOptions & {
    /**
     * Capabilities to advertise as being supported by this server.
     */
    capabilities?: ServerCapabilities;
    /**
     * Optional instructions describing how to use the server and its features.
     */
    instructions?: string;
    /**
     * JSON Schema validator for elicitation response validation.
     *
     * The validator is used to validate user input returned from elicitation
     * requests against the requested schema.
     *
     * @default AjvJsonSchemaValidator
     *
     * @example
     * ```typescript
     * // ajv (default)
     * const server = new Server(
     *   { name: 'my-server', version: '1.0.0' },
     *   {
     *     capabilities: {}
     *     jsonSchemaValidator: new AjvJsonSchemaValidator()
     *   }
     * );
     *
     * // @cfworker/json-schema
     * const server = new Server(
     *   { name: 'my-server', version: '1.0.0' },
     *   {
     *     capabilities: {},
     *     jsonSchemaValidator: new CfWorkerJsonSchemaValidator()
     *   }
     * );
     * ```
     */
    jsonSchemaValidator?: jsonSchemaValidator;
};
/**
 * An MCP server on top of a pluggable transport.
 *
 * This server will automatically respond to the initialization flow as initiated from the client.
 *
 * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
 *
 * ```typescript
 * // Custom schemas
 * const CustomRequestSchema = RequestSchema.extend({...})
 * const CustomNotificationSchema = NotificationSchema.extend({...})
 * const CustomResultSchema = ResultSchema.extend({...})
 *
 * // Type aliases
 * type CustomRequest = z.infer<typeof CustomRequestSchema>
 * type CustomNotification = z.infer<typeof CustomNotificationSchema>
 * type CustomResult = z.infer<typeof CustomResultSchema>
 *
 * // Create typed server
 * const server = new Server<CustomRequest, CustomNotification, CustomResult>({
 *   name: "CustomServer",
 *   version: "1.0.0"
 * })
 * ```
 * @deprecated Use `McpServer` instead for the high-level API. Only use `Server` for advanced use cases.
 */
declare class Server<RequestT extends Request = Request, NotificationT extends Notification = Notification, ResultT extends Result = Result> extends Protocol<ServerRequest | RequestT, ServerNotification | NotificationT, ServerResult | ResultT> {
    private _serverInfo;
    private _clientCapabilities?;
    private _clientVersion?;
    private _capabilities;
    private _instructions?;
    private _jsonSchemaValidator;
    private _experimental?;
    /**
     * Callback for when initialization has fully completed (i.e., the client has sent an `initialized` notification).
     */
    oninitialized?: () => void;
    /**
     * Initializes this server with the given name and version information.
     */
    constructor(_serverInfo: Implementation, options?: ServerOptions);
    /**
     * Access experimental features.
     *
     * WARNING: These APIs are experimental and may change without notice.
     *
     * @experimental
     */
    get experimental(): {
        tasks: ExperimentalServerTasks<RequestT, NotificationT, ResultT>;
    };
    private _loggingLevels;
    private readonly LOG_LEVEL_SEVERITY;
    private isMessageIgnored;
    /**
     * Registers new capabilities. This can only be called before connecting to a transport.
     *
     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
     */
    registerCapabilities(capabilities: ServerCapabilities): void;
    /**
     * Override request handler registration to enforce server-side validation for tools/call.
     */
    setRequestHandler<T extends AnyObjectSchema>(requestSchema: T, handler: (request: SchemaOutput<T>, extra: RequestHandlerExtra<ServerRequest | RequestT, ServerNotification | NotificationT>) => ServerResult | ResultT | Promise<ServerResult | ResultT>): void;
    protected assertCapabilityForMethod(method: RequestT['method']): void;
    protected assertNotificationCapability(method: (ServerNotification | NotificationT)['method']): void;
    protected assertRequestHandlerCapability(method: string): void;
    protected assertTaskCapability(method: string): void;
    protected assertTaskHandlerCapability(method: string): void;
    private _oninitialize;
    /**
     * After initialization has completed, this will be populated with the client's reported capabilities.
     */
    getClientCapabilities(): ClientCapabilities | undefined;
    /**
     * After initialization has completed, this will be populated with information about the client's name and version.
     */
    getClientVersion(): Implementation | undefined;
    private getCapabilities;
    ping(): Promise<{
        _meta?: {
            [x: string]: unknown;
            progressToken?: string | number | undefined;
            "io.modelcontextprotocol/related-task"?: {
                taskId: string;
            } | undefined;
        } | undefined;
    }>;
    /**
     * Request LLM sampling from the client (without tools).
     * Returns single content block for backwards compatibility.
     */
    createMessage(params: CreateMessageRequestParamsBase, options?: RequestOptions): Promise<CreateMessageResult>;
    /**
     * Request LLM sampling from the client with tool support.
     * Returns content that may be a single block or array (for parallel tool calls).
     */
    createMessage(params: CreateMessageRequestParamsWithTools, options?: RequestOptions): Promise<CreateMessageResultWithTools>;
    /**
     * Request LLM sampling from the client.
     * When tools may or may not be present, returns the union type.
     */
    createMessage(params: CreateMessageRequest['params'], options?: RequestOptions): Promise<CreateMessageResult | CreateMessageResultWithTools>;
    /**
     * Creates an elicitation request for the given parameters.
     * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
     * @param params The parameters for the elicitation request.
     * @param options Optional request options.
     * @returns The result of the elicitation request.
     */
    elicitInput(params: ElicitRequestFormParams | ElicitRequestURLParams, options?: RequestOptions): Promise<ElicitResult>;
    /**
     * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
     * notification for the specified elicitation ID.
     *
     * @param elicitationId The ID of the elicitation to mark as complete.
     * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
     * @returns A function that emits the completion notification when awaited.
     */
    createElicitationCompletionNotifier(elicitationId: string, options?: NotificationOptions): () => Promise<void>;
    listRoots(params?: ListRootsRequest['params'], options?: RequestOptions): Promise<{
        [x: string]: unknown;
        roots: {
            uri: string;
            name?: string | undefined;
            _meta?: Record<string, unknown> | undefined;
        }[];
        _meta?: {
            [x: string]: unknown;
            progressToken?: string | number | undefined;
            "io.modelcontextprotocol/related-task"?: {
                taskId: string;
            } | undefined;
        } | undefined;
    }>;
    /**
     * Sends a logging message to the client, if connected.
     * Note: You only need to send the parameters object, not the entire JSON RPC message
     * @see LoggingMessageNotification
     * @param params
     * @param sessionId optional for stateless and backward compatibility
     */
    sendLoggingMessage(params: LoggingMessageNotification['params'], sessionId?: string): Promise<void>;
    sendResourceUpdated(params: ResourceUpdatedNotification['params']): Promise<void>;
    sendResourceListChanged(): Promise<void>;
    sendToolListChanged(): Promise<void>;
    sendPromptListChanged(): Promise<void>;
}

type Variables = Record<string, string | string[]>;
declare class UriTemplate {
    /**
     * Returns true if the given string contains any URI template expressions.
     * A template expression is a sequence of characters enclosed in curly braces,
     * like {foo} or {?bar}.
     */
    static isTemplate(str: string): boolean;
    private static validateLength;
    private readonly template;
    private readonly parts;
    get variableNames(): string[];
    constructor(template: string);
    toString(): string;
    private parse;
    private getOperator;
    private getNames;
    private encodeValue;
    private expandPart;
    expand(variables: Variables): string;
    private escapeRegExp;
    private partToRegExp;
    match(uri: string): Variables | null;
}

/**
 * Experimental McpServer task features for MCP SDK.
 * WARNING: These APIs are experimental and may change without notice.
 *
 * @experimental
 */

/**
 * Experimental task features for McpServer.
 *
 * Access via `server.experimental.tasks`:
 * ```typescript
 * server.experimental.tasks.registerToolTask('long-running', config, handler);
 * ```
 *
 * @experimental
 */
declare class ExperimentalMcpServerTasks {
    private readonly _mcpServer;
    constructor(_mcpServer: McpServer);
    /**
     * Registers a task-based tool with a config object and handler.
     *
     * Task-based tools support long-running operations that can be polled for status
     * and results. The handler must implement `createTask`, `getTask`, and `getTaskResult`
     * methods.
     *
     * @example
     * ```typescript
     * server.experimental.tasks.registerToolTask('long-computation', {
     *   description: 'Performs a long computation',
     *   inputSchema: { input: z.string() },
     *   execution: { taskSupport: 'required' }
     * }, {
     *   createTask: async (args, extra) => {
     *     const task = await extra.taskStore.createTask({ ttl: 300000 });
     *     startBackgroundWork(task.taskId, args);
     *     return { task };
     *   },
     *   getTask: async (args, extra) => {
     *     return extra.taskStore.getTask(extra.taskId);
     *   },
     *   getTaskResult: async (args, extra) => {
     *     return extra.taskStore.getTaskResult(extra.taskId);
     *   }
     * });
     * ```
     *
     * @param name - The tool name
     * @param config - Tool configuration (description, schemas, etc.)
     * @param handler - Task handler with createTask, getTask, getTaskResult methods
     * @returns RegisteredTool for managing the tool's lifecycle
     *
     * @experimental
     */
    registerToolTask<OutputArgs extends undefined | ZodRawShapeCompat | AnySchema>(name: string, config: {
        title?: string;
        description?: string;
        outputSchema?: OutputArgs;
        annotations?: ToolAnnotations;
        execution?: TaskToolExecution;
        _meta?: Record<string, unknown>;
    }, handler: ToolTaskHandler<undefined>): RegisteredTool;
    registerToolTask<InputArgs extends ZodRawShapeCompat | AnySchema, OutputArgs extends undefined | ZodRawShapeCompat | AnySchema>(name: string, config: {
        title?: string;
        description?: string;
        inputSchema: InputArgs;
        outputSchema?: OutputArgs;
        annotations?: ToolAnnotations;
        execution?: TaskToolExecution;
        _meta?: Record<string, unknown>;
    }, handler: ToolTaskHandler<InputArgs>): RegisteredTool;
}

/**
 * High-level MCP server that provides a simpler API for working with resources, tools, and prompts.
 * For advanced usage (like sending notifications or setting custom request handlers), use the underlying
 * Server instance available via the `server` property.
 */
declare class McpServer {
    /**
     * The underlying Server instance, useful for advanced operations like sending notifications.
     */
    readonly server: Server;
    private _registeredResources;
    private _registeredResourceTemplates;
    private _registeredTools;
    private _registeredPrompts;
    private _experimental?;
    constructor(serverInfo: Implementation, options?: ServerOptions);
    /**
     * Access experimental features.
     *
     * WARNING: These APIs are experimental and may change without notice.
     *
     * @experimental
     */
    get experimental(): {
        tasks: ExperimentalMcpServerTasks;
    };
    /**
     * Attaches to the given transport, starts it, and starts listening for messages.
     *
     * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
     */
    connect(transport: Transport): Promise<void>;
    /**
     * Closes the connection.
     */
    close(): Promise<void>;
    private _toolHandlersInitialized;
    private setToolRequestHandlers;
    /**
     * Creates a tool error result.
     *
     * @param errorMessage - The error message.
     * @returns The tool error result.
     */
    private createToolError;
    /**
     * Validates tool input arguments against the tool's input schema.
     */
    private validateToolInput;
    /**
     * Validates tool output against the tool's output schema.
     */
    private validateToolOutput;
    /**
     * Executes a tool handler (either regular or task-based).
     */
    private executeToolHandler;
    /**
     * Handles automatic task polling for tools with taskSupport 'optional'.
     */
    private handleAutomaticTaskPolling;
    private _completionHandlerInitialized;
    private setCompletionRequestHandler;
    private handlePromptCompletion;
    private handleResourceCompletion;
    private _resourceHandlersInitialized;
    private setResourceRequestHandlers;
    private _promptHandlersInitialized;
    private setPromptRequestHandlers;
    /**
     * Registers a resource `name` at a fixed URI, which will use the given callback to respond to read requests.
     * @deprecated Use `registerResource` instead.
     */
    resource(name: string, uri: string, readCallback: ReadResourceCallback): RegisteredResource;
    /**
     * Registers a resource `name` at a fixed URI with metadata, which will use the given callback to respond to read requests.
     * @deprecated Use `registerResource` instead.
     */
    resource(name: string, uri: string, metadata: ResourceMetadata, readCallback: ReadResourceCallback): RegisteredResource;
    /**
     * Registers a resource `name` with a template pattern, which will use the given callback to respond to read requests.
     * @deprecated Use `registerResource` instead.
     */
    resource(name: string, template: ResourceTemplate, readCallback: ReadResourceTemplateCallback): RegisteredResourceTemplate;
    /**
     * Registers a resource `name` with a template pattern and metadata, which will use the given callback to respond to read requests.
     * @deprecated Use `registerResource` instead.
     */
    resource(name: string, template: ResourceTemplate, metadata: ResourceMetadata, readCallback: ReadResourceTemplateCallback): RegisteredResourceTemplate;
    /**
     * Registers a resource with a config object and callback.
     * For static resources, use a URI string. For dynamic resources, use a ResourceTemplate.
     */
    registerResource(name: string, uriOrTemplate: string, config: ResourceMetadata, readCallback: ReadResourceCallback): RegisteredResource;
    registerResource(name: string, uriOrTemplate: ResourceTemplate, config: ResourceMetadata, readCallback: ReadResourceTemplateCallback): RegisteredResourceTemplate;
    private _createRegisteredResource;
    private _createRegisteredResourceTemplate;
    private _createRegisteredPrompt;
    private _createRegisteredTool;
    /**
     * Registers a zero-argument tool `name`, which will run the given function when the client calls it.
     * @deprecated Use `registerTool` instead.
     */
    tool(name: string, cb: ToolCallback): RegisteredTool;
    /**
     * Registers a zero-argument tool `name` (with a description) which will run the given function when the client calls it.
     * @deprecated Use `registerTool` instead.
     */
    tool(name: string, description: string, cb: ToolCallback): RegisteredTool;
    /**
     * Registers a tool taking either a parameter schema for validation or annotations for additional metadata.
     * This unified overload handles both `tool(name, paramsSchema, cb)` and `tool(name, annotations, cb)` cases.
     *
     * Note: We use a union type for the second parameter because TypeScript cannot reliably disambiguate
     * between ToolAnnotations and ZodRawShapeCompat during overload resolution, as both are plain object types.
     * @deprecated Use `registerTool` instead.
     */
    tool<Args extends ZodRawShapeCompat>(name: string, paramsSchemaOrAnnotations: Args | ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;
    /**
     * Registers a tool `name` (with a description) taking either parameter schema or annotations.
     * This unified overload handles both `tool(name, description, paramsSchema, cb)` and
     * `tool(name, description, annotations, cb)` cases.
     *
     * Note: We use a union type for the third parameter because TypeScript cannot reliably disambiguate
     * between ToolAnnotations and ZodRawShapeCompat during overload resolution, as both are plain object types.
     * @deprecated Use `registerTool` instead.
     */
    tool<Args extends ZodRawShapeCompat>(name: string, description: string, paramsSchemaOrAnnotations: Args | ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;
    /**
     * Registers a tool with both parameter schema and annotations.
     * @deprecated Use `registerTool` instead.
     */
    tool<Args extends ZodRawShapeCompat>(name: string, paramsSchema: Args, annotations: ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;
    /**
     * Registers a tool with description, parameter schema, and annotations.
     * @deprecated Use `registerTool` instead.
     */
    tool<Args extends ZodRawShapeCompat>(name: string, description: string, paramsSchema: Args, annotations: ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;
    /**
     * Registers a tool with a config object and callback.
     */
    registerTool<OutputArgs extends ZodRawShapeCompat | AnySchema, InputArgs extends undefined | ZodRawShapeCompat | AnySchema = undefined>(name: string, config: {
        title?: string;
        description?: string;
        inputSchema?: InputArgs;
        outputSchema?: OutputArgs;
        annotations?: ToolAnnotations;
        _meta?: Record<string, unknown>;
    }, cb: ToolCallback<InputArgs>): RegisteredTool;
    /**
     * Registers a zero-argument prompt `name`, which will run the given function when the client calls it.
     * @deprecated Use `registerPrompt` instead.
     */
    prompt(name: string, cb: PromptCallback): RegisteredPrompt;
    /**
     * Registers a zero-argument prompt `name` (with a description) which will run the given function when the client calls it.
     * @deprecated Use `registerPrompt` instead.
     */
    prompt(name: string, description: string, cb: PromptCallback): RegisteredPrompt;
    /**
     * Registers a prompt `name` accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.
     * @deprecated Use `registerPrompt` instead.
     */
    prompt<Args extends PromptArgsRawShape>(name: string, argsSchema: Args, cb: PromptCallback<Args>): RegisteredPrompt;
    /**
     * Registers a prompt `name` (with a description) accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.
     * @deprecated Use `registerPrompt` instead.
     */
    prompt<Args extends PromptArgsRawShape>(name: string, description: string, argsSchema: Args, cb: PromptCallback<Args>): RegisteredPrompt;
    /**
     * Registers a prompt with a config object and callback.
     */
    registerPrompt<Args extends PromptArgsRawShape>(name: string, config: {
        title?: string;
        description?: string;
        argsSchema?: Args;
    }, cb: PromptCallback<Args>): RegisteredPrompt;
    /**
     * Checks if the server is connected to a transport.
     * @returns True if the server is connected
     */
    isConnected(): boolean;
    /**
     * Sends a logging message to the client, if connected.
     * Note: You only need to send the parameters object, not the entire JSON RPC message
     * @see LoggingMessageNotification
     * @param params
     * @param sessionId optional for stateless and backward compatibility
     */
    sendLoggingMessage(params: LoggingMessageNotification['params'], sessionId?: string): Promise<void>;
    /**
     * Sends a resource list changed event to the client, if connected.
     */
    sendResourceListChanged(): void;
    /**
     * Sends a tool list changed event to the client, if connected.
     */
    sendToolListChanged(): void;
    /**
     * Sends a prompt list changed event to the client, if connected.
     */
    sendPromptListChanged(): void;
}
/**
 * A callback to complete one variable within a resource template's URI template.
 */
type CompleteResourceTemplateCallback = (value: string, context?: {
    arguments?: Record<string, string>;
}) => string[] | Promise<string[]>;
/**
 * A resource template combines a URI pattern with optional functionality to enumerate
 * all resources matching that pattern.
 */
declare class ResourceTemplate {
    private _callbacks;
    private _uriTemplate;
    constructor(uriTemplate: string | UriTemplate, _callbacks: {
        /**
         * A callback to list all resources matching this template. This is required to specified, even if `undefined`, to avoid accidentally forgetting resource listing.
         */
        list: ListResourcesCallback | undefined;
        /**
         * An optional callback to autocomplete variables within the URI template. Useful for clients and users to discover possible values.
         */
        complete?: {
            [variable: string]: CompleteResourceTemplateCallback;
        };
    });
    /**
     * Gets the URI template pattern.
     */
    get uriTemplate(): UriTemplate;
    /**
     * Gets the list callback, if one was provided.
     */
    get listCallback(): ListResourcesCallback | undefined;
    /**
     * Gets the callback for completing a specific URI template variable, if one was provided.
     */
    completeCallback(variable: string): CompleteResourceTemplateCallback | undefined;
}
type BaseToolCallback<SendResultT extends Result, Extra extends RequestHandlerExtra<ServerRequest, ServerNotification>, Args extends undefined | ZodRawShapeCompat | AnySchema> = Args extends ZodRawShapeCompat ? (args: ShapeOutput<Args>, extra: Extra) => SendResultT | Promise<SendResultT> : Args extends AnySchema ? (args: SchemaOutput<Args>, extra: Extra) => SendResultT | Promise<SendResultT> : (extra: Extra) => SendResultT | Promise<SendResultT>;
/**
 * Callback for a tool handler registered with Server.tool().
 *
 * Parameters will include tool arguments, if applicable, as well as other request handler context.
 *
 * The callback should return:
 * - `structuredContent` if the tool has an outputSchema defined
 * - `content` if the tool does not have an outputSchema
 * - Both fields are optional but typically one should be provided
 */
type ToolCallback<Args extends undefined | ZodRawShapeCompat | AnySchema = undefined> = BaseToolCallback<CallToolResult, RequestHandlerExtra<ServerRequest, ServerNotification>, Args>;
/**
 * Supertype that can handle both regular tools (simple callback) and task-based tools (task handler object).
 */
type AnyToolHandler<Args extends undefined | ZodRawShapeCompat | AnySchema = undefined> = ToolCallback<Args> | ToolTaskHandler<Args>;
type RegisteredTool = {
    title?: string;
    description?: string;
    inputSchema?: AnySchema;
    outputSchema?: AnySchema;
    annotations?: ToolAnnotations;
    execution?: ToolExecution;
    _meta?: Record<string, unknown>;
    handler: AnyToolHandler<undefined | ZodRawShapeCompat>;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update<InputArgs extends ZodRawShapeCompat, OutputArgs extends ZodRawShapeCompat>(updates: {
        name?: string | null;
        title?: string;
        description?: string;
        paramsSchema?: InputArgs;
        outputSchema?: OutputArgs;
        annotations?: ToolAnnotations;
        _meta?: Record<string, unknown>;
        callback?: ToolCallback<InputArgs>;
        enabled?: boolean;
    }): void;
    remove(): void;
};
/**
 * Additional, optional information for annotating a resource.
 */
type ResourceMetadata = Omit<Resource, 'uri' | 'name'>;
/**
 * Callback to list all resources matching a given template.
 */
type ListResourcesCallback = (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => ListResourcesResult | Promise<ListResourcesResult>;
/**
 * Callback to read a resource at a given URI.
 */
type ReadResourceCallback = (uri: URL, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => ReadResourceResult | Promise<ReadResourceResult>;
type RegisteredResource = {
    name: string;
    title?: string;
    metadata?: ResourceMetadata;
    readCallback: ReadResourceCallback;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update(updates: {
        name?: string;
        title?: string;
        uri?: string | null;
        metadata?: ResourceMetadata;
        callback?: ReadResourceCallback;
        enabled?: boolean;
    }): void;
    remove(): void;
};
/**
 * Callback to read a resource at a given URI, following a filled-in URI template.
 */
type ReadResourceTemplateCallback = (uri: URL, variables: Variables, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => ReadResourceResult | Promise<ReadResourceResult>;
type RegisteredResourceTemplate = {
    resourceTemplate: ResourceTemplate;
    title?: string;
    metadata?: ResourceMetadata;
    readCallback: ReadResourceTemplateCallback;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update(updates: {
        name?: string | null;
        title?: string;
        template?: ResourceTemplate;
        metadata?: ResourceMetadata;
        callback?: ReadResourceTemplateCallback;
        enabled?: boolean;
    }): void;
    remove(): void;
};
type PromptArgsRawShape = ZodRawShapeCompat;
type PromptCallback<Args extends undefined | PromptArgsRawShape = undefined> = Args extends PromptArgsRawShape ? (args: ShapeOutput<Args>, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => GetPromptResult | Promise<GetPromptResult> : (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => GetPromptResult | Promise<GetPromptResult>;
type RegisteredPrompt = {
    title?: string;
    description?: string;
    argsSchema?: AnyObjectSchema;
    callback: PromptCallback<undefined | PromptArgsRawShape>;
    enabled: boolean;
    enable(): void;
    disable(): void;
    update<Args extends PromptArgsRawShape>(updates: {
        name?: string | null;
        title?: string;
        description?: string;
        argsSchema?: Args;
        callback?: PromptCallback<Args>;
        enabled?: boolean;
    }): void;
    remove(): void;
};

interface LikeC4MCPServer {
    readonly mcp: McpServer;
    readonly isStarted: boolean;
    readonly port: number;
    start(port?: number): Promise<void>;
    stop(): Promise<void>;
}

declare class LikeC4MCPServerFactory {
    private services;
    constructor(services: LikeC4Services);
    create(options?: ServerOptions): McpServer;
}

declare class Rpc extends ADisposable {
    private services;
    constructor(services: LikeC4Services);
    init(): void;
    openView(params: DidRequestOpenViewNotification.Params): Promise<void>;
}

declare class NodeKindProvider implements NodeKindProvider$1 {
    private services;
    constructor(services: LangiumSharedServices);
    /**
     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.
     */
    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;
    /**
     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.
     */
    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;
}

declare class WorkspaceSymbolProvider extends DefaultWorkspaceSymbolProvider {
}

interface LikeC4ManualLayouts {
    read(project: Project): Promise<Record<ViewId, LayoutedView> | null>;
    write(project: Project, layouted: LayoutedView): Promise<Location>;
    remove(project: Project, view: ViewId): Promise<Location | null>;
    clearCaches(): void;
}

interface LikeC4AddedSharedServices {
    lsp: {
        NodeKindProvider: NodeKindProvider;
        WorkspaceSymbolProvider: WorkspaceSymbolProvider;
    };
    workspace: {
        Cache: WorkspaceCache<string, any>;
        ProjectsManager: ProjectsManager;
        IndexManager: IndexManager;
        LangiumDocuments: LangiumDocuments;
        WorkspaceManager: LikeC4WorkspaceManager;
        FileSystemProvider: FileSystemProvider;
        FileSystemWatcher: FileSystemWatcher;
    };
}
type LikeC4SharedServices = LangiumSharedServices & LikeC4AddedSharedServices;
/**
 * Declaration of custom services - add your own service classes here.
 */
interface LikeC4AddedServices {
    documentation: {
        DocumentationProvider: LikeC4DocumentationProvider;
    };
    validation: {
        DocumentValidator: LikeC4DocumentValidator;
    };
    Rpc: Rpc;
    mcp: {
        Server: LikeC4MCPServer;
        ServerFactory: LikeC4MCPServerFactory;
    };
    likec4: {
        LanguageServices: LikeC4LanguageServices;
        Views: LikeC4Views;
        ManualLayouts: LikeC4ManualLayouts;
        Layouter: QueueGraphvizLayoter;
        DeploymentsIndex: DeploymentsIndex;
        FqnIndex: FqnIndex;
        ModelParser: LikeC4ModelParser;
        ModelBuilder: LikeC4ModelBuilder;
        ModelLocator: LikeC4ModelLocator;
        ModelChanges: LikeC4ModelChanges;
    };
    lsp: {
        CompletionProvider: LikeC4CompletionProvider;
        DocumentHighlightProvider: LikeC4DocumentHighlightProvider;
        DocumentSymbolProvider: LikeC4DocumentSymbolProvider;
        SemanticTokenProvider: LikeC4SemanticTokenProvider;
        HoverProvider: LikeC4HoverProvider;
        CodeLensProvider: LikeC4CodeLensProvider;
        DocumentLinkProvider: LikeC4DocumentLinkProvider;
        Formatter: LikeC4Formatter;
        CodeActionProvider: LikeC4CodeActionProvider;
    };
    references: {
        NameProvider: LikeC4NameProvider;
        ScopeComputation: LikeC4ScopeComputation;
        ScopeProvider: LikeC4ScopeProvider;
    };
    shared?: LikeC4SharedServices;
    parser: {
        ValueConverter: LikeC4ValueConverter;
    };
}
type LikeC4Services = LangiumServices & LikeC4AddedServices;

interface FileSystemWatcher extends AsyncDisposable {
    /**
     * Watches a folder for changes and triggers a reload of the documents and projects.
     */
    watch(folder: string): void;
}

interface FileSystemProvider extends FileSystemProvider$1 {
    /**
     * Scans the project files for the given URI.
     * @returns The list of file system entries that are contained within the specified directory.
     */
    scanProjectFiles(folderUri: URI$1): Promise<FileSystemNode[]>;
    /**
     * Loads the project config from the given file.
     * @returns The project config.
     */
    loadProjectConfig(filepath: URI$1): Promise<LikeC4ProjectConfig>;
    /**
     * Reads the directory information for the given URI.
     * @param options.recursive If true, recursively reads the directory,
     * @param options.maxDepth Maximum depth to traverse when recursive is true (default: Infinity)
     * @default true
     */
    readDirectory(uri: URI$1, options?: {
        recursive?: boolean;
        maxDepth?: number;
    }): Promise<FileSystemNode[]>;
    /**
     * Finds all files in the given directory, matching the given filter.
     */
    scanDirectory(directory: URI$1, filter: (filepath: string) => boolean): Promise<FileSystemNode[]>;
    /**
     * Writes the content to the file system.
     * Used by manual layouts.
     */
    writeFile(uri: URI$1, content: string): Promise<void>;
    /**
     * Deletes the file from the file system.
     * Used by manual layouts.
     * @return true if the file was deleted, false if the file did not exist.
     */
    deleteFile(uri: URI$1): Promise<boolean>;
}

export { type LikeC4LanguageServices as L, ProjectsManager as P, Range$1 as R, WorkspaceFolder as W, type LikeC4Services as a, type LikeC4Views as b };
