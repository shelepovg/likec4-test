import{isStepEdgeId as rt,getParallelStepsPrefix as it}from"@likec4/core/types";import{Stack as D,isAncestor as G,nonNullable as E,invariant as C,nonexhaustive as st,DefaultMap as nt}from"@likec4/core/utils";import{t as v,e as ot,a as X}from"./likec4.DOUP9ptn.mjs";const at={done:!0,hasNext:!1},H={done:!1,hasNext:!1},lt=()=>at,U=o=>({hasNext:!0,next:o,done:!1});function j(o,...t){let e=o,r=t.map(s=>"lazy"in s?ht(s):void 0),i=0;for(;i<t.length;){if(r[i]===void 0||!ct(e)){let l=t[i];e=l(e),i+=1;continue}
let s=[];for(let l=i;l<t.length;l++){let c=r[l];if(c===void 0||(s.push(c),c.isSingle))break}let n=[];for(let l of e)if(T(l,n,s))break;let{isSingle:a}=s.at(-1);e=a?n[0]:n,i+=s.length}return e}function T(o,t,e){if(e.length===0)return t.push(o),!1;let r=o,i=H,s=!1;for(let[n,a]of e.entries()){let{index:l,items:c}=a;if(c.push(r),i=a(r,l,c),a.index+=1,i.hasNext){if(i.hasMany??!1){for(let u of i.next)if(T(u,t,e.slice(n+1)))return!0;return s}r=i.next}if(!i.hasNext)break;i.done&&(s=!0)}return i.hasNext&&
t.push(r),s}function ht(o){let{lazy:t,lazyArgs:e}=o,r=t(...e);return Object.assign(r,{isSingle:t.single??!1,index:0,items:[]})}function ct(o){return typeof o=="string"||typeof o=="object"&&!!o&&Symbol.iterator in o}function I(...o){return v(ut,o)}const ut=(o,t)=>o.length>=t;function ft(o,t){return typeof o=="object"?Y(o,t):ot(Y,[],dt)}const Y=(o,t)=>t===void 0?o.flat():o.flat(t),dt=o=>o===void 0||o===1?mt:o<=0?U:t=>Array.isArray(t)?{next:t.flat(o-1),hasNext:!0,hasMany:!0,done:!1}:{next:t,hasNext:!0,
done:!1},mt=o=>Array.isArray(o)?{next:o,hasNext:!0,hasMany:!0,done:!1}:{next:o,hasNext:!0,done:!1};function W(...o){return v(pt,o)}const pt=(o,t)=>{let e=Object.create(null);for(let r=0;r<o.length;r++){let i=o[r],s=t(i,r,o);if(s!==void 0){let n=e[s];n===void 0?e[s]=[i]:n.push(i)}}return Object.setPrototypeOf(e,Object.prototype),e};function wt(...o){return v(_t,o)}function _t(o,t){let e=Object.create(null);for(let r of o){let i=r?.[t];if(i!==void 0){let s=e[i];s===void 0?e[i]=[r]:s.push(r)}}return Object.
setPrototypeOf(e,Object.prototype),e}function J(...o){return v(bt,o)}const bt=o=>o.at(-1);function A(...o){return v(gt,o,yt)}const gt=(o,t)=>o.map(t),yt=o=>(t,e,r)=>({done:!1,hasNext:!0,next:o(t,e,r)});function xt(...o){return v(vt,o)}const vt=o=>o.length===1?o[0]:void 0;function q(...o){return v(Object.values,o)}const Z=60,Mt=32,M=80,K=32,Q=50,tt=30,Et=22;function S(){return new O}class O{index={};array=[];size(){return this.array.length}empty(){return this.array.length===0}itemAt(t){return this.
array[t]}contains(t){return this.index[t.id()]!==void 0}find(t){const e=this.index[t.id()];return e===void 0?void 0:this.array[e]}setDefault(t,e){const r=this.index[t.id()];if(r===void 0){const i=new R(t,e());return this.index[t.id()]=this.array.length,this.array.push(i),i}else return this.array[r]}insert(t,e){const r=new R(t,e),i=this.index[t.id()];return i===void 0?(this.index[t.id()]=this.array.length,this.array.push(r)):this.array[i]=r,r}erase(t){const e=this.index[t.id()];if(e===void 0)return;
this.index[t.id()]=void 0;const r=this.array[e],i=this.array.pop();return r!==i&&(this.array[e]=i,this.index[i.first.id()]=e),r}copy(){const t=new O;for(let e=0;e<this.array.length;e++){const r=this.array[e].copy();t.array[e]=r,t.index[r.first.id()]=e}return t}}class R{first;second;constructor(t,e){this.first=t,this.second=e}copy(){return new R(this.first,this.second)}}class L{constructor(t=""){this._name=t}id(){return this._id}name(){return this._name}setName(t){this._name=t}context(){return this.
_context}setContext(t){this._context=t}value(){return this._value}setValue(t){this._value=t}plus(t){return new g(this,t)}minus(t){return new g(this,typeof t=="number"?-t:[-1,t])}multiply(t){return new g([t,this])}divide(t){return new g([1/t,this])}toJSON(){return{name:this._name,value:this._value}}toString(){return this._context+"["+this._name+":"+this._value+"]"}_name;_value=0;_context=null;_id=St++}let St=0;class g{constructor(){let t=kt(arguments);this._terms=t.terms,this._constant=t.constant}terms(){
return this._terms}constant(){return this._constant}value(){let t=this._constant;for(let e=0,r=this._terms.size();e<r;e++){let i=this._terms.itemAt(e);t+=i.first.value()*i.second}return t}plus(t){return new g(this,t)}minus(t){return new g(this,typeof t=="number"?-t:[-1,t])}multiply(t){return new g([t,this])}divide(t){return new g([1/t,this])}isConstant(){return this._terms.size()==0}toString(){let t=this._terms.array.map(function(e){return e.second+"*"+e.first.toString()}).join(" + ");return!this.
isConstant()&&this._constant!==0&&(t+=" + "),t+=this._constant,t}_terms;_constant}function kt(o){let t=0,e=()=>0,r=S();for(let i=0,s=o.length;i<s;++i){let n=o[i];if(typeof n=="number")t+=n;else if(n instanceof L)r.setDefault(n,e).second+=1;else if(n instanceof g){t+=n.constant();let a=n.terms();for(let l=0,c=a.size();l<c;l++){let u=a.itemAt(l);r.setDefault(u.first,e).second+=u.second}}else if(n instanceof Array){if(n.length!==2)throw new Error("array must have length 2");let a=n[0],l=n[1];if(typeof a!=
"number")throw new Error("array item 0 must be a number");if(l instanceof L)r.setDefault(l,e).second+=a;else if(l instanceof g){t+=l.constant()*a;let c=l.terms();for(let u=0,h=c.size();u<h;u++){let f=c.itemAt(u);r.setDefault(f.first,e).second+=f.second*a}}else throw new Error("array item 1 must be a variable or expression")}else throw new Error("invalid Expression argument: "+n)}return{terms:r,constant:t}}class m{static create(t,e,r,i=1){let s=0;return s+=Math.max(0,Math.min(1e3,t*i))*1e6,s+=Math.
max(0,Math.min(1e3,e*i))*1e3,s+=Math.max(0,Math.min(1e3,r*i)),s}static required=m.create(1e3,1e3,1e3);static strong=m.create(1,0,0);static medium=m.create(0,1,0);static weak=m.create(0,0,1);static clip(t){return Math.max(0,Math.min(m.required,t))}}var b;(function(o){o[o.Le=0]="Le",o[o.Ge=1]="Ge",o[o.Eq=2]="Eq"})(b||(b={}));class N{constructor(t,e,r,i=m.required){this._operator=e,this._strength=m.clip(i),r===void 0&&t instanceof g?this._expression=t:this._expression=t.minus(r)}id(){return this._id}expression(){
return this._expression}op(){return this._operator}strength(){return this._strength}toString(){return this._expression.toString()+" "+["<=",">=","="][this._operator]+" 0 ("+this._strength.toString()+")"}_expression;_operator;_strength;_id=At++}let At=0;class Vt{maxIterations=1e3;constructor(){}createConstraint(t,e,r,i=m.required){let s=new N(t,e,r,i);return this.addConstraint(s),s}addConstraint(t){if(this._cnMap.find(t)!==void 0)throw new Error("duplicate constraint");let r=this._createRow(t),i=r.
row,s=r.tag,n=this._chooseSubject(i,s);if(n.type()===d.Invalid&&i.allDummies())if(P(i.constant()))n=s.marker;else throw new Error("unsatisfiable constraint");if(n.type()===d.Invalid){if(!this._addWithArtificialVariable(i))throw new Error("unsatisfiable constraint")}else i.solveFor(n),this._substitute(n,i),this._rowMap.insert(n,i);this._cnMap.insert(t,s),this._optimize(this._objective)}removeConstraint(t){let e=this._cnMap.erase(t);if(e===void 0)throw new Error("unknown constraint");this._removeConstraintEffects(
t,e.second);let r=e.second.marker,i=this._rowMap.erase(r);if(i===void 0){let s=this._getMarkerLeavingSymbol(r);if(s.type()===d.Invalid)throw new Error("failed to find leaving row");i=this._rowMap.erase(s),i.second.solveForEx(s,r),this._substitute(r,i.second)}this._optimize(this._objective)}hasConstraint(t){return this._cnMap.contains(t)}getConstraints(){return this._cnMap.array.map(({first:t})=>t)}addEditVariable(t,e){if(this._editMap.find(t)!==void 0)throw new Error("duplicate edit variable");if(e=
m.clip(e),e===m.required)throw new Error("bad required strength");let i=new g(t),s=new N(i,b.Eq,void 0,e);this.addConstraint(s);let a={tag:this._cnMap.find(s).second,constraint:s,constant:0};this._editMap.insert(t,a)}removeEditVariable(t){let e=this._editMap.erase(t);if(e===void 0)throw new Error("unknown edit variable");this.removeConstraint(e.second.constraint)}hasEditVariable(t){return this._editMap.contains(t)}suggestValue(t,e){let r=this._editMap.find(t);if(r===void 0)throw new Error("unkno\
wn edit variable");let i=this._rowMap,s=r.second,n=e-s.constant;s.constant=e;let a=s.tag.marker,l=i.find(a);if(l!==void 0){l.second.add(-n)<0&&this._infeasibleRows.push(a),this._dualOptimize();return}let c=s.tag.other;if(l=i.find(c),l!==void 0){l.second.add(n)<0&&this._infeasibleRows.push(c),this._dualOptimize();return}for(let u=0,h=i.size();u<h;++u){let f=i.itemAt(u),w=f.second,p=w.coefficientFor(a);p!==0&&w.add(n*p)<0&&f.first.type()!==d.External&&this._infeasibleRows.push(f.first)}this._dualOptimize()}updateVariables(){
let t=this._varMap,e=this._rowMap;for(let r=0,i=t.size();r<i;++r){let s=t.itemAt(r),n=e.find(s.second);n!==void 0?s.first.setValue(n.second.constant()):s.first.setValue(0)}}_getVarSymbol(t){let e=()=>this._makeSymbol(d.External);return this._varMap.setDefault(t,e).second}_createRow(t){let e=t.expression(),r=new B(e.constant()),i=e.terms();for(let l=0,c=i.size();l<c;++l){let u=i.itemAt(l);if(!P(u.second)){let h=this._getVarSymbol(u.first),f=this._rowMap.find(h);f!==void 0?r.insertRow(f.second,u.second):
r.insertSymbol(h,u.second)}}let s=this._objective,n=t.strength(),a={marker:x,other:x};switch(t.op()){case b.Le:case b.Ge:{let l=t.op()===b.Le?1:-1,c=this._makeSymbol(d.Slack);if(a.marker=c,r.insertSymbol(c,l),n<m.required){let u=this._makeSymbol(d.Error);a.other=u,r.insertSymbol(u,-l),s.insertSymbol(u,n)}break}case b.Eq:{if(n<m.required){let l=this._makeSymbol(d.Error),c=this._makeSymbol(d.Error);a.marker=l,a.other=c,r.insertSymbol(l,-1),r.insertSymbol(c,1),s.insertSymbol(l,n),s.insertSymbol(c,n)}else{
let l=this._makeSymbol(d.Dummy);a.marker=l,r.insertSymbol(l)}break}}return r.constant()<0&&r.reverseSign(),{row:r,tag:a}}_chooseSubject(t,e){let r=t.cells();for(let s=0,n=r.size();s<n;++s){let a=r.itemAt(s);if(a.first.type()===d.External)return a.first}let i=e.marker.type();return(i===d.Slack||i===d.Error)&&t.coefficientFor(e.marker)<0?e.marker:(i=e.other.type(),(i===d.Slack||i===d.Error)&&t.coefficientFor(e.other)<0?e.other:x)}_addWithArtificialVariable(t){let e=this._makeSymbol(d.Slack);this._rowMap.
insert(e,t.copy()),this._artificial=t.copy(),this._optimize(this._artificial);let r=P(this._artificial.constant());this._artificial=null;let i=this._rowMap.erase(e);if(i!==void 0){let n=i.second;if(n.isConstant())return r;let a=this._anyPivotableSymbol(n);if(a.type()===d.Invalid)return!1;n.solveForEx(e,a),this._substitute(a,n),this._rowMap.insert(a,n)}let s=this._rowMap;for(let n=0,a=s.size();n<a;++n)s.itemAt(n).second.removeSymbol(e);return this._objective.removeSymbol(e),r}_substitute(t,e){let r=this.
_rowMap;for(let i=0,s=r.size();i<s;++i){let n=r.itemAt(i);n.second.substitute(t,e),n.second.constant()<0&&n.first.type()!==d.External&&this._infeasibleRows.push(n.first)}this._objective.substitute(t,e),this._artificial&&this._artificial.substitute(t,e)}_optimize(t){let e=0;for(;e<this.maxIterations;){let r=this._getEnteringSymbol(t);if(r.type()===d.Invalid)return;let i=this._getLeavingSymbol(r);if(i.type()===d.Invalid)throw new Error("the objective is unbounded");let s=this._rowMap.erase(i).second;
s.solveForEx(i,r),this._substitute(r,s),this._rowMap.insert(r,s),e++}throw new Error("solver iterations exceeded")}_dualOptimize(){let t=this._rowMap,e=this._infeasibleRows;for(;e.length!==0;){let r=e.pop(),i=t.find(r);if(i!==void 0&&i.second.constant()<0){let s=this._getDualEnteringSymbol(i.second);if(s.type()===d.Invalid)throw new Error("dual optimize failed");let n=i.second;t.erase(r),n.solveForEx(r,s),this._substitute(s,n),t.insert(s,n)}}}_getEnteringSymbol(t){let e=t.cells();for(let r=0,i=e.
size();r<i;++r){let s=e.itemAt(r),n=s.first;if(s.second<0&&n.type()!==d.Dummy)return n}return x}_getDualEnteringSymbol(t){let e=Number.MAX_VALUE,r=x,i=t.cells();for(let s=0,n=i.size();s<n;++s){let a=i.itemAt(s),l=a.first,c=a.second;if(c>0&&l.type()!==d.Dummy){let h=this._objective.coefficientFor(l)/c;h<e&&(e=h,r=l)}}return r}_getLeavingSymbol(t){let e=Number.MAX_VALUE,r=x,i=this._rowMap;for(let s=0,n=i.size();s<n;++s){let a=i.itemAt(s),l=a.first;if(l.type()!==d.External){let c=a.second,u=c.coefficientFor(
t);if(u<0){let h=-c.constant()/u;h<e&&(e=h,r=l)}}}return r}_getMarkerLeavingSymbol(t){let e=Number.MAX_VALUE,r=e,i=e,s=x,n=s,a=s,l=s,c=this._rowMap;for(let u=0,h=c.size();u<h;++u){let f=c.itemAt(u),w=f.second,p=w.coefficientFor(t);if(p===0)continue;let _=f.first;if(_.type()===d.External)l=_;else if(p<0){let y=-w.constant()/p;y<r&&(r=y,n=_)}else{let y=w.constant()/p;y<i&&(i=y,a=_)}}return n!==s?n:a!==s?a:l}_removeConstraintEffects(t,e){e.marker.type()===d.Error&&this._removeMarkerEffects(e.marker,
t.strength()),e.other.type()===d.Error&&this._removeMarkerEffects(e.other,t.strength())}_removeMarkerEffects(t,e){let r=this._rowMap.find(t);r!==void 0?this._objective.insertRow(r.second,-e):this._objective.insertSymbol(t,-e)}_anyPivotableSymbol(t){let e=t.cells();for(let r=0,i=e.size();r<i;++r){let s=e.itemAt(r),n=s.first.type();if(n===d.Slack||n===d.Error)return s.first}return x}_makeSymbol(t){return new et(t,this._idTick++)}_cnMap=Pt();_rowMap=Rt();_varMap=Bt();_editMap=$t();_infeasibleRows=[];_objective=new B;_artificial=null;_idTick=0}
function P(o){let t=1e-8;return o<0?-o<t:o<t}function Pt(){return S()}function Rt(){return S()}function Bt(){return S()}function $t(){return S()}var d;(function(o){o[o.Invalid=0]="Invalid",o[o.External=1]="External",o[o.Slack=2]="Slack",o[o.Error=3]="Error",o[o.Dummy=4]="Dummy"})(d||(d={}));let et=class{constructor(t,e){this._id=e,this._type=t}id(){return this._id}type(){return this._type}_id;_type},x=new et(d.Invalid,-1);class B{constructor(t=0){this._constant=t}cells(){return this._cellMap}constant(){
return this._constant}isConstant(){return this._cellMap.empty()}allDummies(){let t=this._cellMap;for(let e=0,r=t.size();e<r;++e)if(t.itemAt(e).first.type()!==d.Dummy)return!1;return!0}copy(){let t=new B(this._constant);return t._cellMap=this._cellMap.copy(),t}add(t){return this._constant+=t}insertSymbol(t,e=1){let r=this._cellMap.setDefault(t,()=>0);P(r.second+=e)&&this._cellMap.erase(t)}insertRow(t,e=1){this._constant+=t._constant*e;let r=t._cellMap;for(let i=0,s=r.size();i<s;++i){let n=r.itemAt(
i);this.insertSymbol(n.first,n.second*e)}}removeSymbol(t){this._cellMap.erase(t)}reverseSign(){this._constant=-this._constant;let t=this._cellMap;for(let e=0,r=t.size();e<r;++e){let i=t.itemAt(e);i.second=-i.second}}solveFor(t){let e=this._cellMap,i=-1/e.erase(t).second;this._constant*=i;for(let s=0,n=e.size();s<n;++s)e.itemAt(s).second*=i}solveForEx(t,e){this.insertSymbol(t,-1),this.solveFor(e)}coefficientFor(t){let e=this._cellMap.find(t);return e!==void 0?e.second:0}substitute(t,e){let r=this.
_cellMap.erase(t);r!==void 0&&this.insertRow(e,r.second)}_cellMap=S();_constant}function zt(o){return j(o,W(t=>t.parallelPrefix??void 0),X((t,e)=>t.reduce((r,i)=>(r.min.column=Math.min(r.min.column,i.from.column,i.to.column),r.min.row=Math.min(r.min.row,i.from.row,i.to.row),r.max.column=Math.max(r.max.column,i.from.column,i.to.column),r.max.row=Math.max(r.max.row,i.from.row,i.to.row),r),{parallelPrefix:e,min:{column:1/0,row:1/0},max:{column:-1/0,row:-1/0}})),q())}function Ct(o,t){if(o.length===0||
o.length===t.length)return[];const e=n=>E(t.find(a=>a.id===n));function r(n){const a=n.parent?e(n.parent):null;return a?[a,...r(a)]:[]}const i=new D,s=[];return o.forEach(n=>{const a=r(n);if(a.length===0){i.clear();return}const l=D.from(a);let c,u;for(;c=i.peek()?.node,u=l.peek(),!(!u||!c);){if(G(u.id,c.id)||u.id===c.id){l.pop();continue}if(!G(c.id,u.id)){i.pop();continue}break}for(;u=l.pop();){const h={node:u,from:n,to:n,nested:[]};let f=i.peek();f?f.nested.push(h):s.push(h),i.push(h)}i.forEach(
h=>h.to=n)}),s}class jt{#e=new Vt;#r;#n=[];#o;#i;#s;#t=[];#a=[];constructor({actors:t,steps:e,compounds:r}){this.#s=this.newVar(tt),this.#o=this.newVar(0),this.#i=this.newVar(0),this.#r=this.addActors(t);for(const n of r){const a=this.addCompound(n),l=a[0];this.constraint(l.y1,"==",0,m.strong),this.put(this.#i).after(l.bottom),this.put(this.#s).after(l.y2),this.#n.push(...a)}for(const n of e)this.addStep(n);for(const n of zt(e))this.addParallelRect(n);const i=this.#r[0];this.constraint(i.offset.
left,"==",0,m.strong);const s=this.#r.reduce((n,a)=>(this.put(a.x).after(n.right,Z),this.put(a.offset.left,m.strong).after(n.offset.right,Mt),this.constraint(a.centerY,"==",n.centerY,m.strong),this.put(this.#s).after(a.offset.bottom),a));if(this.put(this.#o).after(s.offset.right),this.put(this.#i).after(J(this.#t)?.bottom??this.#s),r.length>0)for(const n of this.#n){const a=n.from.column,l=n.to.column;let c=Math.max(n.from.maxRow,n.to.maxRow);for(let h=a+1;h<l;h++){const f=this.actorBox(h);c=Math.
max(c,f.maxRow)}const u=E(this.#t[c],`row ${c} not found`);this.put(n.bottom).after(u.bottom,16),this.put(this.#i).after(n.bottom)}this.#e.updateVariables()}getParallelBoxes(){return this.#a.map(({parallelPrefix:t,x1:e,y1:r,x2:i,y2:s})=>({parallelPrefix:t,x:e.value(),y:r.value(),width:i.value()-e.value(),height:s.value()-r.value()}))}getActorBox(t){const e=this.actorBox(t);return{x:e.x.value(),y:e.y.value(),width:e.width,height:e.height}}getCompoundBoxes(){return this.#n.map(({node:t,depth:e,x1:r,
y1:i,x2:s,bottom:n})=>({node:t,depth:e,x:r.value(),y:i.value(),width:s.value()-r.value(),height:n.value()-i.value()}))}getPortCenter(t,e){const{column:r,row:i}=e==="source"?t.from:t.to,s=this.actorBox(r).centerX,{y:n}=E(this.#t[i]);return{cx:s.value(),cy:n.value()+K/2+t.offset,height:e==="source"?40:24}}getViewBounds(){return{x:0,y:0,width:this.#o.value(),height:this.#i.value()}}actorBox(t){if(typeof t!="number"){const e=typeof t=="string"?t:t.id;t=this.#r.findIndex(r=>r.actor.id===e),C(t>=0,`ac\
tor ${e} not found`)}return E(this.#r[t],`actor at index ${t} not found`)}addActors(t){let e=0;return A(t,(r,i)=>{const s=this.newVar(e);e+=r.width+Z;const n=this.newVar(0),a={column:i,actor:r,x:s,y:n,centerX:s.plus(Math.round(r.width/2)),centerY:n.plus(Math.round(r.height/2)),width:r.width,height:r.height,right:s.plus(r.width),bottom:n.plus(r.height),minRow:1/0,maxRow:-1/0},l=this.newVar(0),c=this.newVar(0),u=this.newVar(0),h=this.newVar(0);return this.put(l,m.strong).before(n),this.put(c,m.strong).
before(s),this.put(u,m.strong).after(a.right),this.put(h,m.strong).after(a.bottom),{...a,offset:{top:l,left:c,right:u,bottom:h}}})}addStep(t){const e=this.actorBox(t.source),r=this.actorBox(t.target);e.minRow=Math.min(e.minRow,t.from.row),e.maxRow=Math.max(e.maxRow,t.from.row),r.minRow=Math.min(r.minRow,t.to.row),r.maxRow=Math.max(r.maxRow,t.to.row);const[i,s]=e.column<=r.column?[e,r]:[r,e],n=(t.label?.width??100)+Q;i!==s?this.constraint(i.centerX.plus(n),"<=",s.centerX):this.constraint(i.centerX.
plus(n),"<=",i.offset.right);let a=t.label?.height?t.label.height+Q+K/2:M;return a=Math.max(a,M)+t.offset,this.ensureRow(t.from.row,a),t.isSelfLoop&&this.ensureRow(t.to.row,M),this}addParallelRect({parallelPrefix:t,min:e,max:r}){const i=this.actorBox(e.column).centerX.minus(30),s=this.actorBox(r.column).centerX.plus(30),n=this.#t[e.row],a=this.#t[r.row];C(n&&a,`parallel box invalid minRow=${e.row} maxRow=${r.row}`);const l=this.newVar(0);this.put(l).before(n.y,40);const c=a.bottom,u=e.row>0&&this.#t[e.
row-1];u&&this.put(l).after(u.bottom,16);const h=r.row<this.#t.length-1&&this.#t[r.row+1];h&&this.put(c).before(h.y,16),this.#a.push({parallelPrefix:t,x1:i,y1:l,x2:s,y2:c})}addCompound(t){const e=[],r=t.nested.flatMap(p=>{const _=this.addCompound(p);return e.push(_[0]),_}),i=Math.max(...r.map(p=>p.depth+1),0),s=this.actorBox(t.from),n=this.actorBox(t.to),a=s.offset.left.minus(32);s.offset.left=a;const l=n.offset.right.plus(32);n.offset.right=l;const c=this.newVar(0),u=xt(e);let h,f;switch(!0){case!!u:{
h=u.y1.minus(40),f=u.y2.plus(32),this.put(c).after(u.bottom,32);break}case n===s:{h=this.newVar(0),f=this.newVar(0),this.put(h).before(s.offset.top,52),this.put(f).after(s.offset.bottom,32),this.put(c).after(f);break}case e.length>0:{h=this.newVar(0),f=this.newVar(0);for(const p of e)this.put(h).before(p.y1,32),this.put(f).after(p.y2,32),this.put(c).after(p.bottom,32);break}default:{h=this.newVar(0),f=this.newVar(0);for(var w=s.column;w<=n.column;w++){const p=this.actorBox(w).offset;this.put(h).
before(p.top,52),this.put(f).after(p.bottom,32)}this.put(c).after(f);break}}for(var w=s.column;w<=n.column;w++){const _=this.actorBox(w).offset;_.top=h,_.bottom=f}return[{node:t.node,depth:i,from:s,to:n,x1:a,y1:h,x2:l,y2:f,bottom:c},...r]}ensureRow(t,e){for(;t>=this.#t.length;){const i=this.#t.length>0&&this.#t[this.#t.length-1]?.bottom||this.#s.plus(tt),s=this.newVar(this.#t.length*M);this.put(s).after(i);const n=this.newVar(M);this.require(n,">=",M),this.#t.push({y:s,height:n,bottom:s.plus(n),
lastHeight:M})}const r=E(this.#t[t]);e>r.lastHeight&&(r.lastHeight=e,this.require(r.height,">=",e),this.#e.suggestValue(r.height,e))}newVar(t){const e=new L;return this.#e.addEditVariable(e,m.weak),typeof t=="number"&&(this.#e.suggestValue(e,t),this.constraint(e,">=",0,m.strong)),e}require(t,e,r=void 0){switch(this.constraint(t,e,r,m.required),e){case"<=":case">=":this.constraint(t,"==",r,m.weak);break;case"<= 0":case">= 0":this.constraint(t,"== 0",void 0,m.weak);break}}constraint(t,e,r=void 0,i=m.
medium){let s;switch(e){case"==":s=b.Eq;break;case">=":s=b.Ge;break;case"<=":s=b.Le;break;case"== 0":{s=b.Eq,r=0;break}case">= 0":{s=b.Ge,r=0;break}case"<= 0":{s=b.Le,r=0;break}default:st(e)}this.#e.addConstraint(new N(t,s,r??0,i))}put(t,e=m.required){const r=e===m.required?m.medium:m.weak;return{before:(i,s)=>{s&&(i=i.minus(s)),this.constraint(t,"<=",i,e),this.constraint(t,"==",i,r)},after:(i,s)=>{s&&(i=i.plus(s)),this.constraint(t,">=",i,e),this.constraint(t,"==",i,r)}}}}function It(o){const t=new Set,
e=h=>E(o.nodes.find(f=>f.id===h)),r=[];for(const h of o.edges.filter(f=>rt(f.id))){const f=e(h.source),w=e(h.target);if(f.children.length||w.children.length){console.error("Sequence view does not support nested actors");continue}t.add(f),t.add(w),r.push({edge:h,source:f,target:w})}const i=o.nodes.filter(h=>t.has(h));C(I(i,1),"actors array must not be empty");const s=new nt(()=>[]),n=[];let a=0;for(const{edge:h,source:f,target:w}of r){const p=n.at(-1);let _=i.indexOf(f),y=i.indexOf(w);const k=f===
w,V=_>y,F=it(h.id);let $=!1;p&&p.target==f&&p.parallelPrefix===F&&($=p.isSelfLoop!==k||p.isBack===V),$||a++;const z={id:h.id,from:{column:_,row:a},to:{column:y,row:k?++a:a},edge:h,isSelfLoop:k,isBack:V,parallelPrefix:F,offset:$?(p?.offset??0)+Et:0,source:f,target:w,label:h.labelBBox?{height:h.labelBBox.height+8+(h.navigateTo?20:0),width:h.labelBBox.width+16,text:h.label}:null};n.push(z),s.get(f).push({step:z,row:a,type:"source",position:V&&!k?"left":"right"}),s.get(w).push({step:z,row:a,type:"ta\
rget",position:V||k?"right":"left"})}const l=new jt({actors:i,steps:n,compounds:Ct(i,o.nodes)}),c=l.getViewBounds(),u=j(l.getCompoundBoxes(),A(({node:h,...f})=>({...f,id:h.id,origin:h.id})),wt("id"),X((h,f)=>I(h,2)?A(h,(w,p)=>({...w,id:`${f}-${p+1}`})):h),q(),ft());return{actors:i.map(h=>qt({actor:h,ports:s.get(h),layout:l})),compounds:u,steps:A(n,h=>({id:h.id,sourceHandle:h.id+"_source",targetHandle:h.id+"_target",...h.label&&{labelBBox:{width:h.label.width,height:h.label.height}}})),parallelAreas:l.
getParallelBoxes(),bounds:c}}function qt({actor:o,ports:t,layout:e}){const{x:r,y:i,width:s,height:n}=e.getActorBox(o);return{id:o.id,x:r,y:i,width:s,height:n,ports:t.map(a=>{const l=e.getPortCenter(a.step,a.type);return{id:`${a.step.id}_${a.type}`,cx:l.cx-r,cy:l.cy-i,height:l.height,type:a.type,position:a.position}})}}export{A as a,q as b,It as c,I as d,H as e,W as f,J as g,lt as n,U as r,j as t};
