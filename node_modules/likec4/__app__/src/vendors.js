import * as React from "react";
import React__default, { useState, Fragment, createContext, useContext, useRef, useEffect, useMemo, useCallback, useLayoutEffect as useLayoutEffect$1, Children, useId as useId$2, forwardRef, cloneElement, createElement, memo as memo$2, useSyncExternalStore, useInsertionEffect as useInsertionEffect$1, isValidElement, Component, useImperativeHandle } from "react";
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { flushSync, createPortal } from "react-dom";
var __assign = function() {
  return __assign = Object.assign || function(t2) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t2[p] = s[p]);
    }
    return t2;
  }, __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t2 = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t2[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++)
      e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]) && (t2[p[i2]] = s[p[i2]]);
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from.length, ar; i2 < l; i2++)
    (ar || !(i2 in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i2)), ar[i2] = from[i2]);
  return to.concat(ar || Array.prototype.slice.call(from));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(ref, value) {
  return typeof ref == "function" ? ref(value) : ref && (ref.current = value), ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          last2 !== value && (ref.value = value, ref.callback(value, last2));
        }
      }
    };
  })[0];
  return ref.callback = callback, ref.facade;
}
var useIsomorphicLayoutEffect$3 = typeof window < "u" ? React.useLayoutEffect : React.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs$1(refs, defaultValue) {
  var callbackRef = useCallbackRef$1(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef$1(ref, newValue);
    });
  });
  return useIsomorphicLayoutEffect$3(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue), nextRefs_1 = new Set(refs), current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        nextRefs_1.has(ref) || assignRef$1(ref, null);
      }), nextRefs_1.forEach(function(ref) {
        prevRefs_1.has(ref) || assignRef$1(ref, current_1);
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]), callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults, middleware) {
  middleware === void 0 && (middleware = ItoI);
  var buffer = [], assigned = !1, medium = {
    read: function() {
      if (assigned)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return buffer.length ? buffer[buffer.length - 1] : defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      return buffer.push(item), function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      for (assigned = !0; buffer.length; ) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = !0;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [], cbs.forEach(cb), pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [], cbs2.forEach(cb);
      }, cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle(), buffer = {
        push: function(x2) {
          pendingQueue.push(x2), cycle();
        },
        filter: function(filter2) {
          return pendingQueue = pendingQueue.filter(filter2), buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  options === void 0 && (options = {});
  var medium = innerCreateMedium(null);
  return medium.options = __assign({ async: !0, ssr: !1 }, options), medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var Target = sideCar.read();
  if (!Target)
    throw new Error("Sidecar medium not found");
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(medium, exported) {
  return medium.useMedium(exported), SideCar$1;
}
var effectCar = createSidecarMedium(), nothing = function() {
}, RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null), _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1], forwardProps = props.forwardProps, children2 = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), SideCar2 = sideCar, containerRef = useMergeRefs$1([ref, parentRef]), containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children2), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children2)
  );
});
RemoveScroll.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  return nonce && tag.setAttribute("nonce", nonce), tag;
}
function injectStyles(tag, css) {
  tag.styleSheet ? tag.styleSheet.cssText = css : tag.appendChild(document.createTextNode(css));
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0, stylesheet = null;
  return {
    add: function(style2) {
      counter == 0 && (stylesheet = makeStyleTag()) && (injectStyles(stylesheet, style2), insertStyleTag(stylesheet)), counter++;
    },
    remove: function() {
      counter--, !counter && stylesheet && (stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet), stylesheet = null);
    }
  };
}, styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      return sheet.add(styles), function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
}, styleSingleton = function() {
  var useStyle2 = styleHookSingleton(), Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    return useStyle2(styles, dynamic), null;
  };
  return Sheet;
}, zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, parse$1 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
}, getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body), left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"], top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"], right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left), parse$1(top), parse$1(right)];
}, getGapWidth = function(gapMode) {
  if (gapMode === void 0 && (gapMode = "margin"), typeof window > "u")
    return zeroGap;
  var offsets = getOffset(gapMode), documentWidth = document.documentElement.clientWidth, windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  return gapMode === void 0 && (gapMode = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(important, `;
   padding-right: `).concat(gap, "px ").concat(important, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(important, `;
    overscroll-behavior: contain;
    `).concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && `
    padding-left: `.concat(left, `px;
    padding-top: `).concat(top, `px;
    padding-right: `).concat(right, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(gap, "px ").concat(important, `;
    `),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(gap, "px ").concat(important, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(important, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(important, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(gap, `px;
  }
`);
}, getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
}, useLockAttribute = function() {
  React.useEffect(function() {
    return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
      var newCounter = getCurrentUseCounter() - 1;
      newCounter <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, newCounter.toString());
    };
  }, []);
}, RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, noImportant ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u")
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        return passiveSupported = !0, !0;
      }
    });
    window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
  } catch {
    passiveSupported = !1;
  }
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element))
    return !1;
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
}, elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
}, elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
}, locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument, current2 = node;
  do {
    typeof ShadowRoot < "u" && current2 instanceof ShadowRoot && (current2 = current2.host);
    var isScrollable = elementCouldBeScrolled(axis, current2);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current2), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight)
        return !0;
    }
    current2 = current2.parentNode;
  } while (current2 && current2 !== ownerDocument.body);
  return !1;
}, getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
}, getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
}, elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
}, getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
}, getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
}, handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction), delta = directionFactor * sourceDelta, target = event.target, targetInLock = endTarget.contains(target), shouldCancelScroll = !1, isDeltaPositive = delta > 0, availableScroll = 0, availableScrollTop = 0;
  do {
    if (!target)
      break;
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2], elementScroll = scroll_1 - capacity - directionFactor * position;
    (position || elementScroll) && elementCouldBeScrolled(axis, target) && (availableScroll += elementScroll, availableScrollTop += position);
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  return (isDeltaPositive && Math.abs(availableScroll) < 1 || !isDeltaPositive && Math.abs(availableScrollTop) < 1) && (shouldCancelScroll = !0), shouldCancelScroll;
}, getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
}, extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
}, generateStyle = function(id2) {
  return `
  .block-interactivity-`.concat(id2, ` {pointer-events: none;}
  .allow-interactivity-`).concat(id2, ` {pointer-events: all;}
`);
}, idCounter$1 = 0, lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]), touchStartRef = React.useRef([0, 0]), activeAxis = React.useRef(), id2 = React.useState(idCounter$1++)[0], Style2 = React.useState(styleSingleton)[0], lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]), React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), !0).filter(Boolean);
      return allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(id2)), allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey)
      return !lastProps.current.allowPinchZoom;
    var touch = getTouchXY(event), touchStart = touchStartRef.current, deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0], deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1], currentAxis, target = event.target, moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range")
      return !1;
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection)
      return !0;
    if (canBeScrolledInMainDirection ? currentAxis = moveDirection : (currentAxis = moveDirection === "v" ? "h" : "v", canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target)), !canBeScrolledInMainDirection)
      return !1;
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY) && (activeAxis.current = currentAxis), !currentAxis)
      return !0;
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []), shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Style2)) {
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event), sourceEvent2 = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent2 && sourceEvent2.should) {
        event.cancelable && event.preventDefault();
        return;
      }
      if (!sourceEvent2) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        }), shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        shouldStop && event.cancelable && event.preventDefault();
      }
    }
  }, []), shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event), setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []), scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event), activeAxis.current = void 0;
  }, []), scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []), scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    return lockStack.push(Style2), props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    }), document.addEventListener("wheel", shouldPrevent, nonPassive), document.addEventListener("touchmove", shouldPrevent, nonPassive), document.addEventListener("touchstart", scrollTouchStart, nonPassive), function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      }), document.removeEventListener("wheel", shouldPrevent, nonPassive), document.removeEventListener("touchmove", shouldPrevent, nonPassive), document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  for (var shadowParent = null; node !== null; )
    node instanceof ShadowRoot && (shadowParent = node.host, node = node.host), node = node.parentNode;
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
function keys$1(object2) {
  return Object.keys(object2);
}
function isObject$2(item) {
  return item && typeof item == "object" && !Array.isArray(item);
}
function deepMerge(target, source) {
  const result = { ...target }, _source = source;
  return isObject$2(target) && isObject$2(source) && Object.keys(source).forEach((key) => {
    isObject$2(_source[key]) && key in target ? result[key] = deepMerge(result[key], _source[key]) : result[key] = _source[key];
  }), result;
}
function camelToKebabCase(value) {
  return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function getTransformedScaledValue(value) {
  return typeof value != "string" || !value.includes("var(--mantine-scale)") ? value : value.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function px$2(value) {
  const transformedValue = getTransformedScaledValue(value);
  return typeof transformedValue == "number" ? transformedValue : typeof transformedValue == "string" ? transformedValue.includes("calc") || transformedValue.includes("var") ? transformedValue : transformedValue.includes("px") ? Number(transformedValue.replace("px", "")) : transformedValue.includes("rem") ? Number(transformedValue.replace("rem", "")) * 16 : transformedValue.includes("em") ? Number(transformedValue.replace("em", "")) * 16 : Number(transformedValue) : NaN;
}
function scaleRem(remValue) {
  return remValue === "0rem" ? "0rem" : `calc(${remValue} * var(--mantine-scale))`;
}
function createConverter(units, { shouldScale = !1 } = {}) {
  function converter(value) {
    if (value === 0 || value === "0")
      return `0${units}`;
    if (typeof value == "number") {
      const val = `${value / 16}${units}`;
      return shouldScale ? scaleRem(val) : val;
    }
    if (typeof value == "string") {
      if (value === "" || value.startsWith("calc(") || value.startsWith("clamp(") || value.includes("rgba("))
        return value;
      if (value.includes(","))
        return value.split(",").map((val) => converter(val)).join(",");
      if (value.includes(" "))
        return value.split(" ").map((val) => converter(val)).join(" ");
      const replaced = value.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        const val = `${Number(replaced) / 16}${units}`;
        return shouldScale ? scaleRem(val) : val;
      }
    }
    return value;
  }
  return converter;
}
const rem = createConverter("rem", { shouldScale: !0 }), em = createConverter("em");
function filterProps$1(props) {
  return Object.keys(props).reduce((acc, key) => (props[key] !== void 0 && (acc[key] = props[key]), acc), {});
}
function isNumberLike(value) {
  if (typeof value == "number")
    return !0;
  if (typeof value == "string") {
    if (value.startsWith("calc(") || value.startsWith("var(") || value.includes(" ") && value.trim() !== "")
      return !0;
    const cssUnitsRegex = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return value.trim().split(/\s+/).every((val) => cssUnitsRegex.test(val));
  }
  return !1;
}
function isElement$1(value) {
  return Array.isArray(value) || value === null ? !1 : typeof value == "object" ? value.type !== Fragment : !1;
}
function createSafeContext(errorMessage) {
  const Context = createContext(null);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => {
    const ctx = useContext(Context);
    if (ctx === null)
      throw new Error(errorMessage);
    return ctx;
  }];
}
function createOptionalContext(initialValue = null) {
  const Context = createContext(initialValue);
  return [({ children: children2, value }) => /* @__PURE__ */ jsx(Context.Provider, { value, children: children2 }), () => useContext(Context)];
}
function getSafeId(uid, errorMessage) {
  return (value) => {
    if (typeof value != "string" || value.trim().length === 0)
      throw new Error(errorMessage);
    return `${uid}-${value}`;
  };
}
function findElementAncestor(element, selector2) {
  let _element = element;
  for (; (_element = _element.parentElement) && !_element.matches(selector2); )
    ;
  return _element;
}
function getPreviousIndex$1(current2, elements, loop) {
  for (let i2 = current2 - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current2;
}
function getNextIndex$1(current2, elements, loop) {
  for (let i2 = current2 + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].disabled)
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].disabled)
        return i2;
  }
  return current2;
}
function onSameLevel(target, sibling, parentSelector) {
  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);
}
function createScopedKeydownHandler({
  parentSelector,
  siblingSelector,
  onKeyDown,
  loop = !0,
  activateOnFocus = !1,
  dir = "rtl",
  orientation
}) {
  return (event) => {
    onKeyDown?.(event);
    const elements = Array.from(
      findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll(
        siblingSelector
      ) || []
    ).filter((node) => onSameLevel(event.currentTarget, node, parentSelector)), current2 = elements.findIndex((el) => event.currentTarget === el), _nextIndex = getNextIndex$1(current2, elements, loop), _previousIndex = getPreviousIndex$1(current2, elements, loop), nextIndex = dir === "rtl" ? _previousIndex : _nextIndex, previousIndex = dir === "rtl" ? _nextIndex : _previousIndex;
    switch (event.key) {
      case "ArrowRight": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[nextIndex].focus(), activateOnFocus && elements[nextIndex].click());
        break;
      }
      case "ArrowLeft": {
        orientation === "horizontal" && (event.stopPropagation(), event.preventDefault(), elements[previousIndex].focus(), activateOnFocus && elements[previousIndex].click());
        break;
      }
      case "ArrowUp": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_previousIndex].focus(), activateOnFocus && elements[_previousIndex].click());
        break;
      }
      case "ArrowDown": {
        orientation === "vertical" && (event.stopPropagation(), event.preventDefault(), elements[_nextIndex].focus(), activateOnFocus && elements[_nextIndex].click());
        break;
      }
      case "Home": {
        event.stopPropagation(), event.preventDefault(), !elements[0].disabled && elements[0].focus();
        break;
      }
      case "End": {
        event.stopPropagation(), event.preventDefault();
        const last2 = elements.length - 1;
        !elements[last2].disabled && elements[last2].focus();
        break;
      }
    }
  };
}
const elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function getDefaultZIndex(level) {
  return elevations[level];
}
const noop$5 = () => {
};
function closeOnEscape(callback, options = { active: !0 }) {
  return typeof callback != "function" || !options.active ? options.onKeyDown || noop$5 : (event) => {
    event.key === "Escape" && (callback(event), options.onTrigger?.());
  };
}
function getSize(size2, prefix2 = "size", convertToRem = !0) {
  if (size2 !== void 0)
    return isNumberLike(size2) ? convertToRem ? rem(size2) : size2 : `var(--${prefix2}-${size2})`;
}
function getSpacing(size2) {
  return getSize(size2, "mantine-spacing");
}
function getRadius$1(size2) {
  return size2 === void 0 ? "var(--mantine-radius-default)" : getSize(size2, "mantine-radius");
}
function getFontSize(size2) {
  return getSize(size2, "mantine-font-size");
}
function getLineHeight(size2) {
  return getSize(size2, "mantine-line-height", !1);
}
function getShadow(size2) {
  if (size2)
    return getSize(size2, "mantine-shadow", !1);
}
function createEventHandler(parentEventHandler, eventHandler) {
  return (event) => {
    parentEventHandler?.(event), eventHandler?.(event);
  };
}
function getBreakpointValue$1(breakpoint, breakpoints) {
  return breakpoint in breakpoints ? px$2(breakpoints[breakpoint]) : px$2(breakpoint);
}
function getSortedBreakpoints(values2, breakpoints) {
  const convertedBreakpoints = values2.map((breakpoint) => ({
    value: breakpoint,
    px: getBreakpointValue$1(breakpoint, breakpoints)
  }));
  return convertedBreakpoints.sort((a2, b) => a2.px - b.px), convertedBreakpoints;
}
function getBaseValue$1(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getContextItemIndex(elementSelector, parentSelector, node) {
  return node ? Array.from(
    findElementAncestor(node, parentSelector)?.querySelectorAll(elementSelector) || []
  ).findIndex((element) => element === node) : null;
}
function clamp$4(value, min2, max2) {
  return min2 === void 0 && max2 === void 0 ? value : min2 !== void 0 && max2 === void 0 ? Math.max(value, min2) : Math.min(min2 === void 0 && max2 !== void 0 ? value : Math.max(value, min2), max2);
}
function randomId(prefix2 = "mantine-") {
  return `${prefix2}${Math.random().toString(36).slice(2, 11)}`;
}
function shallowEqual$1(a2, b) {
  if (a2 === b || Number.isNaN(a2) && Number.isNaN(b))
    return !0;
  if (!(a2 instanceof Object) || !(b instanceof Object))
    return !1;
  const keys2 = Object.keys(a2), { length } = keys2;
  if (length !== Object.keys(b).length)
    return !1;
  for (let i2 = 0; i2 < length; i2 += 1) {
    const key = keys2[i2];
    if (!(key in b) || a2[key] !== b[key] && !(Number.isNaN(a2[key]) && Number.isNaN(b[key])))
      return !1;
  }
  return !0;
}
function useCallbackRef(callback) {
  const callbackRef = useRef(callback);
  return useEffect(() => {
    callbackRef.current = callback;
  }), useMemo(() => ((...args) => callbackRef.current?.(...args)), []);
}
function useDebouncedCallback$1(callback, options) {
  const { delay: delay2, flushOnUnmount, leading } = typeof options == "number" ? { delay: options, flushOnUnmount: !1, leading: !1 } : options, handleCallback = useCallbackRef(callback), debounceTimerRef = useRef(0), lastCallback = useMemo(() => {
    const currentCallback = Object.assign(
      (...args) => {
        window.clearTimeout(debounceTimerRef.current);
        const isFirstCall = currentCallback._isFirstCall;
        currentCallback._isFirstCall = !1;
        function clearTimeoutAndLeadingRef() {
          window.clearTimeout(debounceTimerRef.current), debounceTimerRef.current = 0, currentCallback._isFirstCall = !0;
        }
        if (leading && isFirstCall) {
          handleCallback(...args);
          const resetLeadingState = () => {
            clearTimeoutAndLeadingRef();
          }, flush2 = () => {
            debounceTimerRef.current !== 0 && (clearTimeoutAndLeadingRef(), handleCallback(...args));
          }, cancel22 = () => {
            clearTimeoutAndLeadingRef();
          };
          currentCallback.flush = flush2, currentCallback.cancel = cancel22, debounceTimerRef.current = window.setTimeout(resetLeadingState, delay2);
          return;
        }
        if (leading && !isFirstCall) {
          const flush2 = () => {
            debounceTimerRef.current !== 0 && (clearTimeoutAndLeadingRef(), handleCallback(...args));
          }, cancel22 = () => {
            clearTimeoutAndLeadingRef();
          };
          currentCallback.flush = flush2, currentCallback.cancel = cancel22;
          const resetLeadingState = () => {
            clearTimeoutAndLeadingRef();
          };
          debounceTimerRef.current = window.setTimeout(resetLeadingState, delay2);
          return;
        }
        const flush = () => {
          debounceTimerRef.current !== 0 && (clearTimeoutAndLeadingRef(), handleCallback(...args));
        }, cancel2 = () => {
          clearTimeoutAndLeadingRef();
        };
        currentCallback.flush = flush, currentCallback.cancel = cancel2, debounceTimerRef.current = window.setTimeout(flush, delay2);
      },
      {
        flush: () => {
        },
        cancel: () => {
        },
        _isFirstCall: !0
      }
    );
    return currentCallback;
  }, [handleCallback, delay2, leading]);
  return useEffect(
    () => () => {
      flushOnUnmount ? lastCallback.flush() : lastCallback.cancel();
    },
    [lastCallback, flushOnUnmount]
  ), lastCallback;
}
const DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(callback, events, nodes) {
  const ref = useRef(null), eventsList = events || DEFAULT_EVENTS;
  return useEffect(() => {
    const listener = (event) => {
      const { target } = event ?? {};
      if (Array.isArray(nodes)) {
        const shouldIgnore = !document.body.contains(target) && target?.tagName !== "HTML";
        nodes.every((node) => !!node && !event.composedPath().includes(node)) && !shouldIgnore && callback(event);
      } else ref.current && !ref.current.contains(target) && callback(event);
    };
    return eventsList.forEach((fn) => document.addEventListener(fn, listener)), () => {
      eventsList.forEach((fn) => document.removeEventListener(fn, listener));
    };
  }, [ref, callback, nodes]), ref;
}
function useClipboard(options = { timeout: 2e3 }) {
  const [error, setError] = useState(null), [copied, setCopied] = useState(!1), [copyTimeout, setCopyTimeout] = useState(null), handleCopyResult = (value) => {
    window.clearTimeout(copyTimeout), setCopyTimeout(window.setTimeout(() => setCopied(!1), options.timeout)), setCopied(value);
  };
  return { copy: (value) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(value).then(() => handleCopyResult(!0)).catch((err) => setError(err)) : setError(new Error("useClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    setCopied(!1), setError(null), window.clearTimeout(copyTimeout);
  }, error, copied };
}
function attachMediaListener(query, callback) {
  try {
    return query.addEventListener("change", callback), () => query.removeEventListener("change", callback);
  } catch {
    return query.addListener(callback), () => query.removeListener(callback);
  }
}
function getInitialValue(query, initialValue) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(query).matches : !1;
}
function useMediaQuery(query, initialValue, { getInitialValueInEffect } = {
  getInitialValueInEffect: !0
}) {
  const [matches2, setMatches] = useState(
    getInitialValueInEffect ? initialValue : getInitialValue(query)
  );
  return useEffect(() => {
    try {
      const mediaQuery = window.matchMedia(query);
      return setMatches(mediaQuery.matches), attachMediaListener(mediaQuery, (event) => setMatches(event.matches));
    } catch {
      return;
    }
  }, [query]), matches2 || !1;
}
function useColorScheme(initialValue, options) {
  return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark", options) ? "dark" : "light";
}
function useDebouncedState(defaultValue, wait, options = { leading: !1 }) {
  const [value, setValue] = useState(defaultValue), timeoutRef = useRef(null), leadingRef = useRef(!0), clearTimeout2 = () => window.clearTimeout(timeoutRef.current);
  useEffect(() => clearTimeout2, []);
  const debouncedSetValue = useCallback(
    (newValue) => {
      clearTimeout2(), leadingRef.current && options.leading ? setValue(newValue) : timeoutRef.current = window.setTimeout(() => {
        leadingRef.current = !0, setValue(newValue);
      }, wait), leadingRef.current = !1;
    },
    [options.leading]
  );
  return [value, debouncedSetValue];
}
function useDebouncedValue(value, wait, options = { leading: !1 }) {
  const [_value, setValue] = useState(value), mountedRef = useRef(!1), timeoutRef = useRef(null), cooldownRef = useRef(!1), cancel2 = useCallback(() => window.clearTimeout(timeoutRef.current), []);
  return useEffect(() => {
    mountedRef.current && (!cooldownRef.current && options.leading ? (cooldownRef.current = !0, setValue(value)) : (cancel2(), timeoutRef.current = window.setTimeout(() => {
      cooldownRef.current = !1, setValue(value);
    }, wait)));
  }, [value, options.leading, wait]), useEffect(() => (mountedRef.current = !0, cancel2), []), [_value, cancel2];
}
const useIsomorphicEffect = typeof document < "u" ? useLayoutEffect$1 : useEffect;
function useDocumentTitle(title) {
  useIsomorphicEffect(() => {
    typeof title == "string" && title.trim().length > 0 && (document.title = title.trim());
  }, [title]);
}
function useDidUpdate(fn, dependencies) {
  const mounted = useRef(!1);
  useEffect(
    () => () => {
      mounted.current = !1;
    },
    []
  ), useEffect(() => {
    if (mounted.current)
      return fn();
    mounted.current = !0;
  }, dependencies);
}
function useFocusReturn({
  opened,
  shouldReturnFocus = !0
}) {
  const lastActiveElement = useRef(null), returnFocus = () => {
    lastActiveElement.current && "focus" in lastActiveElement.current && typeof lastActiveElement.current.focus == "function" && lastActiveElement.current?.focus({ preventScroll: !0 });
  };
  return useDidUpdate(() => {
    let timeout2 = -1;
    const clearFocusTimeout = (event) => {
      event.key === "Tab" && window.clearTimeout(timeout2);
    };
    return document.addEventListener("keydown", clearFocusTimeout), opened ? lastActiveElement.current = document.activeElement : shouldReturnFocus && (timeout2 = window.setTimeout(returnFocus, 10)), () => {
      window.clearTimeout(timeout2), document.removeEventListener("keydown", clearFocusTimeout);
    };
  }, [opened, shouldReturnFocus]), returnFocus;
}
const TABBABLE_NODES = /input|select|textarea|button|object/, FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element) {
  return element.style.display === "none";
}
function visible(element) {
  if (element.getAttribute("aria-hidden") || element.getAttribute("hidden") || element.getAttribute("type") === "hidden")
    return !1;
  let parentElement = element;
  for (; parentElement && !(parentElement === document.body || parentElement.nodeType === 11); ) {
    if (hidden(parentElement))
      return !1;
    parentElement = parentElement.parentNode;
  }
  return !0;
}
function getElementTabIndex(element) {
  let tabIndex = element.getAttribute("tabindex");
  return tabIndex === null && (tabIndex = void 0), parseInt(tabIndex, 10);
}
function focusable(element) {
  const nodeName = element.nodeName.toLowerCase(), isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (TABBABLE_NODES.test(nodeName) && !element.disabled || element instanceof HTMLAnchorElement && element.href || isTabIndexNotNaN) && visible(element);
}
function tabbable(element) {
  const tabIndex = getElementTabIndex(element);
  return (Number.isNaN(tabIndex) || tabIndex >= 0) && focusable(element);
}
function findTabbableDescendants(element) {
  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}
function scopeTab(node, event) {
  const tabbable2 = findTabbableDescendants(node);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1], root2 = node.getRootNode();
  let leavingFinalTabbable = finalTabbable === root2.activeElement || node === root2.activeElement;
  const activeElement2 = root2.activeElement;
  if (activeElement2.tagName === "INPUT" && activeElement2.getAttribute("type") === "radio" && (leavingFinalTabbable = tabbable2.filter(
    (element) => element.getAttribute("type") === "radio" && element.getAttribute("name") === activeElement2.getAttribute("name")
  ).includes(finalTabbable)), !leavingFinalTabbable)
    return;
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  target && target.focus();
}
function useFocusTrap(active = !0) {
  const ref = useRef(null), focusNode = (node) => {
    let focusElement = node.querySelector("[data-autofocus]");
    if (!focusElement) {
      const children2 = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
      focusElement = children2.find(tabbable) || children2.find(focusable) || null, !focusElement && focusable(node) && (focusElement = node);
    }
    focusElement && focusElement.focus({ preventScroll: !0 });
  }, setRef2 = useCallback(
    (node) => {
      active && node !== null && ref.current !== node && (node ? (setTimeout(() => {
        node.getRootNode() && focusNode(node);
      }), ref.current = node) : ref.current = null);
    },
    [active]
  );
  return useEffect(() => {
    if (!active)
      return;
    ref.current && setTimeout(() => focusNode(ref.current));
    const handleKeyDown = (event) => {
      event.key === "Tab" && ref.current && scopeTab(ref.current, event);
    };
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [active]), setRef2;
}
const __useId = React__default.useId || (() => {
});
function useReactId$1() {
  const id2 = __useId();
  return id2 ? `mantine-${id2.replace(/:/g, "")}` : "";
}
function useId$1(staticId) {
  const reactId = useReactId$1(), [uuid2, setUuid] = useState(reactId);
  return useIsomorphicEffect(() => {
    setUuid(randomId());
  }, []), typeof staticId == "string" ? staticId : typeof window > "u" ? reactId : uuid2;
}
function useWindowEvent(type, listener, options) {
  useEffect(() => (window.addEventListener(type, listener, options), () => window.removeEventListener(type, listener, options)), [type, listener]);
}
function serializeJSON(value, hookName = "use-local-storage") {
  try {
    return JSON.stringify(value);
  } catch {
    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);
  }
}
function deserializeJSON(value) {
  try {
    return value && JSON.parse(value);
  } catch {
    return value;
  }
}
function createStorageHandler(type) {
  return { getItem: (key) => {
    try {
      return window[type].getItem(key);
    } catch {
      return console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked"), null;
    }
  }, setItem: (key, value) => {
    try {
      window[type].setItem(key, value);
    } catch {
      console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
    }
  }, removeItem: (key) => {
    try {
      window[type].removeItem(key);
    } catch {
      console.warn(
        "use-local-storage: Failed to remove value from storage, localStorage is blocked"
      );
    }
  } };
}
function createStorage(type, hookName) {
  const eventName = type === "localStorage" ? "mantine-local-storage" : "mantine-session-storage", { getItem, setItem, removeItem: removeItem2 } = createStorageHandler(type);
  return function({
    key,
    defaultValue,
    getInitialValueInEffect = !0,
    sync = !0,
    deserialize = deserializeJSON,
    serialize = (value) => serializeJSON(value, hookName)
  }) {
    const readStorageValue = useCallback(
      (skipStorage) => {
        let storageBlockedOrSkipped;
        try {
          storageBlockedOrSkipped = typeof window > "u" || !(type in window) || window[type] === null || !!skipStorage;
        } catch {
          storageBlockedOrSkipped = !0;
        }
        if (storageBlockedOrSkipped)
          return defaultValue;
        const storageValue = getItem(key);
        return storageValue !== null ? deserialize(storageValue) : defaultValue;
      },
      [key, defaultValue]
    ), [value, setValue] = useState(readStorageValue(getInitialValueInEffect)), setStorageValue = useCallback(
      (val) => {
        val instanceof Function ? setValue((current2) => {
          const result = val(current2);
          return setItem(key, serialize(result)), queueMicrotask(() => {
            window.dispatchEvent(
              new CustomEvent(eventName, { detail: { key, value: val(current2) } })
            );
          }), result;
        }) : (setItem(key, serialize(val)), window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: val } })), setValue(val));
      },
      [key]
    ), removeStorageValue = useCallback(() => {
      removeItem2(key), setValue(defaultValue), window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: defaultValue } }));
    }, [key, defaultValue]);
    return useWindowEvent("storage", (event) => {
      sync && event.storageArea === window[type] && event.key === key && setValue(deserialize(event.newValue ?? void 0));
    }), useWindowEvent(eventName, (event) => {
      sync && event.detail.key === key && setValue(event.detail.value);
    }), useEffect(() => {
      defaultValue !== void 0 && value === void 0 && setStorageValue(defaultValue);
    }, [defaultValue, value, setStorageValue]), useEffect(() => {
      const val = readStorageValue();
      val !== void 0 && setStorageValue(val);
    }, [key]), [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];
  };
}
function useLocalStorage(props) {
  return createStorage("localStorage", "use-local-storage")(props);
}
function useSessionStorage(props) {
  return createStorage("sessionStorage", "use-session-storage")(props);
}
function assignRef(ref, value) {
  if (typeof ref == "function")
    return ref(value);
  typeof ref == "object" && ref !== null && "current" in ref && (ref.current = value);
}
function mergeRefs(...refs) {
  const cleanupMap = /* @__PURE__ */ new Map();
  return (node) => {
    if (refs.forEach((ref) => {
      const cleanup = assignRef(ref, node);
      cleanup && cleanupMap.set(ref, cleanup);
    }), cleanupMap.size > 0)
      return () => {
        refs.forEach((ref) => {
          const cleanup = cleanupMap.get(ref);
          cleanup && typeof cleanup == "function" ? cleanup() : assignRef(ref, null);
        }), cleanupMap.clear();
      };
  };
}
function useMergedRef(...refs) {
  return useCallback(mergeRefs(...refs), refs);
}
function clampUseMovePosition(position) {
  return {
    x: clamp$4(position.x, 0, 1),
    y: clamp$4(position.y, 0, 1)
  };
}
function useMove(onChange, handlers, dir = "ltr") {
  const mounted = useRef(!1), isSliding = useRef(!1), frame2 = useRef(0), [active, setActive] = useState(!1), cleanupRef = useRef(null);
  return useEffect(() => {
    mounted.current = !0;
  }, []), { ref: useCallback(
    (node) => {
      if (cleanupRef.current && (cleanupRef.current(), cleanupRef.current = null), !node)
        return;
      const onScrub = ({ x: x2, y: y2 }) => {
        cancelAnimationFrame(frame2.current), frame2.current = requestAnimationFrame(() => {
          if (mounted.current && node) {
            node.style.userSelect = "none";
            const rect = node.getBoundingClientRect();
            if (rect.width && rect.height) {
              const _x = clamp$4((x2 - rect.left) / rect.width, 0, 1);
              onChange({
                x: dir === "ltr" ? _x : 1 - _x,
                y: clamp$4((y2 - rect.top) / rect.height, 0, 1)
              });
            }
          }
        });
      }, bindEvents = () => {
        document.addEventListener("mousemove", onMouseMove), document.addEventListener("mouseup", stopScrubbing), document.addEventListener("touchmove", onTouchMove, { passive: !1 }), document.addEventListener("touchend", stopScrubbing);
      }, unbindEvents = () => {
        document.removeEventListener("mousemove", onMouseMove), document.removeEventListener("mouseup", stopScrubbing), document.removeEventListener("touchmove", onTouchMove), document.removeEventListener("touchend", stopScrubbing);
      }, startScrubbing = () => {
        !isSliding.current && mounted.current && (isSliding.current = !0, typeof handlers?.onScrubStart == "function" && handlers.onScrubStart(), setActive(!0), bindEvents());
      }, stopScrubbing = () => {
        isSliding.current && mounted.current && (isSliding.current = !1, setActive(!1), unbindEvents(), setTimeout(() => {
          typeof handlers?.onScrubEnd == "function" && handlers.onScrubEnd();
        }, 0));
      }, onMouseDown = (event) => {
        startScrubbing(), event.preventDefault(), onMouseMove(event);
      }, onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY }), onTouchStart = (event) => {
        event.cancelable && event.preventDefault(), startScrubbing(), onTouchMove(event);
      }, onTouchMove = (event) => {
        event.cancelable && event.preventDefault(), onScrub({ x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY });
      };
      node.addEventListener("mousedown", onMouseDown), node.addEventListener("touchstart", onTouchStart, { passive: !1 }), cleanupRef.current = () => {
        node.removeEventListener("mousedown", onMouseDown), node.removeEventListener("touchstart", onTouchStart);
      };
    },
    [dir, onChange]
  ), active };
}
function useUncontrolled({
  value,
  defaultValue,
  finalValue,
  onChange = () => {
  }
}) {
  const [uncontrolledValue, setUncontrolledValue] = useState(
    defaultValue !== void 0 ? defaultValue : finalValue
  ), handleUncontrolledChange = (val, ...payload) => {
    setUncontrolledValue(val), onChange?.(val, ...payload);
  };
  return value !== void 0 ? [value, onChange, !0] : [uncontrolledValue, handleUncontrolledChange, !1];
}
function useReducedMotion$1(initialValue, options) {
  return useMediaQuery("(prefers-reduced-motion: reduce)", initialValue, options);
}
function shallowCompare$1(prevValue, currValue) {
  if (!prevValue || !currValue)
    return !1;
  if (prevValue === currValue)
    return !0;
  if (prevValue.length !== currValue.length)
    return !1;
  for (let i2 = 0; i2 < prevValue.length; i2 += 1)
    if (!shallowEqual$1(prevValue[i2], currValue[i2]))
      return !1;
  return !0;
}
function useShallowCompare(dependencies) {
  const ref = useRef([]), updateRef = useRef(0);
  return shallowCompare$1(ref.current, dependencies) || (ref.current = dependencies, updateRef.current += 1), [updateRef.current];
}
function useShallowEffect(cb, dependencies) {
  useEffect(cb, useShallowCompare(dependencies));
}
const eventListerOptions = {
  passive: !0
};
function useViewportSize() {
  const [windowSize, setWindowSize] = useState({
    width: 0,
    height: 0
  }), setSize = useCallback(() => {
    setWindowSize({ width: window.innerWidth || 0, height: window.innerHeight || 0 });
  }, []);
  return useWindowEvent("resize", setSize, eventListerOptions), useWindowEvent("orientationchange", setSize, eventListerOptions), useEffect(setSize, []), windowSize;
}
const keyNameMap = {
  " ": "space",
  ArrowLeft: "arrowleft",
  ArrowRight: "arrowright",
  ArrowUp: "arrowup",
  ArrowDown: "arrowdown",
  Escape: "escape",
  Esc: "escape",
  esc: "escape",
  Enter: "enter",
  Tab: "tab",
  Backspace: "backspace",
  Delete: "delete",
  Insert: "insert",
  Home: "home",
  End: "end",
  PageUp: "pageup",
  PageDown: "pagedown",
  "+": "plus",
  "-": "minus",
  "*": "asterisk",
  "/": "slash"
};
function normalizeKey(key) {
  const lowerKey = key.replace("Key", "").toLowerCase();
  return keyNameMap[key] || lowerKey;
}
function parseHotkey(hotkey) {
  const keys2 = hotkey.toLowerCase().split("+").map((part) => part.trim()), modifiers = {
    alt: keys2.includes("alt"),
    ctrl: keys2.includes("ctrl"),
    meta: keys2.includes("meta"),
    mod: keys2.includes("mod"),
    shift: keys2.includes("shift"),
    plus: keys2.includes("[plus]")
  }, reservedKeys = ["alt", "ctrl", "meta", "shift", "mod"], freeKey = keys2.find((key) => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey === "[plus]" ? "+" : freeKey
  };
}
function isExactHotkey(hotkey, event, usePhysicalKeys) {
  const { alt, ctrl, meta, mod, shift: shift2, key } = hotkey, { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey, code: pressedCode } = event;
  if (alt !== altKey)
    return !1;
  if (mod) {
    if (!ctrlKey && !metaKey)
      return !1;
  } else if (ctrl !== ctrlKey || meta !== metaKey)
    return !1;
  return shift2 !== shiftKey ? !1 : !!(key && (usePhysicalKeys ? normalizeKey(pressedCode) === normalizeKey(key) : normalizeKey(pressedKey ?? pressedCode) === normalizeKey(key)));
}
function getHotkeyMatcher(hotkey, usePhysicalKeys) {
  return (event) => isExactHotkey(parseHotkey(hotkey), event, usePhysicalKeys);
}
function getHotkeyHandler(hotkeys) {
  return (event) => {
    const _event = "nativeEvent" in event ? event.nativeEvent : event;
    hotkeys.forEach(
      ([hotkey, handler, options = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
        getHotkeyMatcher(hotkey, options.usePhysicalKeys)(_event) && (options.preventDefault && event.preventDefault(), handler(_event));
      }
    );
  };
}
function shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = !1) {
  return event.target instanceof HTMLElement ? (triggerOnContentEditable || !event.target.isContentEditable) && !tagsToIgnore.includes(event.target.tagName) : !0;
}
function useHotkeys(hotkeys, tagsToIgnore = ["INPUT", "TEXTAREA", "SELECT"], triggerOnContentEditable = !1) {
  useEffect(() => {
    const keydownListener = (event) => {
      hotkeys.forEach(
        ([hotkey, handler, options = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
          getHotkeyMatcher(hotkey, options.usePhysicalKeys)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable) && (options.preventDefault && event.preventDefault(), handler(event));
        }
      );
    };
    return document.documentElement.addEventListener("keydown", keydownListener), () => document.documentElement.removeEventListener("keydown", keydownListener);
  }, [hotkeys]);
}
function useHover$1() {
  const [hovered, setHovered] = useState(!1), previousNode = useRef(null), handleMouseEnter = useCallback(() => {
    setHovered(!0);
  }, []), handleMouseLeave = useCallback(() => {
    setHovered(!1);
  }, []);
  return { ref: useCallback(
    (node) => {
      previousNode.current && (previousNode.current.removeEventListener("mouseenter", handleMouseEnter), previousNode.current.removeEventListener("mouseleave", handleMouseLeave)), node && (node.addEventListener("mouseenter", handleMouseEnter), node.addEventListener("mouseleave", handleMouseLeave)), previousNode.current = node;
    },
    [handleMouseEnter, handleMouseLeave]
  ), hovered };
}
function useDisclosure(initialState2 = !1, options = {}) {
  const [opened, setOpened] = useState(initialState2), open = useCallback(() => {
    setOpened((isOpened) => isOpened || (options.onOpen?.(), !0));
  }, [options.onOpen]), close = useCallback(() => {
    setOpened((isOpened) => isOpened && (options.onClose?.(), !1));
  }, [options.onClose]), toggle = useCallback(() => {
    opened ? close() : open();
  }, [close, open, opened]);
  return [opened, { open, close, toggle }];
}
function containsRelatedTarget(event) {
  return event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement ? event.currentTarget.contains(event.relatedTarget) : !1;
}
function useFocusWithin({
  onBlur,
  onFocus
} = {}) {
  const [focused, setFocused] = useState(!1), focusedRef = useRef(!1), previousNode = useRef(null), _setFocused = useCallback((value) => {
    setFocused(value), focusedRef.current = value;
  }, []), handleFocusIn = useCallback(
    (event) => {
      focusedRef.current || (_setFocused(!0), onFocus?.(event));
    },
    [onFocus]
  ), handleFocusOut = useCallback(
    (event) => {
      focusedRef.current && !containsRelatedTarget(event) && (_setFocused(!1), onBlur?.(event));
    },
    [onBlur]
  ), callbackRef = useCallback(
    (node) => {
      node && (previousNode.current && (previousNode.current.removeEventListener("focusin", handleFocusIn), previousNode.current.removeEventListener("focusout", handleFocusOut)), node.addEventListener("focusin", handleFocusIn), node.addEventListener("focusout", handleFocusOut), previousNode.current = node);
    },
    [handleFocusIn, handleFocusOut]
  );
  return useEffect(
    () => () => {
      previousNode.current && (previousNode.current.removeEventListener("focusin", handleFocusIn), previousNode.current.removeEventListener("focusout", handleFocusOut));
    },
    []
  ), { ref: callbackRef, focused };
}
function useTimeout(callback, delay2, options = { autoInvoke: !1 }) {
  const timeoutRef = useRef(null), start2 = useCallback(
    (...args) => {
      timeoutRef.current || (timeoutRef.current = window.setTimeout(() => {
        callback(args), timeoutRef.current = null;
      }, delay2));
    },
    [delay2]
  ), clear = useCallback(() => {
    timeoutRef.current && (window.clearTimeout(timeoutRef.current), timeoutRef.current = null);
  }, []);
  return useEffect(() => (options.autoInvoke && start2(), clear), [clear, start2]), { start: start2, clear };
}
function usePrevious$1(value) {
  const ref = useRef(void 0);
  return useEffect(() => {
    ref.current = value;
  }, [value]), ref.current;
}
function useInViewport() {
  const observer = useRef(null), [inViewport, setInViewport] = useState(!1);
  return { ref: useCallback((node) => {
    typeof IntersectionObserver < "u" && (node && !observer.current ? observer.current = new IntersectionObserver((entries) => {
      const lastEntry = entries[entries.length - 1];
      setInViewport(lastEntry.isIntersecting);
    }) : observer.current?.disconnect(), node ? observer.current?.observe(node) : setInViewport(!1));
  }, []), inViewport };
}
function useMutationObserver(callback, options, target) {
  const observer = useRef(null), ref = useRef(null);
  return useEffect(() => {
    const targetElement = typeof target == "function" ? target() : target;
    return (targetElement || ref.current) && (observer.current = new MutationObserver(callback), observer.current.observe(targetElement || ref.current, options)), () => {
      observer.current?.disconnect();
    };
  }, [callback, options]), ref;
}
function useMounted() {
  const [mounted, setMounted] = useState(!1);
  return useEffect(() => setMounted(!0), []), mounted;
}
function useStateHistory(initialValue) {
  const [state, setState] = useState({
    history: [initialValue],
    current: 0
  }), set2 = useCallback(
    (val) => setState((currentState) => {
      const nextState = [...currentState.history.slice(0, currentState.current + 1), val];
      return {
        history: nextState,
        current: nextState.length - 1
      };
    }),
    []
  ), back = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.max(0, currentState.current - steps)
    })),
    []
  ), forward = useCallback(
    (steps = 1) => setState((currentState) => ({
      history: currentState.history,
      current: Math.min(currentState.history.length - 1, currentState.current + steps)
    })),
    []
  ), reset = useCallback(() => {
    setState({ history: [initialValue], current: 0 });
  }, [initialValue]), handlers = useMemo(() => ({ back, forward, reset, set: set2 }), [back, forward, reset, set2]);
  return [state.history[state.current], handlers, state];
}
function useThrottledCallbackWithClearTimeout(callback, wait) {
  const handleCallback = useCallbackRef(callback), latestInArgsRef = useRef(null), latestOutArgsRef = useRef(null), active = useRef(!0), waitRef = useRef(wait), timeoutRef = useRef(-1), clearTimeout2 = () => window.clearTimeout(timeoutRef.current), callThrottledCallback = useCallback(
    (...args) => {
      handleCallback(...args), latestInArgsRef.current = args, latestOutArgsRef.current = args, active.current = !1;
    },
    [handleCallback]
  ), timerCallback = useCallback(() => {
    latestInArgsRef.current && latestInArgsRef.current !== latestOutArgsRef.current ? (callThrottledCallback(...latestInArgsRef.current), timeoutRef.current = window.setTimeout(timerCallback, waitRef.current)) : active.current = !0;
  }, [callThrottledCallback]), throttled = useCallback(
    (...args) => {
      active.current ? (callThrottledCallback(...args), timeoutRef.current = window.setTimeout(timerCallback, waitRef.current)) : latestInArgsRef.current = args;
    },
    [callThrottledCallback, timerCallback]
  );
  return useEffect(() => {
    waitRef.current = wait;
  }, [wait]), [throttled, clearTimeout2];
}
function useThrottledCallback(callback, wait) {
  return useThrottledCallbackWithClearTimeout(callback, wait)[0];
}
function getEnv() {
  return typeof process < "u" && process.env ? "production" : "development";
}
function memoize(func) {
  const cache2 = /* @__PURE__ */ new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache2.has(key))
      return cache2.get(key);
    const result = func(...args);
    return cache2.set(key, result), result;
  };
}
function findClosestNumber(value, numbers) {
  return numbers.length === 0 ? value : numbers.reduce(
    (prev, curr) => Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev
  );
}
function getRefProp(element) {
  const version2 = React__default.version;
  return typeof React__default.version != "string" || version2.startsWith("18.") ? element?.ref : element?.props?.ref;
}
function findElementBySelector(selector2, root2 = document) {
  const element = root2.querySelector(selector2);
  if (element)
    return element;
  const allElements = root2.querySelectorAll("*");
  for (let i2 = 0; i2 < allElements.length; i2 += 1) {
    const el = allElements[i2];
    if (el.shadowRoot) {
      const shadowElement = findElementBySelector(selector2, el.shadowRoot);
      if (shadowElement)
        return shadowElement;
    }
  }
  return null;
}
function findElementsBySelector(selector2, root2 = document) {
  const results = [], elements = root2.querySelectorAll(selector2);
  results.push(...Array.from(elements));
  const allElements = root2.querySelectorAll("*");
  for (let i2 = 0; i2 < allElements.length; i2 += 1) {
    const el = allElements[i2];
    if (el.shadowRoot) {
      const shadowElements = findElementsBySelector(selector2, el.shadowRoot);
      results.push(...shadowElements);
    }
  }
  return results;
}
function getRootElement(targetElement) {
  if (!targetElement)
    return document;
  const root2 = targetElement.getRootNode();
  return root2 instanceof ShadowRoot || root2 instanceof Document ? root2 : document;
}
function getSingleElementChild(children2) {
  const _children = Children.toArray(children2);
  return _children.length !== 1 || !isElement$1(_children[0]) ? null : _children[0];
}
function r$f(e2) {
  var t2, f, n2 = "";
  if (typeof e2 == "string" || typeof e2 == "number") n2 += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) {
    var o = e2.length;
    for (t2 = 0; t2 < o; t2++) e2[t2] && (f = r$f(e2[t2])) && (n2 && (n2 += " "), n2 += f);
  } else for (f in e2) e2[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
function clsx() {
  for (var e2, t2, f = 0, n2 = "", o = arguments.length; f < o; f++) (e2 = arguments[f]) && (t2 = r$f(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const EMPTY_CLASS_NAMES = {};
function mergeClassNames(objects) {
  const merged = {};
  return objects.forEach((obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      merged[key] ? merged[key] = clsx(merged[key], value) : merged[key] = value;
    });
  }), merged;
}
function resolveClassNames({ theme, classNames, props, stylesCtx }) {
  const resolvedClassNames = (Array.isArray(classNames) ? classNames : [classNames]).map(
    (item) => typeof item == "function" ? item(theme, props, stylesCtx) : item || EMPTY_CLASS_NAMES
  );
  return mergeClassNames(resolvedClassNames);
}
function resolveStyles({ theme, styles, props, stylesCtx }) {
  return (Array.isArray(styles) ? styles : [styles]).reduce((acc, style2) => typeof style2 == "function" ? { ...acc, ...style2(theme, props, stylesCtx) } : { ...acc, ...style2 }, {});
}
const MantineContext = createContext(null);
function useMantineContext() {
  const ctx = useContext(MantineContext);
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return ctx;
}
function useMantineCssVariablesResolver() {
  return useMantineContext().cssVariablesResolver;
}
function useMantineClassNamesPrefix() {
  return useMantineContext().classNamesPrefix;
}
function useMantineStyleNonce() {
  return useMantineContext().getStyleNonce;
}
function useMantineWithStaticClasses() {
  return useMantineContext().withStaticClasses;
}
function useMantineIsHeadless() {
  return useMantineContext().headless;
}
function useMantineSxTransform() {
  return useMantineContext().stylesTransform?.sx;
}
function useMantineStylesTransform() {
  return useMantineContext().stylesTransform?.styles;
}
function useMantineEnv() {
  return useMantineContext().env || "default";
}
function isHexColor(hex2) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(hex2);
}
function hexToRgba(color2) {
  let hexString = color2.replace("#", "");
  if (hexString.length === 3) {
    const shorthandHex = hexString.split("");
    hexString = [
      shorthandHex[0],
      shorthandHex[0],
      shorthandHex[1],
      shorthandHex[1],
      shorthandHex[2],
      shorthandHex[2]
    ].join("");
  }
  if (hexString.length === 8) {
    const alpha2 = parseInt(hexString.slice(6, 8), 16) / 255;
    return {
      r: parseInt(hexString.slice(0, 2), 16),
      g: parseInt(hexString.slice(2, 4), 16),
      b: parseInt(hexString.slice(4, 6), 16),
      a: alpha2
    };
  }
  const parsed = parseInt(hexString, 16), r2 = parsed >> 16 & 255, g = parsed >> 8 & 255, b = parsed & 255;
  return {
    r: r2,
    g,
    b,
    a: 1
  };
}
function rgbStringToRgba(color2) {
  const [r2, g, b, a2] = color2.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: r2, g, b, a: a2 === void 0 ? 1 : a2 };
}
function hslStringToRgba(hslaString) {
  const hslaRegex = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, matches2 = hslaString.match(hslaRegex);
  if (!matches2)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const h = parseInt(matches2[1], 10), s = parseInt(matches2[2], 10) / 100, l = parseInt(matches2[3], 10) / 100, a2 = matches2[5] ? parseFloat(matches2[5]) : void 0, chroma = (1 - Math.abs(2 * l - 1)) * s, huePrime = h / 60, x2 = chroma * (1 - Math.abs(huePrime % 2 - 1)), m2 = l - chroma / 2;
  let r2, g, b;
  return huePrime >= 0 && huePrime < 1 ? (r2 = chroma, g = x2, b = 0) : huePrime >= 1 && huePrime < 2 ? (r2 = x2, g = chroma, b = 0) : huePrime >= 2 && huePrime < 3 ? (r2 = 0, g = chroma, b = x2) : huePrime >= 3 && huePrime < 4 ? (r2 = 0, g = x2, b = chroma) : huePrime >= 4 && huePrime < 5 ? (r2 = x2, g = 0, b = chroma) : (r2 = chroma, g = 0, b = x2), {
    r: Math.round((r2 + m2) * 255),
    g: Math.round((g + m2) * 255),
    b: Math.round((b + m2) * 255),
    a: a2 || 1
  };
}
function toRgba$1(color2) {
  return isHexColor(color2) ? hexToRgba(color2) : color2.startsWith("rgb") ? rgbStringToRgba(color2) : color2.startsWith("hsl") ? hslStringToRgba(color2) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function darken(color2, alpha2) {
  if (color2.startsWith("var("))
    return `color-mix(in srgb, ${color2}, black ${alpha2 * 100}%)`;
  const { r: r2, g, b, a: a2 } = toRgba$1(color2), f = 1 - alpha2, dark = (input) => Math.round(input * f);
  return `rgba(${dark(r2)}, ${dark(g)}, ${dark(b)}, ${a2})`;
}
function getPrimaryShade(theme, colorScheme) {
  return typeof theme.primaryShade == "number" ? theme.primaryShade : colorScheme === "dark" ? theme.primaryShade.dark : theme.primaryShade.light;
}
function gammaCorrect(c) {
  return c <= 0.03928 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
}
function getLightnessFromOklch(oklchColor) {
  const match = oklchColor.match(/oklch\((.*?)%\s/);
  return match ? parseFloat(match[1]) : null;
}
function luminance(color2) {
  if (color2.startsWith("oklch("))
    return (getLightnessFromOklch(color2) || 0) / 100;
  const { r: r2, g, b } = toRgba$1(color2), sR = r2 / 255, sG = g / 255, sB = b / 255, rLinear = gammaCorrect(sR), gLinear = gammaCorrect(sG), bLinear = gammaCorrect(sB);
  return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
}
function isLightColor(color2, luminanceThreshold = 0.179) {
  return color2.startsWith("var(") ? !1 : luminance(color2) > luminanceThreshold;
}
function parseThemeColor({
  color: color2,
  theme,
  colorScheme
}) {
  if (typeof color2 != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof color2}`
    );
  if (color2 === "bright")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (color2 === "dimmed")
    return {
      color: color2,
      value: colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        colorScheme === "dark" ? theme.colors.dark[2] : theme.colors.gray[6],
        theme.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (color2 === "white" || color2 === "black")
    return {
      color: color2,
      value: color2 === "white" ? theme.white : theme.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: isLightColor(
        color2 === "white" ? theme.white : theme.black,
        theme.luminanceThreshold
      ),
      variable: `--mantine-color-${color2}`
    };
  const [_color, shade] = color2.split("."), colorShade = shade ? Number(shade) : void 0, isThemeColor = _color in theme.colors;
  if (isThemeColor) {
    const colorValue = colorShade !== void 0 ? theme.colors[_color][colorShade] : theme.colors[_color][getPrimaryShade(theme, colorScheme || "light")];
    return {
      color: _color,
      value: colorValue,
      shade: colorShade,
      isThemeColor,
      isLight: isLightColor(colorValue, theme.luminanceThreshold),
      variable: shade ? `--mantine-color-${_color}-${colorShade}` : `--mantine-color-${_color}-filled`
    };
  }
  return {
    color: color2,
    value: color2,
    isThemeColor,
    isLight: isLightColor(color2, theme.luminanceThreshold),
    shade: colorShade,
    variable: void 0
  };
}
function getThemeColor(color2, theme) {
  const parsed = parseThemeColor({ color: color2 || theme.primaryColor, theme });
  return parsed.variable ? `var(${parsed.variable})` : color2;
}
function getGradient(gradient, theme) {
  const merged = {
    from: gradient?.from || theme.defaultGradient.from,
    to: gradient?.to || theme.defaultGradient.to,
    deg: gradient?.deg ?? theme.defaultGradient.deg ?? 0
  }, fromColor = getThemeColor(merged.from, theme), toColor = getThemeColor(merged.to, theme);
  return `linear-gradient(${merged.deg}deg, ${fromColor} 0%, ${toColor} 100%)`;
}
function rgba$3(color2, alpha2) {
  if (typeof color2 != "string" || alpha2 > 1 || alpha2 < 0)
    return "rgba(0, 0, 0, 1)";
  if (color2.startsWith("var(")) {
    const mixPercentage = (1 - alpha2) * 100;
    return `color-mix(in srgb, ${color2}, transparent ${mixPercentage}%)`;
  }
  if (color2.startsWith("oklch"))
    return color2.includes("/") ? color2.replace(/\/\s*[\d.]+\s*\)/, `/ ${alpha2})`) : color2.replace(")", ` / ${alpha2})`);
  const { r: r2, g, b } = toRgba$1(color2);
  return `rgba(${r2}, ${g}, ${b}, ${alpha2})`;
}
const alpha$1 = rgba$3, defaultVariantColorsResolver = ({
  color: color2,
  theme,
  variant,
  gradient,
  autoContrast
}) => {
  const parsed = parseThemeColor({ color: color2, theme }), _autoContrast = typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
  if (variant === "none")
    return {
      background: "transparent",
      hover: "transparent",
      color: "inherit",
      border: "none"
    };
  if (variant === "filled") {
    const textColor = _autoContrast && parsed.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: `var(--mantine-color-${color2}-filled)`,
      hover: `var(--mantine-color-${color2}-filled-hover)`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      hover: `var(--mantine-color-${parsed.color}-${parsed.shade === 9 ? 8 : parsed.shade + 1})`,
      color: textColor,
      border: `${rem(1)} solid transparent`
    } : {
      background: color2,
      hover: darken(color2, 0.1),
      color: textColor,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "light") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: `var(--mantine-color-${color2}-light)`,
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: rgba$3(parsedColor, 0.1),
        hover: rgba$3(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: rgba$3(color2, 0.1),
      hover: rgba$3(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  if (variant === "outline")
    return parsed.isThemeColor ? parsed.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${color2}-outline-hover)`,
      color: `var(--mantine-color-${color2}-outline)`,
      border: `${rem(1)} solid var(--mantine-color-${color2}-outline)`
    } : {
      background: "transparent",
      hover: rgba$3(theme.colors[parsed.color][parsed.shade], 0.05),
      color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
      border: `${rem(1)} solid var(--mantine-color-${parsed.color}-${parsed.shade})`
    } : {
      background: "transparent",
      hover: rgba$3(color2, 0.05),
      color: color2,
      border: `${rem(1)} solid ${color2}`
    };
  if (variant === "subtle") {
    if (parsed.isThemeColor) {
      if (parsed.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${color2}-light-hover)`,
          color: `var(--mantine-color-${color2}-light-color)`,
          border: `${rem(1)} solid transparent`
        };
      const parsedColor = theme.colors[parsed.color][parsed.shade];
      return {
        background: "transparent",
        hover: rgba$3(parsedColor, 0.12),
        color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
        border: `${rem(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: rgba$3(color2, 0.12),
      color: color2,
      border: `${rem(1)} solid transparent`
    };
  }
  return variant === "transparent" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${color2}-light-color)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${parsed.color}-${Math.min(parsed.shade, 6)})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "white" ? parsed.isThemeColor ? parsed.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${color2}-filled)`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: `var(--mantine-color-${parsed.color}-${parsed.shade})`,
    border: `${rem(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: darken(theme.white, 0.01),
    color: color2,
    border: `${rem(1)} solid transparent`
  } : variant === "gradient" ? {
    background: getGradient(gradient, theme),
    hover: getGradient(gradient, theme),
    color: "var(--mantine-color-white)",
    border: "none"
  } : variant === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${rem(1)} solid var(--mantine-color-default-border)`
  } : {};
}, DEFAULT_COLORS = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, DEFAULT_FONT_FAMILY = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", DEFAULT_THEME = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: DEFAULT_COLORS,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: defaultVariantColorsResolver,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: DEFAULT_FONT_FAMILY,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: rem(34), lineHeight: "1.3" },
      h2: { fontSize: rem(26), lineHeight: "1.35" },
      h3: { fontSize: rem(22), lineHeight: "1.4" },
      h4: { fontSize: rem(18), lineHeight: "1.45" },
      h5: { fontSize: rem(16), lineHeight: "1.5" },
      h6: { fontSize: rem(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: rem(12),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: rem(2),
    sm: rem(4),
    md: rem(8),
    lg: rem(16),
    xl: rem(32)
  },
  spacing: {
    xs: rem(10),
    sm: rem(12),
    md: rem(16),
    lg: rem(20),
    xl: rem(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), 0 ${rem(1)} ${rem(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(10)} ${rem(
      15
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(7)} ${rem(7)} ${rem(-5)}`,
    md: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(20)} ${rem(
      25
    )} ${rem(-5)}, rgba(0, 0, 0, 0.04) 0 ${rem(10)} ${rem(10)} ${rem(-5)}`,
    lg: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(28)} ${rem(
      23
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(12)} ${rem(12)} ${rem(-7)}`,
    xl: `0 ${rem(1)} ${rem(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${rem(36)} ${rem(
      28
    )} ${rem(-7)}, rgba(0, 0, 0, 0.04) 0 ${rem(17)} ${rem(17)} ${rem(-7)}`
  },
  other: {},
  components: {}
};
function isMantineColorScheme(value) {
  return value === "auto" || value === "dark" || value === "light";
}
function localStorageColorSchemeManager({
  key = "mantine-color-scheme-value"
} = {}) {
  let handleStorageEvent;
  return {
    get: (defaultValue) => {
      if (typeof window > "u")
        return defaultValue;
      try {
        const storedColorScheme = window.localStorage.getItem(key);
        return isMantineColorScheme(storedColorScheme) ? storedColorScheme : defaultValue;
      } catch {
        return defaultValue;
      }
    },
    set: (value) => {
      try {
        window.localStorage.setItem(key, value);
      } catch (error) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          error
        );
      }
    },
    subscribe: (onUpdate) => {
      handleStorageEvent = (event) => {
        event.storageArea === window.localStorage && event.key === key && isMantineColorScheme(event.newValue) && onUpdate(event.newValue);
      }, window.addEventListener("storage", handleStorageEvent);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", handleStorageEvent);
    },
    clear: () => {
      window.localStorage.removeItem(key);
    }
  };
}
const INVALID_PRIMARY_COLOR_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more  https://mantine.dev/theming/colors/#primary-color", INVALID_PRIMARY_SHADE_ERROR = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function isValidPrimaryShade(shade) {
  return shade < 0 || shade > 9 ? !1 : parseInt(shade.toString(), 10) === shade;
}
function validateMantineTheme(theme) {
  if (!(theme.primaryColor in theme.colors))
    throw new Error(INVALID_PRIMARY_COLOR_ERROR);
  if (typeof theme.primaryShade == "object" && (!isValidPrimaryShade(theme.primaryShade.dark) || !isValidPrimaryShade(theme.primaryShade.light)))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
  if (typeof theme.primaryShade == "number" && !isValidPrimaryShade(theme.primaryShade))
    throw new Error(INVALID_PRIMARY_SHADE_ERROR);
}
function mergeMantineTheme(currentTheme, themeOverride) {
  if (!themeOverride)
    return validateMantineTheme(currentTheme), currentTheme;
  const result = deepMerge(currentTheme, themeOverride);
  return themeOverride.fontFamily && !themeOverride.headings?.fontFamily && (result.headings.fontFamily = themeOverride.fontFamily), validateMantineTheme(result), result;
}
const MantineThemeContext = createContext(null), useSafeMantineTheme = () => useContext(MantineThemeContext) || DEFAULT_THEME;
function useMantineTheme() {
  const ctx = useContext(MantineThemeContext);
  if (!ctx)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return ctx;
}
function MantineThemeProvider({
  theme,
  children: children2,
  inherit: inherit2 = !0
}) {
  const parentTheme = useSafeMantineTheme(), mergedTheme = useMemo(
    () => mergeMantineTheme(inherit2 ? parentTheme : DEFAULT_THEME, theme),
    [theme, parentTheme, inherit2]
  );
  return /* @__PURE__ */ jsx(MantineThemeContext.Provider, { value: mergedTheme, children: children2 });
}
MantineThemeProvider.displayName = "@mantine/core/MantineThemeProvider";
function MantineClasses() {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), classes2 = keys$1(theme.breakpoints).reduce((acc, breakpoint) => {
    const isPxBreakpoint = theme.breakpoints[breakpoint].includes("px"), pxValue = px$2(theme.breakpoints[breakpoint]), maxWidthBreakpoint = isPxBreakpoint ? `${pxValue - 0.1}px` : em(pxValue - 0.1), minWidthBreakpoint = isPxBreakpoint ? `${pxValue}px` : em(pxValue);
    return `${acc}@media (max-width: ${maxWidthBreakpoint}) {.mantine-visible-from-${breakpoint} {display: none !important;}}@media (min-width: ${minWidthBreakpoint}) {.mantine-hidden-from-${breakpoint} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: classes2 }
    }
  );
}
function cssVariablesObjectToString(variables) {
  return Object.entries(variables).map(([name, value]) => `${name}: ${value};`).join("");
}
function convertCssVariables(input, selectorOverride) {
  const selectors = selectorOverride ? [selectorOverride] : [":root", ":host"], sharedVariables = cssVariablesObjectToString(input.variables), shared = sharedVariables ? `${selectors.join(", ")}{${sharedVariables}}` : "", dark = cssVariablesObjectToString(input.dark), light = cssVariablesObjectToString(input.light), selectorsWithScheme = (scheme) => selectors.map(
    (selector2) => selector2 === ":host" ? `${selector2}([data-mantine-color-scheme="${scheme}"])` : `${selector2}[data-mantine-color-scheme="${scheme}"]`
  ).join(", "), darkForced = dark ? `${selectorsWithScheme("dark")}{${dark}}` : "", lightForced = light ? `${selectorsWithScheme("light")}{${light}}` : "";
  return `${shared}

${darkForced}

${lightForced}`;
}
function getContrastColor({ color: color2, theme, autoContrast }) {
  return (typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast) && parseThemeColor({ color: color2 || theme.primaryColor, theme }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function getPrimaryContrastColor(theme, colorScheme) {
  return getContrastColor({
    color: theme.colors[theme.primaryColor][getPrimaryShade(theme, colorScheme)],
    theme,
    autoContrast: null
  });
}
function getCSSColorVariables({
  theme,
  color: color2,
  colorScheme,
  name = color2,
  withColorValues = !0
}) {
  if (!theme.colors[color2])
    return {};
  if (colorScheme === "light") {
    const primaryShade2 = getPrimaryShade(theme, "light"), dynamicVariables2 = {
      [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-filled)`,
      [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade2 === 9 ? 8 : primaryShade2 + 1})`,
      [`--mantine-color-${name}-light`]: alpha$1(theme.colors[color2][primaryShade2], 0.1),
      [`--mantine-color-${name}-light-hover`]: alpha$1(theme.colors[color2][primaryShade2], 0.12),
      [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${primaryShade2})`,
      [`--mantine-color-${name}-outline-hover`]: alpha$1(theme.colors[color2][primaryShade2], 0.05)
    };
    return withColorValues ? {
      [`--mantine-color-${name}-0`]: theme.colors[color2][0],
      [`--mantine-color-${name}-1`]: theme.colors[color2][1],
      [`--mantine-color-${name}-2`]: theme.colors[color2][2],
      [`--mantine-color-${name}-3`]: theme.colors[color2][3],
      [`--mantine-color-${name}-4`]: theme.colors[color2][4],
      [`--mantine-color-${name}-5`]: theme.colors[color2][5],
      [`--mantine-color-${name}-6`]: theme.colors[color2][6],
      [`--mantine-color-${name}-7`]: theme.colors[color2][7],
      [`--mantine-color-${name}-8`]: theme.colors[color2][8],
      [`--mantine-color-${name}-9`]: theme.colors[color2][9],
      ...dynamicVariables2
    } : dynamicVariables2;
  }
  const primaryShade = getPrimaryShade(theme, "dark"), dynamicVariables = {
    [`--mantine-color-${name}-text`]: `var(--mantine-color-${name}-4)`,
    [`--mantine-color-${name}-filled`]: `var(--mantine-color-${name}-${primaryShade})`,
    [`--mantine-color-${name}-filled-hover`]: `var(--mantine-color-${name}-${primaryShade === 9 ? 8 : primaryShade + 1})`,
    [`--mantine-color-${name}-light`]: alpha$1(
      theme.colors[color2][Math.max(0, primaryShade - 2)],
      0.15
    ),
    [`--mantine-color-${name}-light-hover`]: alpha$1(
      theme.colors[color2][Math.max(0, primaryShade - 2)],
      0.2
    ),
    [`--mantine-color-${name}-light-color`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 5, 0)})`,
    [`--mantine-color-${name}-outline`]: `var(--mantine-color-${name}-${Math.max(primaryShade - 4, 0)})`,
    [`--mantine-color-${name}-outline-hover`]: alpha$1(
      theme.colors[color2][Math.max(primaryShade - 4, 0)],
      0.05
    )
  };
  return withColorValues ? {
    [`--mantine-color-${name}-0`]: theme.colors[color2][0],
    [`--mantine-color-${name}-1`]: theme.colors[color2][1],
    [`--mantine-color-${name}-2`]: theme.colors[color2][2],
    [`--mantine-color-${name}-3`]: theme.colors[color2][3],
    [`--mantine-color-${name}-4`]: theme.colors[color2][4],
    [`--mantine-color-${name}-5`]: theme.colors[color2][5],
    [`--mantine-color-${name}-6`]: theme.colors[color2][6],
    [`--mantine-color-${name}-7`]: theme.colors[color2][7],
    [`--mantine-color-${name}-8`]: theme.colors[color2][8],
    [`--mantine-color-${name}-9`]: theme.colors[color2][9],
    ...dynamicVariables
  } : dynamicVariables;
}
function isVirtualColor(value) {
  return !!value && typeof value == "object" && "mantine-virtual-color" in value;
}
function assignSizeVariables(variables, sizes2, name) {
  keys$1(sizes2).forEach(
    (size2) => Object.assign(variables, { [`--mantine-${name}-${size2}`]: sizes2[size2] })
  );
}
const defaultCssVariablesResolver = (theme) => {
  const lightPrimaryShade = getPrimaryShade(theme, "light"), defaultRadius = theme.defaultRadius in theme.radius ? theme.radius[theme.defaultRadius] : rem(theme.defaultRadius), result = {
    variables: {
      "--mantine-z-index-app": "100",
      "--mantine-z-index-modal": "200",
      "--mantine-z-index-popover": "300",
      "--mantine-z-index-overlay": "400",
      "--mantine-z-index-max": "9999",
      "--mantine-scale": theme.scale.toString(),
      "--mantine-cursor-type": theme.cursorType,
      "--mantine-webkit-font-smoothing": theme.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": theme.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": theme.white,
      "--mantine-color-black": theme.black,
      "--mantine-line-height": theme.lineHeights.md,
      "--mantine-font-family": theme.fontFamily,
      "--mantine-font-family-monospace": theme.fontFamilyMonospace,
      "--mantine-font-family-headings": theme.headings.fontFamily,
      "--mantine-heading-font-weight": theme.headings.fontWeight,
      "--mantine-heading-text-wrap": theme.headings.textWrap,
      "--mantine-radius-default": defaultRadius,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${theme.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${theme.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${theme.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${theme.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${theme.primaryColor}-light-color)`
    },
    light: {
      "--mantine-color-scheme": "light",
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": theme.black,
      "--mantine-color-body": theme.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-${lightPrimaryShade})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)",
      "--mantine-color-disabled": "var(--mantine-color-gray-2)",
      "--mantine-color-disabled-color": "var(--mantine-color-gray-5)",
      "--mantine-color-disabled-border": "var(--mantine-color-gray-3)"
    },
    dark: {
      "--mantine-color-scheme": "dark",
      "--mantine-primary-color-contrast": getPrimaryContrastColor(theme, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${theme.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)",
      "--mantine-color-disabled": "var(--mantine-color-dark-6)",
      "--mantine-color-disabled-color": "var(--mantine-color-dark-3)",
      "--mantine-color-disabled-border": "var(--mantine-color-dark-4)"
    }
  };
  assignSizeVariables(result.variables, theme.breakpoints, "breakpoint"), assignSizeVariables(result.variables, theme.spacing, "spacing"), assignSizeVariables(result.variables, theme.fontSizes, "font-size"), assignSizeVariables(result.variables, theme.lineHeights, "line-height"), assignSizeVariables(result.variables, theme.shadows, "shadow"), assignSizeVariables(result.variables, theme.radius, "radius"), theme.colors[theme.primaryColor].forEach((_2, index2) => {
    result.variables[`--mantine-primary-color-${index2}`] = `var(--mantine-color-${theme.primaryColor}-${index2})`;
  }), keys$1(theme.colors).forEach((color2) => {
    const value = theme.colors[color2];
    if (isVirtualColor(value)) {
      Object.assign(
        result.light,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        result.dark,
        getCSSColorVariables({
          theme,
          name: value.name,
          color: value.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    value.forEach((shade, index2) => {
      result.variables[`--mantine-color-${color2}-${index2}`] = shade;
    }), Object.assign(
      result.light,
      getCSSColorVariables({
        theme,
        color: color2,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      result.dark,
      getCSSColorVariables({
        theme,
        color: color2,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const headings2 = theme.headings.sizes;
  return keys$1(headings2).forEach((heading) => {
    result.variables[`--mantine-${heading}-font-size`] = headings2[heading].fontSize, result.variables[`--mantine-${heading}-line-height`] = headings2[heading].lineHeight, result.variables[`--mantine-${heading}-font-weight`] = headings2[heading].fontWeight || theme.headings.fontWeight;
  }), result;
};
function getMergedVariables({ theme, generator }) {
  const defaultResolver = defaultCssVariablesResolver(theme), providerGenerator = generator?.(theme);
  return providerGenerator ? deepMerge(defaultResolver, providerGenerator) : defaultResolver;
}
const defaultCssVariables = defaultCssVariablesResolver(DEFAULT_THEME);
function removeDefaultVariables(input) {
  const cleaned = {
    variables: {},
    light: {},
    dark: {}
  };
  return keys$1(input.variables).forEach((key) => {
    defaultCssVariables.variables[key] !== input.variables[key] && (cleaned.variables[key] = input.variables[key]);
  }), keys$1(input.light).forEach((key) => {
    defaultCssVariables.light[key] !== input.light[key] && (cleaned.light[key] = input.light[key]);
  }), keys$1(input.dark).forEach((key) => {
    defaultCssVariables.dark[key] !== input.dark[key] && (cleaned.dark[key] = input.dark[key]);
  }), cleaned;
}
function getColorSchemeCssVariables(selectorOverride) {
  return convertCssVariables(
    {
      variables: {},
      dark: { "--mantine-color-scheme": "dark" },
      light: { "--mantine-color-scheme": "light" }
    },
    selectorOverride
  );
}
function MantineCssVariables({
  cssVariablesSelector,
  deduplicateCssVariables
}) {
  const theme = useMantineTheme(), nonce = useMantineStyleNonce(), generator = useMantineCssVariablesResolver(), mergedVariables = getMergedVariables({ theme, generator }), shouldCleanVariables = (cssVariablesSelector === void 0 || cssVariablesSelector === ":root" || cssVariablesSelector === ":host") && deduplicateCssVariables, cleanedVariables = shouldCleanVariables ? removeDefaultVariables(mergedVariables) : mergedVariables, css = convertCssVariables(cleanedVariables, cssVariablesSelector);
  return css ? /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: nonce?.(),
      dangerouslySetInnerHTML: {
        __html: `${css}${shouldCleanVariables ? "" : getColorSchemeCssVariables(cssVariablesSelector)}`
      }
    }
  ) : null;
}
MantineCssVariables.displayName = "@mantine/CssVariables";
function setColorSchemeAttribute(colorScheme, getRootElement2) {
  const hasDarkColorScheme = typeof window < "u" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches, computedColorScheme = colorScheme !== "auto" ? colorScheme : hasDarkColorScheme ? "dark" : "light";
  getRootElement2()?.setAttribute("data-mantine-color-scheme", computedColorScheme);
}
function useProviderColorScheme({
  manager,
  defaultColorScheme,
  getRootElement: getRootElement2,
  forceColorScheme
}) {
  const media = useRef(null), [value, setValue] = useState(() => manager.get(defaultColorScheme)), colorSchemeValue = forceColorScheme || value, setColorScheme = useCallback(
    (colorScheme) => {
      forceColorScheme || (setColorSchemeAttribute(colorScheme, getRootElement2), setValue(colorScheme), manager.set(colorScheme));
    },
    [manager.set, colorSchemeValue, forceColorScheme]
  ), clearColorScheme = useCallback(() => {
    setValue(defaultColorScheme), setColorSchemeAttribute(defaultColorScheme, getRootElement2), manager.clear();
  }, [manager.clear, defaultColorScheme]);
  return useEffect(() => (manager.subscribe(setColorScheme), manager.unsubscribe), [manager.subscribe, manager.unsubscribe]), useIsomorphicEffect(() => {
    setColorSchemeAttribute(manager.get(defaultColorScheme), getRootElement2);
  }, []), useEffect(() => {
    if (forceColorScheme)
      return setColorSchemeAttribute(forceColorScheme, getRootElement2), () => {
      };
    forceColorScheme === void 0 && setColorSchemeAttribute(value, getRootElement2), typeof window < "u" && "matchMedia" in window && (media.current = window.matchMedia("(prefers-color-scheme: dark)"));
    const listener = (event) => {
      value === "auto" && setColorSchemeAttribute(event.matches ? "dark" : "light", getRootElement2);
    };
    return media.current?.addEventListener("change", listener), () => media.current?.removeEventListener("change", listener);
  }, [value, forceColorScheme]), { colorScheme: colorSchemeValue, setColorScheme, clearColorScheme };
}
function useRespectReduceMotion({
  respectReducedMotion,
  getRootElement: getRootElement2
}) {
  useIsomorphicEffect(() => {
    respectReducedMotion && getRootElement2()?.setAttribute("data-respect-reduced-motion", "true");
  }, [respectReducedMotion]);
}
function MantineProvider({
  theme,
  children: children2,
  getStyleNonce,
  withStaticClasses = !0,
  withGlobalClasses = !0,
  deduplicateCssVariables = !0,
  withCssVariables = !0,
  cssVariablesSelector,
  classNamesPrefix = "mantine",
  colorSchemeManager = localStorageColorSchemeManager(),
  defaultColorScheme = "light",
  getRootElement: getRootElement2 = () => document.documentElement,
  cssVariablesResolver,
  forceColorScheme,
  stylesTransform,
  env
}) {
  const { colorScheme, setColorScheme, clearColorScheme } = useProviderColorScheme({
    defaultColorScheme,
    forceColorScheme,
    manager: colorSchemeManager,
    getRootElement: getRootElement2
  });
  return useRespectReduceMotion({
    respectReducedMotion: theme?.respectReducedMotion || !1,
    getRootElement: getRootElement2
  }), /* @__PURE__ */ jsx(
    MantineContext.Provider,
    {
      value: {
        colorScheme,
        setColorScheme,
        clearColorScheme,
        getRootElement: getRootElement2,
        classNamesPrefix,
        getStyleNonce,
        cssVariablesResolver,
        cssVariablesSelector: cssVariablesSelector ?? ":root",
        withStaticClasses,
        stylesTransform,
        env
      },
      children: /* @__PURE__ */ jsxs(MantineThemeProvider, { theme, children: [
        withCssVariables && /* @__PURE__ */ jsx(
          MantineCssVariables,
          {
            cssVariablesSelector,
            deduplicateCssVariables
          }
        ),
        withGlobalClasses && /* @__PURE__ */ jsx(MantineClasses, {}),
        children2
      ] })
    }
  );
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
function useResolvedStylesApi({
  classNames,
  styles,
  props,
  stylesCtx
}) {
  const theme = useMantineTheme();
  return {
    resolvedClassNames: resolveClassNames({
      theme,
      classNames,
      props,
      stylesCtx: stylesCtx || void 0
    }),
    resolvedStyles: resolveStyles({
      theme,
      styles,
      props,
      stylesCtx: stylesCtx || void 0
    })
  };
}
const FOCUS_CLASS_NAMES = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function getGlobalClassNames({ theme, options, unstyled }) {
  return clsx(
    options?.focusable && !unstyled && (theme.focusClassName || FOCUS_CLASS_NAMES[theme.focusRing]),
    options?.active && !unstyled && theme.activeClassName
  );
}
function getOptionsClassNames({
  selector: selector2,
  stylesCtx,
  options,
  props,
  theme
}) {
  return resolveClassNames({
    theme,
    classNames: options?.classNames,
    props: options?.props || props,
    stylesCtx
  })[selector2];
}
function getResolvedClassNames({
  selector: selector2,
  stylesCtx,
  theme,
  classNames,
  props
}) {
  return resolveClassNames({ theme, classNames, props, stylesCtx })[selector2];
}
function getRootClassName({ rootSelector, selector: selector2, className }) {
  return rootSelector === selector2 ? className : void 0;
}
function getSelectorClassName({ selector: selector2, classes: classes2, unstyled }) {
  return unstyled ? void 0 : classes2[selector2];
}
function getStaticClassNames({
  themeName,
  classNamesPrefix,
  selector: selector2,
  withStaticClass
}) {
  return withStaticClass === !1 ? [] : themeName.map((n2) => `${classNamesPrefix}-${n2}-${selector2}`);
}
function getThemeClassNames({
  themeName,
  theme,
  selector: selector2,
  props,
  stylesCtx
}) {
  return themeName.map(
    (n2) => resolveClassNames({
      theme,
      classNames: theme.components[n2]?.classNames,
      props,
      stylesCtx
    })?.[selector2]
  );
}
function getVariantClassName({
  options,
  classes: classes2,
  selector: selector2,
  unstyled
}) {
  return options?.variant && !unstyled ? classes2[`${selector2}--${options.variant}`] : void 0;
}
function getClassName({
  theme,
  options,
  themeName,
  selector: selector2,
  classNamesPrefix,
  classNames,
  classes: classes2,
  unstyled,
  className,
  rootSelector,
  props,
  stylesCtx,
  withStaticClasses,
  headless,
  transformedStyles
}) {
  return clsx(
    getGlobalClassNames({ theme, options, unstyled: unstyled || headless }),
    getThemeClassNames({ theme, themeName, selector: selector2, props, stylesCtx }),
    getVariantClassName({ options, classes: classes2, selector: selector2, unstyled }),
    getResolvedClassNames({ selector: selector2, stylesCtx, theme, classNames, props }),
    getResolvedClassNames({ selector: selector2, stylesCtx, theme, classNames: transformedStyles, props }),
    getOptionsClassNames({ selector: selector2, stylesCtx, options, props, theme }),
    getRootClassName({ rootSelector, selector: selector2, className }),
    getSelectorClassName({ selector: selector2, classes: classes2, unstyled: unstyled || headless }),
    withStaticClasses && !headless && getStaticClassNames({
      themeName,
      classNamesPrefix,
      selector: selector2,
      withStaticClass: options?.withStaticClass
    }),
    options?.className
  );
}
function getThemeStyles({
  theme,
  themeName,
  props,
  stylesCtx,
  selector: selector2
}) {
  return themeName.map(
    (n2) => resolveStyles({
      theme,
      styles: theme.components[n2]?.styles,
      props,
      stylesCtx
    })[selector2]
  ).reduce((acc, val) => ({ ...acc, ...val }), {});
}
function resolveStyle({ style: style2, theme }) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...resolveStyle({ style: item, theme }) }),
    {}
  ) : typeof style2 == "function" ? style2(theme) : style2 ?? {};
}
function mergeVars(vars) {
  return vars.reduce((acc, current2) => (current2 && Object.keys(current2).forEach((key) => {
    acc[key] = { ...acc[key], ...filterProps$1(current2[key]) };
  }), acc), {});
}
function resolveVars({
  vars,
  varsResolver: varsResolver2,
  theme,
  props,
  stylesCtx,
  selector: selector2,
  themeName,
  headless
}) {
  return mergeVars([
    headless ? {} : varsResolver2?.(theme, props, stylesCtx),
    ...themeName.map((name) => theme.components?.[name]?.vars?.(theme, props, stylesCtx)),
    vars?.(theme, props, stylesCtx)
  ])?.[selector2];
}
function getStyle({
  theme,
  themeName,
  selector: selector2,
  options,
  props,
  stylesCtx,
  rootSelector,
  styles,
  style: style2,
  vars,
  varsResolver: varsResolver2,
  headless,
  withStylesTransform
}) {
  return {
    ...!withStylesTransform && getThemeStyles({ theme, themeName, props, stylesCtx, selector: selector2 }),
    ...!withStylesTransform && resolveStyles({ theme, styles, props, stylesCtx })[selector2],
    ...!withStylesTransform && resolveStyles({ theme, styles: options?.styles, props: options?.props || props, stylesCtx })[selector2],
    ...resolveVars({ theme, props, stylesCtx, vars, varsResolver: varsResolver2, selector: selector2, themeName, headless }),
    ...rootSelector === selector2 ? resolveStyle({ style: style2, theme }) : null,
    ...resolveStyle({ style: options?.style, theme })
  };
}
function useStylesTransform({ props, stylesCtx, themeName }) {
  const theme = useMantineTheme(), stylesTransform = useMantineStylesTransform()?.();
  return {
    getTransformedStyles: (styles) => stylesTransform ? [
      ...styles.map(
        (style2) => stylesTransform(style2, { props, theme, ctx: stylesCtx })
      ),
      ...themeName.map(
        (n2) => stylesTransform(theme.components[n2]?.styles, { props, theme, ctx: stylesCtx })
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!stylesTransform
  };
}
function useStyles({
  name,
  classes: classes2,
  props,
  stylesCtx,
  className,
  style: style2,
  rootSelector = "root",
  unstyled,
  classNames,
  styles,
  vars,
  varsResolver: varsResolver2,
  attributes
}) {
  const theme = useMantineTheme(), classNamesPrefix = useMantineClassNamesPrefix(), withStaticClasses = useMantineWithStaticClasses(), headless = useMantineIsHeadless(), themeName = (Array.isArray(name) ? name : [name]).filter((n2) => n2), { withStylesTransform, getTransformedStyles } = useStylesTransform({
    props,
    stylesCtx,
    themeName
  });
  return (selector2, options) => ({
    className: getClassName({
      theme,
      options,
      themeName,
      selector: selector2,
      classNamesPrefix,
      classNames,
      classes: classes2,
      unstyled,
      className,
      rootSelector,
      props,
      stylesCtx,
      withStaticClasses,
      headless,
      transformedStyles: getTransformedStyles([options?.styles, styles])
    }),
    style: getStyle({
      theme,
      themeName,
      selector: selector2,
      options,
      props,
      stylesCtx,
      rootSelector,
      styles,
      style: style2,
      vars,
      varsResolver: varsResolver2,
      headless,
      withStylesTransform
    }),
    ...attributes?.[selector2]
  });
}
function getAutoContrastValue(autoContrast, theme) {
  return typeof autoContrast == "boolean" ? autoContrast : theme.autoContrast;
}
function disableTransition(nonce) {
  const style2 = document.createElement("style");
  return style2.setAttribute("data-mantine-styles", "inline"), style2.innerHTML = "*, *::before, *::after {transition: none !important;}", style2.setAttribute("data-mantine-disable-transition", "true"), nonce && style2.setAttribute("nonce", nonce), document.head.appendChild(style2), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((element) => element.remove());
}
function useMantineColorScheme({ keepTransitions } = {}) {
  const clearStylesRef = useRef(noop$5), timeoutRef = useRef(-1), ctx = useContext(MantineContext), nonce = useMantineStyleNonce(), nonceValue = useRef(nonce?.());
  if (!ctx)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  const setColorScheme = (value) => {
    ctx.setColorScheme(value), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, clearColorScheme = () => {
    ctx.clearColorScheme(), clearStylesRef.current = keepTransitions ? () => {
    } : disableTransition(nonceValue.current), window.clearTimeout(timeoutRef.current), timeoutRef.current = window.setTimeout(() => {
      clearStylesRef.current?.();
    }, 10);
  }, osColorScheme = useColorScheme("light", { getInitialValueInEffect: !1 }), computedColorScheme = ctx.colorScheme === "auto" ? osColorScheme : ctx.colorScheme, toggleColorScheme = useCallback(
    () => setColorScheme(computedColorScheme === "light" ? "dark" : "light"),
    [setColorScheme, computedColorScheme]
  );
  return useEffect(
    () => () => {
      clearStylesRef.current?.(), window.clearTimeout(timeoutRef.current);
    },
    []
  ), {
    colorScheme: ctx.colorScheme,
    setColorScheme,
    clearColorScheme,
    toggleColorScheme
  };
}
function useComputedColorScheme(defaultValue, options = { getInitialValueInEffect: !0 }) {
  const osColorScheme = useColorScheme(defaultValue, options), { colorScheme } = useMantineColorScheme();
  return colorScheme === "auto" ? osColorScheme : colorScheme;
}
function useProps(component, defaultProps2, props) {
  const theme = useMantineTheme(), contextPropsPayload = theme.components[component]?.defaultProps, contextProps = typeof contextPropsPayload == "function" ? contextPropsPayload(theme) : contextPropsPayload;
  return { ...defaultProps2, ...contextProps, ...filterProps$1(props) };
}
function createTheme(theme) {
  return theme;
}
function cssObjectToString(css) {
  return keys$1(css).reduce(
    (acc, rule) => css[rule] !== void 0 ? `${acc}${camelToKebabCase(rule)}:${css[rule]};` : acc,
    ""
  ).trim();
}
function stylesToString({ selector: selector2, styles, media, container }) {
  const baseStyles = styles ? cssObjectToString(styles) : "", mediaQueryStyles = Array.isArray(media) ? media.map((item) => `@media${item.query}{${selector2}{${cssObjectToString(item.styles)}}}`) : [], containerStyles = Array.isArray(container) ? container.map(
    (item) => `@container ${item.query}{${selector2}{${cssObjectToString(item.styles)}}}`
  ) : [];
  return `${baseStyles ? `${selector2}{${baseStyles}}` : ""}${mediaQueryStyles.join("")}${containerStyles.join("")}`.trim();
}
function InlineStyles(props) {
  const nonce = useMantineStyleNonce();
  return /* @__PURE__ */ jsx(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: nonce?.(),
      dangerouslySetInnerHTML: { __html: stylesToString(props) }
    }
  );
}
function extractStyleProps(others) {
  const {
    m: m2,
    mx,
    my,
    mt: mt2,
    mb,
    ml,
    mr,
    me,
    ms,
    p,
    px: px2,
    py,
    pt: pt2,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bdrs,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt: tt2,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx,
    ...rest
  } = others;
  return { styleProps: filterProps$1({
    m: m2,
    mx,
    my,
    mt: mt2,
    mb,
    ml,
    mr,
    me,
    ms,
    p,
    px: px2,
    py,
    pt: pt2,
    pb,
    pl,
    pr,
    pe,
    ps,
    bd,
    bg,
    c,
    opacity,
    ff,
    fz,
    fw,
    lts,
    ta,
    lh,
    fs,
    tt: tt2,
    td,
    w,
    miw,
    maw,
    h,
    mih,
    mah,
    bgsz,
    bgp,
    bgr,
    bga,
    pos,
    top,
    left,
    bottom,
    right,
    inset,
    display,
    flex,
    bdrs,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    sx
  }), rest };
}
const STYlE_PROPS_DATA = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bdrs: { type: "radius", property: "borderRadius" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function colorResolver(color2, theme) {
  const parsedColor = parseThemeColor({ color: color2, theme });
  return parsedColor.color === "dimmed" ? "var(--mantine-color-dimmed)" : parsedColor.color === "bright" ? "var(--mantine-color-bright)" : parsedColor.variable ? `var(${parsedColor.variable})` : parsedColor.color;
}
function textColorResolver(color2, theme) {
  const parsedColor = parseThemeColor({ color: color2, theme });
  return parsedColor.isThemeColor && parsedColor.shade === void 0 ? `var(--mantine-color-${parsedColor.color}-text)` : colorResolver(color2, theme);
}
function borderResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const [size2, style2, ...colorTuple] = value.split(" ").filter((val) => val.trim() !== "");
    let result = `${rem(size2)}`;
    return style2 && (result += ` ${style2}`), colorTuple.length > 0 && (result += ` ${colorResolver(colorTuple.join(" "), theme)}`), result.trim();
  }
  return value;
}
const values = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function fontFamilyResolver(fontFamily) {
  return typeof fontFamily == "string" && fontFamily in values ? values[fontFamily] : fontFamily;
}
const headings$2 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function fontSizeResolver(value, theme) {
  return typeof value == "string" && value in theme.fontSizes ? `var(--mantine-font-size-${value})` : typeof value == "string" && headings$2.includes(value) ? `var(--mantine-${value}-font-size)` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function identityResolver(value) {
  return value;
}
const headings$1 = ["h1", "h2", "h3", "h4", "h5", "h6"];
function lineHeightResolver(value, theme) {
  return typeof value == "string" && value in theme.lineHeights ? `var(--mantine-line-height-${value})` : typeof value == "string" && headings$1.includes(value) ? `var(--mantine-${value}-line-height)` : value;
}
function radiusResolver(value, theme) {
  return typeof value == "string" && value in theme.radius ? `var(--mantine-radius-${value})` : typeof value == "number" || typeof value == "string" ? rem(value) : value;
}
function sizeResolver(value) {
  return typeof value == "number" ? rem(value) : value;
}
function spacingResolver(value, theme) {
  if (typeof value == "number")
    return rem(value);
  if (typeof value == "string") {
    const mod = value.replace("-", "");
    if (!(mod in theme.spacing))
      return rem(value);
    const variable = `--mantine-spacing-${mod}`;
    return value.startsWith("-") ? `calc(var(${variable}) * -1)` : `var(${variable})`;
  }
  return value;
}
const resolvers = {
  color: colorResolver,
  textColor: textColorResolver,
  fontSize: fontSizeResolver,
  spacing: spacingResolver,
  radius: radiusResolver,
  identity: identityResolver,
  size: sizeResolver,
  lineHeight: lineHeightResolver,
  fontFamily: fontFamilyResolver,
  border: borderResolver
};
function replaceMediaQuery(query) {
  return query.replace("(min-width: ", "").replace("em)", "");
}
function sortMediaQueries({
  media,
  ...props
}) {
  const sortedMedia = Object.keys(media).sort((a2, b) => Number(replaceMediaQuery(a2)) - Number(replaceMediaQuery(b))).map((query) => ({ query, styles: media[query] }));
  return { ...props, media: sortedMedia };
}
function hasResponsiveStyles(styleProp) {
  if (typeof styleProp != "object" || styleProp === null)
    return !1;
  const breakpoints = Object.keys(styleProp);
  return !(breakpoints.length === 1 && breakpoints[0] === "base");
}
function getBaseValue(value) {
  return typeof value == "object" && value !== null ? "base" in value ? value.base : void 0 : value;
}
function getBreakpointKeys(value) {
  return typeof value == "object" && value !== null ? keys$1(value).filter((key) => key !== "base") : [];
}
function getBreakpointValue(value, breakpoint) {
  return typeof value == "object" && value !== null && breakpoint in value ? value[breakpoint] : value;
}
function parseStyleProps({
  styleProps,
  data,
  theme
}) {
  return sortMediaQueries(
    keys$1(styleProps).reduce(
      (acc, styleProp) => {
        if (styleProp === "hiddenFrom" || styleProp === "visibleFrom" || styleProp === "sx")
          return acc;
        const propertyData = data[styleProp], properties = Array.isArray(propertyData.property) ? propertyData.property : [propertyData.property], baseValue = getBaseValue(styleProps[styleProp]);
        if (!hasResponsiveStyles(styleProps[styleProp]))
          return properties.forEach((property) => {
            acc.inlineStyles[property] = resolvers[propertyData.type](baseValue, theme);
          }), acc;
        acc.hasResponsiveStyles = !0;
        const breakpoints = getBreakpointKeys(styleProps[styleProp]);
        return properties.forEach((property) => {
          baseValue != null && (acc.styles[property] = resolvers[propertyData.type](baseValue, theme)), breakpoints.forEach((breakpoint) => {
            const bp = `(min-width: ${theme.breakpoints[breakpoint]})`;
            acc.media[bp] = {
              ...acc.media[bp],
              [property]: resolvers[propertyData.type](
                getBreakpointValue(styleProps[styleProp], breakpoint),
                theme
              )
            };
          });
        }), acc;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function useRandomClassName() {
  return `__m__-${useId$2().replace(/[:]/g, "")}`;
}
function getStyleObject(style2, theme) {
  return Array.isArray(style2) ? [...style2].reduce(
    (acc, item) => ({ ...acc, ...getStyleObject(item, theme) }),
    {}
  ) : typeof style2 == "function" ? style2(theme) : style2 ?? {};
}
function transformModKey(key) {
  return key.startsWith("data-") ? key : `data-${key}`;
}
function getMod(props) {
  return Object.keys(props).reduce((acc, key) => {
    const value = props[key];
    return value === void 0 || value === "" || value === !1 || value === null || (acc[transformModKey(key)] = props[key]), acc;
  }, {});
}
function getBoxMod(mod) {
  return mod ? typeof mod == "string" ? { [transformModKey(mod)]: !0 } : Array.isArray(mod) ? [...mod].reduce(
    (acc, value) => ({ ...acc, ...getBoxMod(value) }),
    {}
  ) : getMod(mod) : null;
}
function mergeStyles(styles, theme) {
  return Array.isArray(styles) ? [...styles].reduce(
    (acc, item) => ({ ...acc, ...mergeStyles(item, theme) }),
    {}
  ) : typeof styles == "function" ? styles(theme) : styles ?? {};
}
function getBoxStyle({
  theme,
  style: style2,
  vars,
  styleProps
}) {
  const _style = mergeStyles(style2, theme), _vars = mergeStyles(vars, theme);
  return { ..._style, ..._vars, ...styleProps };
}
const _Box = forwardRef(
  ({
    component,
    style: style2,
    __vars,
    className,
    variant,
    mod,
    size: size2,
    hiddenFrom,
    visibleFrom,
    lightHidden,
    darkHidden,
    renderRoot,
    __size,
    ...others
  }, ref) => {
    const theme = useMantineTheme(), Element2 = component || "div", { styleProps, rest } = extractStyleProps(others), transformedSx = useMantineSxTransform()?.()?.(styleProps.sx), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
      styleProps,
      theme,
      data: STYlE_PROPS_DATA
    }), props = {
      ref,
      style: getBoxStyle({
        theme,
        style: style2,
        vars: __vars,
        styleProps: parsedStyleProps.inlineStyles
      }),
      className: clsx(className, transformedSx, {
        [responsiveClassName]: parsedStyleProps.hasResponsiveStyles,
        "mantine-light-hidden": lightHidden,
        "mantine-dark-hidden": darkHidden,
        [`mantine-hidden-from-${hiddenFrom}`]: hiddenFrom,
        [`mantine-visible-from-${visibleFrom}`]: visibleFrom
      }),
      "data-variant": variant,
      "data-size": isNumberLike(size2) ? void 0 : size2 || void 0,
      size: __size,
      ...getBoxMod(mod),
      ...rest
    };
    return /* @__PURE__ */ jsxs(Fragment$1, { children: [
      parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
        InlineStyles,
        {
          selector: `.${responsiveClassName}`,
          styles: parsedStyleProps.styles,
          media: parsedStyleProps.media
        }
      ),
      typeof renderRoot == "function" ? renderRoot(props) : /* @__PURE__ */ jsx(Element2, { ...props })
    ] });
  }
);
_Box.displayName = "@mantine/core/Box";
const Box = _Box;
function identity$3(value) {
  return value;
}
function getWithProps(Component2) {
  const _Component = Component2;
  return (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(_Component, { ...fixedProps, ...props, ref }));
    return Extended.extend = _Component.extend, Extended.displayName = `WithProps(${_Component.displayName})`, Extended;
  };
}
function factory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.extend = identity$3, Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2;
}
function polymorphicFactory(ui) {
  const Component2 = forwardRef(ui);
  return Component2.withProps = (fixedProps) => {
    const Extended = forwardRef((props, ref) => /* @__PURE__ */ jsx(Component2, { ...fixedProps, ...props, ref }));
    return Extended.extend = Component2.extend, Extended.displayName = `WithProps(${Component2.displayName})`, Extended;
  }, Component2.extend = identity$3, Component2;
}
const DirectionContext = createContext({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function useDirection() {
  return useContext(DirectionContext);
}
function getAutoHeightDuration(height) {
  if (!height || typeof height == "string")
    return 0;
  const constant2 = height / 36;
  return Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10);
}
function getElementHeight(el) {
  return el?.current ? el.current.scrollHeight : "auto";
}
const raf = typeof window < "u" && window.requestAnimationFrame, collapsedHeight = 0, getCollapsedStyles = (keepMounted) => ({
  height: 0,
  overflow: "hidden",
  ...keepMounted ? {} : { display: "none" }
});
function useCollapse({
  transitionDuration,
  transitionTimingFunction = "ease",
  onTransitionEnd = () => {
  },
  opened,
  keepMounted = !1
}) {
  const el = useRef(null), collapsedStyles = getCollapsedStyles(keepMounted), [styles, setStylesRaw] = useState(opened ? {} : collapsedStyles), setStyles = (newStyles) => {
    flushSync(() => setStylesRaw(newStyles));
  }, mergeStyles2 = (newStyles) => {
    setStyles((oldStyles) => ({ ...oldStyles, ...newStyles }));
  };
  function getTransitionStyles2(height) {
    const _duration = transitionDuration || getAutoHeightDuration(height);
    return {
      transition: `height ${_duration}ms ${transitionTimingFunction}, opacity ${_duration}ms ${transitionTimingFunction}`
    };
  }
  useDidUpdate(() => {
    typeof raf == "function" && raf(opened ? () => {
      mergeStyles2({ willChange: "height", display: "block", overflow: "hidden" }), raf(() => {
        const height = getElementHeight(el);
        mergeStyles2({ ...getTransitionStyles2(height), height });
      });
    } : () => {
      const height = getElementHeight(el);
      mergeStyles2({ ...getTransitionStyles2(height), willChange: "height", height }), raf(() => mergeStyles2({ height: collapsedHeight, overflow: "hidden" }));
    });
  }, [opened]);
  const handleTransitionEnd = (e2) => {
    if (!(e2.target !== el.current || e2.propertyName !== "height"))
      if (opened) {
        const height = getElementHeight(el);
        height === styles.height ? setStyles({}) : mergeStyles2({ height }), onTransitionEnd();
      } else styles.height === collapsedHeight && (setStyles(collapsedStyles), onTransitionEnd());
  };
  function getCollapseProps({ style: style2 = {}, refKey = "ref", ...rest } = {}) {
    const theirRef = rest[refKey], props = {
      "aria-hidden": !opened,
      ...rest,
      [refKey]: mergeRefs(el, theirRef),
      onTransitionEnd: handleTransitionEnd,
      style: { boxSizing: "border-box", ...style2, ...styles }
    };
    return React__default.version.startsWith("18") ? opened || (props.inert = "") : props.inert = !opened, props;
  }
  return getCollapseProps;
}
const defaultProps$S = {
  transitionDuration: 200,
  transitionTimingFunction: "ease",
  animateOpacity: !0
}, Collapse = factory((props, ref) => {
  const {
    children: children2,
    in: opened,
    transitionDuration,
    transitionTimingFunction,
    style: style2,
    onTransitionEnd,
    animateOpacity,
    keepMounted,
    ...others
  } = useProps("Collapse", defaultProps$S, props), theme = useMantineTheme(), shouldReduceMotion = useReducedMotion$1(), duration2 = (theme.respectReducedMotion ? shouldReduceMotion : !1) ? 0 : transitionDuration, getCollapseProps = useCollapse({
    opened,
    transitionDuration: duration2,
    transitionTimingFunction,
    onTransitionEnd,
    keepMounted
  });
  return duration2 === 0 ? opened ? /* @__PURE__ */ jsx(Box, { ...others, children: children2 }) : null : /* @__PURE__ */ jsx(
    Box,
    {
      ...getCollapseProps({
        style: {
          opacity: opened || !animateOpacity ? 1 : 0,
          transition: animateOpacity ? `opacity ${duration2}ms ${transitionTimingFunction}` : "none",
          ...getStyleObject(style2, theme)
        },
        ref,
        ...others
      }),
      children: children2
    }
  );
});
Collapse.displayName = "@mantine/core/Collapse";
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(node) {
  return isNode$1(node) ? (node.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode$1(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode$1(value) {
  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;
}
function isElement(value) {
  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;
}
function isHTMLElement$1(value) {
  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;
}
function isShadowRoot(value) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector2) => {
    try {
      return element.matches(selector2);
    } catch {
      return !1;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"], willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"], containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css = isElement(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : !1) || (css.containerType ? css.containerType !== "normal" : !1) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : !1) || !webkit && (css.filter ? css.filter !== "none" : !1) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html")
    return node;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement$1(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node), isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win2 = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win2);
    return list2.concat(win2, win2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win2) {
  return win2.parent && Object.getPrototypeOf(win2.parent) ? win2.frameElement : null;
}
const sides = ["top", "right", "bottom", "left"], alignments = ["start", "end"], placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []), min$1 = Math.min, max$1 = Math.max, round = Math.round, floor = Math.floor, createCoords = (v) => ({
  x: v,
  y: v
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$3(start2, value, end) {
  return max$1(start2, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rlPlacement : lrPlacement : isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list2 = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list2 = list2.map((side) => side + "-" + alignment), flipAlignment && (list2 = list2.concat(list2.map(getOppositeAlignmentPlacement)))), list2;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  return uaData != null && uaData.platform ? uaData.platform : navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {
    let {
      brand,
      version: version2
    } = _ref;
    return brand + "/" + version2;
  }).join(" ") : navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
const FOCUSABLE_ATTRIBUTE$1 = "data-floating-ui-focusable", TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  for (; ((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null; ) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child)
    return !1;
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child))
    return !0;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    for (; next; ) {
      if (parent === next)
        return !0;
      next = next.parentNode || next.host;
    }
  }
  return !1;
}
function getTarget(event) {
  return "composedPath" in event ? event.composedPath()[0] : event.target;
}
function isEventTargetWithin(event, node) {
  if (node == null)
    return !1;
  if ("composedPath" in event)
    return event.composedPath().includes(node);
  const e2 = event;
  return e2.target != null && node.contains(e2.target);
}
function isRootElement(element) {
  return element.matches("html,body");
}
function getDocument(node) {
  return node?.ownerDocument || document;
}
function isTypeableElement(element) {
  return isHTMLElement$1(element) && element.matches(TYPEABLE_SELECTOR);
}
function matchesFocusVisible(element) {
  if (!element || isJSDOM()) return !0;
  try {
    return element.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function getFloatingFocusElement(floatingElement) {
  return floatingElement ? floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE$1) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE$1 + "]") || floatingElement : null;
}
function getNodeChildren(nodes, id2, onlyOpenChildren) {
  return onlyOpenChildren === void 0 && (onlyOpenChildren = !0), nodes.filter((node) => {
    var _node$context;
    return node.parentId === id2 && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));
  }).flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function isReactEvent(event) {
  return "nativeEvent" in event;
}
function isMouseLikePointerType(pointerType, strict) {
  const values2 = ["mouse", "pen"];
  return values2.push("", void 0), values2.includes(pointerType);
}
var isClient$1 = typeof document < "u", noop$4 = function() {
}, index$3 = isClient$1 ? useLayoutEffect$1 : noop$4;
const SafeReact$1 = {
  ...React
};
function useLatestRef$1(value) {
  const ref = React.useRef(value);
  return index$3(() => {
    ref.current = value;
  }), ref;
}
const useInsertionEffect = SafeReact$1.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
  });
  return useSafeInsertionEffect(() => {
    ref.current = callback;
  }), React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2], {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x: x2,
      y: y2
    }, axis = getAlignmentAxis(placement), length = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1, minPadding = min$1(paddingObject[minProp], largestPossiblePadding), maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding), min$1$1 = minPadding, max2 = clientSize - arrowDimensions[length] - maxPadding, center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference, offset2 = clamp$3(min$1$1, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  return (alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement)).filter((placement) => alignment ? getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : !1) : !0);
}
const autoPlacement$1 = function(options) {
  return options === void 0 && (options = {}), {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state, {
        crossAxis = !1,
        alignment,
        allowedPlacements = placements,
        autoAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state), placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements, overflow = await detectOverflow(state, detectOverflowOptions), currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0, currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null)
        return {};
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement)
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]], allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }], nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement)
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a2, b) => a2[1] - b[1]), resetPlacement = ((_placementsThatFitOnE = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0))[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      return resetPlacement !== placement ? {
        data: {
          index: currentIndex + 1,
          overflows: allOverflows
        },
        reset: {
          placement: resetPlacement
        }
      } : {};
    }
  };
}, flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements2 = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements2[nextIndex];
        if (nextPlacement && (!(checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : !0)))
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state, {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          }), offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: !0
          }), offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min$1(...rects.map((rect) => rect.left)), minY = min$1(...rects.map((rect) => rect.top)), maxX = max$1(...rects.map((rect) => rect.right)), maxY = max$1(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a2, b) => a2.y - b.y), groups = [];
  let prevRect = null;
  for (let i2 = 0; i2 < sortedRects.length; i2++) {
    const rect = sortedRects[i2];
    !prevRect || rect.y - prevRect.y > prevRect.height / 2 ? groups.push([rect]) : groups[groups.length - 1].push(rect), prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
const inline$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state, {
        padding = 2,
        x: x2,
        y: y2
      } = evaluate(options, state), nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []), clientRects = getRectsByLine(nativeClientRects), fallback = rectToClientRect(getBoundingRect(nativeClientRects)), paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null)
          return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0], lastRect = clientRects[clientRects.length - 1], isTop = getSide(placement) === "top", top2 = firstRect.top, bottom2 = lastRect.bottom, left2 = isTop ? firstRect.left : lastRect.left, right2 = isTop ? firstRect.right : lastRect.right, width2 = right2 - left2, height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide(placement) === "left", maxRight = max$1(...clientRects.map((rect) => rect.right)), minLeft = min$1(...clientRects.map((rect) => rect.left)), measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight), top = measureRects[0].top, bottom = measureRects[measureRects.length - 1].bottom, left = minLeft, right = maxRight, width = right - left, height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      return rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height ? {
        reset: {
          rects: resetRects
        }
      } : {};
    }
  };
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = originSides.has(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, overflow = await detectOverflow(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$3(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$3(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
}, limitShift$2 = function(options) {
  return options === void 0 && (options = {}), {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state, {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, crossAxis = getSideAxis(placement), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state), computedOffset = typeof rawOffset == "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width", limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis, limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        mainAxisCoord < limitMin ? mainAxisCoord = limitMin : mainAxisCoord > limitMax && (mainAxisCoord = limitMax);
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height", isOriginSide = originSides.has(getSide(placement)), limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide && ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0) + (isOriginSide ? 0 : computedOffset.crossAxis), limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        crossAxisCoord < limitMin ? crossAxisCoord = limitMin : crossAxisCoord > limitMax && (crossAxisCoord = limitMax);
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
}, size$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state, {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state), overflow = await detectOverflow(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === "y", {
        width,
        height
      } = rects.floating;
      let heightSide, widthSide;
      side === "top" || side === "bottom" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right") : (widthSide = side, heightSide = alignment === "end" ? "top" : "bottom");
      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x && (availableWidth = maximumClippingWidth), (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y && (availableHeight = maximumClippingHeight), noShift && !alignment) {
        const xMin = max$1(overflow.left, 0), xMax = max$1(overflow.right, 0), yMin = max$1(overflow.top, 0), yMax = max$1(overflow.bottom, 0);
        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$1(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$1(overflow.top, overflow.bottom));
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      return width !== nextDimensions.width || height !== nextDimensions.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$2(element);
  let width = parseFloat(css.width) || 0, height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width, y2 = ($ ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win2 = getWindow(element);
  return !isWebKit() || !win2.visualViewport ? noOffsets : {
    x: win2.visualViewport.offsetLeft,
    y: win2.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale2 = getScale(offsetParent)) : scale2 = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x, y2 = (clientRect.top + visualOffsets.y) / scale2.y, width = clientRect.width / scale2.x, height = clientRect.height / scale2.y;
  if (domElement) {
    const win2 = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win2, currentIFrame = getFrameElement(currentWin);
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css = getComputedStyle$2(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect(), x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect), y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale2 = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement$1(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale2 = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element), scroll = getNodeScroll(element), body = element.ownerDocument.body, width = max$1(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth), height = max$1(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$2(body).direction === "rtl" && (x2 += max$1(html.clientWidth, body.clientWidth) - width), {
    width,
    height,
    x: x2,
    y: y2
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win2 = getWindow(element), html = getDocumentElement(element), visualViewport = win2.visualViewport;
  let width = html.clientWidth, height = html.clientHeight, x2 = 0, y2 = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument, body = doc.body, bodyStyles = getComputedStyle(body), bodyMarginInline = doc.compatMode === "CSS1Compat" && parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0, clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    clippingStableScrollbarWidth <= SCROLLBAR_MAX && (width -= clippingStableScrollbarWidth);
  } else windowScrollbarX <= SCROLLBAR_MAX && (width += windowScrollbarX);
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale2 = isHTMLElement$1(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale2.x, height = element.clientHeight * scale2.y, x2 = left * scale2.x, y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport")
    rect = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect = getDocumentRect(getDocumentElement(element));
  else if (isElement(clippingAncestor))
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$2(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache2.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max$1(rect.top, accRect.top), accRect.right = min$1(rect.right, accRect.right), accRect.bottom = min$1(rect.bottom, accRect.bottom), accRect.left = max$1(rect.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions$1(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && setLeftRTLScrollbarOffset();
  isFixed && !isOffsetParentAnElement && documentElement && setLeftRTLScrollbarOffset();
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0), x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x, y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed")
    return null;
  if (polyfill)
    return polyfill(element);
  let rawOffsetParent = element.offsetParent;
  return getDocumentElement(element) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body), rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win2 = getWindow(element);
  if (isTopLayer(element))
    return win2;
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win2 : offsetParent || getContainingBlock(element) || win2;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$2(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions: getDimensions$1,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect(), {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left + width)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max$1(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect()) && refresh(), isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo?.(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const offset$1 = offset$2, autoPlacement = autoPlacement$1, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, arrow$2 = arrow$3, inline$1 = inline$2, limitShift$1 = limitShift$2, computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document < "u", noop$3 = function() {
}, index$2 = isClient ? useLayoutEffect$1 : noop$3;
function deepEqual$2(a2, b) {
  if (a2 === b)
    return !0;
  if (typeof a2 != typeof b)
    return !1;
  if (typeof a2 == "function" && a2.toString() === b.toString())
    return !0;
  let length, i2, keys2;
  if (a2 && b && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      if (length = a2.length, length !== b.length) return !1;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual$2(a2[i2], b[i2]))
          return !1;
      return !0;
    }
    if (keys2 = Object.keys(a2), length = keys2.length, length !== Object.keys(b).length)
      return !1;
    for (i2 = length; i2-- !== 0; )
      if (!{}.hasOwnProperty.call(b, keys2[i2]))
        return !1;
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (!(key === "_owner" && a2.$$typeof) && !deepEqual$2(a2[key], b[key]))
        return !1;
    }
    return !0;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  return index$2(() => {
    ref.current = value;
  }), ref;
}
function useFloating$1(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = !0,
    whileElementsMounted,
    open
  } = options, [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  deepEqual$2(latestMiddleware, middleware) || setLatestMiddleware(middleware);
  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node) => {
    node !== referenceRef.current && (referenceRef.current = node, _setReference(node));
  }, []), setFloating = React.useCallback((node) => {
    node !== floatingRef.current && (floatingRef.current = node, _setFloating(node));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef(whileElementsMounted), platformRef = useLatestRef(platform2), openRef = useLatestRef(open), update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config2.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== !1
      };
      isMountedRef.current && !deepEqual$2(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$2(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({
      ...data2,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React.useRef(!1);
  index$2(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index$2(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x2 = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);
    return transform2 ? {
      ...initialStyles,
      transform: "translate(" + x2 + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options == "function" ? options(state) : options;
      return element && isRef(element) ? element.current != null ? arrow$2({
        element: element.current,
        padding
      }).fn(state) : {} : element ? arrow$2({
        element,
        padding
      }).fn(state) : {};
    }
  };
}, offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
}), hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
}), inline = (options, deps) => ({
  ...inline$1(options),
  options: [options, deps]
}), arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
function useMergeRefs(refs) {
  const cleanupRef = React.useRef(void 0), refEffect = React.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref != null) {
        if (typeof ref == "function") {
          const refCallback = ref, refCleanup = refCallback(instance);
          return typeof refCleanup == "function" ? refCleanup : () => {
            refCallback(null);
          };
        }
        return ref.current = instance, () => {
          ref.current = null;
        };
      }
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup?.());
    };
  }, refs);
  return React.useMemo(() => refs.every((ref) => ref == null) ? null : (value) => {
    cleanupRef.current && (cleanupRef.current(), cleanupRef.current = void 0), value != null && (cleanupRef.current = refEffect(value));
  }, refs);
}
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable", ACTIVE_KEY = "active", SELECTED_KEY = "selected", SafeReact = {
  ...React
};
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index$3(() => {
    id2 == null && setId(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), id2;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      map.has(event) || map.set(event, /* @__PURE__ */ new Set()), map.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function clearTimeoutIfSet(timeoutRef) {
  timeoutRef.current !== -1 && (clearTimeout(timeoutRef.current), timeoutRef.current = -1);
}
const safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType))
    return 0;
  if (typeof value == "number")
    return value;
  if (typeof value == "function") {
    const result = value();
    return typeof result == "number" ? result : result?.[prop];
  }
  return value?.[prop];
}
function getRestMs(value) {
  return typeof value == "function" ? value() : value;
}
function useHover(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context, {
    enabled = !0,
    delay: delay2 = 0,
    handleClose = null,
    mouseOnly = !1,
    restMs = 0,
    move = !0
  } = props, tree = useFloatingTree(), parentId = useFloatingParentNodeId(), handleCloseRef = useLatestRef$1(handleClose), delayRef = useLatestRef$1(delay2), openRef = useLatestRef$1(open), restMsRef = useLatestRef$1(restMs), pointerTypeRef = React.useRef(), timeoutRef = React.useRef(-1), handlerRef = React.useRef(), restTimeoutRef = React.useRef(-1), blockMouseMoveRef = React.useRef(!0), performedPointerEventsMutationRef = React.useRef(!1), unbindMouseMoveRef = React.useRef(() => {
  }), restTimeoutPendingRef = React.useRef(!1), isHoverOpen = useEffectEvent(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return type?.includes("mouse") && type !== "mousedown";
  });
  React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        open: open2
      } = _ref;
      open2 || (clearTimeoutIfSet(timeoutRef), clearTimeoutIfSet(restTimeoutRef), blockMouseMoveRef.current = !0, restTimeoutPendingRef.current = !1);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled, events]), React.useEffect(() => {
    if (!enabled || !handleCloseRef.current || !open) return;
    function onLeave(event) {
      isHoverOpen() && onOpenChange(!1, event, "hover");
    }
    const html = getDocument(elements.floating).documentElement;
    return html.addEventListener("mouseleave", onLeave), () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React.useCallback(function(event, runElseBranch, reason) {
    runElseBranch === void 0 && (runElseBranch = !0), reason === void 0 && (reason = "hover");
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    closeDelay && !handlerRef.current ? (clearTimeoutIfSet(timeoutRef), timeoutRef.current = window.setTimeout(() => onOpenChange(!1, event, reason), closeDelay)) : runElseBranch && (clearTimeoutIfSet(timeoutRef), onOpenChange(!1, event, reason));
  }, [delayRef, onOpenChange]), cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current(), handlerRef.current = void 0;
  }), clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "", body.removeAttribute(safePolygonIdentifier), performedPointerEventsMutationRef.current = !1;
    }
  }), isClickLikeOpenEvent = useEffectEvent(() => dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : !1);
  React.useEffect(() => {
    if (!enabled) return;
    function onReferenceMouseEnter(event) {
      if (clearTimeoutIfSet(timeoutRef), blockMouseMoveRef.current = !1, mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open"))
        return;
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      openDelay ? timeoutRef.current = window.setTimeout(() => {
        openRef.current || onOpenChange(!0, event, "hover");
      }, openDelay) : open || onOpenChange(!0, event, "hover");
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      if (clearTimeoutIfSet(restTimeoutRef), restTimeoutPendingRef.current = !1, handleCloseRef.current && dataRef.current.floatingContext) {
        open || clearTimeoutIfSet(timeoutRef), handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event, !0, "safe-polygon");
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler), unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      (pointerTypeRef.current !== "touch" || !contains(elements.floating, event.relatedTarget)) && closeWithDelay(event);
    }
    function onScrollMouseLeave(event) {
      isClickLikeOpenEvent() || dataRef.current.floatingContext && (handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents(), cleanupMouseMoveHandler(), isClickLikeOpenEvent() || closeWithDelay(event);
        }
      })(event));
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      isClickLikeOpenEvent() || closeWithDelay(event, !1);
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference, floating = elements.floating;
      return open && reference2.addEventListener("mouseleave", onScrollMouseLeave), move && reference2.addEventListener("mousemove", onReferenceMouseEnter, {
        once: !0
      }), reference2.addEventListener("mouseenter", onReferenceMouseEnter), reference2.addEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.addEventListener("mouseleave", onScrollMouseLeave), floating.addEventListener("mouseenter", onFloatingMouseEnter), floating.addEventListener("mouseleave", onFloatingMouseLeave)), () => {
        open && reference2.removeEventListener("mouseleave", onScrollMouseLeave), move && reference2.removeEventListener("mousemove", onReferenceMouseEnter), reference2.removeEventListener("mouseenter", onReferenceMouseEnter), reference2.removeEventListener("mouseleave", onReferenceMouseLeave), floating && (floating.removeEventListener("mouseleave", onScrollMouseLeave), floating.removeEventListener("mouseenter", onFloatingMouseEnter), floating.removeEventListener("mouseleave", onFloatingMouseLeave));
      };
    }
  }, [elements, enabled, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]), index$3(() => {
    var _handleCloseRef$curre;
    if (enabled && open && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = !0;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference, parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        return parentFloating && (parentFloating.style.pointerEvents = ""), body.style.pointerEvents = "none", ref.style.pointerEvents = "auto", floatingEl.style.pointerEvents = "auto", () => {
          body.style.pointerEvents = "", ref.style.pointerEvents = "", floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]), index$3(() => {
    open || (pointerTypeRef.current = void 0, restTimeoutPendingRef.current = !1, cleanupMouseMoveHandler(), clearPointerEvents());
  }, [open, cleanupMouseMoveHandler, clearPointerEvents]), React.useEffect(() => () => {
    cleanupMouseMoveHandler(), clearTimeoutIfSet(timeoutRef), clearTimeoutIfSet(restTimeoutRef), clearPointerEvents();
  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          !blockMouseMoveRef.current && !openRef.current && onOpenChange(!0, nativeEvent, "hover");
        }
        mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || open || getRestMs(restMsRef.current) === 0 || restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2 || (clearTimeoutIfSet(restTimeoutRef), pointerTypeRef.current === "touch" ? handleMouseMove() : (restTimeoutPendingRef.current = !0, restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current))));
      }
    };
  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
const NOOP = () => {
}, FloatingDelayGroupContext = /* @__PURE__ */ React.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: !1
}), useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);
function FloatingDelayGroup(props) {
  const {
    children: children2,
    delay: delay2,
    timeoutMs = 0
  } = props, [state, setState] = React.useReducer((prev, next) => ({
    ...prev,
    ...next
  }), {
    delay: delay2,
    timeoutMs,
    initialDelay: delay2,
    currentId: null,
    isInstantPhase: !1
  }), initialCurrentIdRef = React.useRef(null), setCurrentId = React.useCallback((currentId) => {
    setState({
      currentId
    });
  }, []);
  return index$3(() => {
    state.currentId ? initialCurrentIdRef.current === null ? initialCurrentIdRef.current = state.currentId : state.isInstantPhase || setState({
      isInstantPhase: !0
    }) : (state.isInstantPhase && setState({
      isInstantPhase: !1
    }), initialCurrentIdRef.current = null);
  }, [state.currentId, state.isInstantPhase]), /* @__PURE__ */ jsx(FloatingDelayGroupContext.Provider, {
    value: React.useMemo(() => ({
      ...state,
      setState,
      setCurrentId
    }), [state, setCurrentId]),
    children: children2
  });
}
function useDelayGroup(context, options) {
  options === void 0 && (options = {});
  const {
    open,
    onOpenChange,
    floatingId
  } = context, {
    id: optionId,
    enabled = !0
  } = options, id2 = optionId ?? floatingId, groupContext = useDelayGroupContext(), {
    currentId,
    setCurrentId,
    initialDelay,
    setState,
    timeoutMs
  } = groupContext;
  return index$3(() => {
    enabled && currentId && (setState({
      delay: {
        open: 1,
        close: getDelay(initialDelay, "close")
      }
    }), currentId !== id2 && onOpenChange(!1));
  }, [enabled, id2, onOpenChange, setState, currentId, initialDelay]), index$3(() => {
    function unset() {
      onOpenChange(!1), setState({
        delay: initialDelay,
        currentId: null
      });
    }
    if (enabled && currentId && !open && currentId === id2) {
      if (timeoutMs) {
        const timeout2 = window.setTimeout(unset, timeoutMs);
        return () => {
          clearTimeout(timeout2);
        };
      }
      unset();
    }
  }, [enabled, open, setState, currentId, id2, onOpenChange, initialDelay, timeoutMs]), index$3(() => {
    enabled && (setCurrentId === NOOP || !open || setCurrentId(id2));
  }, [enabled, open, setCurrentId, id2]), groupContext;
}
const bubbleHandlerKeys = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, captureHandlerKeys = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, normalizeProp = (normalizable) => {
  var _normalizable$escapeK, _normalizable$outside;
  return {
    escapeKey: typeof normalizable == "boolean" ? normalizable : (_normalizable$escapeK = normalizable?.escapeKey) != null ? _normalizable$escapeK : !1,
    outsidePress: typeof normalizable == "boolean" ? normalizable : (_normalizable$outside = normalizable?.outsidePress) != null ? _normalizable$outside : !0
  };
};
function useDismiss(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    elements,
    dataRef
  } = context, {
    enabled = !0,
    escapeKey = !0,
    outsidePress: unstable_outsidePress = !0,
    outsidePressEvent = "pointerdown",
    referencePress = !1,
    referencePressEvent = "pointerdown",
    ancestorScroll = !1,
    bubbles,
    capture
  } = props, tree = useFloatingTree(), outsidePressFn = useEffectEvent(typeof unstable_outsidePress == "function" ? unstable_outsidePress : () => !1), outsidePress = typeof unstable_outsidePress == "function" ? outsidePressFn : unstable_outsidePress, endedOrStartedInsideRef = React.useRef(!1), {
    escapeKey: escapeKeyBubbles,
    outsidePress: outsidePressBubbles
  } = normalizeProp(bubbles), {
    escapeKey: escapeKeyCapture,
    outsidePress: outsidePressCapture
  } = normalizeProp(capture), isComposingRef = React.useRef(!1), closeOnEscapeKeyDown = useEffectEvent((event) => {
    var _dataRef$current$floa;
    if (!open || !enabled || !escapeKey || event.key !== "Escape" || isComposingRef.current)
      return;
    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId, children2 = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (!escapeKeyBubbles && (event.stopPropagation(), children2.length > 0)) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context;
        if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
  }), closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
    var _getTarget2;
    const callback = () => {
      var _getTarget;
      closeOnEscapeKeyDown(event), (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
    };
    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
  }), closeOnPressOutside = useEffectEvent((event) => {
    var _dataRef$current$floa2;
    const insideReactTree = dataRef.current.insideReactTree;
    dataRef.current.insideReactTree = !1;
    const endedOrStartedInside = endedOrStartedInsideRef.current;
    if (endedOrStartedInsideRef.current = !1, outsidePressEvent === "click" && endedOrStartedInside || insideReactTree || typeof outsidePress == "function" && !outsidePress(event))
      return;
    const target = getTarget(event), inertSelector = "[" + createAttribute("inert") + "]", markers = getDocument(elements.floating).querySelectorAll(inertSelector);
    let targetRootAncestor = isElement(target) ? target : null;
    for (; targetRootAncestor && !isLastTraversableNode(targetRootAncestor); ) {
      const nextParent = getParentNode(targetRootAncestor);
      if (isLastTraversableNode(nextParent) || !isElement(nextParent))
        break;
      targetRootAncestor = nextParent;
    }
    if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(markers).every((marker) => !contains(targetRootAncestor, marker)))
      return;
    if (isHTMLElement$1(target) && floating) {
      const lastTraversableNode = isLastTraversableNode(target), style2 = getComputedStyle$2(target), scrollRe = /auto|scroll/, isScrollableX = lastTraversableNode || scrollRe.test(style2.overflowX), isScrollableY = lastTraversableNode || scrollRe.test(style2.overflowY), canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth, canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight, isRTL2 = style2.direction === "rtl", pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth), pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
      if (pressedVerticalScrollbar || pressedHorizontalScrollbar)
        return;
    }
    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId, targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node) => {
      var _node$context;
      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);
    });
    if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren)
      return;
    const children2 = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
    if (children2.length > 0) {
      let shouldDismiss = !0;
      if (children2.forEach((child) => {
        var _child$context2;
        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
          shouldDismiss = !1;
          return;
        }
      }), !shouldDismiss)
        return;
    }
    onOpenChange(!1, event, "outside-press");
  }), closeOnPressOutsideCapture = useEffectEvent((event) => {
    var _getTarget4;
    const callback = () => {
      var _getTarget3;
      closeOnPressOutside(event), (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
    };
    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
  });
  React.useEffect(() => {
    if (!open || !enabled)
      return;
    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles, dataRef.current.__outsidePressBubbles = outsidePressBubbles;
    let compositionTimeout = -1;
    function onScroll(event) {
      onOpenChange(!1, event, "ancestor-scroll");
    }
    function handleCompositionStart() {
      window.clearTimeout(compositionTimeout), isComposingRef.current = !0;
    }
    function handleCompositionEnd() {
      compositionTimeout = window.setTimeout(
        () => {
          isComposingRef.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        isWebKit() ? 5 : 0
      );
    }
    const doc = getDocument(elements.floating);
    escapeKey && (doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.addEventListener("compositionstart", handleCompositionStart), doc.addEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
    let ancestors = [];
    return ancestorScroll && (isElement(elements.domReference) && (ancestors = getOverflowAncestors(elements.domReference)), isElement(elements.floating) && (ancestors = ancestors.concat(getOverflowAncestors(elements.floating))), !isElement(elements.reference) && elements.reference && elements.reference.contextElement && (ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement)))), ancestors = ancestors.filter((ancestor) => {
      var _doc$defaultView;
      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
    }), ancestors.forEach((ancestor) => {
      ancestor.addEventListener("scroll", onScroll, {
        passive: !0
      });
    }), () => {
      escapeKey && (doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture), doc.removeEventListener("compositionstart", handleCompositionStart), doc.removeEventListener("compositionend", handleCompositionEnd)), outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture), ancestors.forEach((ancestor) => {
        ancestor.removeEventListener("scroll", onScroll);
      }), window.clearTimeout(compositionTimeout);
    };
  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]), React.useEffect(() => {
    dataRef.current.insideReactTree = !1;
  }, [dataRef, outsidePress, outsidePressEvent]);
  const reference = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    ...referencePress && {
      [bubbleHandlerKeys[referencePressEvent]]: (event) => {
        onOpenChange(!1, event.nativeEvent, "reference-press");
      },
      ...referencePressEvent !== "click" && {
        onClick(event) {
          onOpenChange(!1, event.nativeEvent, "reference-press");
        }
      }
    }
  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]), floating = React.useMemo(() => ({
    onKeyDown: closeOnEscapeKeyDown,
    onMouseDown() {
      endedOrStartedInsideRef.current = !0;
    },
    onMouseUp() {
      endedOrStartedInsideRef.current = !0;
    },
    [captureHandlerKeys[outsidePressEvent]]: () => {
      dataRef.current.insideReactTree = !0;
    }
  }), [closeOnEscapeKeyDown, outsidePressEvent, dataRef]);
  return React.useMemo(() => enabled ? {
    reference,
    floating
  } : {}, [enabled, reference, floating]);
}
function useFloatingRootContext(options) {
  const {
    open = !1,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createEventEmitter()), nested = useFloatingParentNodeId() != null, [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0, events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    }), onOpenChangeProp?.(open2, event, reason);
  }), refs = React.useMemo(() => ({
    setPositionReference
  }), []), elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    nodeId
  } = options, internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = computedElements?.domReference || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();
  index$3(() => {
    domReference && (domReferenceRef.current = domReference);
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  }), setPositionReference = React.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference), position.refs.setReference(computedPositionReference);
  }, [position.refs]), setReference = React.useCallback((node) => {
    (isElement(node) || node === null) && (domReferenceRef.current = node, setDomReference(node)), (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) && position.refs.setReference(node);
  }, [position.refs]), refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]), context = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  return index$3(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree?.nodesRef.current.find((node2) => node2.id === nodeId);
    node && (node.context = context);
  }), React.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
function isMacSafari() {
  return isMac() && isSafari();
}
function useFocus(context, props) {
  props === void 0 && (props = {});
  const {
    open,
    onOpenChange,
    events,
    dataRef,
    elements
  } = context, {
    enabled = !0,
    visibleOnly = !0
  } = props, blockFocusRef = React.useRef(!1), timeoutRef = React.useRef(-1), keyboardModalityRef = React.useRef(!0);
  React.useEffect(() => {
    if (!enabled) return;
    const win2 = getWindow(elements.domReference);
    function onBlur() {
      !open && isHTMLElement$1(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference)) && (blockFocusRef.current = !0);
    }
    function onKeyDown() {
      keyboardModalityRef.current = !0;
    }
    function onPointerDown2() {
      keyboardModalityRef.current = !1;
    }
    return win2.addEventListener("blur", onBlur), isMacSafari() && (win2.addEventListener("keydown", onKeyDown, !0), win2.addEventListener("pointerdown", onPointerDown2, !0)), () => {
      win2.removeEventListener("blur", onBlur), isMacSafari() && (win2.removeEventListener("keydown", onKeyDown, !0), win2.removeEventListener("pointerdown", onPointerDown2, !0));
    };
  }, [elements.domReference, open, enabled]), React.useEffect(() => {
    if (!enabled) return;
    function onOpenChange2(_ref) {
      let {
        reason
      } = _ref;
      (reason === "reference-press" || reason === "escape-key") && (blockFocusRef.current = !0);
    }
    return events.on("openchange", onOpenChange2), () => {
      events.off("openchange", onOpenChange2);
    };
  }, [events, enabled]), React.useEffect(() => () => {
    clearTimeoutIfSet(timeoutRef);
  }, []);
  const reference = React.useMemo(() => ({
    onMouseLeave() {
      blockFocusRef.current = !1;
    },
    onFocus(event) {
      if (blockFocusRef.current) return;
      const target = getTarget(event.nativeEvent);
      if (visibleOnly && isElement(target)) {
        if (isMacSafari() && !event.relatedTarget) {
          if (!keyboardModalityRef.current && !isTypeableElement(target))
            return;
        } else if (!matchesFocusVisible(target))
          return;
      }
      onOpenChange(!0, event.nativeEvent, "focus");
    },
    onBlur(event) {
      blockFocusRef.current = !1;
      const relatedTarget = event.relatedTarget, nativeEvent = event.nativeEvent, movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
      timeoutRef.current = window.setTimeout(() => {
        var _dataRef$current$floa;
        const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
        !relatedTarget && activeEl === elements.domReference || contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard || onOpenChange(!1, nativeEvent, "focus");
      });
    }
  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
  return React.useMemo(() => enabled ? {
    reference
  } : {}, [enabled, reference]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map(), isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      return typeof propsOrGetProps == "function" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {
      let [key, value] = _ref;
      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)))
        if (key.indexOf("on") === 0) {
          if (map.has(key) || map.set(key, []), typeof value == "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value), acc[key] = function() {
              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else
          acc[key] = value;
    }), acc), {})
  };
}
function useInteractions(propsList) {
  propsList === void 0 && (propsList = []);
  const referenceDeps = propsList.map((key) => key?.reference), floatingDeps = propsList.map((key) => key?.floating), itemDeps = propsList.map((key) => key?.item), getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  ), getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  ), getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
const componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function useRole(context, props) {
  var _elements$domReferenc, _componentRoleToAriaR;
  props === void 0 && (props = {});
  const {
    open,
    elements,
    floatingId: defaultFloatingId
  } = context, {
    enabled = !0,
    role = "dialog"
  } = props, defaultReferenceId = useId(), referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId, floatingId = React.useMemo(() => {
    var _getFloatingFocusElem;
    return ((_getFloatingFocusElem = getFloatingFocusElement(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
  }, [elements.floating, defaultFloatingId]), ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role, isNested = useFloatingParentNodeId() != null, reference = React.useMemo(() => ariaRole === "tooltip" || role === "label" ? {
    ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open ? floatingId : void 0
  } : {
    "aria-expanded": open ? "true" : "false",
    "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
    "aria-controls": open ? floatingId : void 0,
    ...ariaRole === "listbox" && {
      role: "combobox"
    },
    ...ariaRole === "menu" && {
      id: referenceId
    },
    ...ariaRole === "menu" && isNested && {
      role: "menuitem"
    },
    ...role === "select" && {
      "aria-autocomplete": "none"
    },
    ...role === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [ariaRole, floatingId, isNested, open, referenceId, role]), floating = React.useMemo(() => {
    const floatingProps = {
      id: floatingId,
      ...ariaRole && {
        role: ariaRole
      }
    };
    return ariaRole === "tooltip" || role === "label" ? floatingProps : {
      ...floatingProps,
      ...ariaRole === "menu" && {
        "aria-labelledby": referenceId
      }
    };
  }, [ariaRole, floatingId, referenceId, role]), item = React.useCallback((_ref) => {
    let {
      active,
      selected: selected2
    } = _ref;
    const commonProps = {
      role: "option",
      ...active && {
        id: floatingId + "-fui-option"
      }
    };
    switch (role) {
      case "select":
      case "combobox":
        return {
          ...commonProps,
          "aria-selected": selected2
        };
    }
    return {};
  }, [floatingId, role]);
  return React.useMemo(() => enabled ? {
    reference,
    floating,
    item
  } : {}, [enabled, reference, floating, item]);
}
const [ScrollAreaProvider, useScrollAreaContext] = createSafeContext(
  "ScrollArea.Root component was not found in tree"
);
function useResizeObserver$1(element, onResize) {
  const handleResize = useCallbackRef(onResize);
  useIsomorphicEffect(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF), rAF = window.requestAnimationFrame(handleResize);
      });
      return resizeObserver.observe(element), () => {
        window.cancelAnimationFrame(rAF), resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
const Corner = forwardRef((props, ref) => {
  const { style: style2, ...others } = props, ctx = useScrollAreaContext(), [width, setWidth] = useState(0), [height, setHeight] = useState(0), hasSize = !!(width && height);
  return useResizeObserver$1(ctx.scrollbarX, () => {
    const h = ctx.scrollbarX?.offsetHeight || 0;
    ctx.onCornerHeightChange(h), setHeight(h);
  }), useResizeObserver$1(ctx.scrollbarY, () => {
    const w = ctx.scrollbarY?.offsetWidth || 0;
    ctx.onCornerWidthChange(w), setWidth(w);
  }), hasSize ? /* @__PURE__ */ jsx("div", { ...others, ref, style: { ...style2, width, height } }) : null;
}), ScrollAreaCorner = forwardRef((props, ref) => {
  const ctx = useScrollAreaContext(), hasBothScrollbarsVisible = !!(ctx.scrollbarX && ctx.scrollbarY);
  return ctx.type !== "scroll" && hasBothScrollbarsVisible ? /* @__PURE__ */ jsx(Corner, { ...props, ref }) : null;
}), defaultProps$R = {
  scrollHideDelay: 1e3,
  type: "hover"
}, ScrollAreaRoot = forwardRef((_props, ref) => {
  const { type, scrollHideDelay, scrollbars, getStyles: getStyles2, ...others } = useProps(
    "ScrollAreaRoot",
    defaultProps$R,
    _props
  ), [scrollArea, setScrollArea] = useState(null), [viewport, setViewport] = useState(null), [content, setContent] = useState(null), [scrollbarX, setScrollbarX] = useState(null), [scrollbarY, setScrollbarY] = useState(null), [cornerWidth, setCornerWidth] = useState(0), [cornerHeight, setCornerHeight] = useState(0), [scrollbarXEnabled, setScrollbarXEnabled] = useState(!1), [scrollbarYEnabled, setScrollbarYEnabled] = useState(!1), rootRef = useMergedRef(ref, (node) => setScrollArea(node));
  return /* @__PURE__ */ jsx(
    ScrollAreaProvider,
    {
      value: {
        type,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ...others,
          ref: rootRef,
          __vars: {
            "--sa-corner-width": scrollbars !== "xy" ? "0px" : `${cornerWidth}px`,
            "--sa-corner-height": scrollbars !== "xy" ? "0px" : `${cornerHeight}px`
          }
        }
      )
    }
  );
});
ScrollAreaRoot.displayName = "@mantine/core/ScrollAreaRoot";
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes2) {
  const ratio = getThumbRatio(sizes2.viewport, sizes2.content), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, thumbSize = (sizes2.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1])
      return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function clamp$2(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function getThumbOffsetFromScroll(scrollPos, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), scrollbarPadding = sizes2.scrollbar.paddingStart + sizes2.scrollbar.paddingEnd, scrollbar = sizes2.scrollbar.size - scrollbarPadding, maxScrollPos = sizes2.content - sizes2.viewport, maxThumbPos = scrollbar - thumbSizePx, scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0], scrollWithoutMomentum = clamp$2(scrollPos, scrollClampRange);
  return linearScale([0, maxScrollPos], [0, maxThumbPos])(scrollWithoutMomentum);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes2, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes2), thumbCenter = thumbSizePx / 2, offset2 = pointerOffset || thumbCenter, thumbOffsetFromEnd = thumbSizePx - offset2, minPointerPos = sizes2.scrollbar.paddingStart + offset2, maxPointerPos = sizes2.scrollbar.size - sizes2.scrollbar.paddingEnd - thumbOffsetFromEnd, maxScrollPos = sizes2.content - sizes2.viewport, scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  return linearScale([minPointerPos, maxPointerPos], scrollRange)(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = !0 } = {}) {
  return (event) => {
    originalEventHandler?.(event), (checkForDefaultPrevented === !1 || !event.defaultPrevented) && ourEventHandler?.(event);
  };
}
const [ScrollbarProvider, useScrollbarContext] = createSafeContext(
  "ScrollAreaScrollbar was not found in tree"
), Scrollbar = forwardRef((props, forwardedRef) => {
  const {
    sizes: sizes2,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props, context = useScrollAreaContext(), [scrollbar, setScrollbar] = useState(null), composeRefs2 = useMergedRef(forwardedRef, (node) => setScrollbar(node)), rectRef = useRef(null), prevWebkitUserSelectRef = useRef(""), { viewport } = context, maxScrollPos = sizes2.content - sizes2.viewport, handleWheelScroll = useCallbackRef(onWheelScroll), handleThumbPositionChange = useCallbackRef(onThumbPositionChange), handleResize = useDebouncedCallback$1(onResize, 10), handleDragScroll = (event) => {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left, y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  };
  return useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      scrollbar?.contains(element) && handleWheelScroll(event, maxScrollPos);
    };
    return document.addEventListener("wheel", handleWheel, { passive: !1 }), () => document.removeEventListener("wheel", handleWheel, { passive: !1 });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]), useEffect(handleThumbPositionChange, [sizes2, handleThumbPositionChange]), useResizeObserver$1(scrollbar, handleResize), useResizeObserver$1(context.content, handleResize), /* @__PURE__ */ jsx(
    ScrollbarProvider,
    {
      value: {
        scrollbar,
        hasThumb,
        onThumbChange: useCallbackRef(onThumbChange),
        onThumbPointerUp: useCallbackRef(onThumbPointerUp),
        onThumbPositionChange: handleThumbPositionChange,
        onThumbPointerDown: useCallbackRef(onThumbPointerDown)
      },
      children: /* @__PURE__ */ jsx(
        "div",
        {
          ...scrollbarProps,
          ref: composeRefs2,
          "data-mantine-scrollbar": !0,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            event.preventDefault(), event.button === 0 && (event.target.setPointerCapture(event.pointerId), rectRef.current = scrollbar.getBoundingClientRect(), prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", handleDragScroll(event));
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            element.hasPointerCapture(event.pointerId) && (event.preventDefault(), element.releasePointerCapture(event.pointerId));
          }),
          onLostPointerCapture: () => {
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current, rectRef.current = null;
          }
        }
      )
    }
  );
}), ScrollAreaScrollbarX = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style: style2, ...others } = props, ctx = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs2 = useMergedRef(forwardedRef, ref, ctx.onScrollbarXChange);
    return useEffect(() => {
      ref.current && setComputedStyle(getComputedStyle(ref.current));
    }, [ref]), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        "data-orientation": "horizontal",
        ...others,
        ref: composeRefs2,
        sizes: sizes2,
        style: {
          ...style2,
          "--sa-thumb-width": `${getThumbSize(sizes2)}px`
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
        onWheelScroll: (event, maxScrollPos) => {
          if (ctx.viewport) {
            const scrollPos = ctx.viewport.scrollLeft + event.deltaX;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && ctx.viewport && computedStyle && onSizesChange({
            content: ctx.viewport.scrollWidth,
            viewport: ctx.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarX.displayName = "@mantine/core/ScrollAreaScrollbarX";
const ScrollAreaScrollbarY = forwardRef(
  (props, forwardedRef) => {
    const { sizes: sizes2, onSizesChange, style: style2, ...others } = props, context = useScrollAreaContext(), [computedStyle, setComputedStyle] = useState(), ref = useRef(null), composeRefs2 = useMergedRef(forwardedRef, ref, context.onScrollbarYChange);
    return useEffect(() => {
      ref.current && setComputedStyle(window.getComputedStyle(ref.current));
    }, []), /* @__PURE__ */ jsx(
      Scrollbar,
      {
        ...others,
        "data-orientation": "vertical",
        ref: composeRefs2,
        sizes: sizes2,
        style: {
          "--sa-thumb-height": `${getThumbSize(sizes2)}px`,
          ...style2
        },
        onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
        onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
        onWheelScroll: (event, maxScrollPos) => {
          if (context.viewport) {
            const scrollPos = context.viewport.scrollTop + event.deltaY;
            props.onWheelScroll(scrollPos), isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) && event.preventDefault();
          }
        },
        onResize: () => {
          ref.current && context.viewport && computedStyle && onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    );
  }
);
ScrollAreaScrollbarY.displayName = "@mantine/core/ScrollAreaScrollbarY";
const ScrollAreaScrollbarVisible = forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props, { dir } = useDirection(), context = useScrollAreaContext(), thumbRef = useRef(null), pointerOffsetRef = useRef(0), [sizes2, setSizes] = useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), thumbRatio = getThumbRatio(sizes2.viewport, sizes2.content), commonProps = {
    ...scrollbarProps,
    sizes: sizes2,
    onSizesChange: setSizes,
    hasThumb: thumbRatio > 0 && thumbRatio < 1,
    onThumbChange: (thumb) => {
      thumbRef.current = thumb;
    },
    onThumbPointerUp: () => {
      pointerOffsetRef.current = 0;
    },
    onThumbPointerDown: (pointerPos) => {
      pointerOffsetRef.current = pointerPos;
    }
  }, getScrollPosition = (pointerPos, direction) => getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes2, direction);
  return orientation === "horizontal" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarX,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollLeft, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2, dir);
          thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context.viewport && (context.viewport.scrollLeft = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context.viewport && (context.viewport.scrollLeft = getScrollPosition(pointerPos, dir));
      }
    }
  ) : orientation === "vertical" ? /* @__PURE__ */ jsx(
    ScrollAreaScrollbarY,
    {
      ...commonProps,
      ref: forwardedRef,
      onThumbPositionChange: () => {
        if (context.viewport && thumbRef.current) {
          const scrollPos = context.viewport.scrollTop, offset2 = getThumbOffsetFromScroll(scrollPos, sizes2);
          sizes2.scrollbar.size === 0 ? thumbRef.current.style.setProperty("--thumb-opacity", "0") : thumbRef.current.style.setProperty("--thumb-opacity", "1"), thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
        }
      },
      onWheelScroll: (scrollPos) => {
        context.viewport && (context.viewport.scrollTop = scrollPos);
      },
      onDragScroll: (pointerPos) => {
        context.viewport && (context.viewport.scrollTop = getScrollPosition(pointerPos));
      }
    }
  ) : null;
});
ScrollAreaScrollbarVisible.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
const ScrollAreaScrollbarAuto = forwardRef(
  (props, ref) => {
    const context = useScrollAreaContext(), { forceMount, ...scrollbarProps } = props, [visible2, setVisible] = useState(!1), isHorizontal = props.orientation === "horizontal", handleResize = useDebouncedCallback$1(() => {
      if (context.viewport) {
        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth, isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
        setVisible(isHorizontal ? isOverflowX : isOverflowY);
      }
    }, 10);
    return useResizeObserver$1(context.viewport, handleResize), useResizeObserver$1(context.content, handleResize), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarAuto.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
const ScrollAreaScrollbarHover = forwardRef(
  (props, ref) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), [visible2, setVisible] = useState(!1);
    return useEffect(() => {
      const { scrollArea } = context;
      let hideTimer = 0;
      if (scrollArea) {
        const handlePointerEnter = () => {
          window.clearTimeout(hideTimer), setVisible(!0);
        }, handlePointerLeave = () => {
          hideTimer = window.setTimeout(() => setVisible(!1), context.scrollHideDelay);
        };
        return scrollArea.addEventListener("pointerenter", handlePointerEnter), scrollArea.addEventListener("pointerleave", handlePointerLeave), () => {
          window.clearTimeout(hideTimer), scrollArea.removeEventListener("pointerenter", handlePointerEnter), scrollArea.removeEventListener("pointerleave", handlePointerLeave);
        };
      }
    }, [context.scrollArea, context.scrollHideDelay]), forceMount || visible2 ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarAuto,
      {
        "data-state": visible2 ? "visible" : "hidden",
        ...scrollbarProps,
        ref
      }
    ) : null;
  }
);
ScrollAreaScrollbarHover.displayName = "@mantine/core/ScrollAreaScrollbarHover";
const ScrollAreaScrollbarScroll = forwardRef(
  (props, red) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), isHorizontal = props.orientation === "horizontal", [state, setState] = useState("hidden"), debounceScrollEnd = useDebouncedCallback$1(() => setState("idle"), 100);
    return useEffect(() => {
      if (state === "idle") {
        const hideTimer = window.setTimeout(() => setState("hidden"), context.scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    }, [state, context.scrollHideDelay]), useEffect(() => {
      const { viewport } = context, scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll2 = () => {
          const scrollPos = viewport[scrollDirection];
          prevScrollPos !== scrollPos && (setState("scrolling"), debounceScrollEnd()), prevScrollPos = scrollPos;
        };
        return viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [context.viewport, isHorizontal, debounceScrollEnd]), forceMount || state !== "hidden" ? /* @__PURE__ */ jsx(
      ScrollAreaScrollbarVisible,
      {
        "data-state": state === "hidden" ? "hidden" : "visible",
        ...scrollbarProps,
        ref: red,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => setState("interacting")),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => setState("idle"))
      }
    ) : null;
  }
), ScrollAreaScrollbar = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props, context = useScrollAreaContext(), { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context, isHorizontal = props.orientation === "horizontal";
    return useEffect(() => (isHorizontal ? onScrollbarXEnabledChange(!0) : onScrollbarYEnabledChange(!0), () => {
      isHorizontal ? onScrollbarXEnabledChange(!1) : onScrollbarYEnabledChange(!1);
    }), [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]), context.type === "hover" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = "@mantine/core/ScrollAreaScrollbar";
function addUnlinkedScrollListener(node, handler = () => {
}) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop }, rAF = 0;
  return (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop }, isHorizontalScroll = prevPosition.left !== position.left, isVerticalScroll = prevPosition.top !== position.top;
    (isHorizontalScroll || isVerticalScroll) && handler(), prevPosition = position, rAF = window.requestAnimationFrame(loop);
  })(), () => window.cancelAnimationFrame(rAF);
}
const Thumb$1 = forwardRef((props, forwardedRef) => {
  const { style: style2, ...others } = props, scrollAreaContext = useScrollAreaContext(), scrollbarContext = useScrollbarContext(), { onThumbPositionChange } = scrollbarContext, composedRef = useMergedRef(forwardedRef, (node) => scrollbarContext.onThumbChange(node)), removeUnlinkedScrollListenerRef = useRef(void 0), debounceScrollEnd = useDebouncedCallback$1(() => {
    removeUnlinkedScrollListenerRef.current && (removeUnlinkedScrollListenerRef.current(), removeUnlinkedScrollListenerRef.current = void 0);
  }, 100);
  return useEffect(() => {
    const { viewport } = scrollAreaContext;
    if (viewport) {
      const handleScroll2 = () => {
        if (debounceScrollEnd(), !removeUnlinkedScrollListenerRef.current) {
          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
          removeUnlinkedScrollListenerRef.current = listener, onThumbPositionChange();
        }
      };
      return onThumbPositionChange(), viewport.addEventListener("scroll", handleScroll2), () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]), /* @__PURE__ */ jsx(
    "div",
    {
      "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
      ...others,
      ref: composedRef,
      style: {
        width: "var(--sa-thumb-width)",
        height: "var(--sa-thumb-height)",
        ...style2
      },
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
        const thumbRect = event.target.getBoundingClientRect(), x2 = event.clientX - thumbRect.left, y2 = event.clientY - thumbRect.top;
        scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
      }),
      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
    }
  );
});
Thumb$1.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaThumb = forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props, scrollbarContext = useScrollbarContext();
    return forceMount || scrollbarContext.hasThumb ? /* @__PURE__ */ jsx(Thumb$1, { ref: forwardedRef, ...thumbProps }) : null;
  }
);
ScrollAreaThumb.displayName = "@mantine/core/ScrollAreaThumb";
const ScrollAreaViewport = forwardRef(
  ({ children: children2, style: style2, ...others }, ref) => {
    const ctx = useScrollAreaContext(), rootRef = useMergedRef(ref, ctx.onViewportChange);
    return /* @__PURE__ */ jsx(
      Box,
      {
        ...others,
        ref: rootRef,
        style: {
          overflowX: ctx.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: ctx.scrollbarYEnabled ? "scroll" : "hidden",
          ...style2
        },
        children: /* @__PURE__ */ jsx("div", { ...ctx.getStyles("content"), ref: ctx.onContentChange, children: children2 })
      }
    );
  }
);
ScrollAreaViewport.displayName = "@mantine/core/ScrollAreaViewport";
var classes$I = { root: "m_d57069b5", content: "m_b1336c6", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };
const defaultProps$Q = {
  scrollHideDelay: 1e3,
  type: "hover",
  scrollbars: "xy"
}, varsResolver$M = (_2, { scrollbarSize, overscrollBehavior }) => ({
  root: {
    "--scrollarea-scrollbar-size": rem(scrollbarSize),
    "--scrollarea-over-scroll-behavior": overscrollBehavior
  }
}), ScrollArea = factory((_props, ref) => {
  const props = useProps("ScrollArea", defaultProps$Q, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    scrollbarSize,
    vars,
    type,
    scrollHideDelay,
    viewportProps,
    viewportRef,
    onScrollPositionChange,
    children: children2,
    offsetScrollbars,
    scrollbars,
    onBottomReached,
    onTopReached,
    overscrollBehavior,
    attributes,
    ...others
  } = props, [scrollbarHovered, setScrollbarHovered] = useState(!1), [verticalThumbVisible, setVerticalThumbVisible] = useState(!1), [horizontalThumbVisible, setHorizontalThumbVisible] = useState(!1), getStyles2 = useStyles({
    name: "ScrollArea",
    props,
    classes: classes$I,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$M
  }), localViewportRef = useRef(null), combinedViewportRef = useMergeRefs([viewportRef, localViewportRef]);
  return useEffect(() => {
    if (!localViewportRef.current || offsetScrollbars !== "present")
      return;
    const element = localViewportRef.current, observer = new ResizeObserver(() => {
      const { scrollHeight, clientHeight, scrollWidth, clientWidth } = element;
      setVerticalThumbVisible(scrollHeight > clientHeight), setHorizontalThumbVisible(scrollWidth > clientWidth);
    });
    return observer.observe(element), () => observer.disconnect();
  }, [localViewportRef, offsetScrollbars]), /* @__PURE__ */ jsxs(
    ScrollAreaRoot,
    {
      getStyles: getStyles2,
      type: type === "never" ? "always" : type,
      scrollHideDelay,
      ref,
      scrollbars,
      ...getStyles2("root"),
      ...others,
      children: [
        /* @__PURE__ */ jsx(
          ScrollAreaViewport,
          {
            ...viewportProps,
            ...getStyles2("viewport", { style: viewportProps?.style }),
            ref: combinedViewportRef,
            "data-offset-scrollbars": offsetScrollbars === !0 ? "xy" : offsetScrollbars || void 0,
            "data-scrollbars": scrollbars || void 0,
            "data-horizontal-hidden": offsetScrollbars === "present" && !horizontalThumbVisible ? "true" : void 0,
            "data-vertical-hidden": offsetScrollbars === "present" && !verticalThumbVisible ? "true" : void 0,
            onScroll: (e2) => {
              viewportProps?.onScroll?.(e2), onScrollPositionChange?.({ x: e2.currentTarget.scrollLeft, y: e2.currentTarget.scrollTop });
              const { scrollTop, scrollHeight, clientHeight } = e2.currentTarget;
              scrollTop - (scrollHeight - clientHeight) >= -0.6 && onBottomReached?.(), scrollTop === 0 && onTopReached?.();
            },
            children: children2
          }
        ),
        (scrollbars === "xy" || scrollbars === "x") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "horizontal",
            "data-hidden": type === "never" || offsetScrollbars === "present" && !horizontalThumbVisible ? !0 : void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        (scrollbars === "xy" || scrollbars === "y") && /* @__PURE__ */ jsx(
          ScrollAreaScrollbar,
          {
            ...getStyles2("scrollbar"),
            orientation: "vertical",
            "data-hidden": type === "never" || offsetScrollbars === "present" && !verticalThumbVisible ? !0 : void 0,
            forceMount: !0,
            onMouseEnter: () => setScrollbarHovered(!0),
            onMouseLeave: () => setScrollbarHovered(!1),
            children: /* @__PURE__ */ jsx(ScrollAreaThumb, { ...getStyles2("thumb") })
          }
        ),
        /* @__PURE__ */ jsx(
          ScrollAreaCorner,
          {
            ...getStyles2("corner"),
            "data-hovered": scrollbarHovered || void 0,
            "data-hidden": type === "never" || void 0
          }
        )
      ]
    }
  );
});
ScrollArea.displayName = "@mantine/core/ScrollArea";
const ScrollAreaAutosize = factory((props, ref) => {
  const {
    children: children2,
    classNames,
    styles,
    scrollbarSize,
    scrollHideDelay,
    type,
    dir,
    offsetScrollbars,
    viewportRef,
    onScrollPositionChange,
    unstyled,
    variant,
    viewportProps,
    scrollbars,
    style: style2,
    vars,
    onBottomReached,
    onTopReached,
    onOverflowChange,
    ...others
  } = useProps("ScrollAreaAutosize", defaultProps$Q, props), viewportObserverRef = useRef(null), combinedViewportRef = useMergeRefs([viewportRef, viewportObserverRef]), [overflowing, setOverflowing] = useState(!1), didMount = useRef(!1);
  return useEffect(() => {
    if (!onOverflowChange)
      return;
    const el = viewportObserverRef.current;
    if (!el)
      return;
    const update = () => {
      const isOverflowing = el.scrollHeight > el.clientHeight;
      isOverflowing !== overflowing && (didMount.current ? onOverflowChange?.(isOverflowing) : (didMount.current = !0, isOverflowing && onOverflowChange?.(!0)), setOverflowing(isOverflowing));
    };
    update();
    const ro = new ResizeObserver(update);
    return ro.observe(el), () => ro.disconnect();
  }, [onOverflowChange, overflowing]), /* @__PURE__ */ jsx(Box, { ...others, ref, style: [{ display: "flex", overflow: "hidden" }, style2], children: /* @__PURE__ */ jsx(
    Box,
    {
      style: {
        display: "flex",
        flexDirection: "column",
        flex: 1,
        overflow: "hidden",
        ...scrollbars === "y" && { minWidth: 0 },
        ...scrollbars === "x" && { minHeight: 0 },
        ...scrollbars === "xy" && { minWidth: 0, minHeight: 0 },
        ...scrollbars === !1 && { minWidth: 0, minHeight: 0 }
      },
      children: /* @__PURE__ */ jsx(
        ScrollArea,
        {
          classNames,
          styles,
          scrollHideDelay,
          scrollbarSize,
          type,
          dir,
          offsetScrollbars,
          viewportRef: combinedViewportRef,
          onScrollPositionChange,
          unstyled,
          variant,
          viewportProps,
          vars,
          scrollbars,
          onBottomReached,
          onTopReached,
          "data-autosize": "true",
          children: children2
        }
      )
    }
  ) });
});
ScrollArea.classes = classes$I;
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
ScrollAreaAutosize.classes = classes$I;
ScrollArea.Autosize = ScrollAreaAutosize;
var classes$H = { root: "m_87cf2631" };
const defaultProps$P = {
  __staticSelector: "UnstyledButton"
}, UnstyledButton = polymorphicFactory(
  (_props, ref) => {
    const props = useProps("UnstyledButton", defaultProps$P, _props), {
      className,
      component = "button",
      __staticSelector,
      unstyled,
      classNames,
      styles,
      style: style2,
      attributes,
      ...others
    } = props, getStyles2 = useStyles({
      name: __staticSelector,
      props,
      classes: classes$H,
      className,
      style: style2,
      classNames,
      styles,
      unstyled,
      attributes
    });
    return /* @__PURE__ */ jsx(
      Box,
      {
        ...getStyles2("root", { focusable: !0 }),
        component,
        ref,
        type: component === "button" ? "button" : void 0,
        ...others
      }
    );
  }
);
UnstyledButton.classes = classes$H;
UnstyledButton.displayName = "@mantine/core/UnstyledButton";
var classes$G = { root: "m_515a97f8" };
const VisuallyHidden = factory((_props, ref) => {
  const props = useProps("VisuallyHidden", null, _props), { classNames, className, style: style2, styles, unstyled, vars, attributes, ...others } = props, getStyles2 = useStyles({
    name: "VisuallyHidden",
    classes: classes$G,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes
  });
  return /* @__PURE__ */ jsx(Box, { component: "span", ref, ...getStyles2("root"), ...others });
});
VisuallyHidden.classes = classes$G;
VisuallyHidden.displayName = "@mantine/core/VisuallyHidden";
var classes$F = { root: "m_1b7284a3" };
const varsResolver$L = (_2, { radius, shadow }) => ({
  root: {
    "--paper-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--paper-shadow": getShadow(shadow)
  }
}), Paper = polymorphicFactory((_props, ref) => {
  const props = useProps("Paper", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    withBorder,
    vars,
    radius,
    shadow,
    variant,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Paper",
    props,
    classes: classes$F,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$L
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ "data-with-border": withBorder }, mod],
      ...getStyles2("root"),
      variant,
      ...others
    }
  );
});
Paper.classes = classes$F;
Paper.displayName = "@mantine/core/Paper";
function horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {
  return placement === "center" || arrowPosition === "center" ? { top: arrowY } : placement === "end" ? { bottom: arrowOffset } : placement === "start" ? { top: arrowOffset } : {};
}
function verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {
  return placement === "center" || arrowPosition === "center" ? { left: arrowX } : placement === "end" ? { [dir === "ltr" ? "right" : "left"]: arrowOffset } : placement === "start" ? { [dir === "ltr" ? "left" : "right"]: arrowOffset } : {};
}
const radiusByFloatingSide = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function getArrowPositionStyles({
  position,
  arrowSize,
  arrowOffset,
  arrowRadius,
  arrowPosition,
  arrowX,
  arrowY,
  dir
}) {
  const [side, placement = "center"] = position.split("-"), baseStyles = {
    width: arrowSize,
    height: arrowSize,
    transform: "rotate(45deg)",
    position: "absolute",
    [radiusByFloatingSide[side]]: arrowRadius
  }, arrowPlacement = -arrowSize / 2;
  return side === "left" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    right: arrowPlacement,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent",
    clipPath: "polygon(100% 0, 0 0, 100% 100%)"
  } : side === "right" ? {
    ...baseStyles,
    ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),
    left: arrowPlacement,
    borderRightColor: "transparent",
    borderTopColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 100%)"
  } : side === "top" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    bottom: arrowPlacement,
    borderTopColor: "transparent",
    borderLeftColor: "transparent",
    clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
  } : side === "bottom" ? {
    ...baseStyles,
    ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),
    top: arrowPlacement,
    borderBottomColor: "transparent",
    borderRightColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 0)"
  } : {};
}
const FloatingArrow = forwardRef(
  ({
    position,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    visible: visible2,
    arrowX,
    arrowY,
    style: style2,
    ...others
  }, ref) => {
    const { dir } = useDirection();
    return visible2 ? /* @__PURE__ */ jsx(
      "div",
      {
        ...others,
        ref,
        style: {
          ...style2,
          ...getArrowPositionStyles({
            position,
            arrowSize,
            arrowOffset,
            arrowRadius,
            arrowPosition,
            dir,
            arrowX,
            arrowY
          })
        }
      }
    ) : null;
  }
);
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
function getFloatingPosition(dir, position) {
  if (dir === "rtl" && (position.includes("right") || position.includes("left"))) {
    const [side, placement] = position.split("-"), flippedPosition = side === "right" ? "left" : "right";
    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;
  }
  return position;
}
var classes$E = { root: "m_9814e45f" };
const defaultProps$O = {
  zIndex: getDefaultZIndex("modal")
}, varsResolver$K = (_2, { gradient, color: color2, backgroundOpacity, blur, radius, zIndex }) => ({
  root: {
    "--overlay-bg": gradient || (color2 !== void 0 || backgroundOpacity !== void 0) && rgba$3(color2 || "#000", backgroundOpacity ?? 0.6) || void 0,
    "--overlay-filter": blur ? `blur(${rem(blur)})` : void 0,
    "--overlay-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--overlay-z-index": zIndex?.toString()
  }
}), Overlay = polymorphicFactory((_props, ref) => {
  const props = useProps("Overlay", defaultProps$O, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    fixed,
    center,
    children: children2,
    radius,
    zIndex,
    gradient,
    blur,
    color: color2,
    backgroundOpacity,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Overlay",
    props,
    classes: classes$E,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$K
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), mod: [{ center, fixed }, mod], ...others, children: children2 });
});
Overlay.classes = classes$E;
Overlay.displayName = "@mantine/core/Overlay";
function createPortalNode(props) {
  const node = document.createElement("div");
  return node.setAttribute("data-portal", "true"), typeof props.className == "string" && node.classList.add(...props.className.split(" ").filter(Boolean)), typeof props.style == "object" && Object.assign(node.style, props.style), typeof props.id == "string" && node.setAttribute("id", props.id), node;
}
function getTargetNode({ target, reuseTargetNode, ...others }) {
  if (target)
    return typeof target == "string" ? document.querySelector(target) || createPortalNode(others) : target;
  if (reuseTargetNode) {
    const existingNode = document.querySelector("[data-mantine-shared-portal-node]");
    if (existingNode)
      return existingNode;
    const node = createPortalNode(others);
    return node.setAttribute("data-mantine-shared-portal-node", "true"), document.body.appendChild(node), node;
  }
  return createPortalNode(others);
}
const defaultProps$N = {
  reuseTargetNode: !0
}, Portal = factory((props, ref) => {
  const { children: children2, target, reuseTargetNode, ...others } = useProps("Portal", defaultProps$N, props), [mounted, setMounted] = useState(!1), nodeRef = useRef(null);
  return useIsomorphicEffect(() => (setMounted(!0), nodeRef.current = getTargetNode({ target, reuseTargetNode, ...others }), assignRef(ref, nodeRef.current), !target && !reuseTargetNode && nodeRef.current && document.body.appendChild(nodeRef.current), () => {
    !target && !reuseTargetNode && nodeRef.current && document.body.removeChild(nodeRef.current);
  }), [target]), !mounted || !nodeRef.current ? null : createPortal(/* @__PURE__ */ jsx(Fragment$1, { children: children2 }), nodeRef.current);
});
Portal.displayName = "@mantine/core/Portal";
const OptionalPortal = factory(
  ({ withinPortal = !0, children: children2, ...others }, ref) => useMantineEnv() === "test" || !withinPortal ? /* @__PURE__ */ jsx(Fragment$1, { children: children2 }) : /* @__PURE__ */ jsx(Portal, { ref, ...others, children: children2 })
);
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
const popIn = (from) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${from === "bottom" ? 10 : -10}px)` },
  transitionProperty: "transform, opacity"
}), transitions$1 = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-30px)" },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...popIn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...popIn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...popIn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...popIn("top"),
    common: { transformOrigin: "top right" }
  }
}, transitionStatuses = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function getTransitionStyles({
  transition,
  state,
  duration: duration2,
  timingFunction
}) {
  const shared = {
    WebkitBackfaceVisibility: "hidden",
    transitionDuration: `${duration2}ms`,
    transitionTimingFunction: timingFunction
  };
  return typeof transition == "string" ? transition in transitions$1 ? {
    transitionProperty: transitions$1[transition].transitionProperty,
    ...shared,
    ...transitions$1[transition].common,
    ...transitions$1[transition][transitionStatuses[state]]
  } : {} : {
    transitionProperty: transition.transitionProperty,
    ...shared,
    ...transition.common,
    ...transition[transitionStatuses[state]]
  };
}
function useTransition({
  duration: duration2,
  exitDuration,
  timingFunction,
  mounted,
  onEnter,
  onExit,
  onEntered,
  onExited,
  enterDelay,
  exitDelay
}) {
  const theme = useMantineTheme(), shouldReduceMotion = useReducedMotion$1(), reduceMotion = theme.respectReducedMotion ? shouldReduceMotion : !1, [transitionDuration, setTransitionDuration] = useState(reduceMotion ? 0 : duration2), [transitionStatus, setStatus] = useState(mounted ? "entered" : "exited"), transitionTimeoutRef = useRef(-1), delayTimeoutRef = useRef(-1), rafRef = useRef(-1);
  function clearAllTimeouts() {
    window.clearTimeout(transitionTimeoutRef.current), window.clearTimeout(delayTimeoutRef.current), cancelAnimationFrame(rafRef.current);
  }
  const handleStateChange = (shouldMount) => {
    clearAllTimeouts();
    const preHandler = shouldMount ? onEnter : onExit, handler = shouldMount ? onEntered : onExited, newTransitionDuration = reduceMotion ? 0 : shouldMount ? duration2 : exitDuration;
    setTransitionDuration(newTransitionDuration), newTransitionDuration === 0 ? (typeof preHandler == "function" && preHandler(), typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited")) : rafRef.current = requestAnimationFrame(() => {
      ReactDOM__default.flushSync(() => {
        setStatus(shouldMount ? "pre-entering" : "pre-exiting");
      }), rafRef.current = requestAnimationFrame(() => {
        typeof preHandler == "function" && preHandler(), setStatus(shouldMount ? "entering" : "exiting"), transitionTimeoutRef.current = window.setTimeout(() => {
          typeof handler == "function" && handler(), setStatus(shouldMount ? "entered" : "exited");
        }, newTransitionDuration);
      });
    });
  }, handleTransitionWithDelay = (shouldMount) => {
    if (clearAllTimeouts(), typeof (shouldMount ? enterDelay : exitDelay) != "number") {
      handleStateChange(shouldMount);
      return;
    }
    delayTimeoutRef.current = window.setTimeout(
      () => {
        handleStateChange(shouldMount);
      },
      shouldMount ? enterDelay : exitDelay
    );
  };
  return useDidUpdate(() => {
    handleTransitionWithDelay(mounted);
  }, [mounted]), useEffect(
    () => () => {
      clearAllTimeouts();
    },
    []
  ), {
    transitionDuration,
    transitionStatus,
    transitionTimingFunction: timingFunction || "ease"
  };
}
function Transition$1({
  keepMounted,
  transition = "fade",
  duration: duration2 = 250,
  exitDuration = duration2,
  mounted,
  children: children2,
  timingFunction = "ease",
  onExit,
  onEntered,
  onEnter,
  onExited,
  enterDelay,
  exitDelay
}) {
  const env = useMantineEnv(), { transitionDuration, transitionStatus, transitionTimingFunction } = useTransition({
    mounted,
    exitDuration,
    duration: duration2,
    timingFunction,
    onExit,
    onEntered,
    onEnter,
    onExited,
    enterDelay,
    exitDelay
  });
  return transitionDuration === 0 || env === "test" ? mounted ? /* @__PURE__ */ jsx(Fragment$1, { children: children2({}) }) : keepMounted ? children2({ display: "none" }) : null : transitionStatus === "exited" ? keepMounted ? children2({ display: "none" }) : null : /* @__PURE__ */ jsx(Fragment$1, { children: children2(
    getTransitionStyles({
      transition,
      duration: transitionDuration,
      state: transitionStatus,
      timingFunction: transitionTimingFunction
    })
  ) });
}
Transition$1.displayName = "@mantine/core/Transition";
const [PopoverContextProvider, usePopoverContext] = createSafeContext(
  "Popover component was not found in the tree"
);
function FocusTrap({
  children: children2,
  active = !0,
  refProp = "ref",
  innerRef
}) {
  const focusTrapRef = useFocusTrap(active), ref = useMergedRef(focusTrapRef, innerRef), child = getSingleElementChild(children2);
  return child ? cloneElement(child, { [refProp]: ref }) : children2;
}
function FocusTrapInitialFocus(props) {
  return /* @__PURE__ */ jsx(VisuallyHidden, { tabIndex: -1, "data-autofocus": !0, ...props });
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
FocusTrapInitialFocus.displayName = "@mantine/core/FocusTrapInitialFocus";
FocusTrap.InitialFocus = FocusTrapInitialFocus;
var classes$D = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" };
const PopoverDropdown = factory((_props, ref) => {
  const props = useProps("PopoverDropdown", null, _props), {
    className,
    style: style2,
    vars,
    children: children2,
    onKeyDownCapture,
    variant,
    classNames,
    styles,
    ...others
  } = props, ctx = usePopoverContext(), returnFocus = useFocusReturn({
    opened: ctx.opened,
    shouldReturnFocus: ctx.returnFocus
  }), accessibleProps = ctx.withRoles ? {
    "aria-labelledby": ctx.getTargetId(),
    id: ctx.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, mergedRef = useMergedRef(ref, ctx.floating);
  return ctx.disabled ? null : /* @__PURE__ */ jsx(OptionalPortal, { ...ctx.portalProps, withinPortal: ctx.withinPortal, children: /* @__PURE__ */ jsx(
    Transition$1,
    {
      mounted: ctx.opened,
      ...ctx.transitionProps,
      transition: ctx.transitionProps?.transition || "fade",
      duration: ctx.transitionProps?.duration ?? 150,
      keepMounted: ctx.keepMounted,
      exitDuration: typeof ctx.transitionProps?.exitDuration == "number" ? ctx.transitionProps.exitDuration : ctx.transitionProps?.duration,
      children: (transitionStyles) => /* @__PURE__ */ jsx(FocusTrap, { active: ctx.trapFocus && ctx.opened, innerRef: mergedRef, children: /* @__PURE__ */ jsxs(
        Box,
        {
          ...accessibleProps,
          ...others,
          variant,
          onKeyDownCapture: closeOnEscape(
            () => {
              ctx.onClose?.(), ctx.onDismiss?.();
            },
            {
              active: ctx.closeOnEscape,
              onTrigger: returnFocus,
              onKeyDown: onKeyDownCapture
            }
          ),
          "data-position": ctx.placement,
          "data-fixed": ctx.floatingStrategy === "fixed" || void 0,
          ...ctx.getStyles("dropdown", {
            className,
            props,
            classNames,
            styles,
            style: [
              {
                ...transitionStyles,
                zIndex: ctx.zIndex,
                top: ctx.y ?? 0,
                left: ctx.x ?? 0,
                width: ctx.width === "target" ? void 0 : rem(ctx.width),
                ...ctx.referenceHidden ? { display: "none" } : null
              },
              ctx.resolvedStyles.dropdown,
              styles?.dropdown,
              style2
            ]
          }),
          children: [
            children2,
            /* @__PURE__ */ jsx(
              FloatingArrow,
              {
                ref: ctx.arrowRef,
                arrowX: ctx.arrowX,
                arrowY: ctx.arrowY,
                visible: ctx.withArrow,
                position: ctx.placement,
                arrowSize: ctx.arrowSize,
                arrowRadius: ctx.arrowRadius,
                arrowOffset: ctx.arrowOffset,
                arrowPosition: ctx.arrowPosition,
                ...ctx.getStyles("arrow", {
                  props,
                  classNames,
                  styles
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
PopoverDropdown.classes = classes$D;
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
const defaultProps$M = {
  refProp: "ref",
  popupType: "dialog"
}, PopoverTarget = factory((props, ref) => {
  const { children: children2, refProp, popupType, ...others } = useProps(
    "PopoverTarget",
    defaultProps$M,
    props
  ), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const forwardedProps = others, ctx = usePopoverContext(), targetRef = useMergedRef(ctx.reference, getRefProp(child), ref), accessibleProps = ctx.withRoles ? {
    "aria-haspopup": popupType,
    "aria-expanded": ctx.opened,
    "aria-controls": ctx.getDropdownId(),
    id: ctx.getTargetId()
  } : {}, childProps = child.props;
  return cloneElement(child, {
    ...forwardedProps,
    ...accessibleProps,
    ...ctx.targetProps,
    className: clsx(ctx.targetProps.className, forwardedProps.className, childProps.className),
    [refProp]: targetRef,
    ...ctx.controlled ? null : {
      onClick: () => {
        ctx.onToggle(), childProps.onClick?.();
      }
    }
  });
});
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
function getDefaultMiddlewares$1(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getPopoverMiddlewares(options, getFloating, env) {
  const middlewaresOptions = getDefaultMiddlewares$1(options.middlewares), middlewares = [offset(options.offset), hide()];
  return options.dropdownVisible && env !== "test" && options.preventPositionChangeWhenVisible && (middlewaresOptions.flip = !1), middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { limiter: limitShift(), padding: 5 } : { limiter: limitShift(), padding: 5, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewaresOptions.inline && middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ), middlewares.push(arrow({ element: options.arrowRef, padding: options.arrowOffset })), (middlewaresOptions.size || options.width === "target") && middlewares.push(
    size({
      ...typeof middlewaresOptions.size == "boolean" ? {} : middlewaresOptions.size,
      apply({ rects, availableWidth, availableHeight, ...rest }) {
        const styles = getFloating().refs.floating.current?.style ?? {};
        middlewaresOptions.size && (typeof middlewaresOptions.size == "object" && middlewaresOptions.size.apply ? middlewaresOptions.size.apply({ rects, availableWidth, availableHeight, ...rest }) : Object.assign(styles, {
          maxWidth: `${availableWidth}px`,
          maxHeight: `${availableHeight}px`
        })), options.width === "target" && Object.assign(styles, {
          width: `${rects.reference.width}px`
        });
      }
    })
  ), middlewares;
}
function usePopover(options) {
  const env = useMantineEnv(), [_opened, setOpened] = useUncontrolled({
    value: options.opened,
    defaultValue: options.defaultOpened,
    finalValue: !1,
    onChange: options.onChange
  }), previouslyOpened = useRef(_opened), onClose = () => {
    _opened && !options.disabled && setOpened(!1);
  }, onToggle = () => {
    options.disabled || setOpened(!_opened);
  }, floating = useFloating({
    strategy: options.strategy,
    placement: options.preventPositionChangeWhenVisible ? options.positionRef.current : options.position,
    middleware: getPopoverMiddlewares(options, () => floating, env),
    whileElementsMounted: options.keepMounted ? void 0 : autoUpdate
  });
  return useEffect(() => {
    if (!(!floating.refs.reference.current || !floating.refs.floating.current) && _opened)
      return autoUpdate(
        floating.refs.reference.current,
        floating.refs.floating.current,
        floating.update
      );
  }, [_opened, floating.update]), useDidUpdate(() => {
    options.onPositionChange?.(floating.placement), options.positionRef.current = floating.placement;
  }, [floating.placement, options.preventPositionChangeWhenVisible]), useDidUpdate(() => {
    _opened !== previouslyOpened.current && (_opened ? options.onOpen?.() : options.onClose?.()), previouslyOpened.current = _opened;
  }, [_opened, options.onClose, options.onOpen]), useIsomorphicEffect(() => {
    let timeout2 = -1;
    return _opened && (timeout2 = window.setTimeout(() => options.setDropdownVisible(!0), 4)), () => {
      window.clearTimeout(timeout2);
    };
  }, [_opened, options.position]), {
    floating,
    controlled: typeof options.opened == "boolean",
    opened: _opened,
    onClose,
    onToggle
  };
}
const defaultProps$L = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  withOverlay: !1,
  hideDetached: !0,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: getDefaultZIndex("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, varsResolver$J = (_2, { radius, shadow }) => ({
  dropdown: {
    "--popover-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--popover-shadow": getShadow(shadow)
  }
});
function Popover(_props) {
  const props = useProps("Popover", defaultProps$L, _props), {
    children: children2,
    position,
    offset: offset2,
    onPositionChange,
    // Scheduled for removal in 9.0
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionDependencies,
    opened,
    transitionProps,
    onExitTransitionEnd,
    onEnterTransitionEnd,
    width,
    middlewares,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    unstyled,
    classNames,
    styles,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    closeOnEscape: closeOnEscape2,
    clickOutsideEvents,
    trapFocus,
    onClose,
    onDismiss,
    onOpen,
    onChange,
    zIndex,
    radius,
    shadow,
    id: id2,
    defaultOpened,
    __staticSelector,
    withRoles,
    disabled,
    returnFocus,
    variant,
    keepMounted,
    vars,
    floatingStrategy,
    withOverlay,
    overlayProps,
    hideDetached,
    attributes,
    preventPositionChangeWhenVisible,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    props,
    classes: classes$D,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "dropdown",
    vars,
    varsResolver: varsResolver$J
  }), { resolvedStyles } = useResolvedStylesApi({ classNames, styles, props }), [dropdownVisible, setDropdownVisible] = useState(opened ?? defaultOpened ?? !1), positionRef = useRef(position), arrowRef = useRef(null), [targetNode, setTargetNode] = useState(null), [dropdownNode, setDropdownNode] = useState(null), { dir } = useDirection(), env = useMantineEnv(), uid = useId$1(id2), popover = usePopover({
    middlewares,
    width,
    position: getFloatingPosition(dir, position),
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    arrowRef,
    arrowOffset,
    onPositionChange,
    positionDependencies,
    opened,
    defaultOpened,
    onChange,
    onOpen,
    onClose,
    onDismiss,
    strategy: floatingStrategy,
    dropdownVisible,
    setDropdownVisible,
    positionRef,
    disabled,
    preventPositionChangeWhenVisible,
    keepMounted
  });
  useClickOutside(
    () => {
      closeOnClickOutside && (popover.onClose(), onDismiss?.());
    },
    clickOutsideEvents,
    [targetNode, dropdownNode]
  );
  const reference = useCallback(
    (node) => {
      setTargetNode(node), popover.floating.refs.setReference(node);
    },
    [popover.floating.refs.setReference]
  ), floating = useCallback(
    (node) => {
      setDropdownNode(node), popover.floating.refs.setFloating(node);
    },
    [popover.floating.refs.setFloating]
  ), onExited = useCallback(() => {
    transitionProps?.onExited?.(), onExitTransitionEnd?.(), setDropdownVisible(!1), preventPositionChangeWhenVisible || (positionRef.current = position);
  }, [transitionProps?.onExited, onExitTransitionEnd, preventPositionChangeWhenVisible, position]), onEntered = useCallback(() => {
    transitionProps?.onEntered?.(), onEnterTransitionEnd?.();
  }, [transitionProps?.onEntered, onEnterTransitionEnd]);
  return /* @__PURE__ */ jsxs(
    PopoverContextProvider,
    {
      value: {
        returnFocus,
        disabled,
        controlled: popover.controlled,
        reference,
        floating,
        x: popover.floating.x,
        y: popover.floating.y,
        arrowX: popover.floating?.middlewareData?.arrow?.x,
        arrowY: popover.floating?.middlewareData?.arrow?.y,
        opened: popover.opened,
        arrowRef,
        transitionProps: { ...transitionProps, onExited, onEntered },
        width,
        withArrow,
        arrowSize,
        arrowOffset,
        arrowRadius,
        arrowPosition,
        placement: popover.floating.placement,
        trapFocus,
        withinPortal,
        portalProps,
        zIndex,
        radius,
        shadow,
        closeOnEscape: closeOnEscape2,
        onDismiss,
        onClose: popover.onClose,
        onToggle: popover.onToggle,
        getTargetId: () => `${uid}-target`,
        getDropdownId: () => `${uid}-dropdown`,
        withRoles,
        targetProps: others,
        __staticSelector,
        classNames,
        styles,
        unstyled,
        variant,
        keepMounted,
        getStyles: getStyles2,
        resolvedStyles,
        floatingStrategy,
        referenceHidden: hideDetached && env !== "test" ? popover.floating.middlewareData.hide?.referenceHidden : !1
      },
      children: [
        children2,
        withOverlay && /* @__PURE__ */ jsx(
          Transition$1,
          {
            transition: "fade",
            mounted: popover.opened,
            duration: transitionProps?.duration || 250,
            exitDuration: transitionProps?.exitDuration || 250,
            children: (transitionStyles) => /* @__PURE__ */ jsx(OptionalPortal, { withinPortal, children: /* @__PURE__ */ jsx(
              Overlay,
              {
                ...overlayProps,
                ...getStyles2("overlay", {
                  className: overlayProps?.className,
                  style: [transitionStyles, overlayProps?.style]
                })
              }
            ) })
          }
        )
      ]
    }
  );
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
Popover.extend = (input) => input;
var classes$C = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const Bars = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box, { component: "span", className: clsx(classes$C.barsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$C.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$C.bar }),
  /* @__PURE__ */ jsx("span", { className: classes$C.bar })
] }));
Bars.displayName = "@mantine/core/Bars";
const Dots = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsxs(Box, { component: "span", className: clsx(classes$C.dotsLoader, className), ...others, ref, children: [
  /* @__PURE__ */ jsx("span", { className: classes$C.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$C.dot }),
  /* @__PURE__ */ jsx("span", { className: classes$C.dot })
] }));
Dots.displayName = "@mantine/core/Dots";
const Oval = forwardRef(({ className, ...others }, ref) => /* @__PURE__ */ jsx(Box, { component: "span", className: clsx(classes$C.ovalLoader, className), ...others, ref }));
Oval.displayName = "@mantine/core/Oval";
const defaultLoaders = {
  bars: Bars,
  oval: Oval,
  dots: Dots
}, defaultProps$K = {
  loaders: defaultLoaders,
  type: "oval"
}, varsResolver$I = (theme, { size: size2, color: color2 }) => ({
  root: {
    "--loader-size": getSize(size2, "loader-size"),
    "--loader-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Loader = factory((_props, ref) => {
  const props = useProps("Loader", defaultProps$K, _props), {
    size: size2,
    color: color2,
    type,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    loaders,
    variant,
    children: children2,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Loader",
    props,
    classes: classes$C,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$I
  });
  return children2 ? /* @__PURE__ */ jsx(Box, { ...getStyles2("root"), ref, ...others, children: children2 }) : /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      ref,
      component: loaders[type],
      variant,
      size: size2,
      ...others
    }
  );
});
Loader.defaultLoaders = defaultLoaders;
Loader.classes = classes$C;
Loader.displayName = "@mantine/core/Loader";
var classes$B = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" };
const defaultProps$J = {
  orientation: "horizontal"
}, varsResolver$H = (_2, { borderWidth }) => ({
  group: { "--ai-border-width": rem(borderWidth) }
}), ActionIconGroup = factory((_props, ref) => {
  const props = useProps("ActionIconGroup", defaultProps$J, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    attributes,
    ...others
  } = useProps("ActionIconGroup", defaultProps$J, _props), getStyles2 = useStyles({
    name: "ActionIconGroup",
    props,
    classes: classes$B,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$H,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ActionIconGroup.classes = classes$B;
ActionIconGroup.displayName = "@mantine/core/ActionIconGroup";
const varsResolver$G = (theme, { radius, color: color2, gradient, variant, autoContrast, size: size2 }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size2, "section-height"),
      "--section-padding-x": getSize(size2, "section-padding-x"),
      "--section-fz": getFontSize(size2),
      "--section-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--section-bg": color2 || variant ? colors.background : void 0,
      "--section-color": colors.color,
      "--section-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ActionIconGroupSection = factory((_props, ref) => {
  const props = useProps("ActionIconGroupSection", null, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "ActionIconGroupSection",
    props,
    classes: classes$B,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$G,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ jsx(Box, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ActionIconGroupSection.classes = classes$B;
ActionIconGroupSection.displayName = "@mantine/core/ActionIconGroupSection";
const varsResolver$F = (theme, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ai-size": getSize(size2, "ai-size"),
      "--ai-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ai-bg": color2 || variant ? colors.background : void 0,
      "--ai-hover": color2 || variant ? colors.hover : void 0,
      "--ai-hover-color": color2 || variant ? colors.hoverColor : void 0,
      "--ai-color": colors.color,
      "--ai-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ActionIcon = polymorphicFactory((_props, ref) => {
  const props = useProps("ActionIcon", null, _props), {
    className,
    unstyled,
    variant,
    classNames,
    styles,
    style: style2,
    loading,
    loaderProps,
    size: size2,
    color: color2,
    radius,
    __staticSelector,
    gradient,
    vars,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["ActionIcon", __staticSelector],
    props,
    className,
    style: style2,
    classes: classes$B,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$F
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      ...others,
      unstyled,
      variant,
      size: size2,
      disabled: disabled || loading,
      ref,
      mod: [{ loading, disabled: disabled || dataDisabled }, mod],
      children: [
        typeof loading == "boolean" && /* @__PURE__ */ jsx(Transition$1, { mounted: loading, transition: "slide-down", duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(Loader, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...loaderProps }) }) }),
        /* @__PURE__ */ jsx(Box, { component: "span", mod: { loading }, ...getStyles2("icon"), children: children2 })
      ]
    }
  );
});
ActionIcon.classes = classes$B;
ActionIcon.displayName = "@mantine/core/ActionIcon";
ActionIcon.Group = ActionIconGroup;
ActionIcon.GroupSection = ActionIconGroupSection;
const CloseIcon = forwardRef(
  ({ size: size2 = "var(--cb-icon-size, 70%)", style: style2, ...others }, ref) => /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style2, width: size2, height: size2 },
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
CloseIcon.displayName = "@mantine/core/CloseIcon";
var classes$A = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const defaultProps$I = {
  variant: "subtle"
}, varsResolver$E = (_2, { size: size2, radius, iconSize }) => ({
  root: {
    "--cb-size": getSize(size2, "cb-size"),
    "--cb-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cb-icon-size": rem(iconSize)
  }
}), CloseButton = polymorphicFactory((_props, ref) => {
  const props = useProps("CloseButton", defaultProps$I, _props), {
    iconSize,
    children: children2,
    vars,
    radius,
    className,
    classNames,
    style: style2,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    disabled,
    variant,
    icon,
    mod,
    attributes,
    __staticSelector,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector || "CloseButton",
    props,
    className,
    style: style2,
    classes: classes$A,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$E
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...others,
      unstyled,
      variant,
      disabled,
      mod: [{ disabled: disabled || dataDisabled }, mod],
      ...getStyles2("root", { variant, active: !disabled && !dataDisabled }),
      children: [
        icon || /* @__PURE__ */ jsx(CloseIcon, {}),
        children2
      ]
    }
  );
});
CloseButton.classes = classes$A;
CloseButton.displayName = "@mantine/core/CloseButton";
function filterFalsyChildren(children2) {
  return Children.toArray(children2).filter(Boolean);
}
var classes$z = { root: "m_4081bf90" };
const defaultProps$H = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, varsResolver$D = (_2, { grow, preventGrowOverflow, gap, align, justify, wrap: wrap2 }, { childWidth }) => ({
  root: {
    "--group-child-width": grow && preventGrowOverflow ? childWidth : void 0,
    "--group-gap": getSpacing(gap),
    "--group-align": align,
    "--group-justify": justify,
    "--group-wrap": wrap2
  }
}), Group = factory((_props, ref) => {
  const props = useProps("Group", defaultProps$H, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    children: children2,
    gap,
    align,
    justify,
    wrap: wrap2,
    grow,
    preventGrowOverflow,
    vars,
    variant,
    __size,
    mod,
    attributes,
    ...others
  } = props, filteredChildren = filterFalsyChildren(children2), childrenCount = filteredChildren.length, resolvedGap = getSpacing(gap ?? "md"), stylesCtx = { childWidth: `calc(${100 / childrenCount}% - (${resolvedGap} - ${resolvedGap} / ${childrenCount}))` }, getStyles2 = useStyles({
    name: "Group",
    props,
    stylesCtx,
    className,
    style: style2,
    classes: classes$z,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$D
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      ref,
      variant,
      mod: [{ grow }, mod],
      size: __size,
      ...others,
      children: filteredChildren
    }
  );
});
Group.classes = classes$z;
Group.displayName = "@mantine/core/Group";
const [ModalBaseProvider, useModalBaseContext] = createSafeContext(
  "ModalBase component was not found in tree"
);
function useLockScroll({ opened, transitionDuration }) {
  const [shouldLockScroll, setShouldLockScroll] = useState(opened), timeout2 = useRef(-1), _transitionDuration = useReducedMotion$1() ? 0 : transitionDuration;
  return useEffect(() => (opened ? (setShouldLockScroll(!0), window.clearTimeout(timeout2.current)) : _transitionDuration === 0 ? setShouldLockScroll(!1) : timeout2.current = window.setTimeout(() => setShouldLockScroll(!1), _transitionDuration), () => window.clearTimeout(timeout2.current)), [opened, _transitionDuration]), shouldLockScroll;
}
function useModal({
  id: id2,
  transitionProps,
  opened,
  trapFocus,
  closeOnEscape: closeOnEscape2,
  onClose,
  returnFocus
}) {
  const _id = useId$1(id2), [titleMounted, setTitleMounted] = useState(!1), [bodyMounted, setBodyMounted] = useState(!1), transitionDuration = typeof transitionProps?.duration == "number" ? transitionProps?.duration : 200, shouldLockScroll = useLockScroll({ opened, transitionDuration });
  return useWindowEvent(
    "keydown",
    (event) => {
      event.key === "Escape" && closeOnEscape2 && !event.isComposing && opened && event.target?.getAttribute("data-mantine-stop-propagation") !== "true" && onClose();
    },
    { capture: !0 }
  ), useFocusReturn({ opened, shouldReturnFocus: trapFocus && returnFocus }), {
    _id,
    titleMounted,
    bodyMounted,
    shouldLockScroll,
    setTitleMounted,
    setBodyMounted
  };
}
const ModalBase = forwardRef(
  ({
    keepMounted,
    opened,
    onClose,
    id: id2,
    transitionProps,
    onExitTransitionEnd,
    onEnterTransitionEnd,
    trapFocus,
    closeOnEscape: closeOnEscape2,
    returnFocus,
    closeOnClickOutside,
    withinPortal,
    portalProps,
    lockScroll,
    children: children2,
    zIndex,
    shadow,
    padding,
    __vars,
    unstyled,
    removeScrollProps,
    ...others
  }, ref) => {
    const { _id, titleMounted, bodyMounted, shouldLockScroll, setTitleMounted, setBodyMounted } = useModal({ id: id2, transitionProps, opened, trapFocus, closeOnEscape: closeOnEscape2, onClose, returnFocus }), { key: removeScrollKey, ...otherRemoveScrollProps } = removeScrollProps || {};
    return /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      ModalBaseProvider,
      {
        value: {
          opened,
          onClose,
          closeOnClickOutside,
          onExitTransitionEnd,
          onEnterTransitionEnd,
          transitionProps: { ...transitionProps, keepMounted },
          getTitleId: () => `${_id}-title`,
          getBodyId: () => `${_id}-body`,
          titleMounted,
          bodyMounted,
          setTitleMounted,
          setBodyMounted,
          trapFocus,
          closeOnEscape: closeOnEscape2,
          zIndex,
          unstyled
        },
        children: /* @__PURE__ */ jsx(
          ReactRemoveScroll,
          {
            enabled: shouldLockScroll && lockScroll,
            ...otherRemoveScrollProps,
            children: /* @__PURE__ */ jsx(
              Box,
              {
                ref,
                ...others,
                __vars: {
                  ...__vars,
                  "--mb-z-index": (zIndex || getDefaultZIndex("modal")).toString(),
                  "--mb-shadow": getShadow(shadow),
                  "--mb-padding": getSpacing(padding)
                },
                children: children2
              }
            )
          },
          removeScrollKey
        )
      }
    ) });
  }
);
ModalBase.displayName = "@mantine/core/ModalBase";
function useModalBodyId() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setBodyMounted(!0), () => ctx.setBodyMounted(!1)), []), ctx.getBodyId();
}
var classes$y = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" };
const ModalBaseBody = forwardRef(
  ({ className, ...others }, ref) => {
    const bodyId = useModalBodyId(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...others,
        id: bodyId,
        className: clsx({ [classes$y.body]: !ctx.unstyled }, className)
      }
    );
  }
);
ModalBaseBody.displayName = "@mantine/core/ModalBaseBody";
const ModalBaseCloseButton = forwardRef(
  ({ className, onClick, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      CloseButton,
      {
        ref,
        ...others,
        onClick: (event) => {
          ctx.onClose(), onClick?.(event);
        },
        className: clsx({ [classes$y.close]: !ctx.unstyled }, className),
        unstyled: ctx.unstyled
      }
    );
  }
);
ModalBaseCloseButton.displayName = "@mantine/core/ModalBaseCloseButton";
const ModalBaseContent = forwardRef(
  ({ transitionProps, className, innerProps, onKeyDown, style: style2, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Transition$1,
      {
        mounted: ctx.opened,
        transition: "pop",
        ...ctx.transitionProps,
        onExited: () => {
          ctx.onExitTransitionEnd?.(), ctx.transitionProps?.onExited?.();
        },
        onEntered: () => {
          ctx.onEnterTransitionEnd?.(), ctx.transitionProps?.onEntered?.();
        },
        ...transitionProps,
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          "div",
          {
            ...innerProps,
            className: clsx({ [classes$y.inner]: !ctx.unstyled }, innerProps.className),
            children: /* @__PURE__ */ jsx(FocusTrap, { active: ctx.opened && ctx.trapFocus, innerRef: ref, children: /* @__PURE__ */ jsx(
              Paper,
              {
                ...others,
                component: "section",
                role: "dialog",
                tabIndex: -1,
                "aria-modal": !0,
                "aria-describedby": ctx.bodyMounted ? ctx.getBodyId() : void 0,
                "aria-labelledby": ctx.titleMounted ? ctx.getTitleId() : void 0,
                style: [style2, transitionStyles],
                className: clsx({ [classes$y.content]: !ctx.unstyled }, className),
                unstyled: ctx.unstyled,
                children: others.children
              }
            ) })
          }
        )
      }
    );
  }
);
ModalBaseContent.displayName = "@mantine/core/ModalBaseContent";
const ModalBaseHeader = forwardRef(
  ({ className, ...others }, ref) => {
    const ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        component: "header",
        ref,
        className: clsx({ [classes$y.header]: !ctx.unstyled }, className),
        ...others
      }
    );
  }
);
ModalBaseHeader.displayName = "@mantine/core/ModalBaseHeader";
const DEFAULT_TRANSITION = {
  duration: 200,
  timingFunction: "ease",
  transition: "fade"
};
function useModalTransition(transitionOverride) {
  const ctx = useModalBaseContext();
  return { ...DEFAULT_TRANSITION, ...ctx.transitionProps, ...transitionOverride };
}
const ModalBaseOverlay = forwardRef(
  ({ onClick, transitionProps, style: style2, visible: visible2, ...others }, ref) => {
    const ctx = useModalBaseContext(), transition = useModalTransition(transitionProps);
    return /* @__PURE__ */ jsx(
      Transition$1,
      {
        mounted: visible2 !== void 0 ? visible2 : ctx.opened,
        ...transition,
        transition: "fade",
        children: (transitionStyles) => /* @__PURE__ */ jsx(
          Overlay,
          {
            ref,
            fixed: !0,
            style: [style2, transitionStyles],
            zIndex: ctx.zIndex,
            unstyled: ctx.unstyled,
            onClick: (event) => {
              onClick?.(event), ctx.closeOnClickOutside && ctx.onClose();
            },
            ...others
          }
        )
      }
    );
  }
);
ModalBaseOverlay.displayName = "@mantine/core/ModalBaseOverlay";
function useModalTitle() {
  const ctx = useModalBaseContext();
  return useEffect(() => (ctx.setTitleMounted(!0), () => ctx.setTitleMounted(!1)), []), ctx.getTitleId();
}
const ModalBaseTitle = forwardRef(
  ({ className, ...others }, ref) => {
    const id2 = useModalTitle(), ctx = useModalBaseContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        component: "h2",
        ref,
        className: clsx({ [classes$y.title]: !ctx.unstyled }, className),
        ...others,
        id: id2
      }
    );
  }
);
ModalBaseTitle.displayName = "@mantine/core/ModalBaseTitle";
function NativeScrollArea({ children: children2 }) {
  return /* @__PURE__ */ jsx(Fragment$1, { children: children2 });
}
const [InputContext, useInputContext] = createOptionalContext({
  size: "sm"
}), InputClearButton = factory((_props, ref) => {
  const props = useProps("InputClearButton", null, _props), { size: size2, variant, vars, classNames, styles, ...others } = props, ctx = useInputContext(), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return /* @__PURE__ */ jsx(
    CloseButton,
    {
      variant: variant || "transparent",
      ref,
      size: size2 || ctx?.size || "sm",
      classNames: resolvedClassNames,
      styles: resolvedStyles,
      __staticSelector: "InputClearButton",
      style: { pointerEvents: "all", background: "var(--input-bg)", ...others.style },
      ...others
    }
  );
});
InputClearButton.displayName = "@mantine/core/InputClearButton";
const clearSectionOffset = {
  xs: 7,
  sm: 8,
  md: 10,
  lg: 12,
  xl: 15
};
function InputClearSection({
  __clearable,
  __clearSection,
  rightSection,
  __defaultRightSection,
  size: size2 = "sm"
}) {
  const clearSection = __clearable && __clearSection;
  return clearSection && (rightSection || __defaultRightSection) ? /* @__PURE__ */ jsxs(
    "div",
    {
      "data-combined-clear-section": !0,
      style: {
        display: "flex",
        gap: 2,
        alignItems: "center",
        paddingInlineEnd: clearSectionOffset[size2]
      },
      children: [
        clearSection,
        rightSection || __defaultRightSection
      ]
    }
  ) : rightSection === null ? null : rightSection || clearSection || __defaultRightSection;
}
const [InputWrapperProvider, useInputWrapperContext] = createOptionalContext({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
});
var classes$x = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const varsResolver$C = (_2, { size: size2 }) => ({
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputDescription = factory((_props, ref) => {
  const props = useProps("InputDescription", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    __staticSelector,
    __inheritStyles = !0,
    attributes,
    variant,
    ...others
  } = useProps("InputDescription", null, props), ctx = useInputWrapperContext(), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "description",
    vars,
    varsResolver: varsResolver$C
  }), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("description", ctx?.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputDescription.classes = classes$x;
InputDescription.displayName = "@mantine/core/InputDescription";
const varsResolver$B = (_2, { size: size2 }) => ({
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputError = factory((_props, ref) => {
  const props = useProps("InputError", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    attributes,
    __staticSelector,
    __inheritStyles = !0,
    variant,
    ...others
  } = props, _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "error",
    vars,
    varsResolver: varsResolver$B
  }), ctx = useInputWrapperContext(), getStyles2 = __inheritStyles && ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "p",
      ref,
      variant,
      size: size2,
      ...getStyles2("error", ctx?.getStyles ? { className, style: style2 } : void 0),
      ...others
    }
  );
});
InputError.classes = classes$x;
InputError.displayName = "@mantine/core/InputError";
const defaultProps$G = {
  labelElement: "label"
}, varsResolver$A = (_2, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  }
}), InputLabel = factory((_props, ref) => {
  const props = useProps("InputLabel", defaultProps$G, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    labelElement,
    size: size2,
    required: required2,
    htmlFor,
    onMouseDown,
    children: children2,
    __staticSelector,
    variant,
    mod,
    attributes,
    ...others
  } = useProps("InputLabel", defaultProps$G, props), _getStyles = useStyles({
    name: ["InputWrapper", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "label",
    vars,
    varsResolver: varsResolver$A
  }), ctx = useInputWrapperContext(), getStyles2 = ctx?.getStyles || _getStyles;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("label", ctx?.getStyles ? { className, style: style2 } : void 0),
      component: labelElement,
      variant,
      size: size2,
      ref,
      htmlFor: labelElement === "label" ? htmlFor : void 0,
      mod: [{ required: required2 }, mod],
      onMouseDown: (event) => {
        onMouseDown?.(event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      ...others,
      children: [
        children2,
        required2 && /* @__PURE__ */ jsx("span", { ...getStyles2("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
InputLabel.classes = classes$x;
InputLabel.displayName = "@mantine/core/InputLabel";
const InputPlaceholder = factory((_props, ref) => {
  const props = useProps("InputPlaceholder", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    __staticSelector,
    variant,
    error,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputPlaceholder", __staticSelector],
    props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("placeholder"),
      mod: [{ error: !!error }, mod],
      component: "span",
      variant,
      ref,
      ...others
    }
  );
});
InputPlaceholder.classes = classes$x;
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
function getInputOffsets(inputWrapperOrder, { hasDescription, hasError }) {
  const inputIndex = inputWrapperOrder.findIndex((part) => part === "input"), aboveInput = inputWrapperOrder.slice(0, inputIndex), belowInput = inputWrapperOrder.slice(inputIndex + 1), offsetTop = hasDescription && aboveInput.includes("description") || hasError && aboveInput.includes("error");
  return { offsetBottom: hasDescription && belowInput.includes("description") || hasError && belowInput.includes("error"), offsetTop };
}
const defaultProps$F = {
  labelElement: "label",
  inputContainer: (children2) => children2,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, varsResolver$z = (_2, { size: size2 }) => ({
  label: {
    "--input-label-size": getFontSize(size2),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  },
  description: {
    "--input-description-size": size2 === void 0 ? void 0 : `calc(${getFontSize(size2)} - ${rem(2)})`
  }
}), InputWrapper = factory((_props, ref) => {
  const props = useProps("InputWrapper", defaultProps$F, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    variant,
    __staticSelector,
    inputContainer,
    inputWrapperOrder,
    label,
    error,
    description,
    labelProps,
    descriptionProps,
    errorProps,
    labelElement,
    children: children2,
    withAsterisk,
    id: id2,
    required: required2,
    __stylesApiProps,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["InputWrapper", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$z
  }), sharedProps = {
    size: size2,
    variant,
    __staticSelector
  }, idBase = useId$1(id2), isRequired = typeof withAsterisk == "boolean" ? withAsterisk : required2, errorId = errorProps?.id || `${idBase}-error`, descriptionId = descriptionProps?.id || `${idBase}-description`, inputId = idBase, hasError = !!error && typeof error != "boolean", hasDescription = !!description, _describedBy = `${hasError ? errorId : ""} ${hasDescription ? descriptionId : ""}`, describedBy = _describedBy.trim().length > 0 ? _describedBy.trim() : void 0, labelId = labelProps?.id || `${idBase}-label`, _label = label && /* @__PURE__ */ jsx(
    InputLabel,
    {
      labelElement,
      id: labelId,
      htmlFor: inputId,
      required: isRequired,
      ...sharedProps,
      ...labelProps,
      children: label
    },
    "label"
  ), _description = hasDescription && /* @__PURE__ */ jsx(
    InputDescription,
    {
      ...descriptionProps,
      ...sharedProps,
      size: descriptionProps?.size || sharedProps.size,
      id: descriptionProps?.id || descriptionId,
      children: description
    },
    "description"
  ), _input = /* @__PURE__ */ jsx(Fragment, { children: inputContainer(children2) }, "input"), _error = hasError && /* @__PURE__ */ createElement(
    InputError,
    {
      ...errorProps,
      ...sharedProps,
      size: errorProps?.size || sharedProps.size,
      key: "error",
      id: errorProps?.id || errorId
    },
    error
  ), content = inputWrapperOrder.map((part) => {
    switch (part) {
      case "label":
        return _label;
      case "input":
        return _input;
      case "description":
        return _description;
      case "error":
        return _error;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsx(
    InputWrapperProvider,
    {
      value: {
        getStyles: getStyles2,
        describedBy,
        inputId,
        labelId,
        ...getInputOffsets(inputWrapperOrder, { hasDescription, hasError })
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ref,
          variant,
          size: size2,
          mod: [{ error: !!error }, mod],
          ...getStyles2("root"),
          ...others,
          children: content
        }
      )
    }
  );
});
InputWrapper.classes = classes$x;
InputWrapper.displayName = "@mantine/core/InputWrapper";
const defaultProps$E = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0,
  size: "sm"
}, varsResolver$y = (_2, props, ctx) => ({
  wrapper: {
    "--input-margin-top": ctx.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": ctx.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": getSize(props.size, "input-height"),
    "--input-fz": getFontSize(props.size),
    "--input-radius": props.radius === void 0 ? void 0 : getRadius$1(props.radius),
    "--input-left-section-width": props.leftSectionWidth !== void 0 ? rem(props.leftSectionWidth) : void 0,
    "--input-right-section-width": props.rightSectionWidth !== void 0 ? rem(props.rightSectionWidth) : void 0,
    "--input-padding-y": props.multiline ? getSize(props.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": props.leftSectionPointerEvents,
    "--input-right-section-pointer-events": props.rightSectionPointerEvents
  }
}), Input = polymorphicFactory((_props, ref) => {
  const props = useProps("Input", defaultProps$E, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    required: required2,
    __staticSelector,
    __stylesApiProps,
    size: size2,
    wrapperProps,
    error,
    disabled,
    leftSection,
    leftSectionProps,
    leftSectionWidth,
    rightSection,
    rightSectionProps,
    rightSectionWidth,
    rightSectionPointerEvents,
    leftSectionPointerEvents,
    variant,
    vars,
    pointer: pointer2,
    multiline,
    radius,
    id: id2,
    withAria,
    withErrorStyles,
    mod,
    inputSize,
    attributes,
    __clearSection,
    __clearable,
    __defaultRightSection,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), ctx = useInputWrapperContext(), stylesCtx = { offsetBottom: ctx?.offsetBottom, offsetTop: ctx?.offsetTop }, getStyles2 = useStyles({
    name: ["Input", __staticSelector],
    props: __stylesApiProps || props,
    classes: classes$x,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    stylesCtx,
    rootSelector: "wrapper",
    vars,
    varsResolver: varsResolver$y
  }), ariaAttributes = withAria ? {
    required: required2,
    disabled,
    "aria-invalid": !!error,
    "aria-describedby": ctx?.describedBy,
    id: ctx?.inputId || id2
  } : {}, _rightSection = InputClearSection({
    __clearable,
    __clearSection,
    rightSection,
    __defaultRightSection,
    size: size2
  });
  return /* @__PURE__ */ jsx(InputContext, { value: { size: size2 || "sm" }, children: /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("wrapper"),
      ...styleProps,
      ...wrapperProps,
      mod: [
        {
          error: !!error && withErrorStyles,
          pointer: pointer2,
          disabled,
          multiline,
          "data-with-right-section": !!_rightSection,
          "data-with-left-section": !!leftSection
        },
        mod
      ],
      variant,
      size: size2,
      children: [
        leftSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...leftSectionProps,
            "data-position": "left",
            ...getStyles2("section", {
              className: leftSectionProps?.className,
              style: leftSectionProps?.style
            }),
            children: leftSection
          }
        ),
        /* @__PURE__ */ jsx(
          Box,
          {
            component: "input",
            ...rest,
            ...ariaAttributes,
            ref,
            required: required2,
            mod: { disabled, error: !!error && withErrorStyles },
            variant,
            __size: inputSize,
            ...getStyles2("input")
          }
        ),
        _rightSection && /* @__PURE__ */ jsx(
          "div",
          {
            ...rightSectionProps,
            "data-position": "right",
            ...getStyles2("section", {
              className: rightSectionProps?.className,
              style: rightSectionProps?.style
            }),
            children: _rightSection
          }
        )
      ]
    }
  ) });
});
Input.classes = classes$x;
Input.Wrapper = InputWrapper;
Input.Label = InputLabel;
Input.Error = InputError;
Input.Description = InputDescription;
Input.Placeholder = InputPlaceholder;
Input.ClearButton = InputClearButton;
Input.displayName = "@mantine/core/Input";
function useInputProps(component, defaultProps2, _props) {
  const props = useProps(component, defaultProps2, _props), {
    label,
    description,
    error,
    required: required2,
    classNames,
    styles,
    className,
    unstyled,
    __staticSelector,
    __stylesApiProps,
    errorProps,
    labelProps,
    descriptionProps,
    wrapperProps: _wrapperProps,
    id: id2,
    size: size2,
    style: style2,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    vars,
    mod,
    attributes,
    ...others
  } = props, { styleProps, rest } = extractStyleProps(others), wrapperProps = {
    label,
    description,
    error,
    required: required2,
    classNames,
    className,
    __staticSelector,
    __stylesApiProps: __stylesApiProps || props,
    errorProps,
    labelProps,
    descriptionProps,
    unstyled,
    styles,
    size: size2,
    style: style2,
    inputContainer,
    inputWrapperOrder,
    withAsterisk,
    variant,
    id: id2,
    mod,
    attributes,
    ..._wrapperProps
  };
  return {
    ...rest,
    classNames,
    styles,
    unstyled,
    wrapperProps: { ...wrapperProps, ...styleProps },
    inputProps: {
      required: required2,
      classNames,
      styles,
      unstyled,
      size: size2,
      __staticSelector,
      __stylesApiProps: __stylesApiProps || props,
      error,
      variant,
      id: id2,
      attributes
    }
  };
}
const defaultProps$D = {
  __staticSelector: "InputBase",
  withAria: !0,
  size: "sm"
}, InputBase = polymorphicFactory((props, ref) => {
  const { inputProps, wrapperProps, ...others } = useInputProps("InputBase", defaultProps$D, props);
  return /* @__PURE__ */ jsx(Input.Wrapper, { ...wrapperProps, children: /* @__PURE__ */ jsx(Input, { ...inputProps, ...others, ref }) });
});
InputBase.classes = { ...Input.classes, ...Input.Wrapper.classes };
InputBase.displayName = "@mantine/core/InputBase";
const FLEX_STYLE_PROPS_DATA = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var classes$w = { root: "m_8bffd616" };
const Flex = polymorphicFactory((_props, ref) => {
  const props = useProps("Flex", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    gap,
    rowGap,
    columnGap,
    align,
    justify,
    wrap: wrap2,
    direction,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Flex",
    classes: classes$w,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars
  }), theme = useMantineTheme(), responsiveClassName = useRandomClassName(), parsedStyleProps = parseStyleProps({
    styleProps: { gap, rowGap, columnGap, align, justify, wrap: wrap2, direction },
    theme,
    data: FLEX_STYLE_PROPS_DATA
  });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    parsedStyleProps.hasResponsiveStyles && /* @__PURE__ */ jsx(
      InlineStyles,
      {
        selector: `.${responsiveClassName}`,
        styles: parsedStyleProps.styles,
        media: parsedStyleProps.media
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...getStyles2("root", {
          className: responsiveClassName,
          style: filterProps$1(parsedStyleProps.inlineStyles)
        }),
        ...others
      }
    )
  ] });
});
Flex.classes = classes$w;
Flex.displayName = "@mantine/core/Flex";
function isParent(parentElement, childElement) {
  if (!childElement || !parentElement)
    return !1;
  let parent = childElement.parentNode;
  for (; parent != null; ) {
    if (parent === parentElement)
      return !0;
    parent = parent.parentNode;
  }
  return !1;
}
function useFloatingIndicator({
  target,
  parent,
  ref,
  displayAfterTransitionEnd
}) {
  const transitionTimeout = useRef(-1), [initialized, setInitialized] = useState(!1), [hidden2, setHidden] = useState(
    typeof displayAfterTransitionEnd == "boolean" ? displayAfterTransitionEnd : !1
  ), updatePosition = () => {
    if (!target || !parent || !ref.current)
      return;
    const targetRect = target.getBoundingClientRect(), parentRect = parent.getBoundingClientRect(), targetComputedStyle = window.getComputedStyle(target), parentComputedStyle = window.getComputedStyle(parent), borderTopWidth = toInt(targetComputedStyle.borderTopWidth) + toInt(parentComputedStyle.borderTopWidth), borderLeftWidth = toInt(targetComputedStyle.borderLeftWidth) + toInt(parentComputedStyle.borderLeftWidth), position = {
      top: targetRect.top - parentRect.top - borderTopWidth,
      left: targetRect.left - parentRect.left - borderLeftWidth,
      width: targetRect.width,
      height: targetRect.height
    };
    ref.current.style.transform = `translateY(${position.top}px) translateX(${position.left}px)`, ref.current.style.width = `${position.width}px`, ref.current.style.height = `${position.height}px`;
  }, updatePositionWithoutAnimation = () => {
    window.clearTimeout(transitionTimeout.current), ref.current && (ref.current.style.transitionDuration = "0ms"), updatePosition(), transitionTimeout.current = window.setTimeout(() => {
      ref.current && (ref.current.style.transitionDuration = "");
    }, 30);
  }, targetResizeObserver = useRef(null), parentResizeObserver = useRef(null);
  return useEffect(() => {
    if (updatePosition(), target)
      return targetResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), targetResizeObserver.current.observe(target), parent && (parentResizeObserver.current = new ResizeObserver(updatePositionWithoutAnimation), parentResizeObserver.current.observe(parent)), () => {
        targetResizeObserver.current?.disconnect(), parentResizeObserver.current?.disconnect();
      };
  }, [parent, target]), useEffect(() => {
    if (parent) {
      const handleTransitionEnd = (event) => {
        isParent(event.target, parent) && (updatePositionWithoutAnimation(), setHidden(!1));
      };
      return parent.addEventListener("transitionend", handleTransitionEnd), () => {
        parent.removeEventListener("transitionend", handleTransitionEnd);
      };
    }
  }, [parent]), useTimeout(
    () => {
      getEnv() !== "test" && setInitialized(!0);
    },
    20,
    { autoInvoke: !0 }
  ), useMutationObserver(
    (mutations) => {
      mutations.forEach((mutation) => {
        mutation.type === "attributes" && mutation.attributeName === "dir" && updatePositionWithoutAnimation();
      });
    },
    { attributes: !0, attributeFilter: ["dir"] },
    () => document.documentElement
  ), { initialized, hidden: hidden2 };
}
var classes$v = { root: "m_96b553a6" };
const varsResolver$x = (_theme, { transitionDuration }) => ({
  root: {
    "--transition-duration": typeof transitionDuration == "number" ? `${transitionDuration}ms` : transitionDuration
  }
}), FloatingIndicator = factory((_props, ref) => {
  const props = useProps("FloatingIndicator", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    target,
    parent,
    transitionDuration,
    mod,
    displayAfterTransitionEnd,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "FloatingIndicator",
    classes: classes$v,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$x
  }), innerRef = useRef(null), { initialized, hidden: hidden2 } = useFloatingIndicator({
    target,
    parent,
    ref: innerRef,
    displayAfterTransitionEnd
  }), mergedRef = useMergedRef(ref, innerRef);
  return !target || !parent ? null : /* @__PURE__ */ jsx(Box, { ref: mergedRef, mod: [{ initialized, hidden: hidden2 }, mod], ...getStyles2("root"), ...others });
});
FloatingIndicator.displayName = "@mantine/core/FloatingIndicator";
FloatingIndicator.classes = classes$v;
function useDelayedHover({ open, close, openDelay, closeDelay }) {
  const openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = () => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, openDropdown = () => {
    clearTimeouts(), openDelay === 0 || openDelay === void 0 ? open() : openTimeout.current = window.setTimeout(open, openDelay);
  }, closeDropdown = () => {
    clearTimeouts(), closeDelay === 0 || closeDelay === void 0 ? close() : closeTimeout.current = window.setTimeout(close, closeDelay);
  };
  return useEffect(() => clearTimeouts, []), { openDropdown, closeDropdown };
}
function AccordionChevron({ style: style2, size: size2 = 16, ...others }) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...style2, width: rem(size2), height: rem(size2), display: "block" },
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
AccordionChevron.displayName = "@mantine/core/AccordionChevron";
var classes$u = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };
const varsResolver$w = (theme, { radius, color: color2, variant, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--alert-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--alert-bg": color2 || variant ? colors.background : void 0,
      "--alert-color": colors.color,
      "--alert-bd": color2 || variant ? colors.border : void 0
    }
  };
}, Alert = factory((_props, ref) => {
  const props = useProps("Alert", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color: color2,
    title,
    children: children2,
    id: id2,
    icon,
    withCloseButton,
    onClose,
    closeButtonLabel,
    variant,
    autoContrast,
    role,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Alert",
    classes: classes$u,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$w
  }), rootId = useId$1(id2), titleId = title && `${rootId}-title` || void 0, bodyId = `${rootId}-body`;
  return /* @__PURE__ */ jsx(
    Box,
    {
      id: rootId,
      ...getStyles2("root", { variant }),
      variant,
      ref,
      role: role || "alert",
      ...others,
      "aria-describedby": children2 ? bodyId : void 0,
      "aria-labelledby": title ? titleId : void 0,
      children: /* @__PURE__ */ jsxs("div", { ...getStyles2("wrapper"), children: [
        icon && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), "data-with-close-button": withCloseButton || void 0, children: /* @__PURE__ */ jsx("span", { id: titleId, ...getStyles2("label"), children: title }) }),
          children2 && /* @__PURE__ */ jsx("div", { id: bodyId, ...getStyles2("message"), "data-variant": variant, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            ...getStyles2("closeButton"),
            onClick: onClose,
            variant: "transparent",
            size: 16,
            iconSize: 16,
            "aria-label": closeButtonLabel,
            unstyled
          }
        )
      ] })
    }
  );
});
Alert.classes = classes$u;
Alert.displayName = "@mantine/core/Alert";
var classes$t = { root: "m_b6d8b162" };
function getTextTruncate(truncate) {
  if (truncate === "start")
    return "start";
  if (truncate === "end" || truncate)
    return "end";
}
const defaultProps$C = {
  inherit: !1
}, varsResolver$v = /* Will be removed in 9.0 */ /* eslint-disable-next-line @typescript-eslint/no-deprecated */ (theme, { variant, lineClamp, gradient, size: size2, color: color2 }) => ({
  root: {
    "--text-fz": getFontSize(size2),
    "--text-lh": getLineHeight(size2),
    "--text-gradient": variant === "gradient" ? getGradient(gradient, theme) : void 0,
    "--text-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
    "--text-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Text = polymorphicFactory((_props, ref) => {
  const props = useProps("Text", defaultProps$C, _props), {
    lineClamp,
    truncate,
    inline: inline2,
    inherit: inherit2,
    gradient,
    span,
    __staticSelector,
    vars,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    variant,
    mod,
    size: size2,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: ["Text", __staticSelector],
    props,
    classes: classes$t,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$v
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root", { focusable: !0 }),
      ref,
      component: span ? "span" : "p",
      variant,
      mod: [
        {
          "data-truncate": getTextTruncate(truncate),
          "data-line-clamp": typeof lineClamp == "number",
          "data-inline": inline2,
          "data-inherit": inherit2
        },
        mod
      ],
      size: size2,
      ...others
    }
  );
});
Text.classes = classes$t;
Text.displayName = "@mantine/core/Text";
var classes$s = { root: "m_849cf0da" };
const defaultProps$B = {
  underline: "hover"
}, Anchor = polymorphicFactory((props, ref) => {
  const { underline, className, unstyled, mod, ...others } = useProps(
    "Anchor",
    defaultProps$B,
    props
  );
  return /* @__PURE__ */ jsx(
    Text,
    {
      component: "a",
      ref,
      className: clsx({ [classes$s.root]: !unstyled }, className),
      ...others,
      mod: [{ underline }, mod],
      __staticSelector: "Anchor",
      unstyled
    }
  );
});
Anchor.classes = classes$s;
Anchor.displayName = "@mantine/core/Anchor";
function parseItem(item) {
  return typeof item == "string" ? { value: item, label: item } : "value" in item && !("label" in item) ? { value: item.value, label: item.value, disabled: item.disabled } : typeof item == "number" ? { value: item.toString(), label: item.toString() } : "group" in item ? {
    group: item.group,
    items: item.items.map((i2) => parseItem(i2))
  } : item;
}
function getParsedComboboxData(data) {
  return data ? data.map((item) => parseItem(item)) : [];
}
function getOptionsLockup(options) {
  return options.reduce((acc, item) => "group" in item ? { ...acc, ...getOptionsLockup(item.items) } : (acc[item.value] = item, acc), {});
}
var classes$r = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2", optionsDropdownCheckPlaceholder: "m_a530ee0a" };
const defaultProps$A = {
  error: null
}, varsResolver$u = (theme, { size: size2, color: color2 }) => ({
  chevron: {
    "--combobox-chevron-size": getSize(size2, "combobox-chevron-size"),
    "--combobox-chevron-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), ComboboxChevron = factory((_props, ref) => {
  const props = useProps("ComboboxChevron", defaultProps$A, _props), { size: size2, error, style: style2, className, classNames, styles, unstyled, vars, mod, ...others } = props, getStyles2 = useStyles({
    name: "ComboboxChevron",
    classes: classes$r,
    props,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver$u,
    rootSelector: "chevron"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "svg",
      ...others,
      ...getStyles2("chevron"),
      size: size2,
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      mod: ["combobox-chevron", { error }, mod],
      ref,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
});
ComboboxChevron.classes = classes$r;
ComboboxChevron.displayName = "@mantine/core/ComboboxChevron";
const [ComboboxProvider, useComboboxContext] = createSafeContext(
  "Combobox component was not found in tree"
), ComboboxClearButton = forwardRef(
  ({ size: size2, onMouseDown, onClick, onClear, ...others }, ref) => /* @__PURE__ */ jsx(
    Input.ClearButton,
    {
      ref,
      tabIndex: -1,
      "aria-hidden": !0,
      ...others,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onClick: (event) => {
        onClear(), onClick?.(event);
      }
    }
  )
);
ComboboxClearButton.displayName = "@mantine/core/ComboboxClearButton";
const ComboboxDropdown = factory((props, ref) => {
  const { classNames, styles, className, style: style2, hidden: hidden2, ...others } = useProps(
    "ComboboxDropdown",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Popover.Dropdown,
    {
      ...others,
      ref,
      role: "presentation",
      "data-hidden": hidden2 || void 0,
      ...ctx.getStyles("dropdown", { className, style: style2, classNames, styles })
    }
  );
});
ComboboxDropdown.classes = classes$r;
ComboboxDropdown.displayName = "@mantine/core/ComboboxDropdown";
const defaultProps$z = {
  refProp: "ref"
}, ComboboxDropdownTarget = factory((props, ref) => {
  const { children: children2, refProp } = useProps("ComboboxDropdownTarget", defaultProps$z, props);
  if (useComboboxContext(), !isElement$1(children2))
    throw new Error(
      "Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return /* @__PURE__ */ jsx(Popover.Target, { ref, refProp, children: children2 });
});
ComboboxDropdownTarget.displayName = "@mantine/core/ComboboxDropdownTarget";
const ComboboxEmpty = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxEmpty",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("empty", { className, classNames, styles, style: style2 }),
      ...others
    }
  );
});
ComboboxEmpty.classes = classes$r;
ComboboxEmpty.displayName = "@mantine/core/ComboboxEmpty";
function useComboboxTargetProps({
  onKeyDown,
  withKeyboardNavigation,
  withAriaAttributes,
  withExpandedAttribute,
  targetType,
  autoComplete
}) {
  const ctx = useComboboxContext(), [selectedOptionId, setSelectedOptionId] = useState(null), handleKeyDown = (event) => {
    if (onKeyDown?.(event), !ctx.readOnly && withKeyboardNavigation) {
      if (event.nativeEvent.isComposing)
        return;
      if (event.nativeEvent.code === "ArrowDown" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectNextOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "ArrowUp" && (event.preventDefault(), ctx.store.dropdownOpened ? setSelectedOptionId(ctx.store.selectPreviousOption()) : (ctx.store.openDropdown("keyboard"), setSelectedOptionId(ctx.store.selectActiveOption()), ctx.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), event.nativeEvent.code === "Enter" || event.nativeEvent.code === "NumpadEnter") {
        if (event.nativeEvent.keyCode === 229)
          return;
        const selectedOptionIndex = ctx.store.getSelectedOptionIndex();
        ctx.store.dropdownOpened && selectedOptionIndex !== -1 ? (event.preventDefault(), ctx.store.clickSelectedOption()) : targetType === "button" && (event.preventDefault(), ctx.store.openDropdown("keyboard"));
      }
      event.key === "Escape" && ctx.store.closeDropdown("keyboard"), event.nativeEvent.code === "Space" && targetType === "button" && (event.preventDefault(), ctx.store.toggleDropdown("keyboard"));
    }
  };
  return {
    ...withAriaAttributes ? {
      "aria-haspopup": "listbox",
      "aria-expanded": withExpandedAttribute ? !!(ctx.store.listId && ctx.store.dropdownOpened) : void 0,
      "aria-controls": ctx.store.dropdownOpened && ctx.store.listId ? ctx.store.listId : void 0,
      "aria-activedescendant": ctx.store.dropdownOpened && selectedOptionId || void 0,
      autoComplete,
      "data-expanded": ctx.store.dropdownOpened || void 0,
      "data-mantine-stop-propagation": ctx.store.dropdownOpened || void 0
    } : {},
    onKeyDown: handleKeyDown
  };
}
const defaultProps$y = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxEventsTarget = factory((props, ref) => {
  const {
    children: children2,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxEventsTarget", defaultProps$y, props), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: child.props.onKeyDown,
    autoComplete
  });
  return cloneElement(child, {
    ...targetProps,
    ...others,
    [refProp]: useMergedRef(ref, ctx.store.targetRef, getRefProp(child))
  });
});
ComboboxEventsTarget.displayName = "@mantine/core/ComboboxEventsTarget";
const ComboboxFooter = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxFooter",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("footer", { className, classNames, style: style2, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxFooter.classes = classes$r;
ComboboxFooter.displayName = "@mantine/core/ComboboxFooter";
const ComboboxGroup = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, children: children2, label, id: id2, ...others } = useProps(
    "ComboboxGroup",
    null,
    props
  ), ctx = useComboboxContext(), _id = useId$1(id2);
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref,
      role: "group",
      "aria-labelledby": label ? _id : void 0,
      ...ctx.getStyles("group", { className, classNames, style: style2, styles }),
      ...others,
      children: [
        label && /* @__PURE__ */ jsx("div", { id: _id, ...ctx.getStyles("groupLabel", { classNames, styles }), children: label }),
        children2
      ]
    }
  );
});
ComboboxGroup.classes = classes$r;
ComboboxGroup.displayName = "@mantine/core/ComboboxGroup";
const ComboboxHeader = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "ComboboxHeader",
    null,
    props
  ), ctx = useComboboxContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("header", { className, classNames, style: style2, styles }),
      ...others,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }
  );
});
ComboboxHeader.classes = classes$r;
ComboboxHeader.displayName = "@mantine/core/ComboboxHeader";
function ComboboxHiddenInput({
  value,
  valuesDivider = ",",
  ...others
}) {
  return /* @__PURE__ */ jsx(
    "input",
    {
      type: "hidden",
      value: Array.isArray(value) ? value.join(valuesDivider) : value || "",
      ...others
    }
  );
}
ComboboxHiddenInput.displayName = "@mantine/core/ComboboxHiddenInput";
const ComboboxOption = factory((_props, ref) => {
  const props = useProps("ComboboxOption", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onClick,
    id: id2,
    active,
    onMouseDown,
    onMouseOver,
    disabled,
    selected: selected2,
    mod,
    ...others
  } = props, ctx = useComboboxContext(), uuid2 = useId$2(), _id = id2 || uuid2;
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...ctx.getStyles("option", { className, classNames, styles, style: style2 }),
      ...others,
      ref,
      id: _id,
      mod: [
        "combobox-option",
        { "combobox-active": active, "combobox-disabled": disabled, "combobox-selected": selected2 },
        mod
      ],
      role: "option",
      onClick: (event) => {
        disabled ? event.preventDefault() : (ctx.onOptionSubmit?.(props.value, props), onClick?.(event));
      },
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      },
      onMouseOver: (event) => {
        ctx.resetSelectionOnOptionHover && ctx.store.resetSelectedOption(), onMouseOver?.(event);
      }
    }
  );
});
ComboboxOption.classes = classes$r;
ComboboxOption.displayName = "@mantine/core/ComboboxOption";
const ComboboxOptions = factory((_props, ref) => {
  const props = useProps("ComboboxOptions", null, _props), { classNames, className, style: style2, styles, id: id2, onMouseDown, labelledBy, ...others } = props, ctx = useComboboxContext(), _id = useId$1(id2);
  return useEffect(() => {
    ctx.store.setListId(_id);
  }, [_id]), /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("options", { className, style: style2, classNames, styles }),
      ...others,
      id: _id,
      role: "listbox",
      "aria-labelledby": labelledBy,
      onMouseDown: (event) => {
        event.preventDefault(), onMouseDown?.(event);
      }
    }
  );
});
ComboboxOptions.classes = classes$r;
ComboboxOptions.displayName = "@mantine/core/ComboboxOptions";
const defaultProps$x = {
  withAriaAttributes: !0,
  withKeyboardNavigation: !0
}, ComboboxSearch = factory((_props, ref) => {
  const props = useProps("ComboboxSearch", defaultProps$x, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    withAriaAttributes,
    onKeyDown,
    withKeyboardNavigation,
    size: size2,
    ...others
  } = props, ctx = useComboboxContext(), _styles = ctx.getStyles("search"), targetProps = useComboboxTargetProps({
    targetType: "input",
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute: !1,
    onKeyDown,
    autoComplete: "off"
  });
  return /* @__PURE__ */ jsx(
    Input,
    {
      ref: useMergedRef(ref, ctx.store.searchRef),
      classNames: [{ input: _styles.className }, classNames],
      styles: [{ input: _styles.style }, styles],
      size: size2 || ctx.size,
      ...targetProps,
      ...others,
      __staticSelector: "Combobox"
    }
  );
});
ComboboxSearch.classes = classes$r;
ComboboxSearch.displayName = "@mantine/core/ComboboxSearch";
const defaultProps$w = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, ComboboxTarget = factory((props, ref) => {
  const {
    children: children2,
    refProp,
    withKeyboardNavigation,
    withAriaAttributes,
    withExpandedAttribute,
    targetType,
    autoComplete,
    ...others
  } = useProps("ComboboxTarget", defaultProps$w, props), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useComboboxContext(), targetProps = useComboboxTargetProps({
    targetType,
    withAriaAttributes,
    withKeyboardNavigation,
    withExpandedAttribute,
    onKeyDown: child.props.onKeyDown,
    autoComplete
  }), clonedElement = cloneElement(child, {
    ...targetProps,
    ...others
  });
  return /* @__PURE__ */ jsx(Popover.Target, { ref: useMergedRef(ref, ctx.store.targetRef), children: clonedElement });
});
ComboboxTarget.displayName = "@mantine/core/ComboboxTarget";
function getPreviousIndex(currentIndex, elements, loop) {
  for (let i2 = currentIndex - 1; i2 >= 0; i2 -= 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  if (loop) {
    for (let i2 = elements.length - 1; i2 > -1; i2 -= 1)
      if (!elements[i2].hasAttribute("data-combobox-disabled"))
        return i2;
  }
  return currentIndex;
}
function getNextIndex(currentIndex, elements, loop) {
  for (let i2 = currentIndex + 1; i2 < elements.length; i2 += 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  if (loop) {
    for (let i2 = 0; i2 < elements.length; i2 += 1)
      if (!elements[i2].hasAttribute("data-combobox-disabled"))
        return i2;
  }
  return currentIndex;
}
function getFirstIndex(elements) {
  for (let i2 = 0; i2 < elements.length; i2 += 1)
    if (!elements[i2].hasAttribute("data-combobox-disabled"))
      return i2;
  return -1;
}
function useCombobox({
  defaultOpened,
  opened,
  onOpenedChange,
  onDropdownClose,
  onDropdownOpen,
  loop = !0,
  scrollBehavior = "instant"
} = {}) {
  const [dropdownOpened, setDropdownOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange: onOpenedChange
  }), listId = useRef(null), selectedOptionIndex = useRef(-1), searchRef = useRef(null), targetRef = useRef(null), focusSearchTimeout = useRef(-1), focusTargetTimeout = useRef(-1), selectedIndexUpdateTimeout = useRef(-1), openDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened || (setDropdownOpened(!0), onDropdownOpen?.(eventSource));
    },
    [setDropdownOpened, onDropdownOpen, dropdownOpened]
  ), closeDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened && (setDropdownOpened(!1), onDropdownClose?.(eventSource));
    },
    [setDropdownOpened, onDropdownClose, dropdownOpened]
  ), toggleDropdown = useCallback(
    (eventSource = "unknown") => {
      dropdownOpened ? closeDropdown(eventSource) : openDropdown(eventSource);
    },
    [closeDropdown, openDropdown, dropdownOpened]
  ), clearSelectedItem = useCallback(() => {
    const root2 = getRootElement(targetRef.current), selected2 = findElementBySelector(`#${listId.current} [data-combobox-selected]`, root2);
    selected2?.removeAttribute("data-combobox-selected"), selected2?.removeAttribute("aria-selected");
  }, []), selectOption = useCallback(
    (index2) => {
      const root2 = getRootElement(targetRef.current), list2 = findElementBySelector(`#${listId.current}`, root2), items = list2 ? findElementsBySelector("[data-combobox-option]", list2) : null;
      if (!items)
        return null;
      const nextIndex = index2 >= items.length ? 0 : index2 < 0 ? items.length - 1 : index2;
      return selectedOptionIndex.current = nextIndex, items?.[nextIndex] && !items[nextIndex].hasAttribute("data-combobox-disabled") ? (clearSelectedItem(), items[nextIndex].setAttribute("data-combobox-selected", "true"), items[nextIndex].setAttribute("aria-selected", "true"), items[nextIndex].scrollIntoView({ block: "nearest", behavior: scrollBehavior }), items[nextIndex].id) : null;
    },
    [scrollBehavior, clearSelectedItem]
  ), selectActiveOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), activeOption = findElementBySelector(
      `#${listId.current} [data-combobox-active]`,
      root2
    );
    if (activeOption) {
      const index2 = findElementsBySelector(
        `#${listId.current} [data-combobox-option]`,
        root2
      ).findIndex((option) => option === activeOption);
      return selectOption(index2);
    }
    return selectOption(0);
  }, [selectOption]), selectNextOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    );
    return selectOption(getNextIndex(selectedOptionIndex.current, items, loop));
  }, [selectOption, loop]), selectPreviousOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    );
    return selectOption(getPreviousIndex(selectedOptionIndex.current, items, loop));
  }, [selectOption, loop]), selectFirstOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    );
    return selectOption(getFirstIndex(items));
  }, [selectOption]), updateSelectedOptionIndex = useCallback(
    (target = "selected", options) => {
      selectedIndexUpdateTimeout.current = window.setTimeout(() => {
        const root2 = getRootElement(targetRef.current), items = findElementsBySelector(
          `#${listId.current} [data-combobox-option]`,
          root2
        ), index2 = items.findIndex((option) => option.hasAttribute(`data-combobox-${target}`));
        selectedOptionIndex.current = index2, options?.scrollIntoView && items[index2]?.scrollIntoView({ block: "nearest", behavior: scrollBehavior });
      }, 0);
    },
    []
  ), resetSelectedOption = useCallback(() => {
    selectedOptionIndex.current = -1, clearSelectedItem();
  }, [clearSelectedItem]), clickSelectedOption = useCallback(() => {
    const root2 = getRootElement(targetRef.current);
    findElementsBySelector(
      `#${listId.current} [data-combobox-option]`,
      root2
    )?.[selectedOptionIndex.current]?.click();
  }, []), setListId = useCallback((id2) => {
    listId.current = id2;
  }, []), focusSearchInput = useCallback(() => {
    focusSearchTimeout.current = window.setTimeout(() => searchRef.current?.focus(), 0);
  }, []), focusTarget = useCallback(() => {
    focusTargetTimeout.current = window.setTimeout(() => targetRef.current?.focus(), 0);
  }, []), getSelectedOptionIndex = useCallback(() => selectedOptionIndex.current, []);
  return useEffect(
    () => () => {
      window.clearTimeout(focusSearchTimeout.current), window.clearTimeout(focusTargetTimeout.current), window.clearTimeout(selectedIndexUpdateTimeout.current);
    },
    []
  ), {
    dropdownOpened,
    openDropdown,
    closeDropdown,
    toggleDropdown,
    selectedOptionIndex: selectedOptionIndex.current,
    getSelectedOptionIndex,
    selectOption,
    selectFirstOption,
    selectActiveOption,
    selectNextOption,
    selectPreviousOption,
    resetSelectedOption,
    updateSelectedOptionIndex,
    listId: listId.current,
    setListId,
    clickSelectedOption,
    searchRef,
    focusSearchInput,
    targetRef,
    focusTarget
  };
}
const defaultProps$v = {
  keepMounted: !0,
  withinPortal: !0,
  resetSelectionOnOptionHover: !1,
  width: "target",
  transitionProps: { transition: "fade", duration: 0 },
  size: "sm"
}, varsResolver$t = (_2, { size: size2, dropdownPadding }) => ({
  options: {
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  },
  dropdown: {
    "--combobox-padding": dropdownPadding === void 0 ? void 0 : rem(dropdownPadding),
    "--combobox-option-fz": getFontSize(size2),
    "--combobox-option-padding": getSize(size2, "combobox-option-padding")
  }
});
function Combobox(_props) {
  const props = useProps("Combobox", defaultProps$v, _props), {
    classNames,
    styles,
    unstyled,
    children: children2,
    store: controlledStore,
    vars,
    onOptionSubmit,
    onClose,
    size: size2,
    dropdownPadding,
    resetSelectionOnOptionHover,
    __staticSelector,
    readOnly,
    attributes,
    ...others
  } = props, uncontrolledStore = useCombobox(), store = controlledStore || uncontrolledStore, getStyles2 = useStyles({
    name: __staticSelector || "Combobox",
    classes: classes$r,
    props,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$t
  }), onDropdownClose = () => {
    onClose?.(), store.closeDropdown();
  };
  return /* @__PURE__ */ jsx(
    ComboboxProvider,
    {
      value: {
        getStyles: getStyles2,
        store,
        onOptionSubmit,
        size: size2,
        resetSelectionOnOptionHover,
        readOnly
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          opened: store.dropdownOpened,
          preventPositionChangeWhenVisible: !0,
          ...others,
          onChange: (_opened) => !_opened && onDropdownClose(),
          withRoles: !1,
          unstyled,
          children: children2
        }
      )
    }
  );
}
const extendCombobox = (c) => c;
Combobox.extend = extendCombobox;
Combobox.classes = classes$r;
Combobox.displayName = "@mantine/core/Combobox";
Combobox.Target = ComboboxTarget;
Combobox.Dropdown = ComboboxDropdown;
Combobox.Options = ComboboxOptions;
Combobox.Option = ComboboxOption;
Combobox.Search = ComboboxSearch;
Combobox.Empty = ComboboxEmpty;
Combobox.Chevron = ComboboxChevron;
Combobox.Footer = ComboboxFooter;
Combobox.Header = ComboboxHeader;
Combobox.EventsTarget = ComboboxEventsTarget;
Combobox.DropdownTarget = ComboboxDropdownTarget;
Combobox.Group = ComboboxGroup;
Combobox.ClearButton = ComboboxClearButton;
Combobox.HiddenInput = ComboboxHiddenInput;
function CheckIcon({ size: size2, style: style2, ...others }) {
  const _style = size2 !== void 0 ? { width: rem(size2), height: rem(size2), ...style2 } : style2;
  return /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: _style,
      "aria-hidden": !0,
      ...others,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
function isOptionsGroup(item) {
  return "group" in item;
}
function defaultOptionsFilter({
  options,
  search,
  limit
}) {
  const parsedSearch = search.trim().toLowerCase(), result = [];
  for (let i2 = 0; i2 < options.length; i2 += 1) {
    const item = options[i2];
    if (result.length === limit)
      return result;
    isOptionsGroup(item) && result.push({
      group: item.group,
      items: defaultOptionsFilter({
        options: item.items,
        search,
        limit: limit - result.length
      })
    }), isOptionsGroup(item) || item.label.toLowerCase().includes(parsedSearch) && result.push(item);
  }
  return result;
}
function isEmptyComboboxData(data) {
  if (data.length === 0)
    return !0;
  for (const item of data)
    if (!("group" in item) || item.items.length > 0)
      return !1;
  return !0;
}
function validateOptions(options, valuesSet = /* @__PURE__ */ new Set()) {
  if (Array.isArray(options))
    for (const option of options)
      if (isOptionsGroup(option))
        validateOptions(option.items, valuesSet);
      else {
        if (typeof option.value > "u")
          throw new Error("[@mantine/core] Each option must have value property");
        if (typeof option.value != "string")
          throw new Error(
            `[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof option.value}`
          );
        if (valuesSet.has(option.value))
          throw new Error(
            `[@mantine/core] Duplicate options are not supported. Option with value "${option.value}" was provided more than once`
          );
        valuesSet.add(option.value);
      }
}
function isValueChecked(value, optionValue) {
  return Array.isArray(value) ? value.includes(optionValue) : value === optionValue;
}
function Option({
  data,
  withCheckIcon,
  withAlignedLabels,
  value,
  checkIconPosition,
  unstyled,
  renderOption
}) {
  if (!isOptionsGroup(data)) {
    const checked = isValueChecked(value, data.value), check2 = withCheckIcon && (checked ? /* @__PURE__ */ jsx(CheckIcon, { className: classes$r.optionsDropdownCheckIcon }) : withAlignedLabels ? /* @__PURE__ */ jsx("div", { className: classes$r.optionsDropdownCheckPlaceholder }) : null), defaultContent = /* @__PURE__ */ jsxs(Fragment$1, { children: [
      checkIconPosition === "left" && check2,
      /* @__PURE__ */ jsx("span", { children: data.label }),
      checkIconPosition === "right" && check2
    ] });
    return /* @__PURE__ */ jsx(
      Combobox.Option,
      {
        value: data.value,
        disabled: data.disabled,
        className: clsx({ [classes$r.optionsDropdownOption]: !unstyled }),
        "data-reverse": checkIconPosition === "right" || void 0,
        "data-checked": checked || void 0,
        "aria-selected": checked,
        active: checked,
        children: typeof renderOption == "function" ? renderOption({ option: data, checked }) : defaultContent
      }
    );
  }
  const options = data.items.map((item) => /* @__PURE__ */ jsx(
    Option,
    {
      data: item,
      value,
      unstyled,
      withCheckIcon,
      withAlignedLabels,
      checkIconPosition,
      renderOption
    },
    item.value
  ));
  return /* @__PURE__ */ jsx(Combobox.Group, { label: data.group, children: options });
}
function OptionsDropdown({
  data,
  hidden: hidden2,
  hiddenWhenEmpty,
  filter: filter2,
  search,
  limit,
  maxDropdownHeight,
  withScrollArea = !0,
  filterOptions = !0,
  withCheckIcon = !1,
  withAlignedLabels = !1,
  value,
  checkIconPosition,
  nothingFoundMessage,
  unstyled,
  labelId,
  renderOption,
  scrollAreaProps,
  "aria-label": ariaLabel
}) {
  validateOptions(data);
  const filteredData = typeof search == "string" ? (filter2 || defaultOptionsFilter)({
    options: data,
    search: filterOptions ? search : "",
    limit: limit ?? 1 / 0
  }) : data, isEmpty = isEmptyComboboxData(filteredData), options = filteredData.map((item) => /* @__PURE__ */ jsx(
    Option,
    {
      data: item,
      withCheckIcon,
      withAlignedLabels,
      value,
      checkIconPosition,
      unstyled,
      renderOption
    },
    isOptionsGroup(item) ? item.group : item.value
  ));
  return /* @__PURE__ */ jsx(Combobox.Dropdown, { hidden: hidden2 || hiddenWhenEmpty && isEmpty, "data-composed": !0, children: /* @__PURE__ */ jsxs(Combobox.Options, { labelledBy: labelId, "aria-label": ariaLabel, children: [
    withScrollArea ? /* @__PURE__ */ jsx(
      ScrollArea.Autosize,
      {
        mah: maxDropdownHeight ?? 220,
        type: "scroll",
        scrollbarSize: "var(--combobox-padding)",
        offsetScrollbars: "y",
        ...scrollAreaProps,
        children: options
      }
    ) : options,
    isEmpty && nothingFoundMessage && /* @__PURE__ */ jsx(Combobox.Empty, { children: nothingFoundMessage })
  ] }) });
}
var classes$q = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const varsResolver$s = (theme, { radius, color: color2, gradient, variant, size: size2, autoContrast, circle }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--badge-height": getSize(size2, "badge-height"),
      "--badge-padding-x": getSize(size2, "badge-padding-x"),
      "--badge-fz": getSize(size2, "badge-fz"),
      "--badge-radius": circle || radius === void 0 ? void 0 : getRadius$1(radius),
      "--badge-bg": color2 || variant ? colors.background : void 0,
      "--badge-color": color2 || variant ? colors.color : void 0,
      "--badge-bd": color2 || variant ? colors.border : void 0,
      "--badge-dot-color": variant === "dot" ? getThemeColor(color2, theme) : void 0
    }
  };
}, Badge = polymorphicFactory((_props, ref) => {
  const props = useProps("Badge", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    radius,
    color: color2,
    gradient,
    leftSection,
    rightSection,
    children: children2,
    variant,
    fullWidth,
    autoContrast,
    circle,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Badge",
    props,
    classes: classes$q,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$s
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      variant,
      mod: [
        {
          block: fullWidth,
          circle,
          "with-right-section": !!rightSection,
          "with-left-section": !!leftSection
        },
        mod
      ],
      ...getStyles2("root", { variant }),
      ref,
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "left", children: leftSection }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...getStyles2("section"), "data-position": "right", children: rightSection })
      ]
    }
  );
});
Badge.classes = classes$q;
Badge.displayName = "@mantine/core/Badge";
var classes$p = { root: "m_8b3717df", breadcrumb: "m_f678d540", separator: "m_3b8f2208" };
const defaultProps$u = {
  separator: "/"
}, varsResolver$r = (_2, { separatorMargin }) => ({
  root: {
    "--bc-separator-margin": getSpacing(separatorMargin)
  }
}), Breadcrumbs = factory((_props, ref) => {
  const props = useProps("Breadcrumbs", defaultProps$u, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children: children2,
    separator,
    separatorMargin,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Breadcrumbs",
    classes: classes$p,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$r
  }), items = Children.toArray(children2).reduce((acc, child, index2, array2) => {
    const item = isElement$1(child) ? cloneElement(child, {
      ...getStyles2("breadcrumb", { className: child.props?.className }),
      key: index2
    }) : /* @__PURE__ */ createElement("div", { ...getStyles2("breadcrumb"), key: index2 }, child);
    return acc.push(item), index2 !== array2.length - 1 && acc.push(
      /* @__PURE__ */ createElement(Box, { ...getStyles2("separator"), key: `separator-${index2}` }, separator)
    ), acc;
  }, []);
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), ...others, children: items });
});
Breadcrumbs.classes = classes$p;
Breadcrumbs.displayName = "@mantine/core/Breadcrumbs";
var classes$o = { root: "m_fea6bf1a", burger: "m_d4fb9cad" };
const varsResolver$q = (theme, { color: color2, size: size2, lineSize, transitionDuration, transitionTimingFunction }) => ({
  root: {
    "--burger-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--burger-size": getSize(size2, "burger-size"),
    "--burger-line-size": lineSize ? rem(lineSize) : void 0,
    "--burger-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--burger-transition-timing-function": transitionTimingFunction
  }
}), Burger = factory((_props, ref) => {
  const props = useProps("Burger", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    opened,
    children: children2,
    transitionDuration,
    transitionTimingFunction,
    lineSize,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Burger",
    classes: classes$o,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$q
  });
  return /* @__PURE__ */ jsxs(UnstyledButton, { ...getStyles2("root"), ref, ...others, children: [
    /* @__PURE__ */ jsx(Box, { mod: ["reduce-motion", { opened }], ...getStyles2("burger") }),
    children2
  ] });
});
Burger.classes = classes$o;
Burger.displayName = "@mantine/core/Burger";
var classes$n = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" };
const defaultProps$t = {
  orientation: "horizontal"
}, varsResolver$p = (_2, { borderWidth }) => ({
  group: { "--button-border-width": rem(borderWidth) }
}), ButtonGroup = factory((_props, ref) => {
  const props = useProps("ButtonGroup", defaultProps$t, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    orientation,
    vars,
    borderWidth,
    variant,
    mod,
    attributes,
    ...others
  } = useProps("ButtonGroup", defaultProps$t, _props), getStyles2 = useStyles({
    name: "ButtonGroup",
    props,
    classes: classes$n,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$p,
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("group"),
      ref,
      variant,
      mod: [{ "data-orientation": orientation }, mod],
      role: "group",
      ...others
    }
  );
});
ButtonGroup.classes = classes$n;
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
const varsResolver$o = (theme, { radius, color: color2, gradient, variant, autoContrast, size: size2 }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    groupSection: {
      "--section-height": getSize(size2, "section-height"),
      "--section-padding-x": getSize(size2, "section-padding-x"),
      "--section-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--section-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--section-bg": color2 || variant ? colors.background : void 0,
      "--section-color": colors.color,
      "--section-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ButtonGroupSection = factory((_props, ref) => {
  const props = useProps("ButtonGroupSection", null, _props), {
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    vars,
    variant,
    gradient,
    radius,
    autoContrast,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "ButtonGroupSection",
    props,
    classes: classes$n,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$o,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ jsx(Box, { ...getStyles2("groupSection"), ref, variant, ...others });
});
ButtonGroupSection.classes = classes$n;
ButtonGroupSection.displayName = "@mantine/core/ButtonGroupSection";
const loaderTransition = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${rem(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, varsResolver$n = (theme, { radius, color: color2, gradient, variant, size: size2, justify, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--button-justify": justify,
      "--button-height": getSize(size2, "button-height"),
      "--button-padding-x": getSize(size2, "button-padding-x"),
      "--button-fz": size2?.includes("compact") ? getFontSize(size2.replace("compact-", "")) : getFontSize(size2),
      "--button-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--button-bg": color2 || variant ? colors.background : void 0,
      "--button-hover": color2 || variant ? colors.hover : void 0,
      "--button-color": colors.color,
      "--button-bd": color2 || variant ? colors.border : void 0,
      "--button-hover-color": color2 || variant ? colors.hoverColor : void 0
    }
  };
}, Button = polymorphicFactory((_props, ref) => {
  const props = useProps("Button", null, _props), {
    style: style2,
    vars,
    className,
    color: color2,
    disabled,
    children: children2,
    leftSection,
    rightSection,
    fullWidth,
    variant,
    radius,
    loading,
    loaderProps,
    gradient,
    classNames,
    styles,
    unstyled,
    "data-disabled": dataDisabled,
    autoContrast,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Button",
    props,
    classes: classes$n,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$n
  }), hasLeftSection = !!leftSection, hasRightSection = !!rightSection;
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ref,
      ...getStyles2("root", { active: !disabled && !loading && !dataDisabled }),
      unstyled,
      variant,
      disabled: disabled || loading,
      mod: [
        {
          disabled: disabled || dataDisabled,
          loading,
          block: fullWidth,
          "with-left-section": hasLeftSection,
          "with-right-section": hasRightSection
        },
        mod
      ],
      ...others,
      children: [
        typeof loading == "boolean" && /* @__PURE__ */ jsx(Transition$1, { mounted: loading, transition: loaderTransition, duration: 150, children: (transitionStyles) => /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("loader", { style: transitionStyles }), "aria-hidden": !0, children: /* @__PURE__ */ jsx(
          Loader,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...loaderProps
          }
        ) }) }),
        /* @__PURE__ */ jsxs("span", { ...getStyles2("inner"), children: [
          leftSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsx(Box, { component: "span", mod: { loading }, ...getStyles2("label"), children: children2 }),
          rightSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "right" }, children: rightSection })
        ] })
      ]
    }
  );
});
Button.classes = classes$n;
Button.displayName = "@mantine/core/Button";
Button.Group = ButtonGroup;
Button.GroupSection = ButtonGroupSection;
const [CardProvider, useCardContext] = createSafeContext(
  "Card component was not found in tree"
);
var classes$m = { root: "m_e615b15f", section: "m_599a2148" };
const CardSection = polymorphicFactory((_props, ref) => {
  const props = useProps("CardSection", null, _props), { classNames, className, style: style2, styles, vars, withBorder, inheritPadding, mod, ...others } = props, ctx = useCardContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ "with-border": withBorder, "inherit-padding": inheritPadding }, mod],
      ...ctx.getStyles("section", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
CardSection.classes = classes$m;
CardSection.displayName = "@mantine/core/CardSection";
const varsResolver$m = (_2, { padding }) => ({
  root: {
    "--card-padding": getSpacing(padding)
  }
}), Card = polymorphicFactory((_props, ref) => {
  const props = useProps("Card", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    children: children2,
    padding,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Card",
    props,
    classes: classes$m,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$m
  }), _children = Children.toArray(children2), content = _children.map((child, index2) => typeof child == "object" && child && "type" in child && child.type === CardSection ? cloneElement(child, {
    "data-first-section": index2 === 0 || void 0,
    "data-last-section": index2 === _children.length - 1 || void 0
  }) : child);
  return /* @__PURE__ */ jsx(CardProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsx(Paper, { ref, unstyled, ...getStyles2("root"), ...others, children: content }) });
});
Card.classes = classes$m;
Card.displayName = "@mantine/core/Card";
Card.Section = CardSection;
var classes$l = { root: "m_b183c0a2" };
const varsResolver$l = (theme, { color: color2 }) => ({
  root: {
    "--code-bg": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Code = factory((_props, ref) => {
  const props = useProps("Code", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    block,
    variant,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Code",
    props,
    classes: classes$l,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$l
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: block ? "pre" : "code",
      variant,
      ref,
      mod: [{ block }, mod],
      ...getStyles2("root"),
      ...others,
      dir: "ltr"
    }
  );
});
Code.classes = classes$l;
Code.displayName = "@mantine/core/Code";
var classes$k = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" };
const defaultProps$s = {
  withShadow: !0
}, varsResolver$k = (_2, { radius, size: size2 }) => ({
  root: {
    "--cs-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--cs-size": rem(size2)
  }
}), ColorSwatch = polymorphicFactory((_props, ref) => {
  const props = useProps("ColorSwatch", defaultProps$s, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    size: size2,
    radius,
    withShadow,
    children: children2,
    variant,
    attributes,
    ...others
  } = useProps("ColorSwatch", defaultProps$s, props), getStyles2 = useStyles({
    name: "ColorSwatch",
    props,
    classes: classes$k,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$k
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref,
      variant,
      size: size2,
      ...getStyles2("root", { focusable: !0 }),
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("alphaOverlay") }),
        withShadow && /* @__PURE__ */ jsx("span", { ...getStyles2("shadowOverlay") }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("colorOverlay", { style: { backgroundColor: color2 } }) }),
        /* @__PURE__ */ jsx("span", { ...getStyles2("childrenOverlay"), children: children2 })
      ]
    }
  );
});
ColorSwatch.classes = classes$k;
ColorSwatch.displayName = "@mantine/core/ColorSwatch";
var classes$j = { root: "m_7485cace" };
const varsResolver$j = (_2, { size: size2, fluid }) => ({
  root: {
    "--container-size": fluid ? void 0 : getSize(size2, "container-size")
  }
}), Container = factory((_props, ref) => {
  const props = useProps("Container", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    fluid,
    mod,
    attributes,
    strategy,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Container",
    classes: classes$j,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$j
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ fluid, strategy: strategy || "block" }, mod],
      ...getStyles2("root"),
      ...others
    }
  );
});
Container.classes = classes$j;
Container.displayName = "@mantine/core/Container";
const defaultProps$r = {
  timeout: 1e3
};
function CopyButton(props) {
  const { children: children2, timeout: timeout2, value, ...others } = useProps("CopyButton", defaultProps$r, props), clipboard = useClipboard({ timeout: timeout2 });
  return /* @__PURE__ */ jsx(Fragment$1, { children: children2({ copy: () => clipboard.copy(value), copied: clipboard.copied, ...others }) });
}
CopyButton.displayName = "@mantine/core/CopyButton";
var classes$i = { root: "m_3eebeb36", label: "m_9e365f20" };
const defaultProps$q = {
  orientation: "horizontal"
}, varsResolver$i = (theme, { color: color2, variant, size: size2 }) => ({
  root: {
    "--divider-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--divider-border-style": variant,
    "--divider-size": getSize(size2, "divider-size")
  }
}), Divider = factory((_props, ref) => {
  const props = useProps("Divider", defaultProps$q, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    orientation,
    label,
    labelPosition,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Divider",
    classes: classes$i,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$i
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      mod: [{ orientation, "with-label": !!label }, mod],
      ...getStyles2("root"),
      ...others,
      role: "separator",
      children: label && /* @__PURE__ */ jsx(Box, { component: "span", mod: { position: labelPosition }, ...getStyles2("label"), children: label })
    }
  );
});
Divider.classes = classes$i;
Divider.displayName = "@mantine/core/Divider";
const [DrawerProvider, useDrawerContext] = createSafeContext(
  "Drawer component was not found in tree"
);
var classes$h = { root: "m_f11b401e", header: "m_5a7c2c9", content: "m_b8a05bbd", inner: "m_31cd769a" };
const DrawerBody = factory((_props, ref) => {
  const props = useProps("DrawerBody", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerBody.classes = classes$h;
DrawerBody.displayName = "@mantine/core/DrawerBody";
const DrawerCloseButton = factory((_props, ref) => {
  const props = useProps("DrawerCloseButton", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseCloseButton,
    {
      ref,
      ...ctx.getStyles("close", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerCloseButton.classes = classes$h;
DrawerCloseButton.displayName = "@mantine/core/DrawerCloseButton";
const DrawerContent = factory((_props, ref) => {
  const props = useProps("DrawerContent", null, _props), { classNames, className, style: style2, styles, vars, children: children2, radius, __hidden, ...others } = props, ctx = useDrawerContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
      ref,
      ...others,
      radius: radius || ctx.radius || 0,
      "data-hidden": __hidden || void 0,
      children: /* @__PURE__ */ jsx(Scroll, { style: { height: "calc(100vh - var(--drawer-offset) * 2)" }, children: children2 })
    }
  );
});
DrawerContent.classes = classes$h;
DrawerContent.displayName = "@mantine/core/DrawerContent";
const DrawerHeader = factory((_props, ref) => {
  const props = useProps("DrawerHeader", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseHeader,
    {
      ref,
      ...ctx.getStyles("header", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerHeader.classes = classes$h;
DrawerHeader.displayName = "@mantine/core/DrawerHeader";
const DrawerOverlay = factory((_props, ref) => {
  const props = useProps("DrawerOverlay", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerOverlay.classes = classes$h;
DrawerOverlay.displayName = "@mantine/core/DrawerOverlay";
function getDrawerAlign(position) {
  switch (position) {
    case "top":
      return "flex-start";
    case "bottom":
      return "flex-end";
    default:
      return;
  }
}
function getDrawerFlex(position) {
  if (position === "top" || position === "bottom")
    return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)";
}
const transitions = {
  top: "slide-down",
  bottom: "slide-up",
  left: "slide-right",
  right: "slide-left"
}, rtlTransitions = {
  top: "slide-down",
  bottom: "slide-up",
  right: "slide-right",
  left: "slide-left"
}, defaultProps$p = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  position: "left"
}, varsResolver$h = (_2, { position, size: size2, offset: offset2 }) => ({
  root: {
    "--drawer-size": getSize(size2, "drawer-size"),
    "--drawer-flex": getDrawerFlex(position),
    "--drawer-height": position === "left" || position === "right" ? void 0 : "var(--drawer-size)",
    "--drawer-align": getDrawerAlign(position),
    "--drawer-justify": position === "right" ? "flex-end" : void 0,
    "--drawer-offset": rem(offset2)
  }
}), DrawerRoot = factory((_props, ref) => {
  const props = useProps("DrawerRoot", defaultProps$p, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    scrollAreaComponent,
    position,
    transitionProps,
    radius,
    attributes,
    ...others
  } = props, { dir } = useDirection(), getStyles2 = useStyles({
    name: "Drawer",
    classes: classes$h,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$h
  }), drawerTransition = (dir === "rtl" ? rtlTransitions : transitions)[position];
  return /* @__PURE__ */ jsx(DrawerProvider, { value: { scrollAreaComponent, getStyles: getStyles2, radius }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      transitionProps: { transition: drawerTransition, ...transitionProps },
      "data-offset-scrollbars": scrollAreaComponent === ScrollArea.Autosize || void 0,
      unstyled,
      ...others
    }
  ) });
});
DrawerRoot.classes = classes$h;
DrawerRoot.displayName = "@mantine/core/DrawerRoot";
const [DrawerStackProvider, useDrawerStackContext] = createOptionalContext();
function DrawerStack({ children: children2 }) {
  const [stack, setStack] = useState([]), [maxZIndex, setMaxZIndex] = useState(getDefaultZIndex("modal"));
  return /* @__PURE__ */ jsx(
    DrawerStackProvider,
    {
      value: {
        stack,
        addModal: (id2, zIndex) => {
          setStack((current2) => [.../* @__PURE__ */ new Set([...current2, id2])]), setMaxZIndex(
            (current2) => typeof zIndex == "number" && typeof current2 == "number" ? Math.max(current2, zIndex) : current2
          );
        },
        removeModal: (id2) => setStack((current2) => current2.filter((currentId) => currentId !== id2)),
        getZIndex: (id2) => `calc(${maxZIndex} + ${stack.indexOf(id2)} + 1)`,
        currentId: stack[stack.length - 1],
        maxZIndex
      },
      children: children2
    }
  );
}
DrawerStack.displayName = "@mantine/core/DrawerStack";
const DrawerTitle = factory((_props, ref) => {
  const props = useProps("DrawerTitle", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useDrawerContext();
  return /* @__PURE__ */ jsx(
    ModalBaseTitle,
    {
      ref,
      ...ctx.getStyles("title", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
DrawerTitle.classes = classes$h;
DrawerTitle.displayName = "@mantine/core/DrawerTitle";
const defaultProps$o = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  withOverlay: !0,
  withCloseButton: !0
}, Drawer = factory((_props, ref) => {
  const {
    title,
    withOverlay,
    overlayProps,
    withCloseButton,
    closeButtonProps,
    children: children2,
    opened,
    stackId,
    zIndex,
    ...others
  } = useProps("Drawer", defaultProps$o, _props), ctx = useDrawerStackContext(), hasHeader = !!title || withCloseButton, stackProps = ctx && stackId ? {
    closeOnEscape: ctx.currentId === stackId,
    trapFocus: ctx.currentId === stackId,
    zIndex: ctx.getZIndex(stackId)
  } : {}, overlayVisible = withOverlay === !1 ? !1 : stackId && ctx ? ctx.currentId === stackId : opened;
  return useEffect(() => {
    ctx && stackId && (opened ? ctx.addModal(stackId, zIndex || getDefaultZIndex("modal")) : ctx.removeModal(stackId));
  }, [opened, stackId, zIndex]), /* @__PURE__ */ jsxs(
    DrawerRoot,
    {
      ref,
      opened,
      zIndex: ctx && stackId ? ctx.getZIndex(stackId) : zIndex,
      ...others,
      ...stackProps,
      children: [
        withOverlay && /* @__PURE__ */ jsx(
          DrawerOverlay,
          {
            visible: overlayVisible,
            transitionProps: ctx && stackId ? { duration: 0 } : void 0,
            ...overlayProps
          }
        ),
        /* @__PURE__ */ jsxs(DrawerContent, { __hidden: ctx && stackId && opened ? stackId !== ctx.currentId : !1, children: [
          hasHeader && /* @__PURE__ */ jsxs(DrawerHeader, { children: [
            title && /* @__PURE__ */ jsx(DrawerTitle, { children: title }),
            withCloseButton && /* @__PURE__ */ jsx(DrawerCloseButton, { ...closeButtonProps })
          ] }),
          /* @__PURE__ */ jsx(DrawerBody, { children: children2 })
        ] })
      ]
    }
  );
});
Drawer.classes = classes$h;
Drawer.displayName = "@mantine/core/Drawer";
Drawer.Root = DrawerRoot;
Drawer.Overlay = DrawerOverlay;
Drawer.Content = DrawerContent;
Drawer.Body = DrawerBody;
Drawer.Header = DrawerHeader;
Drawer.Title = DrawerTitle;
Drawer.CloseButton = DrawerCloseButton;
Drawer.Stack = DrawerStack;
const [GridProvider, useGridContext] = createSafeContext(
  "Grid component was not found in tree"
), getColumnFlexBasis = (colSpan, columns) => colSpan === "content" ? "auto" : colSpan === "auto" ? "0rem" : colSpan ? `${100 / (columns / colSpan)}%` : void 0, getColumnMaxWidth = (colSpan, columns, grow) => grow || colSpan === "auto" ? "100%" : colSpan === "content" ? "unset" : getColumnFlexBasis(colSpan, columns), getColumnFlexGrow = (colSpan, grow) => {
  if (colSpan)
    return colSpan === "auto" || grow ? "1" : "auto";
}, getColumnOffset = (offset2, columns) => offset2 === 0 ? "0" : offset2 ? `${100 / (columns / offset2)}%` : void 0;
function GridColVariables({ span, order, offset: offset2, selector: selector2 }) {
  const theme = useMantineTheme(), ctx = useGridContext(), _breakpoints = ctx.breakpoints || theme.breakpoints, baseSpan = getBaseValue$1(span) === void 0 ? 12 : getBaseValue$1(span), baseStyles = filterProps$1({
    "--col-order": getBaseValue$1(order)?.toString(),
    "--col-flex-grow": getColumnFlexGrow(baseSpan, ctx.grow),
    "--col-flex-basis": getColumnFlexBasis(baseSpan, ctx.columns),
    "--col-width": baseSpan === "content" ? "auto" : void 0,
    "--col-max-width": getColumnMaxWidth(baseSpan, ctx.columns, ctx.grow),
    "--col-offset": getColumnOffset(getBaseValue$1(offset2), ctx.columns)
  }), queries = keys$1(_breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof order == "object" && order[breakpoint] !== void 0 && (acc[breakpoint]["--col-order"] = order[breakpoint]?.toString()), typeof span == "object" && span[breakpoint] !== void 0 && (acc[breakpoint]["--col-flex-grow"] = getColumnFlexGrow(span[breakpoint], ctx.grow), acc[breakpoint]["--col-flex-basis"] = getColumnFlexBasis(span[breakpoint], ctx.columns), acc[breakpoint]["--col-width"] = span[breakpoint] === "content" ? "auto" : void 0, acc[breakpoint]["--col-max-width"] = getColumnMaxWidth(
      span[breakpoint],
      ctx.columns,
      ctx.grow
    )), typeof offset2 == "object" && offset2[breakpoint] !== void 0 && (acc[breakpoint]["--col-offset"] = getColumnOffset(offset2[breakpoint], ctx.columns)), acc),
    {}
  ), values2 = getSortedBreakpoints(keys$1(queries), _breakpoints).filter(
    (breakpoint) => keys$1(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: ctx.type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(
    InlineStyles,
    {
      styles: baseStyles,
      media: ctx.type === "container" ? void 0 : values2,
      container: ctx.type === "container" ? values2 : void 0,
      selector: selector2
    }
  );
}
var classes$g = { container: "m_8478a6da", root: "m_410352e9", inner: "m_dee7bd2f", col: "m_96bdd299" };
const defaultProps$n = {
  span: 12
}, GridCol = factory((_props, ref) => {
  const props = useProps("GridCol", defaultProps$n, _props), { classNames, className, style: style2, styles, vars, span, order, offset: offset2, ...others } = props, ctx = useGridContext(), responsiveClassName = useRandomClassName();
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      GridColVariables,
      {
        selector: `.${responsiveClassName}`,
        span,
        order,
        offset: offset2
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        ref,
        ...ctx.getStyles("col", {
          className: clsx(className, responsiveClassName),
          style: style2,
          classNames,
          styles
        }),
        ...others
      }
    )
  ] });
});
GridCol.classes = classes$g;
GridCol.displayName = "@mantine/core/GridCol";
function GridVariables({ gutter, selector: selector2, breakpoints, type }) {
  const theme = useMantineTheme(), _breakpoints = breakpoints || theme.breakpoints, baseStyles = filterProps$1({
    "--grid-gutter": getSpacing(getBaseValue$1(gutter))
  }), queries = keys$1(_breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof gutter == "object" && gutter[breakpoint] !== void 0 && (acc[breakpoint]["--grid-gutter"] = getSpacing(gutter[breakpoint])), acc),
    {}
  ), values2 = getSortedBreakpoints(keys$1(queries), _breakpoints).filter(
    (breakpoint) => keys$1(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: type === "container" ? `mantine-grid (min-width: ${_breakpoints[breakpoint.value]})` : `(min-width: ${_breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(
    InlineStyles,
    {
      styles: baseStyles,
      media: type === "container" ? void 0 : values2,
      container: type === "container" ? values2 : void 0,
      selector: selector2
    }
  );
}
const defaultProps$m = {
  gutter: "md",
  grow: !1,
  columns: 12
}, varsResolver$g = (_2, { justify, align, overflow }) => ({
  root: {
    "--grid-justify": justify,
    "--grid-align": align,
    "--grid-overflow": overflow
  }
}), Grid = factory((_props, ref) => {
  const props = useProps("Grid", defaultProps$m, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    grow,
    gutter,
    columns,
    align,
    justify,
    children: children2,
    breakpoints,
    type,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Grid",
    classes: classes$g,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$g
  }), responsiveClassName = useRandomClassName();
  return type === "container" && breakpoints ? /* @__PURE__ */ jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns, breakpoints, type }, children: [
    /* @__PURE__ */ jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ jsx("div", { ...getStyles2("inner"), children: children2 }) }) })
  ] }) : /* @__PURE__ */ jsxs(GridProvider, { value: { getStyles: getStyles2, grow, columns, breakpoints, type }, children: [
    /* @__PURE__ */ jsx(GridVariables, { selector: `.${responsiveClassName}`, ...props }),
    /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others, children: /* @__PURE__ */ jsx("div", { ...getStyles2("inner"), children: children2 }) })
  ] });
});
Grid.classes = classes$g;
Grid.displayName = "@mantine/core/Grid";
Grid.Col = GridCol;
function getMarkColor({ color: color2, theme, defaultShade }) {
  const parsed = parseThemeColor({ color: color2, theme });
  return parsed.isThemeColor ? parsed.shade === void 0 ? `var(--mantine-color-${parsed.color}-${defaultShade})` : `var(${parsed.variable})` : color2;
}
var classes$f = { root: "m_bcb3f3c2" };
const defaultProps$l = {
  color: "yellow"
}, varsResolver$f = (theme, { color: color2 }) => ({
  root: {
    "--mark-bg-dark": getMarkColor({ color: color2, theme, defaultShade: 5 }),
    "--mark-bg-light": getMarkColor({ color: color2, theme, defaultShade: 2 })
  }
}), Mark = factory((_props, ref) => {
  const props = useProps("Mark", defaultProps$l, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    color: color2,
    variant,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Mark",
    props,
    className,
    style: style2,
    classes: classes$f,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$f
  });
  return /* @__PURE__ */ jsx(Box, { component: "mark", ref, variant, ...getStyles2("root"), ...others });
});
Mark.classes = classes$f;
Mark.displayName = "@mantine/core/Mark";
function escapeRegex$1(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function highlighter(value, _highlight) {
  if (_highlight == null)
    return [{ chunk: value, highlighted: !1 }];
  const highlight = Array.isArray(_highlight) ? _highlight.map(escapeRegex$1) : escapeRegex$1(_highlight);
  if (!(Array.isArray(highlight) ? highlight.filter((part) => part.trim().length > 0).length > 0 : highlight.trim() !== ""))
    return [{ chunk: value, highlighted: !1 }];
  const matcher2 = typeof highlight == "string" ? highlight.trim() : highlight.filter((part) => part.trim().length !== 0).map((part) => part.trim()).sort((a2, b) => b.length - a2.length).join("|"), re2 = new RegExp(`(${matcher2})`, "gi");
  return value.split(re2).map((part) => ({ chunk: part, highlighted: re2.test(part) })).filter(({ chunk }) => chunk);
}
const Highlight = polymorphicFactory((props, ref) => {
  const { unstyled, children: children2, highlight, highlightStyles, color: color2, ...others } = useProps(
    "Highlight",
    null,
    props
  ), highlightChunks = highlighter(children2, highlight);
  return /* @__PURE__ */ jsx(Text, { unstyled, ref, ...others, __staticSelector: "Highlight", children: highlightChunks.map(
    ({ chunk, highlighted }, i2) => highlighted ? /* @__PURE__ */ jsx(
      Mark,
      {
        unstyled,
        color: color2,
        style: highlightStyles,
        "data-highlight": chunk,
        children: chunk
      },
      i2
    ) : /* @__PURE__ */ jsx("span", { children: chunk }, i2)
  ) });
});
Highlight.classes = Text.classes;
Highlight.displayName = "@mantine/core/Highlight";
const [HoverCardContextProvider, useHoverCardContext] = createSafeContext(
  "HoverCard component was not found in the tree"
), HoverCardGroupContext = createContext(!1), HoverCardGroupProvider = HoverCardGroupContext.Provider, useHoverCardGroupContext = () => useContext(HoverCardGroupContext);
function HoverCardDropdown(props) {
  const { children: children2, onMouseEnter, onMouseLeave, ...others } = useProps(
    "HoverCardDropdown",
    null,
    props
  ), ctx = useHoverCardContext();
  if (useHoverCardGroupContext() && ctx.getFloatingProps && ctx.floating) {
    const floatingProps = ctx.getFloatingProps();
    return /* @__PURE__ */ jsx(
      Popover.Dropdown,
      {
        ref: ctx.floating,
        ...floatingProps,
        onMouseEnter: createEventHandler(onMouseEnter, floatingProps.onMouseEnter),
        onMouseLeave: createEventHandler(onMouseLeave, floatingProps.onMouseLeave),
        ...others,
        children: children2
      }
    );
  }
  const handleMouseEnter = createEventHandler(onMouseEnter, ctx.openDropdown), handleMouseLeave = createEventHandler(onMouseLeave, ctx.closeDropdown);
  return /* @__PURE__ */ jsx(Popover.Dropdown, { onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...others, children: children2 });
}
HoverCardDropdown.displayName = "@mantine/core/HoverCardDropdown";
const defaultProps$k = {
  openDelay: 0,
  closeDelay: 0
};
function HoverCardGroup(props) {
  const { openDelay, closeDelay, children: children2 } = useProps("HoverCardGroup", defaultProps$k, props);
  return /* @__PURE__ */ jsx(HoverCardGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children: children2 }) });
}
HoverCardGroup.displayName = "@mantine/core/HoverCardGroup";
HoverCardGroup.extend = (c) => c;
const defaultProps$j = {
  refProp: "ref"
}, HoverCardTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, eventPropsWrapperName, ...others } = useProps(
    "HoverCardTarget",
    defaultProps$j,
    props
  ), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useHoverCardContext();
  if (useHoverCardGroupContext() && ctx.getReferenceProps && ctx.reference) {
    const referenceProps = ctx.getReferenceProps();
    return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
      child,
      eventPropsWrapperName ? { [eventPropsWrapperName]: { ...referenceProps, ref: ctx.reference } } : { ...referenceProps, ref: ctx.reference }
    ) });
  }
  const onMouseEnter = createEventHandler(child.props.onMouseEnter, ctx.openDropdown), onMouseLeave = createEventHandler(child.props.onMouseLeave, ctx.closeDropdown), eventListeners = { onMouseEnter, onMouseLeave };
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, ref, ...others, children: cloneElement(
    child,
    eventPropsWrapperName ? { [eventPropsWrapperName]: eventListeners } : eventListeners
  ) });
});
HoverCardTarget.displayName = "@mantine/core/HoverCardTarget";
function useHoverCard(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useHoverCardGroupContext(), uid = useId$1(), openTimeout = useRef(-1), closeTimeout = useRef(-1), clearTimeouts = useCallback(() => {
    window.clearTimeout(openTimeout.current), window.clearTimeout(closeTimeout.current);
  }, []), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened ? (setCurrentId(uid), settings.onOpen?.()) : settings.onClose?.();
    },
    [uid, settings.onOpen, settings.onClose]
  ), { context, refs } = useFloating({
    open: opened,
    onOpenChange: onChange
  }), { delay: groupDelay, setCurrentId } = useDelayGroup(context, { id: uid }), { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context, {
      enabled: !0,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay }
    }),
    useRole(context, { role: "dialog" }),
    useDismiss(context, { enabled: withinGroup })
  ]), openDropdown = useCallback(() => {
    withinGroup || (clearTimeouts(), settings.openDelay === 0 || settings.openDelay === void 0 ? onChange(!0) : openTimeout.current = window.setTimeout(() => onChange(!0), settings.openDelay));
  }, [withinGroup, clearTimeouts, settings.openDelay, onChange]), closeDropdown = useCallback(() => {
    withinGroup || (clearTimeouts(), settings.closeDelay === 0 || settings.closeDelay === void 0 ? onChange(!1) : closeTimeout.current = window.setTimeout(() => onChange(!1), settings.closeDelay));
  }, [withinGroup, clearTimeouts, settings.closeDelay, onChange]);
  return useEffect(() => () => clearTimeouts(), [clearTimeouts]), {
    opened,
    reference: refs.setReference,
    floating: refs.setFloating,
    getReferenceProps,
    getFloatingProps,
    openDropdown,
    closeDropdown
  };
}
const defaultProps$i = {
  openDelay: 0,
  closeDelay: 150,
  initiallyOpened: !1
};
function HoverCard(props) {
  const { children: children2, onOpen, onClose, openDelay, closeDelay, initiallyOpened, ...others } = useProps(
    "HoverCard",
    defaultProps$i,
    props
  ), hoverCard = useHoverCard({
    openDelay,
    closeDelay,
    defaultOpened: initiallyOpened,
    onOpen,
    onClose
  });
  return /* @__PURE__ */ jsx(
    HoverCardContextProvider,
    {
      value: {
        openDropdown: hoverCard.openDropdown,
        closeDropdown: hoverCard.closeDropdown,
        getReferenceProps: hoverCard.getReferenceProps,
        getFloatingProps: hoverCard.getFloatingProps,
        reference: hoverCard.reference,
        floating: hoverCard.floating
      },
      children: /* @__PURE__ */ jsx(Popover, { ...others, opened: hoverCard.opened, __staticSelector: "HoverCard", children: children2 })
    }
  );
}
HoverCard.displayName = "@mantine/core/HoverCard";
HoverCard.Target = HoverCardTarget;
HoverCard.Dropdown = HoverCardDropdown;
HoverCard.Group = HoverCardGroup;
HoverCard.extend = (input) => input;
var index$1 = useLayoutEffect$1, classes$e = { root: "m_6e45937b", loader: "m_e8eb006c", overlay: "m_df587f17" };
const defaultProps$h = {
  transitionProps: { transition: "fade", duration: 0 },
  overlayProps: { backgroundOpacity: 0.75 },
  zIndex: getDefaultZIndex("overlay")
}, varsResolver$e = (_2, { zIndex }) => ({
  root: {
    "--lo-z-index": zIndex?.toString()
  }
}), LoadingOverlay = factory((_props, ref) => {
  const props = useProps("LoadingOverlay", defaultProps$h, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    transitionProps,
    loaderProps,
    overlayProps,
    visible: visible2,
    zIndex,
    attributes,
    ...others
  } = props, theme = useMantineTheme(), getStyles2 = useStyles({
    name: "LoadingOverlay",
    classes: classes$e,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$e
  }), _overlayProps = { ...defaultProps$h.overlayProps, ...overlayProps };
  return /* @__PURE__ */ jsx(Transition$1, { transition: "fade", ...transitionProps, mounted: !!visible2, children: (transitionStyles) => /* @__PURE__ */ jsxs(Box, { ...getStyles2("root", { style: transitionStyles }), ref, ...others, children: [
    /* @__PURE__ */ jsx(Loader, { ...getStyles2("loader"), unstyled, ...loaderProps }),
    /* @__PURE__ */ jsx(
      Overlay,
      {
        ..._overlayProps,
        ...getStyles2("overlay"),
        darkHidden: !0,
        unstyled,
        color: overlayProps?.color || theme.white
      }
    ),
    /* @__PURE__ */ jsx(
      Overlay,
      {
        ..._overlayProps,
        ...getStyles2("overlay"),
        lightHidden: !0,
        unstyled,
        color: overlayProps?.color || theme.colors.dark[5]
      }
    )
  ] }) });
});
LoadingOverlay.classes = classes$e;
LoadingOverlay.displayName = "@mantine/core/LoadingOverlay";
const [MenuContextProvider, useMenuContext] = createSafeContext(
  "Menu component was not found in the tree"
);
var classes$d = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504", chevron: "m_b85b0bed" };
const MenuDivider = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "MenuDivider",
    null,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("divider", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuDivider.classes = classes$d;
MenuDivider.displayName = "@mantine/core/MenuDivider";
const MenuDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children: children2,
    ...others
  } = useProps("MenuDropdown", null, props), wrapperRef = useRef(null), ctx = useMenuContext(), handleKeyDown = createEventHandler(onKeyDown, (event) => {
    (event.key === "ArrowUp" || event.key === "ArrowDown") && (event.preventDefault(), wrapperRef.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus());
  }), handleMouseEnter = createEventHandler(
    onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), handleMouseLeave = createEventHandler(
    onMouseLeave,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.closeDropdown()
  );
  return /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style: style2,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: handleKeyDown,
      children: [
        ctx.withInitialFocusPlaceholder && /* @__PURE__ */ jsx("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        children2
      ]
    }
  );
});
MenuDropdown.classes = classes$d;
MenuDropdown.displayName = "@mantine/core/MenuDropdown";
const [SubMenuProvider, useSubMenuContext] = createOptionalContext(), MenuItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    color: color2,
    closeMenuOnClick,
    leftSection,
    rightSection,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    ...others
  } = useProps("MenuItem", null, props), ctx = useMenuContext(), subCtx = useSubMenuContext(), theme = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(null), _others = others, handleClick = createEventHandler(_others.onClick, () => {
    dataDisabled || (typeof closeMenuOnClick == "boolean" ? closeMenuOnClick && ctx.closeDropdownImmediately() : ctx.closeOnItemClick && ctx.closeDropdownImmediately());
  }), colors = color2 ? theme.variantColorResolver({ color: color2, theme, variant: "light" }) : void 0, parsedThemeColor = color2 ? parseThemeColor({ color: color2, theme }) : null, handleKeydown = createEventHandler(_others.onKeyDown, (event) => {
    event.key === "ArrowLeft" && subCtx && (subCtx.close(), subCtx.focusParentItem());
  });
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      onMouseDown: (event) => event.preventDefault(),
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-disabled": disabled || dataDisabled || void 0,
      "data-mantine-stop-propagation": !0,
      onClick: handleClick,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: handleKeydown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
        "--menu-item-hover": colors?.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection })
      ]
    }
  );
});
MenuItem.classes = classes$d;
MenuItem.displayName = "@mantine/core/MenuItem";
const MenuLabel = factory((props, ref) => {
  const { classNames, className, style: style2, styles, vars, ...others } = useProps(
    "MenuLabel",
    null,
    props
  ), ctx = useMenuContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...ctx.getStyles("label", { className, style: style2, styles, classNames }),
      ...others
    }
  );
});
MenuLabel.classes = classes$d;
MenuLabel.displayName = "@mantine/core/MenuLabel";
const MenuSubDropdown = factory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    onMouseEnter,
    onMouseLeave,
    onKeyDown,
    children: children2,
    ...others
  } = useProps("MenuSubDropdown", null, props), wrapperRef = useRef(null), ctx = useMenuContext(), subCtx = useSubMenuContext(), handleMouseEnter = createEventHandler(onMouseEnter, subCtx?.open), handleMouseLeave = createEventHandler(onMouseLeave, subCtx?.close);
  return /* @__PURE__ */ jsx(
    Popover.Dropdown,
    {
      ...others,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      role: "menu",
      "aria-orientation": "vertical",
      ref: useMergedRef(ref, wrapperRef),
      ...ctx.getStyles("dropdown", {
        className,
        style: style2,
        styles,
        classNames,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      children: children2
    }
  );
});
MenuSubDropdown.classes = classes$d;
MenuSubDropdown.displayName = "@mantine/core/MenuSubDropdown";
const MenuSubItem = polymorphicFactory((props, ref) => {
  const {
    classNames,
    className,
    style: style2,
    styles,
    vars,
    color: color2,
    leftSection,
    rightSection,
    children: children2,
    disabled,
    "data-disabled": dataDisabled,
    closeMenuOnClick,
    ...others
  } = useProps("MenuSubItem", null, props), ctx = useMenuContext(), subCtx = useSubMenuContext(), theme = useMantineTheme(), { dir } = useDirection(), itemRef = useRef(null), _others = others, colors = color2 ? theme.variantColorResolver({ color: color2, theme, variant: "light" }) : void 0, parsedThemeColor = color2 ? parseThemeColor({ color: color2, theme }) : null, handleKeydown = createEventHandler(_others.onKeyDown, (event) => {
    event.key === "ArrowRight" && (subCtx?.open(), subCtx?.focusFirstItem()), event.key === "ArrowLeft" && subCtx?.parentContext && (subCtx.parentContext.close(), subCtx.parentContext.focusParentItem());
  }), handleClick = createEventHandler(_others.onClick, () => {
    !dataDisabled && closeMenuOnClick && ctx.closeDropdownImmediately();
  }), handleMouseEnter = createEventHandler(_others.onMouseEnter, subCtx?.open), handleMouseLeave = createEventHandler(_others.onMouseLeave, subCtx?.close);
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      onMouseDown: (event) => event.preventDefault(),
      ...others,
      unstyled: ctx.unstyled,
      tabIndex: ctx.menuItemTabIndex,
      ...ctx.getStyles("item", { className, style: style2, styles, classNames }),
      ref: useMergedRef(itemRef, ref),
      role: "menuitem",
      disabled,
      "data-menu-item": !0,
      "data-sub-menu-item": !0,
      "data-disabled": disabled || dataDisabled || void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onClick: handleClick,
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: ctx.loop,
        dir,
        orientation: "vertical",
        onKeyDown: handleKeydown
      }),
      __vars: {
        "--menu-item-color": parsedThemeColor?.isThemeColor && parsedThemeColor?.shade === void 0 ? `var(--mantine-color-${parsedThemeColor.color}-6)` : colors?.color,
        "--menu-item-hover": colors?.hover
      },
      children: [
        leftSection && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemLabel", { styles, classNames }), children: children2 }),
        /* @__PURE__ */ jsx("div", { ...ctx.getStyles("itemSection", { styles, classNames }), "data-position": "right", children: rightSection || /* @__PURE__ */ jsx(AccordionChevron, { ...ctx.getStyles("chevron"), size: 14 }) })
      ]
    }
  );
});
MenuSubItem.classes = classes$d;
MenuSubItem.displayName = "@mantine/core/MenuSubItem";
function MenuSubTarget({ children: children2, refProp }) {
  if (!isElement$1(children2))
    throw new Error(
      "Menu.Sub.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return useMenuContext(), /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", children: children2 });
}
MenuSubTarget.displayName = "@mantine/core/MenuSubTarget";
const defaultProps$g = {
  offset: 0,
  position: "right-start",
  transitionProps: { duration: 0 },
  openDelay: 0,
  middlewares: {
    shift: {
      // Enable crossAxis shift to keep submenu dropdown within viewport bounds when positioned horizontally
      crossAxis: !0
    }
  }
};
function MenuSub(_props) {
  const { children: children2, closeDelay, openDelay, ...others } = useProps("MenuSub", defaultProps$g, _props), id2 = useId$1(), [opened, { open, close }] = useDisclosure(!1), ctx = useSubMenuContext(), { openDropdown, closeDropdown } = useDelayedHover({
    open,
    close,
    closeDelay,
    openDelay
  });
  return /* @__PURE__ */ jsx(
    SubMenuProvider,
    {
      value: {
        opened,
        close: closeDropdown,
        open: openDropdown,
        focusFirstItem: () => window.setTimeout(() => {
          document.getElementById(`${id2}-dropdown`)?.querySelectorAll("[data-menu-item]:not([data-disabled])")[0]?.focus();
        }, 16),
        focusParentItem: () => window.setTimeout(() => {
          document.getElementById(`${id2}-target`)?.focus();
        }, 16),
        parentContext: ctx
      },
      children: /* @__PURE__ */ jsx(Popover, { opened, withinPortal: !1, withArrow: !1, id: id2, ...others, children: children2 })
    }
  );
}
MenuSub.extend = (input) => input;
MenuSub.displayName = "@mantine/core/MenuSub";
MenuSub.Target = MenuSubTarget;
MenuSub.Dropdown = MenuSubDropdown;
MenuSub.Item = MenuSubItem;
const defaultProps$f = {
  refProp: "ref"
}, MenuTarget = forwardRef((props, ref) => {
  const { children: children2, refProp, ...others } = useProps("MenuTarget", defaultProps$f, props), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const ctx = useMenuContext(), _childProps = child.props, onClick = createEventHandler(_childProps.onClick, () => {
    ctx.trigger === "click" ? ctx.toggleDropdown() : ctx.trigger === "click-hover" && (ctx.setOpenedViaClick(!0), ctx.opened || ctx.openDropdown());
  }), onMouseEnter = createEventHandler(
    _childProps.onMouseEnter,
    () => (ctx.trigger === "hover" || ctx.trigger === "click-hover") && ctx.openDropdown()
  ), onMouseLeave = createEventHandler(_childProps.onMouseLeave, () => {
    (ctx.trigger === "hover" || ctx.trigger === "click-hover" && !ctx.openedViaClick) && ctx.closeDropdown();
  });
  return /* @__PURE__ */ jsx(Popover.Target, { refProp, popupType: "menu", ref, ...others, children: cloneElement(child, {
    onClick,
    onMouseEnter,
    onMouseLeave,
    "data-expanded": ctx.opened ? !0 : void 0
  }) });
});
MenuTarget.displayName = "@mantine/core/MenuTarget";
const defaultProps$e = {
  trapFocus: !0,
  closeOnItemClick: !0,
  withInitialFocusPlaceholder: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function Menu(_props) {
  const props = useProps("Menu", defaultProps$e, _props), {
    children: children2,
    onOpen,
    onClose,
    opened,
    defaultOpened,
    trapFocus,
    onChange,
    closeOnItemClick,
    loop,
    closeOnEscape: closeOnEscape2,
    trigger,
    openDelay,
    closeDelay,
    classNames,
    styles,
    unstyled,
    variant,
    vars,
    menuItemTabIndex,
    keepMounted,
    withInitialFocusPlaceholder,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Menu",
    classes: classes$d,
    props,
    classNames,
    styles,
    unstyled,
    attributes
  }), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), [openedViaClick, setOpenedViaClick] = useState(!1), close = () => {
    setOpened(!1), setOpenedViaClick(!1), _opened && onClose?.();
  }, open = () => {
    setOpened(!0), !_opened && onOpen?.();
  }, toggleDropdown = () => {
    _opened ? close() : open();
  }, { openDropdown, closeDropdown } = useDelayedHover({ open, close, closeDelay, openDelay }), getItemIndex = (node) => getContextItemIndex("[data-menu-item]", "[data-menu-dropdown]", node), { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  return /* @__PURE__ */ jsx(
    MenuContextProvider,
    {
      value: {
        getStyles: getStyles2,
        opened: _opened,
        toggleDropdown,
        getItemIndex,
        openedViaClick,
        setOpenedViaClick,
        closeOnItemClick,
        closeDropdown: trigger === "click" ? close : closeDropdown,
        openDropdown: trigger === "click" ? open : openDropdown,
        closeDropdownImmediately: close,
        loop,
        trigger,
        unstyled,
        menuItemTabIndex,
        withInitialFocusPlaceholder
      },
      children: /* @__PURE__ */ jsx(
        Popover,
        {
          returnFocus: !0,
          ...others,
          opened: _opened,
          onChange: toggleDropdown,
          defaultOpened,
          trapFocus: keepMounted ? !1 : trapFocus,
          closeOnEscape: closeOnEscape2,
          __staticSelector: "Menu",
          classNames: resolvedClassNames,
          styles: resolvedStyles,
          unstyled,
          variant,
          keepMounted,
          children: children2
        }
      )
    }
  );
}
Menu.extend = (input) => input;
Menu.withProps = getWithProps(Menu);
Menu.classes = classes$d;
Menu.displayName = "@mantine/core/Menu";
Menu.Item = MenuItem;
Menu.Label = MenuLabel;
Menu.Dropdown = MenuDropdown;
Menu.Target = MenuTarget;
Menu.Divider = MenuDivider;
Menu.Sub = MenuSub;
const [ModalProvider, useModalContext] = createSafeContext(
  "Modal component was not found in tree"
);
var classes$c = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" };
const ModalBody = factory((_props, ref) => {
  const props = useProps("ModalBody", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseBody,
    {
      ref,
      ...ctx.getStyles("body", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalBody.classes = classes$c;
ModalBody.displayName = "@mantine/core/ModalBody";
const ModalContent = factory((_props, ref) => {
  const props = useProps("ModalContent", null, _props), { classNames, className, style: style2, styles, vars, children: children2, __hidden, ...others } = props, ctx = useModalContext(), Scroll = ctx.scrollAreaComponent || NativeScrollArea;
  return /* @__PURE__ */ jsx(
    ModalBaseContent,
    {
      ...ctx.getStyles("content", { className, style: style2, styles, classNames }),
      innerProps: ctx.getStyles("inner", { className, style: style2, styles, classNames }),
      "data-full-screen": ctx.fullScreen || void 0,
      "data-modal-content": !0,
      "data-hidden": __hidden || void 0,
      ref,
      ...others,
      children: /* @__PURE__ */ jsx(
        Scroll,
        {
          style: {
            maxHeight: ctx.fullScreen ? "100dvh" : `calc(100dvh - (${rem(ctx.yOffset)} * 2))`
          },
          children: children2
        }
      )
    }
  );
});
ModalContent.classes = classes$c;
ModalContent.displayName = "@mantine/core/ModalContent";
const ModalOverlay = factory((_props, ref) => {
  const props = useProps("ModalOverlay", null, _props), { classNames, className, style: style2, styles, vars, ...others } = props, ctx = useModalContext();
  return /* @__PURE__ */ jsx(
    ModalBaseOverlay,
    {
      ref,
      ...ctx.getStyles("overlay", { classNames, style: style2, styles, className }),
      ...others
    }
  );
});
ModalOverlay.classes = classes$c;
ModalOverlay.displayName = "@mantine/core/ModalOverlay";
const defaultProps$d = {
  __staticSelector: "Modal",
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: getDefaultZIndex("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  yOffset: "5dvh"
}, varsResolver$d = (_2, { radius, size: size2, yOffset, xOffset }) => ({
  root: {
    "--modal-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--modal-size": getSize(size2, "modal-size"),
    "--modal-y-offset": rem(yOffset),
    "--modal-x-offset": rem(xOffset)
  }
}), ModalRoot = factory((_props, ref) => {
  const props = useProps("ModalRoot", defaultProps$d, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    yOffset,
    scrollAreaComponent,
    radius,
    fullScreen,
    centered,
    xOffset,
    __staticSelector,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: __staticSelector,
    classes: classes$c,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$d
  });
  return /* @__PURE__ */ jsx(ModalProvider, { value: { yOffset, scrollAreaComponent, getStyles: getStyles2, fullScreen }, children: /* @__PURE__ */ jsx(
    ModalBase,
    {
      ref,
      ...getStyles2("root"),
      "data-full-screen": fullScreen || void 0,
      "data-centered": centered || void 0,
      "data-offset-scrollbars": scrollAreaComponent === ScrollArea.Autosize || void 0,
      unstyled,
      ...others
    }
  ) });
});
ModalRoot.classes = classes$c;
ModalRoot.displayName = "@mantine/core/ModalRoot";
const [PillsInputProvider, usePillsInputContext] = createOptionalContext(), [PillGroupProvider, usePillGroupContext] = createOptionalContext();
var classes$b = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };
const varsResolver$c = (_2, { gap }, { size: size2 }) => ({
  group: {
    "--pg-gap": gap !== void 0 ? getSize(gap) : getSize(size2, "pg-gap")
  }
}), PillGroup = factory((_props, ref) => {
  const props = useProps("PillGroup", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    size: size2,
    disabled,
    attributes,
    ...others
  } = props, _size = usePillsInputContext()?.size || size2 || void 0, getStyles2 = useStyles({
    name: "PillGroup",
    classes: classes$b,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$c,
    stylesCtx: { size: _size },
    rootSelector: "group"
  });
  return /* @__PURE__ */ jsx(PillGroupProvider, { value: { size: _size, disabled }, children: /* @__PURE__ */ jsx(Box, { ref, size: _size, ...getStyles2("group"), ...others }) });
});
PillGroup.classes = classes$b;
PillGroup.displayName = "@mantine/core/PillGroup";
const defaultProps$c = {
  variant: "default"
}, varsResolver$b = (_2, { radius }, { size: size2 }) => ({
  root: {
    "--pill-fz": getSize(size2, "pill-fz"),
    "--pill-height": getSize(size2, "pill-height"),
    "--pill-radius": radius === void 0 ? void 0 : getRadius$1(radius)
  }
}), Pill = factory((_props, ref) => {
  const props = useProps("Pill", defaultProps$c, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    variant,
    children: children2,
    withRemoveButton,
    onRemove: onRemove2,
    removeButtonProps,
    radius,
    size: size2,
    disabled,
    mod,
    attributes,
    ...others
  } = props, ctx = usePillGroupContext(), pillsInputCtx = usePillsInputContext(), _size = size2 || ctx?.size || void 0, _variant = pillsInputCtx?.variant === "filled" ? "contrast" : variant || "default", getStyles2 = useStyles({
    name: "Pill",
    classes: classes$b,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$b,
    stylesCtx: { size: _size }
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      component: "span",
      ref,
      variant: _variant,
      size: _size,
      ...getStyles2("root", { variant: _variant }),
      mod: [
        { "with-remove": withRemoveButton && !disabled, disabled: disabled || ctx?.disabled },
        mod
      ],
      ...others,
      children: [
        /* @__PURE__ */ jsx("span", { ...getStyles2("label"), children: children2 }),
        withRemoveButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            variant: "transparent",
            radius,
            tabIndex: -1,
            "aria-hidden": !0,
            unstyled,
            ...removeButtonProps,
            ...getStyles2("remove", {
              className: removeButtonProps?.className,
              style: removeButtonProps?.style
            }),
            onMouseDown: (event) => {
              event.preventDefault(), event.stopPropagation(), removeButtonProps?.onMouseDown?.(event);
            },
            onClick: (event) => {
              event.stopPropagation(), onRemove2?.(), removeButtonProps?.onClick?.(event);
            }
          }
        )
      ]
    }
  );
});
Pill.classes = classes$b;
Pill.displayName = "@mantine/core/Pill";
Pill.Group = PillGroup;
var classes$a = { root: "m_f0824112", description: "m_57492dcc", section: "m_690090b5", label: "m_1f6ac4c4", body: "m_f07af9d2", children: "m_e17b862f", chevron: "m_1fd8a00b" };
const varsResolver$a = (theme, { variant, color: color2, childrenOffset, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    variant: variant || "light",
    autoContrast
  });
  return {
    root: {
      "--nl-bg": color2 || variant ? colors.background : void 0,
      "--nl-hover": color2 || variant ? colors.hover : void 0,
      "--nl-color": color2 || variant ? colors.color : void 0
    },
    children: {
      "--nl-offset": getSpacing(childrenOffset)
    }
  };
}, NavLink = polymorphicFactory((_props, ref) => {
  const props = useProps("NavLink", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    opened,
    defaultOpened,
    onChange,
    children: children2,
    active,
    disabled,
    leftSection,
    rightSection,
    label,
    description,
    disableRightSectionRotation,
    noWrap,
    childrenOffset,
    autoContrast,
    mod,
    attributes,
    onClick,
    onKeyDown,
    ...others
  } = props, getStyles2 = useStyles({
    name: "NavLink",
    props,
    classes: classes$a,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$a
  }), [_opened, setOpened] = useUncontrolled({
    value: opened,
    defaultValue: defaultOpened,
    finalValue: !1,
    onChange
  }), withChildren = !!children2, handleClick = (event) => {
    onClick?.(event), withChildren && (event.preventDefault(), setOpened(!_opened));
  };
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        ...getStyles2("root"),
        component: "a",
        ref,
        onClick: handleClick,
        onKeyDown: (event) => {
          onKeyDown?.(event), event.nativeEvent.code === "Space" && withChildren && (event.preventDefault(), setOpened(!_opened));
        },
        unstyled,
        mod: [{ disabled, active, expanded: _opened }, mod],
        ...others,
        children: [
          leftSection && /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("section"), mod: { position: "left" }, children: leftSection }),
          /* @__PURE__ */ jsxs(Box, { ...getStyles2("body"), mod: { "no-wrap": noWrap }, children: [
            /* @__PURE__ */ jsx(Box, { component: "span", ...getStyles2("label"), children: label }),
            /* @__PURE__ */ jsx(Box, { component: "span", mod: { active }, ...getStyles2("description"), children: description })
          ] }),
          (withChildren || rightSection !== void 0) && /* @__PURE__ */ jsx(
            Box,
            {
              ...getStyles2("section"),
              component: "span",
              mod: { rotate: _opened && !disableRightSectionRotation, position: "right" },
              children: withChildren ? rightSection !== void 0 ? rightSection : /* @__PURE__ */ jsx(AccordionChevron, { ...getStyles2("chevron") }) : rightSection
            }
          )
        ]
      }
    ),
    withChildren && /* @__PURE__ */ jsx(Collapse, { in: _opened, ...getStyles2("collapse"), children: /* @__PURE__ */ jsx("div", { ...getStyles2("children"), children: children2 }) })
  ] });
});
NavLink.classes = classes$a;
NavLink.displayName = "@mantine/core/NavLink";
var classes$9 = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" };
const defaultProps$b = {
  withCloseButton: !0
}, varsResolver$9 = (theme, { radius, color: color2 }) => ({
  root: {
    "--notification-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--notification-color": color2 ? getThemeColor(color2, theme) : void 0
  }
}), Notification = factory((_props, ref) => {
  const props = useProps("Notification", defaultProps$b, _props), {
    className,
    color: color2,
    radius,
    loading,
    withCloseButton,
    withBorder,
    title,
    icon,
    children: children2,
    onClose,
    closeButtonProps,
    classNames,
    style: style2,
    styles,
    unstyled,
    variant,
    vars,
    mod,
    loaderProps,
    role,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Notification",
    classes: classes$9,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$9
  });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      mod: [{ "data-with-icon": !!icon || loading, "data-with-border": withBorder }, mod],
      ref,
      variant,
      role: role || "alert",
      ...others,
      children: [
        icon && !loading && /* @__PURE__ */ jsx("div", { ...getStyles2("icon"), children: icon }),
        loading && /* @__PURE__ */ jsx(Loader, { size: 28, color: color2, ...loaderProps, ...getStyles2("loader") }),
        /* @__PURE__ */ jsxs("div", { ...getStyles2("body"), children: [
          title && /* @__PURE__ */ jsx("div", { ...getStyles2("title"), children: title }),
          /* @__PURE__ */ jsx(Box, { ...getStyles2("description"), mod: { "data-with-title": !!title }, children: children2 })
        ] }),
        withCloseButton && /* @__PURE__ */ jsx(
          CloseButton,
          {
            iconSize: 16,
            color: "gray",
            ...closeButtonProps,
            unstyled,
            onClick: onClose,
            ...getStyles2("closeButton")
          }
        )
      ]
    }
  );
});
Notification.classes = classes$9;
Notification.displayName = "@mantine/core/Notification";
const defaultTransition = {
  duration: 100,
  transition: "fade"
};
function getTransitionProps(transitionProps, componentTransition) {
  return { ...defaultTransition, ...componentTransition, ...transitionProps };
}
function useFloatingTooltip({
  offset: offset2,
  position,
  defaultOpened
}) {
  const [opened, setOpened] = useState(defaultOpened), boundaryRef = useRef(null), { x: x2, y: y2, elements, refs, update, placement } = useFloating({
    placement: position,
    middleware: [
      shift({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), horizontalOffset = placement.includes("right") ? offset2 : position.includes("left") ? offset2 * -1 : 0, verticalOffset = placement.includes("bottom") ? offset2 : position.includes("top") ? offset2 * -1 : 0, handleMouseMove = useCallback(
    ({ clientX, clientY }) => {
      refs.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: clientX,
            y: clientY,
            left: clientX + horizontalOffset,
            top: clientY + verticalOffset,
            right: clientX,
            bottom: clientY
          };
        }
      });
    },
    [elements.reference]
  );
  return useEffect(() => {
    if (refs.floating.current) {
      const boundary = boundaryRef.current;
      boundary.addEventListener("mousemove", handleMouseMove);
      const parents = getOverflowAncestors(refs.floating.current);
      return parents.forEach((parent) => {
        parent.addEventListener("scroll", update);
      }), () => {
        boundary.removeEventListener("mousemove", handleMouseMove), parents.forEach((parent) => {
          parent.removeEventListener("scroll", update);
        });
      };
    }
  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]), { handleMouseMove, x: x2, y: y2, opened, setOpened, boundaryRef, floating: refs.setFloating };
}
var classes$8 = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
const defaultProps$a = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  position: "right",
  zIndex: getDefaultZIndex("popover")
}, varsResolver$8 = (theme, { radius, color: color2 }) => ({
  tooltip: {
    "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--tooltip-bg": color2 ? getThemeColor(color2, theme) : void 0,
    "--tooltip-color": color2 ? "var(--mantine-color-white)" : void 0
  }
}), TooltipFloating = factory((_props, ref) => {
  const props = useProps("TooltipFloating", defaultProps$a, _props), {
    children: children2,
    refProp,
    withinPortal,
    style: style2,
    className,
    classNames,
    styles,
    unstyled,
    radius,
    color: color2,
    label,
    offset: offset2,
    position,
    multiline,
    zIndex,
    disabled,
    defaultOpened,
    variant,
    vars,
    portalProps,
    attributes,
    ...others
  } = props, theme = useMantineTheme(), getStyles2 = useStyles({
    name: "TooltipFloating",
    props,
    classes: classes$8,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$8
  }), { handleMouseMove, x: x2, y: y2, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({
    offset: offset2,
    position,
    defaultOpened
  }), child = getSingleElementChild(children2);
  if (!child)
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const targetRef = useMergedRef(boundaryRef, getRefProp(child), ref), childProps = child.props, onMouseEnter = (event) => {
    childProps.onMouseEnter?.(event), handleMouseMove(event), setOpened(!0);
  }, onMouseLeave = (event) => {
    childProps.onMouseLeave?.(event), setOpened(!1);
  };
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Box,
      {
        ...others,
        ...getStyles2("tooltip", {
          style: {
            ...getStyleObject(style2, theme),
            zIndex,
            display: !disabled && opened ? "block" : "none",
            top: (y2 && Math.round(y2)) ?? "",
            left: (x2 && Math.round(x2)) ?? ""
          }
        }),
        variant,
        ref: floating,
        mod: { multiline },
        children: label
      }
    ) }),
    cloneElement(child, {
      ...childProps,
      [refProp]: targetRef,
      onMouseEnter,
      onMouseLeave
    })
  ] });
});
TooltipFloating.classes = classes$8;
TooltipFloating.displayName = "@mantine/core/TooltipFloating";
const TooltipGroupContext = createContext(!1), TooltipGroupProvider = TooltipGroupContext.Provider, useTooltipGroupContext = () => useContext(TooltipGroupContext), defaultProps$9 = {
  openDelay: 0,
  closeDelay: 0
};
function TooltipGroup(props) {
  const { openDelay, closeDelay, children: children2 } = useProps("TooltipGroup", defaultProps$9, props);
  return /* @__PURE__ */ jsx(TooltipGroupProvider, { value: !0, children: /* @__PURE__ */ jsx(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay }, children: children2 }) });
}
TooltipGroup.displayName = "@mantine/core/TooltipGroup";
TooltipGroup.extend = (c) => c;
function getDefaultMiddlewares(middlewares) {
  if (middlewares === void 0)
    return { shift: !0, flip: !0 };
  const result = { ...middlewares };
  return middlewares.shift === void 0 && (result.shift = !0), middlewares.flip === void 0 && (result.flip = !0), result;
}
function getTooltipMiddlewares(settings) {
  const middlewaresOptions = getDefaultMiddlewares(settings.middlewares), middlewares = [offset(settings.offset)];
  return middlewaresOptions.shift && middlewares.push(
    shift(
      typeof middlewaresOptions.shift == "boolean" ? { padding: 8 } : { padding: 8, ...middlewaresOptions.shift }
    )
  ), middlewaresOptions.flip && middlewares.push(
    typeof middlewaresOptions.flip == "boolean" ? flip() : flip(middlewaresOptions.flip)
  ), middlewares.push(arrow({ element: settings.arrowRef, padding: settings.arrowOffset })), middlewaresOptions.inline ? middlewares.push(
    typeof middlewaresOptions.inline == "boolean" ? inline() : inline(middlewaresOptions.inline)
  ) : settings.inline && middlewares.push(inline()), middlewares;
}
function useTooltip(settings) {
  const [uncontrolledOpened, setUncontrolledOpened] = useState(settings.defaultOpened), opened = typeof settings.opened == "boolean" ? settings.opened : uncontrolledOpened, withinGroup = useTooltipGroupContext(), uid = useId$1(), onChange = useCallback(
    (_opened) => {
      setUncontrolledOpened(_opened), _opened && setCurrentId(uid);
    },
    [uid]
  ), {
    x: x2,
    y: y2,
    context,
    refs,
    placement,
    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }
  } = useFloating({
    strategy: settings.strategy,
    placement: settings.position,
    open: opened,
    onOpenChange: onChange,
    middleware: getTooltipMiddlewares(settings),
    whileElementsMounted: autoUpdate
  }), { delay: groupDelay, currentId, setCurrentId } = useDelayGroup(context, { id: uid }), { getReferenceProps, getFloatingProps } = useInteractions([
    useHover(context, {
      enabled: settings.events?.hover,
      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },
      mouseOnly: !settings.events?.touch
    }),
    useFocus(context, { enabled: settings.events?.focus, visibleOnly: !0 }),
    useRole(context, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    useDismiss(context, { enabled: typeof settings.opened > "u" })
  ]);
  useDidUpdate(() => {
    settings.onPositionChange?.(placement);
  }, [placement]);
  const isGroupPhase = opened && currentId && currentId !== uid;
  return {
    x: x2,
    y: y2,
    arrowX,
    arrowY,
    reference: refs.setReference,
    floating: refs.setFloating,
    getFloatingProps,
    getReferenceProps,
    isGroupPhase,
    opened,
    placement
  };
}
const defaultProps$8 = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: getDefaultZIndex("popover"),
  positionDependencies: [],
  middlewares: { flip: !0, shift: !0, inline: !1 }
}, varsResolver$7 = (theme, { radius, color: color2, variant, autoContrast }) => {
  const colors = theme.variantColorResolver({
    theme,
    color: color2 || theme.primaryColor,
    autoContrast,
    variant: variant || "filled"
  });
  return {
    tooltip: {
      "--tooltip-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--tooltip-bg": color2 ? colors.background : void 0,
      "--tooltip-color": color2 ? colors.color : void 0
    }
  };
}, Tooltip = factory((_props, ref) => {
  const props = useProps("Tooltip", defaultProps$8, _props), {
    children: children2,
    position,
    refProp,
    label,
    openDelay,
    closeDelay,
    onPositionChange,
    opened,
    defaultOpened,
    withinPortal,
    radius,
    color: color2,
    classNames,
    styles,
    unstyled,
    style: style2,
    className,
    withArrow,
    arrowSize,
    arrowOffset,
    arrowRadius,
    arrowPosition,
    offset: offset2,
    transitionProps,
    multiline,
    events,
    zIndex,
    disabled,
    // Scheduled for removal in 9.0
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionDependencies,
    onClick,
    onMouseEnter,
    onMouseLeave,
    inline: inline2,
    variant,
    keepMounted,
    vars,
    portalProps,
    mod,
    floatingStrategy,
    middlewares,
    autoContrast,
    attributes,
    target,
    ...others
  } = useProps("Tooltip", defaultProps$8, props), { dir } = useDirection(), arrowRef = useRef(null), tooltip = useTooltip({
    position: getFloatingPosition(dir, position),
    closeDelay,
    openDelay,
    onPositionChange,
    opened,
    defaultOpened,
    events,
    arrowRef,
    arrowOffset,
    offset: typeof offset2 == "number" ? offset2 + (withArrow ? arrowSize / 2 : 0) : offset2,
    positionDependencies: [...positionDependencies, target ?? children2],
    inline: inline2,
    strategy: floatingStrategy,
    middlewares
  });
  useEffect(() => {
    const targetNode = target instanceof HTMLElement ? target : typeof target == "string" ? document.querySelector(target) : target?.current || null;
    targetNode && tooltip.reference(targetNode);
  }, [target, tooltip]);
  const getStyles2 = useStyles({
    name: "Tooltip",
    props,
    classes: classes$8,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    rootSelector: "tooltip",
    vars,
    varsResolver: varsResolver$7
  }), child = getSingleElementChild(children2);
  if (!target && !child)
    return null;
  if (target) {
    const transition2 = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
    return /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition$1,
      {
        ...transition2,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition2.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }) });
  }
  const childProps = child.props, targetRef = useMergedRef(tooltip.reference, getRefProp(child), ref), transition = getTransitionProps(transitionProps, { duration: 100, transition: "fade" });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(OptionalPortal, { ...portalProps, withinPortal, children: /* @__PURE__ */ jsx(
      Transition$1,
      {
        ...transition,
        keepMounted,
        mounted: !disabled && !!tooltip.opened,
        duration: tooltip.isGroupPhase ? 10 : transition.duration,
        children: (transitionStyles) => /* @__PURE__ */ jsxs(
          Box,
          {
            ...others,
            "data-fixed": floatingStrategy === "fixed" || void 0,
            variant,
            mod: [{ multiline }, mod],
            ...tooltip.getFloatingProps({
              ref: tooltip.floating,
              className: getStyles2("tooltip").className,
              style: {
                ...getStyles2("tooltip").style,
                ...transitionStyles,
                zIndex,
                top: tooltip.y ?? 0,
                left: tooltip.x ?? 0
              }
            }),
            children: [
              label,
              /* @__PURE__ */ jsx(
                FloatingArrow,
                {
                  ref: arrowRef,
                  arrowX: tooltip.arrowX,
                  arrowY: tooltip.arrowY,
                  visible: withArrow,
                  position: tooltip.placement,
                  arrowSize,
                  arrowOffset,
                  arrowRadius,
                  arrowPosition,
                  ...getStyles2("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    cloneElement(
      child,
      tooltip.getReferenceProps({
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseMove: props.onMouseMove,
        onPointerDown: props.onPointerDown,
        onPointerEnter: props.onPointerEnter,
        ...childProps,
        className: clsx(className, childProps.className),
        [refProp]: targetRef
      })
    )
  ] });
});
Tooltip.classes = classes$8;
Tooltip.displayName = "@mantine/core/Tooltip";
Tooltip.Floating = TooltipFloating;
Tooltip.Group = TooltipGroup;
var classes$7 = { root: "m_cf365364", indicator: "m_9e182ccd", label: "m_1738fcb2", input: "m_1714d588", control: "m_69686b9b", innerLabel: "m_78882f40" };
const defaultProps$7 = {
  withItemsBorders: !0
}, varsResolver$6 = (theme, { radius, color: color2, transitionDuration, size: size2, transitionTimingFunction }) => ({
  root: {
    "--sc-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--sc-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--sc-shadow": color2 ? void 0 : "var(--mantine-shadow-xs)",
    "--sc-transition-duration": transitionDuration === void 0 ? void 0 : `${transitionDuration}ms`,
    "--sc-transition-timing-function": transitionTimingFunction,
    "--sc-padding": getSize(size2, "sc-padding"),
    "--sc-font-size": getFontSize(size2)
  }
}), SegmentedControl = factory((_props, ref) => {
  const props = useProps("SegmentedControl", defaultProps$7, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    value,
    defaultValue,
    onChange,
    size: size2,
    name,
    disabled,
    readOnly,
    fullWidth,
    orientation,
    radius,
    color: color2,
    transitionDuration,
    transitionTimingFunction,
    variant,
    autoContrast,
    withItemsBorders,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SegmentedControl",
    props,
    classes: classes$7,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$6
  }), theme = useMantineTheme(), _data = data.map(
    (item) => typeof item == "string" ? { label: item, value: item } : item
  ), initialized = useMounted(), [key, setKey] = useState(randomId()), [parent, setParent] = useState(null), [refs, setRefs] = useState({}), setElementRef = (element, val) => {
    refs[val] = element, setRefs(refs);
  }, [_value, handleValueChange] = useUncontrolled({
    value,
    defaultValue,
    finalValue: Array.isArray(data) ? _data.find((item) => !item.disabled)?.value ?? data[0]?.value ?? null : null,
    onChange
  }), uuid2 = useId$1(name), controls = _data.map((item) => /* @__PURE__ */ createElement(
    Box,
    {
      ...getStyles2("control"),
      mod: { active: _value === item.value, orientation },
      key: item.value
    },
    /* @__PURE__ */ createElement(
      "input",
      {
        ...getStyles2("input"),
        disabled: disabled || item.disabled,
        type: "radio",
        name: uuid2,
        value: item.value,
        id: `${uuid2}-${item.value}`,
        checked: _value === item.value,
        onChange: () => !readOnly && handleValueChange(item.value),
        "data-focus-ring": theme.focusRing,
        key: `${item.value}-input`
      }
    ),
    /* @__PURE__ */ createElement(
      Box,
      {
        component: "label",
        ...getStyles2("label"),
        mod: {
          active: _value === item.value && !(disabled || item.disabled),
          disabled: disabled || item.disabled,
          "read-only": readOnly
        },
        htmlFor: `${uuid2}-${item.value}`,
        ref: (node) => setElementRef(node, item.value),
        __vars: {
          "--sc-label-color": color2 !== void 0 ? getContrastColor({ color: color2, theme, autoContrast }) : void 0
        },
        key: `${item.value}-label`
      },
      /* @__PURE__ */ jsx("span", { ...getStyles2("innerLabel"), children: item.label })
    )
  )), mergedRef = useMergedRef(ref, (node) => setParent(node));
  return useShallowEffect(() => {
    setKey(randomId());
  }, [data.length]), data.length === 0 ? null : /* @__PURE__ */ jsxs(
    Box,
    {
      ...getStyles2("root"),
      variant,
      size: size2,
      ref: mergedRef,
      mod: [
        {
          "full-width": fullWidth,
          orientation,
          initialized,
          "with-items-borders": withItemsBorders
        },
        mod
      ],
      ...others,
      role: "radiogroup",
      "data-disabled": disabled,
      children: [
        typeof _value == "string" && /* @__PURE__ */ jsx(
          FloatingIndicator,
          {
            target: refs[_value],
            parent,
            component: "span",
            transitionDuration: "var(--sc-transition-duration)",
            ...getStyles2("indicator")
          },
          key
        ),
        controls
      ]
    }
  );
});
SegmentedControl.classes = classes$7;
SegmentedControl.displayName = "@mantine/core/SegmentedControl";
const defaultProps$6 = {
  withCheckIcon: !0,
  allowDeselect: !0,
  checkIconPosition: "left"
}, Select = factory((_props, ref) => {
  const props = useProps("Select", defaultProps$6, _props), {
    classNames,
    styles,
    unstyled,
    vars,
    dropdownOpened,
    defaultDropdownOpened,
    onDropdownClose,
    onDropdownOpen,
    onFocus,
    onBlur,
    onClick,
    onChange,
    data,
    value,
    defaultValue,
    selectFirstOptionOnChange,
    onOptionSubmit,
    comboboxProps,
    readOnly,
    disabled,
    filter: filter2,
    limit,
    withScrollArea,
    maxDropdownHeight,
    size: size2,
    searchable,
    rightSection,
    checkIconPosition,
    withCheckIcon,
    withAlignedLabels,
    nothingFoundMessage,
    name,
    form,
    searchValue,
    defaultSearchValue,
    onSearchChange,
    allowDeselect,
    error,
    rightSectionPointerEvents,
    id: id2,
    clearable,
    clearButtonProps,
    hiddenInputProps,
    renderOption,
    onClear,
    autoComplete,
    scrollAreaProps,
    __defaultRightSection,
    __clearSection,
    __clearable,
    chevronColor,
    autoSelectOnBlur,
    attributes,
    ...others
  } = props, parsedData = useMemo(() => getParsedComboboxData(data), [data]), retainedSelectedOptions = useRef({}), optionsLockup = useMemo(() => getOptionsLockup(parsedData), [parsedData]), _id = useId$1(id2), [_value, setValue, controlled] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), selectedOption = typeof _value == "string" ? _value in optionsLockup ? optionsLockup[_value] : retainedSelectedOptions.current[_value] : void 0, previousSelectedOption = usePrevious$1(selectedOption), [search, setSearch, searchControlled] = useUncontrolled({
    value: searchValue,
    defaultValue: defaultSearchValue,
    finalValue: selectedOption ? selectedOption.label : "",
    onChange: onSearchChange
  }), combobox = useCombobox({
    opened: dropdownOpened,
    defaultOpened: defaultDropdownOpened,
    onDropdownOpen: () => {
      onDropdownOpen?.(), combobox.updateSelectedOptionIndex("active", { scrollIntoView: !0 });
    },
    onDropdownClose: () => {
      onDropdownClose?.(), setTimeout(combobox.resetSelectedOption, 0);
    }
  }), handleSearchChange = (value2) => {
    setSearch(value2), combobox.resetSelectedOption();
  }, { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    props,
    styles,
    classNames
  });
  useEffect(() => {
    selectFirstOptionOnChange && combobox.selectFirstOption();
  }, [selectFirstOptionOnChange, search]), useEffect(() => {
    value === null && handleSearchChange(""), typeof value == "string" && selectedOption && (previousSelectedOption?.value !== selectedOption.value || previousSelectedOption?.label !== selectedOption.label) && handleSearchChange(selectedOption.label);
  }, [value, selectedOption]), useEffect(() => {
    !controlled && !searchControlled && handleSearchChange(
      typeof _value == "string" ? _value in optionsLockup ? optionsLockup[_value]?.label : retainedSelectedOptions.current[_value]?.label || "" : ""
    );
  }, [optionsLockup, _value]), useEffect(() => {
    _value && _value in optionsLockup && (retainedSelectedOptions.current[_value] = optionsLockup[_value]);
  }, [optionsLockup, _value]);
  const clearButton = /* @__PURE__ */ jsx(
    Combobox.ClearButton,
    {
      ...clearButtonProps,
      onClear: () => {
        setValue(null, null), handleSearchChange(""), onClear?.();
      }
    }
  ), _clearable = clearable && !!_value && !disabled && !readOnly;
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsxs(
      Combobox,
      {
        store: combobox,
        __staticSelector: "Select",
        classNames: resolvedClassNames,
        styles: resolvedStyles,
        unstyled,
        readOnly,
        size: size2,
        attributes,
        keepMounted: autoSelectOnBlur,
        onOptionSubmit: (val) => {
          onOptionSubmit?.(val);
          const optionLockup = allowDeselect && optionsLockup[val].value === _value ? null : optionsLockup[val], nextValue = optionLockup ? optionLockup.value : null;
          nextValue !== _value && setValue(nextValue, optionLockup), !controlled && handleSearchChange(typeof nextValue == "string" && optionLockup?.label || ""), combobox.closeDropdown();
        },
        ...comboboxProps,
        children: [
          /* @__PURE__ */ jsx(Combobox.Target, { targetType: searchable ? "input" : "button", autoComplete, children: /* @__PURE__ */ jsx(
            InputBase,
            {
              id: _id,
              ref,
              __defaultRightSection: /* @__PURE__ */ jsx(
                Combobox.Chevron,
                {
                  size: size2,
                  error,
                  unstyled,
                  color: chevronColor
                }
              ),
              __clearSection: clearButton,
              __clearable: _clearable,
              rightSection,
              rightSectionPointerEvents: rightSectionPointerEvents || "none",
              ...others,
              size: size2,
              __staticSelector: "Select",
              disabled,
              readOnly: readOnly || !searchable,
              value: search,
              onChange: (event) => {
                handleSearchChange(event.currentTarget.value), combobox.openDropdown(), selectFirstOptionOnChange && combobox.selectFirstOption();
              },
              onFocus: (event) => {
                searchable && combobox.openDropdown(), onFocus?.(event);
              },
              onBlur: (event) => {
                autoSelectOnBlur && combobox.clickSelectedOption(), searchable && combobox.closeDropdown();
                const optionLockup = typeof _value == "string" && (_value in optionsLockup ? optionsLockup[_value] : retainedSelectedOptions.current[_value]);
                handleSearchChange(optionLockup && optionLockup.label || ""), onBlur?.(event);
              },
              onClick: (event) => {
                searchable ? combobox.openDropdown() : combobox.toggleDropdown(), onClick?.(event);
              },
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              unstyled,
              pointer: !searchable,
              error,
              attributes
            }
          ) }),
          /* @__PURE__ */ jsx(
            OptionsDropdown,
            {
              data: parsedData,
              hidden: readOnly || disabled,
              filter: filter2,
              search,
              limit,
              hiddenWhenEmpty: !nothingFoundMessage,
              withScrollArea,
              maxDropdownHeight,
              filterOptions: !!searchable && selectedOption?.label !== search,
              value: _value,
              checkIconPosition,
              withCheckIcon,
              withAlignedLabels,
              nothingFoundMessage,
              unstyled,
              labelId: others.label ? `${_id}-label` : void 0,
              "aria-label": others.label ? void 0 : others["aria-label"],
              renderOption,
              scrollAreaProps
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Combobox.HiddenInput,
      {
        value: _value,
        name,
        form,
        disabled,
        ...hiddenInputProps
      }
    )
  ] });
});
Select.classes = { ...InputBase.classes, ...Combobox.classes };
Select.displayName = "@mantine/core/Select";
function SimpleGridMediaVariables({
  spacing,
  verticalSpacing,
  cols,
  selector: selector2
}) {
  const theme = useMantineTheme(), _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing, baseStyles = filterProps$1({
    "--sg-spacing-x": getSpacing(getBaseValue$1(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue$1(_verticalSpacing)),
    "--sg-cols": getBaseValue$1(cols)?.toString()
  }), queries = keys$1(theme.breakpoints).reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof spacing == "object" && spacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint])), typeof _verticalSpacing == "object" && _verticalSpacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint])), typeof cols == "object" && cols[breakpoint] !== void 0 && (acc[breakpoint]["--sg-cols"] = cols[breakpoint]), acc),
    {}
  ), media = getSortedBreakpoints(keys$1(queries), theme.breakpoints).filter(
    (breakpoint) => keys$1(queries[breakpoint.value]).length > 0
  ).map((breakpoint) => ({
    query: `(min-width: ${theme.breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return /* @__PURE__ */ jsx(InlineStyles, { styles: baseStyles, media, selector: selector2 });
}
function getBreakpoints(values2) {
  return typeof values2 == "object" && values2 !== null ? keys$1(values2) : [];
}
function sortBreakpoints(breakpoints) {
  return breakpoints.sort((a2, b) => px$2(a2) - px$2(b));
}
function getUniqueBreakpoints({
  spacing,
  verticalSpacing,
  cols
}) {
  const breakpoints = Array.from(
    /* @__PURE__ */ new Set([
      ...getBreakpoints(spacing),
      ...getBreakpoints(verticalSpacing),
      ...getBreakpoints(cols)
    ])
  );
  return sortBreakpoints(breakpoints);
}
function SimpleGridContainerVariables({
  spacing,
  verticalSpacing,
  cols,
  selector: selector2
}) {
  const _verticalSpacing = verticalSpacing === void 0 ? spacing : verticalSpacing, baseStyles = filterProps$1({
    "--sg-spacing-x": getSpacing(getBaseValue$1(spacing)),
    "--sg-spacing-y": getSpacing(getBaseValue$1(_verticalSpacing)),
    "--sg-cols": getBaseValue$1(cols)?.toString()
  }), uniqueBreakpoints = getUniqueBreakpoints({ spacing, verticalSpacing, cols }), queries = uniqueBreakpoints.reduce(
    (acc, breakpoint) => (acc[breakpoint] || (acc[breakpoint] = {}), typeof spacing == "object" && spacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-x"] = getSpacing(spacing[breakpoint])), typeof _verticalSpacing == "object" && _verticalSpacing[breakpoint] !== void 0 && (acc[breakpoint]["--sg-spacing-y"] = getSpacing(_verticalSpacing[breakpoint])), typeof cols == "object" && cols[breakpoint] !== void 0 && (acc[breakpoint]["--sg-cols"] = cols[breakpoint]), acc),
    {}
  ), media = uniqueBreakpoints.map((breakpoint) => ({
    query: `simple-grid (min-width: ${breakpoint})`,
    styles: queries[breakpoint]
  }));
  return /* @__PURE__ */ jsx(InlineStyles, { styles: baseStyles, container: media, selector: selector2 });
}
var classes$6 = { container: "m_925c2d2c", root: "m_2415a157" };
const defaultProps$5 = {
  cols: 1,
  spacing: "md",
  type: "media"
}, SimpleGrid = factory((_props, ref) => {
  const props = useProps("SimpleGrid", defaultProps$5, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    cols,
    verticalSpacing,
    spacing,
    type,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "SimpleGrid",
    classes: classes$6,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars
  }), responsiveClassName = useRandomClassName();
  return type === "container" ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SimpleGridContainerVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ jsx("div", { ...getStyles2("container"), children: /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others }) })
  ] }) : /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(SimpleGridMediaVariables, { ...props, selector: `.${responsiveClassName}` }),
    /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root", { className: responsiveClassName }), ...others })
  ] });
});
SimpleGrid.classes = classes$6;
SimpleGrid.displayName = "@mantine/core/SimpleGrid";
const [SliderProvider, useSliderContext] = createSafeContext(
  "SliderProvider was not found in tree"
), SliderRoot = forwardRef(
  ({ size: size2, disabled, variant, color: color2, thumbSize, radius, ...others }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext();
    return /* @__PURE__ */ jsx(
      Box,
      {
        tabIndex: -1,
        variant,
        size: size2,
        ref,
        ...getStyles2("root"),
        ...others
      }
    );
  }
);
SliderRoot.displayName = "@mantine/core/SliderRoot";
const Thumb = forwardRef(
  ({
    max: max2,
    min: min2,
    value,
    position,
    label,
    dragging,
    onMouseDown,
    onKeyDownCapture,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    onFocus,
    onBlur,
    showLabelOnHover,
    isHovered,
    children: children2 = null,
    disabled
  }, ref) => {
    const { getStyles: getStyles2 } = useSliderContext(), [focused, setFocused] = useState(!1), isVisible = labelAlwaysOn || dragging || focused || showLabelOnHover && isHovered;
    return /* @__PURE__ */ jsxs(
      Box,
      {
        tabIndex: 0,
        role: "slider",
        "aria-label": thumbLabel,
        "aria-valuemax": max2,
        "aria-valuemin": min2,
        "aria-valuenow": value,
        ref,
        __vars: { "--slider-thumb-offset": `${position}%` },
        ...getStyles2("thumb", { focusable: !0 }),
        mod: { dragging, disabled },
        onFocus: (event) => {
          setFocused(!0), typeof onFocus == "function" && onFocus(event);
        },
        onBlur: (event) => {
          setFocused(!1), typeof onBlur == "function" && onBlur(event);
        },
        onTouchStart: onMouseDown,
        onMouseDown,
        onKeyDownCapture,
        onClick: (event) => event.stopPropagation(),
        children: [
          children2,
          /* @__PURE__ */ jsx(
            Transition$1,
            {
              mounted: label != null && !!isVisible,
              transition: "fade",
              duration: 0,
              ...labelTransitionProps,
              children: (transitionStyles) => /* @__PURE__ */ jsx("div", { ...getStyles2("label", { style: transitionStyles }), children: label })
            }
          )
        ]
      }
    );
  }
);
Thumb.displayName = "@mantine/core/SliderThumb";
function getPosition({ value, min: min2, max: max2 }) {
  const position = (value - min2) / (max2 - min2) * 100;
  return Math.min(Math.max(position, 0), 100);
}
function isMarkFilled({ mark, offset: offset2, value, inverted = !1 }) {
  return inverted ? typeof offset2 == "number" && mark.value <= offset2 || mark.value >= value : typeof offset2 == "number" ? mark.value >= offset2 && mark.value <= value : mark.value <= value;
}
function Marks({ marks, min: min2, max: max2, disabled, value, offset: offset2, inverted }) {
  const { getStyles: getStyles2 } = useSliderContext();
  if (!marks)
    return null;
  const items = marks.map((mark, index2) => /* @__PURE__ */ createElement(
    Box,
    {
      ...getStyles2("markWrapper"),
      __vars: { "--mark-offset": `${getPosition({ value: mark.value, min: min2, max: max2 })}%` },
      key: index2
    },
    /* @__PURE__ */ jsx(
      Box,
      {
        ...getStyles2("mark"),
        mod: { filled: isMarkFilled({ mark, value, offset: offset2, inverted }), disabled }
      }
    ),
    mark.label && /* @__PURE__ */ jsx("div", { ...getStyles2("markLabel"), children: mark.label })
  ));
  return /* @__PURE__ */ jsx("div", { children: items });
}
Marks.displayName = "@mantine/core/SliderMarks";
function Track({
  filled,
  children: children2,
  offset: offset2,
  disabled,
  marksOffset,
  inverted,
  containerProps,
  ...others
}) {
  const { getStyles: getStyles2 } = useSliderContext();
  return /* @__PURE__ */ jsx(Box, { ...getStyles2("trackContainer"), mod: { disabled }, ...containerProps, children: /* @__PURE__ */ jsxs(Box, { ...getStyles2("track"), mod: { inverted, disabled }, children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        mod: { inverted, disabled },
        __vars: {
          "--slider-bar-width": `calc(${filled}% + 2 * var(--slider-size))`,
          "--slider-bar-offset": `calc(${offset2}% - var(--slider-size))`
        },
        ...getStyles2("bar")
      }
    ),
    children2,
    /* @__PURE__ */ jsx(Marks, { ...others, offset: marksOffset, disabled, inverted })
  ] }) });
}
Track.displayName = "@mantine/core/SliderTrack";
function getChangeValue({
  value,
  containerWidth,
  min: min2,
  max: max2,
  step,
  precision
}) {
  const dx = (containerWidth ? Math.min(Math.max(value, 0), containerWidth) / containerWidth : value) * (max2 - min2), nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min2, nextValueWithinStep = Math.max(nextValue, min2);
  return precision !== void 0 ? Number(nextValueWithinStep.toFixed(precision)) : nextValueWithinStep;
}
function getFloatingValue(value, precision) {
  return parseFloat(value.toFixed(precision));
}
function getPrecision(step) {
  if (!step)
    return 0;
  const split = step.toString().split(".");
  return split.length > 1 ? split[1].length : 0;
}
function getNextMarkValue(currentValue, marks) {
  const nextMark = [...marks].sort((a2, b) => a2.value - b.value).find((mark) => mark.value > currentValue);
  return nextMark ? nextMark.value : currentValue;
}
function getPreviousMarkValue(currentValue, marks) {
  const previousMark = [...marks].sort((a2, b) => b.value - a2.value).find((mark) => mark.value < currentValue);
  return previousMark ? previousMark.value : currentValue;
}
function getFirstMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b) => a2.value - b.value);
  return sortedMarks.length > 0 ? sortedMarks[0].value : 0;
}
function getLastMarkValue(marks) {
  const sortedMarks = [...marks].sort((a2, b) => a2.value - b.value);
  return sortedMarks.length > 0 ? sortedMarks[sortedMarks.length - 1].value : 100;
}
var classes$5 = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };
const defaultProps$4 = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (f) => f,
  labelTransitionProps: { transition: "fade", duration: 0 },
  thumbLabel: "",
  showLabelOnHover: !0,
  scale: (v) => v,
  size: "md"
}, varsResolver$5 = (theme, { size: size2, color: color2, thumbSize, radius }) => ({
  root: {
    "--slider-size": getSize(size2, "slider-size"),
    "--slider-color": color2 ? getThemeColor(color2, theme) : void 0,
    "--slider-radius": radius === void 0 ? void 0 : getRadius$1(radius),
    "--slider-thumb-size": thumbSize !== void 0 ? rem(thumbSize) : "calc(var(--slider-size) * 2)"
  }
}), Slider = factory((_props, ref) => {
  const props = useProps("Slider", defaultProps$4, _props), {
    classNames,
    styles,
    value,
    onChange,
    onChangeEnd,
    size: size2,
    min: min2,
    max: max2,
    domain,
    step,
    precision: _precision,
    defaultValue,
    name,
    marks,
    label,
    labelTransitionProps,
    labelAlwaysOn,
    thumbLabel,
    showLabelOnHover,
    thumbChildren,
    disabled,
    unstyled,
    scale: scale2,
    inverted,
    className,
    style: style2,
    vars,
    hiddenInputProps,
    restrictToMarks,
    thumbProps,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Slider",
    props,
    classes: classes$5,
    classNames,
    className,
    styles,
    style: style2,
    attributes,
    vars,
    varsResolver: varsResolver$5,
    unstyled
  }), { dir } = useDirection(), [hovered, setHovered] = useState(!1), [_value, setValue] = useUncontrolled({
    value: typeof value == "number" ? clamp$4(value, min2, max2) : value,
    defaultValue: typeof defaultValue == "number" ? clamp$4(defaultValue, min2, max2) : defaultValue,
    finalValue: clamp$4(0, min2, max2),
    onChange
  }), valueRef = useRef(_value), onChangeEndRef = useRef(onChangeEnd);
  useEffect(() => {
    onChangeEndRef.current = onChangeEnd;
  }, [onChangeEnd]);
  const root2 = useRef(null), thumb = useRef(null), [domainMin, domainMax] = domain || [min2, max2], position = getPosition({ value: _value, min: domainMin, max: domainMax }), scaledValue = scale2(_value), _label = typeof label == "function" ? label(scaledValue) : label, precision = _precision ?? getPrecision(step), handleChange = useCallback(
    ({ x: x2 }) => {
      if (!disabled) {
        const nextValue = getChangeValue({
          value: x2,
          min: domainMin,
          max: domainMax,
          step,
          precision
        }), clampedValue = clamp$4(nextValue, min2, max2);
        setValue(
          restrictToMarks && marks?.length ? findClosestNumber(
            clampedValue,
            marks.map((mark) => mark.value)
          ) : clampedValue
        ), valueRef.current = clampedValue;
      }
    },
    [disabled, min2, max2, domainMin, domainMax, step, precision, setValue, marks, restrictToMarks]
  ), handleScrubEnd = useCallback(() => {
    if (!disabled && onChangeEndRef.current) {
      const finalValue = restrictToMarks && marks?.length ? findClosestNumber(
        valueRef.current,
        marks.map((mark) => mark.value)
      ) : valueRef.current;
      onChangeEndRef.current(finalValue);
    }
  }, [disabled, marks, restrictToMarks]), { ref: container, active } = useMove(handleChange, { onScrubEnd: handleScrubEnd }, dir), callOnChangeEnd = useCallback(
    (value2) => {
      !disabled && onChangeEndRef.current && onChangeEndRef.current(value2);
    },
    [disabled]
  ), handleTrackKeydownCapture = (event) => {
    if (!disabled)
      switch (event.key) {
        case "ArrowUp": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = getNextMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value + step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowRight": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getPreviousMarkValue(_value, marks) : getNextMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value - step : _value + step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowDown": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = getPreviousMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(_value - step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "ArrowLeft": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            const nextValue2 = dir === "rtl" ? getNextMarkValue(_value, marks) : getPreviousMarkValue(_value, marks);
            setValue(nextValue2), callOnChangeEnd(nextValue2);
            break;
          }
          const nextValue = getFloatingValue(
            Math.min(Math.max(dir === "rtl" ? _value + step : _value - step, min2), max2),
            precision
          );
          setValue(nextValue), callOnChangeEnd(nextValue);
          break;
        }
        case "Home": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            setValue(getFirstMarkValue(marks)), callOnChangeEnd(getFirstMarkValue(marks));
            break;
          }
          setValue(min2), callOnChangeEnd(min2);
          break;
        }
        case "End": {
          if (event.preventDefault(), thumb.current?.focus(), restrictToMarks && marks) {
            setValue(getLastMarkValue(marks)), callOnChangeEnd(getLastMarkValue(marks));
            break;
          }
          setValue(max2), callOnChangeEnd(max2);
          break;
        }
      }
  };
  return /* @__PURE__ */ jsx(SliderProvider, { value: { getStyles: getStyles2 }, children: /* @__PURE__ */ jsxs(
    SliderRoot,
    {
      ...others,
      ref: useMergedRef(ref, root2),
      onKeyDownCapture: handleTrackKeydownCapture,
      onMouseDownCapture: () => root2.current?.focus(),
      size: size2,
      disabled,
      children: [
        /* @__PURE__ */ jsx(
          Track,
          {
            inverted,
            offset: 0,
            filled: position,
            marks,
            min: domainMin,
            max: domainMax,
            value: scaledValue,
            disabled,
            containerProps: {
              ref: container,
              onMouseEnter: showLabelOnHover ? () => setHovered(!0) : void 0,
              onMouseLeave: showLabelOnHover ? () => setHovered(!1) : void 0
            },
            children: /* @__PURE__ */ jsx(
              Thumb,
              {
                max: domainMax,
                min: domainMin,
                value: scaledValue,
                position,
                dragging: active,
                label: _label,
                ref: thumb,
                labelTransitionProps,
                labelAlwaysOn,
                thumbLabel,
                showLabelOnHover,
                isHovered: hovered,
                disabled,
                ...thumbProps,
                children: thumbChildren
              }
            )
          }
        ),
        /* @__PURE__ */ jsx("input", { type: "hidden", name, value: scaledValue, ...hiddenInputProps })
      ]
    }
  ) });
});
Slider.classes = classes$5;
Slider.displayName = "@mantine/core/Slider";
const Space = factory((props, ref) => {
  const { w, h, miw, mih, ...others } = useProps("Space", null, props);
  return /* @__PURE__ */ jsx(Box, { ref, ...others, w, miw: miw ?? w, h, mih: mih ?? h });
});
Space.displayName = "@mantine/core/Space";
var classes$4 = { root: "m_6d731127" };
const defaultProps$3 = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, varsResolver$4 = (_2, { gap, align, justify }) => ({
  root: {
    "--stack-gap": getSpacing(gap),
    "--stack-align": align,
    "--stack-justify": justify
  }
}), Stack = factory((_props, ref) => {
  const props = useProps("Stack", defaultProps$3, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    align,
    justify,
    gap,
    variant,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Stack",
    props,
    classes: classes$4,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$4
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), variant, ...others });
});
Stack.classes = classes$4;
Stack.displayName = "@mantine/core/Stack";
const [TabsProvider, useTabsContext] = createSafeContext(
  "Tabs component was not found in the tree"
);
var classes$3 = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", tab: "m_4ec4dce6", panel: "m_b0c91715", tabSection: "m_fc420b1f", tabLabel: "m_42bbd1ae", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const TabsList = factory((_props, ref) => {
  const props = useProps("TabsList", null, _props), { children: children2, className, grow, justify, classNames, styles, style: style2, mod, ...others } = props, ctx = useTabsContext();
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...others,
      ...ctx.getStyles("list", {
        className,
        style: style2,
        classNames,
        styles,
        props,
        variant: ctx.variant
      }),
      ref,
      role: "tablist",
      variant: ctx.variant,
      mod: [
        {
          grow,
          orientation: ctx.orientation,
          placement: ctx.orientation === "vertical" && ctx.placement,
          inverted: ctx.inverted
        },
        mod
      ],
      "aria-orientation": ctx.orientation,
      __vars: { "--tabs-justify": justify },
      children: children2
    }
  );
});
TabsList.classes = classes$3;
TabsList.displayName = "@mantine/core/TabsList";
const TabsPanel = factory((_props, ref) => {
  const props = useProps("TabsPanel", null, _props), { children: children2, className, value, classNames, styles, style: style2, mod, keepMounted, ...others } = props, ctx = useTabsContext(), active = ctx.value === value, content = ctx.keepMounted || keepMounted || active ? children2 : null;
  return /* @__PURE__ */ jsx(
    Box,
    {
      ...ctx.getStyles("panel", {
        className,
        classNames,
        styles,
        style: [style2, active ? void 0 : { display: "none" }],
        props
      }),
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      role: "tabpanel",
      id: ctx.getPanelId(value),
      "aria-labelledby": ctx.getTabId(value),
      ...others,
      children: content
    }
  );
});
TabsPanel.classes = classes$3;
TabsPanel.displayName = "@mantine/core/TabsPanel";
const TabsTab = factory((_props, ref) => {
  const props = useProps("TabsTab", null, _props), {
    className,
    children: children2,
    rightSection,
    leftSection,
    value,
    onClick,
    onKeyDown,
    disabled,
    color: color2,
    style: style2,
    classNames,
    styles,
    vars,
    mod,
    tabIndex,
    ...others
  } = props, theme = useMantineTheme(), { dir } = useDirection(), ctx = useTabsContext(), active = value === ctx.value, activateTab = (event) => {
    ctx.onChange(ctx.allowTabDeactivation && value === ctx.value ? null : value), onClick?.(event);
  }, stylesApiProps = { classNames, styles, props };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...ctx.getStyles("tab", { className, style: style2, variant: ctx.variant, ...stylesApiProps }),
      disabled,
      unstyled: ctx.unstyled,
      variant: ctx.variant,
      mod: [
        {
          active,
          disabled,
          orientation: ctx.orientation,
          inverted: ctx.inverted,
          placement: ctx.orientation === "vertical" && ctx.placement
        },
        mod
      ],
      ref,
      role: "tab",
      id: ctx.getTabId(value),
      "aria-selected": active,
      tabIndex: tabIndex !== void 0 ? tabIndex : active || ctx.value === null ? 0 : -1,
      "aria-controls": ctx.getPanelId(value),
      onClick: activateTab,
      __vars: { "--tabs-color": color2 ? getThemeColor(color2, theme) : void 0 },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: ctx.activateTabWithKeyboard,
        loop: ctx.loop,
        orientation: ctx.orientation || "horizontal",
        dir,
        onKeyDown
      }),
      ...others,
      children: [
        leftSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "left", children: leftSection }),
        children2 && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabLabel", stylesApiProps), children: children2 }),
        rightSection && /* @__PURE__ */ jsx("span", { ...ctx.getStyles("tabSection", stylesApiProps), "data-position": "right", children: rightSection })
      ]
    }
  );
});
TabsTab.classes = classes$3;
TabsTab.displayName = "@mantine/core/TabsTab";
const VALUE_ERROR = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", defaultProps$2 = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  variant: "default",
  placement: "left"
}, varsResolver$3 = (theme, { radius, color: color2, autoContrast }) => ({
  root: {
    "--tabs-radius": getRadius$1(radius),
    "--tabs-color": getThemeColor(color2, theme),
    "--tabs-text-color": getAutoContrastValue(autoContrast, theme) ? getContrastColor({ color: color2, theme, autoContrast }) : void 0
  }
}), Tabs = factory((_props, ref) => {
  const props = useProps("Tabs", defaultProps$2, _props), {
    defaultValue,
    value,
    onChange,
    orientation,
    children: children2,
    loop,
    id: id2,
    activateTabWithKeyboard,
    allowTabDeactivation,
    variant,
    color: color2,
    radius,
    inverted,
    placement,
    keepMounted,
    classNames,
    styles,
    unstyled,
    className,
    style: style2,
    vars,
    autoContrast,
    mod,
    attributes,
    ...others
  } = props, uid = useId$1(id2), [currentTab, setCurrentTab] = useUncontrolled({
    value,
    defaultValue,
    finalValue: null,
    onChange
  }), getStyles2 = useStyles({
    name: "Tabs",
    props,
    classes: classes$3,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$3
  });
  return /* @__PURE__ */ jsx(
    TabsProvider,
    {
      value: {
        placement,
        value: currentTab,
        orientation,
        id: uid,
        loop,
        activateTabWithKeyboard,
        getTabId: getSafeId(`${uid}-tab`, VALUE_ERROR),
        getPanelId: getSafeId(`${uid}-panel`, VALUE_ERROR),
        onChange: setCurrentTab,
        allowTabDeactivation,
        variant,
        color: color2,
        radius,
        inverted,
        keepMounted,
        unstyled,
        getStyles: getStyles2
      },
      children: /* @__PURE__ */ jsx(
        Box,
        {
          ref,
          id: uid,
          variant,
          mod: [
            {
              orientation,
              inverted: orientation === "horizontal" && inverted,
              placement: orientation === "vertical" && placement
            },
            mod
          ],
          ...getStyles2("root"),
          ...others,
          children: children2
        }
      )
    }
  );
});
Tabs.classes = classes$3;
Tabs.displayName = "@mantine/core/Tabs";
Tabs.Tab = TabsTab;
Tabs.Panel = TabsPanel;
Tabs.List = TabsList;
var classes$2 = { root: "m_7341320d" };
const varsResolver$2 = (theme, { size: size2, radius, variant, gradient, color: color2, autoContrast }) => {
  const colors = theme.variantColorResolver({
    color: color2 || theme.primaryColor,
    theme,
    gradient,
    variant: variant || "filled",
    autoContrast
  });
  return {
    root: {
      "--ti-size": getSize(size2, "ti-size"),
      "--ti-radius": radius === void 0 ? void 0 : getRadius$1(radius),
      "--ti-bg": color2 || variant ? colors.background : void 0,
      "--ti-color": color2 || variant ? colors.color : void 0,
      "--ti-bd": color2 || variant ? colors.border : void 0
    }
  };
}, ThemeIcon = factory((_props, ref) => {
  const props = useProps("ThemeIcon", null, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    autoContrast,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "ThemeIcon",
    classes: classes$2,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$2
  });
  return /* @__PURE__ */ jsx(Box, { ref, ...getStyles2("root"), ...others });
});
ThemeIcon.classes = classes$2;
ThemeIcon.displayName = "@mantine/core/ThemeIcon";
const headings = ["h1", "h2", "h3", "h4", "h5", "h6"], sizes = ["xs", "sm", "md", "lg", "xl"];
function getTitleSize(order, size2) {
  const titleSize = size2 !== void 0 ? size2 : `h${order}`;
  return headings.includes(titleSize) ? {
    fontSize: `var(--mantine-${titleSize}-font-size)`,
    fontWeight: `var(--mantine-${titleSize}-font-weight)`,
    lineHeight: `var(--mantine-${titleSize}-line-height)`
  } : sizes.includes(titleSize) ? {
    fontSize: `var(--mantine-font-size-${titleSize})`,
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  } : {
    fontSize: rem(titleSize),
    fontWeight: `var(--mantine-h${order}-font-weight)`,
    lineHeight: `var(--mantine-h${order}-line-height)`
  };
}
var classes$1 = { root: "m_8a5d1357" };
const defaultProps$1 = {
  order: 1
}, varsResolver$1 = (_2, { order, size: size2, lineClamp, textWrap }) => {
  const sizeVariables = getTitleSize(order || 1, size2);
  return {
    root: {
      "--title-fw": sizeVariables.fontWeight,
      "--title-lh": sizeVariables.lineHeight,
      "--title-fz": sizeVariables.fontSize,
      "--title-line-clamp": typeof lineClamp == "number" ? lineClamp.toString() : void 0,
      "--title-text-wrap": textWrap
    }
  };
}, Title = factory((_props, ref) => {
  const props = useProps("Title", defaultProps$1, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    order,
    vars,
    size: size2,
    variant,
    lineClamp,
    textWrap,
    mod,
    attributes,
    ...others
  } = props, getStyles2 = useStyles({
    name: "Title",
    props,
    classes: classes$1,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver: varsResolver$1
  });
  return [1, 2, 3, 4, 5, 6].includes(order) ? /* @__PURE__ */ jsx(
    Box,
    {
      ...getStyles2("root"),
      component: `h${order}`,
      variant,
      ref,
      mod: [{ order, "data-line-clamp": typeof lineClamp == "number" }, mod],
      size: size2,
      ...others
    }
  ) : null;
});
Title.classes = classes$1;
Title.displayName = "@mantine/core/Title";
function getValuesRange(anchor, value, flatValues) {
  if (!anchor || !value)
    return [];
  const anchorIndex = flatValues.indexOf(anchor), valueIndex = flatValues.indexOf(value), start2 = Math.min(anchorIndex, valueIndex), end = Math.max(anchorIndex, valueIndex);
  return flatValues.slice(start2, end + 1);
}
function TreeNode({
  node,
  getStyles: getStyles2,
  rootIndex,
  controller,
  expandOnClick,
  selectOnClick,
  isSubtree,
  level = 1,
  renderNode,
  flatValues,
  allowRangeSelection,
  expandOnSpace,
  checkOnSpace
}) {
  const ref = useRef(null), nested = (node.children || []).map((child) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node: child,
      flatValues,
      getStyles: getStyles2,
      rootIndex: void 0,
      level: level + 1,
      controller,
      expandOnClick,
      isSubtree: !0,
      renderNode,
      selectOnClick,
      allowRangeSelection,
      expandOnSpace,
      checkOnSpace
    },
    child.value
  )), handleKeyDown = (event) => {
    if (event.nativeEvent.code === "ArrowRight" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node.value] ? event.currentTarget.querySelector("[role=treeitem]")?.focus() : controller.expand(node.value)), event.nativeEvent.code === "ArrowLeft" && (event.stopPropagation(), event.preventDefault(), controller.expandedState[node.value] && (node.children || []).length > 0 ? controller.collapse(node.value) : isSubtree && findElementAncestor(event.currentTarget, "[role=treeitem]")?.focus()), event.nativeEvent.code === "ArrowDown" || event.nativeEvent.code === "ArrowUp") {
      const root2 = findElementAncestor(event.currentTarget, "[data-tree-root]");
      if (!root2)
        return;
      event.stopPropagation(), event.preventDefault();
      const nodes = Array.from(root2.querySelectorAll("[role=treeitem]")), index2 = nodes.indexOf(event.currentTarget);
      if (index2 === -1)
        return;
      const nextIndex = event.nativeEvent.code === "ArrowDown" ? index2 + 1 : index2 - 1;
      if (nodes[nextIndex]?.focus(), event.shiftKey) {
        const selectNode = nodes[nextIndex];
        selectNode && controller.setSelectedState(
          getValuesRange(controller.anchorNode, selectNode.dataset.value, flatValues)
        );
      }
    }
    event.nativeEvent.code === "Space" && (expandOnSpace && (event.stopPropagation(), event.preventDefault(), controller.toggleExpanded(node.value)), checkOnSpace && (event.stopPropagation(), event.preventDefault(), controller.isNodeChecked(node.value) ? controller.uncheckNode(node.value) : controller.checkNode(node.value)));
  }, handleNodeClick2 = (event) => {
    event.stopPropagation(), allowRangeSelection && event.shiftKey && controller.anchorNode ? (controller.setSelectedState(getValuesRange(controller.anchorNode, node.value, flatValues)), ref.current?.focus()) : (expandOnClick && controller.toggleExpanded(node.value), selectOnClick && controller.select(node.value), ref.current?.focus());
  }, selected2 = controller.selectedState.includes(node.value), elementProps = {
    ...getStyles2("label"),
    onClick: handleNodeClick2,
    "data-selected": selected2 || void 0,
    "data-value": node.value,
    "data-hovered": controller.hoveredNode === node.value || void 0
  };
  return /* @__PURE__ */ jsxs(
    "li",
    {
      ...getStyles2("node", {
        style: { "--label-offset": `calc(var(--level-offset) * ${level - 1})` }
      }),
      role: "treeitem",
      "aria-selected": selected2,
      "data-value": node.value,
      "data-selected": selected2 || void 0,
      "data-hovered": controller.hoveredNode === node.value || void 0,
      "data-level": level,
      tabIndex: rootIndex === 0 ? 0 : -1,
      onKeyDown: handleKeyDown,
      ref,
      onMouseOver: (event) => {
        event.stopPropagation(), controller.setHoveredNode(node.value);
      },
      onMouseLeave: (event) => {
        event.stopPropagation(), controller.setHoveredNode(null);
      },
      children: [
        typeof renderNode == "function" ? renderNode({
          node,
          level,
          selected: selected2,
          tree: controller,
          expanded: controller.expandedState[node.value] || !1,
          hasChildren: Array.isArray(node.children) && node.children.length > 0,
          elementProps
        }) : /* @__PURE__ */ jsx("div", { ...elementProps, children: node.label }),
        controller.expandedState[node.value] && nested.length > 0 && /* @__PURE__ */ jsx(Box, { component: "ul", role: "group", ...getStyles2("subtree"), "data-level": level, children: nested })
      ]
    }
  );
}
TreeNode.displayName = "@mantine/core/TreeNode";
function getAllCheckedNodes(data, checkedState, acc = []) {
  const currentTreeChecked = [];
  for (const node of data)
    if (Array.isArray(node.children) && node.children.length > 0) {
      const innerChecked = getAllCheckedNodes(node.children, checkedState, acc);
      if (innerChecked.currentTreeChecked.length === node.children.length) {
        const isChecked = innerChecked.currentTreeChecked.every((item2) => item2.checked), item = {
          checked: isChecked,
          indeterminate: !isChecked,
          value: node.value,
          hasChildren: !0
        };
        currentTreeChecked.push(item), acc.push(item);
      } else if (innerChecked.currentTreeChecked.length > 0) {
        const item = { checked: !1, indeterminate: !0, value: node.value, hasChildren: !0 };
        currentTreeChecked.push(item), acc.push(item);
      }
    } else if (checkedState.includes(node.value)) {
      const item = {
        checked: !0,
        indeterminate: !1,
        value: node.value,
        hasChildren: !1
      };
      currentTreeChecked.push(item), acc.push(item);
    }
  return { result: acc, currentTreeChecked };
}
function findTreeNode(value, data) {
  for (const node of data) {
    if (node.value === value)
      return node;
    if (Array.isArray(node.children)) {
      const childNode = findTreeNode(value, node.children);
      if (childNode)
        return childNode;
    }
  }
  return null;
}
function getChildrenNodesValues(value, data, acc = []) {
  const node = findTreeNode(value, data);
  return node ? !Array.isArray(node.children) || node.children.length === 0 ? [node.value] : (node.children.forEach((child) => {
    Array.isArray(child.children) && child.children.length > 0 ? getChildrenNodesValues(child.value, data, acc) : acc.push(child.value);
  }), acc) : acc;
}
function getAllChildrenNodes(data) {
  return data.reduce((acc, node) => (Array.isArray(node.children) && node.children.length > 0 ? acc.push(...getAllChildrenNodes(node.children)) : acc.push(node.value), acc), []);
}
function isNodeChecked(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : checkedState.includes(value) ? !0 : getAllCheckedNodes(data, checkedState).result.some((node) => node.value === value && node.checked);
}
const memoizedIsNodeChecked = memoize(isNodeChecked);
function isNodeIndeterminate(value, data, checkedState) {
  return checkedState.length === 0 ? !1 : getAllCheckedNodes(data, checkedState).result.some((node) => node.value === value && node.indeterminate);
}
const memoizedIsNodeIndeterminate = memoize(isNodeIndeterminate);
function getInitialTreeExpandedState(initialState2, data, value, acc = {}) {
  return data.forEach((node) => {
    acc[node.value] = node.value in initialState2 ? initialState2[node.value] : node.value === value, Array.isArray(node.children) && getInitialTreeExpandedState(initialState2, node.children, value, acc);
  }), acc;
}
function getInitialCheckedState(initialState2, data) {
  const acc = [];
  return initialState2.forEach((node) => acc.push(...getChildrenNodesValues(node, data))), Array.from(new Set(acc));
}
function useTree({
  initialSelectedState = [],
  initialCheckedState = [],
  initialExpandedState = {},
  multiple = !1,
  onNodeCollapse,
  onNodeExpand
} = {}) {
  const [data, setData] = useState([]), [expandedState, setExpandedState] = useState(initialExpandedState), [selectedState, setSelectedState] = useState(initialSelectedState), [checkedState, setCheckedState] = useState(initialCheckedState), [anchorNode, setAnchorNode] = useState(null), [hoveredNode, setHoveredNode] = useState(null), initialize = useCallback(
    (_data) => {
      setExpandedState((current2) => getInitialTreeExpandedState(current2, _data, selectedState)), setCheckedState((current2) => getInitialCheckedState(current2, _data)), setData(_data);
    },
    [selectedState, checkedState]
  ), toggleExpanded = useCallback(
    (value) => {
      setExpandedState((current2) => {
        const nextState = { ...current2, [value]: !current2[value] };
        return nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value), nextState;
      });
    },
    [onNodeCollapse, onNodeExpand]
  ), collapse = useCallback(
    (value) => {
      setExpandedState((current2) => (current2[value] !== !1 && onNodeCollapse?.(value), { ...current2, [value]: !1 }));
    },
    [onNodeCollapse]
  ), expand = useCallback(
    (value) => {
      setExpandedState((current2) => (current2[value] !== !0 && onNodeExpand?.(value), { ...current2, [value]: !0 }));
    },
    [onNodeExpand]
  ), expandAllNodes = useCallback(() => {
    setExpandedState((current2) => {
      const next = { ...current2 };
      return Object.keys(next).forEach((key) => {
        next[key] = !0;
      }), next;
    });
  }, []), collapseAllNodes = useCallback(() => {
    setExpandedState((current2) => {
      const next = { ...current2 };
      return Object.keys(next).forEach((key) => {
        next[key] = !1;
      }), next;
    });
  }, []), toggleSelected = useCallback(
    (value) => setSelectedState((current2) => multiple ? current2.includes(value) ? (setAnchorNode(null), current2.filter((item) => item !== value)) : (setAnchorNode(value), [...current2, value]) : current2.includes(value) ? (setAnchorNode(null), []) : (setAnchorNode(value), [value])),
    []
  ), select2 = useCallback((value) => {
    setAnchorNode(value), setSelectedState(
      (current2) => multiple ? current2.includes(value) ? current2 : [...current2, value] : [value]
    );
  }, []), deselect = useCallback((value) => {
    anchorNode === value && setAnchorNode(null), setSelectedState((current2) => current2.filter((item) => item !== value));
  }, []), clearSelected = useCallback(() => {
    setSelectedState([]), setAnchorNode(null);
  }, []), checkNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current2) => Array.from(/* @__PURE__ */ new Set([...current2, ...checkedNodes])));
    },
    [data]
  ), uncheckNode = useCallback(
    (value) => {
      const checkedNodes = getChildrenNodesValues(value, data);
      setCheckedState((current2) => current2.filter((item) => !checkedNodes.includes(item)));
    },
    [data]
  ), checkAllNodes = useCallback(() => {
    setCheckedState(() => getAllChildrenNodes(data));
  }, [data]), uncheckAllNodes = useCallback(() => {
    setCheckedState([]);
  }, []);
  return {
    multiple,
    expandedState,
    selectedState,
    checkedState,
    anchorNode,
    initialize,
    toggleExpanded,
    collapse,
    expand,
    expandAllNodes,
    collapseAllNodes,
    setExpandedState,
    checkNode,
    uncheckNode,
    checkAllNodes,
    uncheckAllNodes,
    setCheckedState,
    toggleSelected,
    select: select2,
    deselect,
    clearSelected,
    setSelectedState,
    hoveredNode,
    setHoveredNode,
    getCheckedNodes: () => getAllCheckedNodes(data, checkedState).result,
    isNodeChecked: (value) => memoizedIsNodeChecked(value, data, checkedState),
    isNodeIndeterminate: (value) => memoizedIsNodeIndeterminate(value, data, checkedState)
  };
}
var classes = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };
function getFlatValues(data) {
  return data.reduce((acc, item) => (acc.push(item.value), item.children && acc.push(...getFlatValues(item.children)), acc), []);
}
const defaultProps = {
  expandOnClick: !0,
  allowRangeSelection: !0,
  expandOnSpace: !0
}, varsResolver = (_theme, { levelOffset }) => ({
  root: {
    "--level-offset": getSpacing(levelOffset)
  }
}), Tree = factory((_props, ref) => {
  const props = useProps("Tree", defaultProps, _props), {
    classNames,
    className,
    style: style2,
    styles,
    unstyled,
    vars,
    data,
    expandOnClick,
    tree,
    renderNode,
    selectOnClick,
    clearSelectionOnOutsideClick,
    allowRangeSelection,
    expandOnSpace,
    levelOffset,
    checkOnSpace,
    attributes,
    ...others
  } = props, defaultController = useTree(), controller = tree || defaultController, getStyles2 = useStyles({
    name: "Tree",
    classes,
    props,
    className,
    style: style2,
    classNames,
    styles,
    unstyled,
    attributes,
    vars,
    varsResolver
  }), clickOutsideRef = useClickOutside(
    () => clearSelectionOnOutsideClick && controller.clearSelected()
  ), mergedRef = useMergedRef(ref, clickOutsideRef), flatValues = useMemo(() => getFlatValues(data), [data]);
  useEffect(() => {
    controller.initialize(data);
  }, [data]);
  const nodes = data.map((node, index2) => /* @__PURE__ */ jsx(
    TreeNode,
    {
      node,
      getStyles: getStyles2,
      rootIndex: index2,
      expandOnClick,
      selectOnClick,
      controller,
      renderNode,
      flatValues,
      allowRangeSelection,
      expandOnSpace,
      checkOnSpace
    },
    node.value
  ));
  return /* @__PURE__ */ jsx(
    Box,
    {
      component: "ul",
      ref: mergedRef,
      ...getStyles2("root"),
      ...others,
      role: "tree",
      "aria-multiselectable": controller.multiple,
      "data-tree-root": !0,
      children: nodes
    }
  );
});
Tree.displayName = "@mantine/core/Tree";
Tree.classes = classes;
var prefix = "Invariant failed";
function invariant$1(condition, message) {
  if (!condition)
    throw new Error(prefix);
}
const __storeToDerived = /* @__PURE__ */ new WeakMap(), __derivedToStore = /* @__PURE__ */ new WeakMap(), __depsThatHaveWrittenThisTick = {
  current: []
};
let __isFlushing = !1, __batchDepth = 0;
const __pendingUpdates = /* @__PURE__ */ new Set(), __initialBatchValues = /* @__PURE__ */ new Map();
function __flush_internals(relatedVals) {
  const sorted = Array.from(relatedVals).sort((a2, b) => a2 instanceof Derived && a2.options.deps.includes(b) ? 1 : b instanceof Derived && b.options.deps.includes(a2) ? -1 : 0);
  for (const derived of sorted) {
    if (__depsThatHaveWrittenThisTick.current.includes(derived))
      continue;
    __depsThatHaveWrittenThisTick.current.push(derived), derived.recompute();
    const stores = __derivedToStore.get(derived);
    if (stores)
      for (const store of stores) {
        const relatedLinkedDerivedVals = __storeToDerived.get(store);
        relatedLinkedDerivedVals && __flush_internals(relatedLinkedDerivedVals);
      }
  }
}
function __notifyListeners(store) {
  store.listeners.forEach(
    (listener) => listener({
      prevVal: store.prevState,
      currentVal: store.state
    })
  );
}
function __notifyDerivedListeners(derived) {
  derived.listeners.forEach(
    (listener) => listener({
      prevVal: derived.prevState,
      currentVal: derived.state
    })
  );
}
function __flush(store) {
  if (__batchDepth > 0 && !__initialBatchValues.has(store) && __initialBatchValues.set(store, store.prevState), __pendingUpdates.add(store), !(__batchDepth > 0) && !__isFlushing)
    try {
      for (__isFlushing = !0; __pendingUpdates.size > 0; ) {
        const stores = Array.from(__pendingUpdates);
        __pendingUpdates.clear();
        for (const store2 of stores) {
          const prevState = __initialBatchValues.get(store2) ?? store2.prevState;
          store2.prevState = prevState, __notifyListeners(store2);
        }
        for (const store2 of stores) {
          const derivedVals = __storeToDerived.get(store2);
          derivedVals && (__depsThatHaveWrittenThisTick.current.push(store2), __flush_internals(derivedVals));
        }
        for (const store2 of stores) {
          const derivedVals = __storeToDerived.get(store2);
          if (derivedVals)
            for (const derived of derivedVals)
              __notifyDerivedListeners(derived);
        }
      }
    } finally {
      __isFlushing = !1, __depsThatHaveWrittenThisTick.current = [], __initialBatchValues.clear();
    }
}
function batch(fn) {
  __batchDepth++;
  try {
    fn();
  } finally {
    if (__batchDepth--, __batchDepth === 0) {
      const pendingUpdateToFlush = Array.from(__pendingUpdates)[0];
      pendingUpdateToFlush && __flush(pendingUpdateToFlush);
    }
  }
}
class Store {
  constructor(initialState2, options) {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener), unsub?.();
      };
    }, this.setState = (updater) => {
      var _a, _b, _c;
      this.prevState = this.state, this.state = (_a = this.options) != null && _a.updateFn ? this.options.updateFn(this.prevState)(updater) : updater(this.prevState), (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null || _c.call(_b), __flush(this);
    }, this.prevState = initialState2, this.state = initialState2, this.options = options;
  }
}
class Derived {
  constructor(options) {
    this.listeners = /* @__PURE__ */ new Set(), this._subscriptions = [], this.lastSeenDepValues = [], this.getDepVals = () => {
      const prevDepVals = [], currDepVals = [];
      for (const dep of this.options.deps)
        prevDepVals.push(dep.prevState), currDepVals.push(dep.state);
      return this.lastSeenDepValues = currDepVals, {
        prevDepVals,
        currDepVals,
        prevVal: this.prevState ?? void 0
      };
    }, this.recompute = () => {
      var _a, _b;
      this.prevState = this.state;
      const { prevDepVals, currDepVals, prevVal } = this.getDepVals();
      this.state = this.options.fn({
        prevDepVals,
        currDepVals,
        prevVal
      }), (_b = (_a = this.options).onUpdate) == null || _b.call(_a);
    }, this.checkIfRecalculationNeededDeeply = () => {
      for (const dep of this.options.deps)
        dep instanceof Derived && dep.checkIfRecalculationNeededDeeply();
      let shouldRecompute = !1;
      const lastSeenDepValues = this.lastSeenDepValues, { currDepVals } = this.getDepVals();
      for (let i2 = 0; i2 < currDepVals.length; i2++)
        if (currDepVals[i2] !== lastSeenDepValues[i2]) {
          shouldRecompute = !0;
          break;
        }
      shouldRecompute && this.recompute();
    }, this.mount = () => (this.registerOnGraph(), this.checkIfRecalculationNeededDeeply(), () => {
      this.unregisterFromGraph();
      for (const cleanup of this._subscriptions)
        cleanup();
    }), this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options).onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener), unsub?.();
      };
    }, this.options = options, this.state = options.fn({
      prevDepVals: void 0,
      prevVal: void 0,
      currDepVals: this.getDepVals().currDepVals
    });
  }
  registerOnGraph(deps = this.options.deps) {
    for (const dep of deps)
      if (dep instanceof Derived)
        dep.registerOnGraph(), this.registerOnGraph(dep.options.deps);
      else if (dep instanceof Store) {
        let relatedLinkedDerivedVals = __storeToDerived.get(dep);
        relatedLinkedDerivedVals || (relatedLinkedDerivedVals = /* @__PURE__ */ new Set(), __storeToDerived.set(dep, relatedLinkedDerivedVals)), relatedLinkedDerivedVals.add(this);
        let relatedStores = __derivedToStore.get(this);
        relatedStores || (relatedStores = /* @__PURE__ */ new Set(), __derivedToStore.set(this, relatedStores)), relatedStores.add(dep);
      }
  }
  unregisterFromGraph(deps = this.options.deps) {
    for (const dep of deps)
      if (dep instanceof Derived)
        this.unregisterFromGraph(dep.options.deps);
      else if (dep instanceof Store) {
        const relatedLinkedDerivedVals = __storeToDerived.get(dep);
        relatedLinkedDerivedVals && relatedLinkedDerivedVals.delete(this);
        const relatedStores = __derivedToStore.get(this);
        relatedStores && relatedStores.delete(dep);
      }
  }
}
const stateIndexKey = "__TSR_index", popStateEvent = "popstate", beforeUnloadEvent = "beforeunload";
function createHistory(opts) {
  let location = opts.getLocation();
  const subscribers = /* @__PURE__ */ new Set(), notify2 = (action) => {
    location = opts.getLocation(), subscribers.forEach((subscriber) => subscriber({ location, action }));
  }, handleIndexChange = (action) => {
    opts.notifyOnIndexChange ?? !0 ? notify2(action) : location = opts.getLocation();
  }, tryNavigation = async ({
    task,
    navigateOpts,
    ...actionInfo
  }) => {
    var _a, _b;
    if (navigateOpts?.ignoreBlocker ?? !1) {
      task();
      return;
    }
    const blockers = ((_a = opts.getBlockers) == null ? void 0 : _a.call(opts)) ?? [], isPushOrReplace = actionInfo.type === "PUSH" || actionInfo.type === "REPLACE";
    if (typeof document < "u" && blockers.length && isPushOrReplace)
      for (const blocker of blockers) {
        const nextLocation = parseHref(actionInfo.path, actionInfo.state);
        if (await blocker.blockerFn({
          currentLocation: location,
          nextLocation,
          action: actionInfo.type
        })) {
          (_b = opts.onBlocked) == null || _b.call(opts);
          return;
        }
      }
    task();
  };
  return {
    get location() {
      return location;
    },
    get length() {
      return opts.getLength();
    },
    subscribers,
    subscribe: (cb) => (subscribers.add(cb), () => {
      subscribers.delete(cb);
    }),
    push: (path, state, navigateOpts) => {
      const currentIndex = location.state[stateIndexKey];
      state = assignKeyAndIndex(currentIndex + 1, state), tryNavigation({
        task: () => {
          opts.pushState(path, state), notify2({ type: "PUSH" });
        },
        navigateOpts,
        type: "PUSH",
        path,
        state
      });
    },
    replace: (path, state, navigateOpts) => {
      const currentIndex = location.state[stateIndexKey];
      state = assignKeyAndIndex(currentIndex, state), tryNavigation({
        task: () => {
          opts.replaceState(path, state), notify2({ type: "REPLACE" });
        },
        navigateOpts,
        type: "REPLACE",
        path,
        state
      });
    },
    go: (index2, navigateOpts) => {
      tryNavigation({
        task: () => {
          opts.go(index2), handleIndexChange({ type: "GO", index: index2 });
        },
        navigateOpts,
        type: "GO"
      });
    },
    back: (navigateOpts) => {
      tryNavigation({
        task: () => {
          opts.back(navigateOpts?.ignoreBlocker ?? !1), handleIndexChange({ type: "BACK" });
        },
        navigateOpts,
        type: "BACK"
      });
    },
    forward: (navigateOpts) => {
      tryNavigation({
        task: () => {
          opts.forward(navigateOpts?.ignoreBlocker ?? !1), handleIndexChange({ type: "FORWARD" });
        },
        navigateOpts,
        type: "FORWARD"
      });
    },
    canGoBack: () => location.state[stateIndexKey] !== 0,
    createHref: (str) => opts.createHref(str),
    block: (blocker) => {
      var _a;
      if (!opts.setBlockers) return () => {
      };
      const blockers = ((_a = opts.getBlockers) == null ? void 0 : _a.call(opts)) ?? [];
      return opts.setBlockers([...blockers, blocker]), () => {
        var _a2, _b;
        const blockers2 = ((_a2 = opts.getBlockers) == null ? void 0 : _a2.call(opts)) ?? [];
        (_b = opts.setBlockers) == null || _b.call(opts, blockers2.filter((b) => b !== blocker));
      };
    },
    flush: () => {
      var _a;
      return (_a = opts.flush) == null ? void 0 : _a.call(opts);
    },
    destroy: () => {
      var _a;
      return (_a = opts.destroy) == null ? void 0 : _a.call(opts);
    },
    notify: notify2
  };
}
function assignKeyAndIndex(index2, state) {
  return state || (state = {}), {
    ...state,
    key: createRandomKey(),
    [stateIndexKey]: index2
  };
}
function createBrowserHistory(opts) {
  var _a;
  const win2 = opts?.window ?? (typeof document < "u" ? window : void 0), originalPushState = win2.history.pushState, originalReplaceState = win2.history.replaceState;
  let blockers = [];
  const _getBlockers = () => blockers, _setBlockers = (newBlockers) => blockers = newBlockers, createHref = opts?.createHref ?? ((path) => path), parseLocation = opts?.parseLocation ?? (() => parseHref(
    `${win2.location.pathname}${win2.location.search}${win2.location.hash}`,
    win2.history.state
  ));
  (_a = win2.history.state) != null && _a.key || win2.history.replaceState(
    {
      [stateIndexKey]: 0,
      key: createRandomKey()
    },
    ""
  );
  let currentLocation = parseLocation(), rollbackLocation, nextPopIsGo = !1, ignoreNextPop = !1, skipBlockerNextPop = !1, ignoreNextBeforeUnload = !1;
  const getLocation = () => currentLocation;
  let next, scheduled;
  const flush = () => {
    next && (history._ignoreSubscribers = !0, (next.isPush ? win2.history.pushState : win2.history.replaceState)(
      next.state,
      "",
      next.href
    ), history._ignoreSubscribers = !1, next = void 0, scheduled = void 0, rollbackLocation = void 0);
  }, queueHistoryAction = (type, destHref, state) => {
    const href = createHref(destHref);
    scheduled || (rollbackLocation = currentLocation), currentLocation = parseHref(destHref, state), next = {
      href,
      state,
      isPush: next?.isPush || type === "push"
    }, scheduled || (scheduled = Promise.resolve().then(() => flush()));
  }, onPushPop = (type) => {
    currentLocation = parseLocation(), history.notify({ type });
  }, onPushPopEvent = async () => {
    if (ignoreNextPop) {
      ignoreNextPop = !1;
      return;
    }
    const nextLocation = parseLocation(), delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey], isForward = delta === 1, isBack = delta === -1, isGo = !isForward && !isBack || nextPopIsGo;
    nextPopIsGo = !1;
    const action = isGo ? "GO" : isBack ? "BACK" : "FORWARD", notify2 = isGo ? {
      type: "GO",
      index: delta
    } : {
      type: isBack ? "BACK" : "FORWARD"
    };
    if (skipBlockerNextPop)
      skipBlockerNextPop = !1;
    else {
      const blockers2 = _getBlockers();
      if (typeof document < "u" && blockers2.length) {
        for (const blocker of blockers2)
          if (await blocker.blockerFn({
            currentLocation,
            nextLocation,
            action
          })) {
            ignoreNextPop = !0, win2.history.go(1), history.notify(notify2);
            return;
          }
      }
    }
    currentLocation = parseLocation(), history.notify(notify2);
  }, onBeforeUnload = (e2) => {
    if (ignoreNextBeforeUnload) {
      ignoreNextBeforeUnload = !1;
      return;
    }
    let shouldBlock = !1;
    const blockers2 = _getBlockers();
    if (typeof document < "u" && blockers2.length)
      for (const blocker of blockers2) {
        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? !0;
        if (shouldHaveBeforeUnload === !0) {
          shouldBlock = !0;
          break;
        }
        if (typeof shouldHaveBeforeUnload == "function" && shouldHaveBeforeUnload() === !0) {
          shouldBlock = !0;
          break;
        }
      }
    if (shouldBlock)
      return e2.preventDefault(), e2.returnValue = "";
  }, history = createHistory({
    getLocation,
    getLength: () => win2.history.length,
    pushState: (href, state) => queueHistoryAction("push", href, state),
    replaceState: (href, state) => queueHistoryAction("replace", href, state),
    back: (ignoreBlocker) => (ignoreBlocker && (skipBlockerNextPop = !0), ignoreNextBeforeUnload = !0, win2.history.back()),
    forward: (ignoreBlocker) => {
      ignoreBlocker && (skipBlockerNextPop = !0), ignoreNextBeforeUnload = !0, win2.history.forward();
    },
    go: (n2) => {
      nextPopIsGo = !0, win2.history.go(n2);
    },
    createHref: (href) => createHref(href),
    flush,
    destroy: () => {
      win2.history.pushState = originalPushState, win2.history.replaceState = originalReplaceState, win2.removeEventListener(beforeUnloadEvent, onBeforeUnload, {
        capture: !0
      }), win2.removeEventListener(popStateEvent, onPushPopEvent);
    },
    onBlocked: () => {
      rollbackLocation && currentLocation !== rollbackLocation && (currentLocation = rollbackLocation);
    },
    getBlockers: _getBlockers,
    setBlockers: _setBlockers,
    notifyOnIndexChange: !1
  });
  return win2.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: !0 }), win2.addEventListener(popStateEvent, onPushPopEvent), win2.history.pushState = function(...args) {
    const res = originalPushState.apply(win2.history, args);
    return history._ignoreSubscribers || onPushPop("PUSH"), res;
  }, win2.history.replaceState = function(...args) {
    const res = originalReplaceState.apply(win2.history, args);
    return history._ignoreSubscribers || onPushPop("REPLACE"), res;
  }, history;
}
function createHashHistory(opts) {
  const win2 = typeof document < "u" ? window : void 0;
  return createBrowserHistory({
    window: win2,
    parseLocation: () => {
      const hashSplit = win2.location.hash.split("#").slice(1), pathPart = hashSplit[0] ?? "/", searchPart = win2.location.search, hashEntries = hashSplit.slice(1), hashPart = hashEntries.length === 0 ? "" : `#${hashEntries.join("#")}`, hashHref = `${pathPart}${searchPart}${hashPart}`;
      return parseHref(hashHref, win2.history.state);
    },
    createHref: (href) => `${win2.location.pathname}${win2.location.search}#${href}`
  });
}
function createMemoryHistory(opts = {
  initialEntries: ["/"]
}) {
  const entries = opts.initialEntries;
  let index2 = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1) : entries.length - 1;
  const states = entries.map(
    (_entry, index22) => assignKeyAndIndex(index22, void 0)
  );
  return createHistory({
    getLocation: () => parseHref(entries[index2], states[index2]),
    getLength: () => entries.length,
    pushState: (path, state) => {
      index2 < entries.length - 1 && (entries.splice(index2 + 1), states.splice(index2 + 1)), states.push(state), entries.push(path), index2 = Math.max(entries.length - 1, 0);
    },
    replaceState: (path, state) => {
      states[index2] = state, entries[index2] = path;
    },
    back: () => {
      index2 = Math.max(index2 - 1, 0);
    },
    forward: () => {
      index2 = Math.min(index2 + 1, entries.length - 1);
    },
    go: (n2) => {
      index2 = Math.min(Math.max(index2 + n2, 0), entries.length - 1);
    },
    createHref: (path) => path
  });
}
function parseHref(href, state) {
  const hashIndex = href.indexOf("#"), searchIndex = href.indexOf("?");
  return {
    href,
    pathname: href.substring(
      0,
      hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length
    ),
    hash: hashIndex > -1 ? href.substring(hashIndex) : "",
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
    state: state || { [stateIndexKey]: 0, key: createRandomKey() }
  };
}
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction$1(d) {
  return typeof d == "function";
}
function functionalUpdate(updater, previous) {
  return isFunction$1(updater) ? updater(previous) : updater;
}
function pick$1(parent, keys2) {
  return keys2.reduce((obj, key) => (obj[key] = parent[key], obj), {});
}
function replaceEqualDeep(prev, _next) {
  if (prev === _next)
    return prev;
  const next = _next, array2 = isPlainArray(prev) && isPlainArray(next);
  if (array2 || isPlainObject$2(prev) && isPlainObject$2(next)) {
    const prevItems = array2 ? prev : Object.keys(prev), prevSize = prevItems.length, nextItems = array2 ? next : Object.keys(next), nextSize = nextItems.length, copy = array2 ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < nextSize; i2++) {
      const key = array2 ? i2 : nextItems[i2];
      (!array2 && prevItems.includes(key) || array2) && prev[key] === void 0 && next[key] === void 0 ? (copy[key] = void 0, equalItems++) : (copy[key] = replaceEqualDeep(prev[key], next[key]), copy[key] === prev[key] && prev[key] !== void 0 && equalItems++);
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}
function isPlainObject$2(o) {
  if (!hasObjectPrototype(o))
    return !1;
  const ctor = o.constructor;
  if (typeof ctor > "u")
    return !0;
  const prot = ctor.prototype;
  return !(!hasObjectPrototype(prot) || !prot.hasOwnProperty("isPrototypeOf"));
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function getObjectKeys(obj, ignoreUndefined) {
  let keys2 = Object.keys(obj);
  return ignoreUndefined && (keys2 = keys2.filter((key) => obj[key] !== void 0)), keys2;
}
function deepEqual$1(a2, b, opts) {
  if (a2 === b)
    return !0;
  if (typeof a2 != typeof b)
    return !1;
  if (isPlainObject$2(a2) && isPlainObject$2(b)) {
    const ignoreUndefined = opts?.ignoreUndefined ?? !0, aKeys = getObjectKeys(a2, ignoreUndefined), bKeys = getObjectKeys(b, ignoreUndefined);
    return !opts?.partial && aKeys.length !== bKeys.length ? !1 : bKeys.every((key) => deepEqual$1(a2[key], b[key], opts));
  }
  return Array.isArray(a2) && Array.isArray(b) ? a2.length !== b.length ? !1 : !a2.some((item, index2) => !deepEqual$1(item, b[index2], opts)) : !1;
}
function createControlledPromise(onResolve) {
  let resolveLoadPromise, rejectLoadPromise;
  const controlledPromise = new Promise((resolve, reject) => {
    resolveLoadPromise = resolve, rejectLoadPromise = reject;
  });
  return controlledPromise.status = "pending", controlledPromise.resolve = (value) => {
    controlledPromise.status = "resolved", controlledPromise.value = value, resolveLoadPromise(value), onResolve?.(value);
  }, controlledPromise.reject = (e2) => {
    controlledPromise.status = "rejected", rejectLoadPromise(e2);
  }, controlledPromise;
}
function hasUriEncodedChars(inputString) {
  return /%[0-9A-Fa-f]{2}/.test(inputString);
}
function joinPaths(paths) {
  return cleanPath(
    paths.filter((val) => val !== void 0).join("/")
  );
}
function cleanPath(path) {
  return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
  return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
  return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
  return trimPathRight(trimPathLeft(path));
}
function removeTrailingSlash(value, basepath) {
  return value?.endsWith("/") && value !== "/" && value !== `${basepath}/` ? value.slice(0, -1) : value;
}
function exactPathTest(pathName1, pathName2, basepath) {
  return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);
}
function resolvePath({
  basepath,
  base,
  to,
  trailingSlash = "never",
  caseSensitive
}) {
  var _a, _b;
  base = removeBasepath(basepath, base, caseSensitive), to = removeBasepath(basepath, to, caseSensitive);
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/" && baseSegments.pop(), toSegments.forEach((toSegment, index2) => {
    toSegment.value === "/" ? index2 ? index2 === toSegments.length - 1 && baseSegments.push(toSegment) : baseSegments = [toSegment] : toSegment.value === ".." ? baseSegments.pop() : toSegment.value === "." || baseSegments.push(toSegment);
  }), baseSegments.length > 1 && (((_b = last(baseSegments)) == null ? void 0 : _b.value) === "/" ? trailingSlash === "never" && baseSegments.pop() : trailingSlash === "always" && baseSegments.push({ type: "pathname", value: "/" }));
  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname)
    return [];
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === "/" && (pathname = pathname.substring(1), segments.push({
    type: "pathname",
    value: "/"
  })), !pathname)
    return segments;
  const split = pathname.split("/").filter(Boolean);
  return segments.push(
    ...split.map((part) => part === "$" || part === "*" ? {
      type: "wildcard",
      value: part
    } : part.charAt(0) === "$" ? {
      type: "param",
      value: part
    } : {
      type: "pathname",
      value: part.includes("%25") ? part.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(part)
    })
  ), pathname.slice(-1) === "/" && (pathname = pathname.substring(1), segments.push({
    type: "pathname",
    value: "/"
  })), segments;
}
function interpolatePath({
  path,
  params,
  leaveWildcards,
  leaveParams,
  decodeCharMap
}) {
  const interpolatedPathSegments = parsePathname(path);
  function encodeParam(key) {
    const value = params[key], isValueString = typeof value == "string";
    return ["*", "_splat"].includes(key) ? isValueString ? encodeURI(value) : value : isValueString ? encodePathParam(value, decodeCharMap) : value;
  }
  const usedParams = {}, interpolatedPath = joinPaths(
    interpolatedPathSegments.map((segment) => {
      if (segment.type === "wildcard") {
        usedParams._splat = params._splat;
        const value = encodeParam("_splat");
        return leaveWildcards ? `${segment.value}${value ?? ""}` : value;
      }
      if (segment.type === "param") {
        const key = segment.value.substring(1);
        if (usedParams[key] = params[key], leaveParams) {
          const value = encodeParam(segment.value);
          return `${segment.value}${value ?? ""}`;
        }
        return encodeParam(key) ?? "undefined";
      }
      return segment.value;
    })
  );
  return { usedParams, interpolatedPath };
}
function encodePathParam(value, decodeCharMap) {
  let encoded = encodeURIComponent(value);
  if (decodeCharMap)
    for (const [encodedChar, char] of decodeCharMap)
      encoded = encoded.replaceAll(encodedChar, char);
  return encoded;
}
function matchPathname(basepath, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath, currentPathname, matchLocation);
  if (!(matchLocation.to && !pathParams))
    return pathParams ?? {};
}
function removeBasepath(basepath, pathname, caseSensitive = !1) {
  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase(), normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();
  switch (!0) {
    // default behaviour is to serve app from the root - pathname
    // left untouched
    case normalizedBasepath === "/":
      return pathname;
    // shortcut for removing the basepath if it matches the pathname
    case normalizedPathname === normalizedBasepath:
      return "";
    // in case pathname is shorter than basepath - there is
    // nothing to remove
    case pathname.length < basepath.length:
      return pathname;
    // avoid matching partial segments - strict equality handled
    // earlier, otherwise, basepath separated from pathname with
    // separator, therefore lack of separator means partial
    // segment match (`/app` should not match `/application`)
    case normalizedPathname[normalizedBasepath.length] !== "/":
      return pathname;
    // remove the basepath from the pathname if it starts with it
    case normalizedPathname.startsWith(normalizedBasepath):
      return pathname.slice(basepath.length);
    // otherwise, return the pathname as is
    default:
      return pathname;
  }
}
function matchByPath(basepath, from, matchLocation) {
  if (basepath !== "/" && !from.startsWith(basepath))
    return;
  from = removeBasepath(basepath, from, matchLocation.caseSensitive);
  const to = removeBasepath(
    basepath,
    `${matchLocation.to ?? "$"}`,
    matchLocation.caseSensitive
  ), baseSegments = parsePathname(from), routeSegments = parsePathname(to);
  from.startsWith("/") || baseSegments.unshift({
    type: "pathname",
    value: "/"
  }), to.startsWith("/") || routeSegments.unshift({
    type: "pathname",
    value: "/"
  });
  const params = {};
  return (() => {
    for (let i2 = 0; i2 < Math.max(baseSegments.length, routeSegments.length); i2++) {
      const baseSegment = baseSegments[i2], routeSegment = routeSegments[i2], isLastBaseSegment = i2 >= baseSegments.length - 1, isLastRouteSegment = i2 >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          const _splat = decodeURI(
            joinPaths(baseSegments.slice(i2).map((d) => d.value))
          );
          return params["*"] = _splat, params._splat = _splat, !0;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !baseSegment?.value)
            return !0;
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value)
                return !1;
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase())
              return !1;
          }
        }
        if (!baseSegment)
          return !1;
        if (routeSegment.type === "param") {
          if (baseSegment.value === "/")
            return !1;
          baseSegment.value.charAt(0) !== "$" && (params[routeSegment.value.substring(1)] = decodeURIComponent(
            baseSegment.value
          ));
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment)
        return params["**"] = joinPaths(baseSegments.slice(i2 + 1).map((d) => d.value)), !!matchLocation.fuzzy && routeSegment?.value !== "/";
    }
    return !0;
  })() ? params : void 0;
}
function notFound(options = {}) {
  if (options.isNotFound = !0, options.throw) throw options;
  return options;
}
function isNotFound(obj) {
  return !!obj?.isNotFound;
}
const storageKey = "tsr-scroll-restoration-v1_3";
let sessionsStorage = !1;
try {
  sessionsStorage = typeof window < "u" && typeof window.sessionStorage == "object";
} catch {
}
const throttle = (fn, wait) => {
  let timeout2;
  return (...args) => {
    timeout2 || (timeout2 = setTimeout(() => {
      fn(...args), timeout2 = null;
    }, wait));
  };
}, scrollRestorationCache = sessionsStorage ? {
  state: JSON.parse(window.sessionStorage.getItem(storageKey) || "null") || {},
  // This setter is simply to make sure that we set the sessionStorage right
  // after the state is updated. It doesn't necessarily need to be a functional
  // update.
  set: (updater) => (scrollRestorationCache.state = functionalUpdate(updater, scrollRestorationCache.state) || scrollRestorationCache.state, window.sessionStorage.setItem(
    storageKey,
    JSON.stringify(scrollRestorationCache.state)
  ))
} : void 0, defaultGetScrollRestorationKey = (location) => location.state.key || location.href;
function getCssSelector(el) {
  const path = [];
  let parent;
  for (; parent = el.parentNode; )
    path.unshift(
      `${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`
    ), el = parent;
  return `${path.join(" > ")}`.toLowerCase();
}
let ignoreScroll = !1;
function restoreScroll(storageKey2, key, behavior, shouldScrollRestoration, scrollToTopSelectors) {
  var _a;
  let byKey;
  try {
    byKey = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
  } catch (error) {
    console.error(error);
    return;
  }
  const resolvedKey = key || ((_a = window.history.state) == null ? void 0 : _a.key), elementEntries = byKey[resolvedKey];
  ignoreScroll = !0, (() => {
    if (shouldScrollRestoration && elementEntries) {
      for (const elementSelector in elementEntries) {
        const entry = elementEntries[elementSelector];
        if (elementSelector === "window")
          window.scrollTo({
            top: entry.scrollY,
            left: entry.scrollX,
            behavior
          });
        else if (elementSelector) {
          const element = document.querySelector(elementSelector);
          element && (element.scrollLeft = entry.scrollX, element.scrollTop = entry.scrollY);
        }
      }
      return;
    }
    const hash = window.location.hash.split("#")[1];
    if (hash) {
      const hashScrollIntoViewOptions = (window.history.state || {}).__hashScrollIntoViewOptions ?? !0;
      if (hashScrollIntoViewOptions) {
        const el = document.getElementById(hash);
        el && el.scrollIntoView(hashScrollIntoViewOptions);
      }
      return;
    }
    [
      "window",
      ...scrollToTopSelectors?.filter((d) => d !== "window") ?? []
    ].forEach((selector2) => {
      const element = selector2 === "window" ? window : document.querySelector(selector2);
      element && element.scrollTo({
        top: 0,
        left: 0,
        behavior
      });
    });
  })(), ignoreScroll = !1;
}
function setupScrollRestoration(router, force) {
  if ((router.options.scrollRestoration ?? !1) && (router.isScrollRestoring = !0), typeof document > "u" || router.isScrollRestorationSetup)
    return;
  router.isScrollRestorationSetup = !0, ignoreScroll = !1;
  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;
  window.history.scrollRestoration = "manual";
  const onScroll = (event) => {
    if (ignoreScroll || !router.isScrollRestoring)
      return;
    let elementSelector = "";
    if (event.target === document || event.target === window)
      elementSelector = "window";
    else {
      const attrId = event.target.getAttribute(
        "data-scroll-restoration-id"
      );
      attrId ? elementSelector = `[data-scroll-restoration-id="${attrId}"]` : elementSelector = getCssSelector(event.target);
    }
    const restoreKey = getKey(router.state.location);
    scrollRestorationCache.set((state) => {
      const keyEntry = state[restoreKey] = state[restoreKey] || {}, elementEntry = keyEntry[elementSelector] = keyEntry[elementSelector] || {};
      if (elementSelector === "window")
        elementEntry.scrollX = window.scrollX || 0, elementEntry.scrollY = window.scrollY || 0;
      else if (elementSelector) {
        const element = document.querySelector(elementSelector);
        element && (elementEntry.scrollX = element.scrollLeft || 0, elementEntry.scrollY = element.scrollTop || 0);
      }
      return state;
    });
  };
  typeof document < "u" && document.addEventListener("scroll", throttle(onScroll, 100), !0), router.subscribe("onRendered", (event) => {
    const cacheKey = getKey(event.toLocation);
    if (!router.resetNextScroll) {
      router.resetNextScroll = !0;
      return;
    }
    restoreScroll(
      storageKey,
      cacheKey,
      router.options.scrollRestorationBehavior || void 0,
      router.isScrollRestoring || void 0,
      router.options.scrollToTopSelectors || void 0
    ), router.isScrollRestoring && scrollRestorationCache.set((state) => (state[cacheKey] = state[cacheKey] || {}, state));
  });
}
function encode(obj, pfx) {
  let k, i2, tmp, str = "";
  for (k in obj)
    if ((tmp = obj[k]) !== void 0)
      if (Array.isArray(tmp))
        for (i2 = 0; i2 < tmp.length; i2++)
          str && (str += "&"), str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp[i2]);
      else
        str && (str += "&"), str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp);
  return "" + str;
}
function toValue(mix2) {
  if (!mix2) return "";
  const str = hasUriEncodedChars(mix2) ? decodeURIComponent(mix2) : decodeURIComponent(encodeURIComponent(mix2));
  return str === "false" ? !1 : str === "true" ? !0 : +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str, pfx) {
  let tmp, k;
  const out = {}, arr = str.split("&");
  for (; tmp = arr.shift(); ) {
    const equalIndex = tmp.indexOf("=");
    if (equalIndex !== -1) {
      k = tmp.slice(0, equalIndex), k = decodeURIComponent(k);
      const value = tmp.slice(equalIndex + 1);
      out[k] !== void 0 ? out[k] = [].concat(out[k], toValue(value)) : out[k] = toValue(value);
    } else
      k = tmp, k = decodeURIComponent(k), out[k] = "";
  }
  return out;
}
const defaultParseSearch = parseSearchWith(JSON.parse), defaultStringifySearch = stringifySearchWith(
  JSON.stringify,
  JSON.parse
);
function parseSearchWith(parser) {
  return (searchStr) => {
    searchStr.substring(0, 1) === "?" && (searchStr = searchStr.substring(1));
    const query = decode(searchStr);
    for (const key in query) {
      const value = query[key];
      if (typeof value == "string")
        try {
          query[key] = parser(value);
        } catch {
        }
    }
    return query;
  };
}
function stringifySearchWith(stringify, parser) {
  function stringifyValue(val) {
    if (typeof val == "object" && val !== null)
      try {
        return stringify(val);
      } catch {
      }
    else if (typeof val == "string" && typeof parser == "function")
      try {
        return parser(val), stringify(val);
      } catch {
      }
    return val;
  }
  return (search) => {
    search = { ...search }, Object.keys(search).forEach((key) => {
      const val = search[key];
      typeof val > "u" || val === void 0 ? delete search[key] : search[key] = stringifyValue(val);
    });
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : "";
  };
}
const rootRouteId = "__root__";
function redirect(opts) {
  if (opts.isRedirect = !0, opts.statusCode = opts.statusCode || opts.code || 307, opts.headers = opts.headers || {}, !opts.reloadDocument) {
    opts.reloadDocument = !1;
    try {
      new URL(`${opts.href}`), opts.reloadDocument = !0;
    } catch {
    }
  }
  if (opts.throw)
    throw opts;
  return opts;
}
function isRedirect(obj) {
  return !!obj?.isRedirect;
}
function isResolvedRedirect(obj) {
  return !!obj?.isRedirect && obj.href;
}
function getLocationChangeInfo(routerState) {
  const fromLocation = routerState.resolvedLocation, toLocation = routerState.location, pathChanged = fromLocation?.pathname !== toLocation.pathname, hrefChanged = fromLocation?.href !== toLocation.href, hashChanged = fromLocation?.hash !== toLocation.hash;
  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged };
}
class RouterCore {
  /**
   * @deprecated Use the `createRouter` function instead
   */
  constructor(options) {
    this.tempLocationKey = `${Math.round(
      Math.random() * 1e7
    )}`, this.resetNextScroll = !0, this.shouldViewTransition = void 0, this.isViewTransitionTypesSupported = void 0, this.subscribers = /* @__PURE__ */ new Set(), this.isScrollRestoring = !1, this.isScrollRestorationSetup = !1, this.startTransition = (fn) => fn(), this.update = (newOptions) => {
      var _a;
      newOptions.notFoundRoute && console.warn(
        "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info."
      );
      const previousOptions = this.options;
      this.options = {
        ...this.options,
        ...newOptions
      }, this.isServer = this.options.isServer ?? typeof document > "u", this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(
        this.options.pathParamsAllowedCharacters.map((char) => [
          encodeURIComponent(char),
          char
        ])
      ) : void 0, (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) && (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/" ? this.basepath = "/" : this.basepath = `/${trimPath(newOptions.basepath)}`), // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      (!this.history || this.options.history && this.options.history !== this.history) && (this.history = this.options.history ?? (this.isServer ? createMemoryHistory({
        initialEntries: [this.basepath || "/"]
      }) : createBrowserHistory()), this.latestLocation = this.parseLocation()), this.options.routeTree !== this.routeTree && (this.routeTree = this.options.routeTree, this.buildRouteTree()), this.__store || (this.__store = new Store(getInitialRouterState(this.latestLocation), {
        onUpdate: () => {
          this.__store.state = {
            ...this.state,
            cachedMatches: this.state.cachedMatches.filter(
              (d) => !["redirected"].includes(d.status)
            )
          };
        }
      }), setupScrollRestoration(this)), typeof window < "u" && "CSS" in window && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      typeof ((_a = window.CSS) == null ? void 0 : _a.supports) == "function" && (this.isViewTransitionTypesSupported = window.CSS.supports(
        "selector(:active-view-transition-type(a)"
      ));
    }, this.buildRouteTree = () => {
      this.routesById = {}, this.routesByPath = {};
      const notFoundRoute = this.options.notFoundRoute;
      notFoundRoute && (notFoundRoute.init({
        originalIndex: 99999999999,
        defaultSsr: this.options.defaultSsr
      }), this.routesById[notFoundRoute.id] = notFoundRoute);
      const recurseRoutes = (childRoutes) => {
        childRoutes.forEach((childRoute, i2) => {
          childRoute.init({
            originalIndex: i2,
            defaultSsr: this.options.defaultSsr
          });
          const existingRoute = this.routesById[childRoute.id];
          if (invariant$1(
            !existingRoute,
            `Duplicate routes found with id: ${String(childRoute.id)}`
          ), this.routesById[childRoute.id] = childRoute, !childRoute.isRoot && childRoute.path) {
            const trimmedFullPath = trimPathRight(childRoute.fullPath);
            (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) && (this.routesByPath[trimmedFullPath] = childRoute);
          }
          const children2 = childRoute.children;
          children2?.length && recurseRoutes(children2);
        });
      };
      recurseRoutes([this.routeTree]);
      const scoredRoutes = [];
      Object.values(this.routesById).forEach((d, i2) => {
        var _a;
        if (d.isRoot || !d.path)
          return;
        const trimmed = trimPathLeft(d.fullPath), parsed = parsePathname(trimmed);
        for (; parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/"; )
          parsed.shift();
        const scores = parsed.map((segment) => segment.value === "/" ? 0.75 : segment.type === "param" ? 0.5 : segment.type === "wildcard" ? 0.25 : 1);
        scoredRoutes.push({ child: d, trimmed, parsed, index: i2, scores });
      }), this.flatRoutes = scoredRoutes.sort((a2, b) => {
        const minLength = Math.min(a2.scores.length, b.scores.length);
        for (let i2 = 0; i2 < minLength; i2++)
          if (a2.scores[i2] !== b.scores[i2])
            return b.scores[i2] - a2.scores[i2];
        if (a2.scores.length !== b.scores.length)
          return b.scores.length - a2.scores.length;
        for (let i2 = 0; i2 < minLength; i2++)
          if (a2.parsed[i2].value !== b.parsed[i2].value)
            return a2.parsed[i2].value > b.parsed[i2].value ? 1 : -1;
        return a2.index - b.index;
      }).map((d, i2) => (d.child.rank = i2, d.child));
    }, this.subscribe = (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      return this.subscribers.add(listener), () => {
        this.subscribers.delete(listener);
      };
    }, this.emit = (routerEvent) => {
      this.subscribers.forEach((listener) => {
        listener.eventType === routerEvent.type && listener.fn(routerEvent);
      });
    }, this.parseLocation = (previousLocation, locationToParse) => {
      const parse2 = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = this.options.parseSearch(search), searchStr = this.options.stringifySearch(parsedSearch);
        return {
          pathname,
          searchStr,
          search: replaceEqualDeep(previousLocation?.search, parsedSearch),
          hash: hash.split("#").reverse()[0] ?? "",
          href: `${pathname}${searchStr}${hash}`,
          state: replaceEqualDeep(previousLocation?.state, state)
        };
      }, location = parse2(locationToParse ?? this.history.location), { __tempLocation, __tempKey } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
        const parsedTempLocation = parse2(__tempLocation);
        return parsedTempLocation.state.key = location.state.key, delete parsedTempLocation.state.__tempLocation, {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    }, this.resolvePathWithBase = (from, path) => resolvePath({
      basepath: this.basepath,
      base: from,
      to: cleanPath(path),
      trailingSlash: this.options.trailingSlash,
      caseSensitive: this.options.caseSensitive
    }), this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => typeof pathnameOrNext == "string" ? this.matchRoutesInternal(
      {
        pathname: pathnameOrNext,
        search: locationSearchOrOpts
      },
      opts
    ) : this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts), this.getMatchedRoutes = (next, dest) => {
      let routeParams = {};
      const trimmedPath = trimPathRight(next.pathname), getMatchedParams = (route) => matchPathname(this.basepath, trimmedPath, {
        to: route.fullPath,
        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,
        fuzzy: !0
      });
      let foundRoute = dest?.to !== void 0 ? this.routesByPath[dest.to] : void 0;
      foundRoute ? routeParams = getMatchedParams(foundRoute) : foundRoute = this.flatRoutes.find((route) => {
        const matchedParams = getMatchedParams(route);
        return matchedParams ? (routeParams = matchedParams, !0) : !1;
      });
      let routeCursor = foundRoute || this.routesById[rootRouteId];
      const matchedRoutes = [routeCursor];
      for (; routeCursor.parentRoute; )
        routeCursor = routeCursor.parentRoute, matchedRoutes.unshift(routeCursor);
      return { matchedRoutes, routeParams, foundRoute };
    }, this.cancelMatch = (id2) => {
      const match = this.getMatch(id2);
      match && (match.abortController.abort(), clearTimeout(match.pendingTimeout));
    }, this.cancelMatches = () => {
      var _a;
      (_a = this.state.pendingMatches) == null || _a.forEach((match) => {
        this.cancelMatch(match.id);
      });
    }, this.buildLocation = (opts) => {
      const build = (dest = {}, matchedRoutesResult) => {
        var _a, _b, _c, _d, _e2, _f, _g;
        const fromMatches = dest._fromLocation ? this.matchRoutes(dest._fromLocation, { _buildLocation: !0 }) : this.state.matches, fromMatch = dest.from != null ? fromMatches.find(
          (d) => matchPathname(this.basepath, trimPathRight(d.pathname), {
            to: dest.from,
            caseSensitive: !1,
            fuzzy: !1
          })
        ) : void 0, fromPath = fromMatch?.pathname || this.latestLocation.pathname;
        invariant$1(
          dest.from == null || fromMatch != null,
          "Could not find match for from: " + dest.from
        );
        const fromSearch = (_a = this.state.pendingMatches) != null && _a.length ? (_b = last(this.state.pendingMatches)) == null ? void 0 : _b.search : ((_c = last(fromMatches)) == null ? void 0 : _c.search) || this.latestLocation.search, stayingMatches = matchedRoutesResult?.matchedRoutes.filter(
          (d) => fromMatches.find((e2) => e2.routeId === d.id)
        );
        let pathname;
        if (dest.to) {
          const resolvePathTo = fromMatch?.fullPath || ((_d = last(fromMatches)) == null ? void 0 : _d.fullPath) || this.latestLocation.pathname;
          pathname = this.resolvePathWithBase(resolvePathTo, `${dest.to}`);
        } else {
          const fromRouteByFromPathRouteId = this.routesById[(_e2 = stayingMatches?.find((route) => {
            const interpolatedPath = interpolatePath({
              path: route.fullPath,
              params: matchedRoutesResult?.routeParams ?? {},
              decodeCharMap: this.pathParamsDecodeCharMap
            }).interpolatedPath;
            return joinPaths([this.basepath, interpolatedPath]) === fromPath;
          })) == null ? void 0 : _e2.id];
          pathname = this.resolvePathWithBase(
            fromPath,
            fromRouteByFromPathRouteId?.to ?? fromPath
          );
        }
        const prevParams = { ...(_f = last(fromMatches)) == null ? void 0 : _f.params };
        let nextParams = (dest.params ?? !0) === !0 ? prevParams : {
          ...prevParams,
          ...functionalUpdate(dest.params, prevParams)
        };
        Object.keys(nextParams).length > 0 && matchedRoutesResult?.matchedRoutes.map((route) => {
          var _a2;
          return ((_a2 = route.options.params) == null ? void 0 : _a2.stringify) ?? route.options.stringifyParams;
        }).filter(Boolean).forEach((fn) => {
          nextParams = { ...nextParams, ...fn(nextParams) };
        }), pathname = interpolatePath({
          path: pathname,
          params: nextParams ?? {},
          leaveWildcards: !1,
          leaveParams: opts.leaveParams,
          decodeCharMap: this.pathParamsDecodeCharMap
        }).interpolatedPath;
        let search = fromSearch;
        if (opts._includeValidateSearch && ((_g = this.options.search) != null && _g.strict)) {
          let validatedSearch = {};
          matchedRoutesResult?.matchedRoutes.forEach((route) => {
            try {
              route.options.validateSearch && (validatedSearch = {
                ...validatedSearch,
                ...validateSearch(route.options.validateSearch, {
                  ...validatedSearch,
                  ...search
                }) ?? {}
              });
            } catch {
            }
          }), search = validatedSearch;
        }
        search = ((search2) => {
          const allMiddlewares = matchedRoutesResult?.matchedRoutes.reduce(
            (acc, route) => {
              var _a2;
              const middlewares = [];
              if ("search" in route.options)
                (_a2 = route.options.search) != null && _a2.middlewares && middlewares.push(...route.options.search.middlewares);
              else if (route.options.preSearchFilters || route.options.postSearchFilters) {
                const legacyMiddleware = ({
                  search: search3,
                  next
                }) => {
                  let nextSearch = search3;
                  "preSearchFilters" in route.options && route.options.preSearchFilters && (nextSearch = route.options.preSearchFilters.reduce(
                    (prev, next2) => next2(prev),
                    search3
                  ));
                  const result = next(nextSearch);
                  return "postSearchFilters" in route.options && route.options.postSearchFilters ? route.options.postSearchFilters.reduce(
                    (prev, next2) => next2(prev),
                    result
                  ) : result;
                };
                middlewares.push(legacyMiddleware);
              }
              if (opts._includeValidateSearch && route.options.validateSearch) {
                const validate = ({ search: search3, next }) => {
                  const result = next(search3);
                  try {
                    return {
                      ...result,
                      ...validateSearch(
                        route.options.validateSearch,
                        result
                      ) ?? {}
                    };
                  } catch {
                    return result;
                  }
                };
                middlewares.push(validate);
              }
              return acc.concat(middlewares);
            },
            []
          ) ?? [], final = ({ search: search3 }) => dest.search ? dest.search === !0 ? search3 : functionalUpdate(dest.search, search3) : {};
          allMiddlewares.push(final);
          const applyNext = (index2, currentSearch) => {
            if (index2 >= allMiddlewares.length)
              return currentSearch;
            const middleware = allMiddlewares[index2];
            return middleware({ search: currentSearch, next: (newSearch) => applyNext(index2 + 1, newSearch) });
          };
          return applyNext(0, search2);
        })(search), search = replaceEqualDeep(fromSearch, search);
        const searchStr = this.options.stringifySearch(search), hash = dest.hash === !0 ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0, hashStr = hash ? `#${hash}` : "";
        let nextState = dest.state === !0 ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};
        return nextState = replaceEqualDeep(this.latestLocation.state, nextState), {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash: hash ?? "",
          href: `${pathname}${searchStr}${hashStr}`,
          unmaskOnReload: dest.unmaskOnReload
        };
      }, buildWithMatches = (dest = {}, maskedDest) => {
        var _a;
        const next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : void 0;
        if (!maskedNext) {
          let params = {};
          const foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find((d) => {
            const match = matchPathname(this.basepath, next.pathname, {
              to: d.from,
              caseSensitive: !1,
              fuzzy: !1
            });
            return match ? (params = match, !0) : !1;
          });
          if (foundMask) {
            const { from: _from, ...maskProps } = foundMask;
            maskedDest = {
              ...pick$1(opts, ["from"]),
              ...maskProps,
              params
            }, maskedNext = build(maskedDest);
          }
        }
        const nextMatches = this.getMatchedRoutes(next, dest), final = build(dest, nextMatches);
        if (maskedNext) {
          const maskedMatches = this.getMatchedRoutes(maskedNext, maskedDest), maskedFinal = build(maskedDest, maskedMatches);
          final.maskedLocation = maskedFinal;
        }
        return final;
      };
      return opts.mask ? buildWithMatches(opts, {
        ...pick$1(opts, ["from"]),
        ...opts.mask
      }) : buildWithMatches(opts);
    }, this.commitLocation = ({
      viewTransition,
      ignoreBlocker,
      ...next
    }) => {
      const isSameState = () => {
        const ignoredProps = [
          "key",
          "__TSR_index",
          "__hashScrollIntoViewOptions"
        ];
        ignoredProps.forEach((prop) => {
          next.state[prop] = this.latestLocation.state[prop];
        });
        const isEqual = deepEqual$1(next.state, this.latestLocation.state);
        return ignoredProps.forEach((prop) => {
          delete next.state[prop];
        }), isEqual;
      }, isSameUrl = this.latestLocation.href === next.href, previousCommitPromise = this.commitLocationPromise;
      if (this.commitLocationPromise = createControlledPromise(() => {
        previousCommitPromise?.resolve();
      }), isSameUrl && isSameState())
        this.load();
      else {
        let { maskedLocation, hashScrollIntoView, ...nextHistory } = next;
        maskedLocation && (nextHistory = {
          ...maskedLocation,
          state: {
            ...maskedLocation.state,
            __tempKey: void 0,
            __tempLocation: {
              ...nextHistory,
              search: nextHistory.searchStr,
              state: {
                ...nextHistory.state,
                __tempKey: void 0,
                __tempLocation: void 0,
                key: void 0
              }
            }
          }
        }, (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) && (nextHistory.state.__tempKey = this.tempLocationKey)), nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? !0, this.shouldViewTransition = viewTransition, this.history[next.replace ? "replace" : "push"](
          nextHistory.href,
          nextHistory.state,
          { ignoreBlocker }
        );
      }
      return this.resetNextScroll = next.resetScroll ?? !0, this.history.subscribers.size || this.load(), this.commitLocationPromise;
    }, this.buildAndCommitLocation = ({
      replace,
      resetScroll,
      hashScrollIntoView,
      viewTransition,
      ignoreBlocker,
      href,
      ...rest
    } = {}) => {
      if (href) {
        const currentIndex = this.history.location.state.__TSR_index, parsed = parseHref(href, {
          __TSR_index: replace ? currentIndex : currentIndex + 1
        });
        rest.to = parsed.pathname, rest.search = this.options.parseSearch(parsed.search), rest.hash = parsed.hash.slice(1);
      }
      const location = this.buildLocation({
        ...rest,
        _includeValidateSearch: !0
      });
      return this.commitLocation({
        ...location,
        viewTransition,
        replace,
        resetScroll,
        hashScrollIntoView,
        ignoreBlocker
      });
    }, this.navigate = ({ to, reloadDocument, href, ...rest }) => {
      if (reloadDocument) {
        if (!href) {
          const location = this.buildLocation({ to, ...rest });
          href = this.history.createHref(location.href);
        }
        rest.replace ? window.location.replace(href) : window.location.href = href;
        return;
      }
      return this.buildAndCommitLocation({
        ...rest,
        href,
        to
      });
    }, this.load = async (opts) => {
      this.latestLocation = this.parseLocation(this.latestLocation);
      let redirect2, notFound2, loadPromise;
      for (loadPromise = new Promise((resolve) => {
        this.startTransition(async () => {
          var _a;
          try {
            const next = this.latestLocation, prevLocation = this.state.resolvedLocation;
            this.cancelMatches();
            let pendingMatches;
            batch(() => {
              pendingMatches = this.matchRoutes(next), this.__store.setState((s) => ({
                ...s,
                status: "pending",
                isLoading: !0,
                location: next,
                pendingMatches,
                // If a cached moved to pendingMatches, remove it from cachedMatches
                cachedMatches: s.cachedMatches.filter((d) => !pendingMatches.find((e2) => e2.id === d.id))
              }));
            }), this.state.redirect || this.emit({
              type: "onBeforeNavigate",
              ...getLocationChangeInfo({
                resolvedLocation: prevLocation,
                location: next
              })
            }), this.emit({
              type: "onBeforeLoad",
              ...getLocationChangeInfo({
                resolvedLocation: prevLocation,
                location: next
              })
            }), await this.loadMatches({
              sync: opts?.sync,
              matches: pendingMatches,
              location: next,
              // eslint-disable-next-line @typescript-eslint/require-await
              onReady: async () => {
                this.startViewTransition(async () => {
                  let exitingMatches, enteringMatches, stayingMatches;
                  batch(() => {
                    this.__store.setState((s) => {
                      const previousMatches = s.matches, newMatches = s.pendingMatches || s.matches;
                      return exitingMatches = previousMatches.filter(
                        (match) => !newMatches.find((d) => d.id === match.id)
                      ), enteringMatches = newMatches.filter(
                        (match) => !previousMatches.find((d) => d.id === match.id)
                      ), stayingMatches = previousMatches.filter(
                        (match) => newMatches.find((d) => d.id === match.id)
                      ), {
                        ...s,
                        isLoading: !1,
                        loadedAt: Date.now(),
                        matches: newMatches,
                        pendingMatches: void 0,
                        cachedMatches: [
                          ...s.cachedMatches,
                          ...exitingMatches.filter((d) => d.status !== "error")
                        ]
                      };
                    }), this.clearExpiredCache();
                  }), [
                    [exitingMatches, "onLeave"],
                    [enteringMatches, "onEnter"],
                    [stayingMatches, "onStay"]
                  ].forEach(([matches2, hook]) => {
                    matches2.forEach((match) => {
                      var _a2, _b;
                      (_b = (_a2 = this.looseRoutesById[match.routeId].options)[hook]) == null || _b.call(_a2, match);
                    });
                  });
                });
              }
            });
          } catch (err) {
            isResolvedRedirect(err) ? (redirect2 = err, this.isServer || this.navigate({
              ...redirect2,
              replace: !0,
              ignoreBlocker: !0
            })) : isNotFound(err) && (notFound2 = err), this.__store.setState((s) => ({
              ...s,
              statusCode: redirect2 ? redirect2.statusCode : notFound2 ? 404 : s.matches.some((d) => d.status === "error") ? 500 : 200,
              redirect: redirect2
            }));
          }
          this.latestLoadPromise === loadPromise && ((_a = this.commitLocationPromise) == null || _a.resolve(), this.latestLoadPromise = void 0, this.commitLocationPromise = void 0), resolve();
        });
      }), this.latestLoadPromise = loadPromise, await loadPromise; this.latestLoadPromise && loadPromise !== this.latestLoadPromise; )
        await this.latestLoadPromise;
      this.hasNotFoundMatch() && this.__store.setState((s) => ({
        ...s,
        statusCode: 404
      }));
    }, this.startViewTransition = (fn) => {
      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;
      if (delete this.shouldViewTransition, shouldViewTransition && typeof document < "u" && "startViewTransition" in document && typeof document.startViewTransition == "function") {
        let startViewTransitionParams;
        typeof shouldViewTransition == "object" && this.isViewTransitionTypesSupported ? startViewTransitionParams = {
          update: fn,
          types: shouldViewTransition.types
        } : startViewTransitionParams = fn, document.startViewTransition(startViewTransitionParams);
      } else
        fn();
    }, this.updateMatch = (id2, updater) => {
      var _a;
      let updated;
      const isPending = (_a = this.state.pendingMatches) == null ? void 0 : _a.find((d) => d.id === id2), isMatched = this.state.matches.find((d) => d.id === id2), isCached = this.state.cachedMatches.find((d) => d.id === id2), matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : isCached ? "cachedMatches" : "";
      return matchesKey && this.__store.setState((s) => {
        var _a2;
        return {
          ...s,
          [matchesKey]: (_a2 = s[matchesKey]) == null ? void 0 : _a2.map(
            (d) => d.id === id2 ? updated = updater(d) : d
          )
        };
      }), updated;
    }, this.getMatch = (matchId) => [
      ...this.state.cachedMatches,
      ...this.state.pendingMatches ?? [],
      ...this.state.matches
    ].find((d) => d.id === matchId), this.loadMatches = async ({
      location,
      matches: matches2,
      preload: allPreload,
      onReady,
      updateMatch = this.updateMatch,
      sync
    }) => {
      let firstBadMatchIndex, rendered = !1;
      const triggerOnReady = async () => {
        rendered || (rendered = !0, await onReady?.());
      }, resolvePreload = (matchId) => !!(allPreload && !this.state.matches.find((d) => d.id === matchId));
      !this.isServer && !this.state.matches.length && triggerOnReady();
      const handleRedirectAndNotFound = (match, err) => {
        var _a, _b, _c, _d;
        if (isResolvedRedirect(err) && !err.reloadDocument)
          throw err;
        if (isRedirect(err) || isNotFound(err)) {
          if (updateMatch(match.id, (prev) => ({
            ...prev,
            status: isRedirect(err) ? "redirected" : isNotFound(err) ? "notFound" : "error",
            isFetching: !1,
            error: err,
            beforeLoadPromise: void 0,
            loaderPromise: void 0
          })), err.routeId || (err.routeId = match.routeId), (_a = match.beforeLoadPromise) == null || _a.resolve(), (_b = match.loaderPromise) == null || _b.resolve(), (_c = match.loadPromise) == null || _c.resolve(), isRedirect(err))
            throw rendered = !0, err = this.resolveRedirect({ ...err, _fromLocation: location }), err;
          if (isNotFound(err))
            throw this._handleNotFound(matches2, err, {
              updateMatch
            }), (_d = this.serverSsr) == null || _d.onMatchSettled({
              router: this,
              match: this.getMatch(match.id)
            }), err;
        }
      };
      try {
        await new Promise((resolveAll, rejectAll) => {
          (async () => {
            var _a, _b, _c, _d;
            try {
              const handleSerialError = (index2, err, routerCode) => {
                var _a2, _b2;
                const { id: matchId, routeId } = matches2[index2], route = this.looseRoutesById[routeId];
                if (err instanceof Promise)
                  throw err;
                err.routerCode = routerCode, firstBadMatchIndex = firstBadMatchIndex ?? index2, handleRedirectAndNotFound(this.getMatch(matchId), err);
                try {
                  (_b2 = (_a2 = route.options).onError) == null || _b2.call(_a2, err);
                } catch (errorHandlerErr) {
                  err = errorHandlerErr, handleRedirectAndNotFound(this.getMatch(matchId), err);
                }
                updateMatch(matchId, (prev) => {
                  var _a3, _b3;
                  return (_a3 = prev.beforeLoadPromise) == null || _a3.resolve(), (_b3 = prev.loadPromise) == null || _b3.resolve(), {
                    ...prev,
                    error: err,
                    status: "error",
                    isFetching: !1,
                    updatedAt: Date.now(),
                    abortController: new AbortController(),
                    beforeLoadPromise: void 0
                  };
                });
              };
              for (const [index2, { id: matchId, routeId }] of matches2.entries()) {
                const existingMatch = this.getMatch(matchId), parentMatchId = (_a = matches2[index2 - 1]) == null ? void 0 : _a.id, route = this.looseRoutesById[routeId], pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs, shouldPending = !!(onReady && !this.isServer && !resolvePreload(matchId) && (route.options.loader || route.options.beforeLoad) && typeof pendingMs == "number" && pendingMs !== 1 / 0 && (route.options.pendingComponent ?? ((_b = this.options) == null ? void 0 : _b.defaultPendingComponent)));
                let executeBeforeLoad = !0;
                if (
                  // If we are in the middle of a load, either of these will be present
                  // (not to be confused with `loadPromise`, which is always defined)
                  (existingMatch.beforeLoadPromise || existingMatch.loaderPromise) && (shouldPending && setTimeout(() => {
                    try {
                      triggerOnReady();
                    } catch {
                    }
                  }, pendingMs), await existingMatch.beforeLoadPromise, executeBeforeLoad = this.getMatch(matchId).status !== "success"), executeBeforeLoad
                ) {
                  try {
                    updateMatch(matchId, (prev) => {
                      const prevLoadPromise = prev.loadPromise;
                      return {
                        ...prev,
                        loadPromise: createControlledPromise(() => {
                          prevLoadPromise?.resolve();
                        }),
                        beforeLoadPromise: createControlledPromise()
                      };
                    });
                    const abortController = new AbortController();
                    let pendingTimeout;
                    shouldPending && (pendingTimeout = setTimeout(() => {
                      try {
                        triggerOnReady();
                      } catch {
                      }
                    }, pendingMs));
                    const { paramsError, searchError } = this.getMatch(matchId);
                    paramsError && handleSerialError(index2, paramsError, "PARSE_PARAMS"), searchError && handleSerialError(index2, searchError, "VALIDATE_SEARCH");
                    const getParentMatchContext = () => parentMatchId ? this.getMatch(parentMatchId).context : this.options.context ?? {};
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: "beforeLoad",
                      fetchCount: prev.fetchCount + 1,
                      abortController,
                      pendingTimeout,
                      context: {
                        ...getParentMatchContext(),
                        ...prev.__routeContext
                      }
                    }));
                    const { search, params, context, cause } = this.getMatch(matchId), preload = resolvePreload(matchId), beforeLoadFnContext = {
                      search,
                      abortController,
                      params,
                      preload,
                      context,
                      location,
                      navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                      buildLocation: this.buildLocation,
                      cause: preload ? "preload" : cause,
                      matches: matches2
                    }, beforeLoadContext = await ((_d = (_c = route.options).beforeLoad) == null ? void 0 : _d.call(_c, beforeLoadFnContext)) ?? {};
                    (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) && handleSerialError(index2, beforeLoadContext, "BEFORE_LOAD"), updateMatch(matchId, (prev) => ({
                      ...prev,
                      __beforeLoadContext: beforeLoadContext,
                      context: {
                        ...getParentMatchContext(),
                        ...prev.__routeContext,
                        ...beforeLoadContext
                      },
                      abortController
                    }));
                  } catch (err) {
                    handleSerialError(index2, err, "BEFORE_LOAD");
                  }
                  updateMatch(matchId, (prev) => {
                    var _a2;
                    return (_a2 = prev.beforeLoadPromise) == null || _a2.resolve(), {
                      ...prev,
                      beforeLoadPromise: void 0,
                      isFetching: !1
                    };
                  });
                }
              }
              const validResolvedMatches = matches2.slice(0, firstBadMatchIndex), matchPromises = [];
              validResolvedMatches.forEach(({ id: matchId, routeId }, index2) => {
                matchPromises.push(
                  (async () => {
                    const { loaderPromise: prevLoaderPromise } = this.getMatch(matchId);
                    let loaderShouldRunAsync = !1, loaderIsRunningAsync = !1;
                    if (prevLoaderPromise) {
                      await prevLoaderPromise;
                      const match = this.getMatch(matchId);
                      match.error && handleRedirectAndNotFound(match, match.error);
                    } else {
                      const parentMatchPromise = matchPromises[index2 - 1], route = this.looseRoutesById[routeId], getLoaderContext = () => {
                        const {
                          params,
                          loaderDeps,
                          abortController,
                          context,
                          cause
                        } = this.getMatch(matchId), preload2 = resolvePreload(matchId);
                        return {
                          params,
                          deps: loaderDeps,
                          preload: !!preload2,
                          parentMatchPromise,
                          abortController,
                          context,
                          location,
                          navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                          cause: preload2 ? "preload" : cause,
                          route
                        };
                      }, age = Date.now() - this.getMatch(matchId).updatedAt, preload = resolvePreload(matchId), staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0, shouldReloadOption = route.options.shouldReload, shouldReload = typeof shouldReloadOption == "function" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;
                      updateMatch(matchId, (prev) => ({
                        ...prev,
                        loaderPromise: createControlledPromise(),
                        preload: !!preload && !this.state.matches.find((d) => d.id === matchId)
                      }));
                      const runLoader = async () => {
                        var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k;
                        try {
                          const potentialPendingMinPromise = async () => {
                            const latestMatch = this.getMatch(matchId);
                            latestMatch.minPendingPromise && await latestMatch.minPendingPromise;
                          };
                          try {
                            this.loadRouteChunk(route), updateMatch(matchId, (prev) => ({
                              ...prev,
                              isFetching: "loader"
                            }));
                            const loaderData = await ((_b2 = (_a2 = route.options).loader) == null ? void 0 : _b2.call(_a2, getLoaderContext()));
                            handleRedirectAndNotFound(
                              this.getMatch(matchId),
                              loaderData
                            ), await route._lazyPromise, await potentialPendingMinPromise();
                            const assetContext = {
                              matches: matches2,
                              match: this.getMatch(matchId),
                              params: this.getMatch(matchId).params,
                              loaderData
                            }, headFnContent = (_d2 = (_c2 = route.options).head) == null ? void 0 : _d2.call(_c2, assetContext), meta = headFnContent?.meta, links = headFnContent?.links, headScripts = headFnContent?.scripts, scripts = (_f = (_e2 = route.options).scripts) == null ? void 0 : _f.call(_e2, assetContext), headers = (_h = (_g = route.options).headers) == null ? void 0 : _h.call(_g, {
                              loaderData
                            });
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error: void 0,
                              status: "success",
                              isFetching: !1,
                              updatedAt: Date.now(),
                              loaderData,
                              meta,
                              links,
                              headScripts,
                              headers,
                              scripts
                            }));
                          } catch (e2) {
                            let error = e2;
                            await potentialPendingMinPromise(), handleRedirectAndNotFound(this.getMatch(matchId), e2);
                            try {
                              (_j = (_i = route.options).onError) == null || _j.call(_i, e2);
                            } catch (onErrorError) {
                              error = onErrorError, handleRedirectAndNotFound(
                                this.getMatch(matchId),
                                onErrorError
                              );
                            }
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error,
                              status: "error",
                              isFetching: !1
                            }));
                          }
                          (_k = this.serverSsr) == null || _k.onMatchSettled({
                            router: this,
                            match: this.getMatch(matchId)
                          }), await route._componentsPromise;
                        } catch (err) {
                          updateMatch(matchId, (prev) => ({
                            ...prev,
                            loaderPromise: void 0
                          })), handleRedirectAndNotFound(this.getMatch(matchId), err);
                        }
                      }, { status, invalid } = this.getMatch(matchId);
                      loaderShouldRunAsync = status === "success" && (invalid || (shouldReload ?? age > staleAge)), preload && route.options.preload === !1 || (loaderShouldRunAsync && !sync ? (loaderIsRunningAsync = !0, (async () => {
                        try {
                          await runLoader();
                          const { loaderPromise, loadPromise } = this.getMatch(matchId);
                          loaderPromise?.resolve(), loadPromise?.resolve(), updateMatch(matchId, (prev) => ({
                            ...prev,
                            loaderPromise: void 0
                          }));
                        } catch (err) {
                          isResolvedRedirect(err) && await this.navigate(err);
                        }
                      })()) : (status !== "success" || loaderShouldRunAsync && sync) && await runLoader());
                    }
                    if (!loaderIsRunningAsync) {
                      const { loaderPromise, loadPromise } = this.getMatch(matchId);
                      loaderPromise?.resolve(), loadPromise?.resolve();
                    }
                    return updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: loaderIsRunningAsync ? prev.isFetching : !1,
                      loaderPromise: loaderIsRunningAsync ? prev.loaderPromise : void 0,
                      invalid: !1
                    })), this.getMatch(matchId);
                  })()
                );
              }), await Promise.all(matchPromises), resolveAll();
            } catch (err) {
              rejectAll(err);
            }
          })();
        }), await triggerOnReady();
      } catch (err) {
        if (isRedirect(err) || isNotFound(err))
          throw isNotFound(err) && !allPreload && await triggerOnReady(), err;
      }
      return matches2;
    }, this.invalidate = (opts) => {
      const invalidate = (d) => {
        var _a;
        return ((_a = opts?.filter) == null ? void 0 : _a.call(opts, d)) ?? !0 ? {
          ...d,
          invalid: !0,
          ...d.status === "error" ? { status: "pending", error: void 0 } : {}
        } : d;
      };
      return this.__store.setState((s) => {
        var _a;
        return {
          ...s,
          matches: s.matches.map(invalidate),
          cachedMatches: s.cachedMatches.map(invalidate),
          pendingMatches: (_a = s.pendingMatches) == null ? void 0 : _a.map(invalidate)
        };
      }), this.load({ sync: opts?.sync });
    }, this.resolveRedirect = (err) => {
      const redirect2 = err;
      return redirect2.href || (redirect2.href = this.buildLocation(redirect2).href), redirect2;
    }, this.clearCache = (opts) => {
      const filter2 = opts?.filter;
      filter2 !== void 0 ? this.__store.setState((s) => ({
        ...s,
        cachedMatches: s.cachedMatches.filter(
          (m2) => !filter2(m2)
        )
      })) : this.__store.setState((s) => ({
        ...s,
        cachedMatches: []
      }));
    }, this.clearExpiredCache = () => {
      const filter2 = (d) => {
        const route = this.looseRoutesById[d.routeId];
        if (!route.options.loader)
          return !0;
        const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 300 * 1e3;
        return !(d.status !== "error" && Date.now() - d.updatedAt < gcTime);
      };
      this.clearCache({ filter: filter2 });
    }, this.loadRouteChunk = (route) => (route._lazyPromise === void 0 && (route.lazyFn ? route._lazyPromise = route.lazyFn().then((lazyRoute) => {
      const { id: _id, ...options2 } = lazyRoute.options;
      Object.assign(route.options, options2);
    }) : route._lazyPromise = Promise.resolve()), route._componentsPromise === void 0 && (route._componentsPromise = route._lazyPromise.then(
      () => Promise.all(
        componentTypes.map(async (type) => {
          const component = route.options[type];
          component?.preload && await component.preload();
        })
      )
    )), route._componentsPromise), this.preloadRoute = async (opts) => {
      const next = this.buildLocation(opts);
      let matches2 = this.matchRoutes(next, {
        throwOnError: !0,
        preload: !0,
        dest: opts
      });
      const activeMatchIds = new Set(
        [...this.state.matches, ...this.state.pendingMatches ?? []].map(
          (d) => d.id
        )
      ), loadedMatchIds = /* @__PURE__ */ new Set([
        ...activeMatchIds,
        ...this.state.cachedMatches.map((d) => d.id)
      ]);
      batch(() => {
        matches2.forEach((match) => {
          loadedMatchIds.has(match.id) || this.__store.setState((s) => ({
            ...s,
            cachedMatches: [...s.cachedMatches, match]
          }));
        });
      });
      try {
        return matches2 = await this.loadMatches({
          matches: matches2,
          location: next,
          preload: !0,
          updateMatch: (id2, updater) => {
            activeMatchIds.has(id2) ? matches2 = matches2.map((d) => d.id === id2 ? updater(d) : d) : this.updateMatch(id2, updater);
          }
        }), matches2;
      } catch (err) {
        if (isRedirect(err))
          return err.reloadDocument ? void 0 : await this.preloadRoute({
            ...err,
            _fromLocation: next
          });
        isNotFound(err) || console.error(err);
        return;
      }
    }, this.matchRoute = (location, opts) => {
      const matchLocation = {
        ...location,
        to: location.to ? this.resolvePathWithBase(
          location.from || "",
          location.to
        ) : void 0,
        params: location.params || {},
        leaveParams: !0
      }, next = this.buildLocation(matchLocation);
      if (opts?.pending && this.state.status !== "pending")
        return !1;
      const baseLocation = (opts?.pending === void 0 ? !this.state.isLoading : opts.pending) ? this.latestLocation : this.state.resolvedLocation || this.state.location, match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      return !match || location.params && !deepEqual$1(match, location.params, { partial: !0 }) ? !1 : match && (opts?.includeSearch ?? !0) ? deepEqual$1(baseLocation.search, next.search, { partial: !0 }) ? match : !1 : match;
    }, this._handleNotFound = (matches2, err, {
      updateMatch = this.updateMatch
    } = {}) => {
      var _a;
      const routeCursor = this.routesById[err.routeId ?? ""] ?? this.routeTree, matchesByRouteId = {};
      for (const match of matches2)
        matchesByRouteId[match.routeId] = match;
      !routeCursor.options.notFoundComponent && ((_a = this.options) != null && _a.defaultNotFoundComponent) && (routeCursor.options.notFoundComponent = this.options.defaultNotFoundComponent), invariant$1(
        routeCursor.options.notFoundComponent
      );
      const matchForRoute = matchesByRouteId[routeCursor.id];
      invariant$1(
        matchForRoute,
        "Could not find match for route: " + routeCursor.id
      ), updateMatch(matchForRoute.id, (prev) => ({
        ...prev,
        status: "notFound",
        error: err,
        isFetching: !1
      })), err.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute && (err.routeId = routeCursor.parentRoute.id, this._handleNotFound(matches2, err, {
        updateMatch
      }));
    }, this.hasNotFoundMatch = () => this.__store.state.matches.some(
      (d) => d.status === "notFound" || d.globalNotFound
    ), this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...options,
      caseSensitive: options.caseSensitive ?? !1,
      notFoundMode: options.notFoundMode ?? "fuzzy",
      stringifySearch: options.stringifySearch ?? defaultStringifySearch,
      parseSearch: options.parseSearch ?? defaultParseSearch
    }), typeof document < "u" && (window.__TSR_ROUTER__ = this);
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
  matchRoutesInternal(next, opts) {
    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(
      next,
      opts?.dest
    );
    let isGlobalNotFound = !1;
    // If we found a route, and it's not an index route and we have left over path
    (foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
      // Or if we didn't find a route and we have left over path
      trimPathRight(next.pathname)
    )) && (this.options.notFoundRoute ? matchedRoutes.push(this.options.notFoundRoute) : isGlobalNotFound = !0);
    const globalNotFoundRouteId = (() => {
      if (isGlobalNotFound) {
        if (this.options.notFoundMode !== "root")
          for (let i2 = matchedRoutes.length - 1; i2 >= 0; i2--) {
            const route = matchedRoutes[i2];
            if (route.children)
              return route.id;
          }
        return rootRouteId;
      }
    })(), parseErrors = matchedRoutes.map((route) => {
      var _a;
      let parsedParamsError;
      const parseParams = ((_a = route.options.params) == null ? void 0 : _a.parse) ?? route.options.parseParams;
      if (parseParams)
        try {
          const parsedParams = parseParams(routeParams);
          Object.assign(routeParams, parsedParams);
        } catch (err) {
          if (parsedParamsError = new PathParamError(err.message, {
            cause: err
          }), opts?.throwOnError)
            throw parsedParamsError;
          return parsedParamsError;
        }
    }), matches2 = [], getParentContext = (parentMatch) => parentMatch?.id ? parentMatch.context ?? this.options.context ?? {} : this.options.context ?? {};
    return matchedRoutes.forEach((route, index2) => {
      var _a, _b;
      const parentMatch = matches2[index2 - 1], [preMatchSearch, strictMatchSearch, searchError] = (() => {
        const parentSearch = parentMatch?.search ?? next.search, parentStrictSearch = parentMatch?._strictSearch ?? {};
        try {
          const strictSearch = validateSearch(route.options.validateSearch, { ...parentSearch }) ?? {};
          return [
            {
              ...parentSearch,
              ...strictSearch
            },
            { ...parentStrictSearch, ...strictSearch },
            void 0
          ];
        } catch (err) {
          let searchParamError = err;
          if (err instanceof SearchParamError || (searchParamError = new SearchParamError(err.message, {
            cause: err
          })), opts?.throwOnError)
            throw searchParamError;
          return [parentSearch, {}, searchParamError];
        }
      })(), loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {
        search: preMatchSearch
      })) ?? "", loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "", { usedParams, interpolatedPath } = interpolatePath({
        path: route.fullPath,
        params: routeParams,
        decodeCharMap: this.pathParamsDecodeCharMap
      }), matchId = interpolatePath({
        path: route.id,
        params: routeParams,
        leaveWildcards: !0,
        decodeCharMap: this.pathParamsDecodeCharMap
      }).interpolatedPath + loaderDepsHash, existingMatch = this.getMatch(matchId), previousMatch = this.state.matches.find(
        (d) => d.routeId === route.id
      ), cause = previousMatch ? "stay" : "enter";
      let match;
      if (existingMatch)
        match = {
          ...existingMatch,
          cause,
          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,
          _strictParams: usedParams,
          search: replaceEqualDeep(previousMatch ? previousMatch.search : existingMatch.search, preMatchSearch),
          _strictSearch: strictMatchSearch
        };
      else {
        const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? "pending" : "success";
        match = {
          id: matchId,
          index: index2,
          routeId: route.id,
          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,
          _strictParams: usedParams,
          pathname: joinPaths([this.basepath, interpolatedPath]),
          updatedAt: Date.now(),
          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : preMatchSearch,
          _strictSearch: strictMatchSearch,
          searchError: void 0,
          status,
          isFetching: !1,
          error: void 0,
          paramsError: parseErrors[index2],
          __routeContext: {},
          __beforeLoadContext: {},
          context: {},
          abortController: new AbortController(),
          fetchCount: 0,
          cause,
          loaderDeps: previousMatch ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps) : loaderDeps,
          invalid: !1,
          preload: !1,
          links: void 0,
          scripts: void 0,
          headScripts: void 0,
          meta: void 0,
          staticData: route.options.staticData || {},
          loadPromise: createControlledPromise(),
          fullPath: route.fullPath
        };
      }
      opts?.preload || (match.globalNotFound = globalNotFoundRouteId === route.id), match.searchError = searchError;
      const parentContext = getParentContext(parentMatch);
      match.context = {
        ...parentContext,
        ...match.__routeContext,
        ...match.__beforeLoadContext
      }, matches2.push(match);
    }), matches2.forEach((match, index2) => {
      var _a, _b, _c, _d, _e2, _f, _g, _h;
      const route = this.looseRoutesById[match.routeId];
      if (!this.getMatch(match.id) && opts?._buildLocation !== !0) {
        const parentMatch = matches2[index2 - 1], parentContext = getParentContext(parentMatch), contextFnContext = {
          deps: match.loaderDeps,
          params: match.params,
          context: parentContext,
          location: next,
          navigate: (opts2) => this.navigate({ ...opts2, _fromLocation: next }),
          buildLocation: this.buildLocation,
          cause: match.cause,
          abortController: match.abortController,
          preload: !!match.preload,
          matches: matches2
        };
        match.__routeContext = ((_b = (_a = route.options).context) == null ? void 0 : _b.call(_a, contextFnContext)) ?? {}, match.context = {
          ...parentContext,
          ...match.__routeContext,
          ...match.__beforeLoadContext
        };
      }
      if (match.status === "success") {
        match.headers = (_d = (_c = route.options).headers) == null ? void 0 : _d.call(_c, {
          loaderData: match.loaderData
        });
        const assetContext = {
          matches: matches2,
          match,
          params: match.params,
          loaderData: match.loaderData
        }, headFnContent = (_f = (_e2 = route.options).head) == null ? void 0 : _f.call(_e2, assetContext);
        match.links = headFnContent?.links, match.headScripts = headFnContent?.scripts, match.meta = headFnContent?.meta, match.scripts = (_h = (_g = route.options).scripts) == null ? void 0 : _h.call(_g, assetContext);
      }
    }), matches2;
  }
}
class SearchParamError extends Error {
}
class PathParamError extends Error {
}
function getInitialRouterState(location) {
  return {
    loadedAt: 0,
    isLoading: !1,
    isTransitioning: !1,
    status: "idle",
    resolvedLocation: void 0,
    location,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200
  };
}
function validateSearch(validateSearch2, input) {
  if (validateSearch2 == null) return {};
  if ("~standard" in validateSearch2) {
    const result = validateSearch2["~standard"].validate(input);
    if (result instanceof Promise)
      throw new SearchParamError("Async validation not supported");
    if (result.issues)
      throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), {
        cause: result
      });
    return result.value;
  }
  return "parse" in validateSearch2 ? validateSearch2.parse(input) : typeof validateSearch2 == "function" ? validateSearch2(input) : {};
}
const componentTypes = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent"
];
function routeNeedsPreload(route) {
  var _a;
  for (const componentType of componentTypes)
    if ((_a = route.options[componentType]) != null && _a.preload)
      return !0;
  return !1;
}
const preloadWarning = "Error preloading route! ";
class BaseRoute {
  constructor(options) {
    if (this.init = (opts) => {
      var _a, _b;
      this.originalIndex = opts.originalIndex;
      const options2 = this.options, isRoot = !options2?.path && !options2?.id;
      if (this.parentRoute = (_b = (_a = this.options).getParentRoute) == null ? void 0 : _b.call(_a), isRoot)
        this._path = rootRouteId;
      else if (!this.parentRoute)
        throw new Error(
          "Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance."
        );
      let path = isRoot ? rootRouteId : options2?.path;
      path && path !== "/" && (path = trimPathLeft(path));
      const customId = options2?.id || path;
      let id2 = isRoot ? rootRouteId : joinPaths([
        this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id,
        customId
      ]);
      path === rootRouteId && (path = "/"), id2 !== rootRouteId && (id2 = joinPaths(["/", id2]));
      const fullPath = id2 === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
      this._path = path, this._id = id2, this._fullPath = fullPath, this._to = fullPath, this._ssr = options2?.ssr ?? opts.defaultSsr ?? !0;
    }, this.addChildren = (children2) => this._addFileChildren(children2), this._addFileChildren = (children2) => (Array.isArray(children2) && (this.children = children2), typeof children2 == "object" && children2 !== null && (this.children = Object.values(children2)), this), this._addFileTypes = () => this, this.updateLoader = (options2) => (Object.assign(this.options, options2), this), this.update = (options2) => (Object.assign(this.options, options2), this), this.lazy = (lazyFn) => (this.lazyFn = lazyFn, this), this.options = options || {}, this.isRoot = !options?.getParentRoute, options?.id && options?.path)
      throw new Error("Route cannot have both an 'id' and a 'path' option.");
  }
  get to() {
    return this._to;
  }
  get id() {
    return this._id;
  }
  get path() {
    return this._path;
  }
  get fullPath() {
    return this._fullPath;
  }
  get ssr() {
    return this._ssr;
  }
}
class BaseRootRoute extends BaseRoute {
  constructor(options) {
    super(options);
  }
}
function stripSearchParams(input) {
  return ({ search, next }) => {
    if (input === !0)
      return {};
    const result = next(search);
    return Array.isArray(input) ? input.forEach((key) => {
      delete result[key];
    }) : Object.entries(input).forEach(
      ([key, value]) => {
        deepEqual$1(result[key], value) && delete result[key];
      }
    ), result;
  };
}
function CatchBoundary(props) {
  const errorComponent = props.errorComponent ?? ErrorComponent;
  return /* @__PURE__ */ jsx(
    CatchBoundaryImpl,
    {
      getResetKey: props.getResetKey,
      onCatch: props.onCatch,
      children: ({ error, reset }) => error ? React.createElement(errorComponent, {
        error,
        reset
      }) : props.children
    }
  );
}
class CatchBoundaryImpl extends React.Component {
  constructor() {
    super(...arguments), this.state = { error: null };
  }
  static getDerivedStateFromProps(props) {
    return { resetKey: props.getResetKey() };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  reset() {
    this.setState({ error: null });
  }
  componentDidUpdate(prevProps, prevState) {
    prevState.error && prevState.resetKey !== this.state.resetKey && this.reset();
  }
  componentDidCatch(error, errorInfo) {
    this.props.onCatch && this.props.onCatch(error, errorInfo);
  }
  render() {
    return this.props.children({
      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
      reset: () => {
        this.reset();
      }
    });
  }
}
function ErrorComponent({ error }) {
  const [show, setShow] = React.useState(!1);
  return /* @__PURE__ */ jsxs("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
    /* @__PURE__ */ jsxs("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
      /* @__PURE__ */ jsx("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
      /* @__PURE__ */ jsx(
        "button",
        {
          style: {
            appearance: "none",
            fontSize: ".6em",
            border: "1px solid currentColor",
            padding: ".1rem .2rem",
            fontWeight: "bold",
            borderRadius: ".25rem"
          },
          onClick: () => setShow((d) => !d),
          children: show ? "Hide Error" : "Show Error"
        }
      )
    ] }),
    /* @__PURE__ */ jsx("div", { style: { height: ".25rem" } }),
    show ? /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
      "pre",
      {
        style: {
          fontSize: ".7em",
          border: "1px solid red",
          borderRadius: ".25rem",
          padding: ".3rem",
          color: "red",
          overflow: "auto"
        },
        children: error.message ? /* @__PURE__ */ jsx("code", { children: error.message }) : null
      }
    ) }) : null
  ] });
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var withSelector = { exports: {} }, withSelector_production = {}, shim = { exports: {} }, useSyncExternalStoreShim_production = {};
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = React__default;
  function is2(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is2, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue2 = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState2({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    return useLayoutEffect2(
      function() {
        inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    ), useEffect2(
      function() {
        return checkIfSnapshotChanged(inst) && forceUpdate({ inst }), subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    ), useDebugValue2(value), value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch {
      return !0;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? useSyncExternalStore$1 : useSyncExternalStore$2;
  return useSyncExternalStoreShim_production.useSyncExternalStore = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim2, useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, shim.exports = requireUseSyncExternalStoreShim_production()), shim.exports;
}
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = React__default, shim2 = requireShim();
  function is2(x2, y2) {
    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = typeof Object.is == "function" ? Object.is : is2, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue2 = React2.useDebugValue;
  return withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector2, isEqual) {
    var instRef = useRef2(null);
    if (instRef.current === null) {
      var inst = { hasValue: !1, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo2(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector2(nextSnapshot), isEqual !== void 0 && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector2(nextSnapshot);
          return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector2, isEqual]
    );
    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
    return useEffect2(
      function() {
        inst.hasValue = !0, inst.value = value;
      },
      [value]
    ), useDebugValue2(value), value;
  }, withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  return hasRequiredWithSelector || (hasRequiredWithSelector = 1, withSelector.exports = requireWithSelector_production()), withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
function useStore$2(store, selector2 = (d) => d) {
  return withSelectorExports.useSyncExternalStoreWithSelector(
    store.subscribe,
    () => store.state,
    () => store.state,
    selector2,
    shallow
  );
}
function shallow(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return !1;
    for (const [k, v] of objA)
      if (!objB.has(k) || !Object.is(v, objB.get(k))) return !1;
    return !0;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return !1;
    for (const v of objA)
      if (!objB.has(v)) return !1;
    return !0;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (let i2 = 0; i2 < keysA.length; i2++)
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !Object.is(objA[keysA[i2]], objB[keysA[i2]]))
      return !1;
  return !0;
}
const routerContext = React.createContext(null);
function getRouterContext() {
  return typeof document > "u" ? routerContext : window.__TSR_ROUTER_CONTEXT__ ? window.__TSR_ROUTER_CONTEXT__ : (window.__TSR_ROUTER_CONTEXT__ = routerContext, routerContext);
}
function useRouter(opts) {
  const value = React.useContext(getRouterContext());
  return opts?.warn, value;
}
function useRouterState(opts) {
  const contextRouter = useRouter({
    warn: opts?.router === void 0
  }), router = opts?.router || contextRouter, previousResult = useRef(void 0);
  return useStore$2(router.__store, (state) => {
    if (opts?.select) {
      if (opts.structuralSharing ?? router.options.defaultStructuralSharing) {
        const newSlice = replaceEqualDeep(
          previousResult.current,
          opts.select(state)
        );
        return previousResult.current = newSlice, newSlice;
      }
      return opts.select(state);
    }
    return state;
  });
}
const matchContext = React.createContext(void 0), dummyMatchContext = React.createContext(
  void 0
);
function useMatch(opts) {
  const nearestMatchId = React.useContext(
    opts.from ? dummyMatchContext : matchContext
  );
  return useRouterState({
    select: (state) => {
      const match = state.matches.find(
        (d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId
      );
      if (invariant$1(
        !((opts.shouldThrow ?? !0) && !match),
        `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`
      ), match !== void 0)
        return opts.select ? opts.select(match) : match;
    },
    structuralSharing: opts.structuralSharing
  });
}
function useLoaderData(opts) {
  return useMatch({
    from: opts.from,
    strict: opts.strict,
    structuralSharing: opts.structuralSharing,
    select: (s) => opts.select ? opts.select(s.loaderData) : s.loaderData
  });
}
function useLoaderDeps(opts) {
  const { select: select2, ...rest } = opts;
  return useMatch({
    ...rest,
    select: (s) => select2 ? select2(s.loaderDeps) : s.loaderDeps
  });
}
function useParams(opts) {
  return useMatch({
    from: opts.from,
    strict: opts.strict,
    shouldThrow: opts.shouldThrow,
    structuralSharing: opts.structuralSharing,
    select: (match) => opts.select ? opts.select(match.params) : match.params
  });
}
function useSearch(opts) {
  return useMatch({
    from: opts.from,
    strict: opts.strict,
    shouldThrow: opts.shouldThrow,
    structuralSharing: opts.structuralSharing,
    select: (match) => opts.select ? opts.select(match.search) : match.search
  });
}
function useNavigate(_defaultOpts) {
  const { navigate } = useRouter();
  return React.useCallback(
    (options) => navigate({
      from: _defaultOpts?.from,
      ...options
    }),
    [_defaultOpts?.from, navigate]
  );
}
function Navigate(props) {
  const router = useRouter(), previousPropsRef = React.useRef(null);
  return React.useEffect(() => {
    previousPropsRef.current !== props && (router.navigate({
      ...props
    }), previousPropsRef.current = props);
  }, [router, props]), null;
}
class Route extends BaseRoute {
  /**
   * @deprecated Use the `createRoute` function instead.
   */
  constructor(options) {
    super(options), this.useMatch = (opts) => useMatch({
      select: opts?.select,
      from: this.id,
      structuralSharing: opts?.structuralSharing
    }), this.useRouteContext = (opts) => useMatch({
      ...opts,
      from: this.id,
      select: (d) => opts?.select ? opts.select(d.context) : d.context
    }), this.useSearch = (opts) => useSearch({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useParams = (opts) => useParams({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useLoaderDeps = (opts) => useLoaderDeps({ ...opts, from: this.id }), this.useLoaderData = (opts) => useLoaderData({ ...opts, from: this.id }), this.useNavigate = () => useNavigate({ from: this.fullPath }), this.$$typeof = /* @__PURE__ */ Symbol.for("react.memo");
  }
}
function createRoute(options) {
  return new Route(options);
}
function createRootRouteWithContext() {
  return (options) => createRootRoute(options);
}
class RootRoute extends BaseRootRoute {
  /**
   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
   */
  constructor(options) {
    super(options), this.useMatch = (opts) => useMatch({
      select: opts?.select,
      from: this.id,
      structuralSharing: opts?.structuralSharing
    }), this.useRouteContext = (opts) => useMatch({
      ...opts,
      from: this.id,
      select: (d) => opts?.select ? opts.select(d.context) : d.context
    }), this.useSearch = (opts) => useSearch({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useParams = (opts) => useParams({
      select: opts?.select,
      structuralSharing: opts?.structuralSharing,
      from: this.id
    }), this.useLoaderDeps = (opts) => useLoaderDeps({ ...opts, from: this.id }), this.useLoaderData = (opts) => useLoaderData({ ...opts, from: this.id }), this.useNavigate = () => useNavigate({ from: this.fullPath });
  }
}
function createRootRoute(options) {
  return new RootRoute(options);
}
function createFileRoute(path) {
  return new FileRoute(path, {
    silent: !0
  }).createRoute;
}
class FileRoute {
  constructor(path, _opts) {
    this.path = path, this.createRoute = (options) => {
      this.silent;
      const route = createRoute(options);
      return route.isRoot = !1, route;
    }, this.silent = _opts?.silent;
  }
}
function CatchNotFound(props) {
  const resetKey = useRouterState({
    select: (s) => `not-found-${s.location.pathname}-${s.status}`
  });
  return /* @__PURE__ */ jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      onCatch: (error, errorInfo) => {
        var _a;
        if (isNotFound(error))
          (_a = props.onCatch) == null || _a.call(props, error, errorInfo);
        else
          throw error;
      },
      errorComponent: ({ error }) => {
        var _a;
        if (isNotFound(error))
          return (_a = props.fallback) == null ? void 0 : _a.call(props, error);
        throw error;
      },
      children: props.children
    }
  );
}
function DefaultGlobalNotFound() {
  return /* @__PURE__ */ jsx("p", { children: "Not Found" });
}
function SafeFragment(props) {
  return /* @__PURE__ */ jsx(Fragment$1, { children: props.children });
}
function renderRouteNotFound(router, route, data) {
  return route.options.notFoundComponent ? /* @__PURE__ */ jsx(route.options.notFoundComponent, { data }) : router.options.defaultNotFoundComponent ? /* @__PURE__ */ jsx(router.options.defaultNotFoundComponent, { data }) : /* @__PURE__ */ jsx(DefaultGlobalNotFound, {});
}
var jsesc_1, hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  const object2 = {}, hasOwnProperty2 = object2.hasOwnProperty, forOwn = (object3, callback) => {
    for (const key in object3)
      hasOwnProperty2.call(object3, key) && callback(key, object3[key]);
  }, extend2 = (destination, source) => (source && forOwn(source, (key, value) => {
    destination[key] = value;
  }), destination), forEach = (array2, callback) => {
    const length = array2.length;
    let index2 = -1;
    for (; ++index2 < length; )
      callback(array2[index2]);
  }, fourHexEscape = (hex2) => "\\u" + ("0000" + hex2).slice(-4), hexadecimal = (code, lowercase2) => {
    let hexadecimal2 = code.toString(16);
    return lowercase2 ? hexadecimal2 : hexadecimal2.toUpperCase();
  }, toString2 = object2.toString, isArray2 = Array.isArray, isBuffer = (value) => typeof Buffer == "function" && Buffer.isBuffer(value), isObject2 = (value) => toString2.call(value) == "[object Object]", isString = (value) => typeof value == "string" || toString2.call(value) == "[object String]", isNumber2 = (value) => typeof value == "number" || toString2.call(value) == "[object Number]", isBigInt = (value) => typeof value == "bigint", isFunction2 = (value) => typeof value == "function", isMap2 = (value) => toString2.call(value) == "[object Map]", isSet2 = (value) => toString2.call(value) == "[object Set]", singleEscapes = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, regexSingleEscape = /[\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g, escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
    }, defaults = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, json2 = options && options.json;
    json2 && (defaults.quotes = "double", defaults.wrap = !0), options = extend2(defaults, options), options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick" && (options.quotes = "single");
    const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'", compact = options.compact, lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel), oldIndent = "";
    const inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact ? "" : `
`;
    let result, isEmpty = !0;
    const useBinNumbers = options.numbers == "binary", useOctNumbers = options.numbers == "octal", useDecNumbers = options.numbers == "decimal", useHexNumbers = options.numbers == "hexadecimal";
    if (json2 && argument && isFunction2(argument.toJSON) && (argument = argument.toJSON()), !isString(argument)) {
      if (isMap2(argument))
        return argument.size == 0 ? "new Map()" : (compact || (options.__inline1__ = !0, options.__inline2__ = !1), "new Map(" + jsesc(Array.from(argument), options) + ")");
      if (isSet2(argument))
        return argument.size == 0 ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
      if (isBuffer(argument))
        return argument.length == 0 ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      if (isArray2(argument))
        return result = [], options.wrap = !0, inline1 && (options.__inline1__ = !1, options.__inline2__ = !0), inline2 || increaseIndentation(), forEach(argument, (value) => {
          isEmpty = !1, inline2 && (options.__inline2__ = !1), result.push(
            (compact || inline2 ? "" : indent) + jsesc(value, options)
          );
        }), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
      if (isNumber2(argument) || isBigInt(argument)) {
        if (json2)
          return JSON.stringify(Number(argument));
        let result2;
        if (useDecNumbers)
          result2 = String(argument);
        else if (useHexNumbers) {
          let hexadecimal2 = argument.toString(16);
          lowercaseHex || (hexadecimal2 = hexadecimal2.toUpperCase()), result2 = "0x" + hexadecimal2;
        } else useBinNumbers ? result2 = "0b" + argument.toString(2) : useOctNumbers && (result2 = "0o" + argument.toString(8));
        return isBigInt(argument) ? result2 + "n" : result2;
      } else return isBigInt(argument) ? json2 ? JSON.stringify(Number(argument)) : argument + "n" : isObject2(argument) ? (result = [], options.wrap = !0, increaseIndentation(), forOwn(argument, (key, value) => {
        isEmpty = !1, result.push(
          (compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options)
        );
      }), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}") : json2 ? JSON.stringify(argument) || "null" : String(argument);
    }
    const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    return result = argument.replace(regex, (char, pair, lone, quoteChar, index2, string2) => {
      if (pair) {
        if (options.minimal) return pair;
        const first = pair.charCodeAt(0), second = pair.charCodeAt(1);
        if (options.es6) {
          const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
          return "\\u{" + hexadecimal(codePoint, lowercaseHex) + "}";
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone)
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      if (char == "\0" && !json2 && !regexDigit.test(string2.charAt(index2 + 1)))
        return "\\0";
      if (quoteChar)
        return quoteChar == quote || options.escapeEverything ? "\\" + quoteChar : quoteChar;
      if (regexSingleEscape.test(char))
        return singleEscapes[char];
      if (options.minimal && !regexWhitespace.test(char))
        return char;
      const hex2 = hexadecimal(char.charCodeAt(0), lowercaseHex);
      return json2 || hex2.length > 2 ? fourHexEscape(hex2) : "\\x" + ("00" + hex2).slice(-2);
    }), quote == "`" && (result = result.replace(/\$\{/g, "\\${")), options.isScriptContext && (result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--")), options.wrap && (result = quote + result + quote), result;
  };
  return jsesc.version = "3.0.2", jsesc_1 = jsesc, jsesc_1;
}
requireJsesc();
function ScriptOnce({
  children: children2,
  log: log2
}) {
  return typeof document < "u" ? null : /* @__PURE__ */ jsx(
    "script",
    {
      className: "tsr-once",
      dangerouslySetInnerHTML: {
        __html: [
          children2,
          "",
          'if (typeof __TSR_SSR__ !== "undefined") __TSR_SSR__.cleanScripts()'
        ].filter(Boolean).join(`
`)
      }
    }
  );
}
function ScrollRestoration() {
  const router = useRouter(), userKey = (router.options.getScrollRestorationKey || defaultGetScrollRestorationKey)(router.latestLocation), resolvedKey = userKey !== defaultGetScrollRestorationKey(router.latestLocation) ? userKey : null;
  return !router.isScrollRestoring || !router.isServer ? null : /* @__PURE__ */ jsx(
    ScriptOnce,
    {
      children: `(${restoreScroll.toString()})(${JSON.stringify(storageKey)},${JSON.stringify(resolvedKey)}, undefined, true)`,
      log: !1
    }
  );
}
const Match = React.memo(function({
  matchId
}) {
  var _a, _b;
  const router = useRouter(), routeId = useRouterState({
    select: (s) => {
      var _a2;
      return (_a2 = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  invariant$1(
    routeId
  );
  const route = router.routesById[routeId], PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent, pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null, routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent, routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch, routeNotFoundComponent = route.isRoot ? (
    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
    route.options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component)
  ) : route.options.notFoundComponent, ResolvedSuspenseBoundary = (
    // If we're on the root route, allow forcefully wrapping in suspense
    (!route.isRoot || route.options.wrapInSuspense) && (route.options.wrapInSuspense ?? PendingComponent ?? ((_b = route.options.errorComponent) == null ? void 0 : _b.preload)) ? React.Suspense : SafeFragment
  ), ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment, ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment, resetKey = useRouterState({
    select: (s) => s.loadedAt
  }), parentRouteId = useRouterState({
    select: (s) => {
      var _a2;
      const index2 = s.matches.findIndex((d) => d.id === matchId);
      return (_a2 = s.matches[index2 - 1]) == null ? void 0 : _a2.routeId;
    }
  });
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsx(
      ResolvedCatchBoundary,
      {
        getResetKey: () => resetKey,
        errorComponent: routeErrorComponent || ErrorComponent,
        onCatch: (error, errorInfo) => {
          if (isNotFound(error)) throw error;
          routeOnCatch?.(error, errorInfo);
        },
        children: /* @__PURE__ */ jsx(
          ResolvedNotFoundBoundary,
          {
            fallback: (error) => {
              if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot)
                throw error;
              return React.createElement(routeNotFoundComponent, error);
            },
            children: /* @__PURE__ */ jsx(MatchInner, { matchId })
          }
        )
      }
    ) }) }),
    parentRouteId === rootRouteId && router.options.scrollRestoration ? /* @__PURE__ */ jsxs(Fragment$1, { children: [
      /* @__PURE__ */ jsx(OnRendered, {}),
      /* @__PURE__ */ jsx(ScrollRestoration, {})
    ] }) : null
  ] });
});
function OnRendered() {
  var _a;
  const router = useRouter(), prevLocationRef = React.useRef(
    void 0
  );
  return /* @__PURE__ */ jsx(
    "script",
    {
      suppressHydrationWarning: !0,
      ref: (el) => {
        var _a2;
        el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== ((_a2 = router.state.resolvedLocation) == null ? void 0 : _a2.href)) && (router.emit({
          type: "onRendered",
          ...getLocationChangeInfo(router.state)
        }), prevLocationRef.current = router.state.resolvedLocation);
      }
    },
    (_a = router.state.resolvedLocation) == null ? void 0 : _a.state.key
  );
}
const MatchInner = React.memo(function({
  matchId
}) {
  var _a, _b, _c;
  const router = useRouter(), { match, key, routeId } = useRouterState({
    select: (s) => {
      const matchIndex = s.matches.findIndex((d) => d.id === matchId), match2 = s.matches[matchIndex], routeId2 = match2.routeId, remountFn = router.routesById[routeId2].options.remountDeps ?? router.options.defaultRemountDeps, remountDeps = remountFn?.({
        routeId: routeId2,
        loaderDeps: match2.loaderDeps,
        params: match2._strictParams,
        search: match2._strictSearch
      });
      return {
        key: remountDeps ? JSON.stringify(remountDeps) : void 0,
        routeId: routeId2,
        match: pick$1(match2, ["id", "status", "error"])
      };
    },
    structuralSharing: !0
  }), route = router.routesById[routeId], out = React.useMemo(() => {
    const Comp = route.options.component ?? router.options.defaultComponent;
    return Comp ? /* @__PURE__ */ jsx(Comp, {}, key) : /* @__PURE__ */ jsx(Outlet, {});
  }, [key, route.options.component, router.options.defaultComponent]), RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;
  if (match.status === "notFound")
    return invariant$1(isNotFound(match.error)), renderRouteNotFound(router, route, match.error);
  if (match.status === "redirected")
    throw invariant$1(isRedirect(match.error)), (_a = router.getMatch(match.id)) == null ? void 0 : _a.loadPromise;
  if (match.status === "error") {
    if (router.isServer)
      return /* @__PURE__ */ jsx(
        RouteErrorComponent,
        {
          error: match.error,
          reset: void 0,
          info: {
            componentStack: ""
          }
        }
      );
    throw match.error;
  }
  if (match.status === "pending") {
    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;
    if (pendingMinMs && !((_b = router.getMatch(match.id)) != null && _b.minPendingPromise) && !router.isServer) {
      const minPendingPromise = createControlledPromise();
      Promise.resolve().then(() => {
        router.updateMatch(match.id, (prev) => ({
          ...prev,
          minPendingPromise
        }));
      }), setTimeout(() => {
        minPendingPromise.resolve(), router.updateMatch(match.id, (prev) => ({
          ...prev,
          minPendingPromise: void 0
        }));
      }, pendingMinMs);
    }
    throw (_c = router.getMatch(match.id)) == null ? void 0 : _c.loadPromise;
  }
  return out;
}), Outlet = React.memo(function() {
  const router = useRouter(), matchId = React.useContext(matchContext), routeId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches.find((d) => d.id === matchId)) == null ? void 0 : _a.routeId;
    }
  }), route = router.routesById[routeId], parentGlobalNotFound = useRouterState({
    select: (s) => {
      const parentMatch = s.matches.find((d) => d.id === matchId);
      return invariant$1(
        parentMatch
      ), parentMatch.globalNotFound;
    }
  }), childMatchId = useRouterState({
    select: (s) => {
      var _a;
      const matches2 = s.matches, index2 = matches2.findIndex((d) => d.id === matchId);
      return (_a = matches2[index2 + 1]) == null ? void 0 : _a.id;
    }
  });
  if (parentGlobalNotFound)
    return renderRouteNotFound(router, route, void 0);
  if (!childMatchId)
    return null;
  const nextMatch = /* @__PURE__ */ jsx(Match, { matchId: childMatchId }), pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null;
  return matchId === rootRouteId ? /* @__PURE__ */ jsx(React.Suspense, { fallback: pendingElement, children: nextMatch }) : nextMatch;
}), useLayoutEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect;
function usePrevious(value) {
  const ref = React.useRef({
    value,
    prev: null
  }), current2 = ref.current.value;
  return value !== current2 && (ref.current = {
    value,
    prev: current2
  }), ref.current.prev;
}
function useIntersectionObserver(ref, callback, intersectionObserverOptions = {}, options = {}) {
  const isIntersectionObserverAvailable = React.useRef(
    typeof IntersectionObserver == "function"
  ), observerRef = React.useRef(null);
  return React.useEffect(() => {
    if (!(!ref.current || !isIntersectionObserverAvailable.current || options.disabled))
      return observerRef.current = new IntersectionObserver(([entry]) => {
        callback(entry);
      }, intersectionObserverOptions), observerRef.current.observe(ref.current), () => {
        var _a;
        (_a = observerRef.current) == null || _a.disconnect();
      };
  }, [callback, intersectionObserverOptions, options.disabled, ref]), observerRef.current;
}
function useForwardedRef(ref) {
  const innerRef = React.useRef(null);
  return React.useImperativeHandle(ref, () => innerRef.current, []), innerRef;
}
function Transitioner() {
  const router = useRouter(), mountLoadForRouter = React.useRef({ router, mounted: !1 }), isLoading = useRouterState({
    select: ({ isLoading: isLoading2 }) => isLoading2
  }), [isTransitioning, setIsTransitioning] = React.useState(!1), hasPendingMatches = useRouterState({
    select: (s) => s.matches.some((d) => d.status === "pending"),
    structuralSharing: !0
  }), previousIsLoading = usePrevious(isLoading), isAnyPending = isLoading || isTransitioning || hasPendingMatches, previousIsAnyPending = usePrevious(isAnyPending), isPagePending = isLoading || hasPendingMatches, previousIsPagePending = usePrevious(isPagePending);
  return router.isServer || (router.startTransition = (fn) => {
    setIsTransitioning(!0), React.startTransition(() => {
      fn(), setIsTransitioning(!1);
    });
  }), React.useEffect(() => {
    const unsub = router.history.subscribe(router.load), nextLocation = router.buildLocation({
      to: router.latestLocation.pathname,
      search: !0,
      params: !0,
      hash: !0,
      state: !0,
      _includeValidateSearch: !0
    });
    return trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href) && router.commitLocation({ ...nextLocation, replace: !0 }), () => {
      unsub();
    };
  }, [router, router.history]), useLayoutEffect(() => {
    if (typeof window < "u" && router.clientSsr || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted)
      return;
    mountLoadForRouter.current = { router, mounted: !0 }, (async () => {
      try {
        await router.load();
      } catch (err) {
        console.error(err);
      }
    })();
  }, [router]), useLayoutEffect(() => {
    previousIsLoading && !isLoading && router.emit({
      type: "onLoad",
      // When the new URL has committed, when the new matches have been loaded into state.matches
      ...getLocationChangeInfo(router.state)
    });
  }, [previousIsLoading, router, isLoading]), useLayoutEffect(() => {
    previousIsPagePending && !isPagePending && router.emit({
      type: "onBeforeRouteMount",
      ...getLocationChangeInfo(router.state)
    });
  }, [isPagePending, previousIsPagePending, router]), useLayoutEffect(() => {
    previousIsAnyPending && !isAnyPending && (router.emit({
      type: "onResolved",
      ...getLocationChangeInfo(router.state)
    }), router.__store.setState((s) => ({
      ...s,
      status: "idle",
      resolvedLocation: s.location
    })));
  }, [isAnyPending, previousIsAnyPending, router]), null;
}
function Matches() {
  const router = useRouter(), pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null, ResolvedSuspense = router.isServer || typeof document < "u" && router.clientSsr ? SafeFragment : React.Suspense, inner = /* @__PURE__ */ jsxs(ResolvedSuspense, { fallback: pendingElement, children: [
    /* @__PURE__ */ jsx(Transitioner, {}),
    /* @__PURE__ */ jsx(MatchesInner, {})
  ] });
  return router.options.InnerWrap ? /* @__PURE__ */ jsx(router.options.InnerWrap, { children: inner }) : inner;
}
function MatchesInner() {
  const matchId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = s.matches[0]) == null ? void 0 : _a.id;
    }
  }), resetKey = useRouterState({
    select: (s) => s.loadedAt
  });
  return /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: ErrorComponent,
      onCatch: (error) => {
        error.message || error.toString();
      },
      children: matchId ? /* @__PURE__ */ jsx(Match, { matchId }) : null
    }
  ) });
}
function useMatches(opts) {
  return useRouterState({
    select: (state) => {
      const matches2 = state.matches;
      return opts?.select ? opts.select(matches2) : matches2;
    },
    structuralSharing: opts?.structuralSharing
  });
}
function useParentMatches(opts) {
  const contextMatchId = React.useContext(matchContext);
  return useMatches({
    select: (matches2) => (matches2 = matches2.slice(
      0,
      matches2.findIndex((d) => d.id === contextMatchId)
    ), matches2),
    structuralSharing: void 0
  });
}
function useLinkProps(options, forwardedRef) {
  const router = useRouter(), [isTransitioning, setIsTransitioning] = React.useState(!1), hasRenderFetched = React.useRef(!1), innerRef = useForwardedRef(forwardedRef), {
    // custom props
    activeProps = () => ({ className: "active" }),
    inactiveProps = () => ({}),
    activeOptions,
    to,
    preload: userPreload,
    preloadDelay: userPreloadDelay,
    hashScrollIntoView,
    replace,
    startTransition,
    resetScroll,
    viewTransition,
    // element props
    children: children2,
    target,
    disabled,
    style: style2,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ignoreBlocker,
    ...rest
  } = options, {
    // prevent these from being returned
    params: _params,
    search: _search,
    hash: _hash,
    state: _state,
    mask: _mask,
    reloadDocument: _reloadDocument,
    ...propsSafeToSpread
  } = rest, type = React.useMemo(() => {
    try {
      return new URL(`${to}`), "external";
    } catch {
    }
    return "internal";
  }, [to]), currentSearch = useRouterState({
    select: (s) => s.location.search,
    structuralSharing: !0
  }), from = useMatches({
    select: (matches2) => {
      var _a;
      return options.from ?? ((_a = matches2[matches2.length - 1]) == null ? void 0 : _a.fullPath);
    }
  }), _options = React.useMemo(() => ({ ...options, from }), [options, from]), next = React.useMemo(
    () => router.buildLocation(_options),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [router, _options, currentSearch]
  ), preload = React.useMemo(() => _options.reloadDocument ? !1 : userPreload ?? router.options.defaultPreload, [router.options.defaultPreload, userPreload, _options.reloadDocument]), preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0, isActive = useRouterState({
    select: (s) => {
      if (activeOptions?.exact) {
        if (!exactPathTest(
          s.location.pathname,
          next.pathname,
          router.basepath
        ))
          return !1;
      } else {
        const currentPathSplit = removeTrailingSlash(
          s.location.pathname,
          router.basepath
        ).split("/");
        if (!removeTrailingSlash(
          next.pathname,
          router.basepath
        ).split("/").every(
          (d, i2) => d === currentPathSplit[i2]
        ))
          return !1;
      }
      return (activeOptions?.includeSearch ?? !0) && !deepEqual$1(s.location.search, next.search, {
        partial: !activeOptions?.exact,
        ignoreUndefined: !activeOptions?.explicitUndefined
      }) ? !1 : activeOptions?.includeHash ? s.location.hash === next.hash : !0;
    }
  }), doPreload = React.useCallback(() => {
    router.preloadRoute(_options).catch((err) => {
      console.warn(err), console.warn(preloadWarning);
    });
  }, [_options, router]), preloadViewportIoCallback = React.useCallback(
    (entry) => {
      entry?.isIntersecting && doPreload();
    },
    [doPreload]
  );
  if (useIntersectionObserver(
    innerRef,
    preloadViewportIoCallback,
    { rootMargin: "100px" },
    { disabled: !!disabled || preload !== "viewport" }
  ), useLayoutEffect(() => {
    hasRenderFetched.current || !disabled && preload === "render" && (doPreload(), hasRenderFetched.current = !0);
  }, [disabled, doPreload, preload]), type === "external")
    return {
      ...propsSafeToSpread,
      ref: innerRef,
      type,
      href: to,
      ...children2 && { children: children2 },
      ...target && { target },
      ...disabled && { disabled },
      ...style2 && { style: style2 },
      ...className && { className },
      ...onClick && { onClick },
      ...onFocus && { onFocus },
      ...onMouseEnter && { onMouseEnter },
      ...onMouseLeave && { onMouseLeave },
      ...onTouchStart && { onTouchStart }
    };
  const handleClick = (e2) => {
    if (!disabled && !isCtrlEvent(e2) && !e2.defaultPrevented && (!target || target === "_self") && e2.button === 0) {
      e2.preventDefault(), flushSync(() => {
        setIsTransitioning(!0);
      });
      const unsub = router.subscribe("onResolved", () => {
        unsub(), setIsTransitioning(!1);
      });
      return router.navigate({
        ..._options,
        replace,
        resetScroll,
        hashScrollIntoView,
        startTransition,
        viewTransition,
        ignoreBlocker
      });
    }
  }, handleFocus = (_2) => {
    disabled || preload && doPreload();
  }, handleTouchStart = handleFocus, handleEnter = (e2) => {
    if (disabled) return;
    const eventTarget = e2.target || {};
    if (preload) {
      if (eventTarget.preloadTimeout)
        return;
      eventTarget.preloadTimeout = setTimeout(() => {
        eventTarget.preloadTimeout = null, doPreload();
      }, preloadDelay);
    }
  }, handleLeave = (e2) => {
    if (disabled) return;
    const eventTarget = e2.target || {};
    eventTarget.preloadTimeout && (clearTimeout(eventTarget.preloadTimeout), eventTarget.preloadTimeout = null);
  }, composeHandlers = (handlers) => (e2) => {
    var _a;
    (_a = e2.persist) == null || _a.call(e2), handlers.filter(Boolean).forEach((handler) => {
      e2.defaultPrevented || handler(e2);
    });
  }, resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {}, resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}), resolvedClassName = [
    className,
    resolvedActiveProps.className,
    resolvedInactiveProps.className
  ].filter(Boolean).join(" "), resolvedStyle = {
    ...style2,
    ...resolvedActiveProps.style,
    ...resolvedInactiveProps.style
  };
  return {
    ...propsSafeToSpread,
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    href: disabled ? void 0 : next.maskedLocation ? router.history.createHref(next.maskedLocation.href) : router.history.createHref(next.href),
    ref: innerRef,
    onClick: composeHandlers([onClick, handleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    disabled: !!disabled,
    target,
    ...Object.keys(resolvedStyle).length && { style: resolvedStyle },
    ...resolvedClassName && { className: resolvedClassName },
    ...disabled && {
      role: "link",
      "aria-disabled": !0
    },
    ...isActive && { "data-status": "active", "aria-current": "page" },
    ...isTransitioning && { "data-transitioning": "transitioning" }
  };
}
const Link = React.forwardRef(
  (props, ref) => {
    const { _asChild, ...rest } = props, {
      type: _type,
      ref: innerRef,
      ...linkProps
    } = useLinkProps(rest, ref), children2 = typeof rest.children == "function" ? rest.children({
      isActive: linkProps["data-status"] === "active"
    }) : rest.children;
    return typeof _asChild > "u" && delete linkProps.disabled, React.createElement(
      _asChild || "a",
      {
        ...linkProps,
        ref: innerRef
      },
      children2
    );
  }
);
function isCtrlEvent(e2) {
  return !!(e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey);
}
const createRouter = (options) => new Router(options);
class Router extends RouterCore {
  constructor(options) {
    super(options);
  }
}
function RouterContextProvider({
  router,
  children: children2,
  ...rest
}) {
  router.update({
    ...router.options,
    ...rest,
    context: {
      ...router.options.context,
      ...rest.context
    }
  });
  const routerContext2 = getRouterContext(), provider = /* @__PURE__ */ jsx(routerContext2.Provider, { value: router, children: children2 });
  return router.options.Wrap ? /* @__PURE__ */ jsx(router.options.Wrap, { children: provider }) : provider;
}
function RouterProvider({ router, ...rest }) {
  return /* @__PURE__ */ jsx(RouterContextProvider, { router, ...rest, children: /* @__PURE__ */ jsx(Matches, {}) });
}
function e$i(e2, t2, n2) {
  let r2 = (n3) => e2(n3, ...t2);
  return n2 === void 0 ? r2 : Object.assign(r2, { lazy: n2, lazyArgs: t2 });
}
function t$x(t2, n2, r2) {
  let i2 = t2.length - n2.length;
  if (i2 === 0) return t2(...n2);
  if (i2 === 1) return e$i(t2, n2, r2);
  throw Error("Wrong number of arguments");
}
const e$h = (e2) => (n2, r2) => {
  if (r2 === 0) return e2(n2);
  if (!Number.isInteger(r2)) throw TypeError(`precision must be an integer: ${r2.toString()}`);
  if (r2 > 15 || r2 < -15) throw RangeError("precision must be between -15 and 15");
  if (Number.isNaN(n2) || !Number.isFinite(n2)) return e2(n2);
  let i2 = t$w(n2, r2), a2 = e2(i2);
  return t$w(a2, -r2);
};
function t$w(e2, t2) {
  let [n2, r2] = e2.toString().split("e"), i2 = (r2 === void 0 ? 0 : Number.parseInt(r2, 10)) + t2, a2 = `${n2}e${i2.toString()}`;
  return Number.parseFloat(a2);
}
function n$v(...n2) {
  return t$x(e$h(Math.ceil), n2);
}
function t$v(...t2) {
  return t$x(n$u, t2);
}
const n$u = (e2, { min: t2, max: n2 }) => t2 !== void 0 && e2 < t2 ? t2 : n2 !== void 0 && e2 > n2 ? n2 : e2;
function t$u(...t2) {
  return t$x(n$t, t2);
}
const n$t = (e2, t2) => [...e2, ...t2], t$t = { done: !1, hasNext: !1 }, r$e = (e2) => ({ hasNext: !0, next: e2, done: !1 });
function t$s(e2, ...t2) {
  let a2 = e2, o = t2.map((e3) => "lazy" in e3 ? r$d(e3) : void 0), s = 0;
  for (; s < t2.length; ) {
    if (o[s] === void 0 || !i$7(a2)) {
      let e4 = t2[s];
      a2 = e4(a2), s += 1;
      continue;
    }
    let e3 = [];
    for (let n2 = s; n2 < t2.length; n2++) {
      let t3 = o[n2];
      if (t3 === void 0 || (e3.push(t3), t3.isSingle)) break;
    }
    let r2 = [];
    for (let t3 of a2) if (n$s(t3, r2, e3)) break;
    let { isSingle: c } = e3.at(-1);
    a2 = c ? r2[0] : r2, s += e3.length;
  }
  return a2;
}
function n$s(t2, r2, i2) {
  if (i2.length === 0) return r2.push(t2), !1;
  let a2 = t2, o = t$t, s = !1;
  for (let [e2, t3] of i2.entries()) {
    let { index: c, items: l } = t3;
    if (l.push(a2), o = t3(a2, c, l), t3.index += 1, o.hasNext) {
      if (o.hasMany ?? !1) {
        for (let t4 of o.next) if (n$s(t4, r2, i2.slice(e2 + 1))) return !0;
        return s;
      }
      a2 = o.next;
    }
    if (!o.hasNext) break;
    o.done && (s = !0);
  }
  return o.hasNext && r2.push(a2), s;
}
function r$d(e2) {
  let { lazy: t2, lazyArgs: n2 } = e2, r2 = t2(...n2);
  return Object.assign(r2, { isSingle: t2.single ?? !1, index: 0, items: [] });
}
function i$7(e2) {
  return typeof e2 == "string" || typeof e2 == "object" && !!e2 && Symbol.iterator in e2;
}
function t$r(t2, n2) {
  let r2 = n2.length - t2.length;
  if (r2 === 1) {
    let [r3, ...i2] = n2;
    return t$s(r3, { lazy: t2, lazyArgs: i2 });
  }
  if (r2 === 0) {
    let r3 = { lazy: t2, lazyArgs: n2 };
    return Object.assign((t3) => t$s(t3, r3), r3);
  }
  throw Error("Wrong number of arguments");
}
function r$c(...e2) {
  return t$r(i$6, e2);
}
function i$6(n2) {
  if (n2.length === 0) return r$e;
  let r2 = /* @__PURE__ */ new Map();
  for (let e2 of n2) r2.set(e2, (r2.get(e2) ?? 0) + 1);
  return (t2) => {
    let n3 = r2.get(t2);
    return n3 === void 0 || n3 === 0 ? { done: !1, hasNext: !0, next: t2 } : (r2.set(t2, n3 - 1), t$t);
  };
}
function t$q(...t2) {
  return t$x(n$r, t2);
}
const n$r = (e2, t2) => e2.length >= t2, e$g = { asc: (e2, t2) => e2 > t2, desc: (e2, t2) => e2 < t2 };
function t$p(e2, t2) {
  let [n2, ...a2] = t2;
  if (!i$5(n2)) {
    let t3 = r$b(...a2);
    return e2(n2, t3);
  }
  let o = r$b(n2, ...a2);
  return (t3) => e2(t3, o);
}
function r$b(t2, n2, ...i2) {
  let a2 = typeof t2 == "function" ? t2 : t2[0], o = typeof t2 == "function" ? "asc" : t2[1], { [o]: s } = e$g, c = n2 === void 0 ? void 0 : r$b(n2, ...i2);
  return (e2, t3) => {
    let n3 = a2(e2), r2 = a2(t3);
    return s(n3, r2) ? 1 : s(r2, n3) ? -1 : c?.(e2, t3) ?? 0;
  };
}
function i$5(t2) {
  if (a$3(t2)) return !0;
  if (typeof t2 != "object" || !Array.isArray(t2)) return !1;
  let [n2, r2, ...i2] = t2;
  return a$3(n2) && typeof r2 == "string" && r2 in e$g && i2.length === 0;
}
const a$3 = (e2) => typeof e2 == "function" && e2.length === 1;
function t$o(...t2) {
  return t$x(Object.entries, t2);
}
function n$q(...t2) {
  return t$x(r$a, t2, i$4);
}
const r$a = (e2, t2) => e2.filter(t2), i$4 = (e2) => (n2, r2, i2) => e2(n2, r2, i2) ? { done: !1, hasNext: !0, next: n2 } : t$t, e$f = (e2) => Object.assign(e2, { single: !0 });
function r$9(...t2) {
  return t$x(i$3, t2, e$f(a$2));
}
const i$3 = (e2, t2) => e2.find(t2), a$2 = (e2) => (n2, r2, i2) => e2(n2, r2, i2) ? { done: !0, hasNext: !0, next: n2 } : t$t;
function n$p(...n2) {
  return t$x(r$8, n2, e$f(i$2));
}
const r$8 = ([e2]) => e2, i$2 = () => a$1, a$1 = (e2) => ({ hasNext: !0, next: e2, done: !0 });
function t$n(...t2) {
  return t$x(n$o, t2, r$7);
}
const n$o = (e2, t2) => e2.flatMap(t2), r$7 = (e2) => (t2, n2, r2) => {
  let i2 = e2(t2, n2, r2);
  return Array.isArray(i2) ? { done: !1, hasNext: !0, hasMany: !0, next: i2 } : { done: !1, hasNext: !0, next: i2 };
};
function t$m(...t2) {
  return t$x(n$n, t2);
}
function n$n(e2, t2) {
  for (let [n2, r2] of Object.entries(e2)) t2(r2, n2, e2);
  return e2;
}
function t$l(...t2) {
  return t$x(n$m, t2);
}
const n$m = (e2, t2) => {
  let n2 = /* @__PURE__ */ Object.create(null);
  for (let r2 = 0; r2 < e2.length; r2++) {
    let i2 = e2[r2], a2 = t2(i2, r2, e2);
    if (a2 !== void 0) {
      let e3 = n2[a2];
      e3 === void 0 ? n2[a2] = [i2] : e3.push(i2);
    }
  }
  return Object.setPrototypeOf(n2, Object.prototype), n2;
};
function t$k(...t2) {
  return t$x(n$l, t2);
}
function n$l(e2, t2) {
  if (e2 === t2 || Object.is(e2, t2)) return !0;
  if (typeof e2 != "object" || typeof t2 != "object" || e2 === null || t2 === null || Object.getPrototypeOf(e2) !== Object.getPrototypeOf(t2)) return !1;
  if (Array.isArray(e2)) return r$6(e2, t2);
  if (e2 instanceof Map) return i$1(e2, t2);
  if (e2 instanceof Set) return a(e2, t2);
  if (e2 instanceof Date) return e2.getTime() === t2.getTime();
  if (e2 instanceof RegExp) return e2.toString() === t2.toString();
  if (Object.keys(e2).length !== Object.keys(t2).length) return !1;
  for (let [r2, i2] of Object.entries(e2)) if (!(r2 in t2) || !n$l(i2, t2[r2])) return !1;
  return !0;
}
function r$6(e2, t2) {
  if (e2.length !== t2.length) return !1;
  for (let [r2, i2] of e2.entries()) if (!n$l(i2, t2[r2])) return !1;
  return !0;
}
function i$1(e2, t2) {
  if (e2.size !== t2.size) return !1;
  for (let [r2, i2] of e2.entries()) if (!t2.has(r2) || !n$l(i2, t2.get(r2))) return !1;
  return !0;
}
function a(e2, t2) {
  if (e2.size !== t2.size) return !1;
  let r2 = [...t2];
  for (let t3 of e2) {
    let e3 = !1;
    for (let [i2, a2] of r2.entries()) if (n$l(t3, a2)) {
      e3 = !0, r2.splice(i2, 1);
      break;
    }
    if (!e3) return !1;
  }
  return !0;
}
function n$k(...t2) {
  return t$x(r$5, t2);
}
function r$5(e2, n2) {
  for (let [r2, i2] of Object.entries(n2)) if (!Object.hasOwn(e2, r2) || !t$k(i2, e2[r2])) return !1;
  return !0;
}
function e$e(e2) {
  return Array.isArray(e2);
}
function e$d(e2) {
  return typeof e2 == "boolean";
}
function e$c(e2) {
  return e2 !== void 0;
}
function e$b(e2) {
  return e2 === "" || e2 === void 0 ? !0 : Array.isArray(e2) ? e2.length === 0 : Object.keys(e2).length === 0;
}
const e$a = (e2) => typeof e2 == "function";
function e$9(e2) {
  return e2 !== null;
}
function e$8(e2) {
  return e2 != null;
}
function e$7(e2) {
  return (t2) => !e2(t2);
}
function e$6(e2) {
  return e2 == null;
}
function e$5(e2) {
  return typeof e2 == "number" && !Number.isNaN(e2);
}
function e$4(e2) {
  if (typeof e2 != "object" || !e2) return !1;
  let t2 = Object.getPrototypeOf(e2);
  return t2 === null || t2 === Object.prototype;
}
function t$j(...t2) {
  return t$x(n$j, t2);
}
function n$j(e2, t2) {
  if (e2 === t2 || Object.is(e2, t2)) return !0;
  if (typeof e2 != "object" || !e2 || typeof t2 != "object" || !t2) return !1;
  if (e2 instanceof Map && t2 instanceof Map) return r$4(e2, t2);
  if (e2 instanceof Set && t2 instanceof Set) return i(e2, t2);
  let n2 = Object.keys(e2);
  if (n2.length !== Object.keys(t2).length) return !1;
  for (let r2 of n2) {
    if (!Object.hasOwn(t2, r2)) return !1;
    let { [r2]: n3 } = e2, { [r2]: i2 } = t2;
    if (n3 !== i2 || !Object.is(n3, i2)) return !1;
  }
  return !0;
}
function r$4(e2, t2) {
  if (e2.size !== t2.size) return !1;
  for (let [n2, r2] of e2) {
    let e3 = t2.get(n2);
    if (r2 !== e3 || !Object.is(r2, e3)) return !1;
  }
  return !0;
}
function i(e2, t2) {
  if (e2.size !== t2.size) return !1;
  for (let n2 of e2) if (!t2.has(n2)) return !1;
  return !0;
}
function e$3(e2) {
  return typeof e2 == "string";
}
function e$2(e2) {
  return !!e2;
}
function t$i(...t2) {
  return t$x(n$i, t2);
}
const n$i = (e2, t2) => e2.join(t2);
function t$h(...t2) {
  return t$x(Object.keys, t2);
}
function t$g(...t2) {
  return t$x(n$h, t2);
}
const n$h = (e2) => e2.at(-1);
function t$f(...t2) {
  return t$x(n$g, t2, r$3);
}
const n$g = (e2, t2) => e2.map(t2), r$3 = (e2) => (t2, n2, r2) => ({ done: !1, hasNext: !0, next: e2(t2, n2, r2) });
function t$e(...t2) {
  return t$x(n$f, t2);
}
function n$f(e2, t2) {
  let n2 = {};
  for (let [r2, i2] of e2.entries()) {
    let [a2, o] = t2(i2, r2, e2);
    n2[a2] = o;
  }
  return n2;
}
function t$d(...t2) {
  return t$x(n$e, t2);
}
function n$e(e2, t2) {
  let n2 = {};
  for (let [r2, i2] of Object.entries(e2)) n2[r2] = t2(i2, r2, e2);
  return n2;
}
function n$d(...t2) {
  return t$x(r$2, t2);
}
function r$2(e2, n2) {
  let i2 = { ...e2, ...n2 };
  for (let a2 in n2) {
    if (!(a2 in e2)) continue;
    let { [a2]: o } = e2;
    if (!e$4(o)) continue;
    let { [a2]: s } = n2;
    e$4(s) && (i2[a2] = r$2(o, s));
  }
  return i2;
}
function n$c(...t2) {
  return t$x(r$1, t2);
}
function r$1(e2, n2) {
  if (!t$q(n2, 1)) return { ...e2 };
  if (!t$q(n2, 2)) {
    let { [n2[0]]: t2, ...r3 } = e2;
    return r3;
  }
  let r2 = { ...e2 };
  for (let e3 of n2) delete r2[e3];
  return r2;
}
function t$c(...t2) {
  return t$x(n$b, t2);
}
function n$b(e2, t2) {
  let n2 = { ...e2 };
  for (let [r2, i2] of Object.entries(n2)) t2(i2, r2, e2) && delete n2[r2];
  return n2;
}
function t$b(...t2) {
  return t$x(n$a, t2);
}
const n$a = (e2) => e2.length === 1 ? e2[0] : void 0;
function t$a(...t2) {
  return t$x(n$9, t2);
}
const n$9 = (e2, t2) => {
  let n2 = [[], []];
  for (let [r2, i2] of e2.entries()) t2(i2, r2, e2) ? n2[0].push(i2) : n2[1].push(i2);
  return n2;
};
function t$9(...t2) {
  return t$x(n$8, t2);
}
function n$8(e2, t2) {
  let n2 = {};
  for (let r2 of t2) r2 in e2 && (n2[r2] = e2[r2]);
  return n2;
}
function t$8(...t2) {
  return t$x(n$7, t2);
}
function n$7(e2, t2) {
  let n2 = {};
  for (let [r2, i2] of Object.entries(e2)) t2(i2, r2, e2) && (n2[r2] = i2);
  return n2;
}
function e$1(e2, ...n2) {
  return typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "symbol" ? (r2) => t$7(r2, e2, ...n2) : t$7(e2, ...n2);
}
function t$7(e2, ...t2) {
  let n2 = e2;
  for (let e3 of t2) {
    if (n2 == null) return;
    n2 = n2[e3];
  }
  return n2;
}
function e(e2, t2) {
  let n2 = Math.ceil(e2), r2 = Math.floor(t2);
  if (r2 < n2) throw RangeError(`randomInteger: The range [${e2.toString()},${t2.toString()}] contains no integer`);
  return Math.floor(Math.random() * (r2 - n2 + 1) + n2);
}
function t$6(...t2) {
  return t$x(n$6, t2);
}
function n$6(e2, t2) {
  let n2 = [];
  for (let r2 = e2; r2 < t2; r2++) n2.push(r2);
  return n2;
}
function t$5(...t2) {
  return t$x(n$5, t2);
}
const n$5 = (e2, t2, n2) => e2.reduce(t2, n2);
function t$4(...t2) {
  return t$x(n$4, t2);
}
function n$4(e2) {
  return [...e2].reverse();
}
function t$3(...t2) {
  return t$x(n$3, t2);
}
function n$3(e2, t2) {
  let n2 = [...e2];
  return n2.sort(t2), n2;
}
function t$2(...t2) {
  return t$p(n$2, t2);
}
const n$2 = (e2, t2) => [...e2].sort(t2);
function t$1(...t2) {
  return t$x(n$1, t2);
}
function n$1(e2, t2) {
  return t2(e2), e2;
}
function n(...e2) {
  return t$r(r, e2);
}
function r() {
  let t2 = /* @__PURE__ */ new Set();
  return (n2) => t2.has(n2) ? t$t : (t2.add(n2), { done: !1, hasNext: !0, next: n2 });
}
function useSyncedRef(value) {
  const ref = useRef(value);
  return ref.current = value, useMemo(() => Object.freeze({
    get current() {
      return ref.current;
    }
  }), []);
}
function useUnmountEffect(effect) {
  const effectRef = useSyncedRef(effect);
  useEffect(
    () => () => {
      effectRef.current();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
}
function useDebouncedCallback(callback, deps, delay2, maxWait = 0) {
  const timeout2 = useRef(void 0), waitTimeout = useRef(void 0), cb = useRef(callback), lastCall = useRef(void 0), clear = () => {
    timeout2.current && (clearTimeout(timeout2.current), timeout2.current = void 0), waitTimeout.current && (clearTimeout(waitTimeout.current), waitTimeout.current = void 0);
  };
  return useUnmountEffect(clear), useEffect(() => {
    cb.current = callback;
  }, deps), useMemo(() => {
    const execute = () => {
      if (clear(), !lastCall.current)
        return;
      const context = lastCall.current;
      lastCall.current = void 0, cb.current.apply(context.this, context.args);
    }, wrapped = function(...args) {
      timeout2.current && clearTimeout(timeout2.current), lastCall.current = { args, this: this }, timeout2.current = setTimeout(execute, delay2), maxWait > 0 && !waitTimeout.current && (waitTimeout.current = setTimeout(execute, maxWait));
    };
    return Object.defineProperties(wrapped, {
      length: { value: callback.length },
      name: { value: `${callback.name || "anonymous"}__debounced__${delay2}` }
    }), wrapped;
  }, [delay2, maxWait, ...deps]);
}
const noop$2 = () => {
}, isBrowser$1 = typeof globalThis < "u" && typeof navigator < "u" && typeof document < "u";
function useRafCallback(cb) {
  const cbRef = useSyncedRef(cb), frame2 = useRef(0), cancel2 = useCallback(() => {
    isBrowser$1 && frame2.current && (cancelAnimationFrame(frame2.current), frame2.current = 0);
  }, []);
  return useUnmountEffect(cancel2), [
    useMemo(() => {
      const wrapped = (...args) => {
        isBrowser$1 && (cancel2(), frame2.current = requestAnimationFrame(() => {
          cbRef.current(...args), frame2.current = 0;
        }));
      };
      return Object.defineProperties(wrapped, {
        length: { value: cb.length },
        name: { value: `${cb.name || "anonymous"}__raf` }
      }), wrapped;
    }, []),
    cancel2
  ];
}
const basicDepsComparator = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i2, element] of d1.entries())
    if (element !== d2[i2])
      return !1;
  return !0;
};
function useCustomCompareEffect(callback, deps, comparator = basicDepsComparator, effectHook = useEffect, ...effectHookRestArgs) {
  const dependencies = useRef(void 0);
  (dependencies.current === void 0 || isBrowser$1 && !comparator(dependencies.current, deps)) && (dependencies.current = deps), effectHook(callback, dependencies.current, ...effectHookRestArgs);
}
function useFirstMountState() {
  const isFirstMount = useRef(!0);
  return useEffect(() => {
    isFirstMount.current = !1;
  }, []), isFirstMount.current;
}
const useIsomorphicLayoutEffect$2 = isBrowser$1 ? useLayoutEffect$1 : useEffect;
function useMountEffect(effect) {
  useEffect(() => {
    effect();
  }, []);
}
function useRafEffect(callback, deps) {
  const [rafCallback, cancelRaf] = useRafCallback(callback);
  useEffect(
    () => (rafCallback(), cancelRaf),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
}
const stateChanger = (state) => (state + 1) % Number.MAX_SAFE_INTEGER;
function useRerender() {
  const [, setState] = useState(0);
  return useCallback(() => {
    setState(stateChanger);
  }, []);
}
function useUpdateEffect(effect, deps) {
  const isFirstMount = useFirstMountState();
  useEffect(isFirstMount ? noop$2 : effect, deps);
}
const cancelTimeout = (id2) => {
  id2 && clearTimeout(id2);
};
function useTimeoutEffect(callback, ms) {
  const cbRef = useSyncedRef(callback), msRef = useSyncedRef(ms), timeoutIdRef = useRef(null), cancel2 = useCallback(() => {
    cancelTimeout(timeoutIdRef.current);
  }, []), reset = useCallback(() => {
    msRef.current !== void 0 && (cancel2(), timeoutIdRef.current = setTimeout(() => {
      cbRef.current();
    }, msRef.current));
  }, []);
  return useEffect(() => (reset(), cancel2), [ms]), [cancel2, reset];
}
const useCustomCompareMemo = (factory2, deps, comparator) => {
  const dependencies = useRef(void 0);
  return (dependencies.current === void 0 || !comparator(dependencies.current, deps)) && (dependencies.current = deps), useMemo(factory2, dependencies.current);
};
function useAsync(asyncFn, initialValue) {
  const [state, setState] = useState({
    status: "not-executed",
    error: void 0,
    result: initialValue
  }), promiseRef = useRef(void 0), argsRef = useRef(void 0), methods = useSyncedRef({
    async execute(...params) {
      argsRef.current = params;
      const promise = asyncFn(...params);
      return promiseRef.current = promise, setState((s) => ({ ...s, status: "loading" })), promise.then(
        (result) => {
          promise === promiseRef.current && setState((s) => ({ ...s, status: "success", error: void 0, result }));
        },
        // eslint-disable-next-line @typescript-eslint/use-unknown-in-catch-callback-variable
        (error) => {
          promise === promiseRef.current && setState((previousState) => ({ ...previousState, status: "error", error }));
        }
      ), promise;
    },
    reset() {
      setState({
        status: "not-executed",
        error: void 0,
        result: initialValue
      }), promiseRef.current = void 0, argsRef.current = void 0;
    }
  });
  return [
    state,
    useMemo(
      () => ({
        reset() {
          methods.current.reset();
        },
        execute: async (...params) => methods.current.execute(...params)
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    ),
    { promise: promiseRef.current, lastArgs: argsRef.current }
  ];
}
function cc(names) {
  if (typeof names == "string" || typeof names == "number") return "" + names;
  let out = "";
  if (Array.isArray(names))
    for (let i2 = 0, tmp; i2 < names.length; i2++)
      (tmp = cc(names[i2])) !== "" && (out += (out && " ") + tmp);
  else
    for (let k in names)
      names[k] && (out += (out && " ") + k);
  return out;
}
var noop$1 = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T2 = parseTypenames$1(typename + "", _2), t2, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      for (; ++i2 < n2; ) if ((t2 = (typename = T2[i2]).type) && (t2 = get$2(_2[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback != "function") throw new Error("invalid callback: " + callback);
    for (; ++i2 < n2; )
      if (t2 = (typename = T2[i2]).type) _2[t2] = set$2(_2[t2], typename.name, callback);
      else if (callback == null) for (t2 in _2) _2[t2] = set$2(_2[t2], typename.name, null);
    return this;
  },
  copy: function() {
    var copy = {}, _2 = this._;
    for (var t2 in _2) copy[t2] = _2[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  }
};
function get$2(type, name) {
  for (var i2 = 0, n2 = type.length, c; i2 < n2; ++i2)
    if ((c = type[i2]).name === name)
      return c.value;
}
function set$2(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2)
    if (type[i2].name === name) {
      type[i2] = noop$1, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  return callback != null && type.push({ name, value: callback }), type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix2 = name += "", i2 = prefix2.indexOf(":");
  return i2 >= 0 && (prefix2 = name.slice(0, i2)) !== "xmlns" && (name = name.slice(i2 + 1)), namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector$4(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  typeof select2 != "function" && (select2 = selector$4(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group)) && ("__data__" in node && (subnode.__data__ = node.__data__), subgroup[i2] = subnode);
  return new Selection$1(subgroups, this._parents);
}
function array$2(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array$2(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  typeof select2 == "function" ? select2 = arrayAll(select2) : select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && (subgroups.push(select2.call(node, node.__data__, i2, group)), parents.push(node));
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match == "function" ? match : childMatcher(match)));
}
var filter$1 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter$1.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match == "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && match.call(node, node.__data__, i2, group) && subgroup.push(node);
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument, this.namespaceURI = parent.namespaceURI, this._next = null, this._parent = parent, this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  for (var i2 = 0, node, groupLength = group.length, dataLength = data.length; i2 < dataLength; ++i2)
    (node = group[i2]) ? (node.__data__ = data[i2], update[i2] = node) : enter[i2] = new EnterNode(parent, data[i2]);
  for (; i2 < groupLength; ++i2)
    (node = group[i2]) && (exit[i2] = node);
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2)
    (node = group[i2]) && (keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "", nodeByKeyValue.has(keyValue) ? exit[i2] = node : nodeByKeyValue.set(keyValue, node));
  for (i2 = 0; i2 < dataLength; ++i2)
    keyValue = key.call(parent, data[i2], i2, data) + "", (node = nodeByKeyValue.get(keyValue)) ? (update[i2] = node, node.__data__ = data[i2], nodeByKeyValue.delete(keyValue)) : enter[i2] = new EnterNode(parent, data[i2]);
  for (i2 = 0; i2 < groupLength; ++i2)
    (node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node && (exit[i2] = node);
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  typeof value != "function" && (value = constant$4(value));
  for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0)
      if (previous = enterGroup[i0]) {
        for (i0 >= i1 && (i1 = i0 + 1); !(next = updateGroup[i1]) && ++i1 < dataLength; ) ;
        previous._next = next || null;
      }
  }
  return update = new Selection$1(update, parents), update._enter = enter, update._exit = exit, update;
}
function arraylike(data) {
  return typeof data == "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  return typeof onenter == "function" ? (enter = onenter(enter), enter && (enter = enter.selection())) : enter = enter.append(onenter + ""), onupdate != null && (update = onupdate(update), update && (update = update.selection())), onexit == null ? exit.remove() : onexit(exit), enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  for (var selection2 = context.selection ? context.selection() : context, groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j)
    for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge2 = merges[j] = new Array(n2), node, i2 = 0; i2 < n2; ++i2)
      (node = group0[i2] || group1[i2]) && (merge2[i2] = node);
  for (; j < m0; ++j)
    merges[j] = groups0[j];
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; )
    for (var group = groups[j], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; )
      (node = group[i2]) && (next && node.compareDocumentPosition(next) ^ 4 && next.parentNode.insertBefore(node, next), next = node);
  return this;
}
function selection_sort(compare) {
  compare || (compare = ascending);
  function compareNode(a2, b) {
    return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n2 = group.length, sortgroup = sortgroups[j] = new Array(n2), node, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && (sortgroup[i2] = node);
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  return arguments[0] = this, callback.apply(null, arguments), this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j)
    for (var group = groups[j], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node = group[i2];
      if (node) return node;
    }
  return null;
}
function selection_size() {
  let size2 = 0;
  for (const node of this) ++size2;
  return size2;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j)
    for (var group = groups[j], i2 = 0, n2 = group.length, node; i2 < n2; ++i2)
      (node = group[i2]) && callback.call(node, node.__data__, i2, group);
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? this.removeAttribute(name) : this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? this.removeAttributeNS(fullname.space, fullname.local) : this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value == "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? this.style.removeProperty(name) : this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value == "function" ? styleFunction$1 : styleConstant$1)(name, value, priority ?? "")) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    v == null ? delete this[name] : this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value == "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node, this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    i2 < 0 && (this._names.push(name), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    i2 >= 0 && (this._names.splice(i2, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  for (var list2 = classList(node), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.add(names[i2]);
}
function classedRemove(node, names) {
  for (var list2 = classList(node), i2 = -1, n2 = names.length; ++i2 < n2; ) list2.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    for (var list2 = classList(this.node()), i2 = -1, n2 = names.length; ++i2 < n2; ) if (!list2.contains(names[i2])) return !1;
    return !0;
  }
  return this.each((typeof value == "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v ?? "";
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value == "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v ?? "";
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value == "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise$1() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise$1);
}
function lower() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name == "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name == "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before == "function" ? before : selector$4(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  parent && parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(!1), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(!0), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    return i2 >= 0 && (name = t2.slice(i2 + 1), t2 = t2.slice(0, i2)), { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (on2) {
      for (var j = 0, i2 = -1, m2 = on2.length, o; j < m2; ++j)
        o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name ? this.removeEventListener(o.type, o.listener, o.options) : on2[++i2] = o;
      ++i2 ? on2.length = i2 : delete this.__on;
    }
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on2 = this.__on, o, listener = contextListener(value);
    if (on2) {
      for (var j = 0, m2 = on2.length; j < m2; ++j)
        if ((o = on2[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = listener, o.options = options), o.value = value;
          return;
        }
    }
    this.addEventListener(typename.type, listener, options), o = { type: typename.type, name: typename.name, value, listener, options }, on2 ? on2.push(o) : this.__on = [o];
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2) {
      for (var j = 0, m2 = on2.length, o; j < m2; ++j)
        for (i2 = 0, o = on2[j]; i2 < n2; ++i2)
          if ((t2 = typenames[i2]).type === o.type && t2.name === o.name)
            return o.value;
    }
    return;
  }
  for (on2 = value ? onAdd : onRemove, i2 = 0; i2 < n2; ++i2) this.each(on2(typenames[i2], value, options));
  return this;
}
function dispatchEvent(node, type, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  typeof event == "function" ? event = new event(type, params) : (event = window2.document.createEvent("Event"), params ? (event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail) : event.initEvent(type, !1, !1)), node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params == "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j)
    for (var group = groups[j], i2 = 0, n2 = group.length, node; i2 < n2; ++i2)
      (node = group[i2]) && (yield node);
}
var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups, this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 == "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  for (; sourceEvent2 = event.sourceEvent; ) event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  if (event = sourceEvent(event), node === void 0 && (node = event.currentTarget), node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      return point2.x = event.clientX, point2.y = event.clientY, point2 = point2.matrixTransform(node.getScreenCTM().inverse()), [point2.x, point2.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassive = { passive: !1 }, nonpassivecapture = { capture: !0, passive: !1 };
function nopropagation$1(event) {
  event.stopImmediatePropagation();
}
function noevent$1(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  "onselectstart" in root2 ? selection2.on("selectstart.drag", noevent$1, nonpassivecapture) : (root2.__noselect = root2.style.MozUserSelect, root2.style.MozUserSelect = "none");
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  noclick && (selection2.on("click.drag", noevent$1, nonpassivecapture), setTimeout(function() {
    selection2.on("click.drag", null);
  }, 0)), "onselectstart" in root2 ? selection2.on("selectstart.drag", null) : (root2.style.MozUserSelect = root2.__noselect, delete root2.__noselect);
}
const constant$3 = (x2) => () => x2;
function DragEvent(type, {
  sourceEvent: sourceEvent2,
  subject,
  target,
  identifier,
  active,
  x: x2,
  y: y2,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    subject: { value: subject, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    identifier: { value: identifier, enumerable: !0, configurable: !0 },
    active: { value: active, enumerable: !0, configurable: !0 },
    x: { value: x2, enumerable: !0, configurable: !0 },
    y: { value: y2, enumerable: !0, configurable: !0 },
    dx: { value: dx, enumerable: !0, configurable: !0 },
    dy: { value: dy, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$1(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d ?? { x: event.x, y: event.y };
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag$1() {
  var filter2 = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (!(touchending || !filter2.call(this, event, d))) {
      var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
      gesture && (select(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture), dragDisable(event.view), nopropagation$1(event), mousemoving = !1, mousedownx = event.clientX, mousedowny = event.clientY, gesture("start", event));
    }
  }
  function mousemoved(event) {
    if (noevent$1(event), !mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null), yesdrag(event.view, mousemoving), noevent$1(event), gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (filter2.call(this, event, d)) {
      var touches = event.changedTouches, c = container.call(this, event, d), n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2)
        (gesture = beforestart(this, c, event, d, touches[i2].identifier, touches[i2])) && (nopropagation$1(event), gesture("start", event, touches[i2]));
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (noevent$1(event), gesture("drag", event, touches[i2]));
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (touchending && clearTimeout(touchending), touchending = setTimeout(function() {
      touchending = null;
    }, 500), i2 = 0; i2 < n2; ++i2)
      (gesture = gestures[touches[i2].identifier]) && (nopropagation$1(event), gesture("end", event, touches[i2]));
  }
  function beforestart(that, container2, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer(touch || event, container2), dx, dy, s;
    if ((s = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) != null)
      return dx = s.x - p[0] || 0, dy = s.y - p[1] || 0, function gesture(type, event2, touch2) {
        var p0 = p, n2;
        switch (type) {
          case "start":
            gestures[identifier] = gesture, n2 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          // falls through
          case "drag":
            p = pointer(touch2 || event2, container2), n2 = active;
            break;
        }
        dispatch2.call(
          type,
          that,
          new DragEvent(type, {
            sourceEvent: event2,
            subject: s,
            target: drag2,
            identifier,
            active: n2,
            x: p[0] + dx,
            y: p[1] + dy,
            dx: p[0] - p0[0],
            dy: p[1] - p0[1],
            dispatch: dispatch2
          }),
          d
        );
      };
  }
  return drag2.filter = function(_2) {
    return arguments.length ? (filter2 = typeof _2 == "function" ? _2 : constant$3(!!_2), drag2) : filter2;
  }, drag2.container = function(_2) {
    return arguments.length ? (container = typeof _2 == "function" ? _2 : constant$3(_2), drag2) : container;
  }, drag2.subject = function(_2) {
    return arguments.length ? (subject = typeof _2 == "function" ? _2 : constant$3(_2), drag2) : subject;
  }, drag2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 == "function" ? _2 : constant$3(!!_2), drag2) : touchable;
  }, drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  }, drag2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
  }, drag2;
}
function define(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype, prototype.constructor = constructor;
}
function extend$1(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color$1() {
}
var darker = 0.7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color$1, color$1, {
  copy(channels2) {
    return Object.assign(new this.constructor(), this, channels2);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format) {
  var m2, l;
  return format = (format + "").trim().toLowerCase(), (m2 = reHex.exec(format)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba$2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba$2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format)) ? rgba$2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format)) ? rgba$2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format)) ? hsla$1(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba$2(r2, g, b, a2) {
  return a2 <= 0 && (r2 = g = b = NaN), new Rgb(r2, g, b, a2);
}
function rgbConvert(o) {
  return o instanceof Color$1 || (o = color$1(o)), o ? (o = o.rgb(), new Rgb(o.r, o.g, o.b, o.opacity)) : new Rgb();
}
function rgb(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity ?? 1);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2, this.g = +g, this.b = +b, this.opacity = +opacity;
}
define(Rgb, rgb, extend$1(Color$1, {
  brighter(k) {
    return k = k == null ? brighter : Math.pow(brighter, k), new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    return k = k == null ? darker : Math.pow(darker, k), new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  return value = clampi(value), (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h, s, l, a2) {
  return a2 <= 0 ? h = s = l = NaN : l <= 0 || l >= 1 ? h = s = NaN : s <= 0 && (h = NaN), new Hsl(h, s, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (o instanceof Color$1 || (o = color$1(o)), !o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r2, g, b), max2 = Math.max(r2, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  return s ? (r2 === max2 ? h = (g - b) / s + (g < b) * 6 : g === max2 ? h = (b - r2) / s + 2 : h = (r2 - g) / s + 4, s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2, h *= 60) : s = l > 0 && l < 1 ? 0 : h, new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity ?? 1);
}
function Hsl(h, s, l, opacity) {
  this.h = +h, this.s = +s, this.l = +l, this.opacity = +opacity;
}
define(Hsl, hsl, extend$1(Color$1, {
  brighter(k) {
    return k = k == null ? brighter : Math.pow(brighter, k), new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    return k = k == null ? darker : Math.pow(darker, k), new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  return value = (value || 0) % 360, value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a2, d) {
  return function(t2) {
    return a2 + t2 * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) == 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant$2(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d) : constant$2(isNaN(a2) ? b : a2);
}
const interpolateRgb = (function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      return start2.r = r2(t2), start2.g = g(t2), start2.b = b(t2), start2.opacity = opacity(t2), start2 + "";
    };
  }
  return rgb$1.gamma = rgbGamma, rgb$1;
})(1);
function numberArray(a2, b) {
  b || (b = []);
  var n2 = a2 ? Math.min(b.length, a2.length) : 0, c = b.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2) c[i2] = a2[i2] * (1 - t2) + b[i2] * t2;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2) x2[i2] = interpolate$2(a2[i2], b[i2]);
  for (; i2 < nb; ++i2) c[i2] = b[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2) c[i2] = x2[i2](t2);
    return c;
  };
}
function date$2(a2, b) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t2) {
    return d.setTime(a2 * (1 - t2) + b * t2), d;
  };
}
function interpolateNumber(a2, b) {
  return a2 = +a2, b = +b, function(t2) {
    return a2 * (1 - t2) + b * t2;
  };
}
function object$1(a2, b) {
  var i2 = {}, c = {}, k;
  (a2 === null || typeof a2 != "object") && (a2 = {}), (b === null || typeof b != "object") && (b = {});
  for (k in b)
    k in a2 ? i2[k] = interpolate$2(a2[k], b[k]) : c[k] = b[k];
  return function(t2) {
    for (k in i2) c[k] = i2[k](t2);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t2) {
    return b(t2) + "";
  };
}
function interpolateString(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s = [], q = [];
  for (a2 = a2 + "", b = b + ""; (am = reA.exec(a2)) && (bm = reB.exec(b)); )
    (bs = bm.index) > bi && (bs = b.slice(bi, bs), s[i2] ? s[i2] += bs : s[++i2] = bs), (am = am[0]) === (bm = bm[0]) ? s[i2] ? s[i2] += bm : s[++i2] = bm : (s[++i2] = null, q.push({ i: i2, x: interpolateNumber(am, bm) })), bi = reB.lastIndex;
  return bi < b.length && (bs = b.slice(bi), s[i2] ? s[i2] += bs : s[++i2] = bs), s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t2) {
    for (var i3 = 0, o; i3 < b; ++i3) s[(o = q[i3]).i] = o.x(t2);
    return s.join("");
  });
}
function interpolate$2(a2, b) {
  var t2 = typeof b, c;
  return b == null || t2 === "boolean" ? constant$2(b) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color$1 ? interpolateRgb : b instanceof Date ? date$2 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf != "function" && typeof b.toString != "function" || isNaN(b) ? object$1 : interpolateNumber)(a2, b);
}
var degrees$1 = 180 / Math.PI, identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b, c, d, e2, f) {
  var scaleX2, scaleY2, skewX;
  return (scaleX2 = Math.sqrt(a2 * a2 + b * b)) && (a2 /= scaleX2, b /= scaleX2), (skewX = a2 * c + b * d) && (c -= a2 * skewX, d -= b * skewX), (scaleY2 = Math.sqrt(c * c + d * d)) && (c /= scaleY2, d /= scaleY2, skewX /= scaleY2), a2 * d < b * c && (a2 = -a2, b = -b, skewX = -skewX, scaleX2 = -scaleX2), {
    translateX: e2,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}
var svgNode;
function parseCss(value) {
  const m2 = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m2.isIdentity ? identity$2 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value) {
  return value == null || (svgNode || (svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g")), svgNode.setAttribute("transform", value), !(value = svgNode.transform.baseVal.consolidate())) ? identity$2 : (value = value.matrix, decompose(value.a, value.b, value.c, value.d, value.e, value.f));
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb || yb) && s.push("translate(" + xb + pxComma + yb + pxParen);
  }
  function rotate2(a2, b, s, q) {
    a2 !== b ? (a2 - b > 180 ? b += 360 : b - a2 > 180 && (a2 += 360), q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) })) : b && s.push(pop(s) + "rotate(" + b + degParen);
  }
  function skewX(a2, b, s, q) {
    a2 !== b ? q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) }) : b && s.push(pop(s) + "skewX(" + b + degParen);
  }
  function scale2(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else (xb !== 1 || yb !== 1) && s.push(pop(s) + "scale(" + xb + "," + yb + ")");
  }
  return function(a2, b) {
    var s = [], q = [];
    return a2 = parse2(a2), b = parse2(b), translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s, q), rotate2(a2.rotate, b.rotate, s, q), skewX(a2.skewX, b.skewX, s, q), scale2(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s, q), a2 = b = null, function(t2) {
      for (var i2 = -1, n2 = q.length, o; ++i2 < n2; ) s[(o = q[i2]).i] = o.x(t2);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)"), interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")"), epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = (function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S;
    if (d2 < epsilon2)
      S = Math.log(w1 / w0) / rho, i2 = function(t2) {
        return [
          ux0 + t2 * dx,
          uy0 + t2 * dy,
          w0 * Math.exp(rho * t2 * S)
        ];
      };
    else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho, i2 = function(t2) {
        var s = t2 * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    return i2.duration = S * 1e3 * rho / Math.SQRT2, i2;
  }
  return zoom2.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  }, zoom2;
})(Math.SQRT2, 2, 4);
var frame$1 = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance == "object" && performance.now ? performance : Date, setFrame = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now$1() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay2, time2) {
    if (typeof callback != "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now$1() : +time2) + (delay2 == null ? 0 : +delay2), !this._next && taskTail !== this && (taskTail ? taskTail._next = this : taskHead = this, taskTail = this), this._call = callback, this._time = time2, sleep();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sleep());
  }
};
function timer(callback, delay2, time2) {
  var t2 = new Timer();
  return t2.restart(callback, delay2, time2), t2;
}
function timerFlush() {
  now$1(), ++frame$1;
  for (var t2 = taskHead, e2; t2; )
    (e2 = clockNow - t2._time) >= 0 && t2._call.call(void 0, e2), t2 = t2._next;
  --frame$1;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew, frame$1 = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame$1 = 0, nap(), clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay2 = now2 - clockLast;
  delay2 > pokeDelay && (clockSkew -= delay2, clockLast = now2);
}
function nap() {
  for (var t0, t1 = taskHead, t2, time2 = 1 / 0; t1; )
    t1._call ? (time2 > t1._time && (time2 = t1._time), t0 = t1, t1 = t1._next) : (t2 = t1._next, t1._next = null, t1 = t0 ? t0._next = t2 : taskHead = t2);
  taskTail = t0, sleep(time2);
}
function sleep(time2) {
  if (!frame$1) {
    timeout$1 && (timeout$1 = clearTimeout(timeout$1));
    var delay2 = time2 - clockNow;
    delay2 > 24 ? (time2 < 1 / 0 && (timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew)), interval && (interval = clearInterval(interval))) : (interval || (clockLast = clock.now(), interval = setInterval(poke, pokeDelay)), frame$1 = 1, setFrame(wake));
  }
}
function timeout(callback, delay2, time2) {
  var t2 = new Timer();
  return delay2 = delay2 == null ? 0 : +delay2, t2.restart((elapsed) => {
    t2.stop(), callback(elapsed + delay2);
  }, delay2, time2), t2;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt"), emptyTween = [], CREATED = 0, SCHEDULED = 1, STARTING = 2, STARTED = 3, RUNNING = 4, ENDING = 5, ENDED = 6;
function schedule(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule2 = get$1(node, id2);
  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
  return schedule2;
}
function set$1(node, id2) {
  var schedule2 = get$1(node, id2);
  if (schedule2.state > STARTED) throw new Error("too late; already running");
  return schedule2;
}
function get$1(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2, self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED, self2.timer.restart(start2, self2.delay, self2.time), self2.delay <= elapsed && start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j, n2, o;
    if (self2.state !== SCHEDULED) return stop();
    for (i2 in schedules)
      if (o = schedules[i2], o.name === self2.name) {
        if (o.state === STARTED) return timeout(start2);
        o.state === RUNNING ? (o.state = ENDED, o.timer.stop(), o.on.call("interrupt", node, node.__data__, o.index, o.group), delete schedules[i2]) : +i2 < id2 && (o.state = ENDED, o.timer.stop(), o.on.call("cancel", node, node.__data__, o.index, o.group), delete schedules[i2]);
      }
    if (timeout(function() {
      self2.state === STARTED && (self2.state = RUNNING, self2.timer.restart(tick, self2.delay, self2.time), tick(elapsed));
    }), self2.state = STARTING, self2.on.call("start", node, node.__data__, self2.index, self2.group), self2.state === STARTING) {
      for (self2.state = STARTED, tween = new Array(n2 = self2.tween.length), i2 = 0, j = -1; i2 < n2; ++i2)
        (o = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) && (tween[++j] = o);
      tween.length = j + 1;
    }
  }
  function tick(elapsed) {
    for (var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length; ++i2 < n2; )
      tween[i2].call(node, t2);
    self2.state === ENDING && (self2.on.call("end", node, node.__data__, self2.index, self2.group), stop());
  }
  function stop() {
    self2.state = ENDED, self2.timer.stop(), delete schedules[id2];
    for (var i2 in schedules) return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active, empty2 = !0, i2;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule2 = schedules[i2]).name !== name) {
        empty2 = !1;
        continue;
      }
      active = schedule2.state > STARTING && schedule2.state < ENDING, schedule2.state = ENDED, schedule2.timer.stop(), schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group), delete schedules[i2];
    }
    empty2 && delete node.__transition;
  }
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1 = tween1.slice(), tween1.splice(i2, 1);
          break;
        }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value != "function") throw new Error();
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2)
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      i2 === n2 && tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  if (name += "", arguments.length < 2) {
    for (var tween = get$1(this.node(), id2).tween, i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2)
      if ((t2 = tween[i2]).name === name)
        return t2.value;
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  return transition.each(function() {
    var schedule2 = set$1(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  }), function(node) {
    return get$1(node, id2).value[name];
  };
}
function interpolate$1(a2, b) {
  var c;
  return (typeof b == "number" ? interpolateNumber : b instanceof color$1 ? interpolateRgb : (c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)(a2, b);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttribute(name) : (string0 = this.getAttribute(name), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    return value1 == null ? void this.removeAttributeNS(fullname.space, fullname.local) : (string0 = this.getAttributeNS(fullname.space, fullname.local), string1 = value1 + "", string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1)));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name, typeof value == "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value));
}
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolateNS(fullname, i2)), t0;
  }
  return tween._value = value, tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && attrInterpolate(name, i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value != "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? delayFunction : delayConstant)(id2, value)) : get$1(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$1(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$1(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value == "function" ? durationFunction : durationConstant)(id2, value)) : get$1(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value != "function") throw new Error();
  return function() {
    set$1(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get$1(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v != "function") throw new Error();
    set$1(this, id2).ease = v;
  };
}
function transition_easeVarying(value) {
  if (typeof value != "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  typeof match != "function" && (match = matcher(match));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && match.call(node, node.__data__, i2, group) && subgroup.push(node);
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j)
    for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge2 = merges[j] = new Array(n2), node, i2 = 0; i2 < n2; ++i2)
      (node = group0[i2] || group1[i2]) && (merge2[i2] = node);
  for (; j < m0; ++j)
    merges[j] = groups0[j];
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    return i2 >= 0 && (t2 = t2.slice(0, i2)), !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set$1;
  return function() {
    var schedule2 = sit(this, id2), on2 = schedule2.on;
    on2 !== on0 && (on1 = (on0 = on2).copy()).on(name, listener), schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$1(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition) if (+i2 !== id2) return;
    parent && parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selector$4(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group)) && ("__data__" in node && (subnode.__data__ = node.__data__), subgroup[i2] = subnode, schedule(subgroup[i2], name, id2, i2, subgroup, get$1(node, id2)));
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  typeof select2 != "function" && (select2 = selectorAll(select2));
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2)
      if (node = group[i2]) {
        for (var children2 = select2.call(node, node.__data__, i2, group), child, inherit2 = get$1(node, id2), k = 0, l = children2.length; k < l; ++k)
          (child = children2[k]) && schedule(child, name, id2, k, children2, inherit2);
        subgroups.push(children2), parents.push(node);
      }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    return value1 == null && (string1 = value1 = (this.style.removeProperty(name), styleValue(this, name))), string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set$1(this, id2), on2 = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    (on2 !== on0 || listener0 !== listener) && (on1 = (on0 = on2).copy()).on(event, listener0 = listener), schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i2 = (name += "") == "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value == "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t2 = (i0 = i2) && styleInterpolate(name, i2, priority)), t2;
  }
  return tween._value = value, tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority ?? ""));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 ?? "";
  };
}
function transition_text(value) {
  return this.tween("text", typeof value == "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    return i2 !== i0 && (t0 = (i0 = i2) && textInterpolate(i2)), t0;
  }
  return tween._value = value, tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value != "function") throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  for (var name = this._name, id0 = this._id, id1 = newId(), groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2)
      if (node = group[i2]) {
        var inherit2 = get$1(node, id0);
        schedule(node, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel2 = { value: reject }, end = { value: function() {
      --size2 === 0 && resolve();
    } };
    that.each(function() {
      var schedule2 = set$1(this, id2), on2 = schedule2.on;
      on2 !== on0 && (on1 = (on0 = on2).copy(), on1._.cancel.push(cancel2), on1._.interrupt.push(cancel2), on1._.end.push(end)), schedule2.on = on1;
    }), size2 === 0 && resolve();
  });
}
var id$2 = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups, this._parents = parents, this._name = name, this._id = id2;
}
function newId() {
  return ++id$2;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  for (var timing; !(timing = node.__transition) || !(timing = timing[id2]); )
    if (!(node = node.parentNode))
      throw new Error(`transition ${id2} not found`);
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  name instanceof Transition ? (id2 = name._id, name = name._name) : (id2 = newId(), (timing = defaultTiming).time = now$1(), name = name == null ? null : name + "");
  for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j)
    for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2)
      (node = group[i2]) && schedule(node, name, id2, i2, group, timing || inherit(node, id2));
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const constant$1 = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: !0, configurable: !0 },
    sourceEvent: { value: sourceEvent2, enumerable: !0, configurable: !0 },
    target: { value: target, enumerable: !0, configurable: !0 },
    transform: { value: transform2, enumerable: !0, configurable: !0 },
    _: { value: dispatch2 }
  });
}
function Transform(k, x2, y2) {
  this.k = k, this.x = x2, this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$1 = new Transform(1, 0, 0);
transform$2.prototype = Transform.prototype;
function transform$2(node) {
  for (; !node.__zoom; ) if (!(node = node.parentNode)) return identity$1;
  return node.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault(), event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  return e2 instanceof SVGElement ? (e2 = e2.ownerSVGElement || e2, e2.hasAttribute("viewBox") ? (e2 = e2.viewBox.baseVal, [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]]) : [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]]) : [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity$1;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, 1 / 0], translateExtent = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], duration2 = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: !1 }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point2, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform), collection !== selection2 ? schedule2(collection, transform2, point2, event) : selection2.interrupt().each(function() {
      gesture(this, arguments).event(event).start().zoom(null, typeof transform2 == "function" ? transform2.apply(this, arguments) : transform2).end();
    });
  }, zoom2.scaleBy = function(selection2, k, p, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k == "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  }, zoom2.scaleTo = function(selection2, k, p, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e2) : typeof p == "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k == "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale2(t0, k1), p0, p1), e2, translateExtent);
    }, p, event);
  }, zoom2.translateBy = function(selection2, x2, y2, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 == "function" ? x2.apply(this, arguments) : x2,
        typeof y2 == "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  }, zoom2.translateTo = function(selection2, x2, y2, p, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p == null ? centroid(e2) : typeof p == "function" ? p.apply(this, arguments) : p;
      return constrain(identity$1.translate(p0[0], p0[1]).scale(t2.k).translate(
        typeof x2 == "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 == "function" ? -y2.apply(this, arguments) : -y2
      ), e2, translateExtent);
    }, p, event);
  };
  function scale2(transform2, k) {
    return k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k)), k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point2, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e2 = extent.apply(that, args), p = point2 == null ? centroid(e2) : typeof point2 == "function" ? point2.apply(that, args) : point2, w = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b = typeof transform2 == "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p).concat(w / a2.k), b.invert(p).concat(w / b.k));
      return function(t2) {
        if (t2 === 1) t2 = b;
        else {
          var l = i2(t2), k = w / l[2];
          t2 = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t2);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that, this.args = args, this.active = 0, this.sourceEvent = null, this.extent = extent.apply(that, args), this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      return event && (this.sourceEvent = event), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(key, transform2) {
      return this.mouse && key !== "mouse" && (this.mouse[1] = transform2.invert(this.mouse[0])), this.touch0 && key !== "touch" && (this.touch0[1] = transform2.invert(this.touch0[0])), this.touch1 && key !== "touch" && (this.touch1[1] = transform2.invert(this.touch1[0])), this.that.__zoom = transform2, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(type) {
      var d = select(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t2 = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p = pointer(event);
    if (g.wheel)
      (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) && (g.mouse[1] = t2.invert(g.mouse[0] = p)), clearTimeout(g.wheel);
    else {
      if (t2.k === k) return;
      g.mouse = [p, t2.invert(p)], interrupt(this), g.start();
    }
    noevent(event), g.wheel = setTimeout(wheelidled, wheelDelay), g.zoom("mouse", constrain(translate(scale2(t2, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null, g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g = gesture(this, args, !0).event(event), v = select(event.view).on("mousemove.zoom", mousemoved, !0).on("mouseup.zoom", mouseupped, !0), p = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view), nopropagation(event), g.mouse = [p, this.__zoom.invert(p)], interrupt(this), g.start();
    function mousemoved(event2) {
      if (noevent(event2), !g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null), yesdrag(event2.view, g.moved), noevent(event2), g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale2(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent(event), duration2 > 0 ? select(this).transition().duration(duration2).call(schedule2, t1, p0, event) : select(this).call(zoom2.transform, t1, p0, event);
    }
  }
  function touchstarted(event, ...args) {
    if (filter2.apply(this, arguments)) {
      var touches = event.touches, n2 = touches.length, g = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p;
      for (nopropagation(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p = pointer(t2, this), p = [p, this.__zoom.invert(p), t2.identifier], g.touch0 ? !g.touch1 && g.touch0[2] !== p[2] && (g.touch1 = p, g.taps = 0) : (g.touch0 = p, started = !0, g.taps = 1 + !!touchstarting);
      touchstarting && (touchstarting = clearTimeout(touchstarting)), started && (g.taps < 2 && (touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay)), interrupt(this), g.start());
    }
  }
  function touchmoved(event, ...args) {
    if (this.__zooming) {
      var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p, l;
      for (noevent(event), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], p = pointer(t2, this), g.touch0 && g.touch0[2] === t2.identifier ? g.touch0[0] = p : g.touch1 && g.touch1[2] === t2.identifier && (g.touch1[0] = p);
      if (t2 = g.that.__zoom, g.touch1) {
        var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale2(t2, Math.sqrt(dp / dl)), p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2], l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
      else return;
      g.zoom("touch", constrain(translate(t2, p, l), g.extent, translateExtent));
    }
  }
  function touchended(event, ...args) {
    if (this.__zooming) {
      var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
      for (nopropagation(event), touchending && clearTimeout(touchending), touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay), i2 = 0; i2 < n2; ++i2)
        t2 = touches[i2], g.touch0 && g.touch0[2] === t2.identifier ? delete g.touch0 : g.touch1 && g.touch1[2] === t2.identifier && delete g.touch1;
      if (g.touch1 && !g.touch0 && (g.touch0 = g.touch1, delete g.touch1), g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
      else if (g.end(), g.taps === 2 && (t2 = pointer(t2, this), Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance)) {
        var p = select(this).on("dblclick.zoom");
        p && p.apply(this, arguments);
      }
    }
  }
  return zoom2.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta2 = typeof _2 == "function" ? _2 : constant$1(+_2), zoom2) : wheelDelta2;
  }, zoom2.filter = function(_2) {
    return arguments.length ? (filter2 = typeof _2 == "function" ? _2 : constant$1(!!_2), zoom2) : filter2;
  }, zoom2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 == "function" ? _2 : constant$1(!!_2), zoom2) : touchable;
  }, zoom2.extent = function(_2) {
    return arguments.length ? (extent = typeof _2 == "function" ? _2 : constant$1([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent;
  }, zoom2.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  }, zoom2.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  }, zoom2.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom2) : constrain;
  }, zoom2.duration = function(_2) {
    return arguments.length ? (duration2 = +_2, zoom2) : duration2;
  }, zoom2.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, zoom2) : interpolate2;
  }, zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  }, zoom2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
  }, zoom2.tapDistance = function(_2) {
    return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
  }, zoom2;
}
const errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id2) => `The old edge with id=${id2} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (handleType, { id: id2, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: "${handleType === "source" ? sourceHandle : targetHandle}", edge id: ${id2}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (lib2 = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib2}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], elementSelectionKeys = ["Enter", " ", "Escape"], defaultAriaLabelConfig = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction, x: x2, y: y2 }) => `Moved selected node ${direction}. New position, x: ${x2}, y: ${y2}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2.Strict = "strict", ConnectionMode2.Loose = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2.Free = "free", PanOnScrollMode2.Vertical = "vertical", PanOnScrollMode2.Horizontal = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2.Partial = "partial", SelectionMode2.Full = "full";
})(SelectionMode || (SelectionMode = {}));
const initialConnection = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null,
  pointer: null
};
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2.Bezier = "default", ConnectionLineType2.Straight = "straight", ConnectionLineType2.Step = "step", ConnectionLineType2.SmoothStep = "smoothstep", ConnectionLineType2.SimpleBezier = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2.Arrow = "arrow", MarkerType2.ArrowClosed = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2.Left = "left", Position2.Top = "top", Position2.Right = "right", Position2.Bottom = "bottom";
})(Position || (Position = {}));
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? "valid" : "invalid";
}
const isEdgeBase = (element) => "id" in element && "source" in element && "target" in element, isNodeBase = (element) => "id" in element && "position" in element && !("source" in element) && !("target" in element), isInternalNodeBase = (element) => "id" in element && "internals" in element && !("source" in element) && !("target" in element), getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  const { width, height } = getNodeDimensions(node), origin = node.origin ?? nodeOrigin, offsetX = width * origin[0], offsetY = height * origin[1];
  return {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
}, getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {
  if (nodes.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const box = nodes.reduce((currBox, nodeOrId) => {
    const isId = typeof nodeOrId == "string";
    let currentNode = !params.nodeLookup && !isId ? nodeOrId : void 0;
    params.nodeLookup && (currentNode = isId ? params.nodeLookup.get(nodeOrId) : isInternalNodeBase(nodeOrId) ? nodeOrId : params.nodeLookup.get(nodeOrId.id));
    const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return boxToRect(box);
}, getInternalNodesBounds = (nodeLookup, params = {}) => {
  let box = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, hasVisibleNodes = !1;
  return nodeLookup.forEach((node) => {
    (params.filter === void 0 || params.filter(node)) && (box = getBoundsOfBoxes(box, nodeToBox(node)), hasVisibleNodes = !0);
  }), hasVisibleNodes ? boxToRect(box) : { x: 0, y: 0, width: 0, height: 0 };
}, getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = !1, excludeNonSelectableNodes = !1) => {
  const paneRect = {
    ...pointToRendererPoint(rect, [tx, ty, tScale]),
    width: rect.width / tScale,
    height: rect.height / tScale
  }, visibleNodes = [];
  for (const node of nodes.values()) {
    const { measured, selectable = !0, hidden: hidden2 = !1 } = node;
    if (excludeNonSelectableNodes && !selectable || hidden2)
      continue;
    const width = measured.width ?? node.width ?? node.initialWidth ?? null, height = measured.height ?? node.height ?? node.initialHeight ?? null, overlappingArea = getOverlappingArea(paneRect, nodeToRect(node)), area = (width ?? 0) * (height ?? 0), partiallyVisible = partially && overlappingArea > 0;
    (!node.internals.handleBounds || partiallyVisible || overlappingArea >= area || node.dragging) && visibleNodes.push(node);
  }
  return visibleNodes;
}, getConnectedEdges = (nodes, edges) => {
  const nodeIds = /* @__PURE__ */ new Set();
  return nodes.forEach((node) => {
    nodeIds.add(node.id);
  }), edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));
};
function getFitViewNodes(nodeLookup, options) {
  const fitViewNodes = /* @__PURE__ */ new Map(), optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;
  return nodeLookup.forEach((n2) => {
    n2.measured.width && n2.measured.height && (options?.includeHiddenNodes || !n2.hidden) && (!optionNodeIds || optionNodeIds.has(n2.id)) && fitViewNodes.set(n2.id, n2);
  }), fitViewNodes;
}
async function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {
  if (nodes.size === 0)
    return Promise.resolve(!0);
  const nodesToFit = getFitViewNodes(nodes, options), bounds = getInternalNodesBounds(nodesToFit), viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);
  return await panZoom.setViewport(viewport, {
    duration: options?.duration,
    ease: options?.ease,
    interpolate: options?.interpolate
  }), Promise.resolve(!0);
}
function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError }) {
  const node = nodeLookup.get(nodeId), parentNode = node.parentId ? nodeLookup.get(node.parentId) : void 0, { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 }, origin = node.origin ?? nodeOrigin;
  let extent = node.extent || nodeExtent;
  if (node.extent === "parent" && !node.expandParent)
    if (!parentNode)
      onError?.("005", errorMessages.error005());
    else {
      const parentWidth = parentNode.measured.width, parentHeight = parentNode.measured.height;
      parentWidth && parentHeight && (extent = [
        [parentX, parentY],
        [parentX + parentWidth, parentY + parentHeight]
      ]);
    }
  else parentNode && isCoordinateExtent(node.extent) && (extent = [
    [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
    [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
  ]);
  const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;
  return (node.measured.width === void 0 || node.measured.height === void 0) && onError?.("015", errorMessages.error015()), {
    position: {
      x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],
      y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1]
    },
    positionAbsolute
  };
}
async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {
  const nodeIds = new Set(nodesToRemove.map((node) => node.id)), matchingNodes = [];
  for (const node of nodes) {
    if (node.deletable === !1)
      continue;
    const isIncluded = nodeIds.has(node.id), parentHit = !isIncluded && node.parentId && matchingNodes.find((n2) => n2.id === node.parentId);
    (isIncluded || parentHit) && matchingNodes.push(node);
  }
  const edgeIds = new Set(edgesToRemove.map((edge) => edge.id)), deletableEdges = edges.filter((edge) => edge.deletable !== !1), matchingEdges = getConnectedEdges(matchingNodes, deletableEdges);
  for (const edge of deletableEdges)
    edgeIds.has(edge.id) && !matchingEdges.find((e2) => e2.id === edge.id) && matchingEdges.push(edge);
  if (!onBeforeDelete)
    return {
      edges: matchingEdges,
      nodes: matchingNodes
    };
  const onBeforeDeleteResult = await onBeforeDelete({
    nodes: matchingNodes,
    edges: matchingEdges
  });
  return typeof onBeforeDeleteResult == "boolean" ? onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] } : onBeforeDeleteResult;
}
const clamp$1 = (val, min2 = 0, max2 = 1) => Math.min(Math.max(val, min2), max2), clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({
  x: clamp$1(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),
  y: clamp$1(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0))
});
function clampPositionToParent(childPosition, childDimensions, parent) {
  const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent), { x: parentX, y: parentY } = parent.internals.positionAbsolute;
  return clampPosition(childPosition, [
    [parentX, parentY],
    [parentX + parentWidth, parentY + parentHeight]
  ], childDimensions);
}
const calcAutoPanVelocity = (value, min2, max2) => value < min2 ? clamp$1(Math.abs(value - min2), 1, min2) / min2 : value > max2 ? -clamp$1(Math.abs(value - max2), 1, min2) / min2 : 0, calcAutoPan = (pos, bounds, speed = 15, distance2 = 40) => {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed, yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
}, getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
}), rectToBox = ({ x: x2, y: y2, width, height }) => ({
  x: x2,
  y: y2,
  x2: x2 + width,
  y2: y2 + height
}), boxToRect = ({ x: x2, y: y2, x2: x22, y2: y22 }) => ({
  x: x2,
  y: y2,
  width: x22 - x2,
  height: y22 - y2
}), nodeToRect = (node, nodeOrigin = [0, 0]) => {
  const { x: x2, y: y2 } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x: x2,
    y: y2,
    width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,
    height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0
  };
}, nodeToBox = (node, nodeOrigin = [0, 0]) => {
  const { x: x2, y: y2 } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);
  return {
    x: x2,
    y: y2,
    x2: x2 + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),
    y2: y2 + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0)
  };
}, getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2))), getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x)), yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
}, isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y), isNumeric = (n2) => !isNaN(n2) && isFinite(n2), devWarn = (id2, message) => {
}, snapPosition = (position, snapGrid = [1, 1]) => ({
  x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
  y: snapGrid[1] * Math.round(position.y / snapGrid[1])
}), pointToRendererPoint = ({ x: x2, y: y2 }, [tx, ty, tScale], snapToGrid = !1, snapGrid = [1, 1]) => {
  const position = {
    x: (x2 - tx) / tScale,
    y: (y2 - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
}, rendererPointToPoint = ({ x: x2, y: y2 }, [tx, ty, tScale]) => ({
  x: x2 * tScale + tx,
  y: y2 * tScale + ty
});
function parsePadding(padding, viewport) {
  if (typeof padding == "number")
    return Math.floor((viewport - viewport / (1 + padding)) * 0.5);
  if (typeof padding == "string" && padding.endsWith("px")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue))
      return Math.floor(paddingValue);
  }
  if (typeof padding == "string" && padding.endsWith("%")) {
    const paddingValue = parseFloat(padding);
    if (!Number.isNaN(paddingValue))
      return Math.floor(viewport * paddingValue * 0.01);
  }
  return console.error(`[React Flow] The padding value "${padding}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function parsePaddings(padding, width, height) {
  if (typeof padding == "string" || typeof padding == "number") {
    const paddingY = parsePadding(padding, height), paddingX = parsePadding(padding, width);
    return {
      top: paddingY,
      right: paddingX,
      bottom: paddingY,
      left: paddingX,
      x: paddingX * 2,
      y: paddingY * 2
    };
  }
  if (typeof padding == "object") {
    const top = parsePadding(padding.top ?? padding.y ?? 0, height), bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height), left = parsePadding(padding.left ?? padding.x ?? 0, width), right = parsePadding(padding.right ?? padding.x ?? 0, width);
    return { top, right, bottom, left, x: left + right, y: top + bottom };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function calculateAppliedPaddings(bounds, x2, y2, zoom2, width, height) {
  const { x: left, y: top } = rendererPointToPoint(bounds, [x2, y2, zoom2]), { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x2, y2, zoom2]), right = width - boundRight, bottom = height - boundBottom;
  return {
    left: Math.floor(left),
    top: Math.floor(top),
    right: Math.floor(right),
    bottom: Math.floor(bottom)
  };
}
const getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {
  const p = parsePaddings(padding, width, height), xZoom = (width - p.x) / bounds.width, yZoom = (height - p.y) / bounds.height, zoom2 = Math.min(xZoom, yZoom), clampedZoom = clamp$1(zoom2, minZoom, maxZoom), boundsCenterX = bounds.x + bounds.width / 2, boundsCenterY = bounds.y + bounds.height / 2, x2 = width / 2 - boundsCenterX * clampedZoom, y2 = height / 2 - boundsCenterY * clampedZoom, newPadding = calculateAppliedPaddings(bounds, x2, y2, clampedZoom, width, height), offset2 = {
    left: Math.min(newPadding.left - p.left, 0),
    top: Math.min(newPadding.top - p.top, 0),
    right: Math.min(newPadding.right - p.right, 0),
    bottom: Math.min(newPadding.bottom - p.bottom, 0)
  };
  return {
    x: x2 - offset2.left + offset2.right,
    y: y2 - offset2.top + offset2.bottom,
    zoom: clampedZoom
  };
}, isMacOs = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function isCoordinateExtent(extent) {
  return extent != null && extent !== "parent";
}
function getNodeDimensions(node) {
  return {
    width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,
    height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0
  };
}
function nodeHasDimensions(node) {
  return (node.measured?.width ?? node.width ?? node.initialWidth) !== void 0 && (node.measured?.height ?? node.height ?? node.initialHeight) !== void 0;
}
function evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {
  const positionAbsolute = { ...position }, parent = nodeLookup.get(parentId);
  if (parent) {
    const origin = parent.origin || nodeOrigin;
    positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0], positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];
  }
  return positionAbsolute;
}
function areSetsEqual$1(a2, b) {
  if (a2.size !== b.size)
    return !1;
  for (const item of a2)
    if (!b.has(item))
      return !1;
  return !0;
}
function withResolvers() {
  let resolve, reject;
  return { promise: new Promise((res, rej) => {
    resolve = res, reject = rej;
  }), resolve, reject };
}
function mergeAriaLabelConfig(partial2) {
  return { ...defaultAriaLabelConfig, ...partial2 || {} };
}
function getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = !1, transform: transform2, containerBounds }) {
  const { x: x2, y: y2 } = getEventPosition(event), pointerPos = pointToRendererPoint({ x: x2 - (containerBounds?.left ?? 0), y: y2 - (containerBounds?.top ?? 0) }, transform2), { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;
  return {
    xSnapped,
    ySnapped,
    ...pointerPos
  };
}
const getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
}), getHostForElement = (element) => element?.getRootNode?.() || window?.document, inputTags = ["INPUT", "SELECT", "TEXTAREA"];
function isInputDOMNode(event) {
  const target = event.composedPath?.()?.[0] || event.target;
  return target?.nodeType !== 1 ? !1 : inputTags.includes(target.nodeName) || target.hasAttribute("contenteditable") || !!target.closest(".nokey");
}
const isMouseEvent = (event) => "clientX" in event, getEventPosition = (event, bounds) => {
  const isMouse = isMouseEvent(event), evtX = isMouse ? event.clientX : event.touches?.[0].clientX, evtY = isMouse ? event.clientY : event.touches?.[0].clientY;
  return {
    x: evtX - (bounds?.left ?? 0),
    y: evtY - (bounds?.top ?? 0)
  };
}, getHandleBounds = (type, nodeElement, nodeBounds, zoom2, nodeId) => {
  const handles = nodeElement.querySelectorAll(`.${type}`);
  return !handles || !handles.length ? null : Array.from(handles).map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      type,
      nodeId,
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125, centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125, offsetX = Math.abs(centerX - sourceX), offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  return distance2 >= 0 ? 0.5 * distance2 : curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  }), [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2, centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset, yOffset = Math.abs(targetY - sourceY) / 2, centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex({ sourceNode, targetNode, selected: selected2 = !1, zIndex = 0, elevateOnSelect = !1, zIndexMode = "basic" }) {
  if (zIndexMode === "manual")
    return zIndex;
  const edgeZ = elevateOnSelect && selected2 ? zIndex + 1e3 : zIndex, nodeZ = Math.max(sourceNode.parentId || elevateOnSelect && sourceNode.selected ? sourceNode.internals.z : 0, targetNode.parentId || elevateOnSelect && targetNode.selected ? targetNode.internals.z : 0);
  return edgeZ + nodeZ;
}
function isEdgeVisible({ sourceNode, targetNode, width, height, transform: transform2 }) {
  const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  edgeBox.x === edgeBox.x2 && (edgeBox.x2 += 1), edgeBox.y === edgeBox.y2 && (edgeBox.y2 += 1);
  const viewRect = {
    x: -transform2[0] / transform2[2],
    y: -transform2[1] / transform2[2],
    width: width / transform2[2],
    height: height / transform2[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
const getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ""}-${target}${targetHandle || ""}`, connectionExists = (edge, edges) => edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle)), addEdge = (edgeParams, edges, options = {}) => {
  if (!edgeParams.source || !edgeParams.target)
    return edges;
  const edgeIdGenerator = options.getEdgeId || getEdgeId;
  let edge;
  return isEdgeBase(edgeParams) ? edge = { ...edgeParams } : edge = {
    ...edgeParams,
    id: edgeIdGenerator(edgeParams)
  }, connectionExists(edge, edges) ? edges : (edge.sourceHandle === null && delete edge.sourceHandle, edge.targetHandle === null && delete edge.targetHandle, edges.concat(edge));
};
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
}, getDirection = ({ source, sourcePosition = Position.Bottom, target }) => sourcePosition === Position.Left || sourcePosition === Position.Right ? source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, distance$1 = (a2, b) => Math.sqrt(Math.pow(b.x - a2.x, 2) + Math.pow(b.y - a2.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset: offset2, stepPosition }) {
  const sourceDir = handleDirections[sourcePosition], targetDir = handleDirections[targetPosition], sourceGapped = { x: source.x + sourceDir.x * offset2, y: source.y + sourceDir.y * offset2 }, targetGapped = { x: target.x + targetDir.x * offset2, y: target.y + targetDir.y * offset2 }, dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  }), dirAccessor = dir.x !== 0 ? "x" : "y", currDir = dir[dirAccessor];
  let points = [], centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 }, targetGapOffset = { x: 0, y: 0 }, [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    dirAccessor === "x" ? (centerX = center.x ?? sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition, centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2) : (centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2, centerY = center.y ?? sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ], horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    sourceDir[dirAccessor] === currDir ? points = dirAccessor === "x" ? verticalSplit : horizontalSplit : points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }], targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x" ? points = sourceDir.x === currDir ? targetSource : sourceTarget : points = sourceDir.y === currDir ? sourceTarget : targetSource, sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset2) {
        const gapOffset = Math.min(offset2 - 1, offset2 - diff);
        sourceDir[dirAccessor] === currDir ? sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset : targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x", isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite], sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite], sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      (sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo)) && (points = dirAccessor === "x" ? sourceTarget : targetSource);
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y }, targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y }, maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x)), maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    maxXDistance >= maxYDistance ? (centerX = (sourceGapPoint.x + targetGapPoint.x) / 2, centerY = points[0].y) : (centerX = points[0].x, centerY = (sourceGapPoint.y + targetGapPoint.y) / 2);
  }
  return [[
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ], centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a2, b, c, size2) {
  const bendSize = Math.min(distance$1(a2, b) / 2, distance$1(b, c) / 2, size2), { x: x2, y: y2 } = b;
  if (a2.x === x2 && x2 === c.x || a2.y === y2 && y2 === c.y)
    return `L${x2} ${y2}`;
  if (a2.y === y2) {
    const xDir2 = a2.x < c.x ? -1 : 1, yDir2 = a2.y < c.y ? 1 : -1;
    return `L ${x2 + bendSize * xDir2},${y2}Q ${x2},${y2} ${x2},${y2 + bendSize * yDir2}`;
  }
  const xDir = a2.x < c.x ? 1 : -1, yDir = a2.y < c.y ? -1 : 1;
  return `L ${x2},${y2 + bendSize * yDir}Q ${x2},${y2} ${x2 + bendSize * xDir},${y2}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset: offset2 = 20, stepPosition = 0.5 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset: offset2,
    stepPosition
  });
  return [points.reduce((res, p, i2) => {
    let segment = "";
    return i2 > 0 && i2 < points.length - 1 ? segment = getBend(points[i2 - 1], p, points[i2 + 1], borderRadius) : segment = `${i2 === 0 ? "M" : "L"}${p.x} ${p.y}`, res += segment, res;
  }, ""), labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node) {
  return node && !!(node.internals.handleBounds || node.handles?.length) && !!(node.measured.width || node.width || node.initialWidth);
}
function getEdgePosition(params) {
  const { sourceNode, targetNode } = params;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode))
    return null;
  const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles), targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles), sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle), targetHandle = getHandle$1(
    // when connection type is loose we can define all handles as sources and connect source -> source
    params.connectionMode === ConnectionMode.Strict ? targetHandleBounds?.target ?? [] : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []),
    params.targetHandle
  );
  if (!sourceHandle || !targetHandle)
    return params.onError?.("008", errorMessages.error008(sourceHandle ? "target" : "source", {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    })), null;
  const sourcePosition = sourceHandle?.position || Position.Bottom, targetPosition = targetHandle?.position || Position.Top, source = getHandlePosition(sourceNode, sourceHandle, sourcePosition), target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition,
    targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles)
    return null;
  const source = [], target = [];
  for (const handle of handles)
    handle.width = handle.width ?? 1, handle.height = handle.height ?? 1, handle.type === "source" ? source.push(handle) : handle.type === "target" && target.push(handle);
  return {
    source,
    target
  };
}
function getHandlePosition(node, handle, fallbackPosition = Position.Left, center = !1) {
  const x2 = (handle?.x ?? 0) + node.internals.positionAbsolute.x, y2 = (handle?.y ?? 0) + node.internals.positionAbsolute.y, { width, height } = handle ?? getNodeDimensions(node);
  if (center)
    return { x: x2 + width / 2, y: y2 + height / 2 };
  switch (handle?.position ?? fallbackPosition) {
    case Position.Top:
      return { x: x2 + width / 2, y: y2 };
    case Position.Right:
      return { x: x2 + width, y: y2 + height / 2 };
    case Position.Bottom:
      return { x: x2 + width / 2, y: y2 + height };
    case Position.Left:
      return { x: x2, y: y2 + height / 2 };
  }
}
function getHandle$1(bounds, handleId) {
  return bounds && (handleId ? bounds.find((d) => d.id === handleId) : bounds[0]) || null;
}
function getMarkerId(marker, id2) {
  return marker ? typeof marker == "string" ? marker : `${id2 ? `${id2}__` : ""}${Object.keys(marker).sort().map((key) => `${key}=${marker[key]}`).join("&")}` : "";
}
function createMarkerIds(edges, { id: id2, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {
  const ids = /* @__PURE__ */ new Set();
  return edges.reduce((markers, edge) => ([edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {
    if (marker && typeof marker == "object") {
      const markerId = getMarkerId(marker, id2);
      ids.has(markerId) || (markers.push({ id: markerId, color: marker.color || defaultColor, ...marker }), ids.add(markerId));
    }
  }), markers), []).sort((a2, b) => a2.id.localeCompare(b.id));
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset2, align) {
  let alignmentOffset = 0.5;
  align === "start" ? alignmentOffset = 0 : align === "end" && (alignmentOffset = 1);
  let pos = [
    (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,
    nodeRect.y * viewport.zoom + viewport.y - offset2
  ], shift2 = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [
        (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset2, shift2[1] = 0;
      break;
    case Position.Left:
      pos = [
        nodeRect.x * viewport.zoom + viewport.x - offset2,
        (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y
      ], shift2 = [-100, -100 * alignmentOffset];
      break;
  }
  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift2[0]}%, ${shift2[1]}%)`;
}
const SELECTED_NODE_Z = 1e3, ROOT_PARENT_Z_INCREMENT = 10, defaultOptions$1 = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: !0,
  zIndexMode: "basic",
  defaults: {}
}, adoptUserNodesDefaultOptions = {
  ...defaultOptions$1,
  checkEquality: !0
};
function mergeObjects(base, incoming) {
  const result = { ...base };
  for (const key in incoming)
    incoming[key] !== void 0 && (result[key] = incoming[key]);
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  const _options = mergeObjects(defaultOptions$1, options);
  for (const node of nodeLookup.values())
    if (node.parentId)
      updateChildNode(node, nodeLookup, parentLookup, _options);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin), extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));
      node.internals.positionAbsolute = clampedPosition;
    }
}
function parseHandles(userNode, internalNode) {
  if (!userNode.handles)
    return userNode.measured ? internalNode?.internals.handleBounds : void 0;
  const source = [], target = [];
  for (const handle of userNode.handles) {
    const handleBounds = {
      id: handle.id,
      width: handle.width ?? 1,
      height: handle.height ?? 1,
      nodeId: userNode.id,
      x: handle.x,
      y: handle.y,
      position: handle.position,
      type: handle.type
    };
    handle.type === "source" ? source.push(handleBounds) : handle.type === "target" && target.push(handleBounds);
  }
  return {
    source,
    target
  };
}
function isManualZIndexMode(zIndexMode) {
  return zIndexMode === "manual";
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options = {}) {
  const _options = mergeObjects(adoptUserNodesDefaultOptions, options), rootParentIndex = { i: 0 }, tmpLookup = new Map(nodeLookup), selectedNodeZ = _options?.elevateNodesOnSelect && !isManualZIndexMode(_options.zIndexMode) ? SELECTED_NODE_Z : 0;
  let nodesInitialized = nodes.length > 0;
  nodeLookup.clear(), parentLookup.clear();
  for (const userNode of nodes) {
    let internalNode = tmpLookup.get(userNode.id);
    if (_options.checkEquality && userNode === internalNode?.internals.userNode)
      nodeLookup.set(userNode.id, internalNode);
    else {
      const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin), extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent, clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
      internalNode = {
        ..._options.defaults,
        ...userNode,
        measured: {
          width: userNode.measured?.width,
          height: userNode.measured?.height
        },
        internals: {
          positionAbsolute: clampedPosition,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: parseHandles(userNode, internalNode),
          z: calculateZ(userNode, selectedNodeZ, _options.zIndexMode),
          userNode
        }
      }, nodeLookup.set(userNode.id, internalNode);
    }
    (internalNode.measured === void 0 || internalNode.measured.width === void 0 || internalNode.measured.height === void 0) && !internalNode.hidden && (nodesInitialized = !1), userNode.parentId && updateChildNode(internalNode, nodeLookup, parentLookup, options, rootParentIndex);
  }
  return nodesInitialized;
}
function updateParentLookup(node, parentLookup) {
  if (!node.parentId)
    return;
  const childNodes = parentLookup.get(node.parentId);
  childNodes ? childNodes.set(node.id, node) : parentLookup.set(node.parentId, /* @__PURE__ */ new Map([[node.id, node]]));
}
function updateChildNode(node, nodeLookup, parentLookup, options, rootParentIndex) {
  const { elevateNodesOnSelect, nodeOrigin, nodeExtent, zIndexMode } = mergeObjects(defaultOptions$1, options), parentId = node.parentId, parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  updateParentLookup(node, parentLookup), rootParentIndex && !parentNode.parentId && parentNode.internals.rootParentIndex === void 0 && zIndexMode === "auto" && (parentNode.internals.rootParentIndex = ++rootParentIndex.i, parentNode.internals.z = parentNode.internals.z + rootParentIndex.i * ROOT_PARENT_Z_INCREMENT), rootParentIndex && parentNode.internals.rootParentIndex !== void 0 && (rootParentIndex.i = parentNode.internals.rootParentIndex);
  const selectedNodeZ = elevateNodesOnSelect && !isManualZIndexMode(zIndexMode) ? SELECTED_NODE_Z : 0, { x: x2, y: y2, z: z2 } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode), { positionAbsolute } = node.internals, positionChanged = x2 !== positionAbsolute.x || y2 !== positionAbsolute.y;
  (positionChanged || z2 !== node.internals.z) && nodeLookup.set(node.id, {
    ...node,
    internals: {
      ...node.internals,
      positionAbsolute: positionChanged ? { x: x2, y: y2 } : positionAbsolute,
      z: z2
    }
  });
}
function calculateZ(node, selectedNodeZ, zIndexMode) {
  const zIndex = isNumeric(node.zIndex) ? node.zIndex : 0;
  return isManualZIndexMode(zIndexMode) ? zIndex : zIndex + (node.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode) {
  const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute, childDimensions = getNodeDimensions(childNode), positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin), clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);
  childNode.extent === "parent" && (absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode));
  const childZ = calculateZ(childNode, selectedNodeZ, zIndexMode), parentZ = parentNode.internals.z ?? 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ >= childZ ? parentZ + 1 : childZ
  };
}
function handleExpandParent(children2, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {
  const changes = [], parentExpansions = /* @__PURE__ */ new Map();
  for (const child of children2) {
    const parent = nodeLookup.get(child.parentId);
    if (!parent)
      continue;
    const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent), expandedRect = getBoundsOfRects(parentRect, child.rect);
    parentExpansions.set(child.parentId, { expandedRect, parent });
  }
  return parentExpansions.size > 0 && parentExpansions.forEach(({ expandedRect, parent }, parentId) => {
    const positionAbsolute = parent.internals.positionAbsolute, dimensions = getNodeDimensions(parent), origin = parent.origin ?? nodeOrigin, xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0, yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0, newWidth = Math.max(dimensions.width, Math.round(expandedRect.width)), newHeight = Math.max(dimensions.height, Math.round(expandedRect.height)), widthChange = (newWidth - dimensions.width) * origin[0], heightChange = (newHeight - dimensions.height) * origin[1];
    (xChange > 0 || yChange > 0 || widthChange || heightChange) && (changes.push({
      id: parentId,
      type: "position",
      position: {
        x: parent.position.x - xChange + widthChange,
        y: parent.position.y - yChange + heightChange
      }
    }), parentLookup.get(parentId)?.forEach((childNode) => {
      children2.some((child) => child.id === childNode.id) || changes.push({
        id: childNode.id,
        type: "position",
        position: {
          x: childNode.position.x + xChange,
          y: childNode.position.y + yChange
        }
      });
    })), (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) && changes.push({
      id: parentId,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
      }
    });
  }), changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, zIndexMode) {
  const viewportNode = domNode?.querySelector(".xyflow__viewport");
  let updatedInternals = !1;
  if (!viewportNode)
    return { changes: [], updatedInternals };
  const changes = [], style2 = window.getComputedStyle(viewportNode), { m22: zoom2 } = new window.DOMMatrixReadOnly(style2.transform), parentExpandChildren = [];
  for (const update of updates.values()) {
    const node = nodeLookup.get(update.id);
    if (!node)
      continue;
    if (node.hidden) {
      nodeLookup.set(node.id, {
        ...node,
        internals: {
          ...node.internals,
          handleBounds: void 0
        }
      }), updatedInternals = !0;
      continue;
    }
    const dimensions = getDimensions(update.nodeElement), dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;
    if (!!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force))) {
      const nodeBounds = update.nodeElement.getBoundingClientRect(), extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;
      let { positionAbsolute } = node.internals;
      node.parentId && node.extent === "parent" ? positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId)) : extent && (positionAbsolute = clampPosition(positionAbsolute, extent, dimensions));
      const newNode = {
        ...node,
        measured: dimensions,
        internals: {
          ...node.internals,
          positionAbsolute,
          handleBounds: {
            source: getHandleBounds("source", update.nodeElement, nodeBounds, zoom2, node.id),
            target: getHandleBounds("target", update.nodeElement, nodeBounds, zoom2, node.id)
          }
        }
      };
      nodeLookup.set(node.id, newNode), node.parentId && updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin, zIndexMode }), updatedInternals = !0, dimensionChanged && (changes.push({
        id: node.id,
        type: "dimensions",
        dimensions
      }), node.expandParent && node.parentId && parentExpandChildren.push({
        id: node.id,
        parentId: node.parentId,
        rect: nodeToRect(newNode, nodeOrigin)
      }));
    }
  }
  if (parentExpandChildren.length > 0) {
    const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push(...parentExpandChanges);
  }
  return { changes, updatedInternals };
}
async function panBy({ delta, panZoom, transform: transform2, translateExtent, width, height }) {
  if (!panZoom || !delta.x && !delta.y)
    return Promise.resolve(!1);
  const nextViewport = await panZoom.setViewportConstrained({
    x: transform2[0] + delta.x,
    y: transform2[1] + delta.y,
    zoom: transform2[2]
  }, [
    [0, 0],
    [width, height]
  ], translateExtent), transformChanged = !!nextViewport && (nextViewport.x !== transform2[0] || nextViewport.y !== transform2[1] || nextViewport.k !== transform2[2]);
  return Promise.resolve(transformChanged);
}
function addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {
  let key = nodeId;
  const nodeMap = connectionLookup.get(key) || /* @__PURE__ */ new Map();
  connectionLookup.set(key, nodeMap.set(connectionKey, connection)), key = `${nodeId}-${type}`;
  const typeMap = connectionLookup.get(key) || /* @__PURE__ */ new Map();
  if (connectionLookup.set(key, typeMap.set(connectionKey, connection)), handleId) {
    key = `${nodeId}-${type}-${handleId}`;
    const handleMap = connectionLookup.get(key) || /* @__PURE__ */ new Map();
    connectionLookup.set(key, handleMap.set(connectionKey, connection));
  }
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear(), edgeLookup.clear();
  for (const edge of edges) {
    const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge, connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle }, sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`, targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;
    addConnectionToLookup("source", connection, targetKey, connectionLookup, sourceNode, sourceHandle), addConnectionToLookup("target", connection, sourceKey, connectionLookup, targetNode, targetHandle), edgeLookup.set(edge.id, edge);
  }
}
function isParentSelected(node, nodeLookup) {
  if (!node.parentId)
    return !1;
  const parentNode = nodeLookup.get(node.parentId);
  return parentNode ? parentNode.selected ? !0 : isParentSelected(parentNode, nodeLookup) : !1;
}
function hasSelector(target, selector2, domNode) {
  let current2 = target;
  do {
    if (current2?.matches?.(selector2))
      return !0;
    if (current2 === domNode)
      return !1;
    current2 = current2?.parentElement;
  } while (current2);
  return !1;
}
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  const dragItems = /* @__PURE__ */ new Map();
  for (const [id2, node] of nodeLookup)
    if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable > "u")) {
      const internalNode = nodeLookup.get(id2);
      internalNode && dragItems.set(id2, {
        id: id2,
        position: internalNode.position || { x: 0, y: 0 },
        distance: {
          x: mousePos.x - internalNode.internals.positionAbsolute.x,
          y: mousePos.y - internalNode.internals.positionAbsolute.y
        },
        extent: internalNode.extent,
        parentId: internalNode.parentId,
        origin: internalNode.origin,
        expandParent: internalNode.expandParent,
        internals: {
          positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: internalNode.measured.width ?? 0,
          height: internalNode.measured.height ?? 0
        }
      });
    }
  return dragItems;
}
function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = !0 }) {
  const nodesFromDragItems = [];
  for (const [id2, dragItem] of dragItems) {
    const node2 = nodeLookup.get(id2)?.internals.userNode;
    node2 && nodesFromDragItems.push({
      ...node2,
      position: dragItem.position,
      dragging
    });
  }
  if (!nodeId)
    return [nodesFromDragItems[0], nodesFromDragItems];
  const node = nodeLookup.get(nodeId)?.internals.userNode;
  return [
    node ? {
      ...node,
      position: dragItems.get(nodeId)?.position || node.position,
      dragging
    } : nodesFromDragItems[0],
    nodesFromDragItems
  ];
}
function calculateSnapOffset({ dragItems, snapGrid, x: x2, y: y2 }) {
  const refDragItem = dragItems.values().next().value;
  if (!refDragItem)
    return null;
  const refPos = {
    x: x2 - refDragItem.distance.x,
    y: y2 - refDragItem.distance.y
  }, refPosSnapped = snapPosition(refPos, snapGrid);
  return {
    x: refPosSnapped.x - refPos.x,
    y: refPosSnapped.y - refPos.y
  };
}
function XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {
  let lastPos = { x: null, y: null }, autoPanId = 0, dragItems = /* @__PURE__ */ new Map(), autoPanStarted = !1, mousePosition = { x: 0, y: 0 }, containerBounds = null, dragStarted = !1, d3Selection = null, abortDrag = !1, nodePositionsChanged = !1, dragEvent = null;
  function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {
    d3Selection = select(domNode);
    function updateNodes({ x: x2, y: y2 }) {
      const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();
      lastPos = { x: x2, y: y2 };
      let hasChange = !1;
      const isMultiDrag = dragItems.size > 1, nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null, multiDragSnapOffset = isMultiDrag && snapToGrid ? calculateSnapOffset({
        dragItems,
        snapGrid,
        x: x2,
        y: y2
      }) : null;
      for (const [id2, dragItem] of dragItems) {
        if (!nodeLookup.has(id2))
          continue;
        let nextPosition = { x: x2 - dragItem.distance.x, y: y2 - dragItem.distance.y };
        snapToGrid && (nextPosition = multiDragSnapOffset ? {
          x: Math.round(nextPosition.x + multiDragSnapOffset.x),
          y: Math.round(nextPosition.y + multiDragSnapOffset.y)
        } : snapPosition(nextPosition, snapGrid));
        let adjustedNodeExtent = null;
        if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {
          const { positionAbsolute: positionAbsolute2 } = dragItem.internals, x1 = positionAbsolute2.x - nodesBox.x + nodeExtent[0][0], x22 = positionAbsolute2.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0], y1 = positionAbsolute2.y - nodesBox.y + nodeExtent[0][1], y22 = positionAbsolute2.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
          adjustedNodeExtent = [
            [x1, y1],
            [x22, y22]
          ];
        }
        const { position, positionAbsolute } = calculateNodePosition({
          nodeId: id2,
          nextPosition,
          nodeLookup,
          nodeExtent: adjustedNodeExtent || nodeExtent,
          nodeOrigin,
          onError
        });
        hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y, dragItem.position = position, dragItem.internals.positionAbsolute = positionAbsolute;
      }
      if (nodePositionsChanged = nodePositionsChanged || hasChange, !!hasChange && (updateNodePositions(dragItems, !0), dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag))) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDrag?.(dragEvent, dragItems, currentNode, currentNodes), onNodeDrag?.(dragEvent, currentNode, currentNodes), nodeId || onSelectionDrag?.(dragEvent, currentNodes);
      }
    }
    async function autoPan() {
      if (!containerBounds)
        return;
      const { transform: transform2, panBy: panBy2, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();
      if (!autoPanOnNodeDrag) {
        autoPanStarted = !1, cancelAnimationFrame(autoPanId);
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);
      (xMovement !== 0 || yMovement !== 0) && (lastPos.x = (lastPos.x ?? 0) - xMovement / transform2[2], lastPos.y = (lastPos.y ?? 0) - yMovement / transform2[2], await panBy2({ x: xMovement, y: yMovement }) && updateNodes(lastPos)), autoPanId = requestAnimationFrame(autoPan);
    }
    function startDrag(event) {
      const { nodeLookup, multiSelectionActive, nodesDraggable, transform: transform2, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();
      dragStarted = !0, (!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId && (nodeLookup.get(nodeId)?.selected || unselectNodesAndEdges()), isSelectable && selectNodesOnDrag && nodeId && onNodeMouseDown?.(nodeId);
      const pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if (lastPos = pointerPos, dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId), dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        const [currentNode, currentNodes] = getEventHandlerParams({
          nodeId,
          dragItems,
          nodeLookup
        });
        onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStart?.(event.sourceEvent, currentNodes);
      }
    }
    const d3DragInstance = drag$1().clickDistance(nodeClickDistance).on("start", (event) => {
      const { domNode: domNode2, nodeDragThreshold, transform: transform2, snapGrid, snapToGrid } = getStoreItems();
      containerBounds = domNode2?.getBoundingClientRect() || null, abortDrag = !1, nodePositionsChanged = !1, dragEvent = event.sourceEvent, nodeDragThreshold === 0 && startDrag(event), lastPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds }), mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on("drag", (event) => {
      const { autoPanOnNodeDrag, transform: transform2, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems(), pointerPos = getPointerPosition(event.sourceEvent, { transform: transform2, snapGrid, snapToGrid, containerBounds });
      if (dragEvent = event.sourceEvent, (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) && (abortDrag = !0), !abortDrag) {
        if (!autoPanStarted && autoPanOnNodeDrag && dragStarted && (autoPanStarted = !0, autoPan()), !dragStarted) {
          const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds), x2 = currentMousePosition.x - mousePosition.x, y2 = currentMousePosition.y - mousePosition.y;
          Math.sqrt(x2 * x2 + y2 * y2) > nodeDragThreshold && startDrag(event);
        }
        (lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted && (mousePosition = getEventPosition(event.sourceEvent, containerBounds), updateNodes(pointerPos));
      }
    }).on("end", (event) => {
      if (!(!dragStarted || abortDrag) && (autoPanStarted = !1, dragStarted = !1, cancelAnimationFrame(autoPanId), dragItems.size > 0)) {
        const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();
        if (nodePositionsChanged && (updateNodePositions(dragItems, !1), nodePositionsChanged = !1), onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          const [currentNode, currentNodes] = getEventHandlerParams({
            nodeId,
            dragItems,
            nodeLookup,
            dragging: !1
          });
          onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes), onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes), nodeId || onSelectionDragStop?.(event.sourceEvent, currentNodes);
        }
      }
    }).filter((event) => {
      const target = event.target;
      return !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    d3Selection?.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance2) {
  const nodes = [], rect = {
    x: position.x - distance2,
    y: position.y - distance2,
    width: distance2 * 2,
    height: distance2 * 2
  };
  for (const node of nodeLookup.values())
    getOverlappingArea(rect, nodeToRect(node)) > 0 && nodes.push(node);
  return nodes;
}
const ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  let closestHandles = [], minDistance = 1 / 0;
  const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  for (const node of closeNodes) {
    const allHandles = [...node.internals.handleBounds?.source ?? [], ...node.internals.handleBounds?.target ?? []];
    for (const handle of allHandles) {
      if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id)
        continue;
      const { x: x2, y: y2 } = getHandlePosition(node, handle, handle.position, !0), distance2 = Math.sqrt(Math.pow(x2 - position.x, 2) + Math.pow(y2 - position.y, 2));
      distance2 > connectionRadius || (distance2 < minDistance ? (closestHandles = [{ ...handle, x: x2, y: y2 }], minDistance = distance2) : distance2 === minDistance && closestHandles.push({ ...handle, x: x2, y: y2 }));
    }
  }
  if (!closestHandles.length)
    return null;
  if (closestHandles.length > 1) {
    const oppositeHandleType = fromHandle.type === "source" ? "target" : "source";
    return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = !1) {
  const node = nodeLookup.get(nodeId);
  if (!node)
    return null;
  const handles = connectionMode === "strict" ? node.internals.handleBounds?.[handleType] : [...node.internals.handleBounds?.source ?? [], ...node.internals.handleBounds?.target ?? []], handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;
  return handle && withAbsolutePosition ? { ...handle, ...getHandlePosition(node, handle, handle.position, !0) } : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  return edgeUpdaterType || (handleDomNode?.classList.contains("target") ? "target" : handleDomNode?.classList.contains("source") ? "source" : null);
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  let isValid = null;
  return isHandleValid ? isValid = !0 : isInsideConnectionRadius && !isHandleValid && (isValid = !1), isValid;
}
const alwaysValid = () => !0;
function onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib: lib2, autoPanOnConnect, flowId, panBy: panBy2, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode }) {
  const doc = getHostForElement(event.target);
  let autoPanId = 0, closestHandle;
  const { x: x2, y: y2 } = getEventPosition(event), handleType = getHandleType(edgeUpdaterType, handleDomNode), containerBounds = domNode?.getBoundingClientRect();
  let connectionStarted = !1;
  if (!containerBounds || !handleType)
    return;
  const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal)
    return;
  let position = getEventPosition(event, containerBounds), autoPanStarted = !1, connection = null, isValid = !1, resultHandleDomNode = null;
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds)
      return;
    const [x22, y22] = calcAutoPan(position, containerBounds, autoPanSpeed);
    panBy2({ x: x22, y: y22 }), autoPanId = requestAnimationFrame(autoPan);
  }
  const fromHandle = {
    ...fromHandleInternal,
    nodeId,
    type: handleType,
    position: fromHandleInternal.position
  }, fromInternalNode = nodeLookup.get(nodeId);
  let previousConnection = {
    inProgress: !0,
    isValid: null,
    from: getHandlePosition(fromInternalNode, fromHandle, Position.Left, !0),
    fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromInternalNode,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null,
    pointer: position
  };
  function startConnection() {
    connectionStarted = !0, updateConnection(previousConnection), onConnectStart?.(event, { nodeId, handleId, handleType });
  }
  dragThreshold === 0 && startConnection();
  function onPointerMove(event2) {
    if (!connectionStarted) {
      const { x: evtX, y: evtY } = getEventPosition(event2), dx = evtX - x2, dy = evtY - y2;
      if (!(dx * dx + dy * dy > dragThreshold * dragThreshold))
        return;
      startConnection();
    }
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event2);
      return;
    }
    const transform2 = getTransform();
    position = getEventPosition(event2, containerBounds), closestHandle = getClosestHandle(pointToRendererPoint(position, transform2, !1, [1, 1]), connectionRadius, nodeLookup, fromHandle), autoPanStarted || (autoPan(), autoPanStarted = !0);
    const result = isValidHandle(event2, {
      handle: closestHandle,
      connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? "target" : "source",
      isValidConnection,
      doc,
      lib: lib2,
      flowId,
      nodeLookup
    });
    resultHandleDomNode = result.handleDomNode, connection = result.connection, isValid = isConnectionValid(!!closestHandle, result.isValid);
    const fromInternalNode2 = nodeLookup.get(nodeId), from2 = fromInternalNode2 ? getHandlePosition(fromInternalNode2, fromHandle, Position.Left, !0) : previousConnection.from, newConnection = {
      ...previousConnection,
      from: from2,
      isValid,
      to: result.toHandle && isValid ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform2) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,
      pointer: position
    };
    updateConnection(newConnection), previousConnection = newConnection;
  }
  function onPointerUp(event2) {
    if (!("touches" in event2 && event2.touches.length > 0)) {
      if (connectionStarted) {
        (closestHandle || resultHandleDomNode) && connection && isValid && onConnect?.(connection);
        const { inProgress, ...connectionState } = previousConnection, finalConnectionState = {
          ...connectionState,
          toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
        };
        onConnectEnd?.(event2, finalConnectionState), edgeUpdaterType && onReconnectEnd?.(event2, finalConnectionState);
      }
      cancelConnection(), cancelAnimationFrame(autoPanId), autoPanStarted = !1, isValid = !1, connection = null, resultHandleDomNode = null, doc.removeEventListener("mousemove", onPointerMove), doc.removeEventListener("mouseup", onPointerUp), doc.removeEventListener("touchmove", onPointerMove), doc.removeEventListener("touchend", onPointerUp);
    }
  }
  doc.addEventListener("mousemove", onPointerMove), doc.addEventListener("mouseup", onPointerUp), doc.addEventListener("touchmove", onPointerMove), doc.addEventListener("touchend", onPointerUp);
}
function isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib: lib2, flowId, isValidConnection = alwaysValid, nodeLookup }) {
  const isTarget = fromType === "target", handleDomNode = handle ? doc.querySelector(`.${lib2}-flow__handle[data-id="${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}"]`) : null, { x: x2, y: y2 } = getEventPosition(event), handleBelow = doc.elementFromPoint(x2, y2), handleToCheck = handleBelow?.classList.contains(`${lib2}-flow__handle`) ? handleBelow : handleDomNode, result = {
    handleDomNode: handleToCheck,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck), handleNodeId = handleToCheck.getAttribute("data-nodeid"), handleId = handleToCheck.getAttribute("data-handleid"), connectable = handleToCheck.classList.contains("connectable"), connectableEnd = handleToCheck.classList.contains("connectableend");
    if (!handleNodeId || !handleType)
      return result;
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isValid = connectable && connectableEnd && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection), result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, !0);
  }
  return result;
}
const XYHandle = {
  onPointerDown,
  isValid: isValidHandle
};
function XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {
  const selection2 = select(domNode);
  function update({ translateExtent, width, height, zoomStep = 1, pannable = !0, zoomable = !0, inversePan = !1 }) {
    const zoomHandler = (event) => {
      if (event.sourceEvent.type !== "wheel" || !panZoom)
        return;
      const transform2 = getTransform(), factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1, pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * zoomStep, nextZoom = transform2[2] * Math.pow(2, pinchDelta * factor);
      panZoom.scaleTo(nextZoom);
    };
    let panStart = [0, 0];
    const panStartHandler = (event) => {
      (event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart") && (panStart = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ]);
    }, panHandler = (event) => {
      const transform2 = getTransform();
      if (event.sourceEvent.type !== "mousemove" && event.sourceEvent.type !== "touchmove" || !panZoom)
        return;
      const panCurrent = [
        event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,
        event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY
      ], panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      const moveScale = getViewScale() * Math.max(transform2[2], Math.log(transform2[2])) * (inversePan ? -1 : 1), position = {
        x: transform2[0] - panDelta[0] * moveScale,
        y: transform2[1] - panDelta[1] * moveScale
      }, extent = [
        [0, 0],
        [width, height]
      ];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform2[2]
      }, extent, translateExtent);
    }, zoomAndPanHandler = zoom().on("start", panStartHandler).on("zoom", pannable ? panHandler : null).on("zoom.wheel", zoomable ? zoomHandler : null);
    selection2.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection2.on("zoom", null);
  }
  return {
    update,
    destroy,
    pointer
  };
}
const transformToViewport = (transform2) => ({
  x: transform2.x,
  y: transform2.y,
  zoom: transform2.k
}), viewportToTransform = ({ x: x2, y: y2, zoom: zoom2 }) => identity$1.translate(x2, y2).scale(zoom2), isWrappedWithClass = (event, className) => event.target.closest(`.${className}`), isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2), defaultEase = (t2) => ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2, getD3Transition = (selection2, duration2 = 0, ease2 = defaultEase, onEnd = () => {
}) => {
  const hasDuration = typeof duration2 == "number" && duration2 > 0;
  return hasDuration || onEnd(), hasDuration ? selection2.transition().duration(duration2).ease(ease2).on("end", onEnd) : selection2;
}, wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
function createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {
  return (event) => {
    if (isWrappedWithClass(event, noWheelClassName))
      return event.ctrlKey && event.preventDefault(), !1;
    event.preventDefault(), event.stopImmediatePropagation();
    const currentZoom = d3Selection.property("__zoom").k || 1;
    if (event.ctrlKey && zoomOnPinch) {
      const point2 = pointer(event), pinchDelta = wheelDelta(event), zoom2 = currentZoom * Math.pow(2, pinchDelta);
      d3Zoom.scaleTo(d3Selection, zoom2, point2, event);
      return;
    }
    const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize, deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    !isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical && (deltaX = event.deltaY * deltaNormalize, deltaY = 0), d3Zoom.translateBy(
      d3Selection,
      -(deltaX / currentZoom) * panOnScrollSpeed,
      -(deltaY / currentZoom) * panOnScrollSpeed,
      // @ts-ignore
      { internal: !0 }
    );
    const nextViewport = transformToViewport(d3Selection.property("__zoom"));
    clearTimeout(zoomPanValues.panScrollTimeout), zoomPanValues.isPanScrolling ? (onPanZoom?.(event, nextViewport), zoomPanValues.panScrollTimeout = setTimeout(() => {
      onPanZoomEnd?.(event, nextViewport), zoomPanValues.isPanScrolling = !1;
    }, 150)) : (zoomPanValues.isPanScrolling = !0, onPanZoomStart?.(event, nextViewport));
  };
}
function createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {
  return function(event, d) {
    const isWheel = event.type === "wheel", preventZoom = !preventScrolling && isWheel && !event.ctrlKey, hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);
    if (event.ctrlKey && isWheel && hasNoWheelClass && event.preventDefault(), preventZoom || hasNoWheelClass)
      return null;
    event.preventDefault(), d3ZoomHandler.call(this, event, d);
  };
}
function createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {
  return (event) => {
    if (event.sourceEvent?.internal)
      return;
    const viewport = transformToViewport(event.transform);
    zoomPanValues.mouseButton = event.sourceEvent?.button || 0, zoomPanValues.isZoomingOrPanning = !0, zoomPanValues.prevViewport = viewport, event.sourceEvent?.type === "mousedown" && onDraggingChange(!0), onPanZoomStart && onPanZoomStart?.(event.sourceEvent, viewport);
  };
}
function createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {
  return (event) => {
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0)), event.sourceEvent?.sync || onTransformChange([event.transform.x, event.transform.y, event.transform.k]), onPanZoom && !event.sourceEvent?.internal && onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));
  };
}
function createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {
  return (event) => {
    if (!event.sourceEvent?.internal && (zoomPanValues.isZoomingOrPanning = !1, onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent && onPaneContextMenu(event.sourceEvent), zoomPanValues.usedRightMouseButton = !1, onDraggingChange(!1), onPanZoomEnd)) {
      const viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport, clearTimeout(zoomPanValues.timerId), zoomPanValues.timerId = setTimeout(
        () => {
          onPanZoomEnd?.(event.sourceEvent, viewport);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        panOnScroll ? 150 : 0
      );
    }
  };
}
function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib: lib2, connectionInProgress }) {
  return (event) => {
    const zoomScroll = zoomActivationKeyPressed || zoomOnScroll, pinchZoom = zoomOnPinch && event.ctrlKey, isWheelEvent = event.type === "wheel";
    if (event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, `${lib2}-flow__node`) || isWrappedWithClass(event, `${lib2}-flow__edge`)))
      return !0;
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch || userSelectionActive || connectionInProgress && !isWheelEvent || isWrappedWithClass(event, noWheelClassName) && isWheelEvent || isWrappedWithClass(event, noPanClassName) && (!isWheelEvent || panOnScroll && isWheelEvent && !zoomActivationKeyPressed) || !zoomOnPinch && event.ctrlKey && isWheelEvent)
      return !1;
    if (!zoomOnPinch && event.type === "touchstart" && event.touches?.length > 1)
      return event.preventDefault(), !1;
    if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent || !panOnDrag && (event.type === "mousedown" || event.type === "touchstart") || Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown")
      return !1;
    const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    return (!event.ctrlKey || isWheelEvent) && buttonAllowed;
  };
}
function XYPanZoom({ domNode, minZoom, maxZoom, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {
  const zoomPanValues = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: {},
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, bbox = domNode.getBoundingClientRect(), d3ZoomInstance = zoom().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent), d3Selection = select(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp$1(viewport.zoom, minZoom, maxZoom)
  }, [
    [0, 0],
    [bbox.width, bbox.height]
  ], translateExtent);
  const d3ZoomHandler = d3Selection.on("wheel.zoom"), d3DblClickZoomHandler = d3Selection.on("dblclick.zoom");
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? interpolate$2 : interpolateZoom).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(!0)), transform2);
    }) : Promise.resolve(!1);
  }
  function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib: lib2, onTransformChange, connectionInProgress, paneClickDistance, selectionOnDrag }) {
    userSelectionActive && !zoomPanValues.isZoomingOrPanning && destroy();
    const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    d3ZoomInstance.clickDistance(selectionOnDrag ? 1 / 0 : !isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance);
    const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues,
      noWheelClassName,
      d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode,
      panOnScrollSpeed,
      zoomOnPinch,
      onPanZoomStart,
      onPanZoom,
      onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName,
      preventScrolling,
      d3ZoomHandler
    });
    if (d3Selection.on("wheel.zoom", wheelHandler, { passive: !1 }), !userSelectionActive) {
      const startHandler = createPanZoomStartHandler({
        zoomPanValues,
        onDraggingChange,
        onPanZoomStart
      });
      d3ZoomInstance.on("start", startHandler);
      const panZoomHandler = createPanZoomHandler({
        zoomPanValues,
        panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom,
        onTransformChange
      });
      d3ZoomInstance.on("zoom", panZoomHandler);
      const panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues,
        panOnDrag,
        panOnScroll,
        onPaneContextMenu,
        onPanZoomEnd,
        onDraggingChange
      });
      d3ZoomInstance.on("end", panZoomEndHandler);
    }
    const filter2 = createFilter({
      zoomActivationKeyPressed,
      panOnDrag,
      zoomOnScroll,
      panOnScroll,
      zoomOnDoubleClick,
      zoomOnPinch,
      userSelectionActive,
      noPanClassName,
      noWheelClassName,
      lib: lib2,
      connectionInProgress
    });
    d3ZoomInstance.filter(filter2), zoomOnDoubleClick ? d3Selection.on("dblclick.zoom", d3DblClickZoomHandler) : d3Selection.on("dblclick.zoom", null);
  }
  function destroy() {
    d3ZoomInstance.on("zoom", null);
  }
  async function setViewportConstrained(viewport2, extent, translateExtent2) {
    const nextTransform = viewportToTransform(viewport2), contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent2);
    return contrainedTransform && await setTransform(contrainedTransform), new Promise((resolve) => resolve(contrainedTransform));
  }
  async function setViewport(viewport2, options) {
    const nextTransform = viewportToTransform(viewport2);
    return await setTransform(nextTransform, options), new Promise((resolve) => resolve(nextTransform));
  }
  function syncViewport(viewport2) {
    if (d3Selection) {
      const nextTransform = viewportToTransform(viewport2), currentTransform = d3Selection.property("__zoom");
      (currentTransform.k !== viewport2.zoom || currentTransform.x !== viewport2.x || currentTransform.y !== viewport2.y) && d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: !0 });
    }
  }
  function getViewport() {
    const transform2 = d3Selection ? transform$2(d3Selection.node()) : { x: 0, y: 0, k: 1 };
    return { x: transform2.x, y: transform2.y, zoom: transform2.k };
  }
  function scaleTo(zoom2, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? interpolate$2 : interpolateZoom).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(!0)), zoom2);
    }) : Promise.resolve(!1);
  }
  function scaleBy(factor, options) {
    return d3Selection ? new Promise((resolve) => {
      d3ZoomInstance?.interpolate(options?.interpolate === "linear" ? interpolate$2 : interpolateZoom).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(!0)), factor);
    }) : Promise.resolve(!1);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance?.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent2) {
    d3ZoomInstance?.translateExtent(translateExtent2);
  }
  function setClickDistance(distance2) {
    const validDistance = !isNumeric(distance2) || distance2 < 0 ? 0 : distance2;
    d3ZoomInstance?.clickDistance(validDistance);
  }
  return {
    update,
    destroy,
    setViewport,
    setViewportConstrained,
    getViewport,
    scaleTo,
    scaleBy,
    setScaleExtent,
    setTranslateExtent,
    syncViewport,
    setClickDistance
  };
}
var ResizeControlVariant;
(function(ResizeControlVariant2) {
  ResizeControlVariant2.Line = "line", ResizeControlVariant2.Handle = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {
  const deltaWidth = width - prevWidth, deltaHeight = height - prevHeight, direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  return deltaWidth && affectsX && (direction[0] = direction[0] * -1), deltaHeight && affectsY && (direction[1] = direction[1] * -1), direction;
}
function getControlDirection(controlPosition) {
  const isHorizontal = controlPosition.includes("right") || controlPosition.includes("left"), isVertical = controlPosition.includes("bottom") || controlPosition.includes("top"), affectsX = controlPosition.includes("left"), affectsY = controlPosition.includes("top");
  return {
    isHorizontal,
    isVertical,
    affectsX,
    affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size2, minSize, maxSize) {
  return Math.max(0, minSize - size2, size2 - maxSize);
}
function xor(a2, b) {
  return a2 ? !b : b;
}
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  let { affectsX, affectsY } = controlDirection;
  const { isHorizontal, isVertical } = controlDirection, isDiagonal = isHorizontal && isVertical, { xSnapped, ySnapped } = pointerPosition, { minWidth, maxWidth, minHeight, maxHeight } = boundaries, { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio: aspectRatio2 } = startValues;
  let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0), distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  const newWidth = startWidth + (affectsX ? -distX : distX), newHeight = startHeight + (affectsY ? -distY : distY), originOffsetX = -nodeOrigin[0] * startWidth, originOffsetY = -nodeOrigin[1] * startHeight;
  let clampX = getSizeClamp(newWidth, minWidth, maxWidth), clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  if (extent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX < 0 ? xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]) : !affectsX && distX > 0 && (xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0])), affectsY && distY < 0 ? yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]) : !affectsY && distY > 0 && (yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (childExtent) {
    let xExtentClamp = 0, yExtentClamp = 0;
    affectsX && distX > 0 ? xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]) : !affectsX && distX < 0 && (xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0])), affectsY && distY > 0 ? yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]) : !affectsY && distY < 0 && (yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1])), clampX = Math.max(clampX, xExtentClamp), clampY = Math.max(clampY, yExtentClamp);
  }
  if (keepAspectRatio) {
    if (isHorizontal) {
      const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio2, minHeight, maxHeight) * aspectRatio2;
      if (clampX = Math.max(clampX, aspectHeightClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio2, extent[1][1]) * aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio2, extent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsX && !affectsY && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio2, childExtent[1][1]) * aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio2, childExtent[0][1]) * aspectRatio2, clampX = Math.max(clampX, aspectExtentClamp);
      }
    }
    if (isVertical) {
      const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio2, minWidth, maxWidth) / aspectRatio2;
      if (clampY = Math.max(clampY, aspectWidthClamp), extent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio2 + originOffsetX, extent[1][0]) / aspectRatio2 : aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2 + originOffsetX, extent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
      if (childExtent) {
        let aspectExtentClamp = 0;
        !affectsX && !affectsY || affectsY && !affectsX && isDiagonal ? aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio2, childExtent[1][0]) / aspectRatio2 : aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio2, childExtent[0][0]) / aspectRatio2, clampY = Math.max(clampY, aspectExtentClamp);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY), distX = distX + (distX < 0 ? clampX : -clampX), keepAspectRatio && (isDiagonal ? newWidth > newHeight * aspectRatio2 ? distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio2 : distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio2 : isHorizontal ? (distY = distX / aspectRatio2, affectsY = affectsX) : (distX = distY * aspectRatio2, affectsX = affectsY));
  const x2 = affectsX ? startX + distX : startX, y2 = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (affectsX ? -1 : 1) + x2,
    y: nodeOrigin[1] * distY * (affectsY ? -1 : 1) + y2
  };
}
const initPrevValues$1 = { width: 0, height: 0, x: 0, y: 0 }, initStartValues = {
  ...initPrevValues$1,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function nodeToParentExtent(node) {
  return [
    [0, 0],
    [node.measured.width, node.measured.height]
  ];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  const x2 = parent.position.x + child.position.x, y2 = parent.position.y + child.position.y, width = child.measured.width ?? 0, height = child.measured.height ?? 0, originOffsetX = nodeOrigin[0] * width, originOffsetY = nodeOrigin[1] * height;
  return [
    [x2 - originOffsetX, y2 - originOffsetY],
    [x2 + width - originOffsetX, y2 + height - originOffsetY]
  ];
}
function XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {
  const selection2 = select(domNode);
  let params = {
    controlDirection: getControlDirection("bottom-right"),
    boundaries: {
      minWidth: 0,
      minHeight: 0,
      maxWidth: Number.MAX_VALUE,
      maxHeight: Number.MAX_VALUE
    },
    resizeDirection: void 0,
    keepAspectRatio: !1
  };
  function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize }) {
    let prevValues = { ...initPrevValues$1 }, startValues = { ...initStartValues };
    params = {
      boundaries,
      resizeDirection,
      keepAspectRatio,
      controlDirection: getControlDirection(controlPosition)
    };
    let node, containerBounds = null, childNodes = [], parentNode, parentExtent, childExtent, resizeDetected = !1;
    const dragHandler = drag$1().on("start", (event) => {
      const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();
      if (node = nodeLookup.get(nodeId), !node)
        return;
      containerBounds = paneDomNode?.getBoundingClientRect() ?? null;
      const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      });
      prevValues = {
        width: node.measured.width ?? 0,
        height: node.measured.height ?? 0,
        x: node.position.x ?? 0,
        y: node.position.y ?? 0
      }, startValues = {
        ...prevValues,
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      }, parentNode = void 0, node.parentId && (node.extent === "parent" || node.expandParent) && (parentNode = nodeLookup.get(node.parentId), parentExtent = parentNode && node.extent === "parent" ? nodeToParentExtent(parentNode) : void 0), childNodes = [], childExtent = void 0;
      for (const [childId, child] of nodeLookup)
        if (child.parentId === nodeId && (childNodes.push({
          id: childId,
          position: { ...child.position },
          extent: child.extent
        }), child.extent === "parent" || child.expandParent)) {
          const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);
          childExtent ? childExtent = [
            [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],
            [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]
          ] : childExtent = extent;
        }
      onResizeStart?.(event, { ...prevValues });
    }).on("drag", (event) => {
      const { transform: transform2, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems(), pointerPosition = getPointerPosition(event.sourceEvent, {
        transform: transform2,
        snapGrid,
        snapToGrid,
        containerBounds
      }), childChanges = [];
      if (!node)
        return;
      const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues, change2 = {}, nodeOrigin = node.origin ?? storeNodeOrigin, { width, height, x: x2, y: y2 } = getDimensionsAfterResize(startValues, params.controlDirection, pointerPosition, params.boundaries, params.keepAspectRatio, nodeOrigin, parentExtent, childExtent), isWidthChange = width !== prevWidth, isHeightChange = height !== prevHeight, isXPosChange = x2 !== prevX && isWidthChange, isYPosChange = y2 !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange)
        return;
      if ((isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) && (change2.x = isXPosChange ? x2 : prevValues.x, change2.y = isYPosChange ? y2 : prevValues.y, prevValues.x = change2.x, prevValues.y = change2.y, childNodes.length > 0)) {
        const xChange = x2 - prevX, yChange = y2 - prevY;
        for (const childNode of childNodes)
          childNode.position = {
            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
          }, childChanges.push(childNode);
      }
      if ((isWidthChange || isHeightChange) && (change2.width = isWidthChange && (!params.resizeDirection || params.resizeDirection === "horizontal") ? width : prevValues.width, change2.height = isHeightChange && (!params.resizeDirection || params.resizeDirection === "vertical") ? height : prevValues.height, prevValues.width = change2.width, prevValues.height = change2.height), parentNode && node.expandParent) {
        const xLimit = nodeOrigin[0] * (change2.width ?? 0);
        change2.x && change2.x < xLimit && (prevValues.x = xLimit, startValues.x = startValues.x - (change2.x - xLimit));
        const yLimit = nodeOrigin[1] * (change2.height ?? 0);
        change2.y && change2.y < yLimit && (prevValues.y = yLimit, startValues.y = startValues.y - (change2.y - yLimit));
      }
      const direction = getResizeDirection({
        width: prevValues.width,
        prevWidth,
        height: prevValues.height,
        prevHeight,
        affectsX: params.controlDirection.affectsX,
        affectsY: params.controlDirection.affectsY
      }), nextValues = { ...prevValues, direction };
      shouldResize?.(event, nextValues) !== !1 && (resizeDetected = !0, onResize?.(event, nextValues), onChange(change2, childChanges));
    }).on("end", (event) => {
      resizeDetected && (onResizeEnd?.(event, { ...prevValues }), onEnd?.({ ...prevValues }), resizeDetected = !1);
    });
    selection2.call(dragHandler);
  }
  function destroy() {
    selection2.on(".drag", null);
  }
  return {
    update,
    destroy
  };
}
const __vite_import_meta_env__ = {}, createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set(), setState = (partial2, replace) => {
    const nextState = typeof partial2 == "function" ? partial2(state) : partial2;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = replace ?? (typeof nextState != "object" || nextState === null) ? nextState : Object.assign({}, state, nextState), listeners.forEach((listener) => listener(state, previousState));
    }
  }, getState = () => state, api = { setState, getState, getInitialState: () => initialState2, subscribe: (listener) => (listeners.add(listener), () => listeners.delete(listener)), destroy: () => {
    (__vite_import_meta_env__ ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), listeners.clear();
  } }, initialState2 = state = createState2(setState, getState, api);
  return api;
}, createStore$1 = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl, { useDebugValue } = React__default, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports, identity = (arg) => arg;
function useStoreWithEqualityFn(api, selector2 = identity, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector2,
    equalityFn
  );
  return useDebugValue(slice), slice;
}
const createWithEqualityFnImpl = (createState2, defaultEqualityFn) => {
  const api = createStore$1(createState2), useBoundStoreWithEqualityFn = (selector2, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector2, equalityFn);
  return Object.assign(useBoundStoreWithEqualityFn, api), useBoundStoreWithEqualityFn;
}, createWithEqualityFn = (createState2, defaultEqualityFn) => createState2 ? createWithEqualityFnImpl(createState2, defaultEqualityFn) : createWithEqualityFnImpl;
function shallow$1(objA, objB) {
  if (Object.is(objA, objB))
    return !0;
  if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
    return !1;
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return !1;
    for (const [key, value] of objA)
      if (!Object.is(value, objB.get(key)))
        return !1;
    return !0;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return !1;
    for (const value of objA)
      if (!objB.has(value))
        return !1;
    return !0;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length)
    return !1;
  for (const keyA of keysA)
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA]))
      return !1;
  return !0;
}
const StoreContext = createContext(null), Provider$1 = StoreContext.Provider, zustandErrorMessage = errorMessages.error001();
function useStore$1(selector2, equalityFn) {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useStoreWithEqualityFn(store, selector2, equalityFn);
}
function useStoreApi() {
  const store = useContext(StoreContext);
  if (store === null)
    throw new Error(zustandErrorMessage);
  return useMemo(() => ({
    getState: store.getState,
    setState: store.setState,
    subscribe: store.subscribe
  }), [store]);
}
const style = { display: "none" }, ariaLiveStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, ARIA_NODE_DESC_KEY = "react-flow__node-desc", ARIA_EDGE_DESC_KEY = "react-flow__edge-desc", ARIA_LIVE_MESSAGE = "react-flow__aria-live", ariaLiveSelector = (s) => s.ariaLiveMessage, ariaLabelConfigSelector = (s) => s.ariaLabelConfig;
function AriaLiveMessage({ rfId }) {
  const ariaLiveMessage = useStore$1(ariaLiveSelector);
  return jsx("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle, children: ariaLiveMessage });
}
function A11yDescriptions({ rfId, disableKeyboardA11y }) {
  const ariaLabelConfig = useStore$1(ariaLabelConfigSelector);
  return jsxs(Fragment$1, { children: [jsx("div", { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style, children: disableKeyboardA11y ? ariaLabelConfig["node.a11yDescription.default"] : ariaLabelConfig["node.a11yDescription.keyboardDisabled"] }), jsx("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style, children: ariaLabelConfig["edge.a11yDescription.default"] }), !disableKeyboardA11y && jsx(AriaLiveMessage, { rfId })] });
}
const Panel = forwardRef(({ position = "top-left", children: children2, className, style: style2, ...rest }, ref) => {
  const positionClasses = `${position}`.split("-");
  return jsx("div", { className: cc(["react-flow__panel", className, ...positionClasses]), style: style2, ref, ...rest, children: children2 });
});
Panel.displayName = "Panel";
function Attribution({ proOptions, position = "bottom-right" }) {
  return proOptions?.hideAttribution ? null : jsx(Panel, { position, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const selector$m = (s) => {
  const selectedNodes = [], selectedEdges = [];
  for (const [, node] of s.nodeLookup)
    node.selected && selectedNodes.push(node.internals.userNode);
  for (const [, edge] of s.edgeLookup)
    edge.selected && selectedEdges.push(edge);
  return { selectedNodes, selectedEdges };
}, selectId = (obj) => obj.id;
function areEqual(a2, b) {
  return shallow$1(a2.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && shallow$1(a2.selectedEdges.map(selectId), b.selectedEdges.map(selectId));
}
function SelectionListenerInner({ onSelectionChange }) {
  const store = useStoreApi(), { selectedNodes, selectedEdges } = useStore$1(selector$m, areEqual);
  return useEffect(() => {
    const params = { nodes: selectedNodes, edges: selectedEdges };
    onSelectionChange?.(params), store.getState().onSelectionChangeHandlers.forEach((fn) => fn(params));
  }, [selectedNodes, selectedEdges, onSelectionChange]), null;
}
const changeSelector = (s) => !!s.onSelectionChangeHandlers;
function SelectionListener({ onSelectionChange }) {
  const storeHasSelectionChangeHandlers = useStore$1(changeSelector);
  return onSelectionChange || storeHasSelectionChangeHandlers ? jsx(SelectionListenerInner, { onSelectionChange }) : null;
}
const defaultNodeOrigin = [0, 0], defaultViewport = { x: 0, y: 0, zoom: 1 }, reactFlowFieldsToTrack = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "ariaLabelConfig",
  "zIndexMode"
], fieldsToTrack = [...reactFlowFieldsToTrack, "rfId"], selector$l = (s) => ({
  setNodes: s.setNodes,
  setEdges: s.setEdges,
  setMinZoom: s.setMinZoom,
  setMaxZoom: s.setMaxZoom,
  setTranslateExtent: s.setTranslateExtent,
  setNodeExtent: s.setNodeExtent,
  reset: s.reset,
  setDefaultNodesAndEdges: s.setDefaultNodesAndEdges
}), initPrevValues = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: infiniteExtent,
  nodeOrigin: defaultNodeOrigin,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1"
};
function StoreUpdater(props) {
  const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges } = useStore$1(selector$l, shallow$1), store = useStoreApi();
  useEffect(() => (setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges), () => {
    previousFields.current = initPrevValues, reset();
  }), []);
  const previousFields = useRef(initPrevValues);
  return useEffect(
    () => {
      for (const fieldName of fieldsToTrack) {
        const fieldValue = props[fieldName], previousFieldValue = previousFields.current[fieldName];
        fieldValue !== previousFieldValue && (typeof props[fieldName] > "u" || (fieldName === "nodes" ? setNodes(fieldValue) : fieldName === "edges" ? setEdges(fieldValue) : fieldName === "minZoom" ? setMinZoom(fieldValue) : fieldName === "maxZoom" ? setMaxZoom(fieldValue) : fieldName === "translateExtent" ? setTranslateExtent(fieldValue) : fieldName === "nodeExtent" ? setNodeExtent(fieldValue) : fieldName === "ariaLabelConfig" ? store.setState({ ariaLabelConfig: mergeAriaLabelConfig(fieldValue) }) : fieldName === "fitView" ? store.setState({ fitViewQueued: fieldValue }) : fieldName === "fitViewOptions" ? store.setState({ fitViewOptions: fieldValue }) : store.setState({ [fieldName]: fieldValue })));
      }
      previousFields.current = props;
    },
    // Only re-run the effect if one of the fields we track changes
    fieldsToTrack.map((fieldName) => props[fieldName])
  ), null;
}
function getMediaQuery() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function useColorModeClass(colorMode) {
  const [colorModeClass, setColorModeClass] = useState(colorMode === "system" ? null : colorMode);
  return useEffect(() => {
    if (colorMode !== "system") {
      setColorModeClass(colorMode);
      return;
    }
    const mediaQuery = getMediaQuery(), updateColorModeClass = () => setColorModeClass(mediaQuery?.matches ? "dark" : "light");
    return updateColorModeClass(), mediaQuery?.addEventListener("change", updateColorModeClass), () => {
      mediaQuery?.removeEventListener("change", updateColorModeClass);
    };
  }, [colorMode]), colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? "dark" : "light";
}
const defaultDoc = typeof document < "u" ? document : null;
function useKeyPress(keyCode = null, options = { target: defaultDoc, actInsideInputWithModifier: !0 }) {
  const [keyPressed, setKeyPressed] = useState(!1), modifierPressed = useRef(!1), pressedKeys = useRef(/* @__PURE__ */ new Set([])), [keyCodes, keysToWatch] = useMemo(() => {
    if (keyCode !== null) {
      const keys2 = (Array.isArray(keyCode) ? keyCode : [keyCode]).filter((kc) => typeof kc == "string").map((kc) => kc.replace("+", `
`).replace(`

`, `
+`).split(`
`)), keysFlat = keys2.reduce((res, item) => res.concat(...item), []);
      return [keys2, keysFlat];
    }
    return [[], []];
  }, [keyCode]);
  return useEffect(() => {
    const target = options?.target ?? defaultDoc, actInsideInputWithModifier = options?.actInsideInputWithModifier ?? !0;
    if (keyCode !== null) {
      const downHandler = (event) => {
        if (modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey, (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && isInputDOMNode(event))
          return !1;
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        if (pressedKeys.current.add(event[keyOrCode]), isMatchingKey(keyCodes, pressedKeys.current, !1)) {
          const target2 = event.composedPath?.()?.[0] || event.target, isInteractiveElement = target2?.nodeName === "BUTTON" || target2?.nodeName === "A";
          options.preventDefault !== !1 && (modifierPressed.current || !isInteractiveElement) && event.preventDefault(), setKeyPressed(!0);
        }
      }, upHandler = (event) => {
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        isMatchingKey(keyCodes, pressedKeys.current, !0) ? (setKeyPressed(!1), pressedKeys.current.clear()) : pressedKeys.current.delete(event[keyOrCode]), event.key === "Meta" && pressedKeys.current.clear(), modifierPressed.current = !1;
      }, resetHandler = () => {
        pressedKeys.current.clear(), setKeyPressed(!1);
      };
      return target?.addEventListener("keydown", downHandler), target?.addEventListener("keyup", upHandler), window.addEventListener("blur", resetHandler), window.addEventListener("contextmenu", resetHandler), () => {
        target?.removeEventListener("keydown", downHandler), target?.removeEventListener("keyup", upHandler), window.removeEventListener("blur", resetHandler), window.removeEventListener("contextmenu", resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]), keyPressed;
}
function isMatchingKey(keyCodes, pressedKeys, isUp) {
  return keyCodes.filter((keys2) => isUp || keys2.length === pressedKeys.size).some((keys2) => keys2.every((k) => pressedKeys.has(k)));
}
function useKeyOrCode(eventCode, keysToWatch) {
  return keysToWatch.includes(eventCode) ? "code" : "key";
}
const useViewportHelper = () => {
  const store = useStoreApi();
  return useMemo(() => ({
    zoomIn: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1.2, { duration: options?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleBy(1 / 1.2, { duration: options?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (zoomLevel, options) => {
      const { panZoom } = store.getState();
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => store.getState().transform[2],
    setViewport: async (viewport, options) => {
      const { transform: [tX, tY, tZoom], panZoom } = store.getState();
      return panZoom ? (await panZoom.setViewport({
        x: viewport.x ?? tX,
        y: viewport.y ?? tY,
        zoom: viewport.zoom ?? tZoom
      }, options), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [x2, y2, zoom2] = store.getState().transform;
      return { x: x2, y: y2, zoom: zoom2 };
    },
    setCenter: async (x2, y2, options) => store.getState().setCenter(x2, y2, options),
    fitBounds: async (bounds, options) => {
      const { width, height, minZoom, maxZoom, panZoom } = store.getState(), viewport = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);
      return panZoom ? (await panZoom.setViewport(viewport, {
        duration: options?.duration,
        ease: options?.ease,
        interpolate: options?.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (clientPosition, options = {}) => {
      const { transform: transform2, snapGrid, snapToGrid, domNode } = store.getState();
      if (!domNode)
        return clientPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), correctedPosition = {
        x: clientPosition.x - domX,
        y: clientPosition.y - domY
      }, _snapGrid = options.snapGrid ?? snapGrid, _snapToGrid = options.snapToGrid ?? snapToGrid;
      return pointToRendererPoint(correctedPosition, transform2, _snapToGrid, _snapGrid);
    },
    flowToScreenPosition: (flowPosition) => {
      const { transform: transform2, domNode } = store.getState();
      if (!domNode)
        return flowPosition;
      const { x: domX, y: domY } = domNode.getBoundingClientRect(), rendererPosition = rendererPointToPoint(flowPosition, transform2);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    }
  }), []);
};
function applyChanges(changes, elements) {
  const updatedElements = [], changesMap = /* @__PURE__ */ new Map(), addItemChanges = [];
  for (const change2 of changes)
    if (change2.type === "add") {
      addItemChanges.push(change2);
      continue;
    } else if (change2.type === "remove" || change2.type === "replace")
      changesMap.set(change2.id, [change2]);
    else {
      const elementChanges = changesMap.get(change2.id);
      elementChanges ? elementChanges.push(change2) : changesMap.set(change2.id, [change2]);
    }
  for (const element of elements) {
    const changes2 = changesMap.get(element.id);
    if (!changes2) {
      updatedElements.push(element);
      continue;
    }
    if (changes2[0].type === "remove")
      continue;
    if (changes2[0].type === "replace") {
      updatedElements.push({ ...changes2[0].item });
      continue;
    }
    const updatedElement = { ...element };
    for (const change2 of changes2)
      applyChange(change2, updatedElement);
    updatedElements.push(updatedElement);
  }
  return addItemChanges.length && addItemChanges.forEach((change2) => {
    change2.index !== void 0 ? updatedElements.splice(change2.index, 0, { ...change2.item }) : updatedElements.push({ ...change2.item });
  }), updatedElements;
}
function applyChange(change2, element) {
  switch (change2.type) {
    case "select": {
      element.selected = change2.selected;
      break;
    }
    case "position": {
      typeof change2.position < "u" && (element.position = change2.position), typeof change2.dragging < "u" && (element.dragging = change2.dragging);
      break;
    }
    case "dimensions": {
      typeof change2.dimensions < "u" && (element.measured = {
        ...change2.dimensions
      }, change2.setAttributes && ((change2.setAttributes === !0 || change2.setAttributes === "width") && (element.width = change2.dimensions.width), (change2.setAttributes === !0 || change2.setAttributes === "height") && (element.height = change2.dimensions.height))), typeof change2.resizing == "boolean" && (element.resizing = change2.resizing);
      break;
    }
  }
}
function applyNodeChanges(changes, nodes) {
  return applyChanges(changes, nodes);
}
function applyEdgeChanges(changes, edges) {
  return applyChanges(changes, edges);
}
function createSelectionChange(id2, selected2) {
  return {
    id: id2,
    type: "select",
    selected: selected2
  };
}
function getSelectionChanges(items, selectedIds = /* @__PURE__ */ new Set(), mutateItem = !1) {
  const changes = [];
  for (const [id2, item] of items) {
    const willBeSelected = selectedIds.has(id2);
    !(item.selected === void 0 && !willBeSelected) && item.selected !== willBeSelected && (mutateItem && (item.selected = willBeSelected), changes.push(createSelectionChange(item.id, willBeSelected)));
  }
  return changes;
}
function getElementsDiffChanges({ items = [], lookup }) {
  const changes = [], itemsLookup = new Map(items.map((item) => [item.id, item]));
  for (const [index2, item] of items.entries()) {
    const lookupItem = lookup.get(item.id), storeItem = lookupItem?.internals?.userNode ?? lookupItem;
    storeItem !== void 0 && storeItem !== item && changes.push({ id: item.id, item, type: "replace" }), storeItem === void 0 && changes.push({ item, type: "add", index: index2 });
  }
  for (const [id2] of lookup)
    itemsLookup.get(id2) === void 0 && changes.push({ id: id2, type: "remove" });
  return changes;
}
function elementToRemoveChange(item) {
  return {
    id: item.id,
    type: "remove"
  };
}
const isNode = (element) => isNodeBase(element), isEdge = (element) => isEdgeBase(element);
function fixedForwardRef(render) {
  return forwardRef(render);
}
const useIsomorphicLayoutEffect$1 = typeof window < "u" ? useLayoutEffect$1 : useEffect;
function useQueue(runQueue) {
  const [serial, setSerial] = useState(BigInt(0)), [queue] = useState(() => createQueue(() => setSerial((n2) => n2 + BigInt(1))));
  return useIsomorphicLayoutEffect$1(() => {
    const queueItems = queue.get();
    queueItems.length && (runQueue(queueItems), queue.reset());
  }, [serial]), queue;
}
function createQueue(cb) {
  let queue = [];
  return {
    get: () => queue,
    reset: () => {
      queue = [];
    },
    push: (item) => {
      queue.push(item), cb();
    }
  };
}
const BatchContext = createContext(null);
function BatchProvider({ children: children2 }) {
  const store = useStoreApi(), nodeQueueHandler = useCallback((queueItems) => {
    const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued, onNodesChangeMiddlewareMap } = store.getState();
    let next = nodes;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    let changes = getElementsDiffChanges({
      items: next,
      lookup: nodeLookup
    });
    for (const middleware of onNodesChangeMiddlewareMap.values())
      changes = middleware(changes);
    hasDefaultNodes && setNodes(next), changes.length > 0 ? onNodesChange?.(changes) : fitViewQueued && window.requestAnimationFrame(() => {
      const { fitViewQueued: fitViewQueued2, nodes: nodes2, setNodes: setNodes2 } = store.getState();
      fitViewQueued2 && setNodes2(nodes2);
    });
  }, []), nodeQueue = useQueue(nodeQueueHandler), edgeQueueHandler = useCallback((queueItems) => {
    const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();
    let next = edges;
    for (const payload of queueItems)
      next = typeof payload == "function" ? payload(next) : payload;
    hasDefaultEdges ? setEdges(next) : onEdgesChange && onEdgesChange(getElementsDiffChanges({
      items: next,
      lookup: edgeLookup
    }));
  }, []), edgeQueue = useQueue(edgeQueueHandler), value = useMemo(() => ({ nodeQueue, edgeQueue }), []);
  return jsx(BatchContext.Provider, { value, children: children2 });
}
function useBatchContext() {
  const batchContext = useContext(BatchContext);
  if (!batchContext)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return batchContext;
}
const selector$k = (s) => !!s.panZoom;
function useReactFlow() {
  const viewportHelper = useViewportHelper(), store = useStoreApi(), batchContext = useBatchContext(), viewportInitialized = useStore$1(selector$k), generalHelper = useMemo(() => {
    const getInternalNode = (id2) => store.getState().nodeLookup.get(id2), setNodes = (payload) => {
      batchContext.nodeQueue.push(payload);
    }, setEdges = (payload) => {
      batchContext.edgeQueue.push(payload);
    }, getNodeRect = (node) => {
      const { nodeLookup, nodeOrigin } = store.getState(), nodeToUse = isNode(node) ? node : nodeLookup.get(node.id), position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position, nodeWithPosition = {
        ...nodeToUse,
        position,
        width: nodeToUse.measured?.width ?? nodeToUse.width,
        height: nodeToUse.measured?.height ?? nodeToUse.height
      };
      return nodeToRect(nodeWithPosition);
    }, updateNode = (id2, nodeUpdate, options = { replace: !1 }) => {
      setNodes((prevNodes) => prevNodes.map((node) => {
        if (node.id === id2) {
          const nextNode = typeof nodeUpdate == "function" ? nodeUpdate(node) : nodeUpdate;
          return options.replace && isNode(nextNode) ? nextNode : { ...node, ...nextNode };
        }
        return node;
      }));
    }, updateEdge = (id2, edgeUpdate, options = { replace: !1 }) => {
      setEdges((prevEdges) => prevEdges.map((edge) => {
        if (edge.id === id2) {
          const nextEdge = typeof edgeUpdate == "function" ? edgeUpdate(edge) : edgeUpdate;
          return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
        }
        return edge;
      }));
    };
    return {
      getNodes: () => store.getState().nodes.map((n2) => ({ ...n2 })),
      getNode: (id2) => getInternalNode(id2)?.internals.userNode,
      getInternalNode,
      getEdges: () => {
        const { edges = [] } = store.getState();
        return edges.map((e2) => ({ ...e2 }));
      },
      getEdge: (id2) => store.getState().edgeLookup.get(id2),
      setNodes,
      setEdges,
      addNodes: (payload) => {
        const newNodes = Array.isArray(payload) ? payload : [payload];
        batchContext.nodeQueue.push((nodes) => [...nodes, ...newNodes]);
      },
      addEdges: (payload) => {
        const newEdges = Array.isArray(payload) ? payload : [payload];
        batchContext.edgeQueue.push((edges) => [...edges, ...newEdges]);
      },
      toObject: () => {
        const { nodes = [], edges = [], transform: transform2 } = store.getState(), [x2, y2, zoom2] = transform2;
        return {
          nodes: nodes.map((n2) => ({ ...n2 })),
          edges: edges.map((e2) => ({ ...e2 })),
          viewport: {
            x: x2,
            y: y2,
            zoom: zoom2
          }
        };
      },
      deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] }) => {
        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState(), { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
          nodesToRemove,
          edgesToRemove,
          nodes,
          edges,
          onBeforeDelete
        }), hasMatchingEdges = matchingEdges.length > 0, hasMatchingNodes = matchingNodes.length > 0;
        if (hasMatchingEdges) {
          const edgeChanges = matchingEdges.map(elementToRemoveChange);
          onEdgesDelete?.(matchingEdges), triggerEdgeChanges(edgeChanges);
        }
        if (hasMatchingNodes) {
          const nodeChanges = matchingNodes.map(elementToRemoveChange);
          onNodesDelete?.(matchingNodes), triggerNodeChanges(nodeChanges);
        }
        return (hasMatchingNodes || hasMatchingEdges) && onDelete?.({ nodes: matchingNodes, edges: matchingEdges }), { deletedNodes: matchingNodes, deletedEdges: matchingEdges };
      },
      /**
       * Partial is defined as "the 2 nodes/areas are intersecting partially".
       * If a is contained in b or b is contained in a, they are both
       * considered fully intersecting.
       */
      getIntersectingNodes: (nodeOrRect, partially = !0, nodes) => {
        const isRect = isRectObject(nodeOrRect), nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect), hasNodesOption = nodes !== void 0;
        return nodeRect ? (nodes || store.getState().nodes).filter((n2) => {
          const internalNode = store.getState().nodeLookup.get(n2.id);
          if (internalNode && !isRect && (n2.id === nodeOrRect.id || !internalNode.internals.positionAbsolute))
            return !1;
          const currNodeRect = nodeToRect(hasNodesOption ? n2 : internalNode), overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
          return partially && overlappingArea > 0 || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;
        }) : [];
      },
      isNodeIntersecting: (nodeOrRect, area, partially = !0) => {
        const nodeRect = isRectObject(nodeOrRect) ? nodeOrRect : getNodeRect(nodeOrRect);
        if (!nodeRect)
          return !1;
        const overlappingArea = getOverlappingArea(nodeRect, area);
        return partially && overlappingArea > 0 || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;
      },
      updateNode,
      updateNodeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateNode(id2, (node) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(node) : dataUpdate;
          return options.replace ? { ...node, data: nextData } : { ...node, data: { ...node.data, ...nextData } };
        }, options);
      },
      updateEdge,
      updateEdgeData: (id2, dataUpdate, options = { replace: !1 }) => {
        updateEdge(id2, (edge) => {
          const nextData = typeof dataUpdate == "function" ? dataUpdate(edge) : dataUpdate;
          return options.replace ? { ...edge, data: nextData } : { ...edge, data: { ...edge.data, ...nextData } };
        }, options);
      },
      getNodesBounds: (nodes) => {
        const { nodeLookup, nodeOrigin } = store.getState();
        return getNodesBounds(nodes, { nodeLookup, nodeOrigin });
      },
      getHandleConnections: ({ type, id: id2, nodeId }) => Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id2 ? `-${id2}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type, handleId, nodeId }) => Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ""}`)?.values() ?? []),
      fitView: async (options) => {
        const fitViewResolver = store.getState().fitViewResolver ?? withResolvers();
        return store.setState({ fitViewQueued: !0, fitViewOptions: options, fitViewResolver }), batchContext.nodeQueue.push((nodes) => [...nodes]), fitViewResolver.promise;
      }
    };
  }, []);
  return useMemo(() => ({
    ...generalHelper,
    ...viewportHelper,
    viewportInitialized
  }), [viewportInitialized]);
}
const selected = (item) => item.selected, win$1 = typeof window < "u" ? window : void 0;
function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {
  const store = useStoreApi(), { deleteElements } = useReactFlow(), deleteKeyPressed = useKeyPress(deleteKeyCode, { actInsideInputWithModifier: !1 }), multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, { target: win$1 });
  useEffect(() => {
    if (deleteKeyPressed) {
      const { edges, nodes } = store.getState();
      deleteElements({ nodes: nodes.filter(selected), edges: edges.filter(selected) }), store.setState({ nodesSelectionActive: !1 });
    }
  }, [deleteKeyPressed]), useEffect(() => {
    store.setState({ multiSelectionActive: multiSelectionKeyPressed });
  }, [multiSelectionKeyPressed]);
}
function useResizeHandler(domNode) {
  const store = useStoreApi();
  useEffect(() => {
    const updateDimensions = () => {
      if (!domNode.current || !(domNode.current.checkVisibility?.() ?? !0))
        return !1;
      const size2 = getDimensions(domNode.current);
      (size2.height === 0 || size2.width === 0) && store.getState().onError?.("004", errorMessages.error004()), store.setState({ width: size2.width || 500, height: size2.height || 500 });
    };
    if (domNode.current) {
      updateDimensions(), window.addEventListener("resize", updateDimensions);
      const resizeObserver = new ResizeObserver(() => updateDimensions());
      return resizeObserver.observe(domNode.current), () => {
        window.removeEventListener("resize", updateDimensions), resizeObserver && domNode.current && resizeObserver.unobserve(domNode.current);
      };
    }
  }, []);
}
const containerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, selector$j = (s) => ({
  userSelectionActive: s.userSelectionActive,
  lib: s.lib,
  connectionInProgress: s.connection.inProgress
});
function ZoomPane({ onPaneContextMenu, zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = !0, children: children2, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, selectionOnDrag }) {
  const store = useStoreApi(), zoomPane = useRef(null), { userSelectionActive, lib: lib2, connectionInProgress } = useStore$1(selector$j, shallow$1), zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode), panZoom = useRef();
  useResizeHandler(zoomPane);
  const onTransformChange = useCallback((transform2) => {
    onViewportChange?.({ x: transform2[0], y: transform2[1], zoom: transform2[2] }), isControlledViewport || store.setState({ transform: transform2 });
  }, [onViewportChange, isControlledViewport]);
  return useEffect(() => {
    if (zoomPane.current) {
      panZoom.current = XYPanZoom({
        domNode: zoomPane.current,
        minZoom,
        maxZoom,
        translateExtent,
        viewport: defaultViewport2,
        onDraggingChange: (paneDragging) => store.setState({ paneDragging }),
        onPanZoomStart: (event, vp) => {
          const { onViewportChangeStart, onMoveStart } = store.getState();
          onMoveStart?.(event, vp), onViewportChangeStart?.(vp);
        },
        onPanZoom: (event, vp) => {
          const { onViewportChange: onViewportChange2, onMove } = store.getState();
          onMove?.(event, vp), onViewportChange2?.(vp);
        },
        onPanZoomEnd: (event, vp) => {
          const { onViewportChangeEnd, onMoveEnd } = store.getState();
          onMoveEnd?.(event, vp), onViewportChangeEnd?.(vp);
        }
      });
      const { x: x2, y: y2, zoom: zoom2 } = panZoom.current.getViewport();
      return store.setState({
        panZoom: panZoom.current,
        transform: [x2, y2, zoom2],
        domNode: zoomPane.current.closest(".react-flow")
      }), () => {
        panZoom.current?.destroy();
      };
    }
  }, []), useEffect(() => {
    panZoom.current?.update({
      onPaneContextMenu,
      zoomOnScroll,
      zoomOnPinch,
      panOnScroll,
      panOnScrollSpeed,
      panOnScrollMode,
      zoomOnDoubleClick,
      panOnDrag,
      zoomActivationKeyPressed,
      preventScrolling,
      noPanClassName,
      userSelectionActive,
      noWheelClassName,
      lib: lib2,
      onTransformChange,
      connectionInProgress,
      selectionOnDrag,
      paneClickDistance
    });
  }, [
    onPaneContextMenu,
    zoomOnScroll,
    zoomOnPinch,
    panOnScroll,
    panOnScrollSpeed,
    panOnScrollMode,
    zoomOnDoubleClick,
    panOnDrag,
    zoomActivationKeyPressed,
    preventScrolling,
    noPanClassName,
    userSelectionActive,
    noWheelClassName,
    lib2,
    onTransformChange,
    connectionInProgress,
    selectionOnDrag,
    paneClickDistance
  ]), jsx("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle, children: children2 });
}
const selector$i = (s) => ({
  userSelectionActive: s.userSelectionActive,
  userSelectionRect: s.userSelectionRect
});
function UserSelection() {
  const { userSelectionActive, userSelectionRect } = useStore$1(selector$i, shallow$1);
  return userSelectionActive && userSelectionRect ? jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: userSelectionRect.width,
    height: userSelectionRect.height,
    transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`
  } }) : null;
}
const wrapHandler = (handler, containerRef) => (event) => {
  event.target === containerRef.current && handler?.(event);
}, selector$h = (s) => ({
  userSelectionActive: s.userSelectionActive,
  elementsSelectable: s.elementsSelectable,
  connectionInProgress: s.connection.inProgress,
  dragging: s.paneDragging
});
function Pane({ isSelecting, selectionKeyPressed, selectionMode = SelectionMode.Full, panOnDrag, paneClickDistance, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children: children2 }) {
  const store = useStoreApi(), { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore$1(selector$h, shallow$1), isSelectionEnabled = elementsSelectable && (isSelecting || userSelectionActive), container = useRef(null), containerBounds = useRef(), selectedNodeIds = useRef(/* @__PURE__ */ new Set()), selectedEdgeIds = useRef(/* @__PURE__ */ new Set()), selectionInProgress = useRef(!1), onClick = (event) => {
    if (selectionInProgress.current || connectionInProgress) {
      selectionInProgress.current = !1;
      return;
    }
    onPaneClick?.(event), store.getState().resetSelectedElements(), store.setState({ nodesSelectionActive: !1 });
  }, onContextMenu = (event) => {
    if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {
      event.preventDefault();
      return;
    }
    onPaneContextMenu?.(event);
  }, onWheel = onPaneScroll ? (event) => onPaneScroll(event) : void 0, onClickCapture = (event) => {
    selectionInProgress.current && (event.stopPropagation(), selectionInProgress.current = !1);
  }, onPointerDownCapture = (event) => {
    const { domNode } = store.getState();
    if (containerBounds.current = domNode?.getBoundingClientRect(), !containerBounds.current)
      return;
    const eventTargetIsContainer = event.target === container.current;
    if (!eventTargetIsContainer && !!event.target.closest(".nokey") || !isSelecting || !(selectionOnDrag && eventTargetIsContainer || selectionKeyPressed) || event.button !== 0 || !event.isPrimary)
      return;
    event.target?.setPointerCapture?.(event.pointerId), selectionInProgress.current = !1;
    const { x: x2, y: y2 } = getEventPosition(event.nativeEvent, containerBounds.current);
    store.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: x2,
        startY: y2,
        x: x2,
        y: y2
      }
    }), eventTargetIsContainer || (event.stopPropagation(), event.preventDefault());
  }, onPointerMove = (event) => {
    const { userSelectionRect, transform: transform2, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions, resetSelectedElements } = store.getState();
    if (!containerBounds.current || !userSelectionRect)
      return;
    const { x: mouseX, y: mouseY } = getEventPosition(event.nativeEvent, containerBounds.current), { startX, startY } = userSelectionRect;
    if (!selectionInProgress.current) {
      const requiredDistance = selectionKeyPressed ? 0 : paneClickDistance;
      if (Math.hypot(mouseX - startX, mouseY - startY) <= requiredDistance)
        return;
      resetSelectedElements(), onSelectionStart?.(event);
    }
    selectionInProgress.current = !0;
    const nextUserSelectRect = {
      startX,
      startY,
      x: mouseX < startX ? mouseX : startX,
      y: mouseY < startY ? mouseY : startY,
      width: Math.abs(mouseX - startX),
      height: Math.abs(mouseY - startY)
    }, prevSelectedNodeIds = selectedNodeIds.current, prevSelectedEdgeIds = selectedEdgeIds.current;
    selectedNodeIds.current = new Set(getNodesInside(nodeLookup, nextUserSelectRect, transform2, selectionMode === SelectionMode.Partial, !0).map((node) => node.id)), selectedEdgeIds.current = /* @__PURE__ */ new Set();
    const edgesSelectable = defaultEdgeOptions?.selectable ?? !0;
    for (const nodeId of selectedNodeIds.current) {
      const connections = connectionLookup.get(nodeId);
      if (connections)
        for (const { edgeId } of connections.values()) {
          const edge = edgeLookup.get(edgeId);
          edge && (edge.selectable ?? edgesSelectable) && selectedEdgeIds.current.add(edgeId);
        }
    }
    if (!areSetsEqual$1(prevSelectedNodeIds, selectedNodeIds.current)) {
      const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, !0);
      triggerNodeChanges(changes);
    }
    if (!areSetsEqual$1(prevSelectedEdgeIds, selectedEdgeIds.current)) {
      const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);
      triggerEdgeChanges(changes);
    }
    store.setState({
      userSelectionRect: nextUserSelectRect,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, onPointerUp = (event) => {
    event.button === 0 && (event.target?.releasePointerCapture?.(event.pointerId), !userSelectionActive && event.target === container.current && store.getState().userSelectionRect && onClick?.(event), store.setState({
      userSelectionActive: !1,
      userSelectionRect: null
    }), selectionInProgress.current && (onSelectionEnd?.(event), store.setState({
      nodesSelectionActive: selectedNodeIds.current.size > 0
    })));
  }, draggable = panOnDrag === !0 || Array.isArray(panOnDrag) && panOnDrag.includes(0);
  return jsxs("div", { className: cc(["react-flow__pane", { draggable, dragging, selection: isSelecting }]), onClick: isSelectionEnabled ? void 0 : wrapHandler(onClick, container), onContextMenu: wrapHandler(onContextMenu, container), onWheel: wrapHandler(onWheel, container), onPointerEnter: isSelectionEnabled ? void 0 : onPaneMouseEnter, onPointerMove: isSelectionEnabled ? onPointerMove : onPaneMouseMove, onPointerUp: isSelectionEnabled ? onPointerUp : void 0, onPointerDownCapture: isSelectionEnabled ? onPointerDownCapture : void 0, onClickCapture: isSelectionEnabled ? onClickCapture : void 0, onPointerLeave: onPaneMouseLeave, ref: container, style: containerStyle, children: [children2, jsx(UserSelection, {})] });
}
function handleNodeClick({ id: id2, store, unselect = !1, nodeRef }) {
  const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState(), node = nodeLookup.get(id2);
  if (!node) {
    onError?.("012", errorMessages.error012(id2));
    return;
  }
  store.setState({ nodesSelectionActive: !1 }), node.selected ? (unselect || node.selected && multiSelectionActive) && (unselectNodesAndEdges({ nodes: [node], edges: [] }), requestAnimationFrame(() => nodeRef?.current?.blur())) : addSelectedNodes([id2]);
}
function useDrag({ nodeRef, disabled = !1, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {
  const store = useStoreApi(), [dragging, setDragging] = useState(!1), xyDrag = useRef();
  return useEffect(() => {
    xyDrag.current = XYDrag({
      getStoreItems: () => store.getState(),
      onNodeMouseDown: (id2) => {
        handleNodeClick({
          id: id2,
          store,
          nodeRef
        });
      },
      onDragStart: () => {
        setDragging(!0);
      },
      onDragStop: () => {
        setDragging(!1);
      }
    });
  }, []), useEffect(() => {
    if (disabled)
      xyDrag.current?.destroy();
    else if (nodeRef.current)
      return xyDrag.current?.update({
        noDragClassName,
        handleSelector,
        domNode: nodeRef.current,
        isSelectable,
        nodeId,
        nodeClickDistance
      }), () => {
        xyDrag.current?.destroy();
      };
  }, [noDragClassName, handleSelector, disabled, isSelectable, nodeRef, nodeId]), dragging;
}
const selectedAndDraggable = (nodesDraggable) => (n2) => n2.selected && (n2.draggable || nodesDraggable && typeof n2.draggable > "u");
function useMoveSelectedNodes() {
  const store = useStoreApi();
  return useCallback((params) => {
    const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState(), nodeUpdates = /* @__PURE__ */ new Map(), isSelected = selectedAndDraggable(nodesDraggable), xVelo = snapToGrid ? snapGrid[0] : 5, yVelo = snapToGrid ? snapGrid[1] : 5, xDiff = params.direction.x * xVelo * params.factor, yDiff = params.direction.y * yVelo * params.factor;
    for (const [, node] of nodeLookup) {
      if (!isSelected(node))
        continue;
      let nextPosition = {
        x: node.internals.positionAbsolute.x + xDiff,
        y: node.internals.positionAbsolute.y + yDiff
      };
      snapToGrid && (nextPosition = snapPosition(nextPosition, snapGrid));
      const { position, positionAbsolute } = calculateNodePosition({
        nodeId: node.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError
      });
      node.position = position, node.internals.positionAbsolute = positionAbsolute, nodeUpdates.set(node.id, node);
    }
    updateNodePositions(nodeUpdates);
  }, []);
}
const NodeIdContext = createContext(null), Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => useContext(NodeIdContext), selector$g = (s) => ({
  connectOnClick: s.connectOnClick,
  noPanClassName: s.noPanClassName,
  rfId: s.rfId
}), connectingSelector = (nodeId, handleId, type) => (state) => {
  const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state, { fromHandle, toHandle, isValid } = connection, connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;
  return {
    connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,
    connectingTo,
    clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,
    isPossibleEndHandle: connectionMode === ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,
    connectionInProcess: !!fromHandle,
    clickConnectionInProcess: !!clickHandle,
    valid: connectingTo && isValid
  };
};
function HandleComponent({ type = "source", position = Position.Top, isValidConnection, isConnectable = !0, isConnectableStart = !0, isConnectableEnd = !0, id: id2, onConnect, children: children2, className, onMouseDown, onTouchStart, ...rest }, ref) {
  const handleId = id2 || null, isTarget = type === "target", store = useStoreApi(), nodeId = useNodeId(), { connectOnClick, noPanClassName, rfId } = useStore$1(selector$g, shallow$1), { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore$1(connectingSelector(nodeId, handleId, type), shallow$1);
  nodeId || store.getState().onError?.("010", errorMessages.error010());
  const onConnectExtended = (params) => {
    const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState(), edgeParams = {
      ...defaultEdgeOptions,
      ...params
    };
    if (hasDefaultEdges) {
      const { edges, setEdges } = store.getState();
      setEdges(addEdge(edgeParams, edges));
    }
    onConnectAction?.(edgeParams), onConnect?.(edgeParams);
  }, onPointerDown2 = (event) => {
    if (!nodeId)
      return;
    const isMouseTriggered = isMouseEvent(event.nativeEvent);
    if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
      const currentStore = store.getState();
      XYHandle.onPointerDown(event.nativeEvent, {
        handleDomNode: event.currentTarget,
        autoPanOnConnect: currentStore.autoPanOnConnect,
        connectionMode: currentStore.connectionMode,
        connectionRadius: currentStore.connectionRadius,
        domNode: currentStore.domNode,
        nodeLookup: currentStore.nodeLookup,
        lib: currentStore.lib,
        isTarget,
        handleId,
        nodeId,
        flowId: currentStore.rfId,
        panBy: currentStore.panBy,
        cancelConnection: currentStore.cancelConnection,
        onConnectStart: currentStore.onConnectStart,
        onConnectEnd: currentStore.onConnectEnd,
        updateConnection: currentStore.updateConnection,
        onConnect: onConnectExtended,
        isValidConnection: isValidConnection || currentStore.isValidConnection,
        getTransform: () => store.getState().transform,
        getFromHandle: () => store.getState().connection.fromHandle,
        autoPanSpeed: currentStore.autoPanSpeed,
        dragThreshold: currentStore.connectionDragThreshold
      });
    }
    isMouseTriggered ? onMouseDown?.(event) : onTouchStart?.(event);
  }, onClick = (event) => {
    const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib: lib2, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();
    if (!nodeId || !connectionClickStartHandle && !isConnectableStart)
      return;
    if (!connectionClickStartHandle) {
      onClickConnectStart?.(event.nativeEvent, { nodeId, handleId, handleType: type }), store.setState({ connectionClickStartHandle: { nodeId, type, id: handleId } });
      return;
    }
    const doc = getHostForElement(event.target), isValidConnectionHandler = isValidConnection || isValidConnectionStore, { connection, isValid } = XYHandle.isValid(event.nativeEvent, {
      handle: {
        nodeId,
        id: handleId,
        type
      },
      connectionMode,
      fromNodeId: connectionClickStartHandle.nodeId,
      fromHandleId: connectionClickStartHandle.id || null,
      fromType: connectionClickStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: lib2,
      nodeLookup
    });
    isValid && connection && onConnectExtended(connection);
    const connectionClone = structuredClone(connectionState);
    delete connectionClone.inProgress, connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null, onClickConnectEnd?.(event, connectionClone), store.setState({ connectionClickStartHandle: null });
  };
  return jsx("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position, "data-id": `${rfId}-${nodeId}-${handleId}-${type}`, className: cc([
    "react-flow__handle",
    `react-flow__handle-${position}`,
    "nodrag",
    noPanClassName,
    className,
    {
      source: !isTarget,
      target: isTarget,
      connectable: isConnectable,
      connectablestart: isConnectableStart,
      connectableend: isConnectableEnd,
      clickconnecting: clickConnecting,
      connectingfrom: connectingFrom,
      connectingto: connectingTo,
      valid,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)
    }
  ]), onMouseDown: onPointerDown2, onTouchStart: onPointerDown2, onClick: connectOnClick ? onClick : void 0, ref, ...rest, children: children2 });
}
const Handle = memo$2(fixedForwardRef(HandleComponent));
function InputNode({ data, isConnectable, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment$1, { children: [data?.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function DefaultNode({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom }) {
  return jsxs(Fragment$1, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data?.label, jsx(Handle, { type: "source", position: sourcePosition, isConnectable })] });
}
function GroupNode() {
  return null;
}
function OutputNode({ data, isConnectable, targetPosition = Position.Top }) {
  return jsxs(Fragment$1, { children: [jsx(Handle, { type: "target", position: targetPosition, isConnectable }), data?.label] });
}
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, builtinNodeTypes = {
  input: InputNode,
  default: DefaultNode,
  output: OutputNode,
  group: GroupNode
};
function getNodeInlineStyleDimensions(node) {
  return node.internals.handleBounds === void 0 ? {
    width: node.width ?? node.initialWidth ?? node.style?.width,
    height: node.height ?? node.initialHeight ?? node.style?.height
  } : {
    width: node.width ?? node.style?.width,
    height: node.height ?? node.style?.height
  };
}
const selector$f = (s) => {
  const { width, height, x: x2, y: y2 } = getInternalNodesBounds(s.nodeLookup, {
    filter: (node) => !!node.selected
  });
  return {
    width: isNumeric(width) ? width : null,
    height: isNumeric(height) ? height : null,
    userSelectionActive: s.userSelectionActive,
    transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x2}px,${y2}px)`
  };
};
function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
  const store = useStoreApi(), { width, height, transformString, userSelectionActive } = useStore$1(selector$f, shallow$1), moveSelectedNodes = useMoveSelectedNodes(), nodeRef = useRef(null);
  if (useEffect(() => {
    disableKeyboardA11y || nodeRef.current?.focus({
      preventScroll: !0
    });
  }, [disableKeyboardA11y]), useDrag({
    nodeRef
  }), userSelectionActive || !width || !height)
    return null;
  const onContextMenu = onSelectionContextMenu ? (event) => {
    const selectedNodes = store.getState().nodes.filter((n2) => n2.selected);
    onSelectionContextMenu(event, selectedNodes);
  } : void 0, onKeyDown = (event) => {
    Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key) && (event.preventDefault(), moveSelectedNodes({
      direction: arrowKeyDiffs[event.key],
      factor: event.shiftKey ? 4 : 1
    }));
  };
  return jsx("div", { className: cc(["react-flow__nodesselection", "react-flow__container", noPanClassName]), style: {
    transform: transformString
  }, children: jsx("div", { ref: nodeRef, className: "react-flow__nodesselection-rect", onContextMenu, tabIndex: disableKeyboardA11y ? void 0 : -1, onKeyDown: disableKeyboardA11y ? void 0 : onKeyDown, style: {
    width,
    height
  } }) });
}
const win = typeof window < "u" ? window : void 0, selector$e = (s) => ({ nodesSelectionActive: s.nodesSelectionActive, userSelectionActive: s.userSelectionActive });
function FlowRendererComponent({ children: children2, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {
  const { nodesSelectionActive, userSelectionActive } = useStore$1(selector$e, shallow$1), selectionKeyPressed = useKeyPress(selectionKeyCode, { target: win }), panActivationKeyPressed = useKeyPress(panActivationKeyCode, { target: win }), panOnDrag = panActivationKeyPressed || _panOnDrag, panOnScroll = panActivationKeyPressed || _panOnScroll, _selectionOnDrag = selectionOnDrag && panOnDrag !== !0, isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;
  return useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }), jsx(ZoomPane, { onPaneContextMenu, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, selectionOnDrag: _selectionOnDrag, children: jsxs(Pane, { onSelectionStart, onSelectionEnd, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, panOnDrag, isSelecting: !!isSelecting, selectionMode, selectionKeyPressed, paneClickDistance, selectionOnDrag: _selectionOnDrag, children: [children2, nodesSelectionActive && jsx(NodesSelection, { onSelectionContextMenu, noPanClassName, disableKeyboardA11y })] }) });
}
FlowRendererComponent.displayName = "FlowRenderer";
const FlowRenderer = memo$2(FlowRendererComponent), selector$d = (onlyRenderVisible) => (s) => onlyRenderVisible ? getNodesInside(s.nodeLookup, { x: 0, y: 0, width: s.width, height: s.height }, s.transform, !0).map((node) => node.id) : Array.from(s.nodeLookup.keys());
function useVisibleNodeIds(onlyRenderVisible) {
  return useStore$1(useCallback(selector$d(onlyRenderVisible), [onlyRenderVisible]), shallow$1);
}
const selector$c = (s) => s.updateNodeInternals;
function useResizeObserver() {
  const updateNodeInternals2 = useStore$1(selector$c), [resizeObserver] = useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id2 = entry.target.getAttribute("data-id");
      updates.set(id2, {
        id: id2,
        nodeElement: entry.target,
        force: !0
      });
    }), updateNodeInternals2(updates);
  }));
  return useEffect(() => () => {
    resizeObserver?.disconnect();
  }, [resizeObserver]), resizeObserver;
}
function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {
  const store = useStoreApi(), nodeRef = useRef(null), observedNode = useRef(null), prevSourcePosition = useRef(node.sourcePosition), prevTargetPosition = useRef(node.targetPosition), prevType = useRef(nodeType), isInitialized = hasDimensions && !!node.internals.handleBounds;
  return useEffect(() => {
    nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current) && (observedNode.current && resizeObserver?.unobserve(observedNode.current), resizeObserver?.observe(nodeRef.current), observedNode.current = nodeRef.current);
  }, [isInitialized, node.hidden]), useEffect(() => () => {
    observedNode.current && (resizeObserver?.unobserve(observedNode.current), observedNode.current = null);
  }, []), useEffect(() => {
    if (nodeRef.current) {
      const typeChanged = prevType.current !== nodeType, sourcePosChanged = prevSourcePosition.current !== node.sourcePosition, targetPosChanged = prevTargetPosition.current !== node.targetPosition;
      (typeChanged || sourcePosChanged || targetPosChanged) && (prevType.current = nodeType, prevSourcePosition.current = node.sourcePosition, prevTargetPosition.current = node.targetPosition, store.getState().updateNodeInternals(/* @__PURE__ */ new Map([[node.id, { id: node.id, nodeElement: nodeRef.current, force: !0 }]])));
    }
  }, [node.id, nodeType, node.sourcePosition, node.targetPosition]), nodeRef;
}
function NodeWrapper({ id: id2, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {
  const { node, internals, isParent: isParent2 } = useStore$1((s) => {
    const node2 = s.nodeLookup.get(id2), isParent22 = s.parentLookup.has(id2);
    return {
      node: node2,
      internals: node2.internals,
      isParent: isParent22
    };
  }, shallow$1);
  let nodeType = node.type || "default", NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];
  NodeComponent === void 0 && (onError?.("003", errorMessages.error003(nodeType)), nodeType = "default", NodeComponent = nodeTypes?.default || builtinNodeTypes.default);
  const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable > "u"), isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable > "u"), isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable > "u"), isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable > "u"), store = useStoreApi(), hasDimensions = nodeHasDimensions(node), nodeRef = useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }), dragging = useDrag({
    nodeRef,
    disabled: node.hidden || !isDraggable,
    noDragClassName,
    handleSelector: node.dragHandle,
    nodeId: id2,
    isSelectable,
    nodeClickDistance
  }), moveSelectedNodes = useMoveSelectedNodes();
  if (node.hidden)
    return null;
  const nodeDimensions = getNodeDimensions(node), inlineDimensions = getNodeInlineStyleDimensions(node), hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave, onMouseEnterHandler = onMouseEnter ? (event) => onMouseEnter(event, { ...internals.userNode }) : void 0, onMouseMoveHandler = onMouseMove ? (event) => onMouseMove(event, { ...internals.userNode }) : void 0, onMouseLeaveHandler = onMouseLeave ? (event) => onMouseLeave(event, { ...internals.userNode }) : void 0, onContextMenuHandler = onContextMenu ? (event) => onContextMenu(event, { ...internals.userNode }) : void 0, onDoubleClickHandler = onDoubleClick ? (event) => onDoubleClick(event, { ...internals.userNode }) : void 0, onSelectNodeHandler = (event) => {
    const { selectNodesOnDrag, nodeDragThreshold } = store.getState();
    isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0) && handleNodeClick({
      id: id2,
      store,
      nodeRef
    }), onClick && onClick(event, { ...internals.userNode });
  }, onKeyDown = (event) => {
    if (!(isInputDOMNode(event.nativeEvent) || disableKeyboardA11y)) {
      if (elementSelectionKeys.includes(event.key) && isSelectable) {
        const unselect = event.key === "Escape";
        handleNodeClick({
          id: id2,
          store,
          unselect,
          nodeRef
        });
      } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
        event.preventDefault();
        const { ariaLabelConfig } = store.getState();
        store.setState({
          ariaLiveMessage: ariaLabelConfig["node.a11yDescription.ariaLiveMessage"]({
            direction: event.key.replace("Arrow", "").toLowerCase(),
            x: ~~internals.positionAbsolute.x,
            y: ~~internals.positionAbsolute.y
          })
        }), moveSelectedNodes({
          direction: arrowKeyDiffs[event.key],
          factor: event.shiftKey ? 4 : 1
        });
      }
    }
  }, onFocus = () => {
    if (disableKeyboardA11y || !nodeRef.current?.matches(":focus-visible"))
      return;
    const { transform: transform2, width, height, autoPanOnNodeFocus, setCenter } = store.getState();
    if (!autoPanOnNodeFocus)
      return;
    getNodesInside(/* @__PURE__ */ new Map([[id2, node]]), { x: 0, y: 0, width, height }, transform2, !0).length > 0 || setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {
      zoom: transform2[2]
    });
  };
  return jsx("div", { className: cc([
    "react-flow__node",
    `react-flow__node-${nodeType}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [noPanClassName]: isDraggable
    },
    node.className,
    {
      selected: node.selected,
      selectable: isSelectable,
      parent: isParent2,
      draggable: isDraggable,
      dragging
    }
  ]), ref: nodeRef, style: {
    zIndex: internals.z,
    transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,
    pointerEvents: hasPointerEvents ? "all" : "none",
    visibility: hasDimensions ? "visible" : "hidden",
    ...node.style,
    ...inlineDimensions
  }, "data-id": id2, "data-testid": `rf__node-${id2}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, onFocus: isFocusable ? onFocus : void 0, role: node.ariaRole ?? (isFocusable ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": node.ariaLabel, ...node.domAttributes, children: jsx(Provider, { value: id2, children: jsx(NodeComponent, { id: id2, data: node.data, type: nodeType, positionAbsoluteX: internals.positionAbsolute.x, positionAbsoluteY: internals.positionAbsolute.y, selected: node.selected ?? !1, selectable: isSelectable, draggable: isDraggable, deletable: node.deletable ?? !0, isConnectable, sourcePosition: node.sourcePosition, targetPosition: node.targetPosition, dragging, dragHandle: node.dragHandle, zIndex: internals.z, parentId: node.parentId, ...nodeDimensions }) }) });
}
var NodeWrapper$1 = memo$2(NodeWrapper);
const selector$b = (s) => ({
  nodesDraggable: s.nodesDraggable,
  nodesConnectable: s.nodesConnectable,
  nodesFocusable: s.nodesFocusable,
  elementsSelectable: s.elementsSelectable,
  onError: s.onError
});
function NodeRendererComponent(props) {
  const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore$1(selector$b, shallow$1), nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements), resizeObserver = useResizeObserver();
  return jsx("div", { className: "react-flow__nodes", style: containerStyle, children: nodeIds.map((nodeId) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    jsx(NodeWrapper$1, { id: nodeId, nodeTypes: props.nodeTypes, nodeExtent: props.nodeExtent, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, resizeObserver, nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, nodeClickDistance: props.nodeClickDistance, onError }, nodeId)
  )) });
}
NodeRendererComponent.displayName = "NodeRenderer";
const NodeRenderer = memo$2(NodeRendererComponent);
function useVisibleEdgeIds(onlyRenderVisible) {
  return useStore$1(useCallback((s) => {
    if (!onlyRenderVisible)
      return s.edges.map((edge) => edge.id);
    const visibleEdgeIds = [];
    if (s.width && s.height)
      for (const edge of s.edges) {
        const sourceNode = s.nodeLookup.get(edge.source), targetNode = s.nodeLookup.get(edge.target);
        sourceNode && targetNode && isEdgeVisible({
          sourceNode,
          targetNode,
          width: s.width,
          height: s.height,
          transform: s.transform
        }) && visibleEdgeIds.push(edge.id);
      }
    return visibleEdgeIds;
  }, [onlyRenderVisible]), shallow$1);
}
const ArrowSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => {
  const style2 = {
    strokeWidth,
    ...color2 && { stroke: color2 }
  };
  return jsx("polyline", { className: "arrow", style: style2, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
}, ArrowClosedSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => {
  const style2 = {
    strokeWidth,
    ...color2 && { stroke: color2, fill: color2 }
  };
  return jsx("polyline", { className: "arrowclosed", style: style2, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
}, MarkerSymbols = {
  [MarkerType.Arrow]: ArrowSymbol,
  [MarkerType.ArrowClosed]: ArrowClosedSymbol
};
function useMarkerSymbol(type) {
  const store = useStoreApi();
  return useMemo(() => Object.prototype.hasOwnProperty.call(MarkerSymbols, type) ? MarkerSymbols[type] : (store.getState().onError?.("009", errorMessages.error009(type)), null), [type]);
}
const Marker = ({ id: id2, type, color: color2, width = 12.5, height = 12.5, markerUnits = "strokeWidth", strokeWidth, orient = "auto-start-reverse" }) => {
  const Symbol2 = useMarkerSymbol(type);
  return Symbol2 ? jsx("marker", { className: "react-flow__arrowhead", id: id2, markerWidth: `${width}`, markerHeight: `${height}`, viewBox: "-10 -10 20 20", markerUnits, orient, refX: "0", refY: "0", children: jsx(Symbol2, { color: color2, strokeWidth }) }) : null;
}, MarkerDefinitions = ({ defaultColor, rfId }) => {
  const edges = useStore$1((s) => s.edges), defaultEdgeOptions = useStore$1((s) => s.defaultEdgeOptions), markers = useMemo(() => createMarkerIds(edges, {
    id: rfId,
    defaultColor,
    defaultMarkerStart: defaultEdgeOptions?.markerStart,
    defaultMarkerEnd: defaultEdgeOptions?.markerEnd
  }), [edges, defaultEdgeOptions, rfId, defaultColor]);
  return markers.length ? jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: jsx("defs", { children: markers.map((marker) => jsx(Marker, { id: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient }, marker.id)) }) }) : null;
};
MarkerDefinitions.displayName = "MarkerDefinitions";
var MarkerDefinitions$1 = memo$2(MarkerDefinitions);
function EdgeTextComponent({ x: x2, y: y2, label, labelStyle, labelShowBg = !0, labelBgStyle, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children: children2, className, ...rest }) {
  const [edgeTextBbox, setEdgeTextBbox] = useState({ x: 1, y: 0, width: 0, height: 0 }), edgeTextClasses = cc(["react-flow__edge-textwrapper", className]), edgeTextRef = useRef(null);
  return useEffect(() => {
    if (edgeTextRef.current) {
      const textBbox = edgeTextRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label]), label ? jsxs("g", { transform: `translate(${x2 - edgeTextBbox.width / 2} ${y2 - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? "visible" : "hidden", ...rest, children: [labelShowBg && jsx("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius }), jsx("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeTextRef, style: labelStyle, children: label }), children2] }) : null;
}
EdgeTextComponent.displayName = "EdgeText";
const EdgeText = memo$2(EdgeTextComponent);
function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {
  return jsxs(Fragment$1, { children: [jsx("path", { ...props, d: path, fill: "none", className: cc(["react-flow__edge-path", props.className]) }), interactionWidth ? jsx("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" }) : null, label && isNumeric(labelX) && isNumeric(labelY) ? jsx(EdgeText, { x: labelX, y: labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius }) : null] });
}
function getControl({ pos, x1, y1, x2, y2 }) {
  return pos === Position.Left || pos === Position.Right ? [0.5 * (x1 + x2), y1] : [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {
  const [sourceControlX, sourceControlY] = getControl({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY
  }), [targetControlX, targetControlY] = getControl({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY
  }), [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function createSimpleBezierEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getSimpleBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SimpleBezierEdge = createSimpleBezierEdge({ isInternal: !1 }), SimpleBezierEdgeInternal = createSimpleBezierEdge({ isInternal: !0 });
SimpleBezierEdge.displayName = "SimpleBezierEdge";
SimpleBezierEdgeInternal.displayName = "SimpleBezierEdgeInternal";
function createSmoothStepEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      borderRadius: pathOptions?.borderRadius,
      offset: pathOptions?.offset,
      stepPosition: pathOptions?.stepPosition
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const SmoothStepEdge = createSmoothStepEdge({ isInternal: !1 }), SmoothStepEdgeInternal = createSmoothStepEdge({ isInternal: !0 });
SmoothStepEdge.displayName = "SmoothStepEdge";
SmoothStepEdgeInternal.displayName = "SmoothStepEdgeInternal";
function createStepEdge(params) {
  return memo$2(({ id: id2, ...props }) => {
    const _id = params.isInternal ? void 0 : id2;
    return jsx(SmoothStepEdge, { ...props, id: _id, pathOptions: useMemo(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) });
  });
}
const StepEdge = createStepEdge({ isInternal: !1 }), StepEdgeInternal = createStepEdge({ isInternal: !0 });
StepEdge.displayName = "StepEdge";
StepEdgeInternal.displayName = "StepEdgeInternal";
function createStraightEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const StraightEdge = createStraightEdge({ isInternal: !1 }), StraightEdgeInternal = createStraightEdge({ isInternal: !0 });
StraightEdge.displayName = "StraightEdge";
StraightEdgeInternal.displayName = "StraightEdgeInternal";
function createBezierEdge(params) {
  return memo$2(({ id: id2, sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      curvature: pathOptions?.curvature
    }), _id = params.isInternal ? void 0 : id2;
    return jsx(BaseEdge, { id: _id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
}
const BezierEdge = createBezierEdge({ isInternal: !1 }), BezierEdgeInternal = createBezierEdge({ isInternal: !0 });
BezierEdge.displayName = "BezierEdge";
BezierEdgeInternal.displayName = "BezierEdgeInternal";
const builtinEdgeTypes = {
  default: BezierEdgeInternal,
  straight: StraightEdgeInternal,
  step: StepEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  simplebezier: SimpleBezierEdgeInternal
}, nullPosition = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, shiftX = (x2, shift2, position) => position === Position.Left ? x2 - shift2 : position === Position.Right ? x2 + shift2 : x2, shiftY = (y2, shift2, position) => position === Position.Top ? y2 - shift2 : position === Position.Bottom ? y2 + shift2 : y2, EdgeUpdaterClassName = "react-flow__edgeupdater";
function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {
  return jsx("circle", { onMouseDown, onMouseEnter, onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position), cy: shiftY(centerY, radius, position), r: radius, stroke: "transparent", fill: "transparent" });
}
function EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {
  const store = useStoreApi(), handleEdgeUpdater = (event, oppositeHandle) => {
    if (event.button !== 0)
      return;
    const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib: lib2, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy: panBy2, updateConnection } = store.getState(), isTarget = oppositeHandle.type === "target", _onReconnectEnd = (evt, connectionState) => {
      setReconnecting(!1), onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);
    }, onConnectEdge = (connection) => onReconnect?.(edge, connection), _onConnectStart = (_event, params) => {
      setReconnecting(!0), onReconnectStart?.(event, edge, oppositeHandle.type), onConnectStart?.(_event, params);
    };
    XYHandle.onPointerDown(event.nativeEvent, {
      autoPanOnConnect,
      connectionMode,
      connectionRadius,
      domNode,
      handleId: oppositeHandle.id,
      nodeId: oppositeHandle.nodeId,
      nodeLookup,
      isTarget,
      edgeUpdaterType: oppositeHandle.type,
      lib: lib2,
      flowId,
      cancelConnection,
      panBy: panBy2,
      isValidConnection,
      onConnect: onConnectEdge,
      onConnectStart: _onConnectStart,
      onConnectEnd,
      onReconnectEnd: _onReconnectEnd,
      updateConnection,
      getTransform: () => store.getState().transform,
      getFromHandle: () => store.getState().connection.fromHandle,
      dragThreshold: store.getState().connectionDragThreshold,
      handleDomNode: event.currentTarget
    });
  }, onReconnectSourceMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.target, id: edge.targetHandle ?? null, type: "target" }), onReconnectTargetMouseDown = (event) => handleEdgeUpdater(event, { nodeId: edge.source, id: edge.sourceHandle ?? null, type: "source" }), onReconnectMouseEnter = () => setUpdateHover(!0), onReconnectMouseOut = () => setUpdateHover(!1);
  return jsxs(Fragment$1, { children: [(isReconnectable === !0 || isReconnectable === "source") && jsx(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onReconnectSourceMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "source" }), (isReconnectable === !0 || isReconnectable === "target") && jsx(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onReconnectTargetMouseDown, onMouseEnter: onReconnectMouseEnter, onMouseOut: onReconnectMouseOut, type: "target" })] });
}
function EdgeWrapper({ id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {
  let edge = useStore$1((s) => s.edgeLookup.get(id2));
  const defaultEdgeOptions = useStore$1((s) => s.defaultEdgeOptions);
  edge = defaultEdgeOptions ? { ...defaultEdgeOptions, ...edge } : edge;
  let edgeType = edge.type || "default", EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];
  EdgeComponent === void 0 && (onError?.("011", errorMessages.error011(edgeType)), edgeType = "default", EdgeComponent = edgeTypes?.default || builtinEdgeTypes.default);
  const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable > "u"), isReconnectable = typeof onReconnect < "u" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable > "u"), isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable > "u"), edgeRef = useRef(null), [updateHover, setUpdateHover] = useState(!1), [reconnecting, setReconnecting] = useState(!1), store = useStoreApi(), { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore$1(useCallback((store2) => {
    const sourceNode = store2.nodeLookup.get(edge.source), targetNode = store2.nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode)
      return {
        zIndex: edge.zIndex,
        ...nullPosition
      };
    const edgePosition = getEdgePosition({
      id: id2,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode: store2.connectionMode,
      onError
    });
    return {
      zIndex: getElevatedEdgeZIndex({
        selected: edge.selected,
        zIndex: edge.zIndex,
        sourceNode,
        targetNode,
        elevateOnSelect: store2.elevateEdgesOnSelect,
        zIndexMode: store2.zIndexMode
      }),
      ...edgePosition || nullPosition
    };
  }, [edge.source, edge.target, edge.sourceHandle, edge.targetHandle, edge.selected, edge.zIndex]), shallow$1), markerStartUrl = useMemo(() => edge.markerStart ? `url('#${getMarkerId(edge.markerStart, rfId)}')` : void 0, [edge.markerStart, rfId]), markerEndUrl = useMemo(() => edge.markerEnd ? `url('#${getMarkerId(edge.markerEnd, rfId)}')` : void 0, [edge.markerEnd, rfId]);
  if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null)
    return null;
  const onEdgeClick = (event) => {
    const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
    isSelectable && (store.setState({ nodesSelectionActive: !1 }), edge.selected && multiSelectionActive ? (unselectNodesAndEdges({ nodes: [], edges: [edge] }), edgeRef.current?.blur()) : addSelectedEdges([id2])), onClick && onClick(event, edge);
  }, onEdgeDoubleClick = onDoubleClick ? (event) => {
    onDoubleClick(event, { ...edge });
  } : void 0, onEdgeContextMenu = onContextMenu ? (event) => {
    onContextMenu(event, { ...edge });
  } : void 0, onEdgeMouseEnter = onMouseEnter ? (event) => {
    onMouseEnter(event, { ...edge });
  } : void 0, onEdgeMouseMove = onMouseMove ? (event) => {
    onMouseMove(event, { ...edge });
  } : void 0, onEdgeMouseLeave = onMouseLeave ? (event) => {
    onMouseLeave(event, { ...edge });
  } : void 0, onKeyDown = (event) => {
    if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && isSelectable) {
      const { unselectNodesAndEdges, addSelectedEdges } = store.getState();
      event.key === "Escape" ? (edgeRef.current?.blur(), unselectNodesAndEdges({ edges: [edge] })) : addSelectedEdges([id2]);
    }
  };
  return jsx("svg", { style: { zIndex }, children: jsxs("g", { className: cc([
    "react-flow__edge",
    `react-flow__edge-${edgeType}`,
    edge.className,
    noPanClassName,
    {
      selected: edge.selected,
      animated: edge.animated,
      inactive: !isSelectable && !onClick,
      updating: updateHover,
      selectable: isSelectable
    }
  ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClick, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: edge.ariaRole ?? (isFocusable ? "group" : "img"), "aria-roledescription": "edge", "data-id": id2, "data-testid": `rf__edge-${id2}`, "aria-label": edge.ariaLabel === null ? void 0 : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : void 0, ref: edgeRef, ...edge.domAttributes, children: [!reconnecting && jsx(EdgeComponent, { id: id2, source: edge.source, target: edge.target, type: edge.type, selected: edge.selected, animated: edge.animated, selectable: isSelectable, deletable: edge.deletable ?? !0, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, data: edge.data, style: edge.style, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions: "pathOptions" in edge ? edge.pathOptions : void 0, interactionWidth: edge.interactionWidth }), isReconnectable && jsx(EdgeUpdateAnchors, { edge, isReconnectable, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, setUpdateHover, setReconnecting })] }) });
}
var EdgeWrapper$1 = memo$2(EdgeWrapper);
const selector$a = (s) => ({
  edgesFocusable: s.edgesFocusable,
  edgesReconnectable: s.edgesReconnectable,
  elementsSelectable: s.elementsSelectable,
  connectionMode: s.connectionMode,
  onError: s.onError
});
function EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {
  const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore$1(selector$a, shallow$1), edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);
  return jsxs("div", { className: "react-flow__edges", children: [jsx(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId }), edgeIds.map((id2) => jsx(EdgeWrapper$1, { id: id2, edgesFocusable, edgesReconnectable, elementsSelectable, noPanClassName, onReconnect, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, reconnectRadius, onDoubleClick: onEdgeDoubleClick, onReconnectStart, onReconnectEnd, rfId, onError, edgeTypes, disableKeyboardA11y }, id2))] });
}
EdgeRendererComponent.displayName = "EdgeRenderer";
const EdgeRenderer = memo$2(EdgeRendererComponent), selector$9 = (s) => `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;
function Viewport({ children: children2 }) {
  const transform2 = useStore$1(selector$9);
  return jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: transform2 }, children: children2 });
}
function useOnInitHandler(onInit) {
  const rfInstance = useReactFlow(), isInitialized = useRef(!1);
  useEffect(() => {
    !isInitialized.current && rfInstance.viewportInitialized && onInit && (setTimeout(() => onInit(rfInstance), 1), isInitialized.current = !0);
  }, [onInit, rfInstance.viewportInitialized]);
}
const selector$8 = (state) => state.panZoom?.syncViewport;
function useViewportSync(viewport) {
  const syncViewport = useStore$1(selector$8), store = useStoreApi();
  return useEffect(() => {
    viewport && (syncViewport?.(viewport), store.setState({ transform: [viewport.x, viewport.y, viewport.zoom] }));
  }, [viewport, syncViewport]), null;
}
function storeSelector$1(s) {
  return s.connection.inProgress ? { ...s.connection, to: pointToRendererPoint(s.connection.to, s.transform) } : { ...s.connection };
}
function getSelector(connectionSelector) {
  return storeSelector$1;
}
function useConnection(connectionSelector) {
  const combinedSelector = getSelector();
  return useStore$1(combinedSelector, shallow$1);
}
const selector$7 = (s) => ({
  nodesConnectable: s.nodesConnectable,
  isValid: s.connection.isValid,
  inProgress: s.connection.inProgress,
  width: s.width,
  height: s.height
});
function ConnectionLineWrapper({ containerStyle: containerStyle2, style: style2, type, component }) {
  const { nodesConnectable, width, height, isValid, inProgress } = useStore$1(selector$7, shallow$1);
  return !(width && nodesConnectable && inProgress) ? null : jsx("svg", { style: containerStyle2, width, height, className: "react-flow__connectionline react-flow__container", children: jsx("g", { className: cc(["react-flow__connection", getConnectionStatus(isValid)]), children: jsx(ConnectionLine, { style: style2, type, CustomComponent: component, isValid }) }) });
}
const ConnectionLine = ({ style: style2, type = ConnectionLineType.Bezier, CustomComponent, isValid }) => {
  const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition, pointer: pointer2 } = useConnection();
  if (!inProgress)
    return;
  if (CustomComponent)
    return jsx(CustomComponent, { connectionLineType: type, connectionLineStyle: style2, fromNode, fromHandle, fromX: from.x, fromY: from.y, toX: to.x, toY: to.y, fromPosition, toPosition, connectionStatus: getConnectionStatus(isValid), toNode, toHandle, pointer: pointer2 });
  let path = "";
  const pathParams = {
    sourceX: from.x,
    sourceY: from.y,
    sourcePosition: fromPosition,
    targetX: to.x,
    targetY: to.y,
    targetPosition: toPosition
  };
  switch (type) {
    case ConnectionLineType.Bezier:
      [path] = getBezierPath(pathParams);
      break;
    case ConnectionLineType.SimpleBezier:
      [path] = getSimpleBezierPath(pathParams);
      break;
    case ConnectionLineType.Step:
      [path] = getSmoothStepPath({
        ...pathParams,
        borderRadius: 0
      });
      break;
    case ConnectionLineType.SmoothStep:
      [path] = getSmoothStepPath(pathParams);
      break;
    default:
      [path] = getStraightPath(pathParams);
  }
  return jsx("path", { d: path, fill: "none", className: "react-flow__connection-path", style: style2 });
};
ConnectionLine.displayName = "ConnectionLine";
const emptyTypes = {};
function useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {
  useRef(nodeOrEdgeTypes), useStoreApi(), useEffect(() => {
  }, [nodeOrEdgeTypes]);
}
function useStylesLoadedWarning() {
  useStoreApi(), useRef(!1), useEffect(() => {
  }, []);
}
function GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {
  return useNodeOrEdgeTypesWarning(nodeTypes), useNodeOrEdgeTypesWarning(edgeTypes), useStylesLoadedWarning(), useOnInitHandler(onInit), useViewportSync(viewport), jsx(FlowRenderer, { onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, defaultViewport: defaultViewport2, translateExtent, minZoom, maxZoom, onSelectionContextMenu, preventScrolling, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport: !!viewport, children: jsxs(Viewport, { children: [jsx(EdgeRenderer, { edgeTypes, onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, onlyRenderVisibleElements, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, defaultMarkerColor, noPanClassName, disableKeyboardA11y, rfId }), jsx(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle }), jsx("div", { className: "react-flow__edgelabel-renderer" }), jsx(NodeRenderer, { nodeTypes, onNodeClick, onNodeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, nodeClickDistance, onlyRenderVisibleElements, noPanClassName, noDragClassName, disableKeyboardA11y, nodeExtent, rfId }), jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
GraphViewComponent.displayName = "GraphView";
const GraphView = memo$2(GraphViewComponent), getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent, zIndexMode = "basic" } = {}) => {
  const nodeLookup = /* @__PURE__ */ new Map(), parentLookup = /* @__PURE__ */ new Map(), connectionLookup = /* @__PURE__ */ new Map(), edgeLookup = /* @__PURE__ */ new Map(), storeEdges = defaultEdges ?? edges ?? [], storeNodes = defaultNodes ?? nodes ?? [], storeNodeOrigin = nodeOrigin ?? [0, 0], storeNodeExtent = nodeExtent ?? infiniteExtent;
  updateConnectionLookup(connectionLookup, edgeLookup, storeEdges);
  const nodesInitialized = adoptUserNodes(storeNodes, nodeLookup, parentLookup, {
    nodeOrigin: storeNodeOrigin,
    nodeExtent: storeNodeExtent,
    zIndexMode
  });
  let transform2 = [0, 0, 1];
  if (fitView && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node) => !!((node.width || node.initialWidth) && (node.height || node.initialHeight))
    }), { x: x2, y: y2, zoom: zoom2 } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);
    transform2 = [x2, y2, zoom2];
  }
  return {
    rfId: "1",
    width: width ?? 0,
    height: height ?? 0,
    transform: transform2,
    nodes: storeNodes,
    nodesInitialized,
    nodeLookup,
    parentLookup,
    edges: storeEdges,
    edgeLookup,
    connectionLookup,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: defaultNodes !== void 0,
    hasDefaultEdges: defaultEdges !== void 0,
    panZoom: null,
    minZoom,
    maxZoom,
    translateExtent: infiniteExtent,
    nodeExtent: storeNodeExtent,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: ConnectionMode.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: storeNodeOrigin,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: fitView ?? !1,
    fitViewOptions,
    fitViewResolver: null,
    connection: { ...initialConnection },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: devWarn,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: defaultAriaLabelConfig,
    zIndexMode,
    onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
    onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
  };
}, createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode }) => createWithEqualityFn((set2, get2) => {
  async function resolveFitView() {
    const { nodeLookup, panZoom, fitViewOptions: fitViewOptions2, fitViewResolver, width: width2, height: height2, minZoom: minZoom2, maxZoom: maxZoom2 } = get2();
    panZoom && (await fitViewport({
      nodes: nodeLookup,
      width: width2,
      height: height2,
      panZoom,
      minZoom: minZoom2,
      maxZoom: maxZoom2
    }, fitViewOptions2), fitViewResolver?.resolve(!0), set2({ fitViewResolver: null }));
  }
  return {
    ...getInitialState({
      nodes,
      edges,
      width,
      height,
      fitView,
      fitViewOptions,
      minZoom,
      maxZoom,
      nodeOrigin,
      nodeExtent,
      defaultNodes,
      defaultEdges,
      zIndexMode
    }),
    setNodes: (nodes2) => {
      const { nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, fitViewQueued, zIndexMode: zIndexMode2 } = get2(), nodesInitialized = adoptUserNodes(nodes2, nodeLookup, parentLookup, {
        nodeOrigin: nodeOrigin2,
        nodeExtent,
        elevateNodesOnSelect,
        checkEquality: !0,
        zIndexMode: zIndexMode2
      });
      fitViewQueued && nodesInitialized ? (resolveFitView(), set2({ nodes: nodes2, nodesInitialized, fitViewQueued: !1, fitViewOptions: void 0 })) : set2({ nodes: nodes2, nodesInitialized });
    },
    setEdges: (edges2) => {
      const { connectionLookup, edgeLookup } = get2();
      updateConnectionLookup(connectionLookup, edgeLookup, edges2), set2({ edges: edges2 });
    },
    setDefaultNodesAndEdges: (nodes2, edges2) => {
      if (nodes2) {
        const { setNodes } = get2();
        setNodes(nodes2), set2({ hasDefaultNodes: !0 });
      }
      if (edges2) {
        const { setEdges } = get2();
        setEdges(edges2), set2({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (updates) => {
      const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2, debug: debug2, fitViewQueued, zIndexMode: zIndexMode2 } = get2(), { changes, updatedInternals } = updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin2, nodeExtent2, zIndexMode2);
      updatedInternals && (updateAbsolutePositions(nodeLookup, parentLookup, { nodeOrigin: nodeOrigin2, nodeExtent: nodeExtent2, zIndexMode: zIndexMode2 }), fitViewQueued ? (resolveFitView(), set2({ fitViewQueued: !1, fitViewOptions: void 0 })) : set2({}), changes?.length > 0 && (debug2 && console.log("React Flow: trigger node changes", changes), triggerNodeChanges?.(changes)));
    },
    updateNodePositions: (nodeDragItems, dragging = !1) => {
      const parentExpandChildren = [];
      let changes = [];
      const { nodeLookup, triggerNodeChanges, connection, updateConnection, onNodesChangeMiddlewareMap } = get2();
      for (const [id2, dragItem] of nodeDragItems) {
        const node = nodeLookup.get(id2), expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position), change2 = {
          id: id2,
          type: "position",
          position: expandParent ? {
            x: Math.max(0, dragItem.position.x),
            y: Math.max(0, dragItem.position.y)
          } : dragItem.position,
          dragging
        };
        if (node && connection.inProgress && connection.fromNode.id === node.id) {
          const updatedFrom = getHandlePosition(node, connection.fromHandle, Position.Left, !0);
          updateConnection({ ...connection, from: updatedFrom });
        }
        expandParent && node.parentId && parentExpandChildren.push({
          id: id2,
          parentId: node.parentId,
          rect: {
            ...dragItem.internals.positionAbsolute,
            width: dragItem.measured.width ?? 0,
            height: dragItem.measured.height ?? 0
          }
        }), changes.push(change2);
      }
      if (parentExpandChildren.length > 0) {
        const { parentLookup, nodeOrigin: nodeOrigin2 } = get2(), parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin2);
        changes.push(...parentExpandChanges);
      }
      for (const middleware of onNodesChangeMiddlewareMap.values())
        changes = middleware(changes);
      triggerNodeChanges(changes);
    },
    triggerNodeChanges: (changes) => {
      const { onNodesChange, setNodes, nodes: nodes2, hasDefaultNodes, debug: debug2 } = get2();
      if (changes?.length) {
        if (hasDefaultNodes) {
          const updatedNodes = applyNodeChanges(changes, nodes2);
          setNodes(updatedNodes);
        }
        debug2 && console.log("React Flow: trigger node changes", changes), onNodesChange?.(changes);
      }
    },
    triggerEdgeChanges: (changes) => {
      const { onEdgesChange, setEdges, edges: edges2, hasDefaultEdges, debug: debug2 } = get2();
      if (changes?.length) {
        if (hasDefaultEdges) {
          const updatedEdges = applyEdgeChanges(changes, edges2);
          setEdges(updatedEdges);
        }
        debug2 && console.log("React Flow: trigger edge changes", changes), onEdgesChange?.(changes);
      }
    },
    addSelectedNodes: (selectedNodeIds) => {
      const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
      if (multiSelectionActive) {
        const nodeChanges = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, !0));
        triggerNodeChanges(nodeChanges);
        return;
      }
      triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set([...selectedNodeIds]), !0)), triggerEdgeChanges(getSelectionChanges(edgeLookup));
    },
    addSelectedEdges: (selectedEdgeIds) => {
      const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2();
      if (multiSelectionActive) {
        const changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, !0));
        triggerEdgeChanges(changedEdges);
        return;
      }
      triggerEdgeChanges(getSelectionChanges(edgeLookup, /* @__PURE__ */ new Set([...selectedEdgeIds]))), triggerNodeChanges(getSelectionChanges(nodeLookup, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: nodes2, edges: edges2 } = {}) => {
      const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get2(), nodesToUnselect = nodes2 || storeNodes, edgesToUnselect = edges2 || storeEdges, nodeChanges = nodesToUnselect.map((n2) => {
        const internalNode = nodeLookup.get(n2.id);
        return internalNode && (internalNode.selected = !1), createSelectionChange(n2.id, !1);
      }), edgeChanges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, !1));
      triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
    },
    setMinZoom: (minZoom2) => {
      const { panZoom, maxZoom: maxZoom2 } = get2();
      panZoom?.setScaleExtent([minZoom2, maxZoom2]), set2({ minZoom: minZoom2 });
    },
    setMaxZoom: (maxZoom2) => {
      const { panZoom, minZoom: minZoom2 } = get2();
      panZoom?.setScaleExtent([minZoom2, maxZoom2]), set2({ maxZoom: maxZoom2 });
    },
    setTranslateExtent: (translateExtent) => {
      get2().panZoom?.setTranslateExtent(translateExtent), set2({ translateExtent });
    },
    resetSelectedElements: () => {
      const { edges: edges2, nodes: nodes2, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get2();
      if (!elementsSelectable)
        return;
      const nodeChanges = nodes2.reduce((res, node) => node.selected ? [...res, createSelectionChange(node.id, !1)] : res, []), edgeChanges = edges2.reduce((res, edge) => edge.selected ? [...res, createSelectionChange(edge.id, !1)] : res, []);
      triggerNodeChanges(nodeChanges), triggerEdgeChanges(edgeChanges);
    },
    setNodeExtent: (nextNodeExtent) => {
      const { nodes: nodes2, nodeLookup, parentLookup, nodeOrigin: nodeOrigin2, elevateNodesOnSelect, nodeExtent: nodeExtent2, zIndexMode: zIndexMode2 } = get2();
      nextNodeExtent[0][0] === nodeExtent2[0][0] && nextNodeExtent[0][1] === nodeExtent2[0][1] && nextNodeExtent[1][0] === nodeExtent2[1][0] && nextNodeExtent[1][1] === nodeExtent2[1][1] || (adoptUserNodes(nodes2, nodeLookup, parentLookup, {
        nodeOrigin: nodeOrigin2,
        nodeExtent: nextNodeExtent,
        elevateNodesOnSelect,
        checkEquality: !1,
        zIndexMode: zIndexMode2
      }), set2({ nodeExtent: nextNodeExtent }));
    },
    panBy: (delta) => {
      const { transform: transform2, width: width2, height: height2, panZoom, translateExtent } = get2();
      return panBy({ delta, panZoom, transform: transform2, translateExtent, width: width2, height: height2 });
    },
    setCenter: async (x2, y2, options) => {
      const { width: width2, height: height2, maxZoom: maxZoom2, panZoom } = get2();
      if (!panZoom)
        return Promise.resolve(!1);
      const nextZoom = typeof options?.zoom < "u" ? options.zoom : maxZoom2;
      return await panZoom.setViewport({
        x: width2 / 2 - x2 * nextZoom,
        y: height2 / 2 - y2 * nextZoom,
        zoom: nextZoom
      }, { duration: options?.duration, ease: options?.ease, interpolate: options?.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      set2({
        connection: { ...initialConnection }
      });
    },
    updateConnection: (connection) => {
      set2({ connection });
    },
    reset: () => set2({ ...getInitialState() })
  };
}, Object.is);
function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, zIndexMode, children: children2 }) {
  const [store] = useState(() => createStore({
    nodes,
    edges,
    defaultNodes,
    defaultEdges,
    width,
    height,
    fitView,
    minZoom,
    maxZoom,
    fitViewOptions,
    nodeOrigin,
    nodeExtent,
    zIndexMode
  }));
  return jsx(Provider$1, { value: store, children: jsx(BatchProvider, { children: children2 }) });
}
function Wrapper({ children: children2, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode }) {
  return useContext(StoreContext) ? jsx(Fragment$1, { children: children2 }) : jsx(ReactFlowProvider, { initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, initialFitViewOptions: fitViewOptions, initialMinZoom: minZoom, initialMaxZoom: maxZoom, nodeOrigin, nodeExtent, zIndexMode, children: children2 });
}
const wrapperStyle = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = "Backspace", selectionKeyCode = "Shift", selectionOnDrag = !1, selectionMode = SelectionMode.Full, panActivationKeyCode = "Space", multiSelectionKeyCode = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode = isMacOs() ? "Meta" : "Control", snapToGrid, snapGrid, onlyRenderVisibleElements = !1, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = !0, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = !0, nodeExtent, defaultMarkerColor = "#b1b1b7", zoomOnScroll = !0, zoomOnPinch = !0, panOnScroll = !1, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = !0, panOnDrag = !0, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 1, nodeClickDistance = 0, children: children2, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = "nodrag", noWheelClassName = "nowheel", noPanClassName = "nopan", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = !0, elevateEdgesOnSelect = !1, disableKeyboardA11y = !1, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style: style2, id: id2, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = "light", debug: debug2, onScroll, ariaLabelConfig, zIndexMode = "basic", ...rest }, ref) {
  const rfId = id2 || "1", colorModeClassName = useColorModeClass(colorMode), wrapperOnScroll = useCallback((e2) => {
    e2.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), onScroll?.(e2);
  }, [onScroll]);
  return jsx("div", { "data-testid": "rf__wrapper", ...rest, onScroll: wrapperOnScroll, style: { ...style2, ...wrapperStyle }, ref, className: cc(["react-flow", className, colorModeClassName]), id: id2, role: "application", children: jsxs(Wrapper, { nodes, edges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode, children: [jsx(GraphView, { onInit, onNodeClick, onEdgeClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, nodeTypes, edgeTypes, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, deleteKeyCode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, onlyRenderVisibleElements, defaultViewport: defaultViewport$1, translateExtent, minZoom, maxZoom, preventScrolling, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, defaultMarkerColor, noDragClassName, noWheelClassName, noPanClassName, rfId, disableKeyboardA11y, nodeExtent, viewport, onViewportChange }), jsx(StoreUpdater, { nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, edgesFocusable, edgesReconnectable, elementsSelectable, elevateNodesOnSelect, elevateEdgesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, snapToGrid, snapGrid, connectionMode, translateExtent, connectOnClick, defaultEdgeOptions, fitView, fitViewOptions, onNodesDelete, onEdgesDelete, onDelete, onNodeDragStart, onNodeDrag, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, onMove, onMoveStart, onMoveEnd, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, onError, connectionRadius, isValidConnection, selectNodesOnDrag, nodeDragThreshold, connectionDragThreshold, onBeforeDelete, debug: debug2, ariaLabelConfig, zIndexMode }), jsx(SelectionListener, { onSelectionChange }), children2, jsx(Attribution, { proOptions, position: attributionPosition }), jsx(A11yDescriptions, { rfId, disableKeyboardA11y })] }) });
}
var index = fixedForwardRef(ReactFlow);
const selector$6 = (s) => s.domNode?.querySelector(".react-flow__edgelabel-renderer");
function EdgeLabelRenderer({ children: children2 }) {
  const edgeLabelRenderer = useStore$1(selector$6);
  return edgeLabelRenderer ? createPortal(children2, edgeLabelRenderer) : null;
}
function LinePattern({ dimensions, lineWidth, variant, className }) {
  return jsx("path", { strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`, className: cc(["react-flow__background-pattern", variant, className]) });
}
function DotPattern({ radius, className }) {
  return jsx("circle", { cx: radius, cy: radius, r: radius, className: cc(["react-flow__background-pattern", "dots", className]) });
}
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2.Lines = "lines", BackgroundVariant2.Dots = "dots", BackgroundVariant2.Cross = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
const defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
}, selector$3 = (s) => ({ transform: s.transform, patternId: `pattern-${s.rfId}` });
function BackgroundComponent({
  id: id2,
  variant = BackgroundVariant.Dots,
  // only used for dots and cross
  gap = 20,
  // only used for lines and cross
  size: size2,
  lineWidth = 1,
  offset: offset2 = 0,
  color: color2,
  bgColor,
  style: style2,
  className,
  patternClassName
}) {
  const ref = useRef(null), { transform: transform2, patternId } = useStore$1(selector$3, shallow$1), patternSize = size2 || defaultSize[variant], isDots = variant === BackgroundVariant.Dots, isCross = variant === BackgroundVariant.Cross, gapXY = Array.isArray(gap) ? gap : [gap, gap], scaledGap = [gapXY[0] * transform2[2] || 1, gapXY[1] * transform2[2] || 1], scaledSize = patternSize * transform2[2], offsetXY = Array.isArray(offset2) ? offset2 : [offset2, offset2], patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap, scaledOffset = [
    offsetXY[0] * transform2[2] || 1 + patternDimensions[0] / 2,
    offsetXY[1] * transform2[2] || 1 + patternDimensions[1] / 2
  ], _patternId = `${patternId}${id2 || ""}`;
  return jsxs("svg", { className: cc(["react-flow__background", className]), style: {
    ...style2,
    ...containerStyle,
    "--xy-background-color-props": bgColor,
    "--xy-background-pattern-color-props": color2
  }, ref, "data-testid": "rf__background", children: [jsx("pattern", { id: _patternId, x: transform2[0] % scaledGap[0], y: transform2[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`, children: isDots ? jsx(DotPattern, { radius: scaledSize / 2, className: patternClassName }) : jsx(LinePattern, { dimensions: patternDimensions, lineWidth, variant, className: patternClassName }) }), jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${_patternId})` })] });
}
BackgroundComponent.displayName = "Background";
const Background = memo$2(BackgroundComponent);
function PlusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function MinusIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function FitViewIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function LockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function UnlockIcon() {
  return jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function ControlButton({ children: children2, className, ...rest }) {
  return jsx("button", { type: "button", className: cc(["react-flow__controls-button", className]), ...rest, children: children2 });
}
const selector$2 = (s) => ({
  isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,
  minZoomReached: s.transform[2] <= s.minZoom,
  maxZoomReached: s.transform[2] >= s.maxZoom,
  ariaLabelConfig: s.ariaLabelConfig
});
function ControlsComponent({ style: style2, showZoom = !0, showFitView = !0, showInteractive = !0, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children: children2, position = "bottom-left", orientation = "vertical", "aria-label": ariaLabel }) {
  const store = useStoreApi(), { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore$1(selector$2, shallow$1), { zoomIn, zoomOut, fitView } = useReactFlow(), onZoomInHandler = () => {
    zoomIn(), onZoomIn?.();
  }, onZoomOutHandler = () => {
    zoomOut(), onZoomOut?.();
  }, onFitViewHandler = () => {
    fitView(fitViewOptions), onFitView?.();
  }, onToggleInteractivity = () => {
    store.setState({
      nodesDraggable: !isInteractive,
      nodesConnectable: !isInteractive,
      elementsSelectable: !isInteractive
    }), onInteractiveChange?.(!isInteractive);
  };
  return jsxs(Panel, { className: cc(["react-flow__controls", orientation === "horizontal" ? "horizontal" : "vertical", className]), position, style: style2, "data-testid": "rf__controls", "aria-label": ariaLabel ?? ariaLabelConfig["controls.ariaLabel"], children: [showZoom && jsxs(Fragment$1, { children: [jsx(ControlButton, { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: ariaLabelConfig["controls.zoomIn.ariaLabel"], "aria-label": ariaLabelConfig["controls.zoomIn.ariaLabel"], disabled: maxZoomReached, children: jsx(PlusIcon, {}) }), jsx(ControlButton, { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: ariaLabelConfig["controls.zoomOut.ariaLabel"], "aria-label": ariaLabelConfig["controls.zoomOut.ariaLabel"], disabled: minZoomReached, children: jsx(MinusIcon, {}) })] }), showFitView && jsx(ControlButton, { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: ariaLabelConfig["controls.fitView.ariaLabel"], "aria-label": ariaLabelConfig["controls.fitView.ariaLabel"], children: jsx(FitViewIcon, {}) }), showInteractive && jsx(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: ariaLabelConfig["controls.interactive.ariaLabel"], "aria-label": ariaLabelConfig["controls.interactive.ariaLabel"], children: isInteractive ? jsx(UnlockIcon, {}) : jsx(LockIcon, {}) }), children2] });
}
ControlsComponent.displayName = "Controls";
memo$2(ControlsComponent);
function MiniMapNodeComponent({ id: id2, x: x2, y: y2, width, height, style: style2, color: color2, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected: selected2, onClick }) {
  const { background, backgroundColor } = style2 || {}, fill = color2 || background || backgroundColor;
  return jsx("rect", { className: cc(["react-flow__minimap-node", { selected: selected2 }, className]), x: x2, y: y2, rx: borderRadius, ry: borderRadius, width, height, style: {
    fill,
    stroke: strokeColor,
    strokeWidth
  }, shapeRendering, onClick: onClick ? (event) => onClick(event, id2) : void 0 });
}
const MiniMapNode = memo$2(MiniMapNodeComponent), selectorNodeIds = (s) => s.nodes.map((node) => node.id), getAttrFunction = (func) => func instanceof Function ? func : () => func;
function MiniMapNodes({
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: NodeComponent = MiniMapNode,
  onClick
}) {
  const nodeIds = useStore$1(selectorNodeIds, shallow$1), nodeColorFunc = getAttrFunction(nodeColor), nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor), nodeClassNameFunc = getAttrFunction(nodeClassName), shapeRendering = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return jsx(Fragment$1, { children: nodeIds.map((nodeId) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    jsx(NodeComponentWrapper, { id: nodeId, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, NodeComponent, onClick, shapeRendering }, nodeId)
  )) });
}
function NodeComponentWrapperInner({ id: id2, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {
  const { node, x: x2, y: y2, width, height } = useStore$1((s) => {
    const { internals } = s.nodeLookup.get(id2), node2 = internals.userNode, { x: x22, y: y22 } = internals.positionAbsolute, { width: width2, height: height2 } = getNodeDimensions(node2);
    return {
      node: node2,
      x: x22,
      y: y22,
      width: width2,
      height: height2
    };
  }, shallow$1);
  return !node || node.hidden || !nodeHasDimensions(node) ? null : jsx(NodeComponent, { x: x2, y: y2, width, height, style: node.style, selected: !!node.selected, className: nodeClassNameFunc(node), color: nodeColorFunc(node), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node), strokeWidth: nodeStrokeWidth, shapeRendering, onClick, id: node.id });
}
const NodeComponentWrapper = memo$2(NodeComponentWrapperInner);
var MiniMapNodes$1 = memo$2(MiniMapNodes);
const defaultWidth = 200, defaultHeight = 150, filterHidden = (node) => !node.hidden, selector$1 = (s) => {
  const viewBB = {
    x: -s.transform[0] / s.transform[2],
    y: -s.transform[1] / s.transform[2],
    width: s.width / s.transform[2],
    height: s.height / s.transform[2]
  };
  return {
    viewBB,
    boundingRect: s.nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds(s.nodeLookup, { filter: filterHidden }), viewBB) : viewBB,
    rfId: s.rfId,
    panZoom: s.panZoom,
    translateExtent: s.translateExtent,
    flowWidth: s.width,
    flowHeight: s.height,
    ariaLabelConfig: s.ariaLabelConfig
  };
}, ARIA_LABEL_KEY = "react-flow__minimap-desc";
function MiniMapComponent({
  style: style2,
  className,
  nodeStrokeColor,
  nodeColor,
  nodeClassName = "",
  nodeBorderRadius = 5,
  nodeStrokeWidth,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent,
  bgColor,
  maskColor,
  maskStrokeColor,
  maskStrokeWidth,
  position = "bottom-right",
  onClick,
  onNodeClick,
  pannable = !1,
  zoomable = !1,
  ariaLabel,
  inversePan,
  zoomStep = 1,
  offsetScale = 5
}) {
  const store = useStoreApi(), svg = useRef(null), { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore$1(selector$1, shallow$1), elementWidth = style2?.width ?? defaultWidth, elementHeight = style2?.height ?? defaultHeight, scaledWidth = boundingRect.width / elementWidth, scaledHeight = boundingRect.height / elementHeight, viewScale = Math.max(scaledWidth, scaledHeight), viewWidth = viewScale * elementWidth, viewHeight = viewScale * elementHeight, offset2 = offsetScale * viewScale, x2 = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset2, y2 = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset2, width = viewWidth + offset2 * 2, height = viewHeight + offset2 * 2, labelledBy = `${ARIA_LABEL_KEY}-${rfId}`, viewScaleRef = useRef(0), minimapInstance = useRef();
  viewScaleRef.current = viewScale, useEffect(() => {
    if (svg.current && panZoom)
      return minimapInstance.current = XYMinimap({
        domNode: svg.current,
        panZoom,
        getTransform: () => store.getState().transform,
        getViewScale: () => viewScaleRef.current
      }), () => {
        minimapInstance.current?.destroy();
      };
  }, [panZoom]), useEffect(() => {
    minimapInstance.current?.update({
      translateExtent,
      width: flowWidth,
      height: flowHeight,
      inversePan,
      pannable,
      zoomStep,
      zoomable
    });
  }, [pannable, zoomable, inversePan, zoomStep, translateExtent, flowWidth, flowHeight]);
  const onSvgClick = onClick ? (event) => {
    const [x22, y22] = minimapInstance.current?.pointer(event) || [0, 0];
    onClick(event, { x: x22, y: y22 });
  } : void 0, onSvgNodeClick = onNodeClick ? useCallback((event, nodeId) => {
    const node = store.getState().nodeLookup.get(nodeId).internals.userNode;
    onNodeClick(event, node);
  }, []) : void 0, _ariaLabel = ariaLabel ?? ariaLabelConfig["minimap.ariaLabel"];
  return jsx(Panel, { position, style: {
    ...style2,
    "--xy-minimap-background-color-props": typeof bgColor == "string" ? bgColor : void 0,
    "--xy-minimap-mask-background-color-props": typeof maskColor == "string" ? maskColor : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof maskStrokeColor == "string" ? maskStrokeColor : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof maskStrokeWidth == "number" ? maskStrokeWidth * viewScale : void 0,
    "--xy-minimap-node-background-color-props": typeof nodeColor == "string" ? nodeColor : void 0,
    "--xy-minimap-node-stroke-color-props": typeof nodeStrokeColor == "string" ? nodeStrokeColor : void 0,
    "--xy-minimap-node-stroke-width-props": typeof nodeStrokeWidth == "number" ? nodeStrokeWidth : void 0
  }, className: cc(["react-flow__minimap", className]), "data-testid": "rf__minimap", children: jsxs("svg", { width: elementWidth, height: elementHeight, viewBox: `${x2} ${y2} ${width} ${height}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick, children: [_ariaLabel && jsx("title", { id: labelledBy, children: _ariaLabel }), jsx(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor, nodeStrokeColor, nodeBorderRadius, nodeClassName, nodeStrokeWidth, nodeComponent }), jsx("path", { className: "react-flow__minimap-mask", d: `M${x2 - offset2},${y2 - offset2}h${width + offset2 * 2}v${height + offset2 * 2}h${-width - offset2 * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
MiniMapComponent.displayName = "MiniMap";
memo$2(MiniMapComponent);
const scaleSelector = (calculateScale) => (store) => calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : void 0, defaultPositions = {
  [ResizeControlVariant.Line]: "right",
  [ResizeControlVariant.Handle]: "bottom-right"
};
function ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style: style2 = void 0, children: children2, color: color2, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = !1, resizeDirection, autoScale = !0, shouldResize, onResizeStart, onResize, onResizeEnd }) {
  const contextNodeId = useNodeId(), id2 = typeof nodeId == "string" ? nodeId : contextNodeId, store = useStoreApi(), resizeControlRef = useRef(null), isHandleControl = variant === ResizeControlVariant.Handle, scale2 = useStore$1(useCallback(scaleSelector(isHandleControl && autoScale), [isHandleControl, autoScale]), shallow$1), resizer = useRef(null), controlPosition = position ?? defaultPositions[variant];
  useEffect(() => {
    if (!(!resizeControlRef.current || !id2))
      return resizer.current || (resizer.current = XYResizer({
        domNode: resizeControlRef.current,
        nodeId: id2,
        getStoreItems: () => {
          const { nodeLookup, transform: transform2, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();
          return {
            nodeLookup,
            transform: transform2,
            snapGrid,
            snapToGrid,
            nodeOrigin,
            paneDomNode: domNode
          };
        },
        onChange: (change2, childChanges) => {
          const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState(), changes = [], nextPosition = { x: change2.x, y: change2.y }, node = nodeLookup.get(id2);
          if (node && node.expandParent && node.parentId) {
            const origin = node.origin ?? nodeOrigin, width = change2.width ?? node.measured.width ?? 0, height = change2.height ?? node.measured.height ?? 0, child = {
              id: node.id,
              parentId: node.parentId,
              rect: {
                width,
                height,
                ...evaluateAbsolutePosition({
                  x: change2.x ?? node.position.x,
                  y: change2.y ?? node.position.y
                }, { width, height }, node.parentId, nodeLookup, origin)
              }
            }, parentExpandChanges = handleExpandParent([child], nodeLookup, parentLookup, nodeOrigin);
            changes.push(...parentExpandChanges), nextPosition.x = change2.x ? Math.max(origin[0] * width, change2.x) : void 0, nextPosition.y = change2.y ? Math.max(origin[1] * height, change2.y) : void 0;
          }
          if (nextPosition.x !== void 0 && nextPosition.y !== void 0) {
            const positionChange = {
              id: id2,
              type: "position",
              position: { ...nextPosition }
            };
            changes.push(positionChange);
          }
          if (change2.width !== void 0 && change2.height !== void 0) {
            const dimensionChange = {
              id: id2,
              type: "dimensions",
              resizing: !0,
              setAttributes: resizeDirection ? resizeDirection === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: change2.width,
                height: change2.height
              }
            };
            changes.push(dimensionChange);
          }
          for (const childChange of childChanges) {
            const positionChange = {
              ...childChange,
              type: "position"
            };
            changes.push(positionChange);
          }
          triggerNodeChanges(changes);
        },
        onEnd: ({ width, height }) => {
          const dimensionChange = {
            id: id2,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width,
              height
            }
          };
          store.getState().triggerNodeChanges([dimensionChange]);
        }
      })), resizer.current.update({
        controlPosition,
        boundaries: {
          minWidth,
          minHeight,
          maxWidth,
          maxHeight
        },
        keepAspectRatio,
        resizeDirection,
        onResizeStart,
        onResize,
        onResizeEnd,
        shouldResize
      }), () => {
        resizer.current?.destroy();
      };
  }, [
    controlPosition,
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    keepAspectRatio,
    onResizeStart,
    onResize,
    onResizeEnd,
    shouldResize
  ]);
  const positionClassNames = controlPosition.split("-");
  return jsx("div", { className: cc(["react-flow__resize-control", "nodrag", ...positionClassNames, variant, className]), ref: resizeControlRef, style: {
    ...style2,
    scale: scale2,
    ...color2 && { [isHandleControl ? "backgroundColor" : "borderColor"]: color2 }
  }, children: children2 });
}
memo$2(ResizeControl);
const selector = (state) => state.domNode?.querySelector(".react-flow__renderer");
function NodeToolbarPortal({ children: children2 }) {
  const wrapperRef = useStore$1(selector);
  return wrapperRef ? createPortal(children2, wrapperRef) : null;
}
const nodeEqualityFn = (a2, b) => a2?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a2?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a2?.measured.width !== b?.measured.width || a2?.measured.height !== b?.measured.height || a2?.selected !== b?.selected || a2?.internals.z !== b?.internals.z, nodesEqualityFn = (a2, b) => {
  if (a2.size !== b.size)
    return !1;
  for (const [key, node] of a2)
    if (nodeEqualityFn(node, b.get(key)))
      return !1;
  return !0;
}, storeSelector = (state) => ({
  x: state.transform[0],
  y: state.transform[1],
  zoom: state.transform[2],
  selectedNodesCount: state.nodes.filter((node) => node.selected).length
});
function NodeToolbar({ nodeId, children: children2, className, style: style2, isVisible, position = Position.Top, offset: offset2 = 10, align = "center", ...rest }) {
  const contextNodeId = useNodeId(), nodesSelector2 = useCallback((state) => (Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ""]).reduce((res, id2) => {
    const node = state.nodeLookup.get(id2);
    return node && res.set(node.id, node), res;
  }, /* @__PURE__ */ new Map()), [nodeId, contextNodeId]), nodes = useStore$1(nodesSelector2, nodesEqualityFn), { x: x2, y: y2, zoom: zoom2, selectedNodesCount } = useStore$1(storeSelector, shallow$1);
  if (!(typeof isVisible == "boolean" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1) || !nodes.size)
    return null;
  const nodeRect = getInternalNodesBounds(nodes), nodesArray = Array.from(nodes.values()), zIndex = Math.max(...nodesArray.map((node) => node.internals.z + 1)), wrapperStyle2 = {
    position: "absolute",
    transform: getNodeToolbarTransform(nodeRect, { x: x2, y: y2, zoom: zoom2 }, position, offset2, align),
    zIndex,
    ...style2
  };
  return jsx(NodeToolbarPortal, { children: jsx("div", { style: wrapperStyle2, className: cc(["react-flow__node-toolbar", className]), ...rest, "data-id": nodesArray.reduce((acc, node) => `${acc}${node.id} `, "").trim(), children: children2 }) });
}
const { getOwnPropertyNames, getOwnPropertySymbols } = Object, { hasOwnProperty } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
  return function(a2, b, state) {
    return comparatorA(a2, b, state) && comparatorB(a2, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function(a2, b, state) {
    if (!a2 || !b || typeof a2 != "object" || typeof b != "object")
      return areItemsEqual(a2, b, state);
    const { cache: cache2 } = state, cachedA = cache2.get(a2), cachedB = cache2.get(b);
    if (cachedA && cachedB)
      return cachedA === b && cachedB === a2;
    cache2.set(a2, b), cache2.set(b, a2);
    const result = areItemsEqual(a2, b, state);
    return cache2.delete(a2), cache2.delete(b), result;
  };
}
function getStrictProperties(object2) {
  return getOwnPropertyNames(object2).concat(getOwnPropertySymbols(object2));
}
const hasOwn = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((object2, property) => hasOwnProperty.call(object2, property))
), PREACT_VNODE = "__v", PREACT_OWNER = "__o", REACT_OWNER = "_owner", { getOwnPropertyDescriptor, keys } = Object, sameValueEqual = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.is || function(a2, b) {
    return a2 === b ? a2 !== 0 || 1 / a2 === 1 / b : a2 !== a2 && b !== b;
  }
);
function strictEqual(a2, b) {
  return a2 === b;
}
function areArrayBuffersEqual(a2, b) {
  return a2.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a2), new Uint8Array(b));
}
function areArraysEqual(a2, b, state) {
  let index2 = a2.length;
  if (b.length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!state.equals(a2[index2], b[index2], index2, index2, a2, b, state))
      return !1;
  return !0;
}
function areDataViewsEqual(a2, b) {
  return a2.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}
function areDatesEqual(a2, b) {
  return sameValueEqual(a2.getTime(), b.getTime());
}
function areErrorsEqual(a2, b) {
  return a2.name === b.name && a2.message === b.message && a2.cause === b.cause && a2.stack === b.stack;
}
function areMapsEqual(a2, b, state) {
  const size2 = a2.size;
  if (size2 !== b.size)
    return !1;
  if (!size2)
    return !0;
  const matchedIndices = new Array(size2), aIterable = a2.entries();
  let aResult, bResult, index2 = 0;
  for (; (aResult = aIterable.next()) && !aResult.done; ) {
    const bIterable = b.entries();
    let hasMatch = !1, matchIndex = 0;
    for (; (bResult = bIterable.next()) && !bResult.done; ) {
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      const aEntry = aResult.value, bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index2, matchIndex, a2, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a2, b, state)) {
        hasMatch = matchedIndices[matchIndex] = !0;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch)
      return !1;
    index2++;
  }
  return !0;
}
function areObjectsEqual(a2, b, state) {
  const properties = keys(a2);
  let index2 = properties.length;
  if (keys(b).length !== index2)
    return !1;
  for (; index2-- > 0; )
    if (!isPropertyEqual(a2, b, state, properties[index2]))
      return !1;
  return !0;
}
function areObjectsEqualStrict(a2, b, state) {
  const properties = getStrictProperties(a2);
  let index2 = properties.length;
  if (getStrictProperties(b).length !== index2)
    return !1;
  let property, descriptorA, descriptorB;
  for (; index2-- > 0; )
    if (property = properties[index2], !isPropertyEqual(a2, b, state, property) || (descriptorA = getOwnPropertyDescriptor(a2, property), descriptorB = getOwnPropertyDescriptor(b, property), (descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)))
      return !1;
  return !0;
}
function arePrimitiveWrappersEqual(a2, b) {
  return sameValueEqual(a2.valueOf(), b.valueOf());
}
function areRegExpsEqual(a2, b) {
  return a2.source === b.source && a2.flags === b.flags;
}
function areSetsEqual(a2, b, state) {
  const size2 = a2.size;
  if (size2 !== b.size)
    return !1;
  if (!size2)
    return !0;
  const matchedIndices = new Array(size2), aIterable = a2.values();
  let aResult, bResult;
  for (; (aResult = aIterable.next()) && !aResult.done; ) {
    const bIterable = b.values();
    let hasMatch = !1, matchIndex = 0;
    for (; (bResult = bIterable.next()) && !bResult.done; ) {
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a2, b, state)) {
        hasMatch = matchedIndices[matchIndex] = !0;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch)
      return !1;
  }
  return !0;
}
function areTypedArraysEqual(a2, b) {
  let index2 = a2.byteLength;
  if (b.byteLength !== index2 || a2.byteOffset !== b.byteOffset)
    return !1;
  for (; index2-- > 0; )
    if (a2[index2] !== b[index2])
      return !1;
  return !0;
}
function areUrlsEqual(a2, b) {
  return a2.hostname === b.hostname && a2.pathname === b.pathname && a2.protocol === b.protocol && a2.port === b.port && a2.hash === b.hash && a2.username === b.username && a2.password === b.password;
}
function isPropertyEqual(a2, b, state, property) {
  return (property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a2.$$typeof || b.$$typeof) ? !0 : hasOwn(b, property) && state.equals(a2[property], b[property], property, property, a2, b, state);
}
const toString = Object.prototype.toString;
function createEqualityComparator(config2) {
  const supportedComparatorMap = createSupportedComparatorMap(config2), { areArraysEqual: areArraysEqual2, areDatesEqual: areDatesEqual2, areFunctionsEqual, areMapsEqual: areMapsEqual2, areNumbersEqual, areObjectsEqual: areObjectsEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, getUnsupportedCustomComparator } = config2;
  return function(a2, b, state) {
    if (a2 === b)
      return !0;
    if (a2 == null || b == null)
      return !1;
    const type = typeof a2;
    if (type !== typeof b)
      return !1;
    if (type !== "object")
      return type === "number" || type === "bigint" ? areNumbersEqual(a2, b, state) : type === "function" ? areFunctionsEqual(a2, b, state) : !1;
    const constructor = a2.constructor;
    if (constructor !== b.constructor)
      return !1;
    if (constructor === Object)
      return areObjectsEqual2(a2, b, state);
    if (constructor === Array)
      return areArraysEqual2(a2, b, state);
    if (constructor === Date)
      return areDatesEqual2(a2, b, state);
    if (constructor === RegExp)
      return areRegExpsEqual2(a2, b, state);
    if (constructor === Map)
      return areMapsEqual2(a2, b, state);
    if (constructor === Set)
      return areSetsEqual2(a2, b, state);
    if (constructor === Promise)
      return !1;
    if (Array.isArray(a2))
      return areArraysEqual2(a2, b, state);
    const tag = toString.call(a2), supportedComparator = supportedComparatorMap[tag];
    if (supportedComparator)
      return supportedComparator(a2, b, state);
    const unsupportedCustomComparator = getUnsupportedCustomComparator && getUnsupportedCustomComparator(a2, b, state, tag);
    return unsupportedCustomComparator ? unsupportedCustomComparator(a2, b, state) : !1;
  };
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
  let config2 = {
    areArrayBuffersEqual,
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDataViewsEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual: strictEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual: sameValueEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
    areUrlsEqual,
    getUnsupportedCustomComparator: void 0
  };
  if (createCustomConfig && (config2 = Object.assign({}, config2, createCustomConfig(config2))), circular) {
    const areArraysEqual2 = createIsCircular(config2.areArraysEqual), areMapsEqual2 = createIsCircular(config2.areMapsEqual), areObjectsEqual2 = createIsCircular(config2.areObjectsEqual), areSetsEqual2 = createIsCircular(config2.areSetsEqual);
    config2 = Object.assign({}, config2, {
      areArraysEqual: areArraysEqual2,
      areMapsEqual: areMapsEqual2,
      areObjectsEqual: areObjectsEqual2,
      areSetsEqual: areSetsEqual2
    });
  }
  return config2;
}
function createInternalEqualityComparator(compare) {
  return function(a2, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a2, b, state);
  };
}
function createIsEqual({ circular, comparator, createState: createState2, equals, strict }) {
  if (createState2)
    return function(a2, b) {
      const { cache: cache2 = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta } = createState2();
      return comparator(a2, b, {
        cache: cache2,
        equals,
        meta,
        strict
      });
    };
  if (circular)
    return function(a2, b) {
      return comparator(a2, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  const state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function(a2, b) {
    return comparator(a2, b, state);
  };
}
function createSupportedComparatorMap({ areArrayBuffersEqual: areArrayBuffersEqual2, areArraysEqual: areArraysEqual2, areDataViewsEqual: areDataViewsEqual2, areDatesEqual: areDatesEqual2, areErrorsEqual: areErrorsEqual2, areFunctionsEqual, areMapsEqual: areMapsEqual2, areNumbersEqual, areObjectsEqual: areObjectsEqual2, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, areTypedArraysEqual: areTypedArraysEqual2, areUrlsEqual: areUrlsEqual2 }) {
  return {
    "[object Arguments]": areObjectsEqual2,
    "[object Array]": areArraysEqual2,
    "[object ArrayBuffer]": areArrayBuffersEqual2,
    "[object AsyncGeneratorFunction]": areFunctionsEqual,
    "[object BigInt]": areNumbersEqual,
    "[object BigInt64Array]": areTypedArraysEqual2,
    "[object BigUint64Array]": areTypedArraysEqual2,
    "[object Boolean]": arePrimitiveWrappersEqual2,
    "[object DataView]": areDataViewsEqual2,
    "[object Date]": areDatesEqual2,
    // If an error tag, it should be tested explicitly. Like RegExp, the properties are not
    // enumerable, and therefore will give false positives if tested like a standard object.
    "[object Error]": areErrorsEqual2,
    "[object Float16Array]": areTypedArraysEqual2,
    "[object Float32Array]": areTypedArraysEqual2,
    "[object Float64Array]": areTypedArraysEqual2,
    "[object Function]": areFunctionsEqual,
    "[object GeneratorFunction]": areFunctionsEqual,
    "[object Int8Array]": areTypedArraysEqual2,
    "[object Int16Array]": areTypedArraysEqual2,
    "[object Int32Array]": areTypedArraysEqual2,
    "[object Map]": areMapsEqual2,
    "[object Number]": arePrimitiveWrappersEqual2,
    "[object Object]": (a2, b, state) => (
      // The exception for value comparison is custom `Promise`-like class instances. These should
      // be treated the same as standard `Promise` objects, which means strict equality, and if
      // it reaches this point then that strict equality comparison has already failed.
      typeof a2.then != "function" && typeof b.then != "function" && areObjectsEqual2(a2, b, state)
    ),
    // For RegExp, the properties are not enumerable, and therefore will give false positives if
    // tested like a standard object.
    "[object RegExp]": areRegExpsEqual2,
    "[object Set]": areSetsEqual2,
    "[object String]": arePrimitiveWrappersEqual2,
    "[object URL]": areUrlsEqual2,
    "[object Uint8Array]": areTypedArraysEqual2,
    "[object Uint8ClampedArray]": areTypedArraysEqual2,
    "[object Uint16Array]": areTypedArraysEqual2,
    "[object Uint32Array]": areTypedArraysEqual2
  };
}
const deepEqual = createCustomEqual();
createCustomEqual({ strict: !0 });
createCustomEqual({ circular: !0 });
createCustomEqual({
  circular: !0,
  strict: !0
});
const shallowEqual = createCustomEqual({
  createInternalComparator: () => sameValueEqual
});
createCustomEqual({
  strict: !0,
  createInternalComparator: () => sameValueEqual
});
createCustomEqual({
  circular: !0,
  createInternalComparator: () => sameValueEqual
});
createCustomEqual({
  circular: !0,
  createInternalComparator: () => sameValueEqual,
  strict: !0
});
function createCustomEqual(options = {}) {
  const { circular = !1, createInternalComparator: createCustomInternalComparator, createState: createState2, strict = !1 } = options, config2 = createEqualityComparatorConfig(options), comparator = createEqualityComparator(config2), equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState: createState2, equals, strict });
}
const { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v) {
  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
}
const pi$2 = Math.PI, tau$1 = 2 * pi$2, quart = pi$2 / 2, epsilon$2 = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = { x: 0, y: 0, z: 0 }, utils = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t2, derivativeFn) {
    const d = derivativeFn(t2);
    let l = d.x * d.x + d.y * d.y;
    return typeof d.z < "u" && (l += d.z * d.z), sqrt$1(l);
  },
  compute: function(t2, points, _3d) {
    if (t2 === 0)
      return points[0].t = 0, points[0];
    const order = points.length - 1;
    if (t2 === 1)
      return points[order].t = 1, points[order];
    const mt2 = 1 - t2;
    let p = points;
    if (order === 0)
      return points[0].t = t2, points[0];
    if (order === 1) {
      const ret = {
        x: mt2 * p[0].x + t2 * p[1].x,
        y: mt2 * p[0].y + t2 * p[1].y,
        t: t2
      };
      return _3d && (ret.z = mt2 * p[0].z + t2 * p[1].z), ret;
    }
    if (order < 4) {
      let mt22 = mt2 * mt2, t22 = t2 * t2, a2, b, c, d = 0;
      order === 2 ? (p = [p[0], p[1], p[2], ZERO], a2 = mt22, b = mt2 * t2 * 2, c = t22) : order === 3 && (a2 = mt22 * mt2, b = mt22 * t2 * 3, c = mt2 * t22 * 3, d = t2 * t22);
      const ret = {
        x: a2 * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
        y: a2 * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,
        t: t2
      };
      return _3d && (ret.z = a2 * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z), ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    for (; dCpts.length > 1; ) {
      for (let i2 = 0; i2 < dCpts.length - 1; i2++)
        dCpts[i2] = {
          x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t2,
          y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t2
        }, typeof dCpts[i2].z < "u" && (dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t2);
      dCpts.splice(dCpts.length - 1, 1);
    }
    return dCpts[0].t = t2, dCpts[0];
  },
  computeWithRatios: function(t2, points, ratios, _3d) {
    const mt2 = 1 - t2, r2 = ratios, p = points;
    let f1 = r2[0], f2 = r2[1], f3 = r2[2], f4 = r2[3], d;
    if (f1 *= mt2, f2 *= t2, p.length === 2)
      return d = f1 + f2, {
        x: (f1 * p[0].x + f2 * p[1].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y) / d,
        z: _3d ? (f1 * p[0].z + f2 * p[1].z) / d : !1,
        t: t2
      };
    if (f1 *= mt2, f2 *= 2 * mt2, f3 *= t2 * t2, p.length === 3)
      return d = f1 + f2 + f3, {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
        z: _3d ? (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d : !1,
        t: t2
      };
    if (f1 *= mt2, f2 *= 1.5 * mt2, f3 *= 3 * mt2, f4 *= t2 * t2 * t2, p.length === 4)
      return d = f1 + f2 + f3 + f4, {
        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
        z: _3d ? (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d : !1,
        t: t2
      };
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
      const list2 = [];
      for (let j = 0, dpt; j < c; j++)
        dpt = {
          x: c * (p[j + 1].x - p[j].x),
          y: c * (p[j + 1].y - p[j].y)
        }, _3d && (dpt.z = c * (p[j + 1].z - p[j].z)), list2.push(dpt);
      dpoints.push(list2), p = list2;
    }
    return dpoints;
  },
  between: function(v, m2, M) {
    return m2 <= v && v <= M || utils.approximately(v, m2) || utils.approximately(v, M);
  },
  approximately: function(a2, b, precision) {
    return abs$1(a2 - b) <= (precision || epsilon$2);
  },
  length: function(derivativeFn) {
    const len = utils.Tvalues.length;
    let sum = 0;
    for (let i2 = 0, t2; i2 < len; i2++)
      t2 = 0.5 * utils.Tvalues[i2] + 0.5, sum += utils.Cvalues[i2] * utils.arcfn(t2, derivativeFn);
    return 0.5 * sum;
  },
  map: function(v, ds, de2, ts, te2) {
    const d1 = de2 - ds, d2 = te2 - ts, v2 = v - ds, r2 = v2 / d1;
    return ts + d2 * r2;
  },
  lerp: function(r2, v1, v2) {
    const ret = {
      x: v1.x + r2 * (v2.x - v1.x),
      y: v1.y + r2 * (v2.y - v1.y)
    };
    return v1.z !== void 0 && v2.z !== void 0 && (ret.z = v1.z + r2 * (v2.z - v1.z)), ret;
  },
  pointToString: function(p) {
    let s = p.x + "/" + p.y;
    return typeof p.z < "u" && (s += "/" + p.z), s;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o, v1, v2) {
    const dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot);
  },
  // round as string, to avoid rounding errors
  round: function(v, d) {
    const s = "" + v, pos = s.indexOf(".");
    return parseFloat(s.substring(0, pos + 1 + d));
  },
  dist: function(p1, p2) {
    const dx = p1.x - p2.x, dy = p1.y - p2.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point2) {
    let mdist = pow(2, 63), mpos, d;
    return LUT.forEach(function(p, idx) {
      d = utils.dist(point2, p), d < mdist && (mdist = d, mpos = idx);
    }), { mdist, mpos };
  },
  abcratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const bottom = pow(t2, n2) + pow(1 - t2, n2), top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function(t2, n2) {
    if (n2 !== 2 && n2 !== 3)
      return !1;
    if (typeof t2 > "u")
      t2 = 0.5;
    else if (t2 === 0 || t2 === 1)
      return t2;
    const top = pow(1 - t2, n2), bottom = pow(t2, n2) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    return d == 0 ? !1 : { x: nx / d, y: ny / d };
  },
  lli4: function(p1, p2, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
  },
  lli: function(v1, v2) {
    return utils.lli4(v1, v1.c, v2, v2.c);
  },
  makeline: function(p1, p2) {
    return new Bezier(
      p1.x,
      p1.y,
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2,
      p2.x,
      p2.y
    );
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    return sections.forEach(function(s) {
      const bbox = s.bbox();
      mx > bbox.x.min && (mx = bbox.x.min), my > bbox.y.min && (my = bbox.y.min), MX < bbox.x.max && (MX = bbox.x.max), MY < bbox.y.max && (MY = bbox.y.max);
    }), {
      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
    };
  },
  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox2)) return [];
    const intersections = [], a1 = [s1.startcap, s1.forward, s1.back, s1.endcap], a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
    return a1.forEach(function(l1) {
      l1.virtual || a2.forEach(function(l2) {
        if (l2.virtual) return;
        const iss = l1.intersects(l2, curveIntersectionThreshold);
        iss.length > 0 && (iss.c1 = l1, iss.c2 = l2, iss.s1 = s1, iss.s2 = s2, intersections.push(iss));
      });
    }), intersections;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length, fpl = forward.points.length, start2 = utils.makeline(back.points[bpl - 1], forward.points[0]), end = utils.makeline(forward.points[fpl - 1], back.points[0]), shape = {
      startcap: start2,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([start2, forward, back, end])
    };
    return shape.intersections = function(s2) {
      return utils.shapeintersections(
        shape,
        shape.bbox,
        s2,
        s2.bbox,
        curveIntersectionThreshold
      );
    }, shape;
  },
  getminmax: function(curve, d, list2) {
    if (!list2) return { min: 0, max: 0 };
    let min2 = nMax, max2 = nMin, t2, c;
    list2.indexOf(0) === -1 && (list2 = [0].concat(list2)), list2.indexOf(1) === -1 && list2.push(1);
    for (let i2 = 0, len = list2.length; i2 < len; i2++)
      t2 = list2[i2], c = curve.get(t2), c[d] < min2 && (min2 = c[d]), c[d] > max2 && (max2 = c[d]);
    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };
  },
  align: function(points, line) {
    const tx = line.p1.x, ty = line.p1.y, a2 = -atan2(line.p2.y - ty, line.p2.x - tx), d = function(v) {
      return {
        x: (v.x - tx) * cos$1(a2) - (v.y - ty) * sin$1(a2),
        y: (v.x - tx) * sin$1(a2) + (v.y - ty) * cos$1(a2)
      };
    };
    return points.map(d);
  },
  roots: function(points, line) {
    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const order = points.length - 1, aligned = utils.align(points, line), reduce = function(t2) {
      return 0 <= t2 && t2 <= 1;
    };
    if (order === 2) {
      const a3 = aligned[0].y, b2 = aligned[1].y, c2 = aligned[2].y, d2 = a3 - 2 * b2 + c2;
      if (d2 !== 0) {
        const m1 = -sqrt$1(b2 * b2 - a3 * c2), m2 = -a3 + b2, v12 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
        return [v12, v2].filter(reduce);
      } else if (b2 !== c2 && d2 === 0)
        return [(2 * b2 - c2) / (2 * b2 - 2 * c2)].filter(reduce);
      return [];
    }
    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c = pa;
    if (utils.approximately(d, 0)) {
      if (utils.approximately(a2, 0))
        return utils.approximately(b, 0) ? [] : [-c / b].filter(reduce);
      const q3 = sqrt$1(b * b - 4 * a2 * c), a22 = 2 * a2;
      return [(q3 - b) / a22, (-b - q3) / a22].filter(reduce);
    }
    a2 /= d, b /= d, c /= d;
    const p = (3 * b - a2 * a2) / 3, p3 = p / 3, q = (2 * a2 * a2 * a2 - 9 * a2 * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
    let u1, v1, x1, x2, x3;
    if (discriminant < 0) {
      const mp3 = -p / 3, mp33 = mp3 * mp3 * mp3, r2 = sqrt$1(mp33), t2 = -q / (2 * r2), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos$1(cosphi), crtr = crt(r2), t1 = 2 * crtr;
      return x1 = t1 * cos$1(phi / 3) - a2 / 3, x2 = t1 * cos$1((phi + tau$1) / 3) - a2 / 3, x3 = t1 * cos$1((phi + 2 * tau$1) / 3) - a2 / 3, [x1, x2, x3].filter(reduce);
    } else {
      if (discriminant === 0)
        return u1 = q2 < 0 ? crt(-q2) : -crt(q2), x1 = 2 * u1 - a2 / 3, x2 = -u1 - a2 / 3, [x1, x2].filter(reduce);
      {
        const sd = sqrt$1(discriminant);
        return u1 = crt(-q2 + sd), v1 = crt(q2 + sd), [u1 - v1 - a2 / 3].filter(reduce);
      }
    }
  },
  droots: function(p) {
    if (p.length === 3) {
      const a2 = p[0], b = p[1], c = p[2], d = a2 - 2 * b + c;
      if (d !== 0) {
        const m1 = -sqrt$1(b * b - a2 * c), m2 = -a2 + b, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;
        return [v1, v2];
      } else if (b !== c && d === 0)
        return [(2 * b - c) / (2 * (b - c))];
      return [];
    }
    if (p.length === 2) {
      const a2 = p[0], b = p[1];
      return a2 !== b ? [a2 / (a2 - b)] : [];
    }
    return [];
  },
  curvature: function(t2, d1, d2, _3d, kOnly) {
    let num, dnm, adk, dk, k = 0, r2 = 0;
    const d = utils.compute(t2, d1), dd = utils.compute(t2, d2), qdsum = d.x * d.x + d.y * d.y;
    if (_3d ? (num = sqrt$1(
      pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2)
    ), dnm = pow(qdsum + d.z * d.z, 3 / 2)) : (num = d.x * dd.y - d.y * dd.x, dnm = pow(qdsum, 3 / 2)), num === 0 || dnm === 0)
      return { k: 0, r: 0 };
    if (k = num / dnm, r2 = dnm / num, !kOnly) {
      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, !0).k, nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, !0).k;
      dk = (nk - k + (k - pk)) / 2, adk = (abs$1(nk - k) + abs$1(k - pk)) / 2;
    }
    return { k, r: r2, dk, adk };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p[2].x * p[1].y, b = p[3].x * p[1].y, c = p[1].x * p[2].y, d = p[3].x * p[2].y, v1 = 18 * (-3 * a2 + 2 * b + 3 * c - d), v2 = 18 * (3 * a2 - b - 3 * c), v3 = 18 * (c - a2);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v2, 0)) {
        let t2 = -v3 / v2;
        if (0 <= t2 && t2 <= 1) return [t2];
      }
      return [];
    }
    const d2 = 2 * v1;
    if (utils.approximately(d2, 0)) return [];
    const trm = v2 * v2 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function(r2) {
      return 0 <= r2 && r2 <= 1;
    });
  },
  bboxoverlap: function(b1, b2) {
    const dims = ["x", "y"], len = dims.length;
    for (let i2 = 0, dim, l, t2, d; i2 < len; i2++)
      if (dim = dims[i2], l = b1[dim].mid, t2 = b2[dim].mid, d = (b1[dim].size + b2[dim].size) / 2, abs$1(l - t2) >= d) return !1;
    return !0;
  },
  expandbox: function(bbox, _bbox) {
    _bbox.x.min < bbox.x.min && (bbox.x.min = _bbox.x.min), _bbox.y.min < bbox.y.min && (bbox.y.min = _bbox.y.min), _bbox.z && _bbox.z.min < bbox.z.min && (bbox.z.min = _bbox.z.min), _bbox.x.max > bbox.x.max && (bbox.x.max = _bbox.x.max), _bbox.y.max > bbox.y.max && (bbox.y.max = _bbox.y.max), _bbox.z && _bbox.z.max > bbox.z.max && (bbox.z.max = _bbox.z.max), bbox.x.mid = (bbox.x.min + bbox.x.max) / 2, bbox.y.mid = (bbox.y.min + bbox.y.max) / 2, bbox.z && (bbox.z.mid = (bbox.z.min + bbox.z.max) / 2), bbox.x.size = bbox.x.max - bbox.x.min, bbox.y.size = bbox.y.max - bbox.y.min, bbox.z && (bbox.z.size = bbox.z.max - bbox.z.min);
  },
  pairiteration: function(c1, c2, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c2.bbox(), r2 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold)
      return [
        (r2 * (c1._t1 + c1._t2) / 2 | 0) / r2 + "/" + (r2 * (c2._t1 + c2._t2) / 2 | 0) / r2
      ];
    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
      { left: cc1.left, right: cc2.left },
      { left: cc1.left, right: cc2.right },
      { left: cc1.right, right: cc2.right },
      { left: cc1.right, right: cc2.left }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    return pairs.length === 0 || (pairs.forEach(function(pair) {
      results = results.concat(
        utils.pairiteration(pair.left, pair.right, threshold)
      );
    }), results = results.filter(function(v, i2) {
      return results.indexOf(v) === i2;
    })), results;
  },
  getccenter: function(p1, p2, p3) {
    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r2 = utils.dist(arc, p1);
    let s = atan2(p1.y - arc.y, p1.x - arc.x), m2 = atan2(p2.y - arc.y, p2.x - arc.x), e2 = atan2(p3.y - arc.y, p3.x - arc.x), _2;
    return s < e2 ? ((s > m2 || m2 > e2) && (s += tau$1), s > e2 && (_2 = e2, e2 = s, s = _2)) : e2 < m2 && m2 < s ? (_2 = e2, e2 = s, s = _2) : e2 += tau$1, arc.s = s, arc.e = e2, arc.r = r2, arc;
  },
  numberSort: function(a2, b) {
    return a2 - b;
  }
};
class PolyBezier {
  constructor(curves) {
    this.curves = [], this._3d = !1, curves && (this.curves = curves, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve) {
      return utils.pointsToString(curve.points);
    }).join(", ") + "]";
  }
  addCurve(curve) {
    this.curves.push(curve), this._3d = this._3d || curve._3d;
  }
  length() {
    return this.curves.map(function(v) {
      return v.length();
    }).reduce(function(a2, b) {
      return a2 + b;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c = this.curves;
    for (var bbox = c[0].bbox(), i2 = 1; i2 < c.length; i2++)
      utils.expandbox(bbox, c[i2].bbox());
    return bbox;
  }
  offset(d) {
    const offset2 = [];
    return this.curves.forEach(function(v) {
      offset2.push(...v.offset(d));
    }), new PolyBezier(offset2);
  }
}
const { abs, min, max, cos, sin, acos, sqrt } = Math, pi$1 = Math.PI;
class Bezier {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice(), coordlen = !1;
    if (typeof args[0] == "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point3) {
        ["x", "y", "z"].forEach(function(d) {
          typeof point3[d] < "u" && newargs.push(point3[d]);
        });
      }), args = newargs;
    }
    let higher = !1;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        higher = !0;
      }
    } else if (len !== 6 && len !== 8 && len !== 9 && len !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z < "u", points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point2 = {
        x: args[idx],
        y: args[idx + 1]
      };
      _3d && (point2.z = args[idx + 2]), points.push(point2);
    }
    const order = this.order = points.length - 1, dims = this.dims = ["x", "y"];
    _3d && dims.push("z"), this.dimlen = dims.length;
    const aligned = utils.align(points, { p1: points[0], p2: points[order] }), baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t2, p) => t2 + abs(p.y), 0) < baselength / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(p1, p2, p3, t2) {
    if (typeof t2 > "u" && (t2 = 0.5), t2 === 0)
      return new Bezier(p2, p2, p3);
    if (t2 === 1)
      return new Bezier(p1, p2, p2);
    const abc = Bezier.getABC(2, p1, p2, p3, t2);
    return new Bezier(p1, abc.A, p3);
  }
  static cubicFromPoints(S, B2, E2, t2, d1) {
    typeof t2 > "u" && (t2 = 0.5);
    const abc = Bezier.getABC(3, S, B2, E2, t2);
    typeof d1 > "u" && (d1 = utils.dist(B2, abc.C));
    const d2 = d1 * (1 - t2) / t2, selen = utils.dist(S, E2), lx = (E2.x - S.x) / selen, ly = (E2.y - S.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly, e1 = { x: B2.x - bx1, y: B2.y - by1 }, e2 = { x: B2.x + bx2, y: B2.y + by2 }, A2 = abc.A, v1 = { x: A2.x + (e1.x - A2.x) / (1 - t2), y: A2.y + (e1.y - A2.y) / (1 - t2) }, v2 = { x: A2.x + (e2.x - A2.x) / t2, y: A2.y + (e2.y - A2.y) / t2 }, nc1 = { x: S.x + (v1.x - S.x) / t2, y: S.y + (v1.y - S.y) / t2 }, nc2 = {
      x: E2.x + (v2.x - E2.x) / (1 - t2),
      y: E2.y + (v2.y - E2.y) / (1 - t2)
    };
    return new Bezier(S, nc1, nc2, E2);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const p = this.points, x2 = p[0].x, y2 = p[0].y, s = ["M", x2, y2, this.order === 2 ? "Q" : "C"];
    for (let i2 = 1, last2 = p.length; i2 < last2; i2++)
      s.push(p[i2].x), s.push(p[i2].y);
    return s.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = ratios, this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    print !== this._print && (this._print = print, this.update());
  }
  coordDigest() {
    return this.points.map(function(c, pos) {
      return "" + pos + c.x + c.y + (c.z ? c.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = utils.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const points = this.points, angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S, B2, E2, t2 = 0.5) {
    const u = utils.projectionratio(t2, order), um = 1 - u, C = {
      x: u * S.x + um * E2.x,
      y: u * S.y + um * E2.y
    }, s = utils.abcratio(t2, order);
    return { A: {
      x: B2.x + (B2.x - C.x) / s,
      y: B2.y + (B2.y - C.y) / s
    }, B: B2, C, S, E: E2 };
  }
  getABC(t2, B2) {
    B2 = B2 || this.get(t2);
    let S = this.points[0], E2 = this.points[this.order];
    return Bezier.getABC(this.order, S, B2, E2, t2);
  }
  getLUT(steps) {
    if (this.verify(), steps = steps || 100, this._lut.length === steps + 1)
      return this._lut;
    this._lut = [], steps++, this._lut = [];
    for (let i2 = 0, p, t2; i2 < steps; i2++)
      t2 = i2 / (steps - 1), p = this.compute(t2), p.t = t2, this._lut.push(p);
    return this._lut;
  }
  on(point2, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i2 = 0, c, t2 = 0; i2 < lut.length; i2++)
      c = lut[i2], utils.dist(c, point2) < error && (hits.push(c), t2 += i2 / lut.length);
    return hits.length ? t /= hits.length : !1;
  }
  project(point2) {
    const LUT = this.getLUT(), l = LUT.length - 1, closest = utils.closest(LUT, point2), mpos = closest.mpos, t1 = (mpos - 1) / l, t2 = (mpos + 1) / l, step = 0.1 / l;
    let mdist = closest.mdist, t3 = t1, ft2 = t3, p;
    mdist += 1;
    for (let d; t3 < t2 + step; t3 += step)
      p = this.compute(t3), d = utils.dist(point2, p), d < mdist && (mdist = d, ft2 = t3);
    return ft2 = ft2 < 0 ? 0 : ft2 > 1 ? 1 : ft2, p = this.compute(ft2), p.t = ft2, p.d = mdist, p;
  }
  get(t2) {
    return this.compute(t2);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t2) {
    return this.ratios ? utils.computeWithRatios(t2, this.points, this.ratios, this._3d) : utils.compute(t2, this.points, this._3d, this.ratios);
  }
  raise() {
    const p = this.points, np = [p[0]], k = p.length;
    for (let i2 = 1, pi2, pim; i2 < k; i2++)
      pi2 = p[i2], pim = p[i2 - 1], np[i2] = {
        x: (k - i2) / k * pi2.x + i2 / k * pim.x,
        y: (k - i2) / k * pi2.y + i2 / k * pim.y
      };
    return np[k] = p[k - 1], new Bezier(np);
  }
  derivative(t2) {
    return utils.compute(t2, this.dpoints[0], this._3d);
  }
  dderivative(t2) {
    return utils.compute(t2, this.dpoints[1], this._3d);
  }
  align() {
    let p = this.points;
    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
  }
  curvature(t2) {
    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t2) {
    return this._3d ? this.__normal3(t2) : this.__normal2(t2);
  }
  __normal2(t2) {
    const d = this.derivative(t2), q = sqrt(d.x * d.x + d.y * d.y);
    return { t: t2, x: -d.y / q, y: d.x / q };
  }
  __normal3(t2) {
    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
    r1.x /= q1, r1.y /= q1, r1.z /= q1, r2.x /= q2, r2.y /= q2, r2.z /= q2;
    const c = {
      x: r2.y * r1.z - r2.z * r1.y,
      y: r2.z * r1.x - r2.x * r1.z,
      z: r2.x * r1.y - r2.y * r1.x
    }, m2 = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
    c.x /= m2, c.y /= m2, c.z /= m2;
    const R2 = [
      c.x * c.x,
      c.x * c.y - c.z,
      c.x * c.z + c.y,
      c.x * c.y + c.z,
      c.y * c.y,
      c.y * c.z - c.x,
      c.x * c.z - c.y,
      c.y * c.z + c.x,
      c.z * c.z
    ];
    return {
      t: t2,
      x: R2[0] * r1.x + R2[1] * r1.y + R2[2] * r1.z,
      y: R2[3] * r1.x + R2[4] * r1.y + R2[5] * r1.z,
      z: R2[6] * r1.x + R2[7] * r1.y + R2[8] * r1.z
    };
  }
  hull(t2) {
    let p = this.points, _p = [], q = [], idx = 0;
    for (q[idx++] = p[0], q[idx++] = p[1], q[idx++] = p[2], this.order === 3 && (q[idx++] = p[3]); p.length > 1; ) {
      _p = [];
      for (let i2 = 0, pt2, l = p.length - 1; i2 < l; i2++)
        pt2 = utils.lerp(t2, p[i2], p[i2 + 1]), q[idx++] = pt2, _p.push(pt2);
      p = _p;
    }
    return q;
  }
  split(t1, t2) {
    if (t1 === 0 && t2)
      return this.split(t2).left;
    if (t2 === 1)
      return this.split(t1).right;
    const q = this.hull(t1), result = {
      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),
      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),
      span: q
    };
    return result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2), result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2), result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2), t2 ? (t2 = utils.map(t2, t1, 1, 0, 1), result.right.split(t2).left) : result;
  }
  extrema() {
    const result = {};
    let roots = [];
    return this.dims.forEach(
      function(dim) {
        let mfn = function(v) {
          return v[dim];
        }, p = this.dpoints[0].map(mfn);
        result[dim] = utils.droots(p), this.order === 3 && (p = this.dpoints[1].map(mfn), result[dim] = result[dim].concat(utils.droots(p))), result[dim] = result[dim].filter(function(t2) {
          return t2 >= 0 && t2 <= 1;
        }), roots = roots.concat(result[dim].sort(utils.numberSort));
      }.bind(this)
    ), result.values = roots.sort(utils.numberSort).filter(function(v, idx) {
      return roots.indexOf(v) === idx;
    }), result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    return this.dims.forEach(
      function(d) {
        result[d] = utils.getminmax(this, d, extrema[d]);
      }.bind(this)
    ), result;
  }
  overlaps(curve) {
    const lbbox = this.bbox(), tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t2, d) {
    if (typeof d < "u") {
      const c = this.get(t2), n2 = this.normal(t2), ret = {
        c,
        n: n2,
        x: c.x + n2.x * d,
        y: c.y + n2.y * d
      };
      return this._3d && (ret.z = c.z + n2.z * d), ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p) {
        const ret = {
          x: p.x + t2 * nv.x,
          y: p.y + t2 * nv.y
        };
        return p.z && nv.z && (ret.z = p.z + t2 * nv.z), ret;
      });
      return [new Bezier(coords)];
    }
    return this.reduce().map(function(s) {
      return s._linear ? s.offset(t2)[0] : s.scale(t2);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]), a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return !1;
    }
    const n1 = this.normal(0), n2 = this.normal(1);
    let s = n1.x * n2.x + n1.y * n2.y;
    return this._3d && (s += n1.z * n2.z), abs(acos(s)) < pi$1 / 3;
  }
  reduce() {
    let i2, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [], extrema = this.extrema().values;
    for (extrema.indexOf(0) === -1 && (extrema = [0].concat(extrema)), extrema.indexOf(1) === -1 && extrema.push(1), t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++)
      t2 = extrema[i2], segment = this.split(t1, t2), segment._t1 = t1, segment._t2 = t2, pass1.push(segment), t1 = t2;
    return pass1.forEach(function(p1) {
      for (t1 = 0, t2 = 0; t2 <= 1; )
        for (t2 = t1 + step; t2 <= 1 + step; t2 += step)
          if (segment = p1.split(t1, t2), !segment.simple()) {
            if (t2 -= step, abs(t1 - t2) < step)
              return [];
            segment = p1.split(t1, t2), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2), pass2.push(segment), t1 = t2;
            break;
          }
      t1 < 1 && (segment = p1.split(t1, 1), segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2), segment._t2 = p1._t2, pass2.push(segment));
    }), pass2;
  }
  translate(v, d1, d2) {
    d2 = typeof d2 == "number" ? d2 : d1;
    const o = this.order;
    let d = this.points.map((_2, i2) => (1 - i2 / o) * d1 + i2 / o * d2);
    return new Bezier(
      this.points.map((p, i2) => ({
        x: p.x + v.x * d[i2],
        y: p.y + v.y * d[i2]
      }))
    );
  }
  scale(d) {
    const order = this.order;
    let distanceFn = !1;
    if (typeof d == "function" && (distanceFn = d), distanceFn && order === 2)
      return this.raise().scale(distanceFn);
    const clockwise = this.clockwise, points = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        distanceFn ? distanceFn(0) : d,
        distanceFn ? distanceFn(1) : d
      );
    const r1 = distanceFn ? distanceFn(0) : d, r2 = distanceFn ? distanceFn(1) : d, v = [this.offset(0, 10), this.offset(1, 10)], np = [], o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
    if (!o)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(t2) {
      const p = np[t2 * order] = utils.copy(points[t2 * order]);
      p.x += (t2 ? r2 : r1) * v[t2].n.x, p.y += (t2 ? r2 : r1) * v[t2].n.y;
    }), distanceFn ? ([0, 1].forEach(function(t2) {
      if (!(order === 2 && t2)) {
        var p = points[t2 + 1], ov = {
          x: p.x - o.x,
          y: p.y - o.y
        }, rc = distanceFn ? distanceFn((t2 + 1) / order) : d;
        distanceFn && !clockwise && (rc = -rc);
        var m2 = sqrt(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m2, ov.y /= m2, np[t2 + 1] = {
          x: p.x + rc * ov.x,
          y: p.y + rc * ov.y
        };
      }
    }), new Bezier(np)) : ([0, 1].forEach((t2) => {
      if (order === 2 && t2) return;
      const p = np[t2 * order], d2 = this.derivative(t2), p2 = { x: p.x + d2.x, y: p.y + d2.y };
      np[t2 + 1] = utils.lli4(p, p2, o, points[t2 + 1]);
    }), new Bezier(np));
  }
  outline(d1, d2, d3, d4) {
    if (d2 = d2 === void 0 ? d1 : d2, this._linear) {
      const n2 = this.normal(0), start2 = this.points[0], end = this.points[this.points.length - 1];
      let s, mid, e2;
      d3 === void 0 && (d3 = d1, d4 = d2), s = { x: start2.x + n2.x * d1, y: start2.y + n2.y * d1 }, e2 = { x: end.x + n2.x * d3, y: end.y + n2.y * d3 }, mid = { x: (s.x + e2.x) / 2, y: (s.y + e2.y) / 2 };
      const fline = [s, mid, e2];
      s = { x: start2.x - n2.x * d2, y: start2.y - n2.y * d2 }, e2 = { x: end.x - n2.x * d4, y: end.y - n2.y * d4 }, mid = { x: (s.x + e2.x) / 2, y: (s.y + e2.y) / 2 };
      const bline = [e2, mid, s], ls2 = utils.makeline(bline[2], fline[0]), le3 = utils.makeline(fline[2], bline[0]), segments2 = [ls2, new Bezier(fline), le3, new Bezier(bline)];
      return new PolyBezier(segments2);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p, alen = 0, tlen = this.length();
    const graduated = typeof d3 < "u" && typeof d4 < "u";
    function linearDistanceFunction(s, e2, tlen2, alen2, slen) {
      return function(v) {
        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d = e2 - s;
        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      graduated ? (fcurves.push(
        segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
      ), bcurves.push(
        segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
      )) : (fcurves.push(segment.scale(d1)), bcurves.push(segment.scale(-d2))), alen += slen;
    }), bcurves = bcurves.map(function(s) {
      return p = s.points, p[3] ? s.points = [p[3], p[2], p[1], p[0]] : s.points = [p[2], p[1], p[0]], s;
    }).reverse();
    const fs = fcurves[0].points[0], fe2 = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be2 = bcurves[0].points[0], ls = utils.makeline(bs, fs), le2 = utils.makeline(fe2, be2), segments = [ls].concat(fcurves).concat([le2]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d2, curveIntersectionThreshold) {
    d2 = d2 || d1;
    const outline = this.outline(d1, d2).curves, shapes = [];
    for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
      const shape = utils.makeshape(
        outline[i2],
        outline[len - i2],
        curveIntersectionThreshold
      );
      shape.startcap.virtual = i2 > 1, shape.endcap.virtual = i2 < len / 2 - 1, shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve, curveIntersectionThreshold) {
    return curve ? curve.p1 && curve.p2 ? this.lineIntersects(curve) : (curve instanceof Bezier && (curve = curve.reduce()), this.curveintersects(
      this.reduce(),
      curve,
      curveIntersectionThreshold
    )) : this.selfintersects(curveIntersectionThreshold);
  }
  lineIntersects(line) {
    const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
    return utils.roots(this.points, line).filter((t2) => {
      var p = this.get(t2);
      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i2 = 0, result, left, right; i2 < len; i2++)
      left = reduced.slice(i2, i2 + 1), right = reduced.slice(i2 + 2), result = this.curveintersects(left, right, curveIntersectionThreshold), results.push(...result);
    return results;
  }
  curveintersects(c1, c2, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l) {
      c2.forEach(function(r2) {
        l.overlaps(r2) && pairs.push({ left: l, right: r2 });
      });
    });
    let intersections = [];
    return pairs.forEach(function(pair) {
      const result = utils.pairiteration(
        pair.left,
        pair.right,
        curveIntersectionThreshold
      );
      result.length > 0 && (intersections = intersections.concat(result));
    }), intersections;
  }
  arcs(errorThreshold) {
    return errorThreshold = errorThreshold || 0.5, this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s, e2) {
    const q = (e2 - s) / 4, c1 = this.get(s + q), c2 = this.get(e2 - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
    return abs(d1 - ref) + abs(d2 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0, t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc, prev_arc, curr_good = !1, prev_good = !1, done, t_m = t_e, prev_e = 1;
      do
        if (prev_good = curr_good, prev_arc = arc, t_m = (t_s + t_e) / 2, np2 = this.get(t_m), np3 = this.get(t_e), arc = utils.getccenter(np1, np2, np3), arc.interval = {
          start: t_s,
          end: t_e
        }, curr_good = this._error(arc, np1, t_s, t_e) <= errorThreshold, done = prev_good && !curr_good, done || (prev_e = t_e), curr_good) {
          if (t_e >= 1) {
            if (arc.interval.end = prev_e = 1, prev_arc = arc, t_e > 1) {
              let d = {
                x: arc.x + arc.r * cos(arc.e),
                y: arc.y + arc.r * sin(arc.e)
              };
              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else
          t_e = t_m;
      while (!done && safety++ < 100);
      if (safety >= 100)
        break;
      prev_arc = prev_arc || arc, circles.push(prev_arc), t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
}
let listenerQueue = [], lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4, atom = /* @__NO_SIDE_EFFECTS__ */ (initialValue) => {
  let listeners = [], $atom = {
    get() {
      return $atom.lc || $atom.listen(() => {
      })(), $atom.value;
    },
    lc: 0,
    listen(listener) {
      return $atom.lc = listeners.push(listener), () => {
        for (let i2 = lqIndex + QUEUE_ITEMS_PER_LISTENER; i2 < listenerQueue.length; )
          listenerQueue[i2] === listener ? listenerQueue.splice(i2, QUEUE_ITEMS_PER_LISTENER) : i2 += QUEUE_ITEMS_PER_LISTENER;
        let index2 = listeners.indexOf(listener);
        ~index2 && (listeners.splice(index2, 1), --$atom.lc || $atom.off());
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners)
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER)
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      oldValue !== newValue && ($atom.value = newValue, $atom.notify(oldValue));
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      return listener($atom.value), unbind;
    },
    value: initialValue
  };
  return $atom;
}, MOUNT = 5, UNMOUNT = 6, REVERT_MUTATION = 10;
let on = (object2, listener, eventKey, mutateStore) => (object2.events = object2.events || {}, object2.events[eventKey + REVERT_MUTATION] || (object2.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
  object2.events[eventKey].reduceRight((event, l) => (l(event), event), {
    shared: {},
    ...eventProps
  });
})), object2.events[eventKey] = object2.events[eventKey] || [], object2.events[eventKey].push(listener), () => {
  let currentListeners = object2.events[eventKey], index2 = currentListeners.indexOf(listener);
  currentListeners.splice(index2, 1), currentListeners.length || (delete object2.events[eventKey], object2.events[eventKey + REVERT_MUTATION](), delete object2.events[eventKey + REVERT_MUTATION]);
}), STORE_UNMOUNT_DELAY = 1e3, onMount = ($store, initialize) => on($store, (payload) => {
  let destroy = initialize(payload);
  destroy && $store.events[UNMOUNT].push(destroy);
}, MOUNT, (runListeners) => {
  let originListen = $store.listen;
  $store.listen = (...args) => (!$store.lc && !$store.active && ($store.active = !0, runListeners()), originListen(...args));
  let originOff = $store.off;
  return $store.events[UNMOUNT] = [], $store.off = () => {
    originOff(), setTimeout(() => {
      if ($store.active && !$store.lc) {
        $store.active = !1;
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
      }
    }, STORE_UNMOUNT_DELAY);
  }, () => {
    $store.listen = originListen, $store.off = originOff;
  };
});
function listenKeys($store, keys2, listener) {
  let keysSet = new Set(keys2).add(void 0);
  return $store.listen((value, oldValue, changed) => {
    keysSet.has(changed) && listener(value, oldValue, changed);
  });
}
let emit$1 = (snapshotRef, onChange) => (value) => {
  snapshotRef.current !== value && (snapshotRef.current = value, onChange());
};
function useStore(store, { keys: keys2, deps = [store, keys2] } = {}) {
  let snapshotRef = useRef();
  snapshotRef.current = store.get();
  let subscribe = useCallback((onChange) => (emit$1(snapshotRef, onChange)(store.value), keys2?.length > 0 ? listenKeys(store, keys2, emit$1(snapshotRef, onChange)) : store.listen(emit$1(snapshotRef, onChange))), deps), get2 = () => snapshotRef.current;
  return useSyncExternalStore(subscribe, get2, get2);
}
const LayoutGroupContext = createContext({});
function useConstant(init2) {
  const ref = useRef(null);
  return ref.current === null && (ref.current = init2()), ref.current;
}
const isBrowser = typeof window < "u", useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect$1 : useEffect, PresenceContext = /* @__PURE__ */ createContext(null);
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
const clamp = (min2, max2, v) => v > max2 ? max2 : v < min2 ? min2 : v;
let invariant = () => {
};
const MotionGlobalConfig = {}, isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
function isObject$1(value) {
  return typeof value == "object" && value !== null;
}
const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
// @__NO_SIDE_EFFECTS__
function memo$1(callback) {
  let result;
  return () => (result === void 0 && (result = callback()), result);
}
const noop3 = /* @__NO_SIDE_EFFECTS__ */ (any) => any, combineFunctions = (a2, b) => (v) => b(a2(v)), pipe$1 = (...transformers) => transformers.reduce(combineFunctions), progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a2, b, c);
      else
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b, c);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3, millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const wrap = (min2, max2, v) => {
  const rangeSize = max2 - min2;
  return ((v - min2) % rangeSize + rangeSize) % rangeSize + min2;
}, calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i2 = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop3;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2, reverseEasing = (easing) => (p) => 1 - easing(1 - p), backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))), circIn = (p) => 1 - Math.sin(Math.acos(p)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1), easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1), isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number";
function getEasingForSegment(easing, i2) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number", easingLookup = {
  linear: noop3,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, isValidEasing = (easing) => typeof easing == "string", easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition))
    return easingLookup[definition];
  return definition;
}, stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set(), nextFrame = /* @__PURE__ */ new Set(), isProcessing = !1, flushNextFrame = !1;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function triggerCallback(callback) {
    toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame()), callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      const queue = immediate && isProcessing ? thisFrame : nextFrame;
      return keepAlive && toKeepAlive.add(callback), queue.has(callback) || queue.add(callback), callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback), toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (latestFrameData = frameData2, isProcessing) {
        flushNextFrame = !0;
        return;
      }
      isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], thisFrame.forEach(triggerCallback), thisFrame.clear(), isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = !1, useDefaultElapsed = !0;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, flagRunNextFrame = () => runNextFrame = !0, steps = stepsOrder.reduce((acc, key) => (acc[key] = createRenderStep(flagRunNextFrame), acc), {}), { setup: setup2, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps, processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = !1, MotionGlobalConfig.useManualTiming || (state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1)), state.timestamp = timestamp, state.isProcessing = !0, setup2.process(state), read.process(state), resolveKeyframes.process(state), preUpdate.process(state), update.process(state), preRender.process(state), render.process(state), postRender.process(state), state.isProcessing = !1, runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
  }, wake2 = () => {
    runNextFrame = !0, useDefaultElapsed = !0, state.isProcessing || scheduleNextBatch(processBatch);
  };
  return { schedule: stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    return acc[key] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || wake2(), step.schedule(process2, keepAlive, immediate)), acc;
  }, {}), cancel: (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++)
      steps[stepsOrder[i2]].cancel(process2);
  }, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop3, !0);
let now;
function clearTime() {
  now = void 0;
}
const time$2 = {
  now: () => (now === void 0 && time$2.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
  set: (newTime) => {
    now = newTime, queueMicrotask(clearTime);
  }
}, checkStringStartsWith = (token) => (key) => typeof key == "string" && key.startsWith(token), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (value) => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, number = {
  test: (v) => typeof v == "number",
  parse: parseFloat,
  transform: (v) => v
}, alpha = {
  ...number,
  transform: (v) => clamp(0, 1, v)
}, scale$1 = {
  ...number,
  default: 1
}, sanitize = (v) => Math.round(v * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (type, testProp) => (v) => !!(typeof v == "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp)), splitColor = (aName, bName, cName) => (v) => {
  if (typeof v != "string")
    return v;
  const [a2, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, clampRgbUnit = (v) => clamp(0, 255, v), rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
}, rgba$1 = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
};
function parseHex(v) {
  let r2 = "", g = "", b = "", a2 = "";
  return v.length > 5 ? (r2 = v.substring(1, 3), g = v.substring(3, 5), b = v.substring(5, 7), a2 = v.substring(7, 9)) : (r2 = v.substring(1, 2), g = v.substring(2, 3), b = v.substring(3, 4), a2 = v.substring(4, 5), r2 += r2, g += g, b += b, a2 += a2), {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba$1.transform
}, createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v) => typeof v == "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
}), degrees = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px$1 = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
}, hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
}, color = {
  test: (v) => rgba$1.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => rgba$1.test(v) ? rgba$1.parse(v) : hsla.test(v) ? hsla.parse(v) : hex.parse(v),
  transform: (v) => typeof v == "string" ? v : v.hasOwnProperty("red") ? rgba$1.transform(v) : hsla.transform(v),
  getAnimatableNone: (v) => {
    const parsed = color.parse(v);
    return parsed.alpha = 0, color.transform(parsed);
  }
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  return isNaN(v) && typeof v == "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString(), values2 = [], indexes = {
    color: [],
    number: [],
    var: []
  }, types = [];
  let i2 = 0;
  const split = originalValue.replace(complexRegex, (parsedValue) => (color.test(parsedValue) ? (indexes.color.push(i2), types.push(COLOR_TOKEN), values2.push(color.parse(parsedValue))) : parsedValue.startsWith(VAR_FUNCTION_TOKEN) ? (indexes.var.push(i2), types.push(VAR_TOKEN), values2.push(parsedValue)) : (indexes.number.push(i2), types.push(NUMBER_TOKEN), values2.push(parseFloat(parsedValue))), ++i2, SPLIT_TOKEN)).split(SPLIT_TOKEN);
  return { values: values2, split, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source), numSections = split.length;
  return (v) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++)
      if (output += split[i2], v[i2] !== void 0) {
        const type = types[i2];
        type === NUMBER_TOKEN ? output += sanitize(v[i2]) : type === COLOR_TOKEN ? output += color.transform(v[i2]) : output += v[i2];
      }
    return output;
  };
}
const convertNumbersToZero = (v) => typeof v == "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  return createTransformer(v)(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
function hueToRgb(p, q, t2) {
  return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p + (q - p) * 6 * t2 : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p + (q - p) * (2 / 3 - t2) * 6 : p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red = 0, green = 0, blue = 0;
  if (!saturation)
    red = green = blue = lightness;
  else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3), green = hueToRgb(p, q, hue), blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b) {
  return (p) => p > 0 ? b : a2;
}
const mixNumber$1 = (from, to, progress2) => from + (to - from) * progress2, mixLinearColor = (from, to, v) => {
  const fromExpo = from * from, expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, colorTypes = [hex, rgba$1, hsla], getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!type)
    return !1;
  let model = type.parse(color2);
  return type === hsla && (model = hslaToRgba(model)), model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from), toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA)
    return mixImmediate(from, to);
  const blended = { ...fromRGBA };
  return (v) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v), blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v), rgba$1.transform(blended));
}, invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  return invisibleValues.has(origin) ? (p) => p <= 0 ? origin : target : (p) => p >= 1 ? target : origin;
}
function mixNumber(a2, b) {
  return (p) => mixNumber$1(a2, b, p);
}
function getMixer(a2) {
  return typeof a2 == "number" ? mixNumber : typeof a2 == "string" ? isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex : Array.isArray(a2) ? mixArray : typeof a2 == "object" ? color.test(a2) ? mixColor : mixObject : mixImmediate;
}
function mixArray(a2, b) {
  const output = [...a2], numValues = output.length, blendValue = a2.map((v, i2) => getMixer(v)(v, b[i2]));
  return (p) => {
    for (let i2 = 0; i2 < numValues; i2++)
      output[i2] = blendValue[i2](p);
    return output;
  };
}
function mixObject(a2, b) {
  const output = { ...a2, ...b }, blendValue = {};
  for (const key in output)
    a2[key] !== void 0 && b[key] !== void 0 && (blendValue[key] = getMixer(a2[key])(a2[key], b[key]));
  return (v) => {
    for (const key in blendValue)
      output[key] = blendValue[key](v);
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [], pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2], originIndex = origin.indexes[type][pointers[type]], originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue, pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
  return originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length ? invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length ? mixVisibility(origin, target) : pipe$1(mixArray(matchOrder(originStats, targetStats), targetStats.values), template) : mixImmediate(origin, target);
};
function mix$1(from, to, p) {
  return typeof from == "number" && typeof to == "number" && typeof p == "number" ? mixNumber$1(from, to, p) : getMixer(from)(from, to);
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = !0) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time$2.now()
  };
}, generateLinearEasing = (easing, duration2, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration2 / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++)
    points += Math.round(easing(i2 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${points.substring(0, points.length - 2)})`;
}, maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration2 = 0;
  const timeStep = 50;
  let state = generator.next(duration2);
  for (; !state.done && duration2 < maxGeneratorDuration; )
    duration2 += timeStep, state = generator.next(duration2);
  return duration2 >= maxGeneratorDuration ? 1 / 0 : duration2;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] }), duration2 = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => generator.next(duration2 * progress2).value / scale2,
    duration: /* @__PURE__ */ millisecondsToSeconds(duration2)
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current2) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current2 - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, safeMin = 1e-3;
function findSpring({ duration: duration2 = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope, derivative, dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio), duration2 = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration2)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    const exponentialDecay = undampedFreq2 * dampingRatio, delta = exponentialDecay * duration2, a2 = exponentialDecay - velocity, b = calcAngularFreq(undampedFreq2, dampingRatio), c = Math.exp(-delta);
    return safeMin - a2 / b * c;
  }, derivative = (undampedFreq2) => {
    const delta = undampedFreq2 * dampingRatio * duration2, d = delta * velocity + velocity, e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2, f = Math.exp(-delta), g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d - e2) * f) / g;
  }) : (envelope = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration2), b = (undampedFreq2 - velocity) * duration2 + 1;
    return -safeMin + a2 * b;
  }, derivative = (undampedFreq2) => {
    const a2 = Math.exp(-undampedFreq2 * duration2), b = (velocity - undampedFreq2) * (duration2 * duration2);
    return a2 * b;
  });
  const initialGuess = 5 / duration2, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration2 = /* @__PURE__ */ secondsToMilliseconds(duration2), isNaN(undampedFreq))
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration: duration2
    };
  {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration: duration2
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++)
    result = result - envelope(result) / derivative(result);
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: !1,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys))
    if (options.visualDuration) {
      const visualDuration = options.visualDuration, root2 = 2 * Math.PI / (visualDuration * 1.2), stiffness = root2 * root2, damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      }, springOptions.isResolvedFromDuration = !0;
    }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration != "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0], target = options.keyframes[options.keyframes.length - 1], state = { done: !1, value: origin }, { stiffness, damping, mass, duration: duration2, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  }), initialVelocity = velocity || 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - origin, undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default), restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2), freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration && duration2 || null,
    next: (t2) => {
      const current2 = resolveSpring(t2);
      if (isResolvedFromDuration)
        state.done = t2 >= duration2;
      else {
        let currentVelocity = t2 === 0 ? initialVelocity : 0;
        dampingRatio < 1 && (currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current2));
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target - current2) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target : current2, state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration), easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  return options.ease = generatorOptions.ease, options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration), options.type = "keyframes", options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0], state = {
    done: !1,
    value: origin
  }, isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2, nearestBoundary = (v) => min2 === void 0 ? max2 : max2 === void 0 || Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  let amplitude = power * velocity;
  const ideal = origin + amplitude, target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target !== ideal && (amplitude = target - origin);
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant), calcLatest = (t2) => target + calcDelta(t2), applyFriction = (t2) => {
    const delta = calcDelta(t2), latest2 = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta, state.value = state.done ? target : latest2;
  };
  let timeReachedBoundary, spring$1;
  const checkCatchBoundary = (t2) => {
    isOutOfBounds(state.value) && (timeReachedBoundary = t2, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t2), checkCatchBoundary(t2)), timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary ? spring$1.next(t2 - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t2), state);
    }
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [], mixerFactory = customMixer || MotionGlobalConfig.mix || mix$1, numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop3 : ease2;
      mixer = pipe$1(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  if (invariant(inputLength === output.length), inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  input[0] > input[inputLength - 1] && (input = [...input].reverse(), output = [...output].reverse());
  const mixers = createMixers(output, ease2, mixer), numMixers = mixers.length, interpolator = (v) => {
    if (isZeroDeltaRange && v < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1)
      for (; i2 < input.length - 2 && !(v < input[i2 + 1]); i2++)
        ;
    const progressInRange = /* @__PURE__ */ progress(input[i2], input[i2 + 1], v);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  return fillOffset(offset2, arr.length - 1), offset2;
}
function convertOffsetToTimes(offset2, duration2) {
  return offset2.map((o) => o * duration2);
}
function defaultEasing(values2, easing) {
  return values2.map(() => easing || easeInOut).splice(0, values2.length - 1);
}
function keyframes({ duration: duration2 = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration2
  ), mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration2,
    next: (t2) => (state.value = mapTimeToKeyframe(t2), state.done = t2 >= duration2, state)
  };
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1), index2 = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(transition) {
  typeof transition.type == "string" && (transition.type = transitionTypeMap[transition.type]);
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
class JSAnimation extends WithPromise {
  constructor(options) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: motionValue2 } = this.options;
      motionValue2 && motionValue2.updatedAt !== time$2.now() && this.tick(time$2.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = options, this.initAnimation(), this.play(), options.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type || keyframes;
    generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (this.mixKeyframes = pipe$1(percentToProgress, mix$1(keyframes$1[0], keyframes$1[1])), keyframes$1 = [0, 100]);
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    repeatType === "mirror" && (this.mirroredGenerator = generatorFactory({
      ...options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -velocity
    })), generator.calculatedDuration === null && (generator.calculatedDuration = calcGeneratorDuration(generator));
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration, this.resolvedDuration = calculatedDuration + repeatDelay, this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay, this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = animationTime;
  }
  tick(timestamp, sample = !1) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, timestamp) : this.speed < 0 && (this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime)), sample ? this.currentTime = timestamp : this.updateTime(timestamp);
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1), isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = totalDuration);
    let elapsed = this.currentTime, frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat + 1), currentIteration % 2 && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator)), elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: !1, value: keyframes2[0] } : frameGenerator.next(elapsed);
    mixKeyframes && (state.value = mixKeyframes(state.value));
    let { done } = state;
    !isInDelayPhase && calculatedDuration !== null && (done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0);
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    return isAnimationFinished && type !== inertia && (state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed)), onUpdate && onUpdate(state.value), isAnimationFinished && this.finish(), state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: delay2 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime), this.currentTime = newTime, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = newTime : this.driver && (this.startTime = this.driver.now() - newTime / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time$2.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed, hasChanged && (this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    this.driver || (this.driver = driver((timestamp) => this.tick(timestamp))), this.options.onPlay?.();
    const now2 = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = now2) : this.holdTime !== null ? this.startTime = now2 - this.holdTime : this.startTime || (this.startTime = startTime ?? now2), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(time$2.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(sampleTime) {
    return this.startTime = 0, this.tick(sampleTime, !0);
  }
  attachTimeline(timeline) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), timeline.observe(this);
  }
}
function fillWildcards(keyframes2) {
  for (let i2 = 1; i2 < keyframes2.length; i2++)
    keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
}
const radToDeg = (rad) => rad * 180 / Math.PI, rotate = (v) => {
  const angle = radToDeg(Math.atan2(v[1], v[0]));
  return rebaseAngle(angle);
}, matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v) => radToDeg(Math.atan(v[1])),
  skewY: (v) => radToDeg(Math.atan(v[2])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
}, rebaseAngle = (angle) => (angle = angle % 360, angle < 0 && (angle += 360), angle), rotateZ = rotate, scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]), scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]), matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v) => (scaleX(v) + scaleY(v)) / 2,
  rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
  rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v) => radToDeg(Math.atan(v[4])),
  skewY: (v) => radToDeg(Math.atan(v[1])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform2, name) {
  if (!transform2 || transform2 === "none")
    return defaultTransformValue(name);
  const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers, match;
  if (matrix3dMatch)
    parsers = matrix3dParsers, match = matrix3dMatch;
  else {
    const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers, match = matrix2dMatch;
  }
  if (!match)
    return defaultTransformValue(name);
  const valueParser = parsers[name], values2 = match[1].split(",").map(convertTransformToNumber);
  return typeof valueParser == "function" ? valueParser(values2) : values2[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform: transform2 = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform2, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder), isNumOrPxType = (v) => v === number || v === px$1, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value !== void 0 && (removedTransforms.push([key, value.get()]), value.set(key.startsWith("scale") ? 1 : 0));
  }), removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
  y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = !1, anyNeedsMeasurement = !1, isForced = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement), elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element)), transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      removedTransforms.length && (transformsToRestore.set(element, removedTransforms), element.render());
    }), resolversToMeasure.forEach((resolver) => resolver.measureInitialState()), elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      restore && restore.forEach(([key, value]) => {
        element.getValue(key)?.set(value);
      });
    }), resolversToMeasure.forEach((resolver) => resolver.measureEndState()), resolversToMeasure.forEach((resolver) => {
      resolver.suspendedScrollY !== void 0 && window.scrollTo(0, resolver.suspendedScrollY);
    });
  }
  anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((resolver) => resolver.complete(isForced)), toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes(), resolver.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  isForced = !0, readAllKeyframes(), measureAllKeyframes(), isForced = !1;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...unresolvedKeyframes], this.onComplete = onComplete, this.name = name, this.motionValue = motionValue2, this.element = element, this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2?.get(), finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0)
        unresolvedKeyframes[0] = currentValue;
      else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        valueAsRead != null && (unresolvedKeyframes[0] = valueAsRead);
      }
      unresolvedKeyframes[0] === void 0 && (unresolvedKeyframes[0] = finalKeyframe), motionValue2 && currentValue === void 0 && motionValue2.set(unresolvedKeyframes[0]);
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete), toResolve.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (toResolve.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const isCSSVar = (name) => name.startsWith("--");
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
}
const supportsScrollTimeline = /* @__PURE__ */ memo$1(() => window.ScrollTimeline !== void 0), supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo$1(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), cubicBezierAsString = ([a2, b, c, d]) => `cubic-bezier(${a2}, ${b}, ${c}, ${d})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration2) {
  if (easing)
    return typeof easing == "function" ? supportsLinearEasing() ? generateLinearEasing(easing, duration2) : "ease-out" : isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration2) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[easing];
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration: duration2 = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  times && (keyframeOptions.offset = times);
  const easing = mapEasingToNativeEasing(ease2, duration2);
  Array.isArray(easing) && (keyframeOptions.easing = easing);
  const options = {
    delay: delay2,
    duration: duration2,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  return pseudoElement && (options.pseudoElement = pseudoElement), element.animate(keyframeOptions, options);
}
function isGenerator(type) {
  return typeof type == "function" && "applyToOptions" in type;
}
function applyGeneratorOptions({ type, ...options }) {
  return isGenerator(type) && supportsLinearEasing() ? type.applyToOptions(options) : (options.duration ?? (options.duration = 300), options.ease ?? (options.ease = "easeOut"), options);
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !options)
      return;
    const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = !1, finalKeyframe, onComplete } = options;
    this.isPseudoElement = !!pseudoElement, this.allowFlatten = allowFlatten, this.options = options, invariant(typeof options.type != "string");
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement), transition.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !pseudoElement) {
        const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
        this.updateMotionValue ? this.updateMotionValue(keyframe) : setStyle(element, name, keyframe), this.animation.cancel();
      }
      onComplete?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state } = this;
    state === "idle" || state === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const duration2 = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration2));
  }
  get iterationDuration() {
    const { delay: delay2 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay2);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    newSpeed < 0 && (this.finishedTime = null), this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, timeline && supportsScrollTimeline() ? (this.animation.timeline = timeline, noop3) : observe(this);
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  typeof transition.ease == "string" && isUnsupportedEase(transition.ease) && (transition.ease = unsupportedEasingFunctions[transition.ease]);
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options), replaceTransitionType(options), super(options), options.startTime && (this.startTime = options.startTime), this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: !1
    }), sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
    motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta), sampleAnimation.stop();
  }
}
const isAnimatable = (value, name) => name === "zIndex" ? !1 : !!(typeof value == "number" || Array.isArray(value) || typeof value == "string" && // It's animatable if we have a string
(complex.test(value) || value === "0") && // And it contains numbers and/or colors
!value.startsWith("url("));
function hasKeyframesChanged(keyframes2) {
  const current2 = keyframes2[0];
  if (keyframes2.length === 1)
    return !0;
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    if (keyframes2[i2] !== current2)
      return !0;
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return !1;
  if (name === "display" || name === "visibility")
    return !0;
  const targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(originKeyframe, name), isTargetAnimatable = isAnimatable(targetKeyframe, name);
  return !isOriginAnimatable || !isTargetAnimatable ? !1 : hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
function makeAnimationInstant(options) {
  options.duration = 0, options.type = "keyframes";
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), supportsWaapi = /* @__PURE__ */ memo$1(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
  if (!(motionValue2?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay = !0, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = time$2.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options
    }, KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    this.keyframeResolver = void 0;
    const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time$2.now(), canAnimate(keyframes2, name, type, velocity) || ((MotionGlobalConfig.instantAnimations || !delay2) && onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe)), keyframes2[0] = keyframes2[keyframes2.length - 1], makeAnimationInstant(options), options.repeat = 0);
    const resolvedOptions = {
      startTime: sync ? this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    }, animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
      ...resolvedOptions,
      element: resolvedOptions.motionValue.owner.current
    }) : new JSAnimation(resolvedOptions);
    animation.finished.then(() => this.notifyFinished()).catch(noop3), this.pendingTimeline && (this.stopTimeline = animation.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = animation;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), flushKeyframeResolvers()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(timeline) : this.pendingTimeline = timeline, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
class GroupAnimation {
  constructor(animations2) {
    this.stop = () => this.runAll("stop"), this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => animation.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++)
      this.animations[i2][propName] = newValue;
  }
  attachTimeline(timeline) {
    const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));
    return () => {
      subscriptions.forEach((cancel2, i2) => {
        cancel2 && cancel2(), this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    return getMax(this.animations, "duration");
  }
  get iterationDuration() {
    return getMax(this.animations, "iterationDuration");
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function getMax(animations2, propName) {
  let max2 = 0;
  for (let i2 = 0; i2 < animations2.length; i2++) {
    const value = animations2[i2][propName];
    value !== null && value > max2 && (max2 = value);
  }
  return max2;
}
class GroupAnimationWithThen extends GroupAnimation {
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
}
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current2) {
  const match = splitCSSVariableRegex.exec(current2);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current2, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current2);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function getValueTransition$1(transition, key) {
  return transition?.[key] ?? transition?.default ?? transition;
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]), auto = {
  test: (v) => v === "auto",
  parse: (v) => v
}, testValueType = (v) => (type) => type.test(v), dimensionValueTypes = [number, px$1, percent, degrees, vw, vh, auto], findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
function isNone(value) {
  return typeof value == "number" ? value === 0 : value !== null ? value === "none" || value === "0" || isZeroValueString(value) : !0;
}
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  return number2 !== value && (defaultValue *= 100), name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
}, int = {
  ...number,
  transform: Math.round
}, transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale: scale$1,
  scaleX: scale$1,
  scaleY: scale$1,
  scaleZ: scale$1,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px$1,
  translateX: px$1,
  translateY: px$1,
  translateZ: px$1,
  x: px$1,
  y: px$1,
  z: px$1,
  perspective: px$1,
  transformPerspective: px$1,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px$1
}, numberValueTypes = {
  // Border props
  borderWidth: px$1,
  borderTopWidth: px$1,
  borderRightWidth: px$1,
  borderBottomWidth: px$1,
  borderLeftWidth: px$1,
  borderRadius: px$1,
  radius: px$1,
  borderTopLeftRadius: px$1,
  borderTopRightRadius: px$1,
  borderBottomRightRadius: px$1,
  borderBottomLeftRadius: px$1,
  // Positioning props
  width: px$1,
  maxWidth: px$1,
  height: px$1,
  maxHeight: px$1,
  top: px$1,
  right: px$1,
  bottom: px$1,
  left: px$1,
  // Spacing props
  padding: px$1,
  paddingTop: px$1,
  paddingRight: px$1,
  paddingBottom: px$1,
  paddingLeft: px$1,
  margin: px$1,
  marginTop: px$1,
  marginRight: px$1,
  marginBottom: px$1,
  marginLeft: px$1,
  // Misc
  backgroundPositionX: px$1,
  backgroundPositionY: px$1,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
}, getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  return defaultValueType !== filter && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0, animatableTemplate;
  for (; i2 < unresolvedKeyframes.length && !animatableTemplate; ) {
    const keyframe = unresolvedKeyframes[i2];
    typeof keyframe == "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length && (animatableTemplate = unresolvedKeyframes[i2]), i2++;
  }
  if (animatableTemplate && name)
    for (const noneIndex of noneKeyframeIndexes)
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe == "string" && (keyframe = keyframe.trim(), isCSSVariableToken(keyframe))) {
        const resolved = getVariableValue(keyframe, element.current);
        resolved !== void 0 && (unresolvedKeyframes[i2] = resolved), i2 === unresolvedKeyframes.length - 1 && (this.finalKeyframe = keyframe);
      }
    }
    if (this.resolveNoneKeyframes(), !positionalKeys.has(name) || unresolvedKeyframes.length !== 2)
      return;
    const [origin, target] = unresolvedKeyframes, originType = findDimensionValueType(origin), targetType = findDimensionValueType(target);
    if (originType !== targetType)
      if (isNumOrPxType(originType) && isNumOrPxType(targetType))
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          typeof value == "string" && (unresolvedKeyframes[i2] = parseFloat(value));
        }
      else positionalValues[name] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this, noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++)
      (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) && noneKeyframeIndexes.push(i2);
    noneKeyframeIndexes.length && makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    name === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    measureKeyframe !== void 0 && element.getValue(name, measureKeyframe).jump(measureKeyframe, !1);
  }
  measureEndState() {
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, !1);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1, finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current)), finalKeyframe !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = finalKeyframe), this.removedTransforms?.length && this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
      element.getValue(unsetTransformName).set(unsetTransformValue);
    }), this.resolveNoneKeyframes();
  }
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget)
    return [elementOrSelector];
  if (typeof elementOrSelector == "string") {
    let root2 = document;
    const elements = selectorCache?.[elementOrSelector] ?? root2.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
function createSelectorEffect(subjectEffect) {
  return (subject, values2) => {
    const elements = resolveElements(subject), subscriptions = [];
    for (const element of elements) {
      const remove2 = subjectEffect(element, values2);
      subscriptions.push(remove2);
    }
    return () => {
      for (const remove2 of subscriptions)
        remove2();
    };
  };
}
const getValueAsType = (value, type) => type && typeof value == "number" ? type.transform(value) : value;
class MotionValueState {
  constructor() {
    this.latest = {}, this.values = /* @__PURE__ */ new Map();
  }
  set(name, value, render, computed, useDefaultValueType = !0) {
    const existingValue = this.values.get(name);
    existingValue && existingValue.onRemove();
    const onChange = () => {
      const v = value.get();
      useDefaultValueType ? this.latest[name] = getValueAsType(v, numberValueTypes[name]) : this.latest[name] = v, render && frame.render(render);
    };
    onChange();
    const cancelOnChange = value.on("change", onChange);
    computed && value.addDependent(computed);
    const remove2 = () => {
      cancelOnChange(), render && cancelFrame(render), this.values.delete(name), computed && value.removeDependent(computed);
    };
    return this.values.set(name, { value, onRemove: remove2 }), remove2;
  }
  get(name) {
    return this.values.get(name)?.value;
  }
  destroy() {
    for (const value of this.values.values())
      value.onRemove();
  }
}
function createEffect(addValue) {
  const stateCache = /* @__PURE__ */ new WeakMap(), subscriptions = [];
  return (subject, values2) => {
    const state = stateCache.get(subject) ?? new MotionValueState();
    stateCache.set(subject, state);
    for (const key in values2) {
      const value = values2[key], remove2 = addValue(subject, state, key, value);
      subscriptions.push(remove2);
    }
    return () => {
      for (const cancel2 of subscriptions)
        cancel2();
    };
  };
}
function isHTMLElement(element) {
  return isObject$1(element) && "offsetHeight" in element;
}
const MAX_VELOCITY_DELTA = 30, isFloat = (value) => !isNaN(parseFloat(value)), collectMotionValues = {
  current: void 0
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init2, options = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (v) => {
      const currentTime = time$2.now();
      if (this.updatedAt !== currentTime && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(v), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const dependent of this.dependents)
          dependent.dirty();
    }, this.hasAnimated = !1, this.setCurrent(init2), this.owner = options.owner;
  }
  setCurrent(current2) {
    this.current = current2, this.updatedAt = time$2.now(), this.canTrackVelocity === null && current2 !== void 0 && (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    const unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), frame.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v) {
    this.passiveEffect ? this.passiveEffect(v, this.updateAndNotify) : this.updateAndNotify(v);
  }
  setWithVelocity(prev, current2, delta) {
    this.set(current2), this.prev = void 0, this.prevFrameValue = prev, this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = !0) {
    this.updateAndNotify(v), this.prev = v, this.prevUpdatedAt = this.prevFrameValue = void 0, endAnimation && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(dependent) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    this.dependents && this.dependents.delete(dependent);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return collectMotionValues.current && collectMotionValues.current.push(this), this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time$2.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    return this.stop(), new Promise((resolve) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
const translateAlias$1 = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform$1(state) {
  let transform2 = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < transformPropOrder.length; i2++) {
    const key = transformPropOrder[i2], value = state.latest[key];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault) {
      transformIsDefault = !1;
      const transformName = translateAlias$1[key] || key, valueToRender = state.latest[key];
      transform2 += `${transformName}(${valueToRender}) `;
    }
  }
  return transformIsDefault ? "none" : transform2.trim();
}
const originProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]), addStyleValue = (element, state, key, value) => {
  let render, computed;
  return transformProps.has(key) ? (state.get("transform") || (!isHTMLElement(element) && !state.get("transformBox") && addStyleValue(element, state, "transformBox", new MotionValue("fill-box")), state.set("transform", new MotionValue("none"), () => {
    element.style.transform = buildTransform$1(state);
  })), computed = state.get("transform")) : originProps.has(key) ? (state.get("transformOrigin") || state.set("transformOrigin", new MotionValue(""), () => {
    const originX = state.latest.originX ?? "50%", originY = state.latest.originY ?? "50%", originZ = state.latest.originZ ?? 0;
    element.style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }), computed = state.get("transformOrigin")) : isCSSVar(key) ? render = () => {
    element.style.setProperty(key, state.latest[key]);
  } : render = () => {
    element.style[key] = state.latest[key];
  }, state.set(key, value, render, computed);
}, styleEffect = /* @__PURE__ */ createSelectorEffect(
  /* @__PURE__ */ createEffect(addStyleValue)
), { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, !1), isDragging = {
  x: !1,
  y: !1
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  return axis === "x" || axis === "y" ? isDragging[axis] ? null : (isDragging[axis] = !0, () => {
    isDragging[axis] = !1;
  }) : isDragging.x || isDragging.y ? null : (isDragging.x = isDragging.y = !0, () => {
    isDragging.x = isDragging.y = !1;
  });
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector), gestureAbortController = new AbortController(), eventOptions = {
    passive: !0,
    ...options,
    signal: gestureAbortController.signal
  };
  return [elements, eventOptions, () => gestureAbortController.abort()];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel2] = setupGesture(elementOrSelector, options), onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent, onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd != "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      isValidHover(leaveEvent) && (onHoverEnd(leaveEvent), target.removeEventListener("pointerleave", onPointerLeave));
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  return elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  }), cancel2;
}
const isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1, isPrimaryPointer = (event) => event.pointerType === "mouse" ? typeof event.button != "number" || event.button <= 0 : event.isPrimary !== !1, focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    event.key === "Enter" && callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: !0, bubbles: !0 }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    }), handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions), element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions), element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options), startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent), onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp), window.removeEventListener("pointercancel", onPointerCancel), isPressing.has(target) && isPressing.delete(target), isValidPressEvent(endEvent) && typeof onPressEnd == "function" && onPressEnd(endEvent, { success });
    }, onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    }, onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, !1);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions), window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  return targets.forEach((target) => {
    (options.useGlobalTarget ? window : target).addEventListener("pointerdown", startPress, eventOptions), isHTMLElement(target) && (target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions)), !isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex") && (target.tabIndex = 0));
  }), cancelEvents;
}
function isSVGElement(element) {
  return isObject$1(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
function getOriginIndex(from, total) {
  if (from === "first")
    return 0;
  {
    const lastIndex = total - 1;
    return from === "last" ? lastIndex : lastIndex / 2;
  }
}
function stagger(duration2 = 0.1, { startDelay = 0, from = 0, ease: ease2 } = {}) {
  return (i2, total) => {
    const fromIndex = typeof from == "number" ? from : getOriginIndex(from, total), distance2 = Math.abs(fromIndex - i2);
    let delay2 = duration2 * distance2;
    if (ease2) {
      const maxDelay = total * duration2;
      delay2 = easingDefinitionToFunction(ease2)(delay2 / maxDelay) * maxDelay;
    }
    return startDelay + delay2;
  };
}
function transform$1(...args) {
  const useImmediate = !Array.isArray(args[0]), argOffset = useImmediate ? 0 : -1, inputValue = args[0 + argOffset], inputRange = args[1 + argOffset], outputRange = args[2 + argOffset], options = args[3 + argOffset], interpolator = interpolate(inputRange, outputRange, options);
  return useImmediate ? interpolator(inputValue) : interpolator;
}
function subscribeValue(inputValues, outputValue, getLatest) {
  const update = () => outputValue.set(getLatest()), scheduleUpdate = () => frame.preRender(update, !1, !0), subscriptions = inputValues.map((v) => v.on("change", scheduleUpdate));
  outputValue.on("destroy", () => {
    subscriptions.forEach((unsubscribe) => unsubscribe()), cancelFrame(update);
  });
}
function transformValue(transform2) {
  const collectedValues = [];
  collectMotionValues.current = collectedValues;
  const initialValue = transform2();
  collectMotionValues.current = void 0;
  const value = motionValue(initialValue);
  return subscribeValue(collectedValues, value, transform2), value;
}
function mapValue(inputValue, inputRange, outputRange, options) {
  const map = transform$1(inputRange, outputRange, options);
  return transformValue(() => map(inputValue.get()));
}
const isMotionValue = (value) => !!(value && value.getVelocity), valueTypes = [...dimensionValueTypes, color, complex], findValueType = (v) => valueTypes.find(testValueType(v)), MotionConfigContext = createContext({
  transformPagePoint: (p) => p,
  isStatic: !1,
  reducedMotion: "never"
});
function setRef(ref, value) {
  if (typeof ref == "function")
    return ref(value);
  ref != null && (ref.current = value);
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = !1;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      return !hasCleanup && typeof cleanup == "function" && (hasCleanup = !0), cleanup;
    });
    if (hasCleanup)
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          typeof cleanup == "function" ? cleanup() : setRef(refs[i2], null);
        }
      };
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
class PopChildMeasure extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent = element.offsetParent, parentWidth = isHTMLElement(parent) && parent.offsetWidth || 0, size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0, size2.width = element.offsetWidth || 0, size2.top = element.offsetTop, size2.left = element.offsetLeft, size2.right = parentWidth - size2.width - size2.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children: children2, isPresent, anchorX, root: root2 }) {
  const id2 = useId$2(), ref = useRef(null), size2 = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  }), { nonce } = useContext(MotionConfigContext), composedRef = useComposedRefs(ref, children2?.ref);
  return useInsertionEffect$1(() => {
    const { width, height, top, left, right } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    nonce && (style2.nonce = nonce);
    const parent = root2 ?? document.head;
    return parent.appendChild(style2), style2.sheet && style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `), () => {
      parent.contains(style2) && parent.removeChild(style2);
    };
  }, [isPresent]), jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: React.cloneElement(children2, { ref: composedRef }) });
}
const PresenceChild = ({ children: children2, initial, isPresent, onExitComplete, custom: custom5, presenceAffectsLayout, mode, anchorX, root: root2 }) => {
  const presenceChildren = useConstant(newChildrenMap), id2 = useId$2();
  let isReusedContext = !0, context = useMemo(() => (isReusedContext = !1, {
    id: id2,
    initial,
    isPresent,
    custom: custom5,
    onExitComplete: (childId) => {
      presenceChildren.set(childId, !0);
      for (const isComplete of presenceChildren.values())
        if (!isComplete)
          return;
      onExitComplete && onExitComplete();
    },
    register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
  }), [isPresent, presenceChildren, onExitComplete]);
  return presenceAffectsLayout && isReusedContext && (context = { ...context }), useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, !1));
  }, [isPresent]), React.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children2 = jsx(PopChild, { isPresent, anchorX, root: root2, children: children2 })), jsx(PresenceContext.Provider, { value: context, children: children2 });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = !0) {
  const context = useContext(PresenceContext);
  if (context === null)
    return [!0, null];
  const { isPresent, onExitComplete, register } = context, id2 = useId$2();
  useEffect(() => {
    if (subscribe)
      return register(id2);
  }, [subscribe]);
  const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [!1, safeToRemove] : [!0];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children2) {
  const filtered = [];
  return Children.forEach(children2, (child) => {
    isValidElement(child) && filtered.push(child);
  }), filtered;
}
const AnimatePresence = ({ children: children2, custom: custom5, initial = !0, onExitComplete, presenceAffectsLayout = !0, mode = "sync", propagate = !1, anchorX = "left", root: root2 }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate), presentChildren = useMemo(() => onlyElements(children2), [children2]), presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey), isInitialRender = useRef(!0), pendingPresentChildren = useRef(presentChildren), exitComplete = useConstant(() => /* @__PURE__ */ new Map()), [diffedChildren, setDiffedChildren] = useState(presentChildren), [renderedChildren, setRenderedChildren] = useState(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = !1, pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key = getChildKey(renderedChildren[i2]);
      presentKeys.includes(key) ? exitComplete.delete(key) : exitComplete.get(key) !== !0 && exitComplete.set(key, !1);
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2], key = getChildKey(child);
      presentKeys.includes(key) || (nextChildren.splice(i2, 0, child), exitingChildren.push(child));
    }
    return mode === "wait" && exitingChildren.length && (nextChildren = exitingChildren), setRenderedChildren(onlyElements(nextChildren)), setDiffedChildren(presentChildren), null;
  }
  const { forceRender } = useContext(LayoutGroupContext);
  return jsx(Fragment$1, { children: renderedChildren.map((child) => {
    const key = getChildKey(child), isPresent = propagate && !isParentPresent ? !1 : presentChildren === renderedChildren || presentKeys.includes(key), onExit = () => {
      if (exitComplete.has(key))
        exitComplete.set(key, !0);
      else
        return;
      let isEveryExitComplete = !0;
      exitComplete.forEach((isExitComplete) => {
        isExitComplete || (isEveryExitComplete = !1);
      }), isEveryExitComplete && (forceRender?.(), setRenderedChildren(pendingPresentChildren.current), propagate && safeToRemove?.(), onExitComplete && onExitComplete());
    };
    return jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : !1, custom: custom5, presenceAffectsLayout, mode, root: root2, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
  }) });
}, DeprecatedLayoutGroupContext = createContext(null);
function useIsMounted() {
  const isMounted = useRef(!1);
  return useIsomorphicLayoutEffect(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = useState(0), forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [useCallback(() => frame.postRender(forceRender), [forceRender]), forcedRenderCount];
}
const notify = (node) => !node.isLayoutDirty && node.willUpdate(!1);
function nodeGroup() {
  const nodes = /* @__PURE__ */ new Set(), subscriptions = /* @__PURE__ */ new WeakMap(), dirtyAll = () => nodes.forEach(notify);
  return {
    add: (node) => {
      nodes.add(node), subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
    },
    remove: (node) => {
      nodes.delete(node);
      const unsubscribe = subscriptions.get(node);
      unsubscribe && (unsubscribe(), subscriptions.delete(node)), dirtyAll();
    },
    dirty: dirtyAll
  };
}
const shouldInheritGroup = (inherit2) => inherit2 === !0, shouldInheritId = (inherit2) => shouldInheritGroup(inherit2 === !0) || inherit2 === "id", LayoutGroup = ({ children: children2, id: id2, inherit: inherit2 = !0 }) => {
  const layoutGroupContext = useContext(LayoutGroupContext), deprecatedLayoutGroupContext = useContext(DeprecatedLayoutGroupContext), [forceRender, key] = useForceUpdate(), context = useRef(null), upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  context.current === null && (shouldInheritId(inherit2) && upstreamId && (id2 = id2 ? upstreamId + "-" + id2 : upstreamId), context.current = {
    id: id2,
    group: shouldInheritGroup(inherit2) && layoutGroupContext.group || nodeGroup()
  });
  const memoizedContext = useMemo(() => ({ ...context.current, forceRender }), [key]);
  return jsx(LayoutGroupContext.Provider, { value: memoizedContext, children: children2 });
}, LazyContext = createContext({ strict: !1 }), featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const key in featureProps)
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
function loadFeatures(features) {
  for (const key in features)
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
}
function LazyMotion({ children: children2, features, strict = !1 }) {
  const [, setIsLoaded] = useState(!isLazyBundle(features)), loadedRenderer = useRef(void 0);
  if (!isLazyBundle(features)) {
    const { renderer, ...loadedFeatures } = features;
    loadedRenderer.current = renderer, loadFeatures(loadedFeatures);
  }
  return useEffect(() => {
    isLazyBundle(features) && features().then(({ renderer, ...loadedFeatures }) => {
      loadFeatures(loadedFeatures), loadedRenderer.current = renderer, setIsLoaded(!0);
    });
  }, []), jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children: children2 });
}
function isLazyBundle(features) {
  return typeof features == "function";
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  typeof isValidProp == "function" && (shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key));
}
try {
  loadExternalIsValidProp((void 0).default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props)
    key === "values" && typeof props.values == "object" || (shouldForward(key) || forwardMotionProps === !0 && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props.draggable && key.startsWith("onDrag")) && (filteredProps[key] = props[key]);
  return filteredProps;
}
function MotionConfig({ children: children2, isValidProp, ...config2 }) {
  isValidProp && loadExternalIsValidProp(isValidProp), config2 = { ...useContext(MotionConfigContext), ...config2 }, config2.isStatic = useConstant(() => config2.isStatic);
  const context = useMemo(() => config2, [
    JSON.stringify(config2.transition),
    config2.transformPagePoint,
    config2.reducedMotion
  ]);
  return jsx(MotionConfigContext.Provider, { value: context, children: children2 });
}
const MotionContext = /* @__PURE__ */ createContext({});
function isAnimationControls(v) {
  return v !== null && typeof v == "object" && typeof v.start == "function";
}
function isVariantLabel(v) {
  return typeof v == "string" || Array.isArray(v);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return !!(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== !1 ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest2, node) => {
    if (!node.target)
      return latest2;
    if (typeof latest2 == "string")
      if (px$1.test(latest2))
        latest2 = parseFloat(latest2);
      else
        return latest2;
    const x2 = pixelsToPercent(latest2, node.target.x), y2 = pixelsToPercent(latest2, node.target.y);
    return `${x2}% ${y2}%`;
  }
}, correctBoxShadow = {
  correct: (latest2, { treeScale, projectionDelta }) => {
    const original = latest2, shadow = complex.parse(latest2);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest2), offset2 = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale, shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    return typeof shadow[2 + offset2] == "number" && (shadow[2 + offset2] /= averageScale), typeof shadow[3 + offset2] == "number" && (shadow[3 + offset2] /= averageScale), template(shadow);
  }
}, scaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "", transformIsDefault = !0;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2], value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = !0;
    if (typeof value == "number" ? valueIsDefault = value === (key.startsWith("scale") ? 1 : 0) : valueIsDefault = parseFloat(value) === 0, !valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = !1;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      transformTemplate && (transform2[key] = valueAsType);
    }
  }
  return transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString) : transformIsDefault && (transformString = "none"), transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style: style2, vars, transformOrigin } = state;
  let hasTransform2 = !1, hasTransformOrigin = !1;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = !0;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      key.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key] = valueAsType) : style2[key] = valueAsType;
    }
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style2.transform = buildTransform(latestValues, state.transform, transformTemplate) : style2.transform && (style2.transform = "none")), hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source)
    !isMotionValue(source[key]) && !isForcedMotionValue(key, props) && (target[key] = source[key]);
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {}, style2 = {};
  return copyRawValuesOnly(style2, styleProp, props), Object.assign(style2, useInitialMotionValues(props, visualState)), style2;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {}, style2 = useStyle(props, visualState);
  return props.drag && props.dragListener !== !1 && (htmlProps.draggable = !1, style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none", style2.touchAction = props.drag === !0 ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`), props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps.tabIndex = 0), htmlProps.style = style2, htmlProps;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px$1.transform(-offset2);
  const pathLength = px$1.transform(length), pathSpacing = px$1.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest2
}, isSVGTag2, transformTemplate, styleProp) {
  if (buildHTMLStyles(state, latest2, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  const { attrs, style: style2 } = state;
  attrs.transform && (style2.transform = attrs.transform, delete attrs.transform), (style2.transform || attrs.transformOrigin) && (style2.transformOrigin = attrs.transformOrigin ?? "50% 50%", delete attrs.transformOrigin), style2.transform && (style2.transformBox = styleProp?.transformBox ?? "fill-box", delete attrs.transformBox), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), attrScale !== void 0 && (attrs.scale = attrScale), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
}), isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, isSVGTag(Component2), props.transformTemplate, props.style), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(lowercaseSVGElements.indexOf(Component2) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component2))
    )
  );
}
function useRender(Component2, props, ref, { latestValues }, isStatic, forwardMotionProps = !1) {
  const visualProps = (isSVGComponent(Component2) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component2), filteredProps = filterProps(props, typeof Component2 == "string", forwardMotionProps), elementProps = Component2 !== Fragment ? { ...filteredProps, ...visualProps, ref } : {}, { children: children2 } = props, renderedChildren = useMemo(() => isMotionValue(children2) ? children2.get() : children2, [children2]);
  return createElement(Component2, {
    ...elementProps,
    children: renderedChildren
  });
}
function getValueState(visualElement) {
  const state = [{}, {}];
  return visualElement?.values.forEach((value, key) => {
    state[0][key] = value.get(), state[1][key] = value.getVelocity();
  }), state;
}
function resolveVariantFromProps(props, definition, custom5, visualElement) {
  if (typeof definition == "function") {
    const [current2, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current2, velocity);
  }
  if (typeof definition == "string" && (definition = props.variants && props.variants[definition]), typeof definition == "function") {
    const [current2, velocity] = getValueState(visualElement);
    definition = definition(custom5 !== void 0 ? custom5 : props.custom, current2, velocity);
  }
  return definition;
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
  return {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
}
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values2 = {}, motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues)
    values2[key] = resolveMotionValue(motionValues[key]);
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props), isVariantNode$1 = isVariantNode(props);
  context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== !1 && (initial === void 0 && (initial = context.initial), animate2 === void 0 && (animate2 = context.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list2.length; i2++) {
      const resolved = resolveVariantFromProps(props, list2[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          valueTarget !== null && (values2[key] = valueTarget);
        }
        for (const key in transitionEnd)
          values2[key] = transitionEnd[key];
      }
    }
  }
  return values2;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context = useContext(MotionContext), presenceContext = useContext(PresenceContext), make = () => makeState(config2, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  const { style: style2 } = props, newValues = {};
  for (const key in style2)
    (isMotionValue(style2[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) && (newValues[key] = style2[key]);
  return newValues;
}
const useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  createRenderState: createHtmlRenderState
});
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props)
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  return newValues;
}
const useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps,
  createRenderState: createSvgRenderState
}), motionComponentSymbol = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function isRefObject(ref) {
  return ref && typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.onMount && visualState.onMount(instance), visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    },
    /**
     * Include externalRef in dependencies to ensure the callback updates
     * when the ref changes, allowing proper ref forwarding.
     */
    [visualElement]
  );
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId), SwitchLayoutGroupContext = createContext({});
function useVisualElement(Component2, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  const { visualElement: parent } = useContext(MotionContext), lazyContext = useContext(LazyContext), presenceContext = useContext(PresenceContext), reducedMotionConfig = useContext(MotionConfigContext).reducedMotion, visualElementRef = useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component2, {
    visualState,
    parent,
    props,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  const visualElement = visualElementRef.current, initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
  visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg") && createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  const isMounted = useRef(!1);
  useInsertionEffect$1(() => {
    visualElement && isMounted.current && visualElement.update(props, presenceContext);
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute], wantsHandoff = useRef(!!optimisedAppearId && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
  return useIsomorphicLayoutEffect(() => {
    visualElement && (isMounted.current = !0, window.MotionIsMounted = !0, visualElement.updateFeatures(), visualElement.scheduleRenderMicrotask(), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
  }), useEffect(() => {
    visualElement && (!wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
    }), wantsHandoff.current = !1), visualElement.enteringChildren = void 0);
  }), visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent)), visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: !!drag2 || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 == "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (visualElement)
    return visualElement.options.allowProjection !== !1 ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createMotionComponent(Component2, { forwardMotionProps = !1 } = {}, preloadedFeatures, createVisualElement) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  const useVisualState = isSVGComponent(Component2) ? useSVGVisualState : useHTMLVisualState;
  function MotionDOMComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    }, { isStatic } = configAndProps, context = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout, context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
  }
  MotionDOMComponent.displayName = `motion.${typeof Component2 == "string" ? Component2 : `create(${Component2.displayName ?? Component2.name ?? ""})`}`;
  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);
  return ForwardRefMotionComponent[motionComponentSymbol] = Component2, ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
function createMotionProxy(preloadedFeatures, createVisualElement) {
  if (typeof Proxy > "u")
    return createMotionComponent;
  const componentCache = /* @__PURE__ */ new Map(), factory2 = (Component2, options) => createMotionComponent(Component2, options, preloadedFeatures, createVisualElement), deprecatedFactoryFunction = (Component2, options) => factory2(Component2, options);
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => key === "create" ? factory2 : (componentCache.has(key) || componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement)), componentCache.get(key))
  });
}
const m = /* @__PURE__ */ createMotionProxy();
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top }), bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values2) {
  return hasScale(values2) || has2DTranslate(values2) || values2.z || values2.rotate || values2.rotateX || values2.rotateY || values2.skewX || values2.skewY;
}
function has2DTranslate(values2) {
  return is2DTranslate(values2.x) || is2DTranslate(values2.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point2 = scalePoint(point2, boxScale, originPoint)), scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node, delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2], delta = node.projectionDelta;
    const { visualElement } = node.options;
    visualElement && visualElement.props.style && visualElement.props.style.display === "contents" || (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(box, {
      x: -node.scroll.offset.x,
      y: -node.scroll.offset.y
    }), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node.latestValues) && transformBox(box, node.latestValues));
  }
  treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN && (treeScale.x = 1), treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN && (treeScale.y = 1);
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX), transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
}), prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser)
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key], prevValue = prev[key];
    if (isMotionValue(nextValue))
      element.addValue(key, nextValue);
    else if (isMotionValue(prevValue))
      element.addValue(key, motionValue(nextValue, { owner: element }));
    else if (prevValue !== nextValue)
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        existingValue.liveStyle === !0 ? existingValue.jump(nextValue) : existingValue.hasAnimated || existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (const key in prev)
    next[key] === void 0 && element.removeValue(key);
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const now2 = time$2.now();
      this.renderScheduledAt < now2 && (this.renderScheduledAt = now2, frame.render(this.render, !1, !0));
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options, this.blockInitialAnimation = !!blockInitialAnimation, this.isControllingVariants = isControllingVariants(props), this.isVariantNode = isVariantNode(props), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      latestValues[key] !== void 0 && isMotionValue(value) && value.set(latestValues[key]);
    }
  }
  mount(instance) {
    this.current = instance, visualElementStore.set(instance, this), this.projection && !this.projection.instance && this.projection.mount(instance), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value, key) => this.bindToMotionValue(key, value)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((remove2) => remove2()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const key in this.events)
      this.events[key].clear();
    for (const key in this.features) {
      const feature = this.features[key];
      feature && (feature.unmount(), feature.isMounted = !1);
    }
    this.current = null;
  }
  addChild(child) {
    this.children.add(child), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(child);
  }
  removeChild(child) {
    this.children.delete(child), this.enteringChildren && this.enteringChildren.delete(child);
  }
  bindToMotionValue(key, value) {
    this.valueSubscriptions.has(key) && this.valueSubscriptions.get(key)();
    const valueIsTransform = transformProps.has(key);
    valueIsTransform && this.onBindTransform && this.onBindTransform();
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue, this.props.onUpdate && frame.preRender(this.notifyUpdate), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let removeSyncCheck;
    window.MotionCheckAppearSync && (removeSyncCheck = window.MotionCheckAppearSync(this, key, value)), this.valueSubscriptions.set(key, () => {
      removeOnChange(), removeSyncCheck && removeSyncCheck(), value.owner && value.stop();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props) && (this.features[key] = new FeatureConstructor(this)), this.features[key]) {
        const feature = this.features[key];
        feature.isMounted ? feature.update() : (feature.mount(), feature.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      this.propEventSubscriptions[key] && (this.propEventSubscriptions[key](), delete this.propEventSubscriptions[key]);
      const listenerName = "on" + key, listener = props[listenerName];
      listener && (this.propEventSubscriptions[key] = this.on(key, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    value !== existingValue && (existingValue && this.removeValue(key), this.bindToMotionValue(key, value), this.values.set(key, value), this.latestValues[key] = value.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key)), delete this.latestValues[key], this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key])
      return this.props.values[key];
    let value = this.values.get(key);
    return value === void 0 && defaultValue !== void 0 && (value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this }), this.addValue(key, value)), value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
    return value != null && (typeof value == "string" && (isNumericalString(value) || isZeroValueString(value)) ? value = parseFloat(value) : !findValueType(value) && complex.test(target) && (value = getAnimatableNone(key, target)), this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)), isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial == "string" || typeof initial == "object") {
      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
      variant && (valueFromInitial = variant[key]);
    }
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    const target = this.getBaseTargetFromProps(this.props, key);
    return target !== void 0 && !isMotionValue(target) ? target : this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
  scheduleRenderMicrotask() {
    microtask.render(this.render);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b) {
    return a2.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style: style2 }) {
    delete vars[key], delete style2[key];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: children2 } = this.props;
    isMotionValue(children2) && (this.childSubscription = children2.on("change", (latest2) => {
      this.current && (this.current.textContent = `${latest2}`);
    }));
  }
}
function renderHTML(element, { style: style2, vars }, styleProp, projection) {
  const elementStyle = element.style;
  let key;
  for (key in style2)
    elementStyle[key] = style2[key];
  projection?.applyProjectionStyles(elementStyle, styleProp);
  for (key in vars)
    elementStyle.setProperty(key, vars[key]);
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key))
      return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
    {
      const computedStyle = getComputedStyle$1(instance), value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value == "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key) ? key : camelToDash(key), renderState.attrs[key]);
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType && defaultType.default || 0;
    }
    return key = camelCaseAttributes.has(key) ? key : camelToDash(key), instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName), super.mount(instance);
  }
}
const createDomVisualElement = (Component2, options) => isSVGComponent(Component2) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
  allowProjection: Component2 !== Fragment
});
function resolveVariant(visualElement, definition, custom5) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom5 !== void 0 ? custom5 : props.custom, visualElement);
}
const isKeyframesTarget = (v) => Array.isArray(v);
function setMotionValue(visualElement, key, value) {
  visualElement.hasValue(key) ? visualElement.getValue(key).set(value) : visualElement.addValue(key, motionValue(value));
}
function resolveFinalValueInKeyframes(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function isWillChangeMotionValue(value) {
  return !!(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange))
    return willChange.add(key);
  if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange), newWillChange.add(key);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull), index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index2];
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease;
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition$1(transition, name) || {}, delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v), valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  isTransitionDefined(valueTransition) || Object.assign(options, getDefaultTransition(name, options)), options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration)), options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay)), options.from !== void 0 && (options.keyframes[0] = options.from);
  let shouldSkip = !1;
  if ((options.type === !1 || options.duration === 0 && !options.repeatDelay) && (makeAnimationInstant(options), options.delay === 0 && (shouldSkip = !0)), (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) && (shouldSkip = !0, makeAnimationInstant(options), options.delay = 0), options.allowFlatten = !valueTransition.type && !valueTransition.ease, shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe), options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== !0;
  return needsAnimating[key] = !1, shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  transitionOverride && (transition = transitionOverride);
  const animations2 = [], animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null), valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key))
      continue;
    const valueTransition = {
      delay: delay2,
      ...getValueTransition$1(transition || {}, key)
    }, currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity)
      continue;
    let isHandoff = !1;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        startTime !== null && (valueTransition.startTime = startTime, isHandoff = !0);
      }
    }
    addValueToWillChange(visualElement, key), value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: !1 } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    animation && animations2.push(animation);
  }
  return transitionEnd && Promise.all(animations2).then(() => {
    frame.update(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }), animations2;
}
function calcChildStagger(children2, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
  const index2 = Array.from(children2).sort((a2, b) => a2.sortNodePosition(b)).indexOf(child), numChildren = children2.size, maxStaggerDuration = (numChildren - 1) * staggerChildren;
  return typeof delayChildren == "function" ? delayChildren(index2, numChildren) : staggerDirection === 1 ? index2 * staggerChildren : maxStaggerDuration - index2 * staggerChildren;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options.transitionOverride && (transition = options.transitionOverride);
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    const [first, last2] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last2());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
}
function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  for (const child of visualElement.variantChildren)
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delay2 + (typeof delayChildren == "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
    }).then(() => child.notify("AnimationComplete", variant)));
  return Promise.all(animations2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation = animateVariant(visualElement, definition, options);
  else {
    const resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return !1;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return !1;
  for (let i2 = 0; i2 < prevLength; i2++)
    if (prev[i2] !== next[i2])
      return !1;
  return !0;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    return visualElement.props.initial !== void 0 && (context2.initial = visualElement.props.initial), context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2], prop = visualElement.props[name];
    (isVariantLabel(prop) || prop === !1) && (context[name] = prop);
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement), state = createState(), isInitialRender = !0;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement, context = getVariantContext(visualElement.parent) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2], typeState = state[type], prop = props[type] !== void 0 ? props[type] : context[type], propIsVariant = isVariantLabel(prop), activeDelta = type === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i2);
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
      isAnimationControls(prop) || typeof prop == "boolean")
        continue;
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      activeDelta === !1 && (resolvedValues = {});
      const { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key) => {
        shouldAnimateType = !0, removedKeys.has(key) && (handledRemovedValues = !0, removedKeys.delete(key)), typeState.needsAnimating[key] = !0;
        const motionValue2 = visualElement.getValue(key);
        motionValue2 && (motionValue2.liveStyle = !1);
      };
      for (const key in allKeys) {
        const next = resolvedValues[key], prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = !1;
        isKeyframesTarget(next) && isKeyframesTarget(prev) ? valueHasChanged = !shallowCompare(next, prev) : valueHasChanged = next !== prev, valueHasChanged ? next != null ? markToAnimate(key) : removedKeys.add(key) : next !== void 0 && removedKeys.has(key) ? markToAnimate(key) : typeState.protectedKeys[key] = !0;
      }
      typeState.prevProp = prop, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1);
      const willAnimateViaParent = isInherited && variantDidChange;
      shouldAnimateType && (!willAnimateViaParent || handledRemovedValues) && animations2.push(...definitionList.map((animation) => {
        const options = { type };
        if (typeof animation == "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
          const { parent } = visualElement, parentVariant = resolveVariant(parent, animation);
          if (parent.enteringChildren && parentVariant) {
            const { delayChildren } = parentVariant.transition || {};
            options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
          }
        }
        return {
          animation,
          options
        };
      }));
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial != "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        initialTransition && initialTransition.transition && (fallbackAnimation.transition = initialTransition.transition);
      }
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key), motionValue2 = visualElement.getValue(key);
        motionValue2 && (motionValue2.liveStyle = !0), fallbackAnimation[key] = fallbackTarget ?? null;
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = !!animations2.length;
    return isInitialRender && (props.initial === !1 || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    if (state[type].isActive === isActive)
      return Promise.resolve();
    visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive)), state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state)
      state[key].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
    }
  };
}
function checkVariantsDidChange(prev, next) {
  return typeof next == "string" ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node) {
    this.isMounted = !1, this.node = node;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node), node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    isAnimationControls(animate2) && (this.unmountControls = animate2.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate2 !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    onExitComplete && !isPresent && exitAnimation.then(() => {
      onExitComplete(this.id);
    });
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    onExitComplete && onExitComplete(this.id), register && (this.unmount = register(this.id));
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: !0 }) {
  return target.addEventListener(eventName, handler, options), () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = 0.01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin, delta.originPoint = mixNumber$1(source.min, source.max, delta.origin), delta.scale = calcLength(target) / calcLength(source), delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint, (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) && (delta.scale = 1), (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) && (delta.translate = 0);
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0), calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min, target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x), calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min, target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x), calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
const getContextWindow = ({ current: current2 }) => current2 ? current2.ownerDocument.defaultView : null, distance = (a2, b) => Math.abs(a2 - b);
function distance2D(a2, b) {
  const xDelta = distance(a2.x, b.x), yDelta = distance(a2.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = !1, distanceThreshold = 3 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2, { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info2), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info2);
    }, this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2, this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint), frame.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin && resumeAnimation && resumeAnimation(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event2, panInfo), onSessionEnd && onSessionEnd(event2, panInfo);
    }, !isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin, this.handlers = handlers, this.transformPagePoint = transformPagePoint, this.distanceThreshold = distanceThreshold, this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event), initialInfo = transformPoint(info, this.transformPagePoint), { point: point2 } = initialInfo, { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe$1(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b) {
  return { x: a2.x - b.x, y: a2.y - b.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i2 = history.length - 1, timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  for (; i2 >= 0 && (timestampedPoint = history[i2], !(lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta))); )
    i2--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}
function applyConstraints(point2, { min: min2, max: max2 }, elastic) {
  return min2 !== void 0 && point2 < min2 ? point2 = elastic ? mixNumber$1(min2, point2, elastic.min) : Math.max(point2, min2) : max2 !== void 0 && point2 > max2 && (point2 = elastic ? mixNumber$1(max2, point2, elastic.max) : Math.min(point2, max2)), point2;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min, max2 = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min2, max2] = [max2, min2]), { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source), targetLength = calcLength(target);
  return targetLength > sourceLength ? origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min) : sourceLength > targetLength && (origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min)), clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1, distanceThreshold } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event).point);
    }, onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openDragLock && this.openDragLock(), this.openDragLock = setDragLock(drag2), !this.openDragLock))
        return;
      this.latestPointerEvent = event, this.latestPanInfo = info, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current2 = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current2)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current2 = calcLength(measuredAxis) * (parseFloat(current2) / 100));
          }
        }
        this.originPoint[axis] = current2;
      }), onDragStart && frame.postRender(() => onDragStart(event, info)), addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event, info) => {
      this.latestPointerEvent = event, this.latestPanInfo = info;
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info.point, offset2), this.updateAxis("y", info.point, offset2), this.visualElement.render(), onDrag && onDrag(event, info);
    }, onSessionEnd = (event, info) => {
      this.latestPointerEvent = event, this.latestPanInfo = info, this.stop(event, info), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play()), { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      distanceThreshold,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  /**
   * @internal
   */
  stop(event, panInfo) {
    const finalEvent = event || this.latestPointerEvent, finalPanInfo = panInfo || this.latestPanInfo, isDragging2 = this.isDragging;
    if (this.cancel(), !isDragging2 || !finalPanInfo || !finalEvent)
      return;
    const { velocity } = finalPanInfo;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd && frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    !dragPropagation && this.openDragLock && (this.openDragLock(), this.openDragLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    this.constraints && this.constraints[axis] && (next = applyConstraints(next, this.constraints[axis], this.elastic[axis])), axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps(), layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.constraints !== !1 && this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    const constraintsElement = constraints.current, { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      const bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return addValueToWillChange(this.visualElement, axis), axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, !1));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
  }
  getAnimationState(axis) {
    return this.getAxisMotionValue(axis).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`, props = this.visualElement.getProps(), externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== !1) {
        const latest2 = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest2, max: latest2 }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis), { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event);
    }), measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && dragConstraints.current && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        const motionValue2 = this.getAxisMotionValue(axis);
        motionValue2 && (this.originPoint[axis] += delta[axis].translate, motionValue2.set(motionValue2.get() + delta[axis].translate));
      }), this.visualElement.render());
    }));
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset2.y) > lockThreshold ? direction = "y" : Math.abs(offset2.x) > lockThreshold && (direction = "x"), direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node), this.removeGroupControls = noop3, this.removeListeners = noop3, this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop3;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  handler && frame.postRender(() => handler(event, info));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop3;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session, onPanEnd && frame.postRender(() => onPanEnd(event, info));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
let hasTakenAnySnapshot = !1;
class MeasureLayoutWithContext extends Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), hasTakenAnySnapshot && projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, { projection } = visualElement;
    return projection && (projection.isPresent = isPresent, hasTakenAnySnapshot = !0, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {
      const stack = projection.getStack();
      (!stack || !stack.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), microtask.postRender(() => {
      !projection.currentAnimation && projection.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    hasTakenAnySnapshot = !0, projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence(), layoutGroup = useContext(LayoutGroupContext);
  return jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options)), motionValue$1.animation;
}
const compareByDepth = (a2, b) => a2.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
}
function delay(callback, timeout2) {
  const start2 = time$2.now(), checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    elapsed >= timeout2 && (cancelFrame(checkElapsed), callback(elapsed - timeout2));
  };
  return frame.setup(checkElapsed, !0), () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value) => typeof value == "string" ? parseFloat(value) : value, isPx = (value) => typeof value == "number" || px$1.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2)), target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2));
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target[borderLabel] += "%")) : target[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values2, radiusName) {
  return values2[radiusName] !== void 0 ? values2[radiusName] : values2.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop3);
function compress(min2, max2, easing) {
  return (p) => p < min2 ? 0 : p > max2 ? 1 : easing(/* @__PURE__ */ progress(min2, max2, p));
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate, delta.scale = originDelta.scale, delta.originPoint = originDelta.originPoint, delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  return point2 -= translate, point2 = scalePoint(point2, 1 / scale2, originPoint), boxScale !== void 0 && (point2 = scalePoint(point2, 1 / boxScale, originPoint)), point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min), typeof translate != "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  axis === originAxis && (originPoint -= translate), axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b) {
  return a2.min === b.min && a2.max === b.max;
}
function boxEquals(a2, b) {
  return axisEquals(a2.x, b.x) && axisEquals(a2.y, b.y);
}
function axisEqualsRounded(a2, b) {
  return Math.round(a2.min) === Math.round(b.min) && Math.round(a2.max) === Math.round(b.max);
}
function boxEqualsRounded(a2, b) {
  return axisEqualsRounded(a2.x, b.x) && axisEqualsRounded(a2.y, b.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b) {
  return a2.translate === b.translate && a2.scale === b.scale && a2.originPoint === b.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node), node.scheduleRender();
  }
  remove(node) {
    if (removeItem(this.members, node), node === this.prevLead && (this.prevLead = void 0), node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node !== prevLead && (this.prevLead = prevLead, this.lead = node, node.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node.scheduleRender(), node.resumeFrom = prevLead, preserveFollowOpacity && (node.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node.snapshot = prevLead.snapshot, node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node.root && node.root.isUpdating && (node.isLayoutDirty = !0);
      const { crossfade } = node.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y, zTranslate = latestTransform?.z || 0;
  if ((xTranslate || yTranslate || zTranslate) && (transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    transformPerspective && (transform2 = `perspective(${transformPerspective}px) ${transform2}`), rotate2 && (transform2 += `rotate(${rotate2}deg) `), rotateX && (transform2 += `rotateX(${rotateX}deg) `), rotateY && (transform2 += `rotateY(${rotateY}deg) `), skewX && (transform2 += `skewX(${skewX}deg) `), skewY && (transform2 += `skewY(${skewY}deg) `);
  }
  const elementScaleX = delta.x.scale * treeScale.x, elementScaleY = delta.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform2 += `scale(${elementScaleX}, ${elementScaleY})`), transform2 || "none";
}
const transformAxes = ["", "X", "Y", "Z"], animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values2, sharedAnimationValues) {
  const { latestValues } = visualElement;
  latestValues[key] && (values2[key] = latestValues[key], visualElement.setStaticValue(key, 0), sharedAnimationValues && (sharedAnimationValues[key] = 0));
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  if (projectionNode.hasCheckedOptimisedAppear = !0, projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  parent && !parent.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(parent);
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++)
        this.path[i2].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name, handler) {
      return this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager()), this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance), this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay, innerWidth = 0;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        frame.read(() => {
          innerWidth = window.innerWidth;
        }), attachResizeListener(instance, () => {
          const newInnerWidth = window.innerWidth;
          newInnerWidth !== innerWidth && (innerWidth = newInnerWidth, this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation)));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout), hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
        if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const animationOptions = {
            ...getValueTransition$1(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions), this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
        } else
          hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        node.shouldResetTransform = !0, node.updateScroll("snapshot"), node.options.layoutRoot && node.willUpdate(!1);
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate)) : this.nodes.forEach(clearIsLayoutDirty), this.clearAllSnapshots();
      const now2 = time$2.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp), frameData.timestamp = now2, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i2 = 0; i2 < this.path.length; i2++)
          this.path[i2].updateScroll();
      const prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot))) {
        const { scroll } = this.root;
        scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y));
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      if (copyBoxInto(boxWithoutScroll, box), this.scroll?.wasRoot)
        return boxWithoutScroll;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2], { scroll, options } = node;
        node !== this.root && scroll && options.layoutScroll && (scroll.wasRoot && copyBoxInto(boxWithoutScroll, box), translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y));
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        !transformOnly && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(withTransforms, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        }), hasTransform(node.latestValues) && transformBox(withTransforms, node.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!node.instance || !hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox(), nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(forceRecalculation = !1) {
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = !!this.resumingFrom || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      const relativeParent = this.getClosestProjectingParent();
      relativeParent && this.linkedParentVersion !== relativeParent.layoutVersion && !relativeParent.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (relativeParent && relativeParent.layout ? this.createRelativeTarget(relativeParent, this.layout.layoutBox, relativeParent.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, relativeParent && !!relativeParent.resumingFrom == !!this.resumingFrom && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1 ? this.createRelativeTarget(relativeParent, this.target, relativeParent.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(relativeParent, layout2, parentLayout) {
      this.relativeParent = relativeParent, this.linkedParentVersion = relativeParent.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const lead = this.getLead(), isShared = !!this.resumingFrom || this !== lead;
      let canSkip = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox());
      const { target } = lead;
      if (!target) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues), (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      if (this.options.visualElement?.scheduleRender(), notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
      const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack = this.getStack(), isOnlyMember = !stack || stack.members.length <= 1, shouldCrossfadeOpacity = !!(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest2) => {
        const progress2 = latest2 / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2), mixAxisDelta(targetDelta.y, delta.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = motionValue(0)), this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: !0,
          onUpdate: (latest2) => {
            this.mixTargetDelta(latest2), options.onUpdate && options.onUpdate(latest2);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const stack = this.getStack();
      stack && stack.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min, target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min, target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node);
      const config2 = node.options.initialPromotionConfig;
      node.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : !0;
    }
    getLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      stack && stack.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      return stack ? stack.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = !1;
      const { latestValues } = visualElement;
      if ((latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) && (hasDistortingTransform = !0), !hasDistortingTransform)
        return;
      const resetValues = {};
      latestValues.z && resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      for (let i2 = 0; i2 < transformAxes.length; i2++)
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues), resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      visualElement.render();
      for (const key in resetValues)
        visualElement.setStaticValue(key, resetValues[key]), this.animationValues && (this.animationValues[key] = resetValues[key]);
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, targetStyle.visibility = "", targetStyle.opacity = "", targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "", targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        this.options.layoutId && (targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1);
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform2 = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      transformTemplate && (transform2 = transformTemplate(valuesToRender, transform2)), targetStyle.transform = transform2;
      const { x: x2, y: y2 } = this.projectionDelta;
      targetStyle.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key], corrected = transform2 === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++)
            targetStyle[applyTo[i2]] = corrected;
        } else
          isCSSVariable ? this.options.visualElement.renderState.vars[key] = corrected : targetStyle[key] = corrected;
      }
      this.options.layoutId && (targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => node.currentAnimation?.stop()), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  const snapshot = node.resumeFrom?.snapshot || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout, { animationType } = node.options, isShared = snapshot.source !== node.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length, node.relativeTarget && !node.currentAnimation && (node.isProjectionDirty = !0, node.relativeTarget[axis].max = node.relativeTarget[axis].min + length);
    });
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = !1;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEqualsRounded(relativeSnapshot, relativeLayout) || (hasRelativeLayoutChanged = !0), relativeParent.options.layoutRoot && (node.relativeTarget = relativeLayout, node.relativeTargetOrigin = relativeSnapshot, node.relativeParent = relativeParent);
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  node.parent && (node.isProjecting() || (node.isProjectionDirty = node.parent.isProjectionDirty), node.isSharedProjectionDirty || (node.isSharedProjectionDirty = !!(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty)), node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty));
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = !1;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = !1;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation(), node.targetDelta = node.relativeTarget = node.target = void 0, node.isProjectionDirty = !0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber$1(delta.translate, 0, p), output.scale = mixNumber$1(delta.scale, 1, p), output.origin = delta.origin, output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
  output.min = mixNumber$1(from.min, to.min, p), output.max = mixNumber$1(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p), mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (string2) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string2), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop3;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min), axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node) {
  return node !== node.root && node.scroll?.wasRoot;
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => window.getComputedStyle(instance).position === "fixed"
}), drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  node.animationState && props.whileHover && node.animationState.setActive("whileHover", lifecycle === "Start");
  const eventName = "onHover" + lifecycle, callback = props[eventName];
  callback && frame.postRender(() => callback(event, extractEventInfo(event)));
}
class HoverGesture extends Feature {
  mount() {
    const { current: current2 } = this.node;
    current2 && (this.unmount = hover(current2, (_element, startEvent) => (handleHoverEvent(this.node, startEvent, "Start"), (endEvent) => handleHoverEvent(this.node, endEvent, "End"))));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe$1(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.current instanceof HTMLButtonElement && node.current.disabled)
    return;
  node.animationState && props.whileTap && node.animationState.setActive("whileTap", lifecycle === "Start");
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle), callback = props[eventName];
  callback && frame.postRender(() => callback(event, extractEventInfo(event)));
}
class PressGesture extends Feature {
  mount() {
    const { current: current2 } = this.node;
    current2 && (this.unmount = press(current2, (_element, startEvent) => (handlePressEvent(this.node, startEvent, "Start"), (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  const rootObservers = observers.get(lookupRoot), key = JSON.stringify(options);
  return rootObservers[key] || (rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options })), rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps(), { root: root2, margin: rootMargin, amount = "some", once } = viewport, options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      const { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
}, layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
}, domMax = {
  ...domAnimation,
  ...drag,
  ...layout
};
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial)), { isStatic } = useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = useState(initial);
    useEffect(() => value.on("change", setLatest), []);
  }
  return value;
}
function useReducedMotion() {
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion] = useState(prefersReducedMotion.current);
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion(), { reducedMotion } = useContext(MotionConfigContext);
  return reducedMotion === "never" ? !1 : reducedMotion === "always" ? !0 : reducedMotionPreference;
}
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 == "object" && !Array.isArray(keyframes2);
}
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  return typeof subject == "string" && isDOMKeyframes(keyframes2) ? resolveElements(subject, scope, selectorCache) : subject instanceof NodeList ? Array.from(subject) : Array.isArray(subject) ? subject : [subject];
}
function calculateRepeatDuration(duration2, repeat, _repeatDelay) {
  return duration2 * (repeat + 1);
}
function calcNextTime(current2, next, prev, labels) {
  return typeof next == "number" ? next : next.startsWith("-") || next.startsWith("+") ? Math.max(0, current2 + parseFloat(next)) : next === "<" ? prev : next.startsWith("<") ? Math.max(0, prev + parseFloat(next.slice(1))) : labels.get(next) ?? current2;
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const keyframe = sequence[i2];
    keyframe.at > startTime && keyframe.at < endTime && (removeItem(sequence, keyframe), i2--);
  }
}
function addKeyframes(sequence, keyframes2, easing, offset2, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i2 = 0; i2 < keyframes2.length; i2++)
    sequence.push({
      value: keyframes2[i2],
      at: mixNumber$1(startTime, endTime, offset2[i2]),
      easing: getEasingForSegment(easing, i2)
    });
}
function normalizeTimes(times, repeat) {
  for (let i2 = 0; i2 < times.length; i2++)
    times[i2] = times[i2] / (repeat + 1);
}
function compareByTime(a2, b) {
  return a2.at === b.at ? a2.value === null ? 1 : b.value === null ? -1 : 0 : a2.at - b.at;
}
const defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition: defaultTransition2 = {}, ...sequenceTransition } = {}, scope, generators) {
  const defaultDuration = defaultTransition2.duration || 0.3, animationDefinitions = /* @__PURE__ */ new Map(), sequences = /* @__PURE__ */ new Map(), elementCache = {}, timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0, currentTime = 0, totalDuration = 0;
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const segment = sequence[i2];
    if (typeof segment == "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    transition.at !== void 0 && (currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels));
    let maxDuration = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes), { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition2.ease || "easeOut", duration: duration2 } = valueTransition;
      const calculatedDelay = typeof delay2 == "function" ? delay2(elementIndex, numSubjects) : delay2, numKeyframes = valueKeyframesAsList.length, createGenerator = isGenerator(type) ? type : generators?.[type || "keyframes"];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        duration2 !== void 0 && (springTransition.duration = /* @__PURE__ */ secondsToMilliseconds(duration2));
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease, duration2 = springEasing.duration;
      }
      duration2 ?? (duration2 = defaultDuration);
      const startTime = currentTime + calculatedDelay;
      times.length === 1 && times[0] === 0 && (times[1] = 1);
      const remainder = times.length - valueKeyframesAsList.length;
      if (remainder > 0 && fillOffset(times, remainder), valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null), repeat) {
        duration2 = calculateRepeatDuration(duration2, repeat);
        const originalKeyframes = [...valueKeyframesAsList], originalTimes = [...times];
        ease2 = Array.isArray(ease2) ? [...ease2] : [ease2];
        const originalEase = [...ease2];
        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
          valueKeyframesAsList.push(...originalKeyframes);
          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++)
            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1)), ease2.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
        }
        normalizeTimes(times, repeat);
      }
      const targetTime = startTime + duration2;
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime), maxDuration = Math.max(calculatedDelay + duration2, maxDuration), totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache), numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2, transition = transition;
        const thisSubject = subjects[subjectIndex], subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key in keyframes2)
          resolveValueSequence(keyframes2[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
      }
    }
    prevTime = currentTime, currentTime += maxDuration;
  }
  return sequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      valueSequence.sort(compareByTime);
      const keyframes2 = [], valueOffset = [], valueEasing = [];
      for (let i2 = 0; i2 < valueSequence.length; i2++) {
        const { at: at2, value, easing } = valueSequence[i2];
        keyframes2.push(value), valueOffset.push(/* @__PURE__ */ progress(0, totalDuration, at2)), valueEasing.push(easing || "easeOut");
      }
      valueOffset[0] !== 0 && (valueOffset.unshift(0), keyframes2.unshift(keyframes2[0]), valueEasing.unshift(defaultSegmentEasing)), valueOffset[valueOffset.length - 1] !== 1 && (valueOffset.push(1), keyframes2.push(null)), animationDefinitions.has(element) || animationDefinitions.set(element, {
        keyframes: {},
        transition: {}
      });
      const definition = animationDefinitions.get(element);
      definition.keyframes[key] = keyframes2, definition.transition[key] = {
        ...defaultTransition2,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  }), animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  return !sequences.has(subject) && sequences.set(subject, {}), sequences.get(subject);
}
function getValueSequence(name, sequences) {
  return sequences[name] || (sequences[name] = []), sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition(transition, key) {
  return transition && transition[key] ? {
    ...transition,
    ...transition[key]
  } : { ...transition };
}
const isNumber = (keyframe) => typeof keyframe == "number", isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);
function isObjectKey(key, object2) {
  return key in object2;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(instance, key) {
    if (isObjectKey(key, instance)) {
      const value = instance[key];
      if (typeof value == "string" || typeof value == "number")
        return value;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(key, renderState) {
    delete renderState.output[key];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, node = isSVGElement(element) && !isSVGSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node.mount(element), visualElementStore.set(element, node);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, node = new ObjectVisualElement(options);
  node.mount(subject), visualElementStore.set(subject, node);
}
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject == "number" || typeof subject == "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations2 = [];
  if (isSingleValue(subject, keyframes2))
    animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) && keyframes2.default || keyframes2, options && (options.default || options)));
  else {
    const subjects = resolveSubjects(subject, keyframes2, scope), numSubjects = subjects.length;
    for (let i2 = 0; i2 < numSubjects; i2++) {
      const thisSubject = subjects[i2], createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      visualElementStore.has(thisSubject) || createVisualElement(thisSubject);
      const visualElement = visualElementStore.get(thisSubject), transition = { ...options };
      "delay" in transition && typeof transition.delay == "function" && (transition.delay = transition.delay(i2, numSubjects)), animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations2;
}
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  return createAnimationsFromSequence(sequence, options, scope, { spring }).forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations2.push(...animateSubject(subject, keyframes2, transition));
  }), animations2;
}
function isSequence(value) {
  return Array.isArray(value) && value.some(Array.isArray);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations2 = [], animationOnComplete;
    if (isSequence(subjectOrSequence))
      animations2 = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);
    else {
      const { onComplete, ...rest } = options || {};
      typeof onComplete == "function" && (animationOnComplete = onComplete), animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, rest, scope);
    }
    const animation = new GroupAnimationWithThen(animations2);
    return animationOnComplete && animation.finished.then(animationOnComplete), animation;
  }
  return scopedAnimate;
}
const animate = createScopedAnimate();
class DragControls {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    return this.componentControls.add(controls), () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
  /**
   * Cancels a drag gesture.
   *
   * ```jsx
   * dragControls.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.componentControls.forEach((controls) => {
      controls.cancel();
    });
  }
  /**
   * Stops a drag gesture.
   *
   * ```jsx
   * dragControls.stop()
   * ```
   *
   * @public
   */
  stop() {
    this.componentControls.forEach((controls) => {
      controls.stop();
    });
  }
}
const createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}
const ErrorBoundaryContext = createContext(null), initialState = {
  didCatch: !1,
  error: null
};
class ErrorBoundary extends Component {
  constructor(props) {
    super(props), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: !0,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      for (var _this$props$onReset, _this$props, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 || _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      }), this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 || _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state, {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 || _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      }), this.setState(initialState);
    }
  }
  render() {
    const {
      children: children2,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props, {
      didCatch,
      error
    } = this.state;
    let childToRender = children2;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender == "function")
        childToRender = fallbackRender(props);
      else if (FallbackComponent)
        childToRender = createElement(FallbackComponent, props);
      else if (fallback !== void 0)
        childToRender = fallback;
      else
        throw error;
    }
    return createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b.length || a2.some((item, index2) => !Object.is(item, b[index2]));
}
function getGlobal() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
}
function getDevTools() {
  const w = getGlobal();
  if (w.__xstate__)
    return w.__xstate__;
}
const devToolsAdapter = (service) => {
  if (typeof window > "u")
    return;
  const devTools = getDevTools();
  devTools && devTools.register(service);
};
class Mailbox {
  constructor(_process) {
    this._process = _process, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(event) {
    const enqueued = {
      value: event,
      next: null
    };
    if (this._current) {
      this._last.next = enqueued, this._last = enqueued;
      return;
    }
    this._current = enqueued, this._last = enqueued, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const consumed = this._current;
      this._process(consumed.value), this._current = consumed.next;
    }
    this._last = null;
  }
}
const STATE_DELIMITER = ".", TARGETLESS_KEY = "", NULL_EVENT = "", STATE_IDENTIFIER$1 = "#", WILDCARD = "*", XSTATE_INIT = "xstate.init", XSTATE_ERROR = "xstate.error", XSTATE_STOP = "xstate.stop";
function createAfterEvent(delayRef, id2) {
  return {
    type: `xstate.after.${delayRef}.${id2}`
  };
}
function createDoneStateEvent(id2, output) {
  return {
    type: `xstate.done.state.${id2}`,
    output
  };
}
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output,
    actorId: invokeId
  };
}
function createErrorActorEvent(id2, error) {
  return {
    type: `xstate.error.actor.${id2}`,
    error,
    actorId: id2
  };
}
function createInitEvent(input) {
  return {
    type: XSTATE_INIT,
    input
  };
}
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err;
  });
}
const symbolObservable = typeof Symbol == "function" && Symbol.observable || "@@observable";
function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId), childStateValue = toStateValue(childStateId);
  return typeof childStateValue == "string" ? typeof parentStateValue == "string" ? childStateValue === parentStateValue : !1 : typeof parentStateValue == "string" ? parentStateValue in childStateValue : Object.keys(parentStateValue).every((key) => key in childStateValue ? matchesState(parentStateValue[key], childStateValue[key]) : !1);
}
function toStatePath(stateId) {
  if (isArray$1(stateId))
    return stateId;
  const result = [];
  let segment = "";
  for (let i2 = 0; i2 < stateId.length; i2++) {
    switch (stateId.charCodeAt(i2)) {
      // \
      case 92:
        segment += stateId[i2 + 1], i2++;
        continue;
      // .
      case 46:
        result.push(segment), segment = "";
        continue;
    }
    segment += stateId[i2];
  }
  return result.push(segment), result;
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue))
    return stateValue.value;
  if (typeof stateValue != "string")
    return stateValue;
  const statePath = toStatePath(stateValue);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1)
    return statePath[0];
  const value = {};
  let marker = value;
  for (let i2 = 0; i2 < statePath.length - 1; i2++)
    if (i2 === statePath.length - 2)
      marker[statePath[i2]] = statePath[i2 + 1];
    else {
      const previous = marker;
      marker = {}, previous[statePath[i2]] = marker;
    }
  return value;
}
function mapValues(collection, iteratee) {
  const result = {}, collectionKeys = Object.keys(collection);
  for (let i2 = 0; i2 < collectionKeys.length; i2++) {
    const key = collectionKeys[i2];
    result[key] = iteratee(collection[key], key, collection, i2);
  }
  return result;
}
function toArrayStrict(value) {
  return isArray$1(value) ? value : [value];
}
function toArray$1(value) {
  return value === void 0 ? [] : toArrayStrict(value);
}
function resolveOutput(mapper, context, event, self2) {
  return typeof mapper == "function" ? mapper({
    context,
    event,
    self: self2
  }) : mapper;
}
function isArray$1(value) {
  return Array.isArray(value);
}
function isErrorActorEvent(event) {
  return event.type.startsWith("xstate.error.actor");
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map((transitionLike) => typeof transitionLike > "u" || typeof transitionLike == "string" ? {
    target: transitionLike
  } : transitionLike);
}
function normalizeTarget(target) {
  if (!(target === void 0 || target === TARGETLESS_KEY))
    return toArray$1(target);
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  const isObserver = typeof nextHandler == "object", self2 = isObserver ? nextHandler : void 0;
  return {
    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self2),
    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self2),
    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self2)
  };
}
function createInvokeId(stateNodeId, index2) {
  return `${index2}.${stateNodeId}`;
}
function resolveReferencedActor(machine, src) {
  const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!match)
    return machine.implementations.actors[src];
  const [, indexStr, nodeId] = match, invokeConfig = machine.getStateNodeById(nodeId).config.invoke;
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
}
function createScheduledEventId(actorRef, id2) {
  return `${actorRef.sessionId}.${id2}`;
}
let idCounter = 0;
function createSystem(rootActor, options) {
  const children2 = /* @__PURE__ */ new Map(), keyedActors = /* @__PURE__ */ new Map(), reverseKeyedActors = /* @__PURE__ */ new WeakMap(), inspectionObservers = /* @__PURE__ */ new Set(), timerMap = {}, {
    clock: clock2,
    logger
  } = options, scheduler = {
    schedule: (source, target, event, delay2, id2 = Math.random().toString(36).slice(2)) => {
      const scheduledEvent = {
        source,
        target,
        event,
        delay: delay2,
        id: id2,
        startedAt: Date.now()
      }, scheduledEventId = createScheduledEventId(source, id2);
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
      const timeout2 = clock2.setTimeout(() => {
        delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], system._relay(source, target, event);
      }, delay2);
      timerMap[scheduledEventId] = timeout2;
    },
    cancel: (source, id2) => {
      const scheduledEventId = createScheduledEventId(source, id2), timeout2 = timerMap[scheduledEventId];
      delete timerMap[scheduledEventId], delete system._snapshot._scheduledEvents[scheduledEventId], timeout2 !== void 0 && clock2.clearTimeout(timeout2);
    },
    cancelAll: (actorRef) => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
        scheduledEvent.source === actorRef && scheduler.cancel(actorRef, scheduledEvent.id);
      }
    }
  }, sendInspectionEvent = (event) => {
    if (!inspectionObservers.size)
      return;
    const resolvedInspectionEvent = {
      ...event,
      rootId: rootActor.sessionId
    };
    inspectionObservers.forEach((observer) => observer.next?.(resolvedInspectionEvent));
  }, system = {
    _snapshot: {
      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => (children2.set(sessionId, actorRef), sessionId),
    _unregister: (actorRef) => {
      children2.delete(actorRef.sessionId);
      const systemId = reverseKeyedActors.get(actorRef);
      systemId !== void 0 && (keyedActors.delete(systemId), reverseKeyedActors.delete(actorRef));
    },
    get: (systemId) => keyedActors.get(systemId),
    getAll: () => Object.fromEntries(keyedActors.entries()),
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId);
      if (existing && existing !== actorRef)
        throw new Error(`Actor with system ID '${systemId}' already exists.`);
      keyedActors.set(systemId, actorRef), reverseKeyedActors.set(actorRef, systemId);
    },
    inspect: (observerOrFn) => {
      const observer = toObserver(observerOrFn);
      return inspectionObservers.add(observer), {
        unsubscribe() {
          inspectionObservers.delete(observer);
        }
      };
    },
    _sendInspectionEvent: sendInspectionEvent,
    _relay: (source, target, event) => {
      system._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: source,
        actorRef: target,
        event
      }), target._send(event);
    },
    scheduler,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...system._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const scheduledEvents = system._snapshot._scheduledEvents;
      system._snapshot._scheduledEvents = {};
      for (const scheduledId in scheduledEvents) {
        const {
          source,
          target,
          event,
          delay: delay2,
          id: id2
        } = scheduledEvents[scheduledId];
        scheduler.schedule(source, target, event, delay2, id2);
      }
    },
    _clock: clock2,
    _logger: logger
  };
  return system;
}
let executingCustomAction = !1;
const $$ACTOR_TYPE = 1;
let ProcessingStatus = /* @__PURE__ */ (function(ProcessingStatus2) {
  return ProcessingStatus2[ProcessingStatus2.NotStarted = 0] = "NotStarted", ProcessingStatus2[ProcessingStatus2.Running = 1] = "Running", ProcessingStatus2[ProcessingStatus2.Stopped = 2] = "Stopped", ProcessingStatus2;
})({});
const defaultOptions = {
  clock: {
    setTimeout: (fn, ms) => setTimeout(fn, ms),
    clearTimeout: (id2) => clearTimeout(id2)
  },
  logger: console.log.bind(console),
  devTools: !1
};
class Actor {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(logic, options) {
    this.logic = logic, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new Mailbox(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = ProcessingStatus.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this.systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const resolvedOptions = {
      ...defaultOptions,
      ...options
    }, {
      clock: clock2,
      logger,
      parent,
      syncSnapshot,
      id: id2,
      systemId,
      inspect
    } = resolvedOptions;
    this.system = parent ? parent.system : createSystem(this, {
      clock: clock2,
      logger
    }), inspect && !parent && this.system.inspect(toObserver(inspect)), this.sessionId = this.system._bookId(), this.id = id2 ?? this.sessionId, this.logger = options?.logger ?? this.system._logger, this.clock = options?.clock ?? this.system._clock, this._parent = parent, this._syncSnapshot = syncSnapshot, this.options = resolvedOptions, this.src = resolvedOptions.src ?? logic, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (fn) => {
        this._deferred.push(fn);
      },
      system: this.system,
      stopChild: (child) => {
        if (child._parent !== this)
          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
        child._stop();
      },
      emit: (emittedEvent) => {
        const listeners = this.eventListeners.get(emittedEvent.type), wildcardListener = this.eventListeners.get("*");
        if (!listeners && !wildcardListener)
          return;
        const allListeners = [...listeners ? listeners.values() : [], ...wildcardListener ? wildcardListener.values() : []];
        for (const handler of allListeners)
          try {
            handler(emittedEvent);
          } catch (err) {
            reportUnhandledError(err);
          }
      },
      actionExecutor: (action) => {
        const exec = () => {
          if (this._actorScope.system._sendInspectionEvent({
            type: "@xstate.action",
            actorRef: this,
            action: {
              type: action.type,
              params: action.params
            }
          }), !action.exec)
            return;
          const saveExecutingCustomAction = executingCustomAction;
          try {
            executingCustomAction = !0, action.exec(action.info, action.params);
          } finally {
            executingCustomAction = saveExecutingCustomAction;
          }
        };
        this._processingStatus === ProcessingStatus.Running ? exec() : this._deferred.push(exec);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), systemId && (this.systemId = systemId, this.system._set(systemId, this)), this._initState(options?.snapshot ?? options?.state), systemId && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(persistedState) {
    try {
      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
    } catch (err) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: err
      };
    }
  }
  update(snapshot, event) {
    this._snapshot = snapshot;
    let deferredFn;
    for (; deferredFn = this._deferred.shift(); )
      try {
        deferredFn();
      } catch (err) {
        this._deferred.length = 0, this._snapshot = {
          ...snapshot,
          status: "error",
          error: err
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const observer of this.observers)
          try {
            observer.next?.(snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        break;
      case "done":
        for (const observer of this.observers)
          try {
            observer.next?.(snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event,
      snapshot
    });
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(nextListenerOrObserver, errorListener, completeListener) {
    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
    if (this._processingStatus !== ProcessingStatus.Stopped)
      this.observers.add(observer);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            observer.complete?.();
          } catch (err) {
            reportUnhandledError(err);
          }
          break;
        case "error": {
          const err = this._snapshot.error;
          if (!observer.error)
            reportUnhandledError(err);
          else
            try {
              observer.error(err);
            } catch (err2) {
              reportUnhandledError(err2);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(observer);
      }
    };
  }
  on(type, handler) {
    let listeners = this.eventListeners.get(type);
    listeners || (listeners = /* @__PURE__ */ new Set(), this.eventListeners.set(type, listeners));
    const wrappedHandler = handler.bind(void 0);
    return listeners.add(wrappedHandler), {
      unsubscribe: () => {
        listeners.delete(wrappedHandler);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === ProcessingStatus.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (snapshot) => {
        snapshot.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this.systemId && this.system._set(this.systemId, this), this._processingStatus = ProcessingStatus.Running;
    const initEvent = createInitEvent(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: initEvent
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, initEvent), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (err) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: err
        }, this._error(err), this;
      }
    return this.update(this._snapshot, initEvent), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(event) {
    let nextState, caughtError;
    try {
      nextState = this.logic.transition(this._snapshot, event, this._actorScope);
    } catch (err) {
      caughtError = {
        err
      };
    }
    if (caughtError) {
      const {
        err
      } = caughtError;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: err
      }, this._error(err);
      return;
    }
    this.update(nextState, event), event.type === XSTATE_STOP && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === ProcessingStatus.Stopped ? this : (this.mailbox.clear(), this._processingStatus === ProcessingStatus.NotStarted ? (this._processingStatus = ProcessingStatus.Stopped, this) : (this.mailbox.enqueue({
      type: XSTATE_STOP
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    for (const observer of this.observers)
      try {
        observer.complete?.();
      } catch (err) {
        reportUnhandledError(err);
      }
    this.observers.clear();
  }
  _reportError(err) {
    if (!this.observers.size) {
      this._parent || reportUnhandledError(err);
      return;
    }
    let reportError = !1;
    for (const observer of this.observers) {
      const errorListener = observer.error;
      reportError ||= !errorListener;
      try {
        errorListener?.(err);
      } catch (err2) {
        reportUnhandledError(err2);
      }
    }
    this.observers.clear(), reportError && reportUnhandledError(err);
  }
  _error(err) {
    this._stopProcedure(), this._reportError(err), this._parent && this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== ProcessingStatus.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new Mailbox(this._process.bind(this)), this._processingStatus = ProcessingStatus.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(event) {
    this._processingStatus !== ProcessingStatus.Stopped && this.mailbox.enqueue(event);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(event) {
    this.system._relay(void 0, this, event);
  }
  attachDevTools() {
    const {
      devTools
    } = this.options;
    devTools && (typeof devTools == "function" ? devTools : devToolsAdapter)(this);
  }
  toJSON() {
    return {
      xstate$$type: $$ACTOR_TYPE,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(options) {
    return this.logic.getPersistedSnapshot(this._snapshot, options);
  }
  [symbolObservable]() {
    return this;
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function createActor(logic, ...[options]) {
  return new Actor(logic, options);
}
function resolveCancel(_2, snapshot, actionArgs, actionParams, {
  sendId
}) {
  const resolvedSendId = typeof sendId == "function" ? sendId(actionArgs, actionParams) : sendId;
  return [snapshot, {
    sendId: resolvedSendId
  }, void 0];
}
function executeCancel(actorScope, params) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
  });
}
function cancel(sendId) {
  function cancel2(_args, _params) {
  }
  return cancel2.type = "xstate.cancel", cancel2.sendId = sendId, cancel2.resolve = resolveCancel, cancel2.execute = executeCancel, cancel2;
}
function resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {
  id: id2,
  systemId,
  src,
  input,
  syncSnapshot
}) {
  const logic = typeof src == "string" ? resolveReferencedActor(snapshot.machine, src) : src, resolvedId = typeof id2 == "function" ? id2(actionArgs) : id2;
  let actorRef, resolvedInput;
  return logic && (resolvedInput = typeof input == "function" ? input({
    context: snapshot.context,
    event: actionArgs.event,
    self: actorScope.self
  }) : input, actorRef = createActor(logic, {
    id: resolvedId,
    src,
    parent: actorScope.self,
    syncSnapshot,
    systemId,
    input: resolvedInput
  })), [cloneMachineSnapshot(snapshot, {
    children: {
      ...snapshot.children,
      [resolvedId]: actorRef
    }
  }), {
    id: id2,
    systemId,
    actorRef,
    src,
    input: resolvedInput
  }, void 0];
}
function executeSpawn(actorScope, {
  actorRef
}) {
  actorRef && actorScope.defer(() => {
    actorRef._processingStatus !== ProcessingStatus.Stopped && actorRef.start();
  });
}
function spawnChild(...[src, {
  id: id2,
  systemId,
  input,
  syncSnapshot = !1
} = {}]) {
  function spawnChild2(_args, _params) {
  }
  return spawnChild2.type = "xstate.spawnChild", spawnChild2.id = id2, spawnChild2.systemId = systemId, spawnChild2.src = src, spawnChild2.input = input, spawnChild2.syncSnapshot = syncSnapshot, spawnChild2.resolve = resolveSpawn, spawnChild2.execute = executeSpawn, spawnChild2;
}
function resolveStop(_2, snapshot, args, actionParams, {
  actorRef
}) {
  const actorRefOrString = typeof actorRef == "function" ? actorRef(args, actionParams) : actorRef, resolvedActorRef = typeof actorRefOrString == "string" ? snapshot.children[actorRefOrString] : actorRefOrString;
  let children2 = snapshot.children;
  return resolvedActorRef && (children2 = {
    ...children2
  }, delete children2[resolvedActorRef.id]), [cloneMachineSnapshot(snapshot, {
    children: children2
  }), resolvedActorRef, void 0];
}
function executeStop(actorScope, actorRef) {
  if (actorRef) {
    if (actorScope.system._unregister(actorRef), actorRef._processingStatus !== ProcessingStatus.Running) {
      actorScope.stopChild(actorRef);
      return;
    }
    actorScope.defer(() => {
      actorScope.stopChild(actorRef);
    });
  }
}
function stopChild(actorRef) {
  function stop(_args, _params) {
  }
  return stop.type = "xstate.stopChild", stop.actorRef = actorRef, stop.resolve = resolveStop, stop.execute = executeStop, stop;
}
function checkNot(snapshot, {
  context,
  event
}, {
  guards
}) {
  return !evaluateGuard(guards[0], context, event, snapshot);
}
function not(guard) {
  function not2(_args, _params) {
    return !1;
  }
  return not2.check = checkNot, not2.guards = [guard], not2;
}
function checkAnd(snapshot, {
  context,
  event
}, {
  guards
}) {
  return guards.every((guard) => evaluateGuard(guard, context, event, snapshot));
}
function and(guards) {
  function and2(_args, _params) {
    return !1;
  }
  return and2.check = checkAnd, and2.guards = guards, and2;
}
function checkOr(snapshot, {
  context,
  event
}, {
  guards
}) {
  return guards.some((guard) => evaluateGuard(guard, context, event, snapshot));
}
function or(guards) {
  function or2(_args, _params) {
    return !1;
  }
  return or2.check = checkOr, or2.guards = guards, or2;
}
function evaluateGuard(guard, context, event, snapshot) {
  const {
    machine
  } = snapshot, isInline = typeof guard == "function", resolved = isInline ? guard : machine.implementations.guards[typeof guard == "string" ? guard : guard.type];
  if (!isInline && !resolved)
    throw new Error(`Guard '${typeof guard == "string" ? guard : guard.type}' is not implemented.'.`);
  if (typeof resolved != "function")
    return evaluateGuard(resolved, context, event, snapshot);
  const guardArgs = {
    context,
    event
  }, guardParams = isInline || typeof guard == "string" ? void 0 : "params" in guard ? typeof guard.params == "function" ? guard.params({
    context,
    event
  }) : guard.params : void 0;
  return "check" in resolved ? resolved.check(
    snapshot,
    guardArgs,
    resolved
    // this holds all params
  ) : resolved(guardArgs, guardParams);
}
const isAtomicStateNode = (stateNode) => stateNode.type === "atomic" || stateNode.type === "final";
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter((sn) => sn.type !== "history");
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = [];
  if (toStateNode === stateNode)
    return ancestors;
  let m2 = stateNode.parent;
  for (; m2 && m2 !== toStateNode; )
    ancestors.push(m2), m2 = m2.parent;
  return ancestors;
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes), adjList = getAdjList(nodeSet);
  for (const s of nodeSet)
    if (s.type === "compound" && (!adjList.get(s) || !adjList.get(s).length))
      getInitialStateNodesWithTheirAncestors(s).forEach((sn) => nodeSet.add(sn));
    else if (s.type === "parallel") {
      for (const child of getChildren(s))
        if (child.type !== "history" && !nodeSet.has(child)) {
          const initialStates = getInitialStateNodesWithTheirAncestors(child);
          for (const initialStateNode of initialStates)
            nodeSet.add(initialStateNode);
        }
    }
  for (const s of nodeSet) {
    let m2 = s.parent;
    for (; m2; )
      nodeSet.add(m2), m2 = m2.parent;
  }
  return nodeSet;
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode);
  if (!childStateNodes)
    return {};
  if (baseNode.type === "compound") {
    const childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode))
        return childStateNode.key;
    } else
      return {};
  }
  const stateValue = {};
  for (const childStateNode of childStateNodes)
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
  return stateValue;
}
function getAdjList(stateNodes) {
  const adjList = /* @__PURE__ */ new Map();
  for (const s of stateNodes)
    adjList.has(s) || adjList.set(s, []), s.parent && (adjList.has(s.parent) || adjList.set(s.parent, []), adjList.get(s.parent).push(s));
  return adjList;
}
function getStateValue(rootNode, stateNodes) {
  const config2 = getAllStateNodes(stateNodes);
  return getValueFromAdj(rootNode, getAdjList(config2));
}
function isInFinalState(stateNodeSet, stateNode) {
  return stateNode.type === "compound" ? getChildren(stateNode).some((s) => s.type === "final" && stateNodeSet.has(s)) : stateNode.type === "parallel" ? getChildren(stateNode).every((sn) => isInFinalState(stateNodeSet, sn)) : stateNode.type === "final";
}
const isStateId = (str) => str[0] === STATE_IDENTIFIER$1;
function getCandidates(stateNode, receivedEventType) {
  return stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter((eventDescriptor) => {
    if (eventDescriptor === WILDCARD)
      return !0;
    if (!eventDescriptor.endsWith(".*"))
      return !1;
    const partialEventTokens = eventDescriptor.split("."), eventTokens = receivedEventType.split(".");
    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
      const partialEventToken = partialEventTokens[tokenIndex], eventToken = eventTokens[tokenIndex];
      if (partialEventToken === "*")
        return tokenIndex === partialEventTokens.length - 1;
      if (partialEventToken !== eventToken)
        return !1;
    }
    return !0;
  }).sort((a2, b) => b.length - a2.length).flatMap((key) => stateNode.transitions.get(key));
}
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after;
  if (!afterConfig)
    return [];
  const mutateEntryExit = (delay2) => {
    const afterEvent = createAfterEvent(delay2, stateNode.id), eventType = afterEvent.type;
    return stateNode.entry.push(raise(afterEvent, {
      id: eventType,
      delay: delay2
    })), stateNode.exit.push(cancel(eventType)), eventType;
  };
  return Object.keys(afterConfig).flatMap((delay2) => {
    const configTransition = afterConfig[delay2], resolvedTransition = typeof configTransition == "string" ? {
      target: configTransition
    } : configTransition, resolvedDelay = Number.isNaN(+delay2) ? delay2 : +delay2, eventType = mutateEntryExit(resolvedDelay);
    return toArray$1(resolvedTransition).map((transition) => ({
      ...transition,
      event: eventType,
      delay: resolvedDelay
    }));
  }).map((delayedTransition) => {
    const {
      delay: delay2
    } = delayedTransition;
    return {
      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
      delay: delay2
    };
  });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  const normalizedTarget = normalizeTarget(transitionConfig.target), reenter = transitionConfig.reenter ?? !1, target = resolveTarget(stateNode, normalizedTarget), transition = {
    ...transitionConfig,
    actions: toArray$1(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: target ? target.map((t2) => `#${t2.id}`) : void 0
    })
  };
  return transition;
}
function formatTransitions(stateNode) {
  const transitions2 = /* @__PURE__ */ new Map();
  if (stateNode.config.on)
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const transitionsConfig = stateNode.config.on[descriptor];
      transitions2.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`;
    transitions2.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t2) => formatTransition(stateNode, descriptor, t2)));
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`;
      transitions2.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t2) => formatTransition(stateNode, descriptor, t2)));
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions2.get(delayedTransition.eventType);
    existing || (existing = [], transitions2.set(delayedTransition.eventType, existing)), existing.push(delayedTransition);
  }
  return transitions2;
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget = typeof _target == "string" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : void 0;
  if (!resolvedTarget && _target)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${_target}" not found on parent state node #${stateNode.id}`
    );
  const transition = {
    source: stateNode,
    actions: !_target || typeof _target == "string" ? [] : toArray$1(_target.actions),
    eventType: null,
    reenter: !1,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
    })
  };
  return transition;
}
function resolveTarget(stateNode, targets) {
  if (targets !== void 0)
    return targets.map((target) => {
      if (typeof target != "string")
        return target;
      if (isStateId(target))
        return stateNode.machine.getStateNodeById(target);
      const isInternalTarget = target[0] === STATE_DELIMITER;
      if (isInternalTarget && !stateNode.parent)
        return getStateNodeByPath(stateNode, target.slice(1));
      const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
      if (stateNode.parent)
        try {
          return getStateNodeByPath(stateNode.parent, resolvedTarget);
        } catch (err) {
          throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
        }
      else
        throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    });
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target);
  return normalizedTarget ? {
    target: normalizedTarget.map((t2) => typeof t2 == "string" ? getStateNodeByPath(stateNode.parent, t2) : t2)
  } : stateNode.parent.initial;
}
function isHistoryNode(stateNode) {
  return stateNode.type === "history";
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode);
  for (const initialState2 of states)
    for (const ancestor of getProperAncestors(initialState2, stateNode))
      states.add(ancestor);
  return states;
}
function getInitialStateNodes(stateNode) {
  const set2 = /* @__PURE__ */ new Set();
  function iter(descStateNode) {
    if (!set2.has(descStateNode)) {
      if (set2.add(descStateNode), descStateNode.type === "compound")
        iter(descStateNode.initial.target[0]);
      else if (descStateNode.type === "parallel")
        for (const child of getChildren(descStateNode))
          iter(child);
    }
  }
  return iter(stateNode), set2;
}
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey))
    return stateNode.machine.getStateNodeById(stateKey);
  if (!stateNode.states)
    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
  const result = stateNode.states[stateKey];
  if (!result)
    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
  return result;
}
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath == "string" && isStateId(statePath))
    try {
      return stateNode.machine.getStateNodeById(statePath);
    } catch {
    }
  const arrayStatePath = toStatePath(statePath).slice();
  let currentStateNode = stateNode;
  for (; arrayStatePath.length; ) {
    const key = arrayStatePath.shift();
    if (!key.length)
      break;
    currentStateNode = getStateNode(currentStateNode, key);
  }
  return currentStateNode;
}
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue == "string") {
    const childStateNode = stateNode.states[stateValue];
    if (!childStateNode)
      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
    return [stateNode, childStateNode];
  }
  const childStateKeys = Object.keys(stateValue), childStateNodes = childStateKeys.map((subStateKey) => getStateNode(stateNode, subStateKey)).filter(Boolean);
  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
    const subStateNode = getStateNode(stateNode, subStateKey);
    if (!subStateNode)
      return allSubStateNodes;
    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
    return allSubStateNodes.concat(subStateNodes);
  }, []));
}
function transitionAtomicNode(stateNode, stateValue, snapshot, event) {
  const next = getStateNode(stateNode, stateValue).next(snapshot, event);
  return !next || !next.length ? stateNode.next(snapshot, event) : next;
}
function transitionCompoundNode(stateNode, stateValue, snapshot, event) {
  const subStateKeys = Object.keys(stateValue), childStateNode = getStateNode(stateNode, subStateKeys[0]), next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);
  return !next || !next.length ? stateNode.next(snapshot, event) : next;
}
function transitionParallelNode(stateNode, stateValue, snapshot, event) {
  const allInnerTransitions = [];
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey];
    if (!subStateValue)
      continue;
    const subStateNode = getStateNode(stateNode, subStateKey), innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);
    innerTransitions && allInnerTransitions.push(...innerTransitions);
  }
  return allInnerTransitions.length ? allInnerTransitions : stateNode.next(snapshot, event);
}
function transitionNode(stateNode, stateValue, snapshot, event) {
  return typeof stateValue == "string" ? transitionAtomicNode(stateNode, stateValue, snapshot, event) : Object.keys(stateValue).length === 1 ? transitionCompoundNode(stateNode, stateValue, snapshot, event) : transitionParallelNode(stateNode, stateValue, snapshot, event);
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states).map((key) => stateNode.states[key]).filter((sn) => sn.type === "history");
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode;
  for (; marker.parent && marker.parent !== parentStateNode; )
    marker = marker.parent;
  return marker.parent === parentStateNode;
}
function hasIntersection(s1, s2) {
  const set1 = new Set(s1), set2 = new Set(s2);
  for (const item of set1)
    if (set2.has(item))
      return !0;
  for (const item of set2)
    if (set1.has(item))
      return !0;
  return !1;
}
function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
  const filteredTransitions = /* @__PURE__ */ new Set();
  for (const t1 of enabledTransitions) {
    let t1Preempted = !1;
    const transitionsToRemove = /* @__PURE__ */ new Set();
    for (const t2 of filteredTransitions)
      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue)))
        if (isDescendant(t1.source, t2.source))
          transitionsToRemove.add(t2);
        else {
          t1Preempted = !0;
          break;
        }
    if (!t1Preempted) {
      for (const t3 of transitionsToRemove)
        filteredTransitions.delete(t3);
      filteredTransitions.add(t1);
    }
  }
  return Array.from(filteredTransitions);
}
function findLeastCommonAncestor(stateNodes) {
  const [head, ...tail] = stateNodes;
  for (const ancestor of getProperAncestors(head, void 0))
    if (tail.every((sn) => isDescendant(sn, ancestor)))
      return ancestor;
}
function getEffectiveTargetStates(transition, historyValue) {
  if (!transition.target)
    return [];
  const targets = /* @__PURE__ */ new Set();
  for (const targetNode of transition.target)
    if (isHistoryNode(targetNode))
      if (historyValue[targetNode.id])
        for (const node of historyValue[targetNode.id])
          targets.add(node);
      else
        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue))
          targets.add(node);
    else
      targets.add(targetNode);
  return [...targets];
}
function getTransitionDomain(transition, historyValue) {
  const targetStates = getEffectiveTargetStates(transition, historyValue);
  if (!targetStates)
    return;
  if (!transition.reenter && targetStates.every((target) => target === transition.source || isDescendant(target, transition.source)))
    return transition.source;
  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));
  if (lca)
    return lca;
  if (!transition.reenter)
    return transition.source.machine.root;
}
function computeExitSet(transitions2, stateNodeSet, historyValue) {
  const statesToExit = /* @__PURE__ */ new Set();
  for (const t2 of transitions2)
    if (t2.target?.length) {
      const domain = getTransitionDomain(t2, historyValue);
      t2.reenter && t2.source === domain && statesToExit.add(domain);
      for (const stateNode of stateNodeSet)
        isDescendant(stateNode, domain) && statesToExit.add(stateNode);
    }
  return [...statesToExit];
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size)
    return !1;
  for (const node of prevStateNodes)
    if (!nextStateNodeSet.has(node))
      return !1;
  return !0;
}
function microstep(transitions2, currentSnapshot, actorScope, event, isInitial, internalQueue) {
  if (!transitions2.length)
    return currentSnapshot;
  const mutStateNodeSet = new Set(currentSnapshot._nodes);
  let historyValue = currentSnapshot.historyValue;
  const filteredTransitions = removeConflictingTransitions(transitions2, mutStateNodeSet, historyValue);
  let nextState = currentSnapshot;
  isInitial || ([nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor)), nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t2) => t2.actions), internalQueue, void 0), nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
  const nextStateNodes = [...mutStateNodeSet];
  nextState.status === "done" && (nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a2, b) => b.order - a2.order).flatMap((state) => state.exit), internalQueue, void 0));
  try {
    return historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet) ? nextState : cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue
    });
  } catch (e2) {
    throw e2;
  }
}
function getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {
  if (rootNode.output === void 0)
    return;
  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== void 0 && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : void 0);
  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
}
function enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
  let nextSnapshot = currentSnapshot;
  const statesToEnter = /* @__PURE__ */ new Set(), statesForDefaultEntry = /* @__PURE__ */ new Set();
  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter), isInitial && statesForDefaultEntry.add(currentSnapshot.machine.root);
  const completedNodes = /* @__PURE__ */ new Set();
  for (const stateNodeToEnter of [...statesToEnter].sort((a2, b) => a2.order - b.order)) {
    mutStateNodeSet.add(stateNodeToEnter);
    const actions = [];
    actions.push(...stateNodeToEnter.entry);
    for (const invokeDef of stateNodeToEnter.invoke)
      actions.push(spawnChild(invokeDef.src, {
        ...invokeDef,
        syncSnapshot: !!invokeDef.onSnapshot
      }));
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions;
      actions.push(...initialActions);
    }
    if (nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)), stateNodeToEnter.type === "final") {
      const parent = stateNodeToEnter.parent;
      let ancestorMarker = parent?.type === "parallel" ? parent : parent?.parent, rootCompletionNode = ancestorMarker || stateNodeToEnter;
      for (parent?.type === "compound" && internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== void 0 ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : void 0)); ancestorMarker?.type === "parallel" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker); )
        completedNodes.add(ancestorMarker), internalQueue.push(createDoneStateEvent(ancestorMarker.id)), rootCompletionNode = ancestorMarker, ancestorMarker = ancestorMarker.parent;
      if (ancestorMarker)
        continue;
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: "done",
        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)
      });
    }
  }
  return nextSnapshot;
}
function computeEntrySet(transitions2, historyValue, statesForDefaultEntry, statesToEnter) {
  for (const t2 of transitions2) {
    const domain = getTransitionDomain(t2, historyValue);
    for (const s of t2.target || [])
      !isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered
      (t2.source !== s || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      t2.source !== domain || // reentering transitions always enter the target, even if it's the source itself
      t2.reenter) && (statesToEnter.add(s), statesForDefaultEntry.add(s)), addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
    const targetStates = getEffectiveTargetStates(t2, historyValue);
    for (const s of targetStates) {
      const ancestors = getProperAncestors(s, domain);
      domain?.type === "parallel" && ancestors.push(domain), addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t2.source.parent && t2.reenter ? void 0 : domain);
    }
  }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
  if (isHistoryNode(stateNode))
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id];
      for (const s of historyStateNodes)
        statesToEnter.add(s), addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
      for (const s of historyStateNodes)
        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
    } else {
      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
      for (const s of historyDefaultTransition.target)
        statesToEnter.add(s), historyDefaultTransition === stateNode.parent?.initial && statesForDefaultEntry.add(stateNode.parent), addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
      for (const s of historyDefaultTransition.target)
        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
    }
  else if (stateNode.type === "compound") {
    const [initialState2] = stateNode.initial.target;
    isHistoryNode(initialState2) || (statesToEnter.add(initialState2), statesForDefaultEntry.add(initialState2)), addDescendantStatesToEnter(initialState2, historyValue, statesForDefaultEntry, statesToEnter), addProperAncestorStatesToEnter(initialState2, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
  } else if (stateNode.type === "parallel")
    for (const child of getChildren(stateNode).filter((sn) => !isHistoryNode(sn)))
      [...statesToEnter].some((s) => isDescendant(s, child)) || (isHistoryNode(child) || (statesToEnter.add(child), statesForDefaultEntry.add(child)), addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter));
}
function addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
  for (const anc of ancestors)
    if ((!reentrancyDomain || isDescendant(anc, reentrancyDomain)) && statesToEnter.add(anc), anc.type === "parallel")
      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn)))
        [...statesToEnter].some((s) => isDescendant(s, child)) || (statesToEnter.add(child), addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter));
}
function addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));
}
function exitStates(currentSnapshot, event, actorScope, transitions2, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {
  let nextSnapshot = currentSnapshot;
  const statesToExit = computeExitSet(transitions2, mutStateNodeSet, historyValue);
  statesToExit.sort((a2, b) => b.order - a2.order);
  let changedHistory;
  for (const exitStateNode of statesToExit)
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate;
      historyNode.history === "deep" ? predicate = (sn) => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode) : predicate = (sn) => sn.parent === exitStateNode, changedHistory ??= {
        ...historyValue
      }, changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
    }
  for (const s of statesToExit)
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s.exit, ...s.invoke.map((def) => stopChild(def.id))], internalQueue, void 0), mutStateNodeSet.delete(s);
  return [nextSnapshot, changedHistory || historyValue];
}
function getAction(machine, actionType) {
  return machine.implementations.actions[actionType];
}
function resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {
  const {
    machine
  } = currentSnapshot;
  let intermediateSnapshot = currentSnapshot;
  for (const action of actions) {
    const isInline = typeof action == "function", resolvedAction = isInline ? action : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      getAction(machine, typeof action == "string" ? action : action.type)
    ), actionArgs = {
      context: intermediateSnapshot.context,
      event,
      self: actorScope.self,
      system: actorScope.system
    }, actionParams = isInline || typeof action == "string" ? void 0 : "params" in action ? typeof action.params == "function" ? action.params({
      context: intermediateSnapshot.context,
      event
    }) : action.params : void 0;
    if (!resolvedAction || !("resolve" in resolvedAction)) {
      actorScope.actionExecutor({
        type: typeof action == "string" ? action : typeof action == "object" ? action.type : action.name || "(anonymous)",
        info: actionArgs,
        params: actionParams,
        exec: resolvedAction
      });
      continue;
    }
    const builtinAction = resolvedAction, [nextState, params, actions2] = builtinAction.resolve(
      actorScope,
      intermediateSnapshot,
      actionArgs,
      actionParams,
      resolvedAction,
      // this holds all params
      extra
    );
    intermediateSnapshot = nextState, "retryResolve" in builtinAction && retries?.push([builtinAction, params]), "execute" in builtinAction && actorScope.actionExecutor({
      type: builtinAction.type,
      info: actionArgs,
      params,
      exec: builtinAction.execute.bind(null, actorScope, params)
    }), actions2 && (intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions2, extra, retries));
  }
  return intermediateSnapshot;
}
function resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {
  const retries = deferredActorIds ? [] : void 0, nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {
    internalQueue,
    deferredActorIds
  }, retries);
  return retries?.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params);
  }), nextState;
}
function macrostep(snapshot, event, actorScope, internalQueue) {
  let nextSnapshot = snapshot;
  const microstates = [];
  function addMicrostate(microstate, event2, transitions2) {
    actorScope.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: actorScope.self,
      event: event2,
      snapshot: microstate,
      _transitions: transitions2
    }), microstates.push(microstate);
  }
  if (event.type === XSTATE_STOP)
    return nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {
      status: "stopped"
    }), addMicrostate(nextSnapshot, event, []), {
      snapshot: nextSnapshot,
      microstates
    };
  let nextEvent = event;
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent, isErr = isErrorActorEvent(currentEvent), transitions2 = selectTransitions(currentEvent, nextSnapshot);
    if (isErr && !transitions2.length)
      return nextSnapshot = cloneMachineSnapshot(snapshot, {
        status: "error",
        error: currentEvent.error
      }), addMicrostate(nextSnapshot, currentEvent, []), {
        snapshot: nextSnapshot,
        microstates
      };
    nextSnapshot = microstep(
      transitions2,
      snapshot,
      actorScope,
      nextEvent,
      !1,
      // isInitial
      internalQueue
    ), addMicrostate(nextSnapshot, currentEvent, transitions2);
  }
  let shouldSelectEventlessTransitions = !0;
  for (; nextSnapshot.status === "active"; ) {
    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];
    const previousState = enabledTransitions.length ? nextSnapshot : void 0;
    if (!enabledTransitions.length) {
      if (!internalQueue.length)
        break;
      nextEvent = internalQueue.shift(), enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
    }
    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, !1, internalQueue), shouldSelectEventlessTransitions = nextSnapshot !== previousState, addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
  }
  return nextSnapshot.status !== "active" && stopChildren(nextSnapshot, nextEvent, actorScope), {
    snapshot: nextSnapshot,
    microstates
  };
}
function stopChildren(nextState, event, actorScope) {
  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child) => stopChild(child)), [], void 0);
}
function selectTransitions(event, nextState) {
  return nextState.machine.getTransitionData(nextState, event);
}
function selectEventlessTransitions(nextState, event) {
  const enabledTransitionSet = /* @__PURE__ */ new Set(), atomicStates = nextState._nodes.filter(isAtomicStateNode);
  for (const stateNode of atomicStates)
    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, void 0)))
      if (s.always) {
        for (const transition of s.always)
          if (transition.guard === void 0 || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
            enabledTransitionSet.add(transition);
            break loop;
          }
      }
  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
}
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
  return getStateValue(rootNode, [...allStateNodes]);
}
function isMachineSnapshot(value) {
  return !!value && typeof value == "object" && "machine" in value && "value" in value;
}
const machineSnapshotMatches = function(testValue) {
  return matchesState(testValue, this.value);
}, machineSnapshotHasTag = function(tag) {
  return this.tags.has(tag);
}, machineSnapshotCan = function(event) {
  const transitionData = this.machine.getTransitionData(this, event);
  return !!transitionData?.length && // Check that at least one transition is not forbidden
  transitionData.some((t2) => t2.target !== void 0 || t2.actions.length);
}, machineSnapshotToJSON = function() {
  const {
    _nodes: nodes,
    tags,
    machine,
    getMeta: getMeta2,
    toJSON: toJSON2,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    ...jsonValues
  } = this;
  return {
    ...jsonValues,
    tags: Array.from(tags)
  };
}, machineSnapshotGetMeta = function() {
  return this._nodes.reduce((acc, stateNode) => (stateNode.meta !== void 0 && (acc[stateNode.id] = stateNode.meta), acc), {});
};
function createMachineSnapshot(config2, machine) {
  return {
    status: config2.status,
    output: config2.output,
    error: config2.error,
    machine,
    context: config2.context,
    _nodes: config2._nodes,
    value: getStateValue(machine.root, config2._nodes),
    tags: new Set(config2._nodes.flatMap((sn) => sn.tags)),
    children: config2.children,
    historyValue: config2.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON
  };
}
function cloneMachineSnapshot(snapshot, config2 = {}) {
  return createMachineSnapshot({
    ...snapshot,
    ...config2
  }, snapshot.machine);
}
function serializeHistoryValue(historyValue) {
  if (typeof historyValue != "object" || historyValue === null)
    return {};
  const result = {};
  for (const key in historyValue) {
    const value = historyValue[key];
    Array.isArray(value) && (result[key] = value.map((item) => ({
      id: item.id
    })));
  }
  return result;
}
function getPersistedSnapshot(snapshot, options) {
  const {
    _nodes: nodes,
    tags,
    machine,
    children: children2,
    context,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    getMeta: getMeta2,
    toJSON: toJSON2,
    ...jsonValues
  } = snapshot, childrenJson = {};
  for (const id2 in children2) {
    const child = children2[id2];
    childrenJson[id2] = {
      snapshot: child.getPersistedSnapshot(options),
      src: child.src,
      systemId: child.systemId,
      syncSnapshot: child._syncSnapshot
    };
  }
  return {
    ...jsonValues,
    context: persistContext(context),
    children: childrenJson,
    historyValue: serializeHistoryValue(jsonValues.historyValue)
  };
}
function persistContext(contextPart) {
  let copy;
  for (const key in contextPart) {
    const value = contextPart[key];
    if (value && typeof value == "object")
      if ("sessionId" in value && "send" in value && "ref" in value)
        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
          ...contextPart
        }, copy[key] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id
        };
      else {
        const result = persistContext(value);
        result !== value && (copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
          ...contextPart
        }, copy[key] = result);
      }
  }
  return copy ?? contextPart;
}
function resolveRaise(_2, snapshot, args, actionParams, {
  event: eventOrExpr,
  id: id2,
  delay: delay2
}, {
  internalQueue
}) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`
    );
  const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 == "string") {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
  } else
    resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
  return typeof resolvedDelay != "number" && internalQueue.push(resolvedEvent), [snapshot, {
    event: resolvedEvent,
    id: id2,
    delay: resolvedDelay
  }, void 0];
}
function executeRaise(actorScope, params) {
  const {
    event,
    delay: delay2,
    id: id2
  } = params;
  if (typeof delay2 == "number") {
    actorScope.defer(() => {
      const self2 = actorScope.self;
      actorScope.system.scheduler.schedule(self2, self2, event, delay2, id2);
    });
    return;
  }
}
function raise(eventOrExpr, options) {
  function raise2(_args, _params) {
  }
  return raise2.type = "xstate.raise", raise2.event = eventOrExpr, raise2.id = options?.id, raise2.delay = options?.delay, raise2.resolve = resolveRaise, raise2.execute = executeRaise, raise2;
}
const instanceStates = /* @__PURE__ */ new WeakMap();
function fromCallback(callback) {
  return {
    config: callback,
    start: (state, actorScope) => {
      const {
        self: self2,
        system,
        emit: emit2
      } = actorScope, callbackState = {
        receivers: void 0,
        dispose: void 0
      };
      instanceStates.set(self2, callbackState), callbackState.dispose = callback({
        input: state.input,
        system,
        self: self2,
        sendBack: (event) => {
          self2.getSnapshot().status !== "stopped" && self2._parent && system._relay(self2, self2._parent, event);
        },
        receive: (listener) => {
          callbackState.receivers ??= /* @__PURE__ */ new Set(), callbackState.receivers.add(listener);
        },
        emit: emit2
      });
    },
    transition: (state, event, actorScope) => {
      const callbackState = instanceStates.get(actorScope.self);
      return event.type === XSTATE_STOP ? (state = {
        ...state,
        status: "stopped",
        error: void 0
      }, callbackState.dispose?.(), state) : (callbackState.receivers?.forEach((receiver) => receiver(event)), state);
    },
    getInitialSnapshot: (_2, input) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input
    }),
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
}
const XSTATE_PROMISE_RESOLVE = "xstate.promise.resolve", XSTATE_PROMISE_REJECT = "xstate.promise.reject", controllerMap = /* @__PURE__ */ new WeakMap();
function fromPromise(promiseCreator) {
  return {
    config: promiseCreator,
    transition: (state, event, scope) => {
      if (state.status !== "active")
        return state;
      switch (event.type) {
        case XSTATE_PROMISE_RESOLVE: {
          const resolvedValue = event.data;
          return {
            ...state,
            status: "done",
            output: resolvedValue,
            input: void 0
          };
        }
        case XSTATE_PROMISE_REJECT:
          return {
            ...state,
            status: "error",
            error: event.data,
            input: void 0
          };
        case XSTATE_STOP:
          return controllerMap.get(scope.self)?.abort(), {
            ...state,
            status: "stopped",
            input: void 0
          };
        default:
          return state;
      }
    },
    start: (state, {
      self: self2,
      system,
      emit: emit2
    }) => {
      if (state.status !== "active")
        return;
      const controller = new AbortController();
      controllerMap.set(self2, controller), Promise.resolve(promiseCreator({
        input: state.input,
        system,
        self: self2,
        signal: controller.signal,
        emit: emit2
      })).then((response) => {
        self2.getSnapshot().status === "active" && (controllerMap.delete(self2), system._relay(self2, self2, {
          type: XSTATE_PROMISE_RESOLVE,
          data: response
        }));
      }, (errorData) => {
        self2.getSnapshot().status === "active" && (controllerMap.delete(self2), system._relay(self2, self2, {
          type: XSTATE_PROMISE_REJECT,
          data: errorData
        }));
      });
    },
    getInitialSnapshot: (_2, input) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input
    }),
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
}
function createSpawner(actorScope, {
  machine,
  context
}, event, spawnedChildren) {
  const spawn = (src, options) => {
    if (typeof src == "string") {
      const logic = resolveReferencedActor(machine, src);
      if (!logic)
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
      const actorRef = createActor(logic, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: typeof options?.input == "function" ? options.input({
          context,
          event,
          self: actorScope.self
        }) : options?.input,
        src,
        systemId: options?.systemId
      });
      return spawnedChildren[actorRef.id] = actorRef, actorRef;
    } else
      return createActor(src, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: options?.input,
        src,
        systemId: options?.systemId
      });
  };
  return (src, options) => {
    const actorRef = spawn(src, options);
    return spawnedChildren[actorRef.id] = actorRef, actorScope.defer(() => {
      actorRef._processingStatus !== ProcessingStatus.Stopped && actorRef.start();
    }), actorRef;
  };
}
function resolveAssign(actorScope, snapshot, actionArgs, actionParams, {
  assignment
}) {
  if (!snapshot.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const spawnedChildren = {}, assignArgs = {
    context: snapshot.context,
    event: actionArgs.event,
    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),
    self: actorScope.self,
    system: actorScope.system
  };
  let partialUpdate = {};
  if (typeof assignment == "function")
    partialUpdate = assignment(assignArgs, actionParams);
  else
    for (const key of Object.keys(assignment)) {
      const propAssignment = assignment[key];
      partialUpdate[key] = typeof propAssignment == "function" ? propAssignment(assignArgs, actionParams) : propAssignment;
    }
  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
  return [cloneMachineSnapshot(snapshot, {
    context: updatedContext,
    children: Object.keys(spawnedChildren).length ? {
      ...snapshot.children,
      ...spawnedChildren
    } : snapshot.children
  }), void 0, void 0];
}
function assign(assignment) {
  function assign2(_args, _params) {
  }
  return assign2.type = "xstate.assign", assign2.assignment = assignment, assign2.resolve = resolveAssign, assign2;
}
const cache$1 = /* @__PURE__ */ new WeakMap();
function memo(object2, key, fn) {
  let memoizedData = cache$1.get(object2);
  return memoizedData ? key in memoizedData || (memoizedData[key] = fn()) : (memoizedData = {
    [key]: fn()
  }, cache$1.set(object2, memoizedData)), memoizedData[key];
}
const EMPTY_OBJECT = {}, toSerializableAction = (action) => typeof action == "string" ? {
  type: action
} : typeof action == "function" ? "resolve" in action ? {
  type: action.type
} : {
  type: action.name
} : action;
class StateNode {
  constructor(config2, options) {
    if (this.config = config2, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = options._parent, this.key = options._key, this.machine = options._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => new StateNode(stateConfig, {
      _parent: this,
      _key: key,
      _machine: this.machine
    })) : EMPTY_OBJECT, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = toArray$1(this.config.entry).slice(), this.exit = toArray$1(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = toArray$1(config2.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = formatTransitions(this), this.config.always && (this.always = toTransitionConfigArray(this.config.always).map((t2) => formatTransition(this, NULL_EVENT, t2))), Object.keys(this.states).forEach((key) => {
      this.states[key]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(toSerializableAction),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((t2) => `#${t2.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: mapValues(this.states, (state) => state.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t2) => ({
        ...t2,
        actions: t2.actions.map(toSerializableAction)
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return memo(this, "invoke", () => toArray$1(this.config.invoke).map((invokeConfig, i2) => {
      const {
        src,
        systemId
      } = invokeConfig, resolvedId = invokeConfig.id ?? createInvokeId(this.id, i2), sourceName = typeof src == "string" ? src : `xstate.invoke.${createInvokeId(this.id, i2)}`;
      return {
        ...invokeConfig,
        src: sourceName,
        id: resolvedId,
        systemId,
        toJSON() {
          const {
            onDone,
            onError,
            ...invokeDefValues
          } = invokeConfig;
          return {
            ...invokeDefValues,
            type: "xstate.invoke",
            src: sourceName,
            id: resolvedId
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return memo(this, "on", () => [...this.transitions].flatMap(([descriptor, t2]) => t2.map((t3) => [descriptor, t3])).reduce((map, [descriptor, transition]) => (map[descriptor] = map[descriptor] || [], map[descriptor].push(transition), map), {}));
  }
  get after() {
    return memo(this, "delayedTransitions", () => getDelayedTransitions(this));
  }
  get initial() {
    return memo(this, "initial", () => formatInitialTransition(this, this.config.initial));
  }
  /** @internal */
  next(snapshot, event) {
    const eventType = event.type, actions = [];
    let selectedTransition;
    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));
    for (const candidate of candidates) {
      const {
        guard
      } = candidate, resolvedContext = snapshot.context;
      let guardPassed = !1;
      try {
        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);
      } catch (err) {
        const guardType = typeof guard == "string" ? guard : typeof guard == "object" ? guard.type : void 0;
        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ""}in transition for event '${eventType}' in state node '${this.id}':
${err.message}`);
      }
      if (guardPassed) {
        actions.push(...candidate.actions), selectedTransition = candidate;
        break;
      }
    }
    return selectedTransition ? [selectedTransition] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return memo(this, "events", () => {
      const {
        states
      } = this, events = new Set(this.ownEvents);
      if (states)
        for (const stateId of Object.keys(states)) {
          const state = states[stateId];
          if (state.states)
            for (const event of state.events)
              events.add(`${event}`);
        }
      return Array.from(events);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set([...this.transitions.keys()].filter((descriptor) => this.transitions.get(descriptor).some((transition) => !(!transition.target && !transition.actions.length && !transition.reenter))));
    return Array.from(events);
  }
}
const STATE_IDENTIFIER = "#";
class StateMachine {
  constructor(config2, implementations) {
    this.config = config2, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = config2.id || "(machine)", this.implementations = {
      actors: implementations?.actors ?? {},
      actions: implementations?.actions ?? {},
      delays: implementations?.delays ?? {},
      guards: implementations?.guards ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new StateNode(config2, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations.
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to
   *   recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {
      actions,
      guards,
      actors,
      delays
    } = this.implementations;
    return new StateMachine(this.config, {
      actions: {
        ...actions,
        ...implementations.actions
      },
      guards: {
        ...guards,
        ...implementations.guards
      },
      actors: {
        ...actors,
        ...implementations.actors
      },
      delays: {
        ...delays,
        ...implementations.delays
      }
    });
  }
  resolveState(config2) {
    const resolvedStateValue = resolveStateValue(this.root, config2.value), nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));
    return createMachineSnapshot({
      _nodes: [...nodeSet],
      context: config2.context || {},
      children: {},
      status: isInFinalState(nodeSet, this.root) ? "done" : config2.status || "active",
      output: config2.output,
      error: config2.error,
      historyValue: config2.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).microstates;
  }
  getTransitionData(snapshot, event) {
    return transitionNode(this.root, snapshot.value, snapshot, event) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorScope, initEvent, internalQueue) {
    const {
      context
    } = this.config, preInitial = createMachineSnapshot({
      context: typeof context != "function" && context ? context : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof context == "function" ? resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(({
      spawn,
      event,
      self: self2
    }) => context({
      spawn,
      input: event.input,
      self: self2
    }))], internalQueue, void 0) : preInitial;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(actorScope, input) {
    const initEvent = createInitEvent(input), internalQueue = [], preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue), nextState = microstep([{
      target: [...getInitialStateNodes(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], preInitialState, actorScope, initEvent, !0, internalQueue), {
      snapshot: macroState
    } = macrostep(nextState, initEvent, actorScope, internalQueue);
    return macroState;
  }
  start(snapshot) {
    Object.values(snapshot.children).forEach((child) => {
      child.getSnapshot().status === "active" && child.start();
    });
  }
  getStateNodeById(stateId) {
    const fullPath = toStatePath(stateId), relativePath = fullPath.slice(1), resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0], stateNode = this.idMap.get(resolvedStateId);
    if (!stateNode)
      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
    return getStateNodeByPath(stateNode, relativePath);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(snapshot, options) {
    return getPersistedSnapshot(snapshot, options);
  }
  restoreSnapshot(snapshot, _actorScope) {
    const children2 = {}, snapshotChildren = snapshot.children;
    Object.keys(snapshotChildren).forEach((actorId) => {
      const actorData = snapshotChildren[actorId], childState = actorData.snapshot, src = actorData.src, logic = typeof src == "string" ? resolveReferencedActor(this, src) : src;
      if (!logic)
        return;
      const actorRef = createActor(logic, {
        id: actorId,
        parent: _actorScope.self,
        syncSnapshot: actorData.syncSnapshot,
        snapshot: childState,
        src,
        systemId: actorData.systemId
      });
      children2[actorId] = actorRef;
    });
    function resolveHistoryReferencedState(root2, referenced) {
      if (referenced instanceof StateNode)
        return referenced;
      try {
        return root2.machine.getStateNodeById(referenced.id);
      } catch {
      }
    }
    function reviveHistoryValue(root2, historyValue) {
      if (!historyValue || typeof historyValue != "object")
        return {};
      const revived = {};
      for (const key in historyValue) {
        const arr = historyValue[key];
        for (const item of arr) {
          const resolved = resolveHistoryReferencedState(root2, item);
          resolved && (revived[key] ??= [], revived[key].push(resolved));
        }
      }
      return revived;
    }
    const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue), restoredSnapshot = createMachineSnapshot({
      ...snapshot,
      children: children2,
      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value))),
      historyValue: revivedHistoryValue
    }, this), seen = /* @__PURE__ */ new Set();
    function reviveContext(contextPart, children3) {
      if (!seen.has(contextPart)) {
        seen.add(contextPart);
        for (const key in contextPart) {
          const value = contextPart[key];
          if (value && typeof value == "object") {
            if ("xstate$$type" in value && value.xstate$$type === $$ACTOR_TYPE) {
              contextPart[key] = children3[value.id];
              continue;
            }
            reviveContext(value, children3);
          }
        }
      }
    }
    return reviveContext(restoredSnapshot.context, children2), restoredSnapshot;
  }
}
function resolveEmit(_2, snapshot, args, actionParams, {
  event: eventOrExpr
}) {
  const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  return [snapshot, {
    event: resolvedEvent
  }, void 0];
}
function executeEmit(actorScope, {
  event
}) {
  actorScope.defer(() => actorScope.emit(event));
}
function emit(eventOrExpr) {
  function emit2(_args, _params) {
  }
  return emit2.type = "xstate.emit", emit2.event = eventOrExpr, emit2.resolve = resolveEmit, emit2.execute = executeEmit, emit2;
}
let SpecialTargets = /* @__PURE__ */ (function(SpecialTargets2) {
  return SpecialTargets2.Parent = "#_parent", SpecialTargets2.Internal = "#_internal", SpecialTargets2;
})({});
function resolveSendTo(actorScope, snapshot, args, actionParams, {
  to,
  event: eventOrExpr,
  id: id2,
  delay: delay2
}, extra) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`
    );
  const resolvedEvent = typeof eventOrExpr == "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 == "string") {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay = typeof configDelay == "function" ? configDelay(args, actionParams) : configDelay;
  } else
    resolvedDelay = typeof delay2 == "function" ? delay2(args, actionParams) : delay2;
  const resolvedTarget = typeof to == "function" ? to(args, actionParams) : to;
  let targetActorRef;
  if (typeof resolvedTarget == "string") {
    if (resolvedTarget === SpecialTargets.Parent ? targetActorRef = actorScope.self._parent : resolvedTarget === SpecialTargets.Internal ? targetActorRef = actorScope.self : resolvedTarget.startsWith("#_") ? targetActorRef = snapshot.children[resolvedTarget.slice(2)] : targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget], !targetActorRef)
      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);
  } else
    targetActorRef = resolvedTarget || actorScope.self;
  return [snapshot, {
    to: targetActorRef,
    targetId: typeof resolvedTarget == "string" ? resolvedTarget : void 0,
    event: resolvedEvent,
    id: id2,
    delay: resolvedDelay
  }, void 0];
}
function retryResolveSendTo(_2, snapshot, params) {
  typeof params.to == "string" && (params.to = snapshot.children[params.to]);
}
function executeSendTo(actorScope, params) {
  actorScope.defer(() => {
    const {
      to,
      event,
      delay: delay2,
      id: id2
    } = params;
    if (typeof delay2 == "number") {
      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay2, id2);
      return;
    }
    actorScope.system._relay(
      actorScope.self,
      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
      // if it initially started as a string
      to,
      event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event
    );
  });
}
function sendTo(to, eventOrExpr, options) {
  function sendTo2(_args, _params) {
  }
  return sendTo2.type = "xstate.sendTo", sendTo2.to = to, sendTo2.event = eventOrExpr, sendTo2.id = options?.id, sendTo2.delay = options?.delay, sendTo2.resolve = resolveSendTo, sendTo2.retryResolve = retryResolveSendTo, sendTo2.execute = executeSendTo, sendTo2;
}
function sendParent(event, options) {
  return sendTo(SpecialTargets.Parent, event, options);
}
function resolveEnqueueActions(actorScope, snapshot, args, actionParams, {
  collect
}) {
  const actions = [], enqueue = function(action) {
    actions.push(action);
  };
  return enqueue.assign = (...args2) => {
    actions.push(assign(...args2));
  }, enqueue.cancel = (...args2) => {
    actions.push(cancel(...args2));
  }, enqueue.raise = (...args2) => {
    actions.push(raise(...args2));
  }, enqueue.sendTo = (...args2) => {
    actions.push(sendTo(...args2));
  }, enqueue.sendParent = (...args2) => {
    actions.push(sendParent(...args2));
  }, enqueue.spawnChild = (...args2) => {
    actions.push(spawnChild(...args2));
  }, enqueue.stopChild = (...args2) => {
    actions.push(stopChild(...args2));
  }, enqueue.emit = (...args2) => {
    actions.push(emit(...args2));
  }, collect({
    context: args.context,
    event: args.event,
    enqueue,
    check: (guard) => evaluateGuard(guard, snapshot.context, args.event, snapshot),
    self: actorScope.self,
    system: actorScope.system
  }, actionParams), [snapshot, void 0, actions];
}
function enqueueActions(collect) {
  function enqueueActions2(_args, _params) {
  }
  return enqueueActions2.type = "xstate.enqueueActions", enqueueActions2.collect = collect, enqueueActions2.resolve = resolveEnqueueActions, enqueueActions2;
}
function resolveLog(_2, snapshot, actionArgs, actionParams, {
  value,
  label
}) {
  return [snapshot, {
    value: typeof value == "function" ? value(actionArgs, actionParams) : value,
    label
  }, void 0];
}
function executeLog({
  logger
}, {
  value,
  label
}) {
  label ? logger(label, value) : logger(value);
}
function log(value = ({
  context,
  event
}) => ({
  context,
  event
}), label) {
  function log2(_args, _params) {
  }
  return log2.type = "xstate.log", log2.value = value, log2.label = label, log2.resolve = resolveLog, log2.execute = executeLog, log2;
}
function assertEvent(event, type) {
  const types = toArray$1(type);
  if (!types.includes(event.type)) {
    const typesText = types.length === 1 ? `type "${types[0]}"` : `one of types "${types.join('", "')}"`;
    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);
  }
}
function createMachine(config2, implementations) {
  return new StateMachine(config2, implementations);
}
function setup({
  schemas,
  actors,
  actions,
  guards,
  delays
}) {
  return {
    assign,
    sendTo,
    raise,
    log,
    cancel,
    stopChild,
    enqueueActions,
    emit,
    spawnChild,
    createStateConfig: (config2) => config2,
    createAction: (fn) => fn,
    createMachine: (config2) => createMachine({
      ...config2,
      schemas
    }, {
      actors,
      actions,
      guards,
      delays
    }),
    extend: (extended) => setup({
      schemas,
      actors,
      actions: {
        ...actions,
        ...extended.actions
      },
      guards: {
        ...guards,
        ...extended.guards
      },
      delays: {
        ...delays,
        ...extended.delays
      }
    })
  };
}
requireShim();
const forEachActor = (actorRef, callback) => {
  callback(actorRef);
  const children2 = actorRef.getSnapshot().children;
  children2 && Object.values(children2).forEach((child) => {
    forEachActor(child, callback);
  });
};
function stopRootWithRehydration(actorRef) {
  const persistedSnapshots = [];
  forEachActor(actorRef, (ref) => {
    persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();
  });
  const systemSnapshot = actorRef.system.getSnapshot?.();
  actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {
    ref._processingStatus = 0, ref._snapshot = snapshot;
  });
}
function useIdleActorRef(logic, ...[options]) {
  let [[currentConfig, actorRef], setCurrent] = useState(() => {
    const actorRef2 = createActor(logic, options);
    return [logic.config, actorRef2];
  });
  if (logic.config !== currentConfig) {
    const newActorRef = createActor(logic, {
      ...options,
      snapshot: actorRef.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    setCurrent([logic.config, newActorRef]), actorRef = newActorRef;
  }
  return index$1(() => {
    actorRef.logic.implementations = logic.implementations;
  }), actorRef;
}
function useActorRef(machine, ...[options, observerOrListener]) {
  const actorRef = useIdleActorRef(machine, options);
  return useEffect(() => {
    if (!observerOrListener)
      return;
    const sub = actorRef.subscribe(toObserver(observerOrListener));
    return () => {
      sub.unsubscribe();
    };
  }, [observerOrListener]), useEffect(() => (actorRef.start(), () => {
    stopRootWithRehydration(actorRef);
  }), [actorRef]), actorRef;
}
function defaultCompare(a2, b) {
  return a2 === b;
}
function useSelector(actor, selector2, compare = defaultCompare) {
  const subscribe = useCallback((handleStoreChange) => {
    if (!actor)
      return () => {
      };
    const {
      unsubscribe
    } = actor.subscribe(handleStoreChange);
    return unsubscribe;
  }, [actor]), boundGetSnapshot = useCallback(() => actor?.getSnapshot(), [actor]);
  return withSelectorExports.useSyncExternalStoreWithSelector(subscribe, boundGetSnapshot, boundGetSnapshot, selector2, compare);
}
function createMinimalMotionComponent(Component2, options) {
  return createMotionComponent(Component2, options);
}
const MotionButton = /* @__PURE__ */ createMinimalMotionComponent("button"), MotionDiv = /* @__PURE__ */ createMinimalMotionComponent("div");
var graph, hasRequiredGraph;
function requireGraph() {
  if (hasRequiredGraph) return graph;
  hasRequiredGraph = 1;
  var DEFAULT_EDGE_NAME = "\0", GRAPH_NODE = "\0", EDGE_KEY_DELIM = "";
  class Graph {
    _isDirected = !0;
    _isMultigraph = !1;
    _isCompound = !1;
    // Label for the graph itself
    _label;
    // Defaults to be set when creating a new node
    _defaultNodeLabelFn = () => {
    };
    // Defaults to be set when creating a new edge
    _defaultEdgeLabelFn = () => {
    };
    // v -> label
    _nodes = {};
    // v -> edgeObj
    _in = {};
    // u -> v -> Number
    _preds = {};
    // v -> edgeObj
    _out = {};
    // v -> w -> Number
    _sucs = {};
    // e -> edgeObj
    _edgeObjs = {};
    // e -> label
    _edgeLabels = {};
    /* Number of nodes in the graph. Should only be changed by the implementation. */
    _nodeCount = 0;
    /* Number of edges in the graph. Should only be changed by the implementation. */
    _edgeCount = 0;
    _parent;
    _children;
    constructor(opts) {
      opts && (this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : !0, this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : !1, this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : !1), this._isCompound && (this._parent = {}, this._children = {}, this._children[GRAPH_NODE] = {});
    }
    /* === Graph functions ========= */
    /**
     * Whether graph was created with 'directed' flag set to true or not.
     */
    isDirected() {
      return this._isDirected;
    }
    /**
     * Whether graph was created with 'multigraph' flag set to true or not.
     */
    isMultigraph() {
      return this._isMultigraph;
    }
    /**
     * Whether graph was created with 'compound' flag set to true or not.
     */
    isCompound() {
      return this._isCompound;
    }
    /**
     * Sets the label of the graph.
     */
    setGraph(label) {
      return this._label = label, this;
    }
    /**
     * Gets the graph label.
     */
    graph() {
      return this._label;
    }
    /* === Node functions ========== */
    /**
     * Sets the default node label. If newDefault is a function, it will be
     * invoked ach time when setting a label for a node. Otherwise, this label
     * will be assigned as default label in case if no label was specified while
     * setting a node.
     * Complexity: O(1).
     */
    setDefaultNodeLabel(newDefault) {
      return this._defaultNodeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultNodeLabelFn = () => newDefault), this;
    }
    /**
     * Gets the number of nodes in the graph.
     * Complexity: O(1).
     */
    nodeCount() {
      return this._nodeCount;
    }
    /**
     * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
     * not included in list.
     * Complexity: O(1).
     */
    nodes() {
      return Object.keys(this._nodes);
    }
    /**
     * Gets list of nodes without in-edges.
     * Complexity: O(|V|).
     */
    sources() {
      var self2 = this;
      return this.nodes().filter((v) => Object.keys(self2._in[v]).length === 0);
    }
    /**
     * Gets list of nodes without out-edges.
     * Complexity: O(|V|).
     */
    sinks() {
      var self2 = this;
      return this.nodes().filter((v) => Object.keys(self2._out[v]).length === 0);
    }
    /**
     * Invokes setNode method for each node in names list.
     * Complexity: O(|names|).
     */
    setNodes(vs, value) {
      var args = arguments, self2 = this;
      return vs.forEach(function(v) {
        args.length > 1 ? self2.setNode(v, value) : self2.setNode(v);
      }), this;
    }
    /**
     * Creates or updates the value for the node v in the graph. If label is supplied
     * it is set as the value for the node. If label is not supplied and the node was
     * created by this call then the default node label will be assigned.
     * Complexity: O(1).
     */
    setNode(v, value) {
      return Object.hasOwn(this._nodes, v) ? (arguments.length > 1 && (this._nodes[v] = value), this) : (this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v), this._isCompound && (this._parent[v] = GRAPH_NODE, this._children[v] = {}, this._children[GRAPH_NODE][v] = !0), this._in[v] = {}, this._preds[v] = {}, this._out[v] = {}, this._sucs[v] = {}, ++this._nodeCount, this);
    }
    /**
     * Gets the label of node with specified name.
     * Complexity: O(|V|).
     */
    node(v) {
      return this._nodes[v];
    }
    /**
     * Detects whether graph has a node with specified name or not.
     */
    hasNode(v) {
      return Object.hasOwn(this._nodes, v);
    }
    /**
     * Remove the node with the name from the graph or do nothing if the node is not in
     * the graph. If the node was removed this function also removes any incident
     * edges.
     * Complexity: O(1).
     */
    removeNode(v) {
      var self2 = this;
      if (Object.hasOwn(this._nodes, v)) {
        var removeEdge = (e2) => self2.removeEdge(self2._edgeObjs[e2]);
        delete this._nodes[v], this._isCompound && (this._removeFromParentsChildList(v), delete this._parent[v], this.children(v).forEach(function(child) {
          self2.setParent(child);
        }), delete this._children[v]), Object.keys(this._in[v]).forEach(removeEdge), delete this._in[v], delete this._preds[v], Object.keys(this._out[v]).forEach(removeEdge), delete this._out[v], delete this._sucs[v], --this._nodeCount;
      }
      return this;
    }
    /**
     * Sets node p as a parent for node v if it is defined, or removes the
     * parent for v if p is undefined. Method throws an exception in case of
     * invoking it in context of noncompound graph.
     * Average-case complexity: O(1).
     */
    setParent(v, parent) {
      if (!this._isCompound)
        throw new Error("Cannot set parent in a non-compound graph");
      if (parent === void 0)
        parent = GRAPH_NODE;
      else {
        parent += "";
        for (var ancestor = parent; ancestor !== void 0; ancestor = this.parent(ancestor))
          if (ancestor === v)
            throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
        this.setNode(parent);
      }
      return this.setNode(v), this._removeFromParentsChildList(v), this._parent[v] = parent, this._children[parent][v] = !0, this;
    }
    _removeFromParentsChildList(v) {
      delete this._children[this._parent[v]][v];
    }
    /**
     * Gets parent node for node v.
     * Complexity: O(1).
     */
    parent(v) {
      if (this._isCompound) {
        var parent = this._parent[v];
        if (parent !== GRAPH_NODE)
          return parent;
      }
    }
    /**
     * Gets list of direct children of node v.
     * Complexity: O(1).
     */
    children(v = GRAPH_NODE) {
      if (this._isCompound) {
        var children2 = this._children[v];
        if (children2)
          return Object.keys(children2);
      } else {
        if (v === GRAPH_NODE)
          return this.nodes();
        if (this.hasNode(v))
          return [];
      }
    }
    /**
     * Return all nodes that are predecessors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
    predecessors(v) {
      var predsV = this._preds[v];
      if (predsV)
        return Object.keys(predsV);
    }
    /**
     * Return all nodes that are successors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
    successors(v) {
      var sucsV = this._sucs[v];
      if (sucsV)
        return Object.keys(sucsV);
    }
    /**
     * Return all nodes that are predecessors or successors of the specified node or undefined if
     * node v is not in the graph.
     * Complexity: O(|V|).
     */
    neighbors(v) {
      var preds = this.predecessors(v);
      if (preds) {
        const union2 = new Set(preds);
        for (var succ of this.successors(v))
          union2.add(succ);
        return Array.from(union2.values());
      }
    }
    isLeaf(v) {
      var neighbors;
      return this.isDirected() ? neighbors = this.successors(v) : neighbors = this.neighbors(v), neighbors.length === 0;
    }
    /**
     * Creates new graph with nodes filtered via filter. Edges incident to rejected node
     * are also removed. In case of compound graph, if parent is rejected by filter,
     * than all its children are rejected too.
     * Average-case complexity: O(|E|+|V|).
     */
    filterNodes(filter2) {
      var copy = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      copy.setGraph(this.graph());
      var self2 = this;
      Object.entries(this._nodes).forEach(function([v, value]) {
        filter2(v) && copy.setNode(v, value);
      }), Object.values(this._edgeObjs).forEach(function(e2) {
        copy.hasNode(e2.v) && copy.hasNode(e2.w) && copy.setEdge(e2, self2.edge(e2));
      });
      var parents = {};
      function findParent(v) {
        var parent = self2.parent(v);
        return parent === void 0 || copy.hasNode(parent) ? (parents[v] = parent, parent) : parent in parents ? parents[parent] : findParent(parent);
      }
      return this._isCompound && copy.nodes().forEach((v) => copy.setParent(v, findParent(v))), copy;
    }
    /* === Edge functions ========== */
    /**
     * Sets the default edge label or factory function. This label will be
     * assigned as default label in case if no label was specified while setting
     * an edge or this function will be invoked each time when setting an edge
     * with no label specified and returned value * will be used as a label for edge.
     * Complexity: O(1).
     */
    setDefaultEdgeLabel(newDefault) {
      return this._defaultEdgeLabelFn = newDefault, typeof newDefault != "function" && (this._defaultEdgeLabelFn = () => newDefault), this;
    }
    /**
     * Gets the number of edges in the graph.
     * Complexity: O(1).
     */
    edgeCount() {
      return this._edgeCount;
    }
    /**
     * Gets edges of the graph. In case of compound graph subgraphs are not considered.
     * Complexity: O(|E|).
     */
    edges() {
      return Object.values(this._edgeObjs);
    }
    /**
     * Establish an edges path over the nodes in nodes list. If some edge is already
     * exists, it will update its label, otherwise it will create an edge between pair
     * of nodes with label provided or default label if no label provided.
     * Complexity: O(|nodes|).
     */
    setPath(vs, value) {
      var self2 = this, args = arguments;
      return vs.reduce(function(v, w) {
        return args.length > 1 ? self2.setEdge(v, w, value) : self2.setEdge(v, w), w;
      }), this;
    }
    /**
     * Creates or updates the label for the edge (v, w) with the optionally supplied
     * name. If label is supplied it is set as the value for the edge. If label is not
     * supplied and the edge was created by this call then the default edge label will
     * be assigned. The name parameter is only useful with multigraphs.
     */
    setEdge() {
      var v, w, name, value, valueSpecified = !1, arg0 = arguments[0];
      typeof arg0 == "object" && arg0 !== null && "v" in arg0 ? (v = arg0.v, w = arg0.w, name = arg0.name, arguments.length === 2 && (value = arguments[1], valueSpecified = !0)) : (v = arg0, w = arguments[1], name = arguments[3], arguments.length > 2 && (value = arguments[2], valueSpecified = !0)), v = "" + v, w = "" + w, name !== void 0 && (name = "" + name);
      var e2 = edgeArgsToId(this._isDirected, v, w, name);
      if (Object.hasOwn(this._edgeLabels, e2))
        return valueSpecified && (this._edgeLabels[e2] = value), this;
      if (name !== void 0 && !this._isMultigraph)
        throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(v), this.setNode(w), this._edgeLabels[e2] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
      var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
      return v = edgeObj.v, w = edgeObj.w, Object.freeze(edgeObj), this._edgeObjs[e2] = edgeObj, incrementOrInitEntry(this._preds[w], v), incrementOrInitEntry(this._sucs[v], w), this._in[w][e2] = edgeObj, this._out[v][e2] = edgeObj, this._edgeCount++, this;
    }
    /**
     * Gets the label for the specified edge.
     * Complexity: O(1).
     */
    edge(v, w, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      return this._edgeLabels[e2];
    }
    /**
     * Gets the label for the specified edge and converts it to an object.
     * Complexity: O(1)
     */
    edgeAsObj() {
      const edge = this.edge(...arguments);
      return typeof edge != "object" ? { label: edge } : edge;
    }
    /**
     * Detects whether the graph contains specified edge or not. No subgraphs are considered.
     * Complexity: O(1).
     */
    hasEdge(v, w, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      return Object.hasOwn(this._edgeLabels, e2);
    }
    /**
     * Removes the specified edge from the graph. No subgraphs are considered.
     * Complexity: O(1).
     */
    removeEdge(v, w, name) {
      var e2 = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name), edge = this._edgeObjs[e2];
      return edge && (v = edge.v, w = edge.w, delete this._edgeLabels[e2], delete this._edgeObjs[e2], decrementOrRemoveEntry(this._preds[w], v), decrementOrRemoveEntry(this._sucs[v], w), delete this._in[w][e2], delete this._out[v][e2], this._edgeCount--), this;
    }
    /**
     * Return all edges that point to the node v. Optionally filters those edges down to just those
     * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
    inEdges(v, u) {
      var inV = this._in[v];
      if (inV) {
        var edges = Object.values(inV);
        return u ? edges.filter((edge) => edge.v === u) : edges;
      }
    }
    /**
     * Return all edges that are pointed at by node v. Optionally filters those edges down to just
     * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
    outEdges(v, w) {
      var outV = this._out[v];
      if (outV) {
        var edges = Object.values(outV);
        return w ? edges.filter((edge) => edge.w === w) : edges;
      }
    }
    /**
     * Returns all edges to or from node v regardless of direction. Optionally filters those edges
     * down to just those between nodes v and w regardless of direction.
     * Complexity: O(|E|).
     */
    nodeEdges(v, w) {
      var inEdges = this.inEdges(v, w);
      if (inEdges)
        return inEdges.concat(this.outEdges(v, w));
    }
  }
  function incrementOrInitEntry(map, k) {
    map[k] ? map[k]++ : map[k] = 1;
  }
  function decrementOrRemoveEntry(map, k) {
    --map[k] || delete map[k];
  }
  function edgeArgsToId(isDirected, v_, w_, name) {
    var v = "" + v_, w = "" + w_;
    if (!isDirected && v > w) {
      var tmp = v;
      v = w, w = tmp;
    }
    return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === void 0 ? DEFAULT_EDGE_NAME : name);
  }
  function edgeArgsToObj(isDirected, v_, w_, name) {
    var v = "" + v_, w = "" + w_;
    if (!isDirected && v > w) {
      var tmp = v;
      v = w, w = tmp;
    }
    var edgeObj = { v, w };
    return name && (edgeObj.name = name), edgeObj;
  }
  function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
  }
  return graph = Graph, graph;
}
var version$2, hasRequiredVersion$1;
function requireVersion$1() {
  return hasRequiredVersion$1 || (hasRequiredVersion$1 = 1, version$2 = "2.2.4"), version$2;
}
var lib, hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, lib = {
    Graph: requireGraph(),
    version: requireVersion$1()
  }), lib;
}
var json, hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var Graph = requireGraph();
  json = {
    write,
    read
  };
  function write(g) {
    var json2 = {
      options: {
        directed: g.isDirected(),
        multigraph: g.isMultigraph(),
        compound: g.isCompound()
      },
      nodes: writeNodes(g),
      edges: writeEdges(g)
    };
    return g.graph() !== void 0 && (json2.value = structuredClone(g.graph())), json2;
  }
  function writeNodes(g) {
    return g.nodes().map(function(v) {
      var nodeValue = g.node(v), parent = g.parent(v), node = { v };
      return nodeValue !== void 0 && (node.value = nodeValue), parent !== void 0 && (node.parent = parent), node;
    });
  }
  function writeEdges(g) {
    return g.edges().map(function(e2) {
      var edgeValue = g.edge(e2), edge = { v: e2.v, w: e2.w };
      return e2.name !== void 0 && (edge.name = e2.name), edgeValue !== void 0 && (edge.value = edgeValue), edge;
    });
  }
  function read(json2) {
    var g = new Graph(json2.options).setGraph(json2.value);
    return json2.nodes.forEach(function(entry) {
      g.setNode(entry.v, entry.value), entry.parent && g.setParent(entry.v, entry.parent);
    }), json2.edges.forEach(function(entry) {
      g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    }), g;
  }
  return json;
}
var components_1, hasRequiredComponents;
function requireComponents() {
  if (hasRequiredComponents) return components_1;
  hasRequiredComponents = 1, components_1 = components;
  function components(g) {
    var visited = {}, cmpts = [], cmpt;
    function dfs(v) {
      Object.hasOwn(visited, v) || (visited[v] = !0, cmpt.push(v), g.successors(v).forEach(dfs), g.predecessors(v).forEach(dfs));
    }
    return g.nodes().forEach(function(v) {
      cmpt = [], dfs(v), cmpt.length && cmpts.push(cmpt);
    }), cmpts;
  }
  return components_1;
}
var priorityQueue, hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue) return priorityQueue;
  hasRequiredPriorityQueue = 1;
  class PriorityQueue {
    _arr = [];
    _keyIndices = {};
    /**
     * Returns the number of elements in the queue. Takes `O(1)` time.
     */
    size() {
      return this._arr.length;
    }
    /**
     * Returns the keys that are in the queue. Takes `O(n)` time.
     */
    keys() {
      return this._arr.map(function(x2) {
        return x2.key;
      });
    }
    /**
     * Returns `true` if **key** is in the queue and `false` if not.
     */
    has(key) {
      return Object.hasOwn(this._keyIndices, key);
    }
    /**
     * Returns the priority for **key**. If **key** is not present in the queue
     * then this function returns `undefined`. Takes `O(1)` time.
     *
     * @param {Object} key
     */
    priority(key) {
      var index2 = this._keyIndices[key];
      if (index2 !== void 0)
        return this._arr[index2].priority;
    }
    /**
     * Returns the key for the minimum element in this queue. If the queue is
     * empty this function throws an Error. Takes `O(1)` time.
     */
    min() {
      if (this.size() === 0)
        throw new Error("Queue underflow");
      return this._arr[0].key;
    }
    /**
     * Inserts a new key into the priority queue. If the key already exists in
     * the queue this function returns `false`; otherwise it will return `true`.
     * Takes `O(n)` time.
     *
     * @param {Object} key the key to add
     * @param {Number} priority the initial priority for the key
     */
    add(key, priority) {
      var keyIndices = this._keyIndices;
      if (key = String(key), !Object.hasOwn(keyIndices, key)) {
        var arr = this._arr, index2 = arr.length;
        return keyIndices[key] = index2, arr.push({ key, priority }), this._decrease(index2), !0;
      }
      return !1;
    }
    /**
     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
     */
    removeMin() {
      this._swap(0, this._arr.length - 1);
      var min2 = this._arr.pop();
      return delete this._keyIndices[min2.key], this._heapify(0), min2.key;
    }
    /**
     * Decreases the priority for **key** to **priority**. If the new priority is
     * greater than the previous priority, this function will throw an Error.
     *
     * @param {Object} key the key for which to raise priority
     * @param {Number} priority the new priority for the key
     */
    decrease(key, priority) {
      var index2 = this._keyIndices[key];
      if (priority > this._arr[index2].priority)
        throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
      this._arr[index2].priority = priority, this._decrease(index2);
    }
    _heapify(i2) {
      var arr = this._arr, l = 2 * i2, r2 = l + 1, largest = i2;
      l < arr.length && (largest = arr[l].priority < arr[largest].priority ? l : largest, r2 < arr.length && (largest = arr[r2].priority < arr[largest].priority ? r2 : largest), largest !== i2 && (this._swap(i2, largest), this._heapify(largest)));
    }
    _decrease(index2) {
      for (var arr = this._arr, priority = arr[index2].priority, parent; index2 !== 0 && (parent = index2 >> 1, !(arr[parent].priority < priority)); )
        this._swap(index2, parent), index2 = parent;
    }
    _swap(i2, j) {
      var arr = this._arr, keyIndices = this._keyIndices, origArrI = arr[i2], origArrJ = arr[j];
      arr[i2] = origArrJ, arr[j] = origArrI, keyIndices[origArrJ.key] = i2, keyIndices[origArrI.key] = j;
    }
  }
  return priorityQueue = PriorityQueue, priorityQueue;
}
var dijkstra_1, hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra_1;
  hasRequiredDijkstra = 1;
  var PriorityQueue = requirePriorityQueue();
  dijkstra_1 = dijkstra;
  var DEFAULT_WEIGHT_FUNC = () => 1;
  function dijkstra(g, source, weightFn, edgeFn) {
    return runDijkstra(
      g,
      String(source),
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v) {
        return g.outEdges(v);
      }
    );
  }
  function runDijkstra(g, source, weightFn, edgeFn) {
    var results = {}, pq = new PriorityQueue(), v, vEntry, updateNeighbors = function(edge) {
      var w = edge.v !== v ? edge.v : edge.w, wEntry = results[w], weight = weightFn(edge), distance2 = vEntry.distance + weight;
      if (weight < 0)
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
      distance2 < wEntry.distance && (wEntry.distance = distance2, wEntry.predecessor = v, pq.decrease(w, distance2));
    };
    for (g.nodes().forEach(function(v2) {
      var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
      results[v2] = { distance: distance2 }, pq.add(v2, distance2);
    }); pq.size() > 0 && (v = pq.removeMin(), vEntry = results[v], vEntry.distance !== Number.POSITIVE_INFINITY); )
      edgeFn(v).forEach(updateNeighbors);
    return results;
  }
  return dijkstra_1;
}
var dijkstraAll_1, hasRequiredDijkstraAll;
function requireDijkstraAll() {
  if (hasRequiredDijkstraAll) return dijkstraAll_1;
  hasRequiredDijkstraAll = 1;
  var dijkstra = requireDijkstra();
  dijkstraAll_1 = dijkstraAll;
  function dijkstraAll(g, weightFunc, edgeFunc) {
    return g.nodes().reduce(function(acc, v) {
      return acc[v] = dijkstra(g, v, weightFunc, edgeFunc), acc;
    }, {});
  }
  return dijkstraAll_1;
}
var tarjan_1, hasRequiredTarjan;
function requireTarjan() {
  if (hasRequiredTarjan) return tarjan_1;
  hasRequiredTarjan = 1, tarjan_1 = tarjan;
  function tarjan(g) {
    var index2 = 0, stack = [], visited = {}, results = [];
    function dfs(v) {
      var entry = visited[v] = {
        onStack: !0,
        lowlink: index2,
        index: index2++
      };
      if (stack.push(v), g.successors(v).forEach(function(w2) {
        Object.hasOwn(visited, w2) ? visited[w2].onStack && (entry.lowlink = Math.min(entry.lowlink, visited[w2].index)) : (dfs(w2), entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink));
      }), entry.lowlink === entry.index) {
        var cmpt = [], w;
        do
          w = stack.pop(), visited[w].onStack = !1, cmpt.push(w);
        while (v !== w);
        results.push(cmpt);
      }
    }
    return g.nodes().forEach(function(v) {
      Object.hasOwn(visited, v) || dfs(v);
    }), results;
  }
  return tarjan_1;
}
var findCycles_1, hasRequiredFindCycles;
function requireFindCycles() {
  if (hasRequiredFindCycles) return findCycles_1;
  hasRequiredFindCycles = 1;
  var tarjan = requireTarjan();
  findCycles_1 = findCycles;
  function findCycles(g) {
    return tarjan(g).filter(function(cmpt) {
      return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
    });
  }
  return findCycles_1;
}
var floydWarshall_1, hasRequiredFloydWarshall;
function requireFloydWarshall() {
  if (hasRequiredFloydWarshall) return floydWarshall_1;
  hasRequiredFloydWarshall = 1, floydWarshall_1 = floydWarshall;
  var DEFAULT_WEIGHT_FUNC = () => 1;
  function floydWarshall(g, weightFn, edgeFn) {
    return runFloydWarshall(
      g,
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v) {
        return g.outEdges(v);
      }
    );
  }
  function runFloydWarshall(g, weightFn, edgeFn) {
    var results = {}, nodes = g.nodes();
    return nodes.forEach(function(v) {
      results[v] = {}, results[v][v] = { distance: 0 }, nodes.forEach(function(w) {
        v !== w && (results[v][w] = { distance: Number.POSITIVE_INFINITY });
      }), edgeFn(v).forEach(function(edge) {
        var w = edge.v === v ? edge.w : edge.v, d = weightFn(edge);
        results[v][w] = { distance: d, predecessor: v };
      });
    }), nodes.forEach(function(k) {
      var rowK = results[k];
      nodes.forEach(function(i2) {
        var rowI = results[i2];
        nodes.forEach(function(j) {
          var ik = rowI[k], kj = rowK[j], ij = rowI[j], altDistance = ik.distance + kj.distance;
          altDistance < ij.distance && (ij.distance = altDistance, ij.predecessor = kj.predecessor);
        });
      });
    }), results;
  }
  return floydWarshall_1;
}
var topsort_1, hasRequiredTopsort;
function requireTopsort() {
  if (hasRequiredTopsort) return topsort_1;
  hasRequiredTopsort = 1;
  function topsort(g) {
    var visited = {}, stack = {}, results = [];
    function visit(node) {
      if (Object.hasOwn(stack, node))
        throw new CycleException();
      Object.hasOwn(visited, node) || (stack[node] = !0, visited[node] = !0, g.predecessors(node).forEach(visit), delete stack[node], results.push(node));
    }
    if (g.sinks().forEach(visit), Object.keys(visited).length !== g.nodeCount())
      throw new CycleException();
    return results;
  }
  class CycleException extends Error {
    constructor() {
      super(...arguments);
    }
  }
  return topsort_1 = topsort, topsort.CycleException = CycleException, topsort_1;
}
var isAcyclic_1, hasRequiredIsAcyclic;
function requireIsAcyclic() {
  if (hasRequiredIsAcyclic) return isAcyclic_1;
  hasRequiredIsAcyclic = 1;
  var topsort = requireTopsort();
  isAcyclic_1 = isAcyclic;
  function isAcyclic(g) {
    try {
      topsort(g);
    } catch (e2) {
      if (e2 instanceof topsort.CycleException)
        return !1;
      throw e2;
    }
    return !0;
  }
  return isAcyclic_1;
}
var dfs_1, hasRequiredDfs;
function requireDfs() {
  if (hasRequiredDfs) return dfs_1;
  hasRequiredDfs = 1, dfs_1 = dfs;
  function dfs(g, vs, order) {
    Array.isArray(vs) || (vs = [vs]);
    var navigation = g.isDirected() ? (v) => g.successors(v) : (v) => g.neighbors(v), orderFunc = order === "post" ? postOrderDfs : preOrderDfs, acc = [], visited = {};
    return vs.forEach((v) => {
      if (!g.hasNode(v))
        throw new Error("Graph does not have node: " + v);
      orderFunc(v, navigation, visited, acc);
    }), acc;
  }
  function postOrderDfs(v, navigation, visited, acc) {
    for (var stack = [[v, !1]]; stack.length > 0; ) {
      var curr = stack.pop();
      curr[1] ? acc.push(curr[0]) : Object.hasOwn(visited, curr[0]) || (visited[curr[0]] = !0, stack.push([curr[0], !0]), forEachRight(navigation(curr[0]), (w) => stack.push([w, !1])));
    }
  }
  function preOrderDfs(v, navigation, visited, acc) {
    for (var stack = [v]; stack.length > 0; ) {
      var curr = stack.pop();
      Object.hasOwn(visited, curr) || (visited[curr] = !0, acc.push(curr), forEachRight(navigation(curr), (w) => stack.push(w)));
    }
  }
  function forEachRight(array2, iteratee) {
    for (var length = array2.length; length--; )
      iteratee(array2[length], length, array2);
    return array2;
  }
  return dfs_1;
}
var postorder_1, hasRequiredPostorder;
function requirePostorder() {
  if (hasRequiredPostorder) return postorder_1;
  hasRequiredPostorder = 1;
  var dfs = requireDfs();
  postorder_1 = postorder;
  function postorder(g, vs) {
    return dfs(g, vs, "post");
  }
  return postorder_1;
}
var preorder_1, hasRequiredPreorder;
function requirePreorder() {
  if (hasRequiredPreorder) return preorder_1;
  hasRequiredPreorder = 1;
  var dfs = requireDfs();
  preorder_1 = preorder;
  function preorder(g, vs) {
    return dfs(g, vs, "pre");
  }
  return preorder_1;
}
var prim_1, hasRequiredPrim;
function requirePrim() {
  if (hasRequiredPrim) return prim_1;
  hasRequiredPrim = 1;
  var Graph = requireGraph(), PriorityQueue = requirePriorityQueue();
  prim_1 = prim;
  function prim(g, weightFunc) {
    var result = new Graph(), parents = {}, pq = new PriorityQueue(), v;
    function updateNeighbors(edge) {
      var w = edge.v === v ? edge.w : edge.v, pri = pq.priority(w);
      if (pri !== void 0) {
        var edgeWeight = weightFunc(edge);
        edgeWeight < pri && (parents[w] = v, pq.decrease(w, edgeWeight));
      }
    }
    if (g.nodeCount() === 0)
      return result;
    g.nodes().forEach(function(v2) {
      pq.add(v2, Number.POSITIVE_INFINITY), result.setNode(v2);
    }), pq.decrease(g.nodes()[0], 0);
    for (var init2 = !1; pq.size() > 0; ) {
      if (v = pq.removeMin(), Object.hasOwn(parents, v))
        result.setEdge(v, parents[v]);
      else {
        if (init2)
          throw new Error("Input graph is not connected: " + g);
        init2 = !0;
      }
      g.nodeEdges(v).forEach(updateNeighbors);
    }
    return result;
  }
  return prim_1;
}
var alg, hasRequiredAlg;
function requireAlg() {
  return hasRequiredAlg || (hasRequiredAlg = 1, alg = {
    components: requireComponents(),
    dijkstra: requireDijkstra(),
    dijkstraAll: requireDijkstraAll(),
    findCycles: requireFindCycles(),
    floydWarshall: requireFloydWarshall(),
    isAcyclic: requireIsAcyclic(),
    postorder: requirePostorder(),
    preorder: requirePreorder(),
    prim: requirePrim(),
    tarjan: requireTarjan(),
    topsort: requireTopsort()
  }), alg;
}
var graphlib, hasRequiredGraphlib;
function requireGraphlib() {
  if (hasRequiredGraphlib) return graphlib;
  hasRequiredGraphlib = 1;
  var lib2 = requireLib();
  return graphlib = {
    Graph: lib2.Graph,
    json: requireJson(),
    alg: requireAlg(),
    version: lib2.version
  }, graphlib;
}
var list, hasRequiredList;
function requireList() {
  if (hasRequiredList) return list;
  hasRequiredList = 1;
  class List {
    constructor() {
      let sentinel = {};
      sentinel._next = sentinel._prev = sentinel, this._sentinel = sentinel;
    }
    dequeue() {
      let sentinel = this._sentinel, entry = sentinel._prev;
      if (entry !== sentinel)
        return unlink(entry), entry;
    }
    enqueue(entry) {
      let sentinel = this._sentinel;
      entry._prev && entry._next && unlink(entry), entry._next = sentinel._next, sentinel._next._prev = entry, sentinel._next = entry, entry._prev = sentinel;
    }
    toString() {
      let strs = [], sentinel = this._sentinel, curr = sentinel._prev;
      for (; curr !== sentinel; )
        strs.push(JSON.stringify(curr, filterOutLinks)), curr = curr._prev;
      return "[" + strs.join(", ") + "]";
    }
  }
  function unlink(entry) {
    entry._prev._next = entry._next, entry._next._prev = entry._prev, delete entry._next, delete entry._prev;
  }
  function filterOutLinks(k, v) {
    if (k !== "_next" && k !== "_prev")
      return v;
  }
  return list = List, list;
}
var greedyFas, hasRequiredGreedyFas;
function requireGreedyFas() {
  if (hasRequiredGreedyFas) return greedyFas;
  hasRequiredGreedyFas = 1;
  let Graph = requireGraphlib().Graph, List = requireList();
  greedyFas = greedyFAS;
  let DEFAULT_WEIGHT_FN = () => 1;
  function greedyFAS(g, weightFn) {
    if (g.nodeCount() <= 1)
      return [];
    let state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
    return doGreedyFAS(state.graph, state.buckets, state.zeroIdx).flatMap((e2) => g.outEdges(e2.v, e2.w));
  }
  function doGreedyFAS(g, buckets, zeroIdx) {
    let results = [], sources = buckets[buckets.length - 1], sinks = buckets[0], entry;
    for (; g.nodeCount(); ) {
      for (; entry = sinks.dequeue(); )
        removeNode(g, buckets, zeroIdx, entry);
      for (; entry = sources.dequeue(); )
        removeNode(g, buckets, zeroIdx, entry);
      if (g.nodeCount()) {
        for (let i2 = buckets.length - 2; i2 > 0; --i2)
          if (entry = buckets[i2].dequeue(), entry) {
            results = results.concat(removeNode(g, buckets, zeroIdx, entry, !0));
            break;
          }
      }
    }
    return results;
  }
  function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
    let results = collectPredecessors ? [] : void 0;
    return g.inEdges(entry.v).forEach((edge) => {
      let weight = g.edge(edge), uEntry = g.node(edge.v);
      collectPredecessors && results.push({ v: edge.v, w: edge.w }), uEntry.out -= weight, assignBucket(buckets, zeroIdx, uEntry);
    }), g.outEdges(entry.v).forEach((edge) => {
      let weight = g.edge(edge), w = edge.w, wEntry = g.node(w);
      wEntry.in -= weight, assignBucket(buckets, zeroIdx, wEntry);
    }), g.removeNode(entry.v), results;
  }
  function buildState(g, weightFn) {
    let fasGraph = new Graph(), maxIn = 0, maxOut = 0;
    g.nodes().forEach((v) => {
      fasGraph.setNode(v, { v, in: 0, out: 0 });
    }), g.edges().forEach((e2) => {
      let prevWeight = fasGraph.edge(e2.v, e2.w) || 0, weight = weightFn(e2), edgeWeight = prevWeight + weight;
      fasGraph.setEdge(e2.v, e2.w, edgeWeight), maxOut = Math.max(maxOut, fasGraph.node(e2.v).out += weight), maxIn = Math.max(maxIn, fasGraph.node(e2.w).in += weight);
    });
    let buckets = range(maxOut + maxIn + 3).map(() => new List()), zeroIdx = maxIn + 1;
    return fasGraph.nodes().forEach((v) => {
      assignBucket(buckets, zeroIdx, fasGraph.node(v));
    }), { graph: fasGraph, buckets, zeroIdx };
  }
  function assignBucket(buckets, zeroIdx, entry) {
    entry.out ? entry.in ? buckets[entry.out - entry.in + zeroIdx].enqueue(entry) : buckets[buckets.length - 1].enqueue(entry) : buckets[0].enqueue(entry);
  }
  function range(limit) {
    const range2 = [];
    for (let i2 = 0; i2 < limit; i2++)
      range2.push(i2);
    return range2;
  }
  return greedyFas;
}
var util$1, hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  let Graph = requireGraphlib().Graph;
  util$1 = {
    addBorderNode,
    addDummyNode,
    applyWithChunking,
    asNonCompoundGraph,
    buildLayerMatrix,
    intersectRect,
    mapValues: mapValues2,
    maxRank,
    normalizeRanks,
    notime,
    partition,
    pick: pick2,
    predecessorWeights,
    range,
    removeEmptyRanks,
    simplify,
    successorWeights,
    time: time2,
    uniqueId,
    zipObject
  };
  function addDummyNode(g, type, attrs, name) {
    for (var v = name; g.hasNode(v); )
      v = uniqueId(name);
    return attrs.dummy = type, g.setNode(v, attrs), v;
  }
  function simplify(g) {
    let simplified = new Graph().setGraph(g.graph());
    return g.nodes().forEach((v) => simplified.setNode(v, g.node(v))), g.edges().forEach((e2) => {
      let simpleLabel = simplified.edge(e2.v, e2.w) || { weight: 0, minlen: 1 }, label = g.edge(e2);
      simplified.setEdge(e2.v, e2.w, {
        weight: simpleLabel.weight + label.weight,
        minlen: Math.max(simpleLabel.minlen, label.minlen)
      });
    }), simplified;
  }
  function asNonCompoundGraph(g) {
    let simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
    return g.nodes().forEach((v) => {
      g.children(v).length || simplified.setNode(v, g.node(v));
    }), g.edges().forEach((e2) => {
      simplified.setEdge(e2, g.edge(e2));
    }), simplified;
  }
  function successorWeights(g) {
    let weightMap = g.nodes().map((v) => {
      let sucs = {};
      return g.outEdges(v).forEach((e2) => {
        sucs[e2.w] = (sucs[e2.w] || 0) + g.edge(e2).weight;
      }), sucs;
    });
    return zipObject(g.nodes(), weightMap);
  }
  function predecessorWeights(g) {
    let weightMap = g.nodes().map((v) => {
      let preds = {};
      return g.inEdges(v).forEach((e2) => {
        preds[e2.v] = (preds[e2.v] || 0) + g.edge(e2).weight;
      }), preds;
    });
    return zipObject(g.nodes(), weightMap);
  }
  function intersectRect(rect, point2) {
    let x2 = rect.x, y2 = rect.y, dx = point2.x - x2, dy = point2.y - y2, w = rect.width / 2, h = rect.height / 2;
    if (!dx && !dy)
      throw new Error("Not possible to find intersection inside of the rectangle");
    let sx, sy;
    return Math.abs(dy) * w > Math.abs(dx) * h ? (dy < 0 && (h = -h), sx = h * dx / dy, sy = h) : (dx < 0 && (w = -w), sx = w, sy = w * dy / dx), { x: x2 + sx, y: y2 + sy };
  }
  function buildLayerMatrix(g) {
    let layering = range(maxRank(g) + 1).map(() => []);
    return g.nodes().forEach((v) => {
      let node = g.node(v), rank = node.rank;
      rank !== void 0 && (layering[rank][node.order] = v);
    }), layering;
  }
  function normalizeRanks(g) {
    let nodeRanks = g.nodes().map((v) => {
      let rank = g.node(v).rank;
      return rank === void 0 ? Number.MAX_VALUE : rank;
    }), min2 = applyWithChunking(Math.min, nodeRanks);
    g.nodes().forEach((v) => {
      let node = g.node(v);
      Object.hasOwn(node, "rank") && (node.rank -= min2);
    });
  }
  function removeEmptyRanks(g) {
    let nodeRanks = g.nodes().map((v) => g.node(v).rank), offset2 = applyWithChunking(Math.min, nodeRanks), layers = [];
    g.nodes().forEach((v) => {
      let rank = g.node(v).rank - offset2;
      layers[rank] || (layers[rank] = []), layers[rank].push(v);
    });
    let delta = 0, nodeRankFactor = g.graph().nodeRankFactor;
    Array.from(layers).forEach((vs, i2) => {
      vs === void 0 && i2 % nodeRankFactor !== 0 ? --delta : vs !== void 0 && delta && vs.forEach((v) => g.node(v).rank += delta);
    });
  }
  function addBorderNode(g, prefix2, rank, order) {
    let node = {
      width: 0,
      height: 0
    };
    return arguments.length >= 4 && (node.rank = rank, node.order = order), addDummyNode(g, "border", node, prefix2);
  }
  function splitToChunks(array2, chunkSize = CHUNKING_THRESHOLD) {
    const chunks = [];
    for (let i2 = 0; i2 < array2.length; i2 += chunkSize) {
      const chunk = array2.slice(i2, i2 + chunkSize);
      chunks.push(chunk);
    }
    return chunks;
  }
  const CHUNKING_THRESHOLD = 65535;
  function applyWithChunking(fn, argsArray) {
    if (argsArray.length > CHUNKING_THRESHOLD) {
      const chunks = splitToChunks(argsArray);
      return fn.apply(null, chunks.map((chunk) => fn.apply(null, chunk)));
    } else
      return fn.apply(null, argsArray);
  }
  function maxRank(g) {
    const nodeRanks = g.nodes().map((v) => {
      let rank = g.node(v).rank;
      return rank === void 0 ? Number.MIN_VALUE : rank;
    });
    return applyWithChunking(Math.max, nodeRanks);
  }
  function partition(collection, fn) {
    let result = { lhs: [], rhs: [] };
    return collection.forEach((value) => {
      fn(value) ? result.lhs.push(value) : result.rhs.push(value);
    }), result;
  }
  function time2(name, fn) {
    let start2 = Date.now();
    try {
      return fn();
    } finally {
      console.log(name + " time: " + (Date.now() - start2) + "ms");
    }
  }
  function notime(name, fn) {
    return fn();
  }
  let idCounter2 = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter2;
    return prefix2 + ("" + id2);
  }
  function range(start2, limit, step = 1) {
    limit == null && (limit = start2, start2 = 0);
    let endCon = (i2) => i2 < limit;
    step < 0 && (endCon = (i2) => limit < i2);
    const range2 = [];
    for (let i2 = start2; endCon(i2); i2 += step)
      range2.push(i2);
    return range2;
  }
  function pick2(source, keys2) {
    const dest = {};
    for (const key of keys2)
      source[key] !== void 0 && (dest[key] = source[key]);
    return dest;
  }
  function mapValues2(obj, funcOrProp) {
    let func = funcOrProp;
    return typeof funcOrProp == "string" && (func = (val) => val[funcOrProp]), Object.entries(obj).reduce((acc, [k, v]) => (acc[k] = func(v, k), acc), {});
  }
  function zipObject(props, values2) {
    return props.reduce((acc, key, i2) => (acc[key] = values2[i2], acc), {});
  }
  return util$1;
}
var acyclic, hasRequiredAcyclic;
function requireAcyclic() {
  if (hasRequiredAcyclic) return acyclic;
  hasRequiredAcyclic = 1;
  let greedyFAS = requireGreedyFas(), uniqueId = requireUtil$1().uniqueId;
  acyclic = {
    run,
    undo
  };
  function run(g) {
    (g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g)).forEach((e2) => {
      let label = g.edge(e2);
      g.removeEdge(e2), label.forwardName = e2.name, label.reversed = !0, g.setEdge(e2.w, e2.v, label, uniqueId("rev"));
    });
    function weightFn(g2) {
      return (e2) => g2.edge(e2).weight;
    }
  }
  function dfsFAS(g) {
    let fas = [], stack = {}, visited = {};
    function dfs(v) {
      Object.hasOwn(visited, v) || (visited[v] = !0, stack[v] = !0, g.outEdges(v).forEach((e2) => {
        Object.hasOwn(stack, e2.w) ? fas.push(e2) : dfs(e2.w);
      }), delete stack[v]);
    }
    return g.nodes().forEach(dfs), fas;
  }
  function undo(g) {
    g.edges().forEach((e2) => {
      let label = g.edge(e2);
      if (label.reversed) {
        g.removeEdge(e2);
        let forwardName = label.forwardName;
        delete label.reversed, delete label.forwardName, g.setEdge(e2.w, e2.v, label, forwardName);
      }
    });
  }
  return acyclic;
}
var normalize, hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize) return normalize;
  hasRequiredNormalize = 1;
  let util2 = requireUtil$1();
  normalize = {
    run,
    undo
  };
  function run(g) {
    g.graph().dummyChains = [], g.edges().forEach((edge) => normalizeEdge(g, edge));
  }
  function normalizeEdge(g, e2) {
    let v = e2.v, vRank = g.node(v).rank, w = e2.w, wRank = g.node(w).rank, name = e2.name, edgeLabel = g.edge(e2), labelRank = edgeLabel.labelRank;
    if (wRank === vRank + 1) return;
    g.removeEdge(e2);
    let dummy, attrs, i2;
    for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank)
      edgeLabel.points = [], attrs = {
        width: 0,
        height: 0,
        edgeLabel,
        edgeObj: e2,
        rank: vRank
      }, dummy = util2.addDummyNode(g, "edge", attrs, "_d"), vRank === labelRank && (attrs.width = edgeLabel.width, attrs.height = edgeLabel.height, attrs.dummy = "edge-label", attrs.labelpos = edgeLabel.labelpos), g.setEdge(v, dummy, { weight: edgeLabel.weight }, name), i2 === 0 && g.graph().dummyChains.push(dummy), v = dummy;
    g.setEdge(v, w, { weight: edgeLabel.weight }, name);
  }
  function undo(g) {
    g.graph().dummyChains.forEach((v) => {
      let node = g.node(v), origLabel = node.edgeLabel, w;
      for (g.setEdge(node.edgeObj, origLabel); node.dummy; )
        w = g.successors(v)[0], g.removeNode(v), origLabel.points.push({ x: node.x, y: node.y }), node.dummy === "edge-label" && (origLabel.x = node.x, origLabel.y = node.y, origLabel.width = node.width, origLabel.height = node.height), v = w, node = g.node(v);
    });
  }
  return normalize;
}
var util, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  const { applyWithChunking } = requireUtil$1();
  util = {
    longestPath,
    slack
  };
  function longestPath(g) {
    var visited = {};
    function dfs(v) {
      var label = g.node(v);
      if (Object.hasOwn(visited, v))
        return label.rank;
      visited[v] = !0;
      let outEdgesMinLens = g.outEdges(v).map((e2) => e2 == null ? Number.POSITIVE_INFINITY : dfs(e2.w) - g.edge(e2).minlen);
      var rank = applyWithChunking(Math.min, outEdgesMinLens);
      return rank === Number.POSITIVE_INFINITY && (rank = 0), label.rank = rank;
    }
    g.sources().forEach(dfs);
  }
  function slack(g, e2) {
    return g.node(e2.w).rank - g.node(e2.v).rank - g.edge(e2).minlen;
  }
  return util;
}
var feasibleTree_1, hasRequiredFeasibleTree;
function requireFeasibleTree() {
  if (hasRequiredFeasibleTree) return feasibleTree_1;
  hasRequiredFeasibleTree = 1;
  var Graph = requireGraphlib().Graph, slack = requireUtil().slack;
  feasibleTree_1 = feasibleTree;
  function feasibleTree(g) {
    var t2 = new Graph({ directed: !1 }), start2 = g.nodes()[0], size2 = g.nodeCount();
    t2.setNode(start2, {});
    for (var edge, delta; tightTree(t2, g) < size2; )
      edge = findMinSlackEdge(t2, g), delta = t2.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge), shiftRanks(t2, g, delta);
    return t2;
  }
  function tightTree(t2, g) {
    function dfs(v) {
      g.nodeEdges(v).forEach((e2) => {
        var edgeV = e2.v, w = v === edgeV ? e2.w : edgeV;
        !t2.hasNode(w) && !slack(g, e2) && (t2.setNode(w, {}), t2.setEdge(v, w, {}), dfs(w));
      });
    }
    return t2.nodes().forEach(dfs), t2.nodeCount();
  }
  function findMinSlackEdge(t2, g) {
    return g.edges().reduce((acc, edge) => {
      let edgeSlack = Number.POSITIVE_INFINITY;
      return t2.hasNode(edge.v) !== t2.hasNode(edge.w) && (edgeSlack = slack(g, edge)), edgeSlack < acc[0] ? [edgeSlack, edge] : acc;
    }, [Number.POSITIVE_INFINITY, null])[1];
  }
  function shiftRanks(t2, g, delta) {
    t2.nodes().forEach((v) => g.node(v).rank += delta);
  }
  return feasibleTree_1;
}
var networkSimplex_1, hasRequiredNetworkSimplex;
function requireNetworkSimplex() {
  if (hasRequiredNetworkSimplex) return networkSimplex_1;
  hasRequiredNetworkSimplex = 1;
  var feasibleTree = requireFeasibleTree(), slack = requireUtil().slack, initRank = requireUtil().longestPath, preorder = requireGraphlib().alg.preorder, postorder = requireGraphlib().alg.postorder, simplify = requireUtil$1().simplify;
  networkSimplex_1 = networkSimplex, networkSimplex.initLowLimValues = initLowLimValues, networkSimplex.initCutValues = initCutValues, networkSimplex.calcCutValue = calcCutValue, networkSimplex.leaveEdge = leaveEdge, networkSimplex.enterEdge = enterEdge, networkSimplex.exchangeEdges = exchangeEdges;
  function networkSimplex(g) {
    g = simplify(g), initRank(g);
    var t2 = feasibleTree(g);
    initLowLimValues(t2), initCutValues(t2, g);
    for (var e2, f; e2 = leaveEdge(t2); )
      f = enterEdge(t2, g, e2), exchangeEdges(t2, g, e2, f);
  }
  function initCutValues(t2, g) {
    var vs = postorder(t2, t2.nodes());
    vs = vs.slice(0, vs.length - 1), vs.forEach((v) => assignCutValue(t2, g, v));
  }
  function assignCutValue(t2, g, child) {
    var childLab = t2.node(child), parent = childLab.parent;
    t2.edge(child, parent).cutvalue = calcCutValue(t2, g, child);
  }
  function calcCutValue(t2, g, child) {
    var childLab = t2.node(child), parent = childLab.parent, childIsTail = !0, graphEdge = g.edge(child, parent), cutValue = 0;
    return graphEdge || (childIsTail = !1, graphEdge = g.edge(parent, child)), cutValue = graphEdge.weight, g.nodeEdges(child).forEach((e2) => {
      var isOutEdge = e2.v === child, other = isOutEdge ? e2.w : e2.v;
      if (other !== parent) {
        var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e2).weight;
        if (cutValue += pointsToHead ? otherWeight : -otherWeight, isTreeEdge(t2, child, other)) {
          var otherCutValue = t2.edge(child, other).cutvalue;
          cutValue += pointsToHead ? -otherCutValue : otherCutValue;
        }
      }
    }), cutValue;
  }
  function initLowLimValues(tree, root2) {
    arguments.length < 2 && (root2 = tree.nodes()[0]), dfsAssignLowLim(tree, {}, 1, root2);
  }
  function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
    var low = nextLim, label = tree.node(v);
    return visited[v] = !0, tree.neighbors(v).forEach((w) => {
      Object.hasOwn(visited, w) || (nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v));
    }), label.low = low, label.lim = nextLim++, parent ? label.parent = parent : delete label.parent, nextLim;
  }
  function leaveEdge(tree) {
    return tree.edges().find((e2) => tree.edge(e2).cutvalue < 0);
  }
  function enterEdge(t2, g, edge) {
    var v = edge.v, w = edge.w;
    g.hasEdge(v, w) || (v = edge.w, w = edge.v);
    var vLabel = t2.node(v), wLabel = t2.node(w), tailLabel = vLabel, flip2 = !1;
    vLabel.lim > wLabel.lim && (tailLabel = wLabel, flip2 = !0);
    var candidates = g.edges().filter((edge2) => flip2 === isDescendant2(t2, t2.node(edge2.v), tailLabel) && flip2 !== isDescendant2(t2, t2.node(edge2.w), tailLabel));
    return candidates.reduce((acc, edge2) => slack(g, edge2) < slack(g, acc) ? edge2 : acc);
  }
  function exchangeEdges(t2, g, e2, f) {
    var v = e2.v, w = e2.w;
    t2.removeEdge(v, w), t2.setEdge(f.v, f.w, {}), initLowLimValues(t2), initCutValues(t2, g), updateRanks(t2, g);
  }
  function updateRanks(t2, g) {
    var root2 = t2.nodes().find((v) => !g.node(v).parent), vs = preorder(t2, root2);
    vs = vs.slice(1), vs.forEach((v) => {
      var parent = t2.node(v).parent, edge = g.edge(v, parent), flipped = !1;
      edge || (edge = g.edge(parent, v), flipped = !0), g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
    });
  }
  function isTreeEdge(tree, u, v) {
    return tree.hasEdge(u, v);
  }
  function isDescendant2(tree, vLabel, rootLabel) {
    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
  }
  return networkSimplex_1;
}
var rank_1, hasRequiredRank;
function requireRank() {
  if (hasRequiredRank) return rank_1;
  hasRequiredRank = 1;
  var rankUtil = requireUtil(), longestPath = rankUtil.longestPath, feasibleTree = requireFeasibleTree(), networkSimplex = requireNetworkSimplex();
  rank_1 = rank;
  function rank(g) {
    var ranker = g.graph().ranker;
    if (ranker instanceof Function)
      return ranker(g);
    switch (g.graph().ranker) {
      case "network-simplex":
        networkSimplexRanker(g);
        break;
      case "tight-tree":
        tightTreeRanker(g);
        break;
      case "longest-path":
        longestPathRanker(g);
        break;
      case "none":
        break;
      default:
        networkSimplexRanker(g);
    }
  }
  var longestPathRanker = longestPath;
  function tightTreeRanker(g) {
    longestPath(g), feasibleTree(g);
  }
  function networkSimplexRanker(g) {
    networkSimplex(g);
  }
  return rank_1;
}
var parentDummyChains_1, hasRequiredParentDummyChains;
function requireParentDummyChains() {
  if (hasRequiredParentDummyChains) return parentDummyChains_1;
  hasRequiredParentDummyChains = 1, parentDummyChains_1 = parentDummyChains;
  function parentDummyChains(g) {
    let postorderNums = postorder(g);
    g.graph().dummyChains.forEach((v) => {
      let node = g.node(v), edgeObj = node.edgeObj, pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w), path = pathData.path, lca = pathData.lca, pathIdx = 0, pathV = path[pathIdx], ascending2 = !0;
      for (; v !== edgeObj.w; ) {
        if (node = g.node(v), ascending2) {
          for (; (pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank; )
            pathIdx++;
          pathV === lca && (ascending2 = !1);
        }
        if (!ascending2) {
          for (; pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank; )
            pathIdx++;
          pathV = path[pathIdx];
        }
        g.setParent(v, pathV), v = g.successors(v)[0];
      }
    });
  }
  function findPath(g, postorderNums, v, w) {
    let vPath = [], wPath = [], low = Math.min(postorderNums[v].low, postorderNums[w].low), lim = Math.max(postorderNums[v].lim, postorderNums[w].lim), parent, lca;
    parent = v;
    do
      parent = g.parent(parent), vPath.push(parent);
    while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    for (lca = parent, parent = w; (parent = g.parent(parent)) !== lca; )
      wPath.push(parent);
    return { path: vPath.concat(wPath.reverse()), lca };
  }
  function postorder(g) {
    let result = {}, lim = 0;
    function dfs(v) {
      let low = lim;
      g.children(v).forEach(dfs), result[v] = { low, lim: lim++ };
    }
    return g.children().forEach(dfs), result;
  }
  return parentDummyChains_1;
}
var nestingGraph, hasRequiredNestingGraph;
function requireNestingGraph() {
  if (hasRequiredNestingGraph) return nestingGraph;
  hasRequiredNestingGraph = 1;
  let util2 = requireUtil$1();
  nestingGraph = {
    run,
    cleanup
  };
  function run(g) {
    let root2 = util2.addDummyNode(g, "root", {}, "_root"), depths = treeDepths(g), depthsArr = Object.values(depths), height = util2.applyWithChunking(Math.max, depthsArr) - 1, nodeSep = 2 * height + 1;
    g.graph().nestingRoot = root2, g.edges().forEach((e2) => g.edge(e2).minlen *= nodeSep);
    let weight = sumWeights(g) + 1;
    g.children().forEach((child) => dfs(g, root2, nodeSep, weight, height, depths, child)), g.graph().nodeRankFactor = nodeSep;
  }
  function dfs(g, root2, nodeSep, weight, height, depths, v) {
    let children2 = g.children(v);
    if (!children2.length) {
      v !== root2 && g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
      return;
    }
    let top = util2.addBorderNode(g, "_bt"), bottom = util2.addBorderNode(g, "_bb"), label = g.node(v);
    g.setParent(top, v), label.borderTop = top, g.setParent(bottom, v), label.borderBottom = bottom, children2.forEach((child) => {
      dfs(g, root2, nodeSep, weight, height, depths, child);
      let childNode = g.node(child), childTop = childNode.borderTop ? childNode.borderTop : child, childBottom = childNode.borderBottom ? childNode.borderBottom : child, thisWeight = childNode.borderTop ? weight : 2 * weight, minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
      g.setEdge(top, childTop, {
        weight: thisWeight,
        minlen,
        nestingEdge: !0
      }), g.setEdge(childBottom, bottom, {
        weight: thisWeight,
        minlen,
        nestingEdge: !0
      });
    }), g.parent(v) || g.setEdge(root2, top, { weight: 0, minlen: height + depths[v] });
  }
  function treeDepths(g) {
    var depths = {};
    function dfs2(v, depth) {
      var children2 = g.children(v);
      children2 && children2.length && children2.forEach((child) => dfs2(child, depth + 1)), depths[v] = depth;
    }
    return g.children().forEach((v) => dfs2(v, 1)), depths;
  }
  function sumWeights(g) {
    return g.edges().reduce((acc, e2) => acc + g.edge(e2).weight, 0);
  }
  function cleanup(g) {
    var graphLabel = g.graph();
    g.removeNode(graphLabel.nestingRoot), delete graphLabel.nestingRoot, g.edges().forEach((e2) => {
      var edge = g.edge(e2);
      edge.nestingEdge && g.removeEdge(e2);
    });
  }
  return nestingGraph;
}
var addBorderSegments_1, hasRequiredAddBorderSegments;
function requireAddBorderSegments() {
  if (hasRequiredAddBorderSegments) return addBorderSegments_1;
  hasRequiredAddBorderSegments = 1;
  let util2 = requireUtil$1();
  addBorderSegments_1 = addBorderSegments;
  function addBorderSegments(g) {
    function dfs(v) {
      let children2 = g.children(v), node = g.node(v);
      if (children2.length && children2.forEach(dfs), Object.hasOwn(node, "minRank")) {
        node.borderLeft = [], node.borderRight = [];
        for (let rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank)
          addBorderNode(g, "borderLeft", "_bl", v, node, rank), addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
    g.children().forEach(dfs);
  }
  function addBorderNode(g, prop, prefix2, sg, sgNode, rank) {
    let label = { width: 0, height: 0, rank, borderType: prop }, prev = sgNode[prop][rank - 1], curr = util2.addDummyNode(g, "border", label, prefix2);
    sgNode[prop][rank] = curr, g.setParent(curr, sg), prev && g.setEdge(prev, curr, { weight: 1 });
  }
  return addBorderSegments_1;
}
var coordinateSystem, hasRequiredCoordinateSystem;
function requireCoordinateSystem() {
  if (hasRequiredCoordinateSystem) return coordinateSystem;
  hasRequiredCoordinateSystem = 1, coordinateSystem = {
    adjust: adjust2,
    undo
  };
  function adjust2(g) {
    let rankDir = g.graph().rankdir.toLowerCase();
    (rankDir === "lr" || rankDir === "rl") && swapWidthHeight(g);
  }
  function undo(g) {
    let rankDir = g.graph().rankdir.toLowerCase();
    (rankDir === "bt" || rankDir === "rl") && reverseY(g), (rankDir === "lr" || rankDir === "rl") && (swapXY(g), swapWidthHeight(g));
  }
  function swapWidthHeight(g) {
    g.nodes().forEach((v) => swapWidthHeightOne(g.node(v))), g.edges().forEach((e2) => swapWidthHeightOne(g.edge(e2)));
  }
  function swapWidthHeightOne(attrs) {
    let w = attrs.width;
    attrs.width = attrs.height, attrs.height = w;
  }
  function reverseY(g) {
    g.nodes().forEach((v) => reverseYOne(g.node(v))), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.points.forEach(reverseYOne), Object.hasOwn(edge, "y") && reverseYOne(edge);
    });
  }
  function reverseYOne(attrs) {
    attrs.y = -attrs.y;
  }
  function swapXY(g) {
    g.nodes().forEach((v) => swapXYOne(g.node(v))), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.points.forEach(swapXYOne), Object.hasOwn(edge, "x") && swapXYOne(edge);
    });
  }
  function swapXYOne(attrs) {
    let x2 = attrs.x;
    attrs.x = attrs.y, attrs.y = x2;
  }
  return coordinateSystem;
}
var initOrder_1, hasRequiredInitOrder;
function requireInitOrder() {
  if (hasRequiredInitOrder) return initOrder_1;
  hasRequiredInitOrder = 1;
  let util2 = requireUtil$1();
  initOrder_1 = initOrder;
  function initOrder(g) {
    let visited = {}, simpleNodes = g.nodes().filter((v) => !g.children(v).length), simpleNodesRanks = simpleNodes.map((v) => g.node(v).rank), maxRank = util2.applyWithChunking(Math.max, simpleNodesRanks), layers = util2.range(maxRank + 1).map(() => []);
    function dfs(v) {
      if (visited[v]) return;
      visited[v] = !0;
      let node = g.node(v);
      layers[node.rank].push(v), g.successors(v).forEach(dfs);
    }
    return simpleNodes.sort((a2, b) => g.node(a2).rank - g.node(b).rank).forEach(dfs), layers;
  }
  return initOrder_1;
}
var crossCount_1, hasRequiredCrossCount;
function requireCrossCount() {
  if (hasRequiredCrossCount) return crossCount_1;
  hasRequiredCrossCount = 1;
  let zipObject = requireUtil$1().zipObject;
  crossCount_1 = crossCount;
  function crossCount(g, layering) {
    let cc2 = 0;
    for (let i2 = 1; i2 < layering.length; ++i2)
      cc2 += twoLayerCrossCount(g, layering[i2 - 1], layering[i2]);
    return cc2;
  }
  function twoLayerCrossCount(g, northLayer, southLayer) {
    let southPos = zipObject(southLayer, southLayer.map((v, i2) => i2)), southEntries = northLayer.flatMap((v) => g.outEdges(v).map((e2) => ({ pos: southPos[e2.w], weight: g.edge(e2).weight })).sort((a2, b) => a2.pos - b.pos)), firstIndex = 1;
    for (; firstIndex < southLayer.length; ) firstIndex <<= 1;
    let treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    let tree = new Array(treeSize).fill(0), cc2 = 0;
    return southEntries.forEach((entry) => {
      let index2 = entry.pos + firstIndex;
      tree[index2] += entry.weight;
      let weightSum = 0;
      for (; index2 > 0; )
        index2 % 2 && (weightSum += tree[index2 + 1]), index2 = index2 - 1 >> 1, tree[index2] += entry.weight;
      cc2 += entry.weight * weightSum;
    }), cc2;
  }
  return crossCount_1;
}
var barycenter_1, hasRequiredBarycenter;
function requireBarycenter() {
  if (hasRequiredBarycenter) return barycenter_1;
  hasRequiredBarycenter = 1, barycenter_1 = barycenter;
  function barycenter(g, movable = []) {
    return movable.map((v) => {
      let inV = g.inEdges(v);
      if (inV.length) {
        let result = inV.reduce((acc, e2) => {
          let edge = g.edge(e2), nodeU = g.node(e2.v);
          return {
            sum: acc.sum + edge.weight * nodeU.order,
            weight: acc.weight + edge.weight
          };
        }, { sum: 0, weight: 0 });
        return {
          v,
          barycenter: result.sum / result.weight,
          weight: result.weight
        };
      } else
        return { v };
    });
  }
  return barycenter_1;
}
var resolveConflicts_1, hasRequiredResolveConflicts;
function requireResolveConflicts() {
  if (hasRequiredResolveConflicts) return resolveConflicts_1;
  hasRequiredResolveConflicts = 1;
  let util2 = requireUtil$1();
  resolveConflicts_1 = resolveConflicts;
  function resolveConflicts(entries, cg) {
    let mappedEntries = {};
    entries.forEach((entry, i2) => {
      let tmp = mappedEntries[entry.v] = {
        indegree: 0,
        in: [],
        out: [],
        vs: [entry.v],
        i: i2
      };
      entry.barycenter !== void 0 && (tmp.barycenter = entry.barycenter, tmp.weight = entry.weight);
    }), cg.edges().forEach((e2) => {
      let entryV = mappedEntries[e2.v], entryW = mappedEntries[e2.w];
      entryV !== void 0 && entryW !== void 0 && (entryW.indegree++, entryV.out.push(mappedEntries[e2.w]));
    });
    let sourceSet = Object.values(mappedEntries).filter((entry) => !entry.indegree);
    return doResolveConflicts(sourceSet);
  }
  function doResolveConflicts(sourceSet) {
    let entries = [];
    function handleIn(vEntry) {
      return (uEntry) => {
        uEntry.merged || (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) && mergeEntries(vEntry, uEntry);
      };
    }
    function handleOut(vEntry) {
      return (wEntry) => {
        wEntry.in.push(vEntry), --wEntry.indegree === 0 && sourceSet.push(wEntry);
      };
    }
    for (; sourceSet.length; ) {
      let entry = sourceSet.pop();
      entries.push(entry), entry.in.reverse().forEach(handleIn(entry)), entry.out.forEach(handleOut(entry));
    }
    return entries.filter((entry) => !entry.merged).map((entry) => util2.pick(entry, ["vs", "i", "barycenter", "weight"]));
  }
  function mergeEntries(target, source) {
    let sum = 0, weight = 0;
    target.weight && (sum += target.barycenter * target.weight, weight += target.weight), source.weight && (sum += source.barycenter * source.weight, weight += source.weight), target.vs = source.vs.concat(target.vs), target.barycenter = sum / weight, target.weight = weight, target.i = Math.min(source.i, target.i), source.merged = !0;
  }
  return resolveConflicts_1;
}
var sort_1, hasRequiredSort;
function requireSort() {
  if (hasRequiredSort) return sort_1;
  hasRequiredSort = 1;
  let util2 = requireUtil$1();
  sort_1 = sort;
  function sort(entries, biasRight) {
    let parts = util2.partition(entries, (entry) => Object.hasOwn(entry, "barycenter")), sortable = parts.lhs, unsortable = parts.rhs.sort((a2, b) => b.i - a2.i), vs = [], sum = 0, weight = 0, vsIndex = 0;
    sortable.sort(compareWithBias(!!biasRight)), vsIndex = consumeUnsortable(vs, unsortable, vsIndex), sortable.forEach((entry) => {
      vsIndex += entry.vs.length, vs.push(entry.vs), sum += entry.barycenter * entry.weight, weight += entry.weight, vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    let result = { vs: vs.flat(!0) };
    return weight && (result.barycenter = sum / weight, result.weight = weight), result;
  }
  function consumeUnsortable(vs, unsortable, index2) {
    let last2;
    for (; unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= index2; )
      unsortable.pop(), vs.push(last2.vs), index2++;
    return index2;
  }
  function compareWithBias(bias) {
    return (entryV, entryW) => entryV.barycenter < entryW.barycenter ? -1 : entryV.barycenter > entryW.barycenter ? 1 : bias ? entryW.i - entryV.i : entryV.i - entryW.i;
  }
  return sort_1;
}
var sortSubgraph_1, hasRequiredSortSubgraph;
function requireSortSubgraph() {
  if (hasRequiredSortSubgraph) return sortSubgraph_1;
  hasRequiredSortSubgraph = 1;
  let barycenter = requireBarycenter(), resolveConflicts = requireResolveConflicts(), sort = requireSort();
  sortSubgraph_1 = sortSubgraph;
  function sortSubgraph(g, v, cg, biasRight) {
    let movable = g.children(v), node = g.node(v), bl = node ? node.borderLeft : void 0, br = node ? node.borderRight : void 0, subgraphs = {};
    bl && (movable = movable.filter((w) => w !== bl && w !== br));
    let barycenters = barycenter(g, movable);
    barycenters.forEach((entry) => {
      if (g.children(entry.v).length) {
        let subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
        subgraphs[entry.v] = subgraphResult, Object.hasOwn(subgraphResult, "barycenter") && mergeBarycenters(entry, subgraphResult);
      }
    });
    let entries = resolveConflicts(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    let result = sort(entries, biasRight);
    if (bl && (result.vs = [bl, result.vs, br].flat(!0), g.predecessors(bl).length)) {
      let blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
      Object.hasOwn(result, "barycenter") || (result.barycenter = 0, result.weight = 0), result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2), result.weight += 2;
    }
    return result;
  }
  function expandSubgraphs(entries, subgraphs) {
    entries.forEach((entry) => {
      entry.vs = entry.vs.flatMap((v) => subgraphs[v] ? subgraphs[v].vs : v);
    });
  }
  function mergeBarycenters(target, other) {
    target.barycenter !== void 0 ? (target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight), target.weight += other.weight) : (target.barycenter = other.barycenter, target.weight = other.weight);
  }
  return sortSubgraph_1;
}
var buildLayerGraph_1, hasRequiredBuildLayerGraph;
function requireBuildLayerGraph() {
  if (hasRequiredBuildLayerGraph) return buildLayerGraph_1;
  hasRequiredBuildLayerGraph = 1;
  let Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  buildLayerGraph_1 = buildLayerGraph;
  function buildLayerGraph(g, rank, relationship, nodesWithRank) {
    nodesWithRank || (nodesWithRank = g.nodes());
    let root2 = createRootNode(g), result = new Graph({ compound: !0 }).setGraph({ root: root2 }).setDefaultNodeLabel((v) => g.node(v));
    return nodesWithRank.forEach((v) => {
      let node = g.node(v), parent = g.parent(v);
      (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) && (result.setNode(v), result.setParent(v, parent || root2), g[relationship](v).forEach((e2) => {
        let u = e2.v === v ? e2.w : e2.v, edge = result.edge(u, v), weight = edge !== void 0 ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e2).weight + weight });
      }), Object.hasOwn(node, "minRank") && result.setNode(v, {
        borderLeft: node.borderLeft[rank],
        borderRight: node.borderRight[rank]
      }));
    }), result;
  }
  function createRootNode(g) {
    for (var v; g.hasNode(v = util2.uniqueId("_root")); ) ;
    return v;
  }
  return buildLayerGraph_1;
}
var addSubgraphConstraints_1, hasRequiredAddSubgraphConstraints;
function requireAddSubgraphConstraints() {
  if (hasRequiredAddSubgraphConstraints) return addSubgraphConstraints_1;
  hasRequiredAddSubgraphConstraints = 1, addSubgraphConstraints_1 = addSubgraphConstraints;
  function addSubgraphConstraints(g, cg, vs) {
    let prev = {}, rootPrev;
    vs.forEach((v) => {
      let child = g.parent(v), parent, prevChild;
      for (; child; ) {
        if (parent = g.parent(child), parent ? (prevChild = prev[parent], prev[parent] = child) : (prevChild = rootPrev, rootPrev = child), prevChild && prevChild !== child) {
          cg.setEdge(prevChild, child);
          return;
        }
        child = parent;
      }
    });
  }
  return addSubgraphConstraints_1;
}
var order_1, hasRequiredOrder;
function requireOrder() {
  if (hasRequiredOrder) return order_1;
  hasRequiredOrder = 1;
  let initOrder = requireInitOrder(), crossCount = requireCrossCount(), sortSubgraph = requireSortSubgraph(), buildLayerGraph = requireBuildLayerGraph(), addSubgraphConstraints = requireAddSubgraphConstraints(), Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  order_1 = order;
  function order(g, opts) {
    if (opts && typeof opts.customOrder == "function") {
      opts.customOrder(g, order);
      return;
    }
    let maxRank = util2.maxRank(g), downLayerGraphs = buildLayerGraphs(g, util2.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, util2.range(maxRank - 1, -1, -1), "outEdges"), layering = initOrder(g);
    if (assignOrder(g, layering), opts && opts.disableOptimalOrderHeuristic)
      return;
    let bestCC = Number.POSITIVE_INFINITY, best;
    for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
      sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2), layering = util2.buildLayerMatrix(g);
      let cc2 = crossCount(g, layering);
      cc2 < bestCC && (lastBest = 0, best = Object.assign({}, layering), bestCC = cc2);
    }
    assignOrder(g, best);
  }
  function buildLayerGraphs(g, ranks, relationship) {
    const nodesByRank = /* @__PURE__ */ new Map(), addNodeToRank = (rank, node) => {
      nodesByRank.has(rank) || nodesByRank.set(rank, []), nodesByRank.get(rank).push(node);
    };
    for (const v of g.nodes()) {
      const node = g.node(v);
      if (typeof node.rank == "number" && addNodeToRank(node.rank, v), typeof node.minRank == "number" && typeof node.maxRank == "number")
        for (let r2 = node.minRank; r2 <= node.maxRank; r2++)
          r2 !== node.rank && addNodeToRank(r2, v);
    }
    return ranks.map(function(rank) {
      return buildLayerGraph(g, rank, relationship, nodesByRank.get(rank) || []);
    });
  }
  function sweepLayerGraphs(layerGraphs, biasRight) {
    let cg = new Graph();
    layerGraphs.forEach(function(lg) {
      let root2 = lg.graph().root, sorted = sortSubgraph(lg, root2, cg, biasRight);
      sorted.vs.forEach((v, i2) => lg.node(v).order = i2), addSubgraphConstraints(lg, cg, sorted.vs);
    });
  }
  function assignOrder(g, layering) {
    Object.values(layering).forEach((layer) => layer.forEach((v, i2) => g.node(v).order = i2));
  }
  return order_1;
}
var bk, hasRequiredBk;
function requireBk() {
  if (hasRequiredBk) return bk;
  hasRequiredBk = 1;
  let Graph = requireGraphlib().Graph, util2 = requireUtil$1();
  bk = {
    positionX,
    findType1Conflicts,
    findType2Conflicts,
    addConflict,
    hasConflict,
    verticalAlignment,
    horizontalCompaction,
    alignCoordinates,
    findSmallestWidthAlignment,
    balance
  };
  function findType1Conflicts(g, layering) {
    let conflicts = {};
    function visitLayer(prevLayer, layer) {
      let k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = layer[layer.length - 1];
      return layer.forEach((v, i2) => {
        let w = findOtherInnerSegmentNode(g, v), k1 = w ? g.node(w).order : prevLayerLength;
        (w || v === lastNode) && (layer.slice(scanPos, i2 + 1).forEach((scanNode) => {
          g.predecessors(scanNode).forEach((u) => {
            let uLabel = g.node(u), uPos = uLabel.order;
            (uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy) && addConflict(conflicts, u, scanNode);
          });
        }), scanPos = i2 + 1, k0 = k1);
      }), layer;
    }
    return layering.length && layering.reduce(visitLayer), conflicts;
  }
  function findType2Conflicts(g, layering) {
    let conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
      let v;
      util2.range(southPos, southEnd).forEach((i2) => {
        v = south[i2], g.node(v).dummy && g.predecessors(v).forEach((u) => {
          let uNode = g.node(u);
          uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder) && addConflict(conflicts, u, v);
        });
      });
    }
    function visitLayer(north, south) {
      let prevNorthPos = -1, nextNorthPos, southPos = 0;
      return south.forEach((v, southLookahead) => {
        if (g.node(v).dummy === "border") {
          let predecessors = g.predecessors(v);
          predecessors.length && (nextNorthPos = g.node(predecessors[0]).order, scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos), southPos = southLookahead, prevNorthPos = nextNorthPos);
        }
        scan(south, southPos, south.length, nextNorthPos, north.length);
      }), south;
    }
    return layering.length && layering.reduce(visitLayer), conflicts;
  }
  function findOtherInnerSegmentNode(g, v) {
    if (g.node(v).dummy)
      return g.predecessors(v).find((u) => g.node(u).dummy);
  }
  function addConflict(conflicts, v, w) {
    if (v > w) {
      let tmp = v;
      v = w, w = tmp;
    }
    let conflictsV = conflicts[v];
    conflictsV || (conflicts[v] = conflictsV = {}), conflictsV[w] = !0;
  }
  function hasConflict(conflicts, v, w) {
    if (v > w) {
      let tmp = v;
      v = w, w = tmp;
    }
    return !!conflicts[v] && Object.hasOwn(conflicts[v], w);
  }
  function verticalAlignment(g, layering, conflicts, neighborFn) {
    let root2 = {}, align = {}, pos = {};
    return layering.forEach((layer) => {
      layer.forEach((v, order) => {
        root2[v] = v, align[v] = v, pos[v] = order;
      });
    }), layering.forEach((layer) => {
      let prevIdx = -1;
      layer.forEach((v) => {
        let ws = neighborFn(v);
        if (ws.length) {
          ws = ws.sort((a2, b) => pos[a2] - pos[b]);
          let mp = (ws.length - 1) / 2;
          for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
            let w = ws[i2];
            align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w) && (align[w] = v, align[v] = root2[v] = root2[w], prevIdx = pos[w]);
          }
        }
      });
    }), { root: root2, align };
  }
  function horizontalCompaction(g, layering, root2, align, reverseSep) {
    let xs = {}, blockG = buildBlockGraph(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
    function iterate(setXsFunc, nextNodesFunc) {
      let stack = blockG.nodes(), elem = stack.pop(), visited = {};
      for (; elem; )
        visited[elem] ? setXsFunc(elem) : (visited[elem] = !0, stack.push(elem), stack = stack.concat(nextNodesFunc(elem))), elem = stack.pop();
    }
    function pass1(elem) {
      xs[elem] = blockG.inEdges(elem).reduce((acc, e2) => Math.max(acc, xs[e2.v] + blockG.edge(e2)), 0);
    }
    function pass2(elem) {
      let min2 = blockG.outEdges(elem).reduce((acc, e2) => Math.min(acc, xs[e2.w] - blockG.edge(e2)), Number.POSITIVE_INFINITY), node = g.node(elem);
      min2 !== Number.POSITIVE_INFINITY && node.borderType !== borderType && (xs[elem] = Math.max(xs[elem], min2));
    }
    return iterate(pass1, blockG.predecessors.bind(blockG)), iterate(pass2, blockG.successors.bind(blockG)), Object.keys(align).forEach((v) => xs[v] = xs[root2[v]]), xs;
  }
  function buildBlockGraph(g, layering, root2, reverseSep) {
    let blockGraph = new Graph(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
    return layering.forEach((layer) => {
      let u;
      layer.forEach((v) => {
        let vRoot = root2[v];
        if (blockGraph.setNode(vRoot), u) {
          var uRoot = root2[u], prevMax = blockGraph.edge(uRoot, vRoot);
          blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
        }
        u = v;
      });
    }), blockGraph;
  }
  function findSmallestWidthAlignment(g, xss) {
    return Object.values(xss).reduce((currentMinAndXs, xs) => {
      let max2 = Number.NEGATIVE_INFINITY, min2 = Number.POSITIVE_INFINITY;
      Object.entries(xs).forEach(([v, x2]) => {
        let halfWidth = width(g, v) / 2;
        max2 = Math.max(x2 + halfWidth, max2), min2 = Math.min(x2 - halfWidth, min2);
      });
      const newMin = max2 - min2;
      return newMin < currentMinAndXs[0] && (currentMinAndXs = [newMin, xs]), currentMinAndXs;
    }, [Number.POSITIVE_INFINITY, null])[1];
  }
  function alignCoordinates(xss, alignTo) {
    let alignToVals = Object.values(alignTo), alignToMin = util2.applyWithChunking(Math.min, alignToVals), alignToMax = util2.applyWithChunking(Math.max, alignToVals);
    ["u", "d"].forEach((vert) => {
      ["l", "r"].forEach((horiz) => {
        let alignment = vert + horiz, xs = xss[alignment];
        if (xs === alignTo) return;
        let xsVals = Object.values(xs), delta = alignToMin - util2.applyWithChunking(Math.min, xsVals);
        horiz !== "l" && (delta = alignToMax - util2.applyWithChunking(Math.max, xsVals)), delta && (xss[alignment] = util2.mapValues(xs, (x2) => x2 + delta));
      });
    });
  }
  function balance(xss, align) {
    return util2.mapValues(xss.ul, (num, v) => {
      if (align)
        return xss[align.toLowerCase()][v];
      {
        let xs = Object.values(xss).map((xs2) => xs2[v]).sort((a2, b) => a2 - b);
        return (xs[1] + xs[2]) / 2;
      }
    });
  }
  function positionX(g) {
    let layering = util2.buildLayerMatrix(g), conflicts = Object.assign(
      findType1Conflicts(g, layering),
      findType2Conflicts(g, layering)
    ), xss = {}, adjustedLayering;
    ["u", "d"].forEach((vert) => {
      adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse(), ["l", "r"].forEach((horiz) => {
        horiz === "r" && (adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse()));
        let neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g), align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn), xs = horizontalCompaction(
          g,
          adjustedLayering,
          align.root,
          align.align,
          horiz === "r"
        );
        horiz === "r" && (xs = util2.mapValues(xs, (x2) => -x2)), xss[vert + horiz] = xs;
      });
    });
    let smallestWidth = findSmallestWidthAlignment(g, xss);
    return alignCoordinates(xss, smallestWidth), balance(xss, g.graph().align);
  }
  function sep(nodeSep, edgeSep, reverseSep) {
    return (g, v, w) => {
      let vLabel = g.node(v), wLabel = g.node(w), sum = 0, delta;
      if (sum += vLabel.width / 2, Object.hasOwn(vLabel, "labelpos"))
        switch (vLabel.labelpos.toLowerCase()) {
          case "l":
            delta = -vLabel.width / 2;
            break;
          case "r":
            delta = vLabel.width / 2;
            break;
        }
      if (delta && (sum += reverseSep ? delta : -delta), delta = 0, sum += (vLabel.dummy ? edgeSep : nodeSep) / 2, sum += (wLabel.dummy ? edgeSep : nodeSep) / 2, sum += wLabel.width / 2, Object.hasOwn(wLabel, "labelpos"))
        switch (wLabel.labelpos.toLowerCase()) {
          case "l":
            delta = wLabel.width / 2;
            break;
          case "r":
            delta = -wLabel.width / 2;
            break;
        }
      return delta && (sum += reverseSep ? delta : -delta), delta = 0, sum;
    };
  }
  function width(g, v) {
    return g.node(v).width;
  }
  return bk;
}
var position_1, hasRequiredPosition;
function requirePosition() {
  if (hasRequiredPosition) return position_1;
  hasRequiredPosition = 1;
  let util2 = requireUtil$1(), positionX = requireBk().positionX;
  position_1 = position;
  function position(g) {
    g = util2.asNonCompoundGraph(g), positionY(g), Object.entries(positionX(g)).forEach(([v, x2]) => g.node(v).x = x2);
  }
  function positionY(g) {
    let layering = util2.buildLayerMatrix(g), rankSep = g.graph().ranksep, prevY = 0;
    layering.forEach((layer) => {
      const maxHeight = layer.reduce((acc, v) => {
        const height = g.node(v).height;
        return acc > height ? acc : height;
      }, 0);
      layer.forEach((v) => g.node(v).y = prevY + maxHeight / 2), prevY += maxHeight + rankSep;
    });
  }
  return position_1;
}
var layout_1, hasRequiredLayout;
function requireLayout() {
  if (hasRequiredLayout) return layout_1;
  hasRequiredLayout = 1;
  let acyclic2 = requireAcyclic(), normalize2 = requireNormalize(), rank = requireRank(), normalizeRanks = requireUtil$1().normalizeRanks, parentDummyChains = requireParentDummyChains(), removeEmptyRanks = requireUtil$1().removeEmptyRanks, nestingGraph2 = requireNestingGraph(), addBorderSegments = requireAddBorderSegments(), coordinateSystem2 = requireCoordinateSystem(), order = requireOrder(), position = requirePosition(), util2 = requireUtil$1(), Graph = requireGraphlib().Graph;
  layout_1 = layout2;
  function layout2(g, opts) {
    let time2 = opts && opts.debugTiming ? util2.time : util2.notime;
    time2("layout", () => {
      let layoutGraph = time2("  buildLayoutGraph", () => buildLayoutGraph(g));
      time2("  runLayout", () => runLayout(layoutGraph, time2, opts)), time2("  updateInputGraph", () => updateInputGraph(g, layoutGraph));
    });
  }
  function runLayout(g, time2, opts) {
    time2("    makeSpaceForEdgeLabels", () => makeSpaceForEdgeLabels(g)), time2("    removeSelfEdges", () => removeSelfEdges(g)), time2("    acyclic", () => acyclic2.run(g)), time2("    nestingGraph.run", () => nestingGraph2.run(g)), time2("    rank", () => rank(util2.asNonCompoundGraph(g))), time2("    injectEdgeLabelProxies", () => injectEdgeLabelProxies(g)), time2("    removeEmptyRanks", () => removeEmptyRanks(g)), time2("    nestingGraph.cleanup", () => nestingGraph2.cleanup(g)), time2("    normalizeRanks", () => normalizeRanks(g)), time2("    assignRankMinMax", () => assignRankMinMax(g)), time2("    removeEdgeLabelProxies", () => removeEdgeLabelProxies(g)), time2("    normalize.run", () => normalize2.run(g)), time2("    parentDummyChains", () => parentDummyChains(g)), time2("    addBorderSegments", () => addBorderSegments(g)), time2("    order", () => order(g, opts)), time2("    insertSelfEdges", () => insertSelfEdges(g)), time2("    adjustCoordinateSystem", () => coordinateSystem2.adjust(g)), time2("    position", () => position(g)), time2("    positionSelfEdges", () => positionSelfEdges(g)), time2("    removeBorderNodes", () => removeBorderNodes(g)), time2("    normalize.undo", () => normalize2.undo(g)), time2("    fixupEdgeLabelCoords", () => fixupEdgeLabelCoords(g)), time2("    undoCoordinateSystem", () => coordinateSystem2.undo(g)), time2("    translateGraph", () => translateGraph(g)), time2("    assignNodeIntersects", () => assignNodeIntersects(g)), time2("    reversePoints", () => reversePointsForReversedEdges(g)), time2("    acyclic.undo", () => acyclic2.undo(g));
  }
  function updateInputGraph(inputGraph, layoutGraph) {
    inputGraph.nodes().forEach((v) => {
      let inputLabel = inputGraph.node(v), layoutLabel = layoutGraph.node(v);
      inputLabel && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y, inputLabel.rank = layoutLabel.rank, layoutGraph.children(v).length && (inputLabel.width = layoutLabel.width, inputLabel.height = layoutLabel.height));
    }), inputGraph.edges().forEach((e2) => {
      let inputLabel = inputGraph.edge(e2), layoutLabel = layoutGraph.edge(e2);
      inputLabel.points = layoutLabel.points, Object.hasOwn(layoutLabel, "x") && (inputLabel.x = layoutLabel.x, inputLabel.y = layoutLabel.y);
    }), inputGraph.graph().width = layoutGraph.graph().width, inputGraph.graph().height = layoutGraph.graph().height;
  }
  let graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, graphAttrs = ["acyclicer", "ranker", "rankdir", "align"], nodeNumAttrs = ["width", "height", "rank"], nodeDefaults = { width: 0, height: 0 }, edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"], edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r"
  }, edgeAttrs = ["labelpos"];
  function buildLayoutGraph(inputGraph) {
    let g = new Graph({ multigraph: !0, compound: !0 }), graph2 = canonicalize(inputGraph.graph());
    return g.setGraph(Object.assign(
      {},
      graphDefaults,
      selectNumberAttrs(graph2, graphNumAttrs),
      util2.pick(graph2, graphAttrs)
    )), inputGraph.nodes().forEach((v) => {
      let node = canonicalize(inputGraph.node(v));
      const newNode = selectNumberAttrs(node, nodeNumAttrs);
      Object.keys(nodeDefaults).forEach((k) => {
        newNode[k] === void 0 && (newNode[k] = nodeDefaults[k]);
      }), g.setNode(v, newNode), g.setParent(v, inputGraph.parent(v));
    }), inputGraph.edges().forEach((e2) => {
      let edge = canonicalize(inputGraph.edge(e2));
      g.setEdge(e2, Object.assign(
        {},
        edgeDefaults,
        selectNumberAttrs(edge, edgeNumAttrs),
        util2.pick(edge, edgeAttrs)
      ));
    }), g;
  }
  function makeSpaceForEdgeLabels(g) {
    let graph2 = g.graph();
    graph2.ranksep /= 2, g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.minlen *= 2, edge.labelpos.toLowerCase() !== "c" && (graph2.rankdir === "TB" || graph2.rankdir === "BT" ? edge.width += edge.labeloffset : edge.height += edge.labeloffset);
    });
  }
  function injectEdgeLabelProxies(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      if (edge.width && edge.height) {
        let v = g.node(e2.v), label = { rank: (g.node(e2.w).rank - v.rank) / 2 + v.rank, e: e2 };
        util2.addDummyNode(g, "edge-proxy", label, "_ep");
      }
    });
  }
  function assignRankMinMax(g) {
    let maxRank = 0;
    g.nodes().forEach((v) => {
      let node = g.node(v);
      node.borderTop && (node.minRank = g.node(node.borderTop).rank, node.maxRank = g.node(node.borderBottom).rank, maxRank = Math.max(maxRank, node.maxRank));
    }), g.graph().maxRank = maxRank;
  }
  function removeEdgeLabelProxies(g) {
    g.nodes().forEach((v) => {
      let node = g.node(v);
      node.dummy === "edge-proxy" && (g.edge(node.e).labelRank = node.rank, g.removeNode(v));
    });
  }
  function translateGraph(g) {
    let minX = Number.POSITIVE_INFINITY, maxX = 0, minY = Number.POSITIVE_INFINITY, maxY = 0, graphLabel = g.graph(), marginX = graphLabel.marginx || 0, marginY = graphLabel.marginy || 0;
    function getExtremes(attrs) {
      let x2 = attrs.x, y2 = attrs.y, w = attrs.width, h = attrs.height;
      minX = Math.min(minX, x2 - w / 2), maxX = Math.max(maxX, x2 + w / 2), minY = Math.min(minY, y2 - h / 2), maxY = Math.max(maxY, y2 + h / 2);
    }
    g.nodes().forEach((v) => getExtremes(g.node(v))), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      Object.hasOwn(edge, "x") && getExtremes(edge);
    }), minX -= marginX, minY -= marginY, g.nodes().forEach((v) => {
      let node = g.node(v);
      node.x -= minX, node.y -= minY;
    }), g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.points.forEach((p) => {
        p.x -= minX, p.y -= minY;
      }), Object.hasOwn(edge, "x") && (edge.x -= minX), Object.hasOwn(edge, "y") && (edge.y -= minY);
    }), graphLabel.width = maxX - minX + marginX, graphLabel.height = maxY - minY + marginY;
  }
  function assignNodeIntersects(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2), nodeV = g.node(e2.v), nodeW = g.node(e2.w), p1, p2;
      edge.points ? (p1 = edge.points[0], p2 = edge.points[edge.points.length - 1]) : (edge.points = [], p1 = nodeW, p2 = nodeV), edge.points.unshift(util2.intersectRect(nodeV, p1)), edge.points.push(util2.intersectRect(nodeW, p2));
    });
  }
  function fixupEdgeLabelCoords(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      if (Object.hasOwn(edge, "x"))
        switch ((edge.labelpos === "l" || edge.labelpos === "r") && (edge.width -= edge.labeloffset), edge.labelpos) {
          case "l":
            edge.x -= edge.width / 2 + edge.labeloffset;
            break;
          case "r":
            edge.x += edge.width / 2 + edge.labeloffset;
            break;
        }
    });
  }
  function reversePointsForReversedEdges(g) {
    g.edges().forEach((e2) => {
      let edge = g.edge(e2);
      edge.reversed && edge.points.reverse();
    });
  }
  function removeBorderNodes(g) {
    g.nodes().forEach((v) => {
      if (g.children(v).length) {
        let node = g.node(v), t2 = g.node(node.borderTop), b = g.node(node.borderBottom), l = g.node(node.borderLeft[node.borderLeft.length - 1]), r2 = g.node(node.borderRight[node.borderRight.length - 1]);
        node.width = Math.abs(r2.x - l.x), node.height = Math.abs(b.y - t2.y), node.x = l.x + node.width / 2, node.y = t2.y + node.height / 2;
      }
    }), g.nodes().forEach((v) => {
      g.node(v).dummy === "border" && g.removeNode(v);
    });
  }
  function removeSelfEdges(g) {
    g.edges().forEach((e2) => {
      if (e2.v === e2.w) {
        var node = g.node(e2.v);
        node.selfEdges || (node.selfEdges = []), node.selfEdges.push({ e: e2, label: g.edge(e2) }), g.removeEdge(e2);
      }
    });
  }
  function insertSelfEdges(g) {
    var layers = util2.buildLayerMatrix(g);
    layers.forEach((layer) => {
      var orderShift = 0;
      layer.forEach((v, i2) => {
        var node = g.node(v);
        node.order = i2 + orderShift, (node.selfEdges || []).forEach((selfEdge) => {
          util2.addDummyNode(g, "selfedge", {
            width: selfEdge.label.width,
            height: selfEdge.label.height,
            rank: node.rank,
            order: i2 + ++orderShift,
            e: selfEdge.e,
            label: selfEdge.label
          }, "_se");
        }), delete node.selfEdges;
      });
    });
  }
  function positionSelfEdges(g) {
    g.nodes().forEach((v) => {
      var node = g.node(v);
      if (node.dummy === "selfedge") {
        var selfNode = g.node(node.e.v), x2 = selfNode.x + selfNode.width / 2, y2 = selfNode.y, dx = node.x - x2, dy = selfNode.height / 2;
        g.setEdge(node.e, node.label), g.removeNode(v), node.label.points = [
          { x: x2 + 2 * dx / 3, y: y2 - dy },
          { x: x2 + 5 * dx / 6, y: y2 - dy },
          { x: x2 + dx, y: y2 },
          { x: x2 + 5 * dx / 6, y: y2 + dy },
          { x: x2 + 2 * dx / 3, y: y2 + dy }
        ], node.label.x = node.x, node.label.y = node.y;
      }
    });
  }
  function selectNumberAttrs(obj, attrs) {
    return util2.mapValues(util2.pick(obj, attrs), Number);
  }
  function canonicalize(attrs) {
    var newAttrs = {};
    return attrs && Object.entries(attrs).forEach(([k, v]) => {
      typeof k == "string" && (k = k.toLowerCase()), newAttrs[k] = v;
    }), newAttrs;
  }
  return layout_1;
}
var debug, hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug;
  hasRequiredDebug = 1;
  let util2 = requireUtil$1(), Graph = requireGraphlib().Graph;
  debug = {
    debugOrdering
  };
  function debugOrdering(g) {
    let layerMatrix = util2.buildLayerMatrix(g), h = new Graph({ compound: !0, multigraph: !0 }).setGraph({});
    return g.nodes().forEach((v) => {
      h.setNode(v, { label: v }), h.setParent(v, "layer" + g.node(v).rank);
    }), g.edges().forEach((e2) => h.setEdge(e2.v, e2.w, {}, e2.name)), layerMatrix.forEach((layer, i2) => {
      let layerV = "layer" + i2;
      h.setNode(layerV, { rank: "same" }), layer.reduce((u, v) => (h.setEdge(u, v, { style: "invis" }), v));
    }), h;
  }
  return debug;
}
var version$1, hasRequiredVersion;
function requireVersion() {
  return hasRequiredVersion || (hasRequiredVersion = 1, version$1 = "1.1.8"), version$1;
}
var dagre$1, hasRequiredDagre;
function requireDagre() {
  return hasRequiredDagre || (hasRequiredDagre = 1, dagre$1 = {
    graphlib: requireGraphlib(),
    layout: requireLayout(),
    debug: requireDebug(),
    util: {
      time: requireUtil$1().time,
      notime: requireUtil$1().notime
    },
    version: requireVersion()
  }), dagre$1;
}
var dagreExports = requireDagre();
const dagre = /* @__PURE__ */ getDefaultExportFromCjs(dagreExports);
function constant(x2) {
  return function() {
    return x2;
  };
}
const epsilon$1 = 1e-12, pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
    this._ += arguments[i2] + strings[i2];
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2)
      this._ += Math.round(arguments[i2] * k) / k + strings[i2];
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    if (x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null)
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    else if (l01_2 > epsilon) if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2)
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      Math.abs(t01 - 1) > epsilon && this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`, this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    if (x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw, r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    this._x1 === null ? this._append`M${x0},${y0}` : (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) && this._append`L${x0},${y0}`, r2 && (da < 0 && (da = da % tau + tau), da > tauEpsilon ? this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}` : da > epsilon && this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`);
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  return shape.digits = function(_2) {
    if (!arguments.length) return digits;
    if (_2 == null)
      digits = null;
    else {
      const d = Math.floor(_2);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_2}`);
      digits = d;
    }
    return shape;
  }, () => new Path(digits);
}
function array$1(x2) {
  return typeof x2 == "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
function d3line(x$1, y$1) {
  var defined = constant(!0), context = null, curve = curveLinear, output = null, path = withPath(line);
  x$1 = typeof x$1 == "function" ? x$1 : x$1 === void 0 ? x : constant(x$1), y$1 = typeof y$1 == "function" ? y$1 : y$1 === void 0 ? y : constant(y$1);
  function line(data) {
    var i2, n2 = (data = array$1(data)).length, d, defined0 = !1, buffer;
    for (context == null && (output = curve(buffer = path())), i2 = 0; i2 <= n2; ++i2)
      !(i2 < n2 && defined(d = data[i2], i2, data)) === defined0 && ((defined0 = !defined0) ? output.lineStart() : output.lineEnd()), defined0 && output.point(+x$1(d, i2, data), +y$1(d, i2, data));
    if (buffer) return output = null, buffer + "" || null;
  }
  return line.x = function(_2) {
    return arguments.length ? (x$1 = typeof _2 == "function" ? _2 : constant(+_2), line) : x$1;
  }, line.y = function(_2) {
    return arguments.length ? (y$1 = typeof _2 == "function" ? _2 : constant(+_2), line) : y$1;
  }, line.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 == "function" ? _2 : constant(!!_2), line) : defined;
  }, line.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line) : curve;
  }, line.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line) : context;
  }, line;
}
function point$1(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context, this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$1(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2, this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom(+tension2);
  }, cardinal;
})(0);
function CardinalOpen(context, tension) {
  this._context = context, this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    switch (x2 = +x2, y2 = +y2, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point$1(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom2(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  return cardinal.tension = function(tension2) {
    return custom2(+tension2);
  }, cardinal;
})(0);
function point(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2, y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2, y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha2) {
  this._context = context, this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
(function custom3(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom3(+alpha3);
  }, catmullRom;
})(0.5);
function CatmullRomOpen(context, alpha2) {
  this._context = context, this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    if (x2 = +x2, y2 = +y2, this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const curveCatmullRomOpen = (function custom4(alpha2) {
  function catmullRom(context) {
    return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
  }
  return catmullRom.alpha = function(alpha3) {
    return custom4(+alpha3);
  }, catmullRom;
})(0.5);
var NOTHING = /* @__PURE__ */ Symbol.for("immer-nothing"), DRAFTABLE = /* @__PURE__ */ Symbol.for("immer-draftable"), DRAFT_STATE = /* @__PURE__ */ Symbol.for("immer-state");
function die(error, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var O = Object, getPrototypeOf = O.getPrototypeOf, CONSTRUCTOR = "constructor", PROTOTYPE = "prototype", CONFIGURABLE = "configurable", ENUMERABLE = "enumerable", WRITABLE = "writable", VALUE = "value", isDraft = (value) => !!value && !!value[DRAFT_STATE];
function isDraftable(value) {
  return value ? isPlainObject$1(value) || isArray(value) || !!value[DRAFTABLE] || !!value[CONSTRUCTOR]?.[DRAFTABLE] || isMap(value) || isSet(value) : !1;
}
var objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString(), cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject$1(value) {
  if (!value || !isObjectish(value))
    return !1;
  const proto = getPrototypeOf(value);
  if (proto === null || proto === O[PROTOTYPE])
    return !0;
  const Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];
  if (Ctor === Object)
    return !0;
  if (!isFunction(Ctor))
    return !1;
  let ctorString = cachedCtorStrings.get(Ctor);
  return ctorString === void 0 && (ctorString = Function.toString.call(Ctor), cachedCtorStrings.set(Ctor, ctorString)), ctorString === objectCtorString;
}
function each(obj, iter, strict = !0) {
  getArchtype(obj) === 0 ? (strict ? Reflect.ownKeys(obj) : O.keys(obj)).forEach((key) => {
    iter(key, obj[key], obj);
  }) : obj.forEach((entry, index2) => iter(index2, entry, obj));
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
var has = (thing, prop, type = getArchtype(thing)) => type === 2 ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop), get = (thing, prop, type = getArchtype(thing)) => (
  // @ts-ignore
  type === 2 ? thing.get(prop) : thing[prop]
), set = (thing, propOrOldValue, value, type = getArchtype(thing)) => {
  type === 2 ? thing.set(propOrOldValue, value) : type === 3 ? thing.add(value) : thing[propOrOldValue] = value;
};
function is(x2, y2) {
  return x2 === y2 ? x2 !== 0 || 1 / x2 === 1 / y2 : x2 !== x2 && y2 !== y2;
}
var isArray = Array.isArray, isMap = (target) => target instanceof Map, isSet = (target) => target instanceof Set, isObjectish = (target) => typeof target == "object", isFunction = (target) => typeof target == "function", isBoolean = (target) => typeof target == "boolean";
function isArrayIndex(value) {
  const n2 = +value;
  return Number.isInteger(n2) && String(n2) === value;
}
var latest = (state) => state.copy_ || state.base_, getFinalValue = (state) => state.modified_ ? state.copy_ : state.base_;
function shallowCopy(base, strict) {
  if (isMap(base))
    return new Map(base);
  if (isSet(base))
    return new Set(base);
  if (isArray(base))
    return Array[PROTOTYPE].slice.call(base);
  const isPlain = isPlainObject$1(base);
  if (strict === !0 || strict === "class_only" && !isPlain) {
    const descriptors = O.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2], desc = descriptors[key];
      desc[WRITABLE] === !1 && (desc[WRITABLE] = !0, desc[CONFIGURABLE] = !0), (desc.get || desc.set) && (descriptors[key] = {
        [CONFIGURABLE]: !0,
        [WRITABLE]: !0,
        // could live with !!desc.set as well here...
        [ENUMERABLE]: desc[ENUMERABLE],
        [VALUE]: base[key]
      });
    }
    return O.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain)
      return { ...base };
    const obj = O.create(proto);
    return O.assign(obj, base);
  }
}
function freeze(obj, deep = !1) {
  return isFrozen(obj) || isDraft(obj) || !isDraftable(obj) || (getArchtype(obj) > 1 && O.defineProperties(obj, {
    set: dontMutateMethodOverride,
    add: dontMutateMethodOverride,
    clear: dontMutateMethodOverride,
    delete: dontMutateMethodOverride
  }), O.freeze(obj), deep && each(
    obj,
    (_key, value) => {
      freeze(value, !0);
    },
    !1
  )), obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  [VALUE]: dontMutateFrozenCollections
};
function isFrozen(obj) {
  return obj === null || !isObjectish(obj) ? !0 : O.isFrozen(obj);
}
var PluginMapSet = "MapSet", PluginPatches = "Patches", PluginArrayMethods = "ArrayMethods", plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  return plugin || die(0, pluginKey), plugin;
}
var isPluginLoaded = (pluginKey) => !!plugins[pluginKey], currentScope, getCurrentScope = () => currentScope, createScope = (parent_, immer_) => ({
  drafts_: [],
  parent_,
  immer_,
  // Whenever the modified draft contains a draft from another scope, we
  // need to prevent auto-freezing so the unowned draft can be finalized.
  canAutoFreeze_: !0,
  unfinalizedDrafts_: 0,
  handledSet_: /* @__PURE__ */ new Set(),
  processedForPatches_: /* @__PURE__ */ new Set(),
  mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0,
  arrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods) ? getPlugin(PluginArrayMethods) : void 0
});
function usePatchesInScope(scope, patchListener) {
  patchListener && (scope.patchPlugin_ = getPlugin(PluginPatches), scope.patches_ = [], scope.inversePatches_ = [], scope.patchListener_ = patchListener);
}
function revokeScope(scope) {
  leaveScope(scope), scope.drafts_.forEach(revokeDraft), scope.drafts_ = null;
}
function leaveScope(scope) {
  scope === currentScope && (currentScope = scope.parent_);
}
var enterScope = (immer2) => currentScope = createScope(currentScope, immer2);
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  state.type_ === 0 || state.type_ === 1 ? state.revoke_() : state.revoked_ = !0;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  if (result !== void 0 && result !== baseDraft) {
    baseDraft[DRAFT_STATE].modified_ && (revokeScope(scope), die(4)), isDraftable(result) && (result = finalize(scope, result));
    const { patchPlugin_ } = scope;
    patchPlugin_ && patchPlugin_.generateReplacementPatches_(
      baseDraft[DRAFT_STATE].base_,
      result,
      scope
    );
  } else
    result = finalize(scope, baseDraft);
  return maybeFreeze(scope, result, !0), revokeScope(scope), scope.patches_ && scope.patchListener_(scope.patches_, scope.inversePatches_), result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state)
    return handleValue(value, rootScope.handledSet_, rootScope);
  if (!isSameScope(state, rootScope))
    return value;
  if (!state.modified_)
    return state.base_;
  if (!state.finalized_) {
    const { callbacks_ } = state;
    if (callbacks_)
      for (; callbacks_.length > 0; )
        callbacks_.pop()(rootScope);
    generatePatchesAndFinalize(state, rootScope);
  }
  return state.copy_;
}
function maybeFreeze(scope, value, deep = !1) {
  !scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_ && freeze(value, deep);
}
function markStateFinalized(state) {
  state.finalized_ = !0, state.scope_.unfinalizedDrafts_--;
}
var isSameScope = (state, rootScope) => state.scope_ === rootScope, EMPTY_LOCATIONS_RESULT = [];
function updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {
  const parentCopy = latest(parent), parentType = parent.type_;
  if (originalKey !== void 0 && get(parentCopy, originalKey, parentType) === draftValue) {
    set(parentCopy, originalKey, finalizedValue, parentType);
    return;
  }
  if (!parent.draftLocations_) {
    const draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();
    each(parentCopy, (key, value) => {
      if (isDraft(value)) {
        const keys2 = draftLocations.get(value) || [];
        keys2.push(key), draftLocations.set(value, keys2);
      }
    });
  }
  const locations = parent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT;
  for (const location of locations)
    set(parentCopy, location, finalizedValue, parentType);
}
function registerChildFinalizationCallback(parent, child, key) {
  parent.callbacks_.push(function(rootScope) {
    const state = child;
    if (!state || !isSameScope(state, rootScope))
      return;
    rootScope.mapSetPlugin_?.fixSetContents(state);
    const finalizedValue = getFinalValue(state);
    updateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key), generatePatchesAndFinalize(state, rootScope);
  });
}
function generatePatchesAndFinalize(state, rootScope) {
  if (state.modified_ && !state.finalized_ && (state.type_ === 3 || state.type_ === 1 && state.allIndicesReassigned_ || (state.assigned_?.size ?? 0) > 0)) {
    const { patchPlugin_ } = rootScope;
    if (patchPlugin_) {
      const basePath = patchPlugin_.getPath(state);
      basePath && patchPlugin_.generatePatches_(state, basePath, rootScope);
    }
    markStateFinalized(state);
  }
}
function handleCrossReference(target, key, value) {
  const { scope_ } = target;
  if (isDraft(value)) {
    const state = value[DRAFT_STATE];
    isSameScope(state, scope_) && state.callbacks_.push(function() {
      prepareCopy(target);
      const finalizedValue = getFinalValue(state);
      updateDraftInParent(target, value, finalizedValue, key);
    });
  } else isDraftable(value) && target.callbacks_.push(function() {
    const targetCopy = latest(target);
    get(targetCopy, key, target.type_) === value && scope_.drafts_.length > 1 && (target.assigned_.get(key) ?? !1) === !0 && target.copy_ && handleValue(
      get(target.copy_, key, target.type_),
      scope_.handledSet_,
      scope_
    );
  });
}
function handleValue(target, handledSet, rootScope) {
  return !rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1 || isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target) || (handledSet.add(target), each(target, (key, value) => {
    if (isDraft(value)) {
      const state = value[DRAFT_STATE];
      if (isSameScope(state, rootScope)) {
        const updatedValue = getFinalValue(state);
        set(target, key, updatedValue, target.type_), markStateFinalized(state);
      }
    } else isDraftable(value) && handleValue(value, handledSet, rootScope);
  })), target;
}
function createProxyProxy(base, parent) {
  const baseIsArray = isArray(base), state = {
    type_: baseIsArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    // actually instantiated in `prepareCopy()`
    assigned_: void 0,
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1,
    // `callbacks` actually gets assigned in `createProxy`
    callbacks_: void 0
  };
  let target = state, traps = objectTraps;
  baseIsArray && (target = [state], traps = arrayTraps);
  const { revoke, proxy } = Proxy.revocable(target, traps);
  return state.draft_ = proxy, state.revoke_ = revoke, [proxy, state];
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    let arrayPlugin = state.scope_.arrayMethodsPlugin_;
    const isArrayWithStringProp = state.type_ === 1 && typeof prop == "string";
    if (isArrayWithStringProp && arrayPlugin?.isArrayOperationMethod(prop))
      return arrayPlugin.createMethodInterceptor(state, prop);
    const source = latest(state);
    if (!has(source, prop, state.type_))
      return readPropFromProto(state, source, prop);
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value) || isArrayWithStringProp && state.operationMethod && arrayPlugin?.isMutatingArrayMethod(
      state.operationMethod
    ) && isArrayIndex(prop))
      return value;
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      const childKey = state.type_ === 1 ? +prop : prop, childDraft = createProxy(state.scope_, value, state, childKey);
      return state.copy_[childKey] = childDraft;
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set)
      return desc.set.call(state.draft_, value), !0;
    if (!state.modified_) {
      const current2 = peek(latest(state), prop), currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value)
        return state.copy_[prop] = value, state.assigned_.set(prop, !1), !0;
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_)))
        return !0;
      prepareCopy(state), markChanged(state);
    }
    return state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]) || (state.copy_[prop] = value, state.assigned_.set(prop, !0), handleCrossReference(state, prop, value)), !0;
  },
  deleteProperty(state, prop) {
    return prepareCopy(state), peek(state.base_, prop) !== void 0 || prop in state.base_ ? (state.assigned_.set(prop, !1), markChanged(state)) : state.assigned_.delete(prop), state.copy_ && delete state.copy_[prop], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state), desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    return desc && {
      [WRITABLE]: !0,
      [CONFIGURABLE]: state.type_ !== 1 || prop !== "length",
      [ENUMERABLE]: desc[ENUMERABLE],
      [VALUE]: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
}, arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    const args = arguments;
    return args[0] = args[0][0], fn.apply(this, args);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  return (state ? latest(state) : draft)[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? VALUE in desc ? desc[VALUE] : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return;
  let proto = getPrototypeOf(source);
  for (; proto; ) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
}
function markChanged(state) {
  state.modified_ || (state.modified_ = !0, state.parent_ && markChanged(state.parent_));
}
function prepareCopy(state) {
  state.copy_ || (state.assigned_ = /* @__PURE__ */ new Map(), state.copy_ = shallowCopy(
    state.base_,
    state.scope_.immer_.useStrictShallowCopy_
  ));
}
var Immer2 = class {
  constructor(config2) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.useStrictIteration_ = !1, this.produce = (base, recipe, patchListener) => {
      if (isFunction(base) && !isFunction(recipe)) {
        const defaultBase = recipe;
        recipe = base;
        const self2 = this;
        return function(base2 = defaultBase, ...args) {
          return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      isFunction(recipe) || die(6), patchListener !== void 0 && !isFunction(patchListener) && die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this), proxy = createProxy(scope, base, void 0);
        let hasError = !0;
        try {
          result = recipe(proxy), hasError = !1;
        } finally {
          hasError ? revokeScope(scope) : leaveScope(scope);
        }
        return usePatchesInScope(scope, patchListener), processResult(result, scope);
      } else if (!base || !isObjectish(base)) {
        if (result = recipe(base), result === void 0 && (result = base), result === NOTHING && (result = void 0), this.autoFreeze_ && freeze(result, !0), patchListener) {
          const p = [], ip = [];
          getPlugin(PluginPatches).generateReplacementPatches_(base, result, {
            patches_: p,
            inversePatches_: ip
          }), patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    }, this.produceWithPatches = (base, recipe) => {
      if (isFunction(base))
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      let patches, inversePatches;
      return [this.produce(base, recipe, (p, ip) => {
        patches = p, inversePatches = ip;
      }), patches, inversePatches];
    }, isBoolean(config2?.autoFreeze) && this.setAutoFreeze(config2.autoFreeze), isBoolean(config2?.useStrictShallowCopy) && this.setUseStrictShallowCopy(config2.useStrictShallowCopy), isBoolean(config2?.useStrictIteration) && this.setUseStrictIteration(config2.useStrictIteration);
  }
  createDraft(base) {
    isDraftable(base) || die(8), isDraft(base) && (base = current(base));
    const scope = enterScope(this), proxy = createProxy(scope, base, void 0);
    return proxy[DRAFT_STATE].isManual_ = !0, leaveScope(scope), proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    (!state || !state.isManual_) && die(9);
    const { scope_: scope } = state;
    return usePatchesInScope(scope, patchListener), processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i2;
    for (i2 = patches.length - 1; i2 >= 0; i2--) {
      const patch = patches[i2];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    i2 > -1 && (patches = patches.slice(i2 + 1));
    const applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;
    return isDraft(base) ? applyPatchesImpl(base, patches) : this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(rootScope, value, parent, key) {
  const [draft, state] = isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent);
  return (parent?.scope_ ?? getCurrentScope()).drafts_.push(draft), state.callbacks_ = parent?.callbacks_ ?? [], state.key_ = key, parent && key !== void 0 ? registerChildFinalizationCallback(parent, state, key) : state.callbacks_.push(function(rootScope2) {
    rootScope2.mapSetPlugin_?.fixSetContents(state);
    const { patchPlugin_ } = rootScope2;
    state.modified_ && patchPlugin_ && patchPlugin_.generatePatches_(state, [], rootScope2);
  }), draft;
}
function current(value) {
  return isDraft(value) || die(10, value), currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy, strict = !0;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = !0, copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_), strict = state.scope_.immer_.shouldUseStrictIteration();
  } else
    copy = shallowCopy(value, !0);
  return each(
    copy,
    (key, childValue) => {
      set(copy, key, currentImpl(childValue));
    },
    strict
  ), state && (state.finalized_ = !1), copy;
}
var immer = new Immer2(), produce = immer.produce, setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer), castDraft = (value) => value;
const Channel = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (r2) => r2 >= 255 ? 255 : r2 < 0 ? 0 : r2,
    g: (g) => g >= 255 ? 255 : g < 0 ? 0 : g,
    b: (b) => b >= 255 ? 255 : b < 0 ? 0 : b,
    h: (h) => h % 360,
    s: (s) => s >= 100 ? 100 : s < 0 ? 0 : s,
    l: (l) => l >= 100 ? 100 : l < 0 ? 0 : l,
    a: (a2) => a2 >= 1 ? 1 : a2 < 0 ? 0 : a2
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (c) => {
    const n2 = c / 255;
    return c > 0.03928 ? Math.pow((n2 + 0.055) / 1.055, 2.4) : n2 / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (p, q, t2) => (t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p + (q - p) * 6 * t2 : t2 < 1 / 2 ? q : t2 < 2 / 3 ? p + (q - p) * (2 / 3 - t2) * 6 : p),
  hsl2rgb: ({ h, s, l }, channel) => {
    if (!s)
      return l * 2.55;
    h /= 360, s /= 100, l /= 100;
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
    switch (channel) {
      case "r":
        return Channel.hue2rgb(p, q, h + 1 / 3) * 255;
      case "g":
        return Channel.hue2rgb(p, q, h) * 255;
      case "b":
        return Channel.hue2rgb(p, q, h - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: r2, g, b }, channel) => {
    r2 /= 255, g /= 255, b /= 255;
    const max2 = Math.max(r2, g, b), min2 = Math.min(r2, g, b), l = (max2 + min2) / 2;
    if (channel === "l")
      return l * 100;
    if (max2 === min2)
      return 0;
    const d = max2 - min2, s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    if (channel === "s")
      return s * 100;
    switch (max2) {
      case r2:
        return ((g - b) / d + (g < b ? 6 : 0)) * 60;
      case g:
        return ((b - r2) / d + 2) * 60;
      case b:
        return ((r2 - g) / d + 4) * 60;
      default:
        return -1;
    }
  }
}, Lang = {
  /* API */
  clamp: (number2, lower2, upper) => lower2 > upper ? Math.min(lower2, Math.max(upper, number2)) : Math.min(upper, Math.max(lower2, number2)),
  round: (number2) => Math.round(number2 * 1e10) / 1e10
}, Unit = {
  /* API */
  dec2hex: (dec) => {
    const hex2 = Math.round(dec).toString(16);
    return hex2.length > 1 ? hex2 : `0${hex2}`;
  }
}, Utils = {
  channel: Channel,
  lang: Lang,
  unit: Unit
}, DEC2HEX = {};
for (let i2 = 0; i2 <= 255; i2++)
  DEC2HEX[i2] = Utils.unit.dec2hex(i2);
const TYPE = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
class Type {
  constructor() {
    this.type = TYPE.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(type) {
    if (this.type && this.type !== type)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = type;
  }
  reset() {
    this.type = TYPE.ALL;
  }
  is(type) {
    return this.type === type;
  }
}
class Channels {
  /* CONSTRUCTOR */
  constructor(data, color2) {
    this.color = color2, this.changed = !1, this.data = data, this.type = new Type();
  }
  /* API */
  set(data, color2) {
    return this.color = color2, this.changed = !1, this.data = data, this.type.type = TYPE.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const data = this.data, { h, s, l } = data;
    h === void 0 && (data.h = Utils.channel.rgb2hsl(data, "h")), s === void 0 && (data.s = Utils.channel.rgb2hsl(data, "s")), l === void 0 && (data.l = Utils.channel.rgb2hsl(data, "l"));
  }
  _ensureRGB() {
    const data = this.data, { r: r2, g, b } = data;
    r2 === void 0 && (data.r = Utils.channel.hsl2rgb(data, "r")), g === void 0 && (data.g = Utils.channel.hsl2rgb(data, "g")), b === void 0 && (data.b = Utils.channel.hsl2rgb(data, "b"));
  }
  /* GETTERS */
  get r() {
    const data = this.data, r2 = data.r;
    return !this.type.is(TYPE.HSL) && r2 !== void 0 ? r2 : (this._ensureHSL(), Utils.channel.hsl2rgb(data, "r"));
  }
  get g() {
    const data = this.data, g = data.g;
    return !this.type.is(TYPE.HSL) && g !== void 0 ? g : (this._ensureHSL(), Utils.channel.hsl2rgb(data, "g"));
  }
  get b() {
    const data = this.data, b = data.b;
    return !this.type.is(TYPE.HSL) && b !== void 0 ? b : (this._ensureHSL(), Utils.channel.hsl2rgb(data, "b"));
  }
  get h() {
    const data = this.data, h = data.h;
    return !this.type.is(TYPE.RGB) && h !== void 0 ? h : (this._ensureRGB(), Utils.channel.rgb2hsl(data, "h"));
  }
  get s() {
    const data = this.data, s = data.s;
    return !this.type.is(TYPE.RGB) && s !== void 0 ? s : (this._ensureRGB(), Utils.channel.rgb2hsl(data, "s"));
  }
  get l() {
    const data = this.data, l = data.l;
    return !this.type.is(TYPE.RGB) && l !== void 0 ? l : (this._ensureRGB(), Utils.channel.rgb2hsl(data, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(r2) {
    this.type.set(TYPE.RGB), this.changed = !0, this.data.r = r2;
  }
  set g(g) {
    this.type.set(TYPE.RGB), this.changed = !0, this.data.g = g;
  }
  set b(b) {
    this.type.set(TYPE.RGB), this.changed = !0, this.data.b = b;
  }
  set h(h) {
    this.type.set(TYPE.HSL), this.changed = !0, this.data.h = h;
  }
  set s(s) {
    this.type.set(TYPE.HSL), this.changed = !0, this.data.s = s;
  }
  set l(l) {
    this.type.set(TYPE.HSL), this.changed = !0, this.data.l = l;
  }
  set a(a2) {
    this.changed = !0, this.data.a = a2;
  }
}
const channels = new Channels({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), Hex = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (color2) => {
    if (color2.charCodeAt(0) !== 35)
      return;
    const match = color2.match(Hex.re);
    if (!match)
      return;
    const hex2 = match[1], dec = parseInt(hex2, 16), length = hex2.length, hasAlpha = length % 4 === 0, isFullLength = length > 4, multiplier = isFullLength ? 1 : 17, bits = isFullLength ? 8 : 4, bitsOffset = hasAlpha ? 0 : -1, mask = isFullLength ? 255 : 15;
    return channels.set({
      r: (dec >> bits * (bitsOffset + 3) & mask) * multiplier,
      g: (dec >> bits * (bitsOffset + 2) & mask) * multiplier,
      b: (dec >> bits * (bitsOffset + 1) & mask) * multiplier,
      a: hasAlpha ? (dec & mask) * multiplier / 255 : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { r: r2, g, b, a: a2 } = channels2;
    return a2 < 1 ? `#${DEC2HEX[Math.round(r2)]}${DEC2HEX[Math.round(g)]}${DEC2HEX[Math.round(b)]}${DEC2HEX[Math.round(a2 * 255)]}` : `#${DEC2HEX[Math.round(r2)]}${DEC2HEX[Math.round(g)]}${DEC2HEX[Math.round(b)]}`;
  }
}, HSL = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (hue) => {
    const match = hue.match(HSL.hueRe);
    if (match) {
      const [, number2, unit] = match;
      switch (unit) {
        case "grad":
          return Utils.channel.clamp.h(parseFloat(number2) * 0.9);
        case "rad":
          return Utils.channel.clamp.h(parseFloat(number2) * 180 / Math.PI);
        case "turn":
          return Utils.channel.clamp.h(parseFloat(number2) * 360);
      }
    }
    return Utils.channel.clamp.h(parseFloat(hue));
  },
  /* API */
  parse: (color2) => {
    const charCode = color2.charCodeAt(0);
    if (charCode !== 104 && charCode !== 72)
      return;
    const match = color2.match(HSL.re);
    if (!match)
      return;
    const [, h, s, l, a2, isAlphaPercentage] = match;
    return channels.set({
      h: HSL._hue2deg(h),
      s: Utils.channel.clamp.s(parseFloat(s)),
      l: Utils.channel.clamp.l(parseFloat(l)),
      a: a2 ? Utils.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { h, s, l, a: a2 } = channels2;
    return a2 < 1 ? `hsla(${Utils.lang.round(h)}, ${Utils.lang.round(s)}%, ${Utils.lang.round(l)}%, ${a2})` : `hsl(${Utils.lang.round(h)}, ${Utils.lang.round(s)}%, ${Utils.lang.round(l)}%)`;
  }
}, Keyword = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (color2) => {
    color2 = color2.toLowerCase();
    const hex2 = Keyword.colors[color2];
    if (hex2)
      return Hex.parse(hex2);
  },
  stringify: (channels2) => {
    const hex2 = Hex.stringify(channels2);
    for (const name in Keyword.colors)
      if (Keyword.colors[name] === hex2)
        return name;
  }
}, RGB = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (color2) => {
    const charCode = color2.charCodeAt(0);
    if (charCode !== 114 && charCode !== 82)
      return;
    const match = color2.match(RGB.re);
    if (!match)
      return;
    const [, r2, isRedPercentage, g, isGreenPercentage, b, isBluePercentage, a2, isAlphaPercentage] = match;
    return channels.set({
      r: Utils.channel.clamp.r(isRedPercentage ? parseFloat(r2) * 2.55 : parseFloat(r2)),
      g: Utils.channel.clamp.g(isGreenPercentage ? parseFloat(g) * 2.55 : parseFloat(g)),
      b: Utils.channel.clamp.b(isBluePercentage ? parseFloat(b) * 2.55 : parseFloat(b)),
      a: a2 ? Utils.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { r: r2, g, b, a: a2 } = channels2;
    return a2 < 1 ? `rgba(${Utils.lang.round(r2)}, ${Utils.lang.round(g)}, ${Utils.lang.round(b)}, ${Utils.lang.round(a2)})` : `rgb(${Utils.lang.round(r2)}, ${Utils.lang.round(g)}, ${Utils.lang.round(b)})`;
  }
}, Color = {
  /* VARIABLES */
  format: {
    keyword: Keyword,
    hex: Hex,
    rgb: RGB,
    rgba: RGB,
    hsl: HSL,
    hsla: HSL
  },
  /* API */
  parse: (color2) => {
    if (typeof color2 != "string")
      return color2;
    const channels2 = Hex.parse(color2) || RGB.parse(color2) || HSL.parse(color2) || Keyword.parse(color2);
    if (channels2)
      return channels2;
    throw new Error(`Unsupported color format: "${color2}"`);
  },
  stringify: (channels2) => !channels2.changed && channels2.color ? channels2.color : channels2.type.is(TYPE.HSL) || channels2.data.r === void 0 ? HSL.stringify(channels2) : channels2.a < 1 || !Number.isInteger(channels2.r) || !Number.isInteger(channels2.g) || !Number.isInteger(channels2.b) ? RGB.stringify(channels2) : Hex.stringify(channels2)
}, change = (color2, channels2) => {
  const ch = Color.parse(color2);
  for (const c in channels2)
    ch[c] = Utils.channel.clamp[c](channels2[c]);
  return Color.stringify(ch);
}, rgba = (r2, g, b = 0, a2 = 1) => {
  if (typeof r2 != "number")
    return change(r2, { a: g });
  const channels$1 = channels.set({
    r: Utils.channel.clamp.r(r2),
    g: Utils.channel.clamp.g(g),
    b: Utils.channel.clamp.b(b),
    a: Utils.channel.clamp.a(a2)
  });
  return Color.stringify(channels$1);
}, toHex = (color2) => Color.format.hex.stringify(Color.parse(color2)), toRgba = (color2) => Color.format.rgba.stringify(Color.parse(color2)), adjust = (color2, channels2) => {
  const ch = Color.parse(color2), changes = {};
  for (const c in channels2)
    channels2[c] && (changes[c] = ch[c] + channels2[c]);
  return change(color2, changes);
}, mix = (color1, color2, weight = 50) => {
  const { r: r1, g: g1, b: b1, a: a1 } = Color.parse(color1), { r: r2, g: g2, b: b2, a: a2 } = Color.parse(color2), weightScale = weight / 100, weightNormalized = weightScale * 2 - 1, alphaDelta = a1 - a2, weight1 = ((weightNormalized * alphaDelta === -1 ? weightNormalized : (weightNormalized + alphaDelta) / (1 + weightNormalized * alphaDelta)) + 1) / 2, weight2 = 1 - weight1, r3 = r1 * weight1 + r2 * weight2, g = g1 * weight1 + g2 * weight2, b = b1 * weight1 + b2 * weight2, a3 = a1 * weightScale + a2 * (1 - weightScale);
  return rgba(r3, g, b, a3);
}, scale = (color2, channels2) => {
  const ch = Color.parse(color2), adjustments = {}, delta = (amount, weight, max2) => weight > 0 ? (max2 - amount) * weight / 100 : amount * weight / 100;
  for (const c in channels2)
    adjustments[c] = delta(ch[c], channels2[c], Utils.channel.max[c]);
  return adjust(color2, adjustments);
};
function resolveUrl(url, baseUrl) {
  if (url.match(/^[a-z]+:\/\//i))
    return url;
  if (url.match(/^\/\//))
    return window.location.protocol + url;
  if (url.match(/^[a-z]+:/i))
    return url;
  const doc = document.implementation.createHTMLDocument(), base = doc.createElement("base"), a2 = doc.createElement("a");
  return doc.head.appendChild(base), doc.body.appendChild(a2), baseUrl && (base.href = baseUrl), a2.href = url, a2.href;
}
const uuid$1 = /* @__PURE__ */ (() => {
  let counter = 0;
  const random = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (counter += 1, `u${random()}${counter}`);
})();
function toArray(arrayLike) {
  const arr = [];
  for (let i2 = 0, l = arrayLike.length; i2 < l; i2++)
    arr.push(arrayLike[i2]);
  return arr;
}
function px(node, styleProperty) {
  const val = (node.ownerDocument.defaultView || window).getComputedStyle(node).getPropertyValue(styleProperty);
  return val ? parseFloat(val.replace("px", "")) : 0;
}
function getNodeWidth(node) {
  const leftBorder = px(node, "border-left-width"), rightBorder = px(node, "border-right-width");
  return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
  const topBorder = px(node, "border-top-width"), bottomBorder = px(node, "border-bottom-width");
  return node.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options = {}) {
  const width = options.width || getNodeWidth(targetNode), height = options.height || getNodeHeight(targetNode);
  return { width, height };
}
function getPixelRatio() {
  let ratio, FINAL_PROCESS;
  try {
    FINAL_PROCESS = process;
  } catch {
  }
  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
  return val && (ratio = parseInt(val, 10), Number.isNaN(ratio) && (ratio = 1)), ratio || window.devicePixelRatio || 1;
}
const canvasDimensionLimit = 16384;
function checkCanvasDimensions(canvas) {
  (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) && (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit ? canvas.width > canvas.height ? (canvas.height *= canvasDimensionLimit / canvas.width, canvas.width = canvasDimensionLimit) : (canvas.width *= canvasDimensionLimit / canvas.height, canvas.height = canvasDimensionLimit) : canvas.width > canvasDimensionLimit ? (canvas.height *= canvasDimensionLimit / canvas.width, canvas.width = canvasDimensionLimit) : (canvas.width *= canvasDimensionLimit / canvas.height, canvas.height = canvasDimensionLimit));
}
function canvasToBlob(canvas, options = {}) {
  return canvas.toBlob ? new Promise((resolve) => {
    canvas.toBlob(resolve, options.type ? options.type : "image/png", options.quality ? options.quality : 1);
  }) : new Promise((resolve) => {
    const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : void 0, options.quality ? options.quality : void 0).split(",")[1]), len = binaryString.length, binaryArray = new Uint8Array(len);
    for (let i2 = 0; i2 < len; i2 += 1)
      binaryArray[i2] = binaryString.charCodeAt(i2);
    resolve(new Blob([binaryArray], {
      type: options.type ? options.type : "image/png"
    }));
  });
}
function createImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.decode = () => resolve(img), img.onload = () => resolve(img), img.onerror = reject, img.crossOrigin = "anonymous", img.decoding = "async", img.src = url;
  });
}
async function svgToDataURL(svg) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
}
async function nodeToDataURL(node, width, height) {
  const xmlns = "http://www.w3.org/2000/svg", svg = document.createElementNS(xmlns, "svg"), foreignObject = document.createElementNS(xmlns, "foreignObject");
  return svg.setAttribute("width", `${width}`), svg.setAttribute("height", `${height}`), svg.setAttribute("viewBox", `0 0 ${width} ${height}`), foreignObject.setAttribute("width", "100%"), foreignObject.setAttribute("height", "100%"), foreignObject.setAttribute("x", "0"), foreignObject.setAttribute("y", "0"), foreignObject.setAttribute("externalResourcesRequired", "true"), svg.appendChild(foreignObject), foreignObject.appendChild(node), svgToDataURL(svg);
}
const isInstanceOfElement = (node, instance) => {
  if (node instanceof instance)
    return !0;
  const nodePrototype = Object.getPrototypeOf(node);
  return nodePrototype === null ? !1 : nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
};
function formatCSSText(style2) {
  const content = style2.getPropertyValue("content");
  return `${style2.cssText} content: '${content.replace(/'|"/g, "")}';`;
}
function formatCSSProperties(style2) {
  return toArray(style2).map((name) => {
    const value = style2.getPropertyValue(name), priority = style2.getPropertyPriority(name);
    return `${name}: ${value}${priority ? " !important" : ""};`;
  }).join(" ");
}
function getPseudoElementStyle(className, pseudo, style2) {
  const selector2 = `.${className}:${pseudo}`, cssText = style2.cssText ? formatCSSText(style2) : formatCSSProperties(style2);
  return document.createTextNode(`${selector2}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo) {
  const style2 = window.getComputedStyle(nativeNode, pseudo), content = style2.getPropertyValue("content");
  if (content === "" || content === "none")
    return;
  const className = uuid$1();
  try {
    clonedNode.className = `${clonedNode.className} ${className}`;
  } catch {
    return;
  }
  const styleElement = document.createElement("style");
  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style2)), clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode) {
  clonePseudoElement(nativeNode, clonedNode, ":before"), clonePseudoElement(nativeNode, clonedNode, ":after");
}
const WOFF = "application/font-woff", JPEG = "image/jpeg", mimes = {
  woff: WOFF,
  woff2: WOFF,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: JPEG,
  jpeg: JPEG,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function getExtension(url) {
  const match = /\.([^./]*?)$/g.exec(url);
  return match ? match[1] : "";
}
function getMimeType(url) {
  const extension = getExtension(url).toLowerCase();
  return mimes[extension] || "";
}
function getContentFromDataUrl(dataURL) {
  return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
  return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
  return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init2, process2) {
  const res = await fetch(url, init2);
  if (res.status === 404)
    throw new Error(`Resource "${res.url}" not found`);
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject, reader.onloadend = () => {
      try {
        resolve(process2({ res, result: reader.result }));
      } catch (error) {
        reject(error);
      }
    }, reader.readAsDataURL(blob);
  });
}
const cache = {};
function getCacheKey(url, contentType, includeQueryParams) {
  let key = url.replace(/\?.*/, "");
  return includeQueryParams && (key = url), /ttf|otf|eot|woff2?/i.test(key) && (key = key.replace(/.*\//, "")), contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options) {
  const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
  if (cache[cacheKey] != null)
    return cache[cacheKey];
  options.cacheBust && (resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let dataURL;
  try {
    const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => (contentType || (contentType = res.headers.get("Content-Type") || ""), getContentFromDataUrl(result)));
    dataURL = makeDataUrl(content, contentType);
  } catch (error) {
    dataURL = options.imagePlaceholder || "";
    let msg = `Failed to fetch resource: ${resourceUrl}`;
    error && (msg = typeof error == "string" ? error : error.message), msg && console.warn(msg);
  }
  return cache[cacheKey] = dataURL, dataURL;
}
async function cloneCanvasElement(canvas) {
  const dataURL = canvas.toDataURL();
  return dataURL === "data:," ? canvas.cloneNode(!1) : createImage(dataURL);
}
async function cloneVideoElement(video, options) {
  if (video.currentSrc) {
    const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
    canvas.width = video.clientWidth, canvas.height = video.clientHeight, ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataURL2 = canvas.toDataURL();
    return createImage(dataURL2);
  }
  const poster = video.poster, contentType = getMimeType(poster), dataURL = await resourceToDataURL(poster, contentType, options);
  return createImage(dataURL);
}
async function cloneIFrameElement(iframe) {
  var _a;
  try {
    if (!((_a = iframe?.contentDocument) === null || _a === void 0) && _a.body)
      return await cloneNode(iframe.contentDocument.body, {}, !0);
  } catch {
  }
  return iframe.cloneNode(!1);
}
async function cloneSingleNode(node, options) {
  return isInstanceOfElement(node, HTMLCanvasElement) ? cloneCanvasElement(node) : isInstanceOfElement(node, HTMLVideoElement) ? cloneVideoElement(node, options) : isInstanceOfElement(node, HTMLIFrameElement) ? cloneIFrameElement(node) : node.cloneNode(!1);
}
const isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
async function cloneChildren(nativeNode, clonedNode, options) {
  var _a, _b;
  let children2 = [];
  return isSlotElement(nativeNode) && nativeNode.assignedNodes ? children2 = toArray(nativeNode.assignedNodes()) : isInstanceOfElement(nativeNode, HTMLIFrameElement) && (!((_a = nativeNode.contentDocument) === null || _a === void 0) && _a.body) ? children2 = toArray(nativeNode.contentDocument.body.childNodes) : children2 = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes), children2.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement) || await children2.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
    clonedChild && clonedNode.appendChild(clonedChild);
  }), Promise.resolve()), clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode) {
  const targetStyle = clonedNode.style;
  if (!targetStyle)
    return;
  const sourceStyle = window.getComputedStyle(nativeNode);
  sourceStyle.cssText ? (targetStyle.cssText = sourceStyle.cssText, targetStyle.transformOrigin = sourceStyle.transformOrigin) : toArray(sourceStyle).forEach((name) => {
    let value = sourceStyle.getPropertyValue(name);
    name === "font-size" && value.endsWith("px") && (value = `${Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1}px`), isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline" && (value = "block"), name === "d" && clonedNode.getAttribute("d") && (value = `path(${clonedNode.getAttribute("d")})`), targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
  });
}
function cloneInputValue(nativeNode, clonedNode) {
  isInstanceOfElement(nativeNode, HTMLTextAreaElement) && (clonedNode.innerHTML = nativeNode.value), isInstanceOfElement(nativeNode, HTMLInputElement) && clonedNode.setAttribute("value", nativeNode.value);
}
function cloneSelectValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const selectedOption = Array.from(clonedNode.children).find((child) => nativeNode.value === child.getAttribute("value"));
    selectedOption && selectedOption.setAttribute("selected", "");
  }
}
function decorate(nativeNode, clonedNode) {
  return isInstanceOfElement(clonedNode, Element) && (cloneCSSStyle(nativeNode, clonedNode), clonePseudoElements(nativeNode, clonedNode), cloneInputValue(nativeNode, clonedNode), cloneSelectValue(nativeNode, clonedNode)), clonedNode;
}
async function ensureSVGSymbols(clone2, options) {
  const uses = clone2.querySelectorAll ? clone2.querySelectorAll("use") : [];
  if (uses.length === 0)
    return clone2;
  const processedDefs = {};
  for (let i2 = 0; i2 < uses.length; i2++) {
    const id2 = uses[i2].getAttribute("xlink:href");
    if (id2) {
      const exist = clone2.querySelector(id2), definition = document.querySelector(id2);
      !exist && definition && !processedDefs[id2] && (processedDefs[id2] = await cloneNode(definition, options, !0));
    }
  }
  const nodes = Object.values(processedDefs);
  if (nodes.length) {
    const ns = "http://www.w3.org/1999/xhtml", svg = document.createElementNS(ns, "svg");
    svg.setAttribute("xmlns", ns), svg.style.position = "absolute", svg.style.width = "0", svg.style.height = "0", svg.style.overflow = "hidden", svg.style.display = "none";
    const defs = document.createElementNS(ns, "defs");
    svg.appendChild(defs);
    for (let i2 = 0; i2 < nodes.length; i2++)
      defs.appendChild(nodes[i2]);
    clone2.appendChild(svg);
  }
  return clone2;
}
async function cloneNode(node, options, isRoot) {
  return !isRoot && options.filter && !options.filter(node) ? null : Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
}
const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g, URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
}
function parseURLs(cssText) {
  const urls = [];
  return cssText.replace(URL_REGEX, (raw, quotation, url) => (urls.push(url), raw)), urls.filter((url) => !isDataUrl(url));
}
async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL, contentType = getMimeType(resourceURL);
    let dataURL;
    return getContentFromUrl || (dataURL = await resourceToDataURL(resolvedURL, contentType, options)), cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
  } catch {
  }
  return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
  return preferredFontFormat ? str.replace(FONT_SRC_REGEX, (match) => {
    for (; ; ) {
      const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
      if (!format)
        return "";
      if (format === preferredFontFormat)
        return `src: ${src};`;
    }
  }) : str;
}
function shouldEmbed(url) {
  return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options) {
  if (!shouldEmbed(cssText))
    return cssText;
  const filteredCSSText = filterPreferredFontFormat(cssText, options);
  return parseURLs(filteredCSSText).reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
}
async function embedProp(propName, node, options) {
  var _a;
  const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
  if (propValue) {
    const cssString = await embedResources(propValue, null, options);
    return node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName)), !0;
  }
  return !1;
}
async function embedBackground(clonedNode, options) {
  await embedProp("background", clonedNode, options) || await embedProp("background-image", clonedNode, options), await embedProp("mask", clonedNode, options) || await embedProp("mask-image", clonedNode, options);
}
async function embedImageNode(clonedNode, options) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal)))
    return;
  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal, dataURL = await resourceToDataURL(url, getMimeType(url), options);
  await new Promise((resolve, reject) => {
    clonedNode.onload = resolve, clonedNode.onerror = reject;
    const image = clonedNode;
    image.decode && (image.decode = resolve), image.loading === "lazy" && (image.loading = "eager"), isImageElement ? (clonedNode.srcset = "", clonedNode.src = dataURL) : clonedNode.href.baseVal = dataURL;
  });
}
async function embedChildren(clonedNode, options) {
  const deferreds = toArray(clonedNode.childNodes).map((child) => embedImages(child, options));
  await Promise.all(deferreds).then(() => clonedNode);
}
async function embedImages(clonedNode, options) {
  isInstanceOfElement(clonedNode, Element) && (await embedBackground(clonedNode, options), await embedImageNode(clonedNode, options), await embedChildren(clonedNode, options));
}
function applyStyle(node, options) {
  const { style: style2 } = node;
  options.backgroundColor && (style2.backgroundColor = options.backgroundColor), options.width && (style2.width = `${options.width}px`), options.height && (style2.height = `${options.height}px`);
  const manual = options.style;
  return manual != null && Object.keys(manual).forEach((key) => {
    style2[key] = manual[key];
  }), node;
}
const cssFetchCache = {};
async function fetchCSS(url) {
  let cache2 = cssFetchCache[url];
  if (cache2 != null)
    return cache2;
  const cssText = await (await fetch(url)).text();
  return cache2 = { url, cssText }, cssFetchCache[url] = cache2, cache2;
}
async function embedFonts(data, options) {
  let cssText = data.cssText;
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g, loadFonts = (cssText.match(/url\([^)]+\)/g) || []).map(async (loc) => {
    let url = loc.replace(regexUrl, "$1");
    return url.startsWith("https://") || (url = new URL(url, data.url).href), fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => (cssText = cssText.replace(loc, `url(${result})`), [loc, result]));
  });
  return Promise.all(loadFonts).then(() => cssText);
}
function parseCSS(source) {
  if (source == null)
    return [];
  const result = [], commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
  let cssText = source.replace(commentsRegex, "");
  const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const matches2 = keyframesRegex.exec(cssText);
    if (matches2 === null)
      break;
    result.push(matches2[0]);
  }
  cssText = cssText.replace(keyframesRegex, "");
  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", unifiedRegex = new RegExp(combinedCSSRegex, "gi");
  for (; ; ) {
    let matches2 = importRegex.exec(cssText);
    if (matches2 === null) {
      if (matches2 = unifiedRegex.exec(cssText), matches2 === null)
        break;
      importRegex.lastIndex = unifiedRegex.lastIndex;
    } else
      unifiedRegex.lastIndex = importRegex.lastIndex;
    result.push(matches2[0]);
  }
  return result;
}
async function getCSSRules(styleSheets, options) {
  const ret = [], deferreds = [];
  return styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet)
      try {
        toArray(sheet.cssRules || []).forEach((item, index2) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index2 + 1;
            const url = item.href, deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              try {
                sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
              } catch (error) {
                console.error("Error inserting rule from remote css", {
                  rule,
                  error
                });
              }
            })).catch((e2) => {
              console.error("Error loading remote css", e2.toString());
            });
            deferreds.push(deferred);
          }
        });
      } catch (e2) {
        const inline2 = styleSheets.find((a2) => a2.href == null) || document.styleSheets[0];
        sheet.href != null && deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
          inline2.insertRule(rule, sheet.cssRules.length);
        })).catch((err) => {
          console.error("Error loading remote stylesheet", err);
        })), console.error("Error inlining remote css file", e2);
      }
  }), Promise.all(deferreds).then(() => (styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet)
      try {
        toArray(sheet.cssRules || []).forEach((item) => {
          ret.push(item);
        });
      } catch (e2) {
        console.error(`Error while reading CSS rules from ${sheet.href}`, e2);
      }
  }), ret));
}
function getWebFontRules(cssRules) {
  return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
}
async function parseWebFontRules(node, options) {
  if (node.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const styleSheets = toArray(node.ownerDocument.styleSheets), cssRules = await getCSSRules(styleSheets, options);
  return getWebFontRules(cssRules);
}
async function getWebFontCSS(node, options) {
  const rules = await parseWebFontRules(node, options);
  return (await Promise.all(rules.map((rule) => {
    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
    return embedResources(rule.cssText, baseUrl, options);
  }))).join(`
`);
}
async function embedWebFonts(clonedNode, options) {
  const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
  if (cssText) {
    const styleNode = document.createElement("style"), sytleContent = document.createTextNode(cssText);
    styleNode.appendChild(sytleContent), clonedNode.firstChild ? clonedNode.insertBefore(styleNode, clonedNode.firstChild) : clonedNode.appendChild(styleNode);
  }
}
async function toSvg(node, options = {}) {
  const { width, height } = getImageSize(node, options), clonedNode = await cloneNode(node, options, !0);
  return await embedWebFonts(clonedNode, options), await embedImages(clonedNode, options), applyStyle(clonedNode, options), await nodeToDataURL(clonedNode, width, height);
}
async function toCanvas(node, options = {}) {
  const { width, height } = getImageSize(node, options), svg = await toSvg(node, options), img = await createImage(svg), canvas = document.createElement("canvas"), context = canvas.getContext("2d"), ratio = options.pixelRatio || getPixelRatio(), canvasWidth = options.canvasWidth || width, canvasHeight = options.canvasHeight || height;
  return canvas.width = canvasWidth * ratio, canvas.height = canvasHeight * ratio, options.skipAutoScale || checkCanvasDimensions(canvas), canvas.style.width = `${canvasWidth}`, canvas.style.height = `${canvasHeight}`, options.backgroundColor && (context.fillStyle = options.backgroundColor, context.fillRect(0, 0, canvas.width, canvas.height)), context.drawImage(img, 0, 0, canvas.width, canvas.height), canvas;
}
async function toBlob(node, options = {}) {
  const canvas = await toCanvas(node, options);
  return await canvasToBlob(canvas);
}
function z(e2, t2 = "Assertion error") {
  if (!e2)
    throw Error(t2);
}
function B({
  group: e2
}) {
  const { orientation: t2, panels: n2 } = e2;
  return n2.reduce((o, r2) => (o += t2 === "horizontal" ? r2.element.offsetWidth : r2.element.offsetHeight, o), 0);
}
function se(e2, t2) {
  return t2.sort(
    e2 === "horizontal" ? Qe : et
  );
}
function Qe(e2, t2) {
  const n2 = e2.element.offsetLeft - t2.element.offsetLeft;
  return n2 !== 0 ? n2 : e2.element.offsetWidth - t2.element.offsetWidth;
}
function et(e2, t2) {
  const n2 = e2.element.offsetTop - t2.element.offsetTop;
  return n2 !== 0 ? n2 : e2.element.offsetHeight - t2.element.offsetHeight;
}
function Ie(e2, t2) {
  return {
    x: e2.x >= t2.left && e2.x <= t2.right ? 0 : Math.min(
      Math.abs(e2.x - t2.left),
      Math.abs(e2.x - t2.right)
    ),
    y: e2.y >= t2.top && e2.y <= t2.bottom ? 0 : Math.min(
      Math.abs(e2.y - t2.top),
      Math.abs(e2.y - t2.bottom)
    )
  };
}
function tt({
  orientation: e2,
  rects: t2,
  targetRect: n2
}) {
  const o = {
    x: n2.x + n2.width / 2,
    y: n2.y + n2.height / 2
  };
  let r2, a2 = Number.MAX_VALUE;
  for (const l of t2) {
    const { x: i2, y: s } = Ie(o, l), u = e2 === "horizontal" ? i2 : s;
    u < a2 && (a2 = u, r2 = l);
  }
  return z(r2, "No rect found"), r2;
}
function Ge(e2) {
  const { element: t2, orientation: n2, panels: o, separators: r2 } = e2, a2 = se(
    n2,
    Array.from(t2.children).filter((c) => c instanceof HTMLElement).map((c) => ({ element: c }))
  ).map(({ element: c }) => c), l = [];
  let i2 = !1, s, u = [];
  for (const c of a2)
    if (c.hasAttribute("data-panel")) {
      const h = o.find(
        (m2) => m2.element === c
      );
      if (h) {
        if (s) {
          const m2 = s.element.getBoundingClientRect(), p = c.getBoundingClientRect();
          let f;
          if (i2) {
            const d = n2 === "horizontal" ? new DOMRect(m2.right, m2.top, 0, m2.height) : new DOMRect(
              m2.left,
              m2.bottom,
              m2.width,
              0
            ), y2 = n2 === "horizontal" ? new DOMRect(p.left, p.top, 0, p.height) : new DOMRect(p.left, p.top, p.width, 0);
            switch (u.length) {
              case 0: {
                f = [
                  d,
                  y2
                ];
                break;
              }
              case 1: {
                const v = u[0], S = tt({
                  orientation: n2,
                  rects: [m2, p],
                  targetRect: v.element.getBoundingClientRect()
                });
                f = [
                  v,
                  S === m2 ? y2 : d
                ];
                break;
              }
              default: {
                f = u;
                break;
              }
            }
          } else
            u.length ? f = u : f = [
              n2 === "horizontal" ? new DOMRect(
                m2.right,
                p.top,
                p.left - m2.right,
                p.height
              ) : new DOMRect(
                p.left,
                m2.bottom,
                p.width,
                p.top - m2.bottom
              )
            ];
          for (const d of f)
            l.push({
              group: e2,
              groupSize: B({ group: e2 }),
              panels: [s, h],
              separator: "width" in d ? void 0 : d,
              rect: "width" in d ? d : d.element.getBoundingClientRect()
            });
        }
        i2 = !1, s = h, u = [];
      }
    } else if (c.hasAttribute("data-separator")) {
      const h = r2.find(
        (m2) => m2.element === c
      );
      h ? u.push(h) : (s = void 0, u = []);
    } else
      i2 = !0;
  return l;
}
function nt(e2, t2) {
  const n2 = getComputedStyle(e2), o = parseFloat(n2.fontSize);
  return t2 * o;
}
function ot(e2, t2) {
  const n2 = getComputedStyle(e2.ownerDocument.body), o = parseFloat(n2.fontSize);
  return t2 * o;
}
function it(e2) {
  return e2 / 100 * window.innerHeight;
}
function rt(e2) {
  return e2 / 100 * window.innerWidth;
}
function st(e2) {
  switch (typeof e2) {
    case "number":
      return [e2, "px"];
    case "string": {
      const t2 = parseFloat(e2);
      return e2.endsWith("%") ? [t2, "%"] : e2.endsWith("px") ? [t2, "px"] : e2.endsWith("rem") ? [t2, "rem"] : e2.endsWith("em") ? [t2, "em"] : e2.endsWith("vh") ? [t2, "vh"] : e2.endsWith("vw") ? [t2, "vw"] : [t2, "%"];
    }
  }
}
function te({
  groupSize: e2,
  panelElement: t2,
  styleProp: n2
}) {
  let o;
  const [r2, a2] = st(n2);
  switch (a2) {
    case "%": {
      o = r2 / 100 * e2;
      break;
    }
    case "px": {
      o = r2;
      break;
    }
    case "rem": {
      o = ot(t2, r2);
      break;
    }
    case "em": {
      o = nt(t2, r2);
      break;
    }
    case "vh": {
      o = it(r2);
      break;
    }
    case "vw": {
      o = rt(r2);
      break;
    }
  }
  return o;
}
function I(e2) {
  return parseFloat(e2.toFixed(3));
}
function ye(e2) {
  const { panels: t2 } = e2, n2 = B({ group: e2 });
  return n2 === 0 ? t2.map((o) => ({
    collapsedSize: 0,
    collapsible: o.panelConstraints.collapsible === !0,
    defaultSize: void 0,
    minSize: 0,
    maxSize: 100,
    panelId: o.id
  })) : t2.map((o) => {
    const { element: r2, panelConstraints: a2 } = o;
    let l = 0;
    if (a2.collapsedSize) {
      const c = te({
        groupSize: n2,
        panelElement: r2,
        styleProp: a2.collapsedSize
      });
      l = I(c / n2 * 100);
    }
    let i2;
    if (a2.defaultSize) {
      const c = te({
        groupSize: n2,
        panelElement: r2,
        styleProp: a2.defaultSize
      });
      i2 = I(c / n2 * 100);
    }
    let s = 0;
    if (a2.minSize) {
      const c = te({
        groupSize: n2,
        panelElement: r2,
        styleProp: a2.minSize
      });
      s = I(c / n2 * 100);
    }
    let u = 100;
    if (a2.maxSize) {
      const c = te({
        groupSize: n2,
        panelElement: r2,
        styleProp: a2.maxSize
      });
      u = I(c / n2 * 100);
    }
    return {
      collapsedSize: l,
      collapsible: a2.collapsible === !0,
      defaultSize: i2,
      minSize: s,
      maxSize: u,
      panelId: o.id
    };
  });
}
class at {
  #e = {};
  addListener(t2, n2) {
    const o = this.#e[t2];
    return o === void 0 ? this.#e[t2] = [n2] : o.includes(n2) || o.push(n2), () => {
      this.removeListener(t2, n2);
    };
  }
  emit(t2, n2) {
    const o = this.#e[t2];
    if (o !== void 0)
      if (o.length === 1)
        o[0].call(null, n2);
      else {
        let r2 = !1, a2 = null;
        const l = Array.from(o);
        for (let i2 = 0; i2 < l.length; i2++) {
          const s = l[i2];
          try {
            s.call(null, n2);
          } catch (u) {
            a2 === null && (r2 = !0, a2 = u);
          }
        }
        if (r2)
          throw a2;
      }
  }
  removeAllListeners() {
    this.#e = {};
  }
  removeListener(t2, n2) {
    const o = this.#e[t2];
    if (o !== void 0) {
      const r2 = o.indexOf(n2);
      r2 >= 0 && o.splice(r2, 1);
    }
  }
}
function P(e2, t2, n2 = 0) {
  return Math.abs(I(e2) - I(t2)) <= n2;
}
let R = {
  cursorFlags: 0,
  interactionState: {
    state: "inactive"
  },
  mountedGroups: /* @__PURE__ */ new Map()
};
const _ = new at();
function D() {
  return R;
}
function E(e2) {
  const t2 = typeof e2 == "function" ? e2(R) : e2;
  if (R === t2)
    return R;
  const n2 = R;
  return R = {
    ...R,
    ...t2
  }, t2.cursorFlags !== void 0 && _.emit("cursorFlagsChange", R.cursorFlags), t2.interactionState !== void 0 && _.emit("interactionStateChange", R.interactionState), t2.mountedGroups !== void 0 && (R.mountedGroups.forEach((o, r2) => {
    o.derivedPanelConstraints.forEach((a2) => {
      if (a2.collapsible) {
        const { layout: l } = n2.mountedGroups.get(r2) ?? {};
        if (l) {
          const i2 = P(
            a2.collapsedSize,
            o.layout[a2.panelId]
          ), s = P(
            a2.collapsedSize,
            l[a2.panelId]
          );
          i2 && !s && (r2.inMemoryLastExpandedPanelSizes[a2.panelId] = l[a2.panelId]);
        }
      }
    });
  }), _.emit("mountedGroupsChange", R.mountedGroups)), R;
}
const lt = (e2) => e2, ie = () => {
}, De = 1, Oe = 2, Te = 4, _e = 8, ge = {
  coarse: 10,
  precise: 5
};
function ut({
  cursorFlags: e2,
  groups: t2,
  state: n2
}) {
  let o = 0, r2 = 0;
  switch (n2) {
    case "active":
    case "hover":
      t2.forEach((a2) => {
        if (!a2.disableCursor)
          switch (a2.orientation) {
            case "horizontal": {
              o++;
              break;
            }
            case "vertical": {
              r2++;
              break;
            }
          }
      });
  }
  if (o === 0 && r2 === 0)
    return null;
  switch (n2) {
    case "active": {
      const a2 = (e2 & De) !== 0, l = (e2 & Oe) !== 0, i2 = (e2 & Te) !== 0, s = (e2 & _e) !== 0;
      if (e2) {
        if (a2)
          return i2 ? "se-resize" : s ? "ne-resize" : "e-resize";
        if (l)
          return i2 ? "sw-resize" : s ? "nw-resize" : "w-resize";
        if (i2)
          return "s-resize";
        if (s)
          return "n-resize";
      }
      break;
    }
  }
  return o > 0 && r2 > 0 ? "move" : o > 0 ? "ew-resize" : "ns-resize";
}
let re, G;
function le() {
  G === void 0 && (G = new CSSStyleSheet(), document.adoptedStyleSheets = [G]);
  const { cursorFlags: e2, interactionState: t2 } = D();
  switch (t2.state) {
    case "active":
    case "hover": {
      const n2 = ut({
        cursorFlags: e2,
        groups: t2.hitRegions.map((r2) => r2.group),
        state: t2.state
      }), o = `*{cursor: ${n2} !important; ${t2.state === "active" ? "touch-action: none;" : ""} }`;
      if (re === o)
        return;
      re = o, n2 ? G.cssRules.length === 0 ? G.insertRule(o) : G.replaceSync(o) : G.cssRules.length === 1 && G.deleteRule(0);
      break;
    }
    case "inactive": {
      re = void 0, G.cssRules.length === 1 && G.deleteRule(0);
      break;
    }
  }
}
function ct(e2, t2) {
  if (e2.length !== t2.length)
    return !1;
  for (let n2 = 0; n2 < e2.length; n2++)
    if (e2[n2] != t2[n2])
      return !1;
  return !0;
}
function X(e2, t2) {
  return P(e2, t2) ? 0 : e2 > t2 ? 1 : -1;
}
function W({
  panelConstraints: e2,
  size: t2
}) {
  const {
    collapsedSize: n2 = 0,
    collapsible: o,
    maxSize: r2 = 100,
    minSize: a2 = 0
  } = e2;
  if (X(t2, a2) < 0)
    if (o) {
      const l = (n2 + a2) / 2;
      X(t2, l) < 0 ? t2 = n2 : t2 = a2;
    } else
      t2 = a2;
  return t2 = Math.min(r2, t2), t2 = I(t2), t2;
}
function Y({
  delta: e2,
  initialLayout: t2,
  panelConstraints: n2,
  pivotIndices: o,
  prevLayout: r2,
  trigger: a2
}) {
  if (P(e2, 0))
    return t2;
  const l = Object.values(t2), i2 = Object.values(r2), s = [...l], [u, c] = o;
  z(u != null, "Invalid first pivot index"), z(c != null, "Invalid second pivot index");
  let h = 0;
  if (a2 === "keyboard") {
    {
      const f = e2 < 0 ? c : u, d = n2[f];
      z(
        d,
        `Panel constraints not found for index ${f}`
      );
      const {
        collapsedSize: y2 = 0,
        collapsible: v,
        minSize: S = 0
      } = d;
      if (v) {
        const x2 = l[f];
        if (z(
          x2 != null,
          `Previous layout not found for panel index ${f}`
        ), P(x2, y2)) {
          const g = S - x2;
          X(g, Math.abs(e2)) > 0 && (e2 = e2 < 0 ? 0 - g : g);
        }
      }
    }
    {
      const f = e2 < 0 ? u : c, d = n2[f];
      z(
        d,
        `No panel constraints found for index ${f}`
      );
      const {
        collapsedSize: y2 = 0,
        collapsible: v,
        minSize: S = 0
      } = d;
      if (v) {
        const x2 = l[f];
        if (z(
          x2 != null,
          `Previous layout not found for panel index ${f}`
        ), P(x2, S)) {
          const g = x2 - y2;
          X(g, Math.abs(e2)) > 0 && (e2 = e2 < 0 ? 0 - g : g);
        }
      }
    }
  }
  {
    const f = e2 < 0 ? 1 : -1;
    let d = e2 < 0 ? c : u, y2 = 0;
    for (; ; ) {
      const S = l[d];
      z(
        S != null,
        `Previous layout not found for panel index ${d}`
      );
      const g = W({
        panelConstraints: n2[d],
        size: 100
      }) - S;
      if (y2 += g, d += f, d < 0 || d >= n2.length)
        break;
    }
    const v = Math.min(Math.abs(e2), Math.abs(y2));
    e2 = e2 < 0 ? 0 - v : v;
  }
  {
    let d = e2 < 0 ? u : c;
    for (; d >= 0 && d < n2.length; ) {
      const y2 = Math.abs(e2) - Math.abs(h), v = l[d];
      z(
        v != null,
        `Previous layout not found for panel index ${d}`
      );
      const S = v - y2, x2 = W({
        panelConstraints: n2[d],
        size: S
      });
      if (!P(v, x2) && (h += v - x2, s[d] = x2, h.toFixed(3).localeCompare(Math.abs(e2).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e2 < 0 ? d-- : d++;
    }
  }
  if (ct(i2, s))
    return r2;
  {
    const f = e2 < 0 ? c : u, d = l[f];
    z(
      d != null,
      `Previous layout not found for panel index ${f}`
    );
    const y2 = d + h, v = W({
      panelConstraints: n2[f],
      size: y2
    });
    if (s[f] = v, !P(v, y2)) {
      let S = y2 - v, g = e2 < 0 ? c : u;
      for (; g >= 0 && g < n2.length; ) {
        const b = s[g];
        z(
          b != null,
          `Previous layout not found for panel index ${g}`
        );
        const L = b + S, C = W({
          panelConstraints: n2[g],
          size: L
        });
        if (P(b, C) || (S -= C - b, s[g] = C), P(S, 0))
          break;
        e2 > 0 ? g-- : g++;
      }
    }
  }
  const m2 = Object.values(s).reduce(
    (f, d) => d + f,
    0
  );
  if (!P(m2, 100, 0.1))
    return r2;
  const p = Object.keys(r2);
  return s.reduce((f, d, y2) => (f[p[y2]] = d, f), {});
}
function U(e2, t2) {
  if (Object.keys(e2).length !== Object.keys(t2).length)
    return !1;
  for (const n2 in e2)
    if (t2[n2] === void 0 || X(e2[n2], t2[n2]) !== 0)
      return !1;
  return !0;
}
function Ae({
  event: e2,
  hitRegions: t2,
  initialLayoutMap: n2,
  mountedGroups: o,
  pointerDownAtPoint: r2
}) {
  let a2 = 0;
  const l = new Map(o);
  t2.forEach((i2) => {
    const { group: s, groupSize: u } = i2, { disableCursor: c, orientation: h, panels: m2 } = s;
    let p = 0;
    r2 ? h === "horizontal" ? p = (e2.clientX - r2.x) / u * 100 : p = (e2.clientY - r2.y) / u * 100 : h === "horizontal" ? p = e2.clientX < 0 ? -100 : 100 : p = e2.clientY < 0 ? -100 : 100;
    const f = n2.get(s), {
      defaultLayoutDeferred: d,
      derivedPanelConstraints: y2,
      layout: v,
      separatorToPanels: S
    } = o.get(s) ?? { defaultLayoutDeferred: !1 };
    if (y2 && f && v && S) {
      const x2 = Y({
        delta: p,
        initialLayout: f,
        panelConstraints: y2,
        pivotIndices: i2.panels.map((g) => m2.indexOf(g)),
        prevLayout: v,
        trigger: "mouse-or-touch"
      });
      if (U(x2, v)) {
        if (p !== 0 && !c)
          switch (h) {
            case "horizontal": {
              a2 |= p < 0 ? De : Oe;
              break;
            }
            case "vertical": {
              a2 |= p < 0 ? Te : _e;
              break;
            }
          }
      } else {
        l.set(i2.group, {
          defaultLayoutDeferred: d,
          derivedPanelConstraints: y2,
          layout: x2,
          separatorToPanels: S
        });
        const g = i2.group.panels.map(({ id: b }) => b).join(",");
        i2.group.inMemoryLayouts[g] = x2;
      }
    }
  }), E({
    cursorFlags: a2,
    mountedGroups: l
  }), le();
}
function ve(e2) {
  if (e2.defaultPrevented || e2.relatedTarget !== null || e2.clientX === 0 && e2.clientY === 0)
    return;
  const { interactionState: t2, mountedGroups: n2 } = D();
  t2.state === "active" && t2.hitRegions.forEach((o) => {
    e2.currentTarget === o.group.element && Ae({
      event: e2,
      hitRegions: t2.hitRegions,
      initialLayoutMap: t2.initialLayoutMap,
      mountedGroups: n2
    });
  });
}
function oe(e2) {
  const t2 = e2.parentElement;
  z(t2, "Parent group element not found");
  const { mountedGroups: n2 } = D();
  for (const [o] of n2)
    if (o.element === t2)
      return o;
  throw Error("Could not find parent Group for separator element");
}
function A({
  layout: e2,
  panelConstraints: t2
}) {
  const o = [...Object.values(e2)], r2 = o.reduce(
    (i2, s) => i2 + s,
    0
  );
  if (o.length !== t2.length)
    throw Error(
      `Invalid ${t2.length} panel layout: ${o.map((i2) => `${i2}%`).join(", ")}`
    );
  if (!P(r2, 100) && o.length > 0)
    for (let i2 = 0; i2 < t2.length; i2++) {
      const s = o[i2];
      z(s != null, `No layout data found for index ${i2}`);
      const u = 100 / r2 * s;
      o[i2] = u;
    }
  let a2 = 0;
  for (let i2 = 0; i2 < t2.length; i2++) {
    const s = o[i2];
    z(s != null, `No layout data found for index ${i2}`);
    const u = W({
      panelConstraints: t2[i2],
      size: s
    });
    s != u && (a2 += s - u, o[i2] = u);
  }
  if (!P(a2, 0))
    for (let i2 = 0; i2 < t2.length; i2++) {
      const s = o[i2];
      z(s != null, `No layout data found for index ${i2}`);
      const u = s + a2, c = W({
        panelConstraints: t2[i2],
        size: u
      });
      if (s !== c && (a2 -= c - s, o[i2] = c, P(a2, 0)))
        break;
    }
  const l = Object.keys(e2);
  return o.reduce((i2, s, u) => (i2[l[u]] = s, i2), {});
}
function Ne({
  groupId: e2
}) {
  const t2 = () => {
    const { mountedGroups: n2 } = D();
    for (const [o, r2] of n2)
      if (o.id === e2)
        return { group: o, ...r2 };
    throw Error(`Could not find Group with id "${e2}"`);
  };
  return {
    getLayout() {
      const { defaultLayoutDeferred: n2, layout: o } = t2();
      return n2 ? {} : o;
    },
    setLayout(n2) {
      const {
        defaultLayoutDeferred: o,
        derivedPanelConstraints: r2,
        group: a2,
        layout: l,
        separatorToPanels: i2
      } = t2(), s = A({
        layout: n2,
        panelConstraints: r2
      });
      return o ? l : (U(l, s) || E((u) => ({
        mountedGroups: new Map(u.mountedGroups).set(a2, {
          defaultLayoutDeferred: o,
          derivedPanelConstraints: r2,
          layout: s,
          separatorToPanels: i2
        })
      })), s);
    }
  };
}
function $e(e2) {
  const { mountedGroups: t2 } = D(), n2 = t2.get(e2);
  return z(n2, `Mounted Group ${e2.id} not found`), n2;
}
function T(e2, t2) {
  const n2 = oe(e2), o = $e(n2), r2 = n2.separators.find(
    (h) => h.element === e2
  );
  z(r2, "Matching separator not found");
  const a2 = o.separatorToPanels.get(r2);
  z(a2, "Matching panels not found");
  const l = a2.map((h) => n2.panels.indexOf(h)), s = Ne({ groupId: n2.id }).getLayout(), u = Y({
    delta: t2,
    initialLayout: s,
    panelConstraints: o.derivedPanelConstraints,
    pivotIndices: l,
    prevLayout: s,
    trigger: "keyboard"
  }), c = A({
    layout: u,
    panelConstraints: o.derivedPanelConstraints
  });
  U(s, c) || E((h) => ({
    mountedGroups: new Map(h.mountedGroups).set(n2, {
      defaultLayoutDeferred: o.defaultLayoutDeferred,
      derivedPanelConstraints: o.derivedPanelConstraints,
      layout: c,
      separatorToPanels: o.separatorToPanels
    })
  }));
}
function Se(e2) {
  if (e2.defaultPrevented)
    return;
  const t2 = e2.currentTarget, n2 = oe(t2);
  if (!n2.disabled)
    switch (e2.key) {
      case "ArrowDown": {
        e2.preventDefault(), n2.orientation === "vertical" && T(t2, 5);
        break;
      }
      case "ArrowLeft": {
        e2.preventDefault(), n2.orientation === "horizontal" && T(t2, -5);
        break;
      }
      case "ArrowRight": {
        e2.preventDefault(), n2.orientation === "horizontal" && T(t2, 5);
        break;
      }
      case "ArrowUp": {
        e2.preventDefault(), n2.orientation === "vertical" && T(t2, -5);
        break;
      }
      case "End": {
        e2.preventDefault(), T(t2, 100);
        break;
      }
      case "Enter": {
        e2.preventDefault();
        const o = oe(t2), { derivedPanelConstraints: r2, layout: a2, separatorToPanels: l } = $e(o), i2 = o.separators.find(
          (h) => h.element === t2
        );
        z(i2, "Matching separator not found");
        const s = l.get(i2);
        z(s, "Matching panels not found");
        const u = s[0], c = r2.find(
          (h) => h.panelId === u.id
        );
        if (z(c, "Panel metadata not found"), c.collapsible) {
          const h = a2[u.id], m2 = c.collapsedSize === h ? o.inMemoryLastExpandedPanelSizes[u.id] ?? c.minSize : c.collapsedSize;
          T(t2, m2 - h);
        }
        break;
      }
      case "F6": {
        e2.preventDefault();
        const r2 = oe(t2).separators.map(
          (s) => s.element
        ), a2 = Array.from(r2).findIndex(
          (s) => s === e2.currentTarget
        );
        z(a2 !== null, "Index not found");
        const l = e2.shiftKey ? a2 > 0 ? a2 - 1 : r2.length - 1 : a2 + 1 < r2.length ? a2 + 1 : 0;
        r2[l].focus();
        break;
      }
      case "Home": {
        e2.preventDefault(), T(t2, -100);
        break;
      }
    }
}
function ft(e2, t2, n2) {
  let o, r2 = {
    x: 1 / 0,
    y: 1 / 0
  };
  for (const a2 of t2) {
    const l = Ie(n2, a2.rect);
    switch (e2) {
      case "horizontal": {
        l.x <= r2.x && (o = a2, r2 = l);
        break;
      }
      case "vertical": {
        l.y <= r2.y && (o = a2, r2 = l);
        break;
      }
    }
  }
  return o ? {
    distance: r2,
    hitRegion: o
  } : void 0;
}
let ne;
function dt() {
  return ne === void 0 && (typeof matchMedia == "function" ? ne = !!matchMedia("(pointer:coarse)").matches : ne = !1), ne;
}
function pt(e2, t2) {
  if (e2 === t2) throw new Error("Cannot compare node with itself");
  const n2 = {
    a: we(e2),
    b: we(t2)
  };
  let o;
  for (; n2.a.at(-1) === n2.b.at(-1); )
    e2 = n2.a.pop(), t2 = n2.b.pop(), o = e2;
  z(
    o,
    "Stacking order can only be calculated for elements with a common ancestor"
  );
  const r2 = {
    a: ze(xe(n2.a)),
    b: ze(xe(n2.b))
  };
  if (r2.a === r2.b) {
    const a2 = o.childNodes, l = {
      a: n2.a.at(-1),
      b: n2.b.at(-1)
    };
    let i2 = a2.length;
    for (; i2--; ) {
      const s = a2[i2];
      if (s === l.a) return 1;
      if (s === l.b) return -1;
    }
  }
  return Math.sign(r2.a - r2.b);
}
const ht = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function mt(e2) {
  const t2 = getComputedStyle(Fe(e2) ?? e2).display;
  return t2 === "flex" || t2 === "inline-flex";
}
function yt(e2) {
  const t2 = getComputedStyle(e2);
  return !!(t2.position === "fixed" || t2.zIndex !== "auto" && (t2.position !== "static" || mt(e2)) || +t2.opacity < 1 || "transform" in t2 && t2.transform !== "none" || "webkitTransform" in t2 && t2.webkitTransform !== "none" || "mixBlendMode" in t2 && t2.mixBlendMode !== "normal" || "filter" in t2 && t2.filter !== "none" || "webkitFilter" in t2 && t2.webkitFilter !== "none" || "isolation" in t2 && t2.isolation === "isolate" || ht.test(t2.willChange) || t2.webkitOverflowScrolling === "touch");
}
function xe(e2) {
  let t2 = e2.length;
  for (; t2--; ) {
    const n2 = e2[t2];
    if (z(n2, "Missing node"), yt(n2)) return n2;
  }
  return null;
}
function ze(e2) {
  return e2 && Number(getComputedStyle(e2).zIndex) || 0;
}
function we(e2) {
  const t2 = [];
  for (; e2; )
    t2.push(e2), e2 = Fe(e2);
  return t2;
}
function Fe(e2) {
  const { parentNode: t2 } = e2;
  return t2 && t2 instanceof ShadowRoot ? t2.host : t2;
}
function gt(e2, t2) {
  return e2.x < t2.x + t2.width && e2.x + e2.width > t2.x && e2.y < t2.y + t2.height && e2.y + e2.height > t2.y;
}
function vt({
  groupElement: e2,
  hitRegion: t2,
  pointerEventTarget: n2
}) {
  if (!(n2 instanceof HTMLElement) || n2.contains(e2) || e2.contains(n2))
    return !0;
  if (pt(n2, e2) > 0) {
    let o = n2;
    for (; o; ) {
      if (o.contains(e2))
        return !0;
      if (gt(o.getBoundingClientRect(), t2))
        return !1;
      o = o.parentElement;
    }
  }
  return !0;
}
function He(e2, t2) {
  const n2 = [];
  return t2.forEach((o, r2) => {
    if (r2.disabled)
      return;
    const a2 = dt() ? ge.coarse : ge.precise, l = Ge(r2), i2 = ft(r2.orientation, l, {
      x: e2.clientX,
      y: e2.clientY
    });
    i2 && i2.distance.x <= a2 && i2.distance.y <= a2 && vt({
      groupElement: r2.element,
      hitRegion: i2.hitRegion.rect,
      pointerEventTarget: e2.target
    }) && n2.push(i2.hitRegion);
  }), n2;
}
function be(e2) {
  if (e2.defaultPrevented)
    return;
  const { mountedGroups: t2 } = D(), n2 = He(e2, t2), o = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Set(), a2 = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
  let i2 = !1;
  n2.forEach((s) => {
    o.add(s.group), s.panels.forEach((c) => {
      r2.add(c);
    }), s.separator && (a2.add(s.separator), i2 || (i2 = !0, s.separator.element.focus()));
    const u = t2.get(s.group);
    u && l.set(s.group, u.layout);
  }), E({
    interactionState: {
      hitRegions: n2,
      initialLayoutMap: l,
      pointerDownAtPoint: { x: e2.clientX, y: e2.clientY },
      state: "active"
    }
  }), n2.length && e2.preventDefault();
}
function Le(e2) {
  if (e2.defaultPrevented)
    return;
  const { interactionState: t2, mountedGroups: n2 } = D();
  switch (t2.state) {
    case "active": {
      if (
        // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
        e2.type !== "pointerleave" && e2.buttons === 0
      ) {
        E(
          (o) => o.interactionState.state === "inactive" ? o : {
            cursorFlags: 0,
            interactionState: {
              state: "inactive"
            }
          }
        );
        return;
      }
      Ae({
        event: e2,
        hitRegions: t2.hitRegions,
        initialLayoutMap: t2.initialLayoutMap,
        mountedGroups: n2,
        pointerDownAtPoint: t2.pointerDownAtPoint
      });
      break;
    }
    default: {
      const o = He(e2, n2);
      o.length === 0 ? t2.state !== "inactive" && E({
        interactionState: { state: "inactive" }
      }) : E({
        interactionState: {
          hitRegions: o,
          state: "hover"
        }
      }), le();
      break;
    }
  }
}
function Pe(e2) {
  if (e2.defaultPrevented)
    return;
  e2.preventDefault();
  const { interactionState: t2 } = D();
  t2.state === "active" && (E({
    cursorFlags: 0,
    interactionState: {
      state: "inactive"
    }
  }), le());
}
function Ce(e2) {
  let t2 = 0, n2 = 0;
  const o = {};
  for (const a2 of e2)
    if (a2.defaultSize !== void 0) {
      t2++;
      const l = I(a2.defaultSize);
      n2 += l, o[a2.panelId] = l;
    } else
      o[a2.panelId] = void 0;
  const r2 = e2.length - t2;
  if (r2 !== 0) {
    const a2 = I((100 - n2) / r2);
    for (const l of e2)
      l.defaultSize === void 0 && (o[l.panelId] = a2);
  }
  return o;
}
function St(e2, t2, n2) {
  const o = n2[0];
  if (!o)
    return;
  const r2 = e2.panels.find((l) => l.element === t2);
  if (!r2 || !r2.onResize)
    return;
  const a2 = B({ group: e2 });
  r2.onResize(
    {
      asPercentage: I(
        o.inlineSize / a2 * 100
      ),
      inPixels: o.inlineSize
    },
    r2.id
  );
}
function xt(e2, t2) {
  if (Object.keys(e2).length !== Object.keys(t2).length)
    return !1;
  for (const o in e2)
    if (e2[o] !== t2[o])
      return !1;
  return !0;
}
function zt(e2) {
  let t2 = !0;
  const n2 = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r2 = new ResizeObserver((p) => {
    for (const f of p) {
      const { borderBoxSize: d, target: y2 } = f;
      if (y2 === e2.element) {
        if (t2) {
          if (B({ group: e2 }) === 0)
            return;
          E((S) => {
            const x2 = S.mountedGroups.get(e2);
            if (x2) {
              const g = ye(e2), b = x2.defaultLayoutDeferred ? Ce(g) : x2.layout, L = A({
                layout: b,
                panelConstraints: g
              });
              return !x2.defaultLayoutDeferred && U(b, L) && xt(
                x2.derivedPanelConstraints,
                g
              ) ? S : {
                mountedGroups: new Map(S.mountedGroups).set(e2, {
                  defaultLayoutDeferred: !1,
                  derivedPanelConstraints: g,
                  layout: L,
                  separatorToPanels: x2.separatorToPanels
                })
              };
            }
            return S;
          });
        }
      } else
        St(e2, y2, d);
    }
  });
  r2.observe(e2.element), e2.panels.forEach((p) => {
    z(
      !n2.has(p.id),
      `Panel ids must be unique; id "${p.id}" was used more than once`
    ), n2.add(p.id), p.onResize && r2.observe(p.element);
  });
  const a2 = B({ group: e2 }), l = ye(e2), i2 = e2.panels.map(({ id: p }) => p).join(",");
  let s = e2.defaultLayout;
  s && e2.panels.length !== Object.keys(s).length && (s = void 0);
  const u = e2.inMemoryLayouts[i2] ?? s ?? Ce(l), c = A({
    layout: u,
    panelConstraints: l
  }), h = Ge(e2), m2 = E((p) => {
    const f = /* @__PURE__ */ new Map();
    return h.forEach((d) => {
      d.separator && f.set(d.separator, d.panels);
    }), {
      mountedGroups: new Map(p.mountedGroups).set(e2, {
        defaultLayoutDeferred: a2 === 0,
        derivedPanelConstraints: l,
        layout: c,
        separatorToPanels: f
      })
    };
  });
  return e2.element.addEventListener("pointerleave", ve), e2.separators.forEach((p) => {
    z(
      !o.has(p.id),
      `Separator ids must be unique; id "${p.id}" was used more than once`
    ), o.add(p.id), p.element.addEventListener("keydown", Se);
  }), m2.mountedGroups.size === 1 && (window.addEventListener("pointerdown", be), window.addEventListener("pointermove", Le), window.addEventListener("pointerup", Pe)), function() {
    t2 = !1;
    const f = E((d) => {
      const y2 = new Map(d.mountedGroups);
      return y2.delete(e2), { mountedGroups: y2 };
    });
    e2.element.removeEventListener("pointerleave", ve), e2.separators.forEach((d) => {
      d.element.removeEventListener("keydown", Se);
    }), f.mountedGroups.size === 0 && (window.removeEventListener("pointerdown", be), window.removeEventListener("pointermove", Le), window.removeEventListener("pointerup", Pe)), r2.disconnect();
  };
}
function ue(e2) {
  const t2 = useId$2();
  return `${e2 ?? t2}`;
}
const N = typeof window < "u" ? useLayoutEffect$1 : useEffect;
function ce(e2) {
  const t2 = useRef(e2);
  return N(() => {
    t2.current = e2;
  }, [e2]), useCallback((n2) => t2.current?.(n2), [t2]);
}
function fe(...e2) {
  return ce((t2) => {
    e2.forEach((n2) => {
      if (n2)
        switch (typeof n2) {
          case "function": {
            n2(t2);
            break;
          }
          case "object": {
            n2.current = t2;
            break;
          }
        }
    });
  });
}
function wt(e2) {
  const t2 = useRef({ ...e2 });
  return N(() => {
    for (const n2 in e2)
      t2.current[n2] = e2[n2];
  }, [e2]), t2.current;
}
const je = "--react-resizable-panels--panel--pointer-events";
function We(e2, t2) {
  const n2 = e2.replace(/[^a-zA-Z0-9\-_]/g, ""), o = t2.replace(/[^a-zA-Z0-9\-_]/g, "");
  return `--react-resizable-panels--${n2}--${o}`;
}
const Be = createContext(null);
function bt(e2, t2) {
  const n2 = useRef({
    getLayout: () => ({}),
    setLayout: lt
  });
  useImperativeHandle(t2, () => n2.current, []), N(() => {
    Object.assign(
      n2.current,
      Ne({ groupId: e2 })
    );
  });
}
function Gt({
  children: e2,
  className: t2,
  defaultLayout: n2,
  disableCursor: o,
  disabled: r2,
  elementRef: a2,
  groupRef: l,
  id: i2,
  onLayoutChange: s,
  orientation: u = "horizontal",
  style: c,
  ...h
}) {
  const m2 = useRef({}), p = ce((w) => {
    U(m2.current, w) || (m2.current = w, s?.(w));
  }), f = ue(i2), [d, y2] = useState(!1), [v, S] = useState(null), [x2, g] = useState(n2 ?? {}), [b, L] = useState([]), [C, q] = useState([]), Z = useRef({
    lastExpandedPanelSizes: {},
    layouts: {}
  }), J = fe(S, a2);
  bt(f, l);
  const Q = useMemo(
    () => ({
      id: f,
      orientation: u,
      registerPanel: (w) => (L((M) => se(u, [...M, w])), () => {
        L((M) => M.filter((F) => F !== w));
      }),
      registerSeparator: (w) => (q(
        (M) => se(u, [...M, w])
      ), () => {
        q(
          (M) => M.filter((F) => F !== w)
        );
      })
    }),
    [f, u]
  ), $ = wt({
    defaultLayout: n2,
    disableCursor: o
  }), V = useRef(null);
  N(() => {
    if (v === null)
      return;
    const w = {
      defaultLayout: $.defaultLayout,
      disableCursor: !!$.disableCursor,
      disabled: !!r2,
      element: v,
      id: f,
      inMemoryLastExpandedPanelSizes: Z.current.lastExpandedPanelSizes,
      inMemoryLayouts: Z.current.layouts,
      orientation: u,
      panels: b,
      separators: C
    };
    V.current = w;
    const M = zt(w), he = D().mountedGroups.get(w);
    if (he) {
      const { defaultLayoutDeferred: H, derivedPanelConstraints: j, layout: ee } = he;
      !H && j.length > 0 && (g(ee), p?.(ee));
    }
    const Ue = _.addListener(
      "interactionStateChange",
      (H) => {
        H.state === "active" ? y2(
          H.hitRegions.some(
            (j) => j.group === w
          )
        ) : y2(!1);
      }
    ), Ve = _.addListener(
      "mountedGroupsChange",
      (H) => {
        const j = H.get(w);
        if (j) {
          const { defaultLayoutDeferred: ee, derivedPanelConstraints: Ke, layout: me } = j;
          if (ee || Ke.length === 0)
            return;
          g(me), p?.(me);
        }
      }
    );
    return () => {
      V.current = null, M(), Ue(), Ve();
    };
  }, [
    r2,
    v,
    f,
    p,
    u,
    b,
    C,
    $
  ]), useEffect(() => {
    const w = V.current;
    w && (w.defaultLayout = n2, w.disableCursor = !!o);
  });
  const pe = {
    [je]: d ? "none" : void 0
  };
  for (const w in x2) {
    const M = We(f, w), F = x2[w];
    pe[M] = F;
  }
  return /* @__PURE__ */ jsx(Be.Provider, { value: Q, children: /* @__PURE__ */ jsx(
    "div",
    {
      ...h,
      "aria-orientation": u,
      className: t2,
      "data-group": !0,
      "data-testid": f,
      id: f,
      ref: J,
      style: {
        ...c,
        ...pe,
        display: "flex",
        flexDirection: u === "horizontal" ? "row" : "column",
        flexWrap: "nowrap"
      },
      children: e2
    }
  ) });
}
function de() {
  const e2 = useContext(Be);
  return z(
    e2,
    "Group Context not found; did you render a Panel or Separator outside of a Group?"
  ), e2;
}
function Ct({
  groupId: e2,
  panelId: t2
}) {
  const n2 = () => {
    const { mountedGroups: i2 } = D();
    for (const [
      s,
      {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: c,
        layout: h,
        separatorToPanels: m2
      }
    ] of i2)
      if (s.id === e2)
        return {
          defaultLayoutDeferred: u,
          derivedPanelConstraints: c,
          group: s,
          layout: h,
          separatorToPanels: m2
        };
    throw Error(`Group ${e2} not found`);
  }, o = () => {
    const i2 = n2().derivedPanelConstraints.find(
      (s) => s.panelId === t2
    );
    if (i2 !== void 0)
      return i2;
    throw Error(`Panel constraints not found for Panel ${t2}`);
  }, r2 = () => {
    const i2 = n2().group.panels.find((s) => s.id === t2);
    if (i2 !== void 0)
      return i2;
    throw Error(`Layout not found for Panel ${t2}`);
  }, a2 = () => {
    const i2 = n2().layout[t2];
    if (i2 !== void 0)
      return i2;
    throw Error(`Layout not found for Panel ${t2}`);
  }, l = (i2) => {
    const s = a2();
    if (i2 === s)
      return;
    const {
      defaultLayoutDeferred: u,
      derivedPanelConstraints: c,
      group: h,
      layout: m2,
      separatorToPanels: p
    } = n2(), f = h.panels.findIndex((S) => S.id === t2), d = f === h.panels.length - 1, y2 = Y({
      delta: d ? s - i2 : i2 - s,
      initialLayout: m2,
      panelConstraints: c,
      pivotIndices: d ? [f - 1, f] : [f, f + 1],
      prevLayout: m2,
      trigger: "imperative-api"
    }), v = A({
      layout: y2,
      panelConstraints: c
    });
    U(m2, v) || E((S) => ({
      mountedGroups: new Map(S.mountedGroups).set(h, {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: c,
        layout: v,
        separatorToPanels: p
      })
    }));
  };
  return {
    collapse: () => {
      const { collapsible: i2, collapsedSize: s } = o(), u = a2();
      i2 && u !== s && l(s);
    },
    expand: () => {
      const { collapsible: i2, collapsedSize: s, minSize: u } = o(), c = a2();
      i2 && c === s && l(u);
    },
    getSize: () => {
      const { group: i2 } = n2(), s = a2(), { element: u } = r2(), c = i2.orientation === "horizontal" ? u.offsetWidth : u.offsetHeight;
      return {
        asPercentage: s,
        inPixels: c
      };
    },
    isCollapsed: () => {
      const { collapsible: i2, collapsedSize: s } = o(), u = a2();
      return i2 && P(s, u);
    },
    resize: (i2) => {
      if (a2() !== i2) {
        let u;
        switch (typeof i2) {
          case "number": {
            const { group: c } = n2(), h = B({ group: c });
            u = I(i2 / h * 100);
            break;
          }
          case "string": {
            u = parseFloat(i2);
            break;
          }
        }
        l(u);
      }
    }
  };
}
function Rt(e2, t2) {
  const { id: n2 } = de(), o = useRef({
    collapse: ie,
    expand: ie,
    getSize: () => ({
      asPercentage: 0,
      inPixels: 0
    }),
    isCollapsed: () => !1,
    resize: ie
  });
  useImperativeHandle(t2, () => o.current, []), N(() => {
    Object.assign(
      o.current,
      Ct({ groupId: n2, panelId: e2 })
    );
  });
}
function _t({
  children: e2,
  className: t2,
  collapsedSize: n2 = "0%",
  collapsible: o = !1,
  defaultSize: r2,
  elementRef: a2,
  id: l,
  maxSize: i2 = "100%",
  minSize: s = "0%",
  onResize: u,
  panelRef: c,
  style: h,
  ...m2
}) {
  const p = !!l, f = ue(l), [d, y2] = useState(null), v = fe(y2, a2), { id: S, registerPanel: x2 } = de(), g = u !== null, b = ce((C) => {
    u?.(C, l);
  });
  N(() => {
    if (d !== null)
      return x2({
        element: d,
        id: f,
        idIsStable: p,
        onResize: g ? b : void 0,
        panelConstraints: {
          collapsedSize: n2,
          collapsible: o,
          defaultSize: r2,
          maxSize: i2,
          minSize: s
        }
      });
  }, [
    n2,
    o,
    r2,
    d,
    g,
    f,
    p,
    i2,
    s,
    b,
    x2
  ]), Rt(f, c);
  const L = We(S, f);
  return /* @__PURE__ */ jsx(
    "div",
    {
      ...m2,
      "data-panel": !0,
      "data-testid": f,
      id: f,
      ref: v,
      style: {
        ...Et,
        flexBasis: 0,
        flexGrow: `var(${L}, 1)`,
        flexShrink: 1,
        // Prevent Panel content from interfering with panel size
        overflow: "hidden",
        // Disable pointer events inside of a panel during resize
        // This avoid edge cases like nested iframes
        pointerEvents: `var(${je})`
      },
      children: /* @__PURE__ */ jsx(
        "div",
        {
          className: t2,
          style: {
            width: "100%",
            height: "100%",
            ...h
          },
          children: e2
        }
      )
    }
  );
}
const Et = {
  minHeight: "unset",
  maxHeight: "unset",
  height: "unset",
  minWidth: "unset",
  maxWidth: "unset",
  width: "unset",
  flex: "unset",
  flexBasis: "unset",
  flexShrink: "unset",
  flexGrow: "unset",
  border: "unset",
  borderWidth: "unset",
  padding: "unset",
  margin: "unset"
};
function Mt({
  layout: e2,
  panelConstraints: t2,
  panelId: n2,
  panelIndex: o
}) {
  let r2, a2;
  const l = e2[n2], i2 = t2.find(
    (s) => s.panelId === n2
  );
  if (i2) {
    const s = i2.maxSize, u = a2 = i2.collapsible ? i2.collapsedSize : i2.minSize, c = [o, o + 1];
    a2 = A({
      layout: Y({
        delta: u - l,
        initialLayout: e2,
        panelConstraints: t2,
        pivotIndices: c,
        prevLayout: e2,
        trigger: "keyboard"
      }),
      panelConstraints: t2
    })[n2], r2 = A({
      layout: Y({
        delta: s - l,
        initialLayout: e2,
        panelConstraints: t2,
        pivotIndices: c,
        prevLayout: e2,
        trigger: "keyboard"
      }),
      panelConstraints: t2
    })[n2];
  }
  return {
    valueControls: n2,
    valueMax: r2,
    valueMin: a2,
    valueNow: l
  };
}
function $t({
  children: e2,
  className: t2,
  elementRef: n2,
  id: o,
  style: r2,
  ...a2
}) {
  const l = ue(o), [i2, s] = useState({}), [u, c] = useState("inactive"), [h, m2] = useState(null), p = fe(m2, n2), {
    id: f,
    orientation: d,
    registerSeparator: y2
  } = de(), v = d === "horizontal" ? "vertical" : "horizontal";
  return N(() => {
    if (h !== null) {
      const S = {
        element: h,
        id: l
      }, x2 = y2(S), g = _.addListener(
        "interactionStateChange",
        (L) => {
          c(
            L.state !== "inactive" && L.hitRegions.some(
              (C) => C.separator === S
            ) ? L.state : "inactive"
          );
        }
      ), b = _.addListener(
        "mountedGroupsChange",
        (L) => {
          L.forEach(
            ({ derivedPanelConstraints: C, layout: q, separatorToPanels: Z }, J) => {
              if (J.id === f) {
                const Q = Z.get(S);
                if (Q) {
                  const $ = Q[0], V = J.panels.indexOf($);
                  s(
                    Mt({
                      layout: q,
                      panelConstraints: C,
                      panelId: $.id,
                      panelIndex: V
                    })
                  );
                }
              }
            }
          );
        }
      );
      return () => {
        g(), b(), x2();
      };
    }
  }, [h, f, l, y2]), /* @__PURE__ */ jsx(
    "div",
    {
      ...a2,
      "aria-controls": i2.valueControls,
      "aria-orientation": v,
      "aria-valuemax": i2.valueMax,
      "aria-valuemin": i2.valueMin,
      "aria-valuenow": i2.valueNow,
      children: e2,
      className: t2,
      "data-separator": u,
      "data-testid": l,
      id: l,
      ref: p,
      role: "separator",
      style: {
        flexBasis: "auto",
        ...r2,
        flexGrow: 0,
        flexShrink: 0
      },
      tabIndex: 0
    }
  );
}
function $constructor(name, initializer2, params) {
  function init2(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: !1
    }), (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set()), inst._zod.traits.add(name), initializer2(inst, def);
    for (const k in _2.prototype)
      k in inst || Object.defineProperty(inst, k, { value: _2.prototype[k].bind(inst) });
    inst._zod.constr = _2, inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _2(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init2(inst, def), (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred)
      fn();
    return inst;
  }
  return Object.defineProperty(_2, "init", { value: init2 }), Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => params?.Parent && inst instanceof params.Parent ? !0 : inst?._zod?.traits?.has(name)
  }), Object.defineProperty(_2, "name", { value: name }), _2;
}
class $ZodAsyncError extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
const globalConfig = {};
function config(newConfig) {
  return globalConfig;
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v == "number");
  return Object.entries(entries).filter(([k, _2]) => numericValues.indexOf(+k) === -1).map(([_2, v]) => v);
}
function jsonStringifyReplacer(_2, value) {
  return typeof value == "bigint" ? value.toString() : value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        return Object.defineProperty(this, "value", { value }), value;
      }
    }
  };
}
function nullish(input) {
  return input == null;
}
function cleanRegex(source) {
  const start2 = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start2, end);
}
function defineLazy(object2, key, getter) {
  Object.defineProperty(object2, key, {
    get() {
      {
        const value = getter();
        return object2[key] = value, value;
      }
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function esc(str) {
  return JSON.stringify(str);
}
const captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data == "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const F = Function;
    return new F(""), !0;
  } catch {
    return !1;
  }
});
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  const ctor = o.constructor;
  if (ctor === void 0)
    return !0;
  const prot = ctor.prototype;
  return !(isObject(prot) === !1 || Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === !1);
}
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  return (!def || params?.parent) && (cl._zod.parent = inst), cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params == "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  return delete params.message, typeof params.error == "string" ? { ...params, error: () => params.error } : params;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional");
}
function pick(schema, mask) {
  const newShape = {}, currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape))
      throw new Error(`Unrecognized key: "${key}"`);
    mask[key] && (newShape[key] = currDef.shape[key]);
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape }, currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape))
      throw new Error(`Unrecognized key: "${key}"`);
    mask[key] && delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to extend: expected a plain object");
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a2, b) {
  return clone(a2, {
    ...a2._zod.def,
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b._zod.def.shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape, shape = { ...oldShape };
  if (mask)
    for (const key in mask) {
      if (!(key in oldShape))
        throw new Error(`Unrecognized key: "${key}"`);
      mask[key] && (shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key]);
    }
  else
    for (const key in oldShape)
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class, schema, mask) {
  const oldShape = schema._zod.def.shape, shape = { ...oldShape };
  if (mask)
    for (const key in mask) {
      if (!(key in shape))
        throw new Error(`Unrecognized key: "${key}"`);
      mask[key] && (shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      }));
    }
  else
    for (const key in oldShape)
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x2, startIndex = 0) {
  for (let i2 = startIndex; i2 < x2.issues.length; i2++)
    if (x2.issues[i2]?.continue !== !0)
      return !0;
  return !1;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    return (_a = iss).path ?? (_a.path = []), iss.path.unshift(path), iss;
  });
}
function unwrapMessage(message) {
  return typeof message == "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  return delete full.inst, delete full.continue, ctx?.reportInput || delete full.input, full;
}
function getLengthableOrigin(input) {
  return Array.isArray(input) ? "array" : typeof input == "string" ? "string" : "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  return typeof iss == "string" ? {
    message: iss,
    code: "custom",
    input,
    inst
  } : { ...iss };
}
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError", Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: !1
  }), Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: !1
  }), Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: !0
    // configurable: false,
  }), Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: !1
  });
}, $ZodError = $constructor("$ZodError", initializer$1), $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {}, formErrors = [];
  for (const sub of error.issues)
    sub.path.length > 0 ? (fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub))) : formErrors.push(mapper(sub));
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  }, fieldErrors = { _errors: [] }, processError = (error2) => {
    for (const issue2 of error2.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues });
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues });
      else if (issue2.path.length === 0)
        fieldErrors._errors.push(mapper(issue2));
      else {
        let curr = fieldErrors, i2 = 0;
        for (; i2 < issue2.path.length; ) {
          const el = issue2.path[i2];
          i2 === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i2++;
        }
      }
  };
  return processError(error), fieldErrors;
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: !1 }) : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e2, _params?.callee), e2;
  }
  return result.value;
}, _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise && (result = await result), result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e2, params?.callee), e2;
  }
  return result.value;
}, _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: !1 } : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  return result.issues.length ? {
    success: !1,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError), _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  return result instanceof Promise && (result = await result), result.issues.length ? {
    success: !1,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError), cuid = /^[cC][^\s-]{8,}$/, cuid2 = /^[0-9a-z]+$/, ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, xid = /^[0-9a-vA-V]{20}$/, ksuid = /^[A-Za-z0-9]{27}$/, nanoid = /^[a-zA-Z0-9_-]{21}$/, duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, uuid = (version2) => version2 ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, _emoji$1 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function emoji() {
  return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, base64url = /^[A-Za-z0-9_-]*$/, hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/, e164 = /^\+(?:[0-9]){6,14}[0-9]$/, dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof args.precision == "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision }), opts = ["Z"];
  args.local && opts.push(""), args.offset && opts.push("([+-]\\d{2}:\\d{2})");
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${regex}$`);
}, boolean = /true|false/i, lowercase = /^[^A-Z]*$/, uppercase = /^[^a-z]*$/, $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {}), inst._zod.def = def, (_a = inst._zod).onattach ?? (_a.onattach = []);
}), $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def), (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    const input = payload.value;
    if (input.length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def), (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    const input = payload.value;
    if (input.length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def), (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length, bag.maximum = def.length, bag.length = def.length;
  }), inst._zod.check = (payload) => {
    const input = payload.value, length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input), tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format, def.pattern && (bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(def.pattern));
  }), def.pattern ? (_a = inst._zod).check ?? (_a.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? { pattern: def.pattern.toString() } : {},
      inst,
      continue: !def.abort
    });
  }) : (_b = inst._zod).check ?? (_b.check = () => {
  });
}), $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes), pattern = new RegExp(typeof def.position == "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern, inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.includes(def.includes, def.position) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.startsWith(def.prefix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.endsWith(def.suffix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [], this.indent = 0, this && (this.args = args);
  }
  indented(fn) {
    this.indent += 1, fn(this), this.indent -= 1;
  }
  write(arg) {
    if (typeof arg == "function") {
      arg(this, { execution: "sync" }), arg(this, { execution: "async" });
      return;
    }
    const lines = arg.split(`
`).filter((x2) => x2), minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length)), dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line of dedented)
      this.content.push(line);
  }
  compile() {
    const F = Function, args = this?.args, lines = [...(this?.content ?? [""]).map((x2) => `  ${x2}`)];
    return new F(...args, lines.join(`
`));
  }
}
const version = {
  major: 4,
  minor: 0,
  patch: 0
}, $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {}), inst._zod.def = def, inst._zod.bag = inst._zod.bag || {}, inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  inst._zod.traits.has("$ZodCheck") && checks.unshift(inst);
  for (const ch of checks)
    for (const fn of ch._zod.onattach)
      fn(inst);
  if (checks.length === 0)
    (_a = inst._zod).deferred ?? (_a.deferred = []), inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload), asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          if (!ch._zod.def.when(payload))
            continue;
        } else if (isAborted)
          continue;
        const currLen = payload.issues.length, _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === !1)
          throw new $ZodAsyncError();
        if (asyncResult || _2 instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2, payload.issues.length !== currLen && (isAborted || (isAborted = aborted(payload, currLen)));
          });
        else {
          if (payload.issues.length === currLen)
            continue;
          isAborted || (isAborted = aborted(payload, currLen));
        }
      }
      return asyncResult ? asyncResult.then(() => payload) : payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r2 = safeParse$1(inst, value);
        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };
      } catch {
        return safeParseAsync$1(inst, value).then((r2) => r2.success ? { value: r2.data } : { issues: r2.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag), inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch {
      }
    return typeof payload.value == "string" || payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), $ZodString.init(inst, def);
}), $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid), $ZodStringFormat.init(inst, def);
}), $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const v = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
}), $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email), $ZodStringFormat.init(inst, def);
}), $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    try {
      const orig = payload.value, url = new URL(orig), href = url.href;
      def.hostname && (def.hostname.lastIndex = 0, def.hostname.test(url.hostname) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: hostname.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.protocol && (def.protocol.lastIndex = 0, def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: def.protocol.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), !orig.endsWith("/") && href.endsWith("/") ? payload.value = href.slice(0, -1) : payload.value = href;
      return;
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji()), $ZodStringFormat.init(inst, def);
}), $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid), $ZodStringFormat.init(inst, def);
}), $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid), $ZodStringFormat.init(inst, def);
}), $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2), $ZodStringFormat.init(inst, def);
}), $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid), $ZodStringFormat.init(inst, def);
}), $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid), $ZodStringFormat.init(inst, def);
}), $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid), $ZodStringFormat.init(inst, def);
}), $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$1), $ZodStringFormat.init(inst, def);
}), $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1), $ZodStringFormat.init(inst, def);
}), $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4), $ZodStringFormat.init(inst, def), inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = "ipv4";
  });
}), $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6), $ZodStringFormat.init(inst, def), inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = "ipv6";
  }), inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4), $ZodStringFormat.init(inst, def);
}), $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6), $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    const [address, prefix2] = payload.value.split("/");
    try {
      if (!prefix2)
        throw new Error();
      const prefixNum = Number(prefix2);
      if (`${prefixNum}` !== prefix2)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return !0;
  if (data.length % 4 !== 0)
    return !1;
  try {
    return atob(data), !0;
  } catch {
    return !1;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64), $ZodStringFormat.init(inst, def), inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  }), inst._zod.check = (payload) => {
    isValidBase64(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return !1;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/"), padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url), $ZodStringFormat.init(inst, def), inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  }), inst._zod.check = (payload) => {
    isValidBase64URL(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164), $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return !1;
    const [header] = tokensParts;
    if (!header)
      return !1;
    const parsedHeader = JSON.parse(atob(header));
    return !("typ" in parsedHeader && parsedHeader?.typ !== "JWT" || !parsedHeader.alg || algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm));
  } catch {
    return !1;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    isValidJWT(payload.value, def.alg) || payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = boolean, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = !!payload.value;
      } catch {
      }
    const input = payload.value;
    return typeof input == "boolean" || payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => (payload.issues.push({
    expected: "never",
    code: "invalid_type",
    input: payload.value,
    inst
  }), payload);
});
function handleArrayResult(result, final, index2) {
  result.issues.length && final.issues.push(...prefixIssues(index2, result.issues)), final.value[index2] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2], result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleArrayResult(result2, payload, i2))) : handleArrayResult(result, payload, i2);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleObjectResult(result, final, key) {
  result.issues.length && final.issues.push(...prefixIssues(key, result.issues)), final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  result.issues.length ? input[key] === void 0 ? key in input ? final.value[key] = void 0 : final.value[key] = result.value : final.issues.push(...prefixIssues(key, result.issues)) : result.value === void 0 ? key in input && (final.value[key] = void 0) : final.value[key] = result.value;
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys2 = Object.keys(def.shape);
    for (const k of keys2)
      if (!(def.shape[k] instanceof $ZodType))
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys: keys2,
      keySet: new Set(keys2),
      numKeys: keys2.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape, propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]), normalized = _normalized.value, parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write("const input = payload.value;");
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys)
      ids[key] = `key_${counter++}`;
    doc.write("const newResult = {}");
    for (const key of normalized.keys)
      if (normalized.optionalKeys.has(key)) {
        const id2 = ids[key];
        doc.write(`const ${id2} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id2}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id2}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id2}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id2}.value;
        }
        `);
      } else {
        const id2 = ids[key];
        doc.write(`const ${id2} = ${parseStr(key)};`), doc.write(`
          if (${id2}.issues.length) payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`), doc.write(`newResult[${esc(key)}] = ${id2}.value`);
      }
    doc.write("payload.value = newResult;"), doc.write("return payload;");
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject$12 = isObject, jit = !globalConfig.jitless, fastEnabled = jit && allowsEval.value, catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$12(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    const proms = [];
    if (jit && fastEnabled && ctx?.async === !1 && ctx.jitless !== !0)
      fastpass || (fastpass = generateFastpass(def.shape)), payload = fastpass(payload, ctx);
    else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key], r2 = el._zod.run({ value: input[key], issues: [] }, ctx), isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        r2 instanceof Promise ? proms.push(r2.then((r3) => isOptional ? handleOptionalObjectResult(r3, payload, key, input) : handleObjectResult(r3, payload, key))) : isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key);
      }
    }
    if (!catchall)
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    const unrecognized = [], keySet = value.keySet, _catchall = catchall._zod, t2 = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t2 === "never") {
        unrecognized.push(key);
        continue;
      }
      const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);
      r2 instanceof Promise ? proms.push(r2.then((r3) => handleObjectResult(r3, payload, key))) : handleObjectResult(r2, payload, key);
    }
    return unrecognized.length && payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    }), proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results)
    if (result.issues.length === 0)
      return final.value = result.value, final;
  return final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }), final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values))
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
  }), defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
  }), inst._zod.parse = (payload, ctx) => {
    let async = !1;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    return async ? Promise.all(results).then((results2) => handleUnionResults(results2, payload, inst, ctx)) : handleUnionResults(results, payload, inst, ctx);
  };
}), $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    const input = payload.value, left = def.left._zod.run({ value: input, issues: [] }, ctx), right = def.right._zod.run({ value: input, issues: [] }, ctx);
    return left instanceof Promise || right instanceof Promise ? Promise.all([left, right]).then(([left2, right2]) => handleIntersectionResults(payload, left2, right2)) : handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b) {
  if (a2 === b)
    return { valid: !0, data: a2 };
  if (a2 instanceof Date && b instanceof Date && +a2 == +b)
    return { valid: !0, data: a2 };
  if (isPlainObject(a2) && isPlainObject(b)) {
    const bKeys = Object.keys(b), sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b)) {
    if (a2.length !== b.length)
      return { valid: !1, mergeErrorPath: [] };
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2], itemB = b[index2], sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length && result.issues.push(...left.issues), right.issues.length && result.issues.push(...right.issues), aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  return result.value = merged.data, result;
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values2 = getEnumValues(def.entries);
  inst._zod.values = new Set(values2), inst._zod.pattern = new RegExp(`^(${values2.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o == "string" ? escapeRegex(o) : o.toString()).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    return inst._zod.values.has(input) || payload.issues.push({
      code: "invalid_value",
      values: values2,
      input,
      inst
    }), payload;
  };
}), $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.values = new Set(def.values), inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o == "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    return inst._zod.values.has(input) || payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    }), payload;
  };
}), $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async)
      return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output2) => (payload.value = output2, payload));
    if (_out instanceof Promise)
      throw new $ZodAsyncError();
    return payload.value = _out, payload;
  };
}), $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", inst._zod.optout = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0), defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  }), inst._zod.parse = (payload, ctx) => def.innerType._zod.optin === "optional" ? def.innerType._zod.run(payload, ctx) : payload.value === void 0 ? payload : def.innerType._zod.run(payload, ctx);
}), $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  }), defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0), inst._zod.parse = (payload, ctx) => payload.value === null ? payload : def.innerType._zod.run(payload, ctx);
}), $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0)
      return payload.value = def.defaultValue, payload;
    const result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleDefaultResult(result2, def)) : handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  return payload.value === void 0 && (payload.value = def.defaultValue), payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => (payload.value === void 0 && (payload.value = def.defaultValue), def.innerType._zod.run(payload, ctx));
}), $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x2) => x2 !== void 0)) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleNonOptionalResult(result2, inst)) : handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  return !payload.issues.length && payload.value === void 0 && payload.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: payload.value,
    inst
  }), payload;
}
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.value, result2.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload)) : (payload.value = result.value, result.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload);
  };
}), $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    return left instanceof Promise ? left.then((left2) => handlePipeResult(left2, def, ctx)) : handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  return aborted(left) ? left : def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then(handleReadonlyResult) : handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  return payload.value = Object.freeze(payload.value), payload;
}
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def), $ZodType.init(inst, def), inst._zod.parse = (payload, _2) => payload, inst._zod.check = (payload) => {
    const input = payload.value, r2 = def.fn(input);
    if (r2 instanceof Promise)
      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
    handleRefineResult(r2, payload, input, inst);
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    inst._zod.def.params && (_iss.params = inst._zod.def.params), payload.issues.push(issue(_iss));
  }
}
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    if (this._map.set(schema, meta), meta && typeof meta == "object" && "id" in meta) {
      if (this._idmap.has(meta.id))
        throw new Error(`ID ${meta.id} already exists in the registry`);
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    return meta && typeof meta == "object" && "id" in meta && this._idmap.delete(meta.id), this._map.delete(schema), this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      return delete pm.id, { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
const globalRegistry = /* @__PURE__ */ registry();
function _string(Class, params) {
  return new Class({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class, params) {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _guid(Class, params) {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _uuid(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class, params) {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _emoji(Class, params) {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cuid(Class, params) {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ulid(Class, params) {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _xid(Class, params) {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _base64(Class, params) {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _base64url(Class, params) {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _e164(Class, params) {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _jwt(Class, params) {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class, params) {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _unknown(Class) {
  return new Class({
    type: "unknown"
  });
}
function _never(Class, params) {
  return new Class({
    type: "never",
    ...normalizeParams(params)
  });
}
function _maxLength(maximum, params) {
  return new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix2, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix: prefix2
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _refine(Class, fn, _params) {
  return new Class({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  params.case !== "sensitive" && (truthyArray = truthyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v), falsyArray = falsyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v));
  const truthySet = new Set(truthyArray), falsySet = new Set(falsyArray), _Pipe = Classes.Pipe ?? $ZodPipe, _Boolean = Classes.Boolean ?? $ZodBoolean, _String = Classes.String ?? $ZodString, _Transform = Classes.Transform ?? $ZodTransform, tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      return params.case !== "sensitive" && (data = data.toLowerCase()), truthySet.has(data) ? !0 : falsySet.has(data) ? !1 : (payload.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...truthySet, ...falsySet],
        input: payload.value,
        inst: tx
      }), {});
    },
    error: params.error
  }), innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  return new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
}
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def), ZodStringFormat.init(inst, def);
});
function date(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def), ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues), inst.name = "ZodError", Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
}), parse = /* @__PURE__ */ _parse(ZodRealError), parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError), safeParse = /* @__PURE__ */ _safeParse(ZodRealError), safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError), ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => ($ZodType.init(inst, def), inst.def = def, Object.defineProperty(inst, "_def", { value: def }), inst.check = (...checks) => inst.clone(
  {
    ...def,
    checks: [
      ...def.checks ?? [],
      ...checks.map((ch) => typeof ch == "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
    ]
  }
  // { parent: true }
), inst.clone = (def2, params) => clone(inst, def2, params), inst.brand = () => inst, inst.register = ((reg, meta) => (reg.add(inst, meta), inst)), inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse }), inst.safeParse = (data, params) => safeParse(inst, data, params), inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync }), inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params), inst.spa = inst.safeParseAsync, inst.refine = (check2, params) => inst.check(refine(check2, params)), inst.superRefine = (refinement) => inst.check(superRefine(refinement)), inst.overwrite = (fn) => inst.check(_overwrite(fn)), inst.optional = () => optional(inst), inst.nullable = () => nullable(inst), inst.nullish = () => optional(nullable(inst)), inst.nonoptional = (params) => nonoptional(inst, params), inst.array = () => array(inst), inst.or = (arg) => union([inst, arg]), inst.and = (arg) => intersection(inst, arg), inst.transform = (tx) => pipe(inst, transform(tx)), inst.default = (def2) => _default(inst, def2), inst.prefault = (def2) => prefault(inst, def2), inst.catch = (params) => _catch(inst, params), inst.pipe = (target) => pipe(inst, target), inst.readonly = () => readonly(inst), inst.describe = (description) => {
  const cl = inst.clone();
  return globalRegistry.add(cl, { description }), cl;
}, Object.defineProperty(inst, "description", {
  get() {
    return globalRegistry.get(inst)?.description;
  },
  configurable: !0
}), inst.meta = (...args) => {
  if (args.length === 0)
    return globalRegistry.get(inst);
  const cl = inst.clone();
  return globalRegistry.add(cl, args[0]), cl;
}, inst.isOptional = () => inst.safeParse(void 0).success, inst.isNullable = () => inst.safeParse(null).success, inst)), _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def), ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null, inst.minLength = bag.minimum ?? null, inst.maxLength = bag.maximum ?? null, inst.regex = (...args) => inst.check(_regex(...args)), inst.includes = (...args) => inst.check(_includes(...args)), inst.startsWith = (...args) => inst.check(_startsWith(...args)), inst.endsWith = (...args) => inst.check(_endsWith(...args)), inst.min = (...args) => inst.check(_minLength(...args)), inst.max = (...args) => inst.check(_maxLength(...args)), inst.length = (...args) => inst.check(_length(...args)), inst.nonempty = (...args) => inst.check(_minLength(1, ...args)), inst.lowercase = (params) => inst.check(_lowercase(params)), inst.uppercase = (params) => inst.check(_uppercase(params)), inst.trim = () => inst.check(_trim()), inst.normalize = (...args) => inst.check(_normalize(...args)), inst.toLowerCase = () => inst.check(_toLowerCase()), inst.toUpperCase = () => inst.check(_toUpperCase());
}), ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def), _ZodString.init(inst, def), inst.email = (params) => inst.check(_email(ZodEmail, params)), inst.url = (params) => inst.check(_url(ZodURL, params)), inst.jwt = (params) => inst.check(_jwt(ZodJWT, params)), inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.uuid = (params) => inst.check(_uuid(ZodUUID, params)), inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params)), inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params)), inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params)), inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.cuid = (params) => inst.check(_cuid(ZodCUID, params)), inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params)), inst.ulid = (params) => inst.check(_ulid(ZodULID, params)), inst.base64 = (params) => inst.check(_base64(ZodBase64, params)), inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params)), inst.xid = (params) => inst.check(_xid(ZodXID, params)), inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params)), inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params)), inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params)), inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params)), inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params)), inst.e164 = (params) => inst.check(_e164(ZodE164, params)), inst.datetime = (params) => inst.check(datetime(params)), inst.date = (params) => inst.check(date(params)), inst.time = (params) => inst.check(time(params)), inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), _ZodString.init(inst, def);
}), ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def), ZodStringFormat.init(inst, def);
}), ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def), ZodType.init(inst, def);
}), ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def), ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def), ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def), ZodType.init(inst, def), inst.element = def.element, inst.min = (minLength, params) => inst.check(_minLength(minLength, params)), inst.nonempty = (params) => inst.check(_minLength(1, params)), inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params)), inst.length = (len, params) => inst.check(_length(len, params)), inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def), ZodType.init(inst, def), defineLazy(inst, "shape", () => def.shape), inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)), inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall }), inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() }), inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 }), inst.extend = (incoming) => extend(inst, incoming), inst.merge = (other) => merge(inst, other), inst.pick = (mask) => pick(inst, mask), inst.omit = (mask) => omit(inst, mask), inst.partial = (...args) => partial(ZodOptional, inst, args[0]), inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      return assignProp(this, "shape", { ...shape }), this.shape;
    },
    ...normalizeParams(params)
  };
  return new ZodObject(def);
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def), ZodType.init(inst, def), inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def), ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def), ZodType.init(inst, def), inst.enum = def.entries, inst.options = Object.values(def.entries);
  const keys2 = new Set(Object.keys(def.entries));
  inst.extract = (values2, params) => {
    const newEntries = {};
    for (const value of values2)
      if (keys2.has(value))
        newEntries[value] = def.entries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  }, inst.exclude = (values2, params) => {
    const newEntries = { ...def.entries };
    for (const value of values2)
      if (keys2.has(value))
        delete newEntries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v) => [v, v])) : values2;
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def), ZodType.init(inst, def), inst.values = new Set(def.values), Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def), ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 == "string")
        payload.issues.push(issue(issue$1, payload.value, def));
      else {
        const _issue = issue$1;
        _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = inst), _issue.continue ?? (_issue.continue = !0), payload.issues.push(issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    return output instanceof Promise ? output.then((output2) => (payload.value = output2, payload)) : (payload.value = output, payload);
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def), ZodType.init(inst, def), inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def), ZodType.init(inst, def), inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def), ZodType.init(inst, def), inst.unwrap = () => inst._zod.def.innerType, inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : defaultValue;
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def), ZodType.init(inst, def), inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : defaultValue;
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def), ZodType.init(inst, def), inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def), ZodType.init(inst, def), inst.unwrap = () => inst._zod.def.innerType, inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue == "function" ? catchValue : () => catchValue
  });
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def), ZodType.init(inst, def), inst.in = def.in, inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def), ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def), ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return ch._zod.check = fn, ch;
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => (payload.addIssue = (issue$1) => {
    if (typeof issue$1 == "string")
      payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
    else {
      const _issue = issue$1;
      _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = ch), _issue.continue ?? (_issue.continue = !ch._zod.def.abort), payload.issues.push(issue(_issue));
    }
  }, fn(payload.value, payload)));
  return ch;
}
const stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
export {
  t$f as $,
  createTheme as A,
  Background as B,
  MantineProvider as C,
  useMantineStyleNonce as D,
  domMax as E,
  MotionConfig as F,
  e$b as G,
  t$s as H,
  t$i as I,
  t$n as J,
  t$o as K,
  LazyMotion as L,
  MantineContext as M,
  useId$1 as N,
  ErrorBoundary as O,
  Portal as P,
  ThemeIcon as Q,
  Text as R,
  ScrollAreaAutosize as S,
  Tooltip as T,
  Button as U,
  useSelector as V,
  setup as W,
  emit as X,
  assertEvent as Y,
  assign as Z,
  raise as _,
  BackgroundVariant as a,
  Badge as a$,
  n$c as a0,
  t$g as a1,
  n$q as a2,
  e$7 as a3,
  fromCallback as a4,
  getHotkeyHandler as a5,
  enqueueActions as a6,
  r$9 as a7,
  sendTo as a8,
  log as a9,
  MotionDiv as aA,
  Breadcrumbs as aB,
  Menu as aC,
  UnstyledButton as aD,
  SegmentedControl as aE,
  Divider as aF,
  AnimatePresence as aG,
  useHover$1 as aH,
  Popover as aI,
  PopoverTarget as aJ,
  PopoverDropdown as aK,
  Box as aL,
  FloatingIndicator as aM,
  Flex as aN,
  useDebouncedCallback as aO,
  useUncontrolled as aP,
  clampUseMovePosition as aQ,
  useMove as aR,
  useMergedRef as aS,
  TooltipGroup as aT,
  useDebouncedValue as aU,
  EdgeLabelRenderer as aV,
  e$5 as aW,
  useDebouncedState as aX,
  NodeToolbar as aY,
  Position as aZ,
  Handle as a_,
  fromPromise as aa,
  getViewportForBounds as ab,
  getNodesBounds as ac,
  getEdgePosition as ad,
  t$m as ae,
  t$l as af,
  e$1 as ag,
  t$u as ah,
  t$b as ai,
  n as aj,
  dagre as ak,
  t$5 as al,
  t$1 as am,
  t$2 as an,
  cancel as ao,
  applyEdgeChanges as ap,
  applyNodeChanges as aq,
  e$6 as ar,
  stopChild as as,
  spawnChild as at,
  e$3 as au,
  not as av,
  t$4 as aw,
  e$2 as ax,
  ActionIcon as ay,
  MotionButton as az,
  useCustomCompareEffect as b,
  useFocusWithin as b$,
  CopyButton as b0,
  HoverCard as b1,
  HoverCardTarget as b2,
  HoverCardDropdown as b3,
  Notification as b4,
  isMacOs as b5,
  NavLink as b6,
  ColorSwatch as b7,
  Space as b8,
  Stack as b9,
  getBezierPath as bA,
  ReactFlowProvider as bB,
  useStateHistory as bC,
  useRafEffect as bD,
  Panel as bE,
  Anchor as bF,
  Pill as bG,
  useViewportSize as bH,
  useSessionStorage as bI,
  t$a as bJ,
  useDragControls as bK,
  useMotionValue as bL,
  CloseButton as bM,
  ActionIconGroup as bN,
  Tabs as bO,
  TabsList as bP,
  TabsTab as bQ,
  TabsPanel as bR,
  ScrollArea as bS,
  useCallbackRef as bT,
  animate as bU,
  e$8 as bV,
  VisuallyHidden as bW,
  n$p as bX,
  useWindowEvent as bY,
  FocusTrap as bZ,
  Title as b_,
  CheckIcon as ba,
  rem as bb,
  useUpdateEffect as bc,
  Slider as bd,
  Paper as be,
  MenuTarget as bf,
  MenuDropdown as bg,
  MenuItem as bh,
  useFocusTrap as bi,
  useReducedMotionConfig as bj,
  useTimeoutEffect as bk,
  m as bl,
  ReactRemoveScroll as bm,
  useThrottledCallback as bn,
  Input as bo,
  createScopedKeydownHandler as bp,
  t$3 as bq,
  Highlight as br,
  useMountEffect as bs,
  e$9 as bt,
  useActorRef as bu,
  LayoutGroup as bv,
  useTree as bw,
  Alert as bx,
  Tree as by,
  Group as bz,
  useStore$1 as c,
  Navigate as c$,
  useCombobox as c0,
  ComboboxOption as c1,
  Combobox as c2,
  ComboboxTarget as c3,
  ComboboxDropdown as c4,
  ComboboxOptions as c5,
  ComboboxEmpty as c6,
  useHotkeys as c7,
  Grid as c8,
  GridCol as c9,
  t$c as cA,
  toRgba as cB,
  t$6 as cC,
  mix as cD,
  toHex as cE,
  scale as cF,
  e$4 as cG,
  t$d as cH,
  stagger as cI,
  motionValue as cJ,
  mapValue as cK,
  styleEffect as cL,
  isValidMotionProp as cM,
  useRouter as cN,
  isNotFound as cO,
  Container as cP,
  Code as cQ,
  Link as cR,
  useNavigate as cS,
  createRootRouteWithContext as cT,
  stripSearchParams as cU,
  Outlet as cV,
  createFileRoute as cW,
  redirect as cX,
  useDocumentTitle as cY,
  Loader as cZ,
  useStore as c_,
  autoUpdate as ca,
  computePosition as cb,
  offset$1 as cc,
  autoPlacement as cd,
  size$1 as ce,
  hide$1 as cf,
  useLocalStorage as cg,
  Card as ch,
  n$v as ci,
  useRerender as cj,
  d3line as ck,
  curveCatmullRomOpen as cl,
  getSmoothStepPath as cm,
  r$c as cn,
  produce as co,
  useTimeout as cp,
  useDebouncedCallback$1 as cq,
  useCustomCompareMemo as cr,
  setAutoFreeze as cs,
  castDraft as ct,
  n$d as cu,
  t$9 as cv,
  nodeToRect as cw,
  and as cx,
  or as cy,
  e$d as cz,
  deepEqual as d,
  useParams as d0,
  useMatches as d1,
  SimpleGrid as d2,
  useInViewport as d3,
  e as d4,
  notFound as d5,
  useComputedColorScheme as d6,
  onMount as d7,
  Drawer as d8,
  MenuDivider as d9,
  string as dA,
  formatError as dB,
  Select as da,
  ModalRoot as db,
  ModalOverlay as dc,
  ModalContent as dd,
  ModalBody as de,
  useMantineTheme as df,
  useMediaQuery as dg,
  useDisclosure as dh,
  useParentMatches as di,
  MenuLabel as dj,
  useSearch as dk,
  LoadingOverlay as dl,
  toBlob as dm,
  useAsync as dn,
  Gt as dp,
  _t as dq,
  $t as dr,
  Burger as ds,
  createRouter as dt,
  createHashHistory as du,
  createBrowserHistory as dv,
  RouterProvider as dw,
  object as dx,
  literal as dy,
  stringbool as dz,
  useStoreApi as e,
  useReactFlow as f,
  e$e as g,
  t$q as h,
  Bezier as i,
  getNodeDimensions as j,
  useMantineColorScheme as k,
  index as l,
  e$c as m,
  n$k as n,
  t$8 as o,
  t$j as p,
  createSafeContext as q,
  atom as r,
  shallowEqual as s,
  t$v as t,
  useFirstMountState as u,
  useIsomorphicLayoutEffect$2 as v,
  useSyncedRef as w,
  t$h as x,
  e$a as y,
  t$e as z
};
