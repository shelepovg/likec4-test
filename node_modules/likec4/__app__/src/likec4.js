import { forwardRef, createElement, useContext, createContext, memo as memo$1, useRef, useMemo, useState, useEffect, useCallback, Fragment as Fragment$1, useLayoutEffect, useDeferredValue } from "react";
import { vector, BBox as BBox$2 } from "@likec4/core/geometry";
import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import "react-dom";
import { B as Background$1, a as BackgroundVariant, d as deepEqual, u as useFirstMountState, b as useCustomCompareEffect, s as shallowEqual, c as useStore, e as useStoreApi, f as useReactFlow, t, g as e, h as t$1, i as Bezier, j as getNodeDimensions, n, k as useMantineColorScheme, l as index, m as e$1, o as t$2, p as t$3, q as createSafeContext$1, r as atom, v as useIsomorphicLayoutEffect, w as useSyncedRef, x as t$4, y as e$2, z as t$5, A as createTheme, T as Tooltip$6, P as Portal, M as MantineContext, C as MantineProvider, D as useMantineStyleNonce, L as LazyMotion, E as domMax, F as MotionConfig, G as e$3, H as t$6, I as t$7, J as t$8, K as t$9, N as useId$1, O as ErrorBoundary$1, Q as ThemeIcon, R as Text, S as ScrollAreaAutosize, U as Button, V as useSelector, W as setup, X as emit, Y as assertEvent, Z as assign, _ as raise, $ as t$a, a0 as n$1, a1 as t$b, a2 as n$2, a3 as e$4, a4 as fromCallback, a5 as getHotkeyHandler, a6 as enqueueActions, a7 as r, a8 as sendTo, a9 as log, aa as fromPromise, ab as getViewportForBounds, ac as getNodesBounds, ad as getEdgePosition, ae as t$c, af as t$d, ag as e$5, ah as t$e, ai as t$f, aj as n$3, ak as dagre, al as t$g, am as t$h, an as t$i, ao as cancel, ap as applyEdgeChanges, aq as applyNodeChanges, ar as e$6, as as stopChild, at as spawnChild, au as e$7, av as not, aw as t$j, ax as e$8, ay as ActionIcon, az as MotionButton, aA as MotionDiv, aB as Breadcrumbs, aC as Menu, aD as UnstyledButton, aE as SegmentedControl, aF as Divider$2, aG as AnimatePresence, aH as useHover, aI as Popover, aJ as PopoverTarget, aK as PopoverDropdown, aL as Box$1, aM as FloatingIndicator, aN as Flex, aO as useDebouncedCallback, aP as useUncontrolled, aQ as clampUseMovePosition, aR as useMove, aS as useMergedRef, aT as TooltipGroup, aU as useDebouncedValue, aV as EdgeLabelRenderer, aW as e$9, aX as useDebouncedState, aY as NodeToolbar, aZ as Position, a_ as Handle, a$ as Badge, b0 as CopyButton, b1 as HoverCard, b2 as HoverCardTarget, b3 as HoverCardDropdown, b4 as Notification, b5 as isMacOs, b6 as NavLink, b7 as ColorSwatch, b8 as Space, b9 as Stack, ba as CheckIcon, bb as rem, bc as useUpdateEffect$1, bd as Slider, be as Paper, bf as MenuTarget, bg as MenuDropdown, bh as MenuItem, bi as useFocusTrap, bj as useReducedMotionConfig, bk as useTimeoutEffect, bl as m, bm as ReactRemoveScroll, bn as useThrottledCallback, bo as Input, bp as createScopedKeydownHandler, bq as t$k, br as Highlight, bs as useMountEffect, bt as e$a, bu as useActorRef, bv as LayoutGroup, bw as useTree, bx as Alert, by as Tree, bz as Group, bA as getBezierPath, bB as ReactFlowProvider, bC as useStateHistory, bD as useRafEffect, bE as Panel, bF as Anchor, bG as Pill, bH as useViewportSize, bI as useSessionStorage, bJ as t$l, bK as useDragControls, bL as useMotionValue, bM as CloseButton, bN as ActionIconGroup, bO as Tabs, bP as TabsList, bQ as TabsTab, bR as TabsPanel, bS as ScrollArea, bT as useCallbackRef$1, bU as animate, bV as e$b, bW as VisuallyHidden, bX as n$4, bY as useWindowEvent, bZ as FocusTrap, b_ as Title$1, b$ as useFocusWithin, c0 as useCombobox, c1 as ComboboxOption, c2 as Combobox, c3 as ComboboxTarget, c4 as ComboboxDropdown, c5 as ComboboxOptions, c6 as ComboboxEmpty, c7 as useHotkeys, c8 as Grid, c9 as GridCol, ca as autoUpdate, cb as computePosition, cc as offset, cd as autoPlacement, ce as size, cf as hide, cg as useLocalStorage, ch as Card, ci as n$5, cj as useRerender, ck as d3line, cl as curveCatmullRomOpen, cm as getSmoothStepPath, cn as r$1, co as produce, cp as useTimeout, cq as useDebouncedCallback$1, cr as useCustomCompareMemo, cs as setAutoFreeze, ct as castDraft, cu as n$6, cv as t$m, cw as nodeToRect$1, cx as and, cy as or, cz as e$c, cA as t$n, cB as toRgba, cC as t$o, cD as mix, cE as toHex, cF as scale, cG as e$d, cH as t$p, cI as stagger, cJ as motionValue, cK as mapValue, cL as styleEffect, cM as isValidMotionProp } from "./vendors.js";
import { nonexhaustive, BBox, isTagColorSpecified, Queue, GroupElementKind, nonNullable as nonNullable$1, invariant as invariant$1, isStepEdgeId, extractStep, RichText as RichText$1, ancestorsFqn, nameFromFqn, isAncestor as isAncestor$1, DefaultMap as DefaultMap$1, whereOperatorAsPredicate, getParallelStepsPrefix } from "@likec4/core";
import { DefaultTagColors, LikeC4Styles as LikeC4Styles$1, ElementShapes } from "@likec4/core/styles";
import { computeRelationshipsView, treeFromElements } from "@likec4/core/compute-view/relationships";
import { BBox as BBox$1, preferSummary, exact, ensureSizes, RichText } from "@likec4/core/types";
import { invariant, nonNullable, nonexhaustive as nonexhaustive$1, toArray, ifind, DefaultMap, delay, ifirst, ifilter, compareNaturalHierarchically, compareNatural, isAncestor, sortParentsFirst, nameFromFqn as nameFromFqn$1, isome } from "@likec4/core/utils";
import { extractViewTitleFromPath, VIEW_FOLDERS_SEPARATOR, normalizeViewPath, modelConnection } from "@likec4/core/model";
function isObject(value) {
  return typeof value == "object" && value != null && !Array.isArray(value);
}
var isObjectOrArray = (obj) => typeof obj == "object" && obj !== null;
function compact(value) {
  return Object.fromEntries(Object.entries(value ?? {}).filter(([_, value2]) => value2 !== void 0));
}
var isBaseCondition = (v) => v === "base";
function filterBaseConditions(c) {
  return c.slice().filter((v) => !isBaseCondition(v));
}
function toChar(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
}
function toName(code) {
  let name = "", x;
  for (x = Math.abs(code); x > 52; x = x / 52 | 0) name = toChar(x % 52) + name;
  return toChar(x % 52) + name;
}
function toPhash(h, x) {
  let i = x.length;
  for (; i; ) h = h * 33 ^ x.charCodeAt(--i);
  return h;
}
function toHash(value) {
  return toName(toPhash(5381, value) >>> 0);
}
var importantRegex = /\s*!(important)?/i;
function isImportant(value) {
  return typeof value == "string" ? importantRegex.test(value) : !1;
}
function withoutImportant(value) {
  return typeof value == "string" ? value.replace(importantRegex, "").trim() : value;
}
function withoutSpace(str) {
  return typeof str == "string" ? str.replaceAll(" ", "_") : str;
}
var memo = (fn) => {
  const cache = /* @__PURE__ */ new Map();
  return (...args) => {
    const key2 = JSON.stringify(args);
    if (cache.has(key2))
      return cache.get(key2);
    const result = fn(...args);
    return cache.set(key2, result), result;
  };
}, MERGE_OMIT = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function mergeProps(...sources) {
  return sources.reduce((prev, obj) => (obj && Object.keys(obj).forEach((key2) => {
    if (MERGE_OMIT.has(key2)) return;
    const prevValue = prev[key2], value = obj[key2];
    isObject(prevValue) && isObject(value) ? prev[key2] = mergeProps(prevValue, value) : prev[key2] = value;
  }), prev), {});
}
var isNotNullish = (element) => element != null;
function walkObject(target, predicate, options = {}) {
  const { stop, getKey } = options;
  function inner(value, path = []) {
    if (isObjectOrArray(value)) {
      const result = {};
      for (const [prop, child] of Object.entries(value)) {
        const key2 = getKey?.(prop, child) ?? prop, childPath = [...path, key2];
        if (stop?.(value, childPath))
          return predicate(value, path);
        const next = inner(child, childPath);
        isNotNullish(next) && (result[key2] = next);
      }
      return result;
    }
    return predicate(value, path);
  }
  return inner(target);
}
function mapObject(obj, fn) {
  return Array.isArray(obj) ? obj.map((value) => fn(value)) : isObject(obj) ? walkObject(obj, (value) => fn(value)) : fn(obj);
}
function toResponsiveObject(values, breakpoints) {
  return values.reduce(
    (acc, current, index2) => {
      const key2 = breakpoints[index2];
      return current != null && (acc[key2] = current), acc;
    },
    {}
  );
}
function normalizeStyleObject(styles, context2, shorthand = !0) {
  const { utility, conditions: conditions2 } = context2, { hasShorthand, resolveShorthand: resolveShorthand2 } = utility;
  return walkObject(
    styles,
    (value) => Array.isArray(value) ? toResponsiveObject(value, conditions2.breakpoints.keys) : value,
    {
      stop: (value) => Array.isArray(value),
      getKey: shorthand ? (prop) => hasShorthand ? resolveShorthand2(prop) : prop : void 0
    }
  );
}
var fallbackCondition = {
  shift: (v) => v,
  finalize: (v) => v,
  breakpoints: { keys: [] }
}, sanitize = (value) => typeof value == "string" ? value.replaceAll(/[\n\s]+/g, " ") : value;
function createCss(context2) {
  const { utility, hash, conditions: conds = fallbackCondition } = context2, formatClassName = (str) => [utility.prefix, str].filter(Boolean).join("-"), hashFn = (conditions2, className) => {
    let result;
    if (hash) {
      const baseArray = [...conds.finalize(conditions2), className];
      result = formatClassName(utility.toHash(baseArray, toHash));
    } else
      result = [...conds.finalize(conditions2), formatClassName(className)].join(":");
    return result;
  };
  return memo(({ base, ...styles } = {}) => {
    const styleObject = Object.assign(styles, base), normalizedObject = normalizeStyleObject(styleObject, context2), classNames = /* @__PURE__ */ new Set();
    return walkObject(normalizedObject, (value, paths) => {
      if (value == null) return;
      const important = isImportant(value), [prop, ...allConditions] = conds.shift(paths), conditions2 = filterBaseConditions(allConditions), transformed = utility.transform(prop, withoutImportant(sanitize(value)));
      let className = hashFn(conditions2, transformed.className);
      important && (className = `${className}!`), classNames.add(className);
    }), Array.from(classNames).join(" ");
  });
}
function compactStyles(...styles) {
  return styles.flat().filter((style) => isObject(style) && Object.keys(compact(style)).length > 0);
}
function createMergeCss(context2) {
  function resolve(styles) {
    const allStyles = compactStyles(...styles);
    return allStyles.length === 1 ? allStyles : allStyles.map((style) => normalizeStyleObject(style, context2));
  }
  function mergeCss2(...styles) {
    return mergeProps(...resolve(styles));
  }
  function assignCss(...styles) {
    return Object.assign({}, ...resolve(styles));
  }
  return { mergeCss: memo(mergeCss2), assignCss };
}
var wordRegex = /([A-Z])/g, msRegex = /^ms-/, hypenateProperty = memo((property) => property.startsWith("--") ? property : property.replace(wordRegex, "-$1").replace(msRegex, "-ms-").toLowerCase()), fns = ["min", "max", "clamp", "calc"], fnRegExp = new RegExp(`^(${fns.join("|")})\\(.*\\)`), isCssFunction = (v) => typeof v == "string" && fnRegExp.test(v), lengthUnits = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%", lengthUnitsPattern = `(?:${lengthUnits.split(",").join("|")})`, lengthRegExp = new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`), isCssUnit = (v) => typeof v == "string" && lengthRegExp.test(v), isCssVar = (v) => typeof v == "string" && /^var\(--.+\)$/.test(v), patternFns = {
  map: mapObject,
  isCssFunction,
  isCssVar,
  isCssUnit
}, getPatternStyles = (pattern, styles) => {
  if (!pattern?.defaultValues) return styles;
  const defaults2 = typeof pattern.defaultValues == "function" ? pattern.defaultValues(styles) : pattern.defaultValues;
  return Object.assign({}, defaults2, compact(styles));
}, getSlotRecipes = (recipe = {}) => {
  const init = (slot) => ({
    className: [recipe.className, slot].filter(Boolean).join("__"),
    base: recipe.base?.[slot] ?? {},
    variants: {},
    defaultVariants: recipe.defaultVariants ?? {},
    compoundVariants: recipe.compoundVariants ? getSlotCompoundVariant(recipe.compoundVariants, slot) : []
  }), recipeParts = (recipe.slots ?? []).map((slot) => [slot, init(slot)]);
  for (const [variantsKey, variantsSpec] of Object.entries(recipe.variants ?? {}))
    for (const [variantKey, variantSpec] of Object.entries(variantsSpec))
      recipeParts.forEach(([slot, slotRecipe]) => {
        slotRecipe.variants[variantsKey] ??= {}, slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? {};
      });
  return Object.fromEntries(recipeParts);
}, getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({ ...compoundVariant, css: compoundVariant.css[slotName] }));
function splitProps(props, ...keys) {
  const descriptors = Object.getOwnPropertyDescriptors(props), dKeys = Object.keys(descriptors), split = (k) => {
    const clone = {};
    for (let i = 0; i < k.length; i++) {
      const key2 = k[i];
      descriptors[key2] && (Object.defineProperty(clone, key2, descriptors[key2]), delete descriptors[key2]);
    }
    return clone;
  }, fn = (key2) => split(Array.isArray(key2) ? key2 : dKeys.filter(key2));
  return keys.map(fn).concat(split(dKeys));
}
var uniq = (...items) => {
  const set = items.reduce((acc, currItems) => (currItems && currItems.forEach((item) => acc.add(item)), acc), /* @__PURE__ */ new Set([]));
  return Array.from(set);
}, htmlProps = ["htmlSize", "htmlTranslate", "htmlWidth", "htmlHeight"];
function convert(key2) {
  return htmlProps.includes(key2) ? key2.replace("html", "").toLowerCase() : key2;
}
function normalizeHTMLProps(props) {
  return Object.fromEntries(Object.entries(props).map(([key2, value]) => [convert(key2), value]));
}
normalizeHTMLProps.keys = htmlProps;
const conditionsStr = "_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_noscript,_invertedColors,_shapeSizeXs,_shapeSizeSm,_shapeSizeMd,_shapeSizeLg,_shapeSizeXl,_shapeRectangle,_shapePerson,_shapeBrowser,_shapeMobile,_shapeCylinder,_shapeStorage,_shapeQueue,_shapeBucket,_shapeDocument,_notDisabled,_reduceGraphics,_reduceGraphicsOnPan,_noReduceGraphics,_whenPanning,_smallZoom,_compoundTransparent,_edgeActive,_whenHovered,_whenSelectable,_whenSelected,_whenDimmed,_whenFocused,_p3,_srgb,_rec2020,xs,xsOnly,xsDown,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,xsToSm,xsToMd,xsToLg,xsToXl,smToMd,smToLg,smToXl,mdToLg,mdToXl,lgToXl,@/xs,@/sm,@/md,@/lg,@likec4-root/xs,@likec4-root/sm,@likec4-root/md,@likec4-root/lg,@likec4-dialog/xs,@likec4-dialog/sm,@likec4-dialog/md,@likec4-dialog/lg,base", conditions = new Set(conditionsStr.split(",")), conditionRegex = /^@|&|&$/;
function isCondition(value) {
  return conditions.has(value) || conditionRegex.test(value);
}
const underscoreRegex = /^_/, conditionsSelectorRegex = /&|@/;
function finalizeConditions(paths) {
  return paths.map((path) => conditions.has(path) ? path.replace(underscoreRegex, "") : conditionsSelectorRegex.test(path) ? `[${withoutSpace(path.trim())}]` : path);
}
function sortConditions(paths) {
  return paths.sort((a, b) => {
    const aa = isCondition(a), bb = isCondition(b);
    return aa && !bb ? 1 : !aa && bb ? -1 : 0;
  });
}
const utilities = "aspectRatio:asp,boxDecorationBreak:bx-db,zIndex:z,boxSizing:bx-s,objectPosition:obj-p,objectFit:obj-f,overscrollBehavior:ovs-b,overscrollBehaviorX:ovs-bx,overscrollBehaviorY:ovs-by,position:pos/1,top:top,left:left,inset:inset,insetInline:inset-x/insetX,insetBlock:inset-y/insetY,insetBlockEnd:inset-be,insetBlockStart:inset-bs,insetInlineEnd:inset-e/insetEnd/end,insetInlineStart:inset-s/insetStart/start,right:right,bottom:bottom,float:float,visibility:vis,display:d,hideFrom:hide,hideBelow:show,flexBasis:flex-b,flex:flex,flexDirection:flex-d/flexDir,flexGrow:flex-g,flexShrink:flex-sh,gridTemplateColumns:grid-tc,gridTemplateRows:grid-tr,gridColumn:grid-c,gridRow:grid-r,gridColumnStart:grid-cs,gridColumnEnd:grid-ce,gridAutoFlow:grid-af,gridAutoColumns:grid-ac,gridAutoRows:grid-ar,gap:gap,gridGap:grid-g,gridRowGap:grid-rg,gridColumnGap:grid-cg,rowGap:rg,columnGap:cg,justifyContent:jc,alignContent:ac,alignItems:ai,alignSelf:as,padding:p/1,paddingLeft:pl/1,paddingRight:pr/1,paddingTop:pt/1,paddingBottom:pb/1,paddingBlock:py/1/paddingY,paddingBlockEnd:pbe,paddingBlockStart:pbs,paddingInline:px/paddingX/1,paddingInlineEnd:pe/1/paddingEnd,paddingInlineStart:ps/1/paddingStart,marginLeft:ml/1,marginRight:mr/1,marginTop:mt/1,marginBottom:mb/1,margin:m/1,marginBlock:my/1/marginY,marginBlockEnd:mbe,marginBlockStart:mbs,marginInline:mx/1/marginX,marginInlineEnd:me/1/marginEnd,marginInlineStart:ms/1/marginStart,spaceX:sx,spaceY:sy,outlineWidth:ring-w/ringWidth,outlineColor:ring-c/ringColor,outline:ring/1,outlineOffset:ring-o/ringOffset,focusRing:focus-ring,focusVisibleRing:focus-v-ring,focusRingColor:focus-ring-c,focusRingOffset:focus-ring-o,focusRingWidth:focus-ring-w,focusRingStyle:focus-ring-s,divideX:dvd-x,divideY:dvd-y,divideColor:dvd-c,divideStyle:dvd-s,width:w/1,inlineSize:w-is,minWidth:min-w/minW,minInlineSize:min-w-is,maxWidth:max-w/maxW,maxInlineSize:max-w-is,height:h/1,blockSize:h-bs,minHeight:min-h/minH,minBlockSize:min-h-bs,maxHeight:max-h/maxH,maxBlockSize:max-b,boxSize:size,color:c,fontFamily:ff,fontSize:fs,fontSizeAdjust:fs-a,fontPalette:fp,fontKerning:fk,fontFeatureSettings:ff-s,fontWeight:fw,fontSmoothing:fsmt,fontVariant:fv,fontVariantAlternates:fv-alt,fontVariantCaps:fv-caps,fontVariationSettings:fv-s,fontVariantNumeric:fv-num,letterSpacing:ls,lineHeight:lh,textAlign:ta,textDecoration:td,textDecorationColor:td-c,textEmphasisColor:te-c,textDecorationStyle:td-s,textDecorationThickness:td-t,textUnderlineOffset:tu-o,textTransform:tt,textIndent:ti,textShadow:tsh,textShadowColor:tsh-c/textShadowColor,WebkitTextFillColor:wktf-c,textOverflow:tov,verticalAlign:va,wordBreak:wb,textWrap:tw,truncate:trunc,lineClamp:lc,listStyleType:li-t,listStylePosition:li-pos,listStyleImage:li-img,listStyle:li-s,backgroundPosition:bg-p/bgPosition,backgroundPositionX:bg-p-x/bgPositionX,backgroundPositionY:bg-p-y/bgPositionY,backgroundAttachment:bg-a/bgAttachment,backgroundClip:bg-cp/bgClip,background:bg/1,backgroundColor:bg-c/bgColor,backgroundOrigin:bg-o/bgOrigin,backgroundImage:bg-i/bgImage,backgroundRepeat:bg-r/bgRepeat,backgroundBlendMode:bg-bm/bgBlendMode,backgroundSize:bg-s/bgSize,backgroundGradient:bg-grad/bgGradient,backgroundLinear:bg-linear/bgLinear,backgroundRadial:bg-radial/bgRadial,backgroundConic:bg-conic/bgConic,textGradient:txt-grad,gradientFromPosition:grad-from-pos,gradientToPosition:grad-to-pos,gradientFrom:grad-from,gradientTo:grad-to,gradientVia:grad-via,gradientViaPosition:grad-via-pos,borderRadius:bdr/rounded,borderTopLeftRadius:bdr-tl/roundedTopLeft,borderTopRightRadius:bdr-tr/roundedTopRight,borderBottomRightRadius:bdr-br/roundedBottomRight,borderBottomLeftRadius:bdr-bl/roundedBottomLeft,borderTopRadius:bdr-t/roundedTop,borderRightRadius:bdr-r/roundedRight,borderBottomRadius:bdr-b/roundedBottom,borderLeftRadius:bdr-l/roundedLeft,borderStartStartRadius:bdr-ss/roundedStartStart,borderStartEndRadius:bdr-se/roundedStartEnd,borderStartRadius:bdr-s/roundedStart,borderEndStartRadius:bdr-es/roundedEndStart,borderEndEndRadius:bdr-ee/roundedEndEnd,borderEndRadius:bdr-e/roundedEnd,border:bd,borderWidth:bd-w,borderTopWidth:bd-t-w,borderLeftWidth:bd-l-w,borderRightWidth:bd-r-w,borderBottomWidth:bd-b-w,borderBlockStartWidth:bd-bs-w,borderBlockEndWidth:bd-be-w,borderColor:bd-c,borderInline:bd-x/borderX,borderInlineWidth:bd-x-w/borderXWidth,borderInlineColor:bd-x-c/borderXColor,borderBlock:bd-y/borderY,borderBlockWidth:bd-y-w/borderYWidth,borderBlockColor:bd-y-c/borderYColor,borderLeft:bd-l,borderLeftColor:bd-l-c,borderInlineStart:bd-s/borderStart,borderInlineStartWidth:bd-s-w/borderStartWidth,borderInlineStartColor:bd-s-c/borderStartColor,borderRight:bd-r,borderRightColor:bd-r-c,borderInlineEnd:bd-e/borderEnd,borderInlineEndWidth:bd-e-w/borderEndWidth,borderInlineEndColor:bd-e-c/borderEndColor,borderTop:bd-t,borderTopColor:bd-t-c,borderBottom:bd-b,borderBottomColor:bd-b-c,borderBlockEnd:bd-be,borderBlockEndColor:bd-be-c,borderBlockStart:bd-bs,borderBlockStartColor:bd-bs-c,opacity:op,boxShadow:bx-sh/shadow,boxShadowColor:bx-sh-c/shadowColor,mixBlendMode:mix-bm,filter:filter,brightness:brightness,contrast:contrast,grayscale:grayscale,hueRotate:hue-rotate,invert:invert,saturate:saturate,sepia:sepia,dropShadow:drop-shadow,blur:blur,backdropFilter:bkdp,backdropBlur:bkdp-blur,backdropBrightness:bkdp-brightness,backdropContrast:bkdp-contrast,backdropGrayscale:bkdp-grayscale,backdropHueRotate:bkdp-hue-rotate,backdropInvert:bkdp-invert,backdropOpacity:bkdp-opacity,backdropSaturate:bkdp-saturate,backdropSepia:bkdp-sepia,borderCollapse:bd-cl,borderSpacing:bd-sp,borderSpacingX:bd-sx,borderSpacingY:bd-sy,tableLayout:tbl,transitionTimingFunction:trs-tmf,transitionDelay:trs-dly,transitionDuration:trs-dur,transitionProperty:trs-prop,transition:transition,animation:anim,animationName:anim-n,animationTimingFunction:anim-tmf,animationDuration:anim-dur,animationDelay:anim-dly,animationPlayState:anim-ps,animationComposition:anim-comp,animationFillMode:anim-fm,animationDirection:anim-dir,animationIterationCount:anim-ic,animationRange:anim-r,animationState:anim-s,animationRangeStart:anim-rs,animationRangeEnd:anim-re,animationTimeline:anim-tl,transformOrigin:trf-o,transformBox:trf-b,transformStyle:trf-s,transform:trf,rotate:rotate,rotateX:rotate-x,rotateY:rotate-y,rotateZ:rotate-z,scale:scale,scaleX:scale-x,scaleY:scale-y,translate:translate,translateX:translate-x/x,translateY:translate-y/y,translateZ:translate-z/z,accentColor:ac-c,caretColor:ca-c,scrollBehavior:scr-bhv,scrollbar:scr-bar,scrollbarColor:scr-bar-c,scrollbarGutter:scr-bar-g,scrollbarWidth:scr-bar-w,scrollMargin:scr-m,scrollMarginLeft:scr-ml,scrollMarginRight:scr-mr,scrollMarginTop:scr-mt,scrollMarginBottom:scr-mb,scrollMarginBlock:scr-my/scrollMarginY,scrollMarginBlockEnd:scr-mbe,scrollMarginBlockStart:scr-mbt,scrollMarginInline:scr-mx/scrollMarginX,scrollMarginInlineEnd:scr-me,scrollMarginInlineStart:scr-ms,scrollPadding:scr-p,scrollPaddingBlock:scr-py/scrollPaddingY,scrollPaddingBlockStart:scr-pbs,scrollPaddingBlockEnd:scr-pbe,scrollPaddingInline:scr-px/scrollPaddingX,scrollPaddingInlineEnd:scr-pe,scrollPaddingInlineStart:scr-ps,scrollPaddingLeft:scr-pl,scrollPaddingRight:scr-pr,scrollPaddingTop:scr-pt,scrollPaddingBottom:scr-pb,scrollSnapAlign:scr-sa,scrollSnapStop:scrs-s,scrollSnapType:scrs-t,scrollSnapStrictness:scrs-strt,scrollSnapMargin:scrs-m,scrollSnapMarginTop:scrs-mt,scrollSnapMarginBottom:scrs-mb,scrollSnapMarginLeft:scrs-ml,scrollSnapMarginRight:scrs-mr,scrollSnapCoordinate:scrs-c,scrollSnapDestination:scrs-d,scrollSnapPointsX:scrs-px,scrollSnapPointsY:scrs-py,scrollSnapTypeX:scrs-tx,scrollSnapTypeY:scrs-ty,scrollTimeline:scrtl,scrollTimelineAxis:scrtl-a,scrollTimelineName:scrtl-n,touchAction:tch-a,userSelect:us,overflow:ov,overflowWrap:ov-wrap,overflowX:ov-x,overflowY:ov-y,overflowAnchor:ov-a,overflowBlock:ov-b,overflowInline:ov-i,overflowClipBox:ovcp-bx,overflowClipMargin:ovcp-m,overscrollBehaviorBlock:ovs-bb,overscrollBehaviorInline:ovs-bi,fill:fill,stroke:stk,strokeWidth:stk-w,strokeDasharray:stk-dsh,strokeDashoffset:stk-do,strokeLinecap:stk-lc,strokeLinejoin:stk-lj,strokeMiterlimit:stk-ml,strokeOpacity:stk-op,srOnly:sr,debug:debug,appearance:ap,backfaceVisibility:bfv,clipPath:cp-path,hyphens:hy,mask:msk,maskImage:msk-i,maskSize:msk-s,textSizeAdjust:txt-adj,container:cq,containerName:cq-n,containerType:cq-t,cursor:cursor,textStyle:textStyle,layerStyle:layerStyle,animationStyle:animationStyle", classNameByProp = /* @__PURE__ */ new Map(), shorthands = /* @__PURE__ */ new Map();
utilities.split(",").forEach((utility) => {
  const [prop, meta] = utility.split(":"), [className, ...shorthandList] = meta.split("/");
  classNameByProp.set(prop, className), shorthandList.length && shorthandList.forEach((shorthand) => {
    shorthands.set(shorthand === "1" ? className : shorthand, prop);
  });
});
const resolveShorthand = (prop) => shorthands.get(prop) || prop, context = {
  conditions: {
    shift: sortConditions,
    finalize: finalizeConditions,
    breakpoints: { keys: ["base", "xs", "sm", "md", "lg", "xl"] }
  },
  utility: {
    transform: (prop, value) => {
      const key2 = resolveShorthand(prop);
      return { className: `${classNameByProp.get(key2) || hypenateProperty(key2)}_${withoutSpace(value)}` };
    },
    hasShorthand: !0,
    toHash: (path, hashFn) => hashFn(path.join(":")),
    resolveShorthand
  }
}, cssFn = createCss(context), css = (...styles) => cssFn(mergeCss(...styles));
css.raw = (...styles) => mergeCss(...styles);
const { mergeCss } = createMergeCss(context);
function cx() {
  let str = "", i = 0, arg;
  for (; i < arguments.length; )
    (arg = arguments[i++]) && typeof arg == "string" && (str && (str += " "), str += arg);
  return str;
}
const defaults = (conf) => ({
  base: {},
  variants: {},
  defaultVariants: {},
  compoundVariants: [],
  ...conf
});
function cva(config) {
  const { base, variants, defaultVariants, compoundVariants } = defaults(config), getVariantProps2 = (variants2) => ({ ...defaultVariants, ...compact(variants2) });
  function resolve(props = {}) {
    const computedVariants = getVariantProps2(props);
    let variantCss = { ...base };
    for (const [key2, value] of Object.entries(computedVariants))
      variants[key2]?.[value] && (variantCss = mergeCss(variantCss, variants[key2][value]));
    const compoundVariantCss = getCompoundVariantCss(compoundVariants, computedVariants);
    return mergeCss(variantCss, compoundVariantCss);
  }
  function merge(__cva) {
    const override = defaults(__cva.config), variantKeys2 = uniq(__cva.variantKeys, Object.keys(variants));
    return cva({
      base: mergeCss(base, override.base),
      variants: Object.fromEntries(
        variantKeys2.map((key2) => [key2, mergeCss(variants[key2], override.variants[key2])])
      ),
      defaultVariants: mergeProps(defaultVariants, override.defaultVariants),
      compoundVariants: [...compoundVariants, ...override.compoundVariants]
    });
  }
  function cvaFn(props) {
    return css(resolve(props));
  }
  const variantKeys = Object.keys(variants);
  function splitVariantProps(props) {
    return splitProps(props, variantKeys);
  }
  const variantMap = Object.fromEntries(Object.entries(variants).map(([key2, value]) => [key2, Object.keys(value)]));
  return Object.assign(memo(cvaFn), {
    __cva__: !0,
    variantMap,
    variantKeys,
    raw: resolve,
    config,
    merge,
    splitVariantProps,
    getVariantProps: getVariantProps2
  });
}
function getCompoundVariantCss(compoundVariants, variantMap) {
  let result = {};
  return compoundVariants.forEach((compoundVariant) => {
    Object.entries(compoundVariant).every(([key2, value]) => key2 === "css" ? !0 : (Array.isArray(value) ? value : [value]).some((value2) => variantMap[key2] === value2)) && (result = mergeCss(result, compoundVariant.css));
  }), result;
}
function assertCompoundVariant(name, compoundVariants, variants, prop) {
  if (compoundVariants.length > 0 && typeof variants?.[prop] == "object")
    throw new Error(`[recipe:${name}:${prop}] Conditions are not supported when using compound variants.`);
}
function sva(config) {
  const slots = Object.entries(getSlotRecipes(config)).map(([slot, slotCva]) => [slot, cva(slotCva)]), defaultVariants = config.defaultVariants ?? {}, classNameMap = slots.reduce((acc, [slot, cvaFn]) => (config.className && (acc[slot] = cvaFn.config.className), acc), {});
  function svaFn(props) {
    const result = slots.map(([slot, cvaFn]) => [slot, cx(cvaFn(props), classNameMap[slot])]);
    return Object.fromEntries(result);
  }
  function raw(props) {
    const result = slots.map(([slot, cvaFn]) => [slot, cvaFn.raw(props)]);
    return Object.fromEntries(result);
  }
  const variants = config.variants ?? {}, variantKeys = Object.keys(variants);
  function splitVariantProps(props) {
    return splitProps(props, variantKeys);
  }
  const getVariantProps2 = (variants2) => ({ ...defaultVariants, ...compact(variants2) }), variantMap = Object.fromEntries(
    Object.entries(variants).map(([key2, value]) => [key2, Object.keys(value)])
  );
  return Object.assign(memo(svaFn), {
    __cva__: !1,
    raw,
    config,
    variantMap,
    variantKeys,
    classNameMap,
    splitVariantProps,
    getVariantProps: getVariantProps2
  });
}
var defaultAttributes = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
const createReactComponent = (type, iconName, iconNamePascal, iconNode) => {
  const Component = forwardRef(
    ({ color = "currentColor", size: size2 = 24, stroke = 2, title: title2, className, children, ...rest }, ref) => createElement(
      "svg",
      {
        ref,
        ...defaultAttributes[type],
        width: size2,
        height: size2,
        className: ["tabler-icon", `tabler-icon-${iconName}`, className].join(" "),
        ...type === "filled" ? {
          fill: color
        } : {
          strokeWidth: stroke,
          stroke: color
        },
        ...rest
      },
      [
        title2 && createElement("title", { key: "svg-title" }, title2),
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );
  return Component.displayName = `${iconNamePascal}`, Component;
};
const __iconNode$S = [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]], IconAlertTriangle = createReactComponent("outline", "alert-triangle", "AlertTriangle", __iconNode$S);
const __iconNode$R = [["path", { d: "M7 7l10 10", key: "svg-0" }], ["path", { d: "M17 8l0 9l-9 0", key: "svg-1" }]], IconArrowDownRight = createReactComponent("outline", "arrow-down-right", "ArrowDownRight", __iconNode$R);
const __iconNode$Q = [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M5 12l6 6", key: "svg-1" }], ["path", { d: "M5 12l6 -6", key: "svg-2" }]], IconArrowLeft = createReactComponent("outline", "arrow-left", "ArrowLeft", __iconNode$Q);
const __iconNode$P = [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M13 18l6 -6", key: "svg-1" }], ["path", { d: "M13 6l6 6", key: "svg-2" }]], IconArrowRight = createReactComponent("outline", "arrow-right", "ArrowRight", __iconNode$P);
const __iconNode$O = [["path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11", key: "svg-0" }]], IconBolt = createReactComponent("outline", "bolt", "Bolt", __iconNode$O);
const __iconNode$N = [["path", { d: "M4 8h16", key: "svg-0" }], ["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-1" }], ["path", { d: "M8 4v4", key: "svg-2" }]], IconBrowser = createReactComponent("outline", "browser", "Browser", __iconNode$N);
const __iconNode$M = [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]], IconCheck = createReactComponent("outline", "check", "Check", __iconNode$M);
const __iconNode$L = [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]], IconChevronDown = createReactComponent("outline", "chevron-down", "ChevronDown", __iconNode$L);
const __iconNode$K = [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]], IconChevronLeft = createReactComponent("outline", "chevron-left", "ChevronLeft", __iconNode$K);
const __iconNode$J = [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]], IconChevronRight = createReactComponent("outline", "chevron-right", "ChevronRight", __iconNode$J);
const __iconNode$I = [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]], IconCopy = createReactComponent("outline", "copy", "Copy", __iconNode$I);
const __iconNode$H = [["path", { d: "M12 6m-7 0a7 3 0 1 0 14 0a7 3 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M5 6v12c0 1.657 3.134 3 7 3s7 -1.343 7 -3v-12", key: "svg-1" }]], IconCylinder = createReactComponent("outline", "cylinder", "Cylinder", __iconNode$H);
const __iconNode$G = [["path", { d: "M6 5a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-14z", key: "svg-0" }], ["path", { d: "M11 4h2", key: "svg-1" }], ["path", { d: "M12 17v.01", key: "svg-2" }]], IconDeviceMobile = createReactComponent("outline", "device-mobile", "DeviceMobile", __iconNode$G);
const __iconNode$F = [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]], IconExternalLink = createReactComponent("outline", "external-link", "ExternalLink", __iconNode$F);
const __iconNode$E = [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M10 13l-1 2l1 2", key: "svg-2" }], ["path", { d: "M14 13l1 2l-1 2", key: "svg-3" }]], IconFileCode = createReactComponent("outline", "file-code", "FileCode", __iconNode$E);
const __iconNode$D = [["path", { d: "M4 21v-4a3 3 0 0 1 3 -3h5", key: "svg-0" }], ["path", { d: "M9 17l3 -3l-3 -3", key: "svg-1" }], ["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-2" }], ["path", { d: "M5 11v-6a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-9.5", key: "svg-3" }]], IconFileSymlink = createReactComponent("outline", "file-symlink", "FileSymlink", __iconNode$D);
const __iconNode$C = [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M9 9l1 0", key: "svg-2" }], ["path", { d: "M9 13l6 0", key: "svg-3" }], ["path", { d: "M9 17l6 0", key: "svg-4" }]], IconFileText = createReactComponent("outline", "file-text", "FileText", __iconNode$C);
const __iconNode$B = [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-1" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-2" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-3" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-4" }]], IconFocusCentered = createReactComponent("outline", "focus-centered", "FocusCentered", __iconNode$B);
const __iconNode$A = [["path", { d: "M5 19l2.757 -7.351a1 1 0 0 1 .936 -.649h12.307a1 1 0 0 1 .986 1.164l-.996 5.211a2 2 0 0 1 -1.964 1.625h-14.026a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2", key: "svg-0" }]], IconFolderOpen = createReactComponent("outline", "folder-open", "FolderOpen", __iconNode$A);
const __iconNode$z = [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 16v.01", key: "svg-1" }], ["path", { d: "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483", key: "svg-2" }]], IconHelpCircle = createReactComponent("outline", "help-circle", "HelpCircle", __iconNode$z);
const __iconNode$y = [["path", { d: "M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v10a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3z", key: "svg-0" }], ["path", { d: "M9 10m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M15 8l2 0", key: "svg-2" }], ["path", { d: "M15 12l2 0", key: "svg-3" }], ["path", { d: "M7 16l10 0", key: "svg-4" }]], IconId = createReactComponent("outline", "id", "Id", __iconNode$y);
const __iconNode$x = [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]], IconInfoCircle = createReactComponent("outline", "info-circle", "InfoCircle", __iconNode$x);
const __iconNode$w = [["path", { d: "M4 20l16 0", key: "svg-0" }], ["path", { d: "M9 4m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignBottom = createReactComponent("outline", "layout-align-bottom", "LayoutAlignBottom", __iconNode$w);
const __iconNode$v = [["path", { d: "M12 4l0 5", key: "svg-0" }], ["path", { d: "M12 15l0 5", key: "svg-1" }], ["path", { d: "M6 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-2" }]], IconLayoutAlignCenter = createReactComponent("outline", "layout-align-center", "LayoutAlignCenter", __iconNode$v);
const __iconNode$u = [["path", { d: "M4 4l0 16", key: "svg-0" }], ["path", { d: "M8 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignLeft = createReactComponent("outline", "layout-align-left", "LayoutAlignLeft", __iconNode$u);
const __iconNode$t = [["path", { d: "M4 12l5 0", key: "svg-0" }], ["path", { d: "M15 12l5 0", key: "svg-1" }], ["path", { d: "M9 6m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }]], IconLayoutAlignMiddle = createReactComponent("outline", "layout-align-middle", "LayoutAlignMiddle", __iconNode$t);
const __iconNode$s = [["path", { d: "M20 4l0 16", key: "svg-0" }], ["path", { d: "M4 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignRight = createReactComponent("outline", "layout-align-right", "LayoutAlignRight", __iconNode$s);
const __iconNode$r = [["path", { d: "M4 4l16 0", key: "svg-0" }], ["path", { d: "M9 8m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]], IconLayoutAlignTop = createReactComponent("outline", "layout-align-top", "LayoutAlignTop", __iconNode$r);
const __iconNode$q = [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M4 12h8", key: "svg-1" }], ["path", { d: "M12 15h8", key: "svg-2" }], ["path", { d: "M12 9h8", key: "svg-3" }], ["path", { d: "M12 4v16", key: "svg-4" }]], IconLayoutBoardSplit = createReactComponent("outline", "layout-board-split", "LayoutBoardSplit", __iconNode$q);
const __iconNode$p = [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M10 4l4 16", key: "svg-1" }], ["path", { d: "M12 12l-8 2", key: "svg-2" }]], IconLayoutCollage = createReactComponent("outline", "layout-collage", "LayoutCollage", __iconNode$p);
const __iconNode$o = [["path", { d: "M5 4h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-0" }], ["path", { d: "M5 16h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-1" }], ["path", { d: "M15 12h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-2" }], ["path", { d: "M15 4h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-3" }]], IconLayoutDashboard = createReactComponent("outline", "layout-dashboard", "LayoutDashboard", __iconNode$o);
const __iconNode$n = [["path", { d: "M9 15l6 -6", key: "svg-0" }], ["path", { d: "M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464", key: "svg-1" }], ["path", { d: "M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463", key: "svg-2" }]], IconLink = createReactComponent("outline", "link", "Link", __iconNode$n);
const __iconNode$m = [["path", { d: "M3 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M9 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M13 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]], IconLockOpen2 = createReactComponent("outline", "lock-open-2", "LockOpen2", __iconNode$m);
const __iconNode$l = [["path", { d: "M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z", key: "svg-0" }], ["path", { d: "M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M8 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]], IconLock = createReactComponent("outline", "lock", "Lock", __iconNode$l);
const __iconNode$k = [["path", { d: "M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z", key: "svg-0" }], ["path", { d: "M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2", key: "svg-1" }], ["path", { d: "M19 11h2m-1 -1v2", key: "svg-2" }]], IconMoonStars = createReactComponent("outline", "moon-stars", "MoonStars", __iconNode$k);
const __iconNode$j = [["path", { d: "M21 14.008v-5.018a1.98 1.98 0 0 0 -1 -1.717l-4 -2.008a2.016 2.016 0 0 0 -2 0l-10 5.008c-.619 .355 -1 1.01 -1 1.718v5.018c0 .709 .381 1.363 1 1.717l4 2.008a2.016 2.016 0 0 0 2 0l10 -5.008c.619 -.355 1 -1.01 1 -1.718z", key: "svg-0" }], ["path", { d: "M9 21v-7.5", key: "svg-1" }], ["path", { d: "M9 13.5l11.5 -5.5", key: "svg-2" }], ["path", { d: "M3.5 11l5.5 2.5", key: "svg-3" }]], IconRectangularPrism = createReactComponent("outline", "rectangular-prism", "RectangularPrism", __iconNode$j);
const __iconNode$i = [["path", { d: "M3 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-0" }], ["path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-1" }], ["path", { d: "M17 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-2" }], ["path", { d: "M5 11v-3a3 3 0 0 1 3 -3h8a3 3 0 0 1 3 3v3", key: "svg-3" }], ["path", { d: "M16.5 8.5l2.5 2.5l2.5 -2.5", key: "svg-4" }]], IconReorder = createReactComponent("outline", "reorder", "Reorder", __iconNode$i);
const __iconNode$h = [["path", { d: "M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M18 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M12 19h4.5c.71 0 1.372 -.212 1.924 -.576m1.545 -2.459a3.5 3.5 0 0 0 -3.469 -3.965h-.499m-4 0h-3.501a3.5 3.5 0 0 1 -2.477 -5.972m2.477 -1.028h3.5", key: "svg-2" }], ["path", { d: "M3 3l18 18", key: "svg-3" }]], IconRouteOff = createReactComponent("outline", "route-off", "RouteOff", __iconNode$h);
const __iconNode$g = [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]], IconSearch = createReactComponent("outline", "search", "Search", __iconNode$g);
const __iconNode$f = [["path", { d: "M8 9l4 -4l4 4", key: "svg-0" }], ["path", { d: "M16 15l-4 4l-4 -4", key: "svg-1" }]], IconSelector = createReactComponent("outline", "selector", "Selector", __iconNode$f);
const __iconNode$e = [["path", { d: "M6 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-0" }], ["path", { d: "M18 6m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-1" }], ["path", { d: "M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-2" }], ["path", { d: "M8.7 10.7l6.6 -3.4", key: "svg-3" }], ["path", { d: "M8.7 13.3l6.6 3.4", key: "svg-4" }]], IconShare = createReactComponent("outline", "share", "Share", __iconNode$e);
const __iconNode$d = [["path", { d: "M12 4l-8 4l8 4l8 -4l-8 -4", key: "svg-0" }], ["path", { d: "M4 12l8 4l8 -4", key: "svg-1" }], ["path", { d: "M4 16l8 4l8 -4", key: "svg-2" }]], IconStack2 = createReactComponent("outline", "stack-2", "Stack2", __iconNode$d);
const __iconNode$c = [["path", { d: "M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0", key: "svg-0" }], ["path", { d: "M3 12h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7", key: "svg-1" }]], IconSun = createReactComponent("outline", "sun", "Sun", __iconNode$c);
const __iconNode$b = [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M12 12m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0", key: "svg-1" }], ["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-2" }]], IconTarget = createReactComponent("outline", "target", "Target", __iconNode$b);
const __iconNode$a = [["path", { d: "M3 6a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-0" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-1" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-2" }], ["path", { d: "M15 18a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]], IconTransform = createReactComponent("outline", "transform", "Transform", __iconNode$a);
const __iconNode$9 = [["path", { d: "M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0", key: "svg-0" }], ["path", { d: "M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }]], IconUser = createReactComponent("outline", "user", "User", __iconNode$9);
const __iconNode$8 = [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]], IconX = createReactComponent("outline", "x", "X", __iconNode$8);
const __iconNode$7 = [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }], ["path", { d: "M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-4" }], ["path", { d: "M16 16l-2.5 -2.5", key: "svg-5" }]], IconZoomScan = createReactComponent("outline", "zoom-scan", "ZoomScan", __iconNode$7);
const __iconNode$6 = [["path", { d: "M10.52 2.614a2.095 2.095 0 0 1 2.835 -.117l.126 .117l7.905 7.905c.777 .777 .816 2.013 .117 2.836l-.117 .126l-7.905 7.905a2.094 2.094 0 0 1 -2.836 .117l-.126 -.117l-7.907 -7.906a2.096 2.096 0 0 1 -.115 -2.835l.117 -.126l7.905 -7.905zm5.969 9.535l.01 -.116l-.003 -.12l-.016 -.114l-.03 -.11l-.044 -.112l-.052 -.098l-.076 -.105l-.07 -.081l-3.5 -3.5l-.095 -.083a1 1 0 0 0 -1.226 0l-.094 .083l-.083 .094a1 1 0 0 0 0 1.226l.083 .094l1.792 1.793h-5.085l-.117 .007a1 1 0 0 0 0 1.986l.117 .007h5.085l-1.792 1.793l-.083 .094a1 1 0 0 0 1.403 1.403l.094 -.083l3.5 -3.5l.097 -.112l.05 -.074l.037 -.067l.05 -.112l.023 -.076l.025 -.117z", key: "svg-0" }]], IconDirectionSignFilled = createReactComponent("filled", "direction-sign-filled", "DirectionSignFilled", __iconNode$6);
const __iconNode$5 = [["path", { d: "M9 3a1 1 0 0 1 .608 .206l.1 .087l2.706 2.707h6.586a3 3 0 0 1 2.995 2.824l.005 .176v8a3 3 0 0 1 -2.824 2.995l-.176 .005h-14a3 3 0 0 1 -2.995 -2.824l-.005 -.176v-11a3 3 0 0 1 2.824 -2.995l.176 -.005h4z", key: "svg-0" }]], IconFolderFilled = createReactComponent("filled", "folder-filled", "FolderFilled", __iconNode$5);
const __iconNode$4 = [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]], IconPlayerPlayFilled = createReactComponent("filled", "player-play-filled", "PlayerPlayFilled", __iconNode$4);
const __iconNode$3 = [["path", { d: "M19.496 4.136l-12 7a1 1 0 0 0 0 1.728l12 7a1 1 0 0 0 1.504 -.864v-14a1 1 0 0 0 -1.504 -.864z", key: "svg-0" }], ["path", { d: "M4 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]], IconPlayerSkipBackFilled = createReactComponent("filled", "player-skip-back-filled", "PlayerSkipBackFilled", __iconNode$3);
const __iconNode$2 = [["path", { d: "M3 5v14a1 1 0 0 0 1.504 .864l12 -7a1 1 0 0 0 0 -1.728l-12 -7a1 1 0 0 0 -1.504 .864z", key: "svg-0" }], ["path", { d: "M20 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]], IconPlayerSkipForwardFilled = createReactComponent("filled", "player-skip-forward-filled", "PlayerSkipForwardFilled", __iconNode$2);
const __iconNode$1 = [["path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", key: "svg-0" }]], IconPlayerStopFilled = createReactComponent("filled", "player-stop-filled", "PlayerStopFilled", __iconNode$1);
const __iconNode = [["path", { d: "M8.243 7.34l-6.38 .925l-.113 .023a1 1 0 0 0 -.44 1.684l4.622 4.499l-1.09 6.355l-.013 .11a1 1 0 0 0 1.464 .944l5.706 -3l5.693 3l.1 .046a1 1 0 0 0 1.352 -1.1l-1.091 -6.355l4.624 -4.5l.078 -.085a1 1 0 0 0 -.633 -1.62l-6.38 -.926l-2.852 -5.78a1 1 0 0 0 -1.794 0l-2.853 5.78z", key: "svg-0" }]], IconStarFilled = createReactComponent("filled", "star-filled", "StarFilled", __iconNode), IconRendererContext = createContext(null);
function IconRendererProvider({
  value,
  children
}) {
  return useContext(IconRendererContext) ? /* @__PURE__ */ jsx(Fragment, { children }) : /* @__PURE__ */ jsx(IconRendererContext.Provider, { value, children });
}
function IconRenderer({
  element,
  className,
  style
}) {
  const RenderIcon = useContext(IconRendererContext);
  if (!element || !element.icon || element.icon === "none")
    return null;
  let icon2;
  return element.icon.startsWith("http://") || element.icon.startsWith("https://") ? icon2 = /* @__PURE__ */ jsx("img", { src: element.icon, alt: element.title }) : RenderIcon && (icon2 = /* @__PURE__ */ jsx(RenderIcon, { node: element })), icon2 ? /* @__PURE__ */ jsx(
    "div",
    {
      className: cx(
        className,
        "likec4-element-icon"
      ),
      "data-likec4-icon": element.icon,
      style,
      children: icon2
    }
  ) : null;
}
const ShapeIcons = {
  browser: IconBrowser,
  cylinder: IconCylinder,
  mobile: IconDeviceMobile,
  person: IconUser,
  queue: IconReorder,
  rectangle: IconRectangularPrism,
  storage: IconCylinder,
  bucket: IconCylinder,
  document: IconFileText
};
function IconOrShapeRenderer({
  element,
  className
}) {
  const icon2 = /* @__PURE__ */ jsx(IconRenderer, { element, className });
  if (icon2)
    return icon2;
  const ShapeIcon = ShapeIcons[element.shape];
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: cx(
        className,
        "likec4-shape-icon"
      ),
      children: /* @__PURE__ */ jsx(ShapeIcon, {})
    }
  );
}
function literalToEnum(value) {
  switch (value) {
    case "dots":
      return BackgroundVariant.Dots;
    case "lines":
      return BackgroundVariant.Lines;
    case "cross":
      return BackgroundVariant.Cross;
    default:
      nonexhaustive(value);
  }
}
const compareProps = (prev, next) => typeof prev.background == "string" && typeof next.background == "string" ? prev.background === next.background : deepEqual(prev.background, next.background), Background = memo$1(({ background }) => typeof background == "string" ? /* @__PURE__ */ jsx(Background$1, { variant: literalToEnum(background), size: 2, gap: 20 }) : /* @__PURE__ */ jsx(Background$1, { ...background }), compareProps);
Background.displayName = "Background";
function useCallbackRef(callback) {
  const ref = useRef(callback);
  ref.current = callback;
  const callbackRef = useRef(null);
  return callbackRef.current == null && (callbackRef.current = ((...args) => ref.current?.(...args))), callbackRef.current;
}
const noop = () => {
}, depsShallowEqual = (d1, d2) => {
  if (d1 === d2)
    return !0;
  if (d1.length !== d2.length)
    return !1;
  for (const [i, element] of d1.entries())
    if (!(element === d2[i] || shallowEqual(element, d2[i])))
      return !1;
  return !0;
};
function useUpdateEffect(callback, deps, equalityFn, effectHook) {
  const isFirstMount = useFirstMountState();
  useCustomCompareEffect(
    isFirstMount ? noop : callback,
    deps,
    depsShallowEqual,
    effectHook
  );
}
function useXYFlow() {
  return useReactFlow();
}
function useXYStore(selector3, equalityFn) {
  return useStore(
    useCallbackRef(selector3),
    equalityFn ?? shallowEqual
  );
}
function useXYStoreApi() {
  return useStoreApi();
}
const selectCurrentZoom = (state) => Math.round(state.transform[2] * 100) / 100;
function useCurrentZoom() {
  return useStore(selectCurrentZoom);
}
const selectZoom = (state) => state.transform[2] < 0.2;
function useIsZoomTooSmall() {
  return useStore(selectZoom);
}
function getDevicePixelRatio() {
  const dpr = typeof window < "u" && typeof window.devicePixelRatio == "number" ? window.devicePixelRatio : 1;
  return t(Math.floor(dpr), {
    min: 1,
    max: 4
  });
}
let knownDpr;
function roundDpr(v) {
  return knownDpr ??= getDevicePixelRatio(), knownDpr < 2 ? Math.round(v) : Math.round(v * knownDpr) / knownDpr;
}
function isEqualRects(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
const nodeToRect = (nd) => ({
  x: Math.round(nd.internals.positionAbsolute.x),
  y: Math.round(nd.internals.positionAbsolute.y),
  width: nd.measured?.width ?? nd.width ?? nd.initialWidth ?? 0,
  height: nd.measured?.height ?? nd.height ?? nd.initialHeight ?? 0
});
function getNodeCenter(node2) {
  const { width, height } = getNodeDimensions(node2), { x, y } = node2.internals.positionAbsolute;
  return {
    x: Math.round(x + width / 2),
    y: Math.round(y + height / 2)
  };
}
function getNodeIntersectionFromCenterToPoint(intersectionNode, target, nodeMargin = 0) {
  const { width, height } = intersectionNode, nodeCenter = BBox.center(intersectionNode), v = vector(target.x, target.y).subtract(nodeCenter), xScale = (nodeMargin + width / 2) / v.x, yScale = (nodeMargin + height / 2) / v.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v).multiply(scale2).add(nodeCenter).round();
}
function bezierControlPoints(points) {
  let [start, ...bezierPoints] = points;
  invariant(start, "start should be defined");
  const handles = [
    // start
  ];
  for (; t$1(bezierPoints, 3); ) {
    const [cp1, cp2, end, ...rest] = bezierPoints, bezier = new Bezier(start[0], start[1], cp1[0], cp1[1], cp2[0], cp2[1], end[0], end[1]), inflections = bezier.inflections();
    inflections.length === 0 && inflections.push(0.5), inflections.forEach((t2) => {
      const { x, y } = bezier.get(t2);
      handles.push({
        x: Math.round(x),
        y: Math.round(y)
      });
    }), bezierPoints = rest, start = end;
  }
  return invariant(bezierPoints.length === 0, "all points should be consumed"), invariant(t$1(handles, 1), "at least one control point should be generated"), handles;
}
function isSamePoint(a, b) {
  const pointA = e(a) ? { x: a[0], y: a[1] } : a, pointB = e(b) ? { x: b[0], y: b[1] } : b;
  return distanceBetweenPoints(pointA, pointB) < 2.1;
}
function distanceBetweenPoints(a, b) {
  return Math.hypot(b.x - a.x, b.y - a.y);
}
function stopPropagation(e2) {
  return e2.stopPropagation();
}
function bezierPath(bezierSpline) {
  let [start, ...points] = bezierSpline;
  invariant(start, "start should be defined");
  let path = `M ${start[0]},${start[1]}`;
  for (; t$1(points, 3); ) {
    const [cp1, cp2, end, ...rest] = points;
    path = path + ` C ${cp1[0]},${cp1[1]} ${cp2[0]},${cp2[1]} ${end[0]},${end[1]}`, points = rest;
  }
  return invariant(points.length === 0, "all points should be consumed"), path;
}
const _setDimmed = (v, dimmed) => (v.data.dimmed ?? !1) === dimmed ? v : {
  ...v,
  data: {
    ...v.data,
    dimmed
  }
};
function setDimmed(arg1, arg2) {
  return arg2 !== void 0 ? _setDimmed(arg1, arg2) : (v) => _setDimmed(v, arg1);
}
const _setHovered = (v, hovered) => (v.data.hovered ?? !1) === hovered ? v : {
  ...v,
  data: {
    ...v.data,
    hovered
  }
};
function setHovered(arg1, arg2) {
  return arg2 !== void 0 ? _setHovered(arg1, arg2) : (v) => _setHovered(v, arg1);
}
function _setData(value, state) {
  return n(value.data, state) ? value : {
    ...value,
    data: {
      ...value.data,
      ...state
    }
  };
}
function setData(arg1, arg2) {
  return arg2 !== void 0 ? _setData(arg1, arg2) : (edge) => _setData(edge, arg1);
}
const Base = {
  setDimmed,
  setHovered,
  setData
}, ZIndexes = {
  Compound: 1,
  // XYFlow increments zIndexes of compounds
  Edge: 20,
  Element: 20,
  Max: 30
}, MinZoom = 0.05, MaxZoom = 3, FitViewPaddings = {
  default: "16px",
  withControls: {
    top: "58px",
    left: "16px",
    right: "16px",
    bottom: "16px"
  }
};
function BaseXYFlow({
  nodes,
  edges,
  onEdgesChange,
  onNodesChange,
  className,
  pannable = !0,
  zoomable = !0,
  nodesSelectable = !0,
  nodesDraggable = !1,
  background = "dots",
  children,
  colorMode,
  fitViewPadding = 0,
  fitView = !0,
  zoomOnDoubleClick = !1,
  onViewportResize,
  onMoveEnd,
  onNodeMouseEnter: onNodeMouseEnter2,
  onNodeMouseLeave: onNodeMouseLeave2,
  onEdgeMouseEnter: onEdgeMouseEnter2,
  onEdgeMouseLeave: onEdgeMouseLeave2,
  ...props
}) {
  const fitViewOptions = useMemo(() => ({
    minZoom: MinZoom,
    maxZoom: 1,
    padding: fitViewPadding,
    includeHiddenNodes: !1
  }), [fitViewPadding]), isBgWithPattern = background !== "transparent" && background !== "solid", isZoomTooSmall = useIsZoomTooSmall(), xystore = useXYStoreApi(), { colorScheme } = useMantineColorScheme();
  return colorMode || (colorMode = colorScheme === "auto" ? "system" : colorScheme), /* @__PURE__ */ jsxs(
    index,
    {
      colorMode,
      nodes,
      edges,
      className: cx(
        background === "transparent" && "bg-transparent",
        className
      ),
      ...isZoomTooSmall && {
        "data-likec4-zoom-small": !0
      },
      zoomOnPinch: zoomable,
      zoomOnScroll: !pannable && zoomable,
      ...!zoomable && {
        zoomActivationKeyCode: null
      },
      zoomOnDoubleClick,
      maxZoom: zoomable ? MaxZoom : 1,
      minZoom: zoomable ? MinZoom : 1,
      fitView,
      fitViewOptions,
      preventScrolling: zoomable || pannable,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      noWheelClassName: "nowheel",
      panOnScroll: pannable,
      panOnDrag: pannable,
      ...!pannable && {
        panActivationKeyCode: null,
        selectionKeyCode: null
      },
      elementsSelectable: nodesSelectable,
      nodesFocusable: nodesDraggable || nodesSelectable,
      edgesFocusable: !1,
      nodesDraggable,
      nodeDragThreshold: 4,
      nodeClickDistance: 3,
      paneClickDistance: 3,
      elevateNodesOnSelect: !1,
      selectNodesOnDrag: !1,
      onNodesChange,
      onEdgesChange,
      onMoveEnd: useCallbackRef((event, { x, y, zoom }) => {
        const roundedX = roundDpr(x), roundedY = roundDpr(y);
        (x !== roundedX || y !== roundedY) && xystore.setState({ transform: [roundedX, roundedY, zoom] }), onMoveEnd?.(event, { x: roundedX, y: roundedY, zoom });
      }),
      onNodeMouseEnter: useCallbackRef((event, node2) => {
        if (onNodeMouseEnter2) {
          onNodeMouseEnter2(event, node2);
          return;
        }
        onNodesChange([{
          id: node2.id,
          type: "replace",
          item: Base.setHovered(node2, !0)
        }]);
      }),
      onNodeMouseLeave: useCallbackRef((event, node2) => {
        if (onNodeMouseLeave2) {
          onNodeMouseLeave2(event, node2);
          return;
        }
        onNodesChange([{
          id: node2.id,
          type: "replace",
          item: Base.setHovered(node2, !1)
        }]);
      }),
      onEdgeMouseEnter: useCallbackRef((event, edge) => {
        if (onEdgeMouseEnter2) {
          onEdgeMouseEnter2(event, edge);
          return;
        }
        onEdgesChange([{
          id: edge.id,
          type: "replace",
          item: Base.setHovered(edge, !0)
        }]);
      }),
      onEdgeMouseLeave: useCallbackRef((event, edge) => {
        if (onEdgeMouseLeave2) {
          onEdgeMouseLeave2(event, edge);
          return;
        }
        onEdgesChange([{
          id: edge.id,
          type: "replace",
          item: Base.setHovered(edge, !1)
        }]);
      }),
      onNodeDoubleClick: stopPropagation,
      onEdgeDoubleClick: stopPropagation,
      ...props,
      children: [
        isBgWithPattern && /* @__PURE__ */ jsx(Background, { background }),
        onViewportResize && /* @__PURE__ */ jsx(ViewportResizeHanlder, { onViewportResize }),
        children
      ]
    }
  );
}
const selectDimensions = ({ width, height }) => (width || 1) * (height || 1), ViewportResizeHanlder = ({
  onViewportResize
}) => {
  const square = useStore(selectDimensions);
  return useUpdateEffect(onViewportResize, [square]), null;
}, EMPTY_OBJ$1 = {};
function _update$1(current, updated) {
  return current === updated ? current : (updated = updated.map((update) => {
    const existing = current.find(
      (n2) => n2.id === update.id && n2.type === update.type && n2.source === update.source && n2.target === update.target
    );
    if (!existing)
      return update;
    const isSameData = deepEqual(existing.data, update.data), data = isSameData ? existing.data : update.data;
    return isSameData && deepEqual(existing.hidden, update.hidden ?? existing.hidden) && deepEqual(existing.selected, update.selected ?? existing.selected) && deepEqual(existing.selectable, update.selectable ?? existing.selectable) && deepEqual(existing.focusable, update.focusable ?? existing.focusable) && deepEqual(existing.animated, update.animated ?? existing.animated) && deepEqual(existing.className, update.className) && deepEqual(existing.zIndex, update.zIndex ?? existing.zIndex) && deepEqual(existing.label, update.label) && deepEqual(existing.sourceHandle, update.sourceHandle) && deepEqual(existing.targetHandle, update.targetHandle) && deepEqual(existing.style ?? EMPTY_OBJ$1, update.style ?? EMPTY_OBJ$1) ? existing : {
      // Retain existing properties that are defined, except parentId
      ...t$2(existing, e$1),
      // Apply updates, omitting undefined values
      ...t$2(update, e$1),
      data
    };
  }), t$3(current, updated) ? current : updated);
}
function updateEdges(current, update) {
  return e$1(update) ? _update$1(current, update) : (update = current, (current2) => _update$1(current2, update));
}
const EMPTY_OBJ = {};
function _update(current, updated) {
  return current === updated ? current : (updated = updated.map((update) => {
    const existing = current.find((n2) => n2.id === update.id && n2.type === update.type);
    if (!existing)
      return update;
    const isSameData = n(existing.data, update.data);
    let data = isSameData ? existing.data : update.data;
    isSameData || (e$1(existing.data.hovered) && !e$1(update.data.hovered) && (data = {
      ...data,
      hovered: existing.data.hovered
    }), e$1(existing.data.dimmed) && !e$1(update.data.dimmed) && (data = {
      ...data,
      dimmed: existing.data.dimmed
    }));
    const { width: existingWidth, height: existingHeight } = getNodeDimensions(existing), haveHandles = Object.hasOwn(existing, "handles") || Object.hasOwn(update, "handles"), isSameHandles = !haveHandles || deepEqual(existing.handles ?? [], update.handles ?? []);
    if (isSameData && isSameHandles && deepEqual(existingWidth, update.width ?? update.initialWidth) && deepEqual(existingHeight, update.height ?? update.initialHeight) && deepEqual(existing.parentId ?? null, update.parentId ?? null) && deepEqual(existing.hidden, update.hidden ?? existing.hidden) && deepEqual(existing.selected, update.selected ?? existing.selected) && deepEqual(existing.selectable, update.selectable ?? existing.selectable) && deepEqual(existing.focusable, update.focusable ?? existing.focusable) && deepEqual(existing.draggable, update.draggable ?? existing.draggable) && deepEqual(existing.dragHandle, update.dragHandle) && deepEqual(existing.className, update.className) && deepEqual(existing.zIndex, update.zIndex ?? existing.zIndex) && deepEqual(existing.position, update.position) && deepEqual(existing.domAttributes ?? EMPTY_OBJ, update.domAttributes ?? EMPTY_OBJ) && deepEqual(existing.style ?? EMPTY_OBJ, update.style ?? EMPTY_OBJ))
      return existing;
    const handles = haveHandles && isSameHandles ? existing.handles : update.handles;
    return {
      // Retain existing properties that are defined, except parentId
      ...t$2(existing, (v, k) => e$1(v) && k !== "parentId"),
      // Retain measured dimensions from existing if present
      ..."measured" in existing && {
        measured: {
          width: update.width ?? update.initialWidth,
          height: update.height ?? update.initialHeight
        }
      },
      // Apply updates, omitting undefined values
      ...t$2(update, e$1),
      // Force dimensions
      width: update.width ?? update.initialWidth,
      height: update.height ?? update.initialHeight,
      ...handles && { handles },
      data
    };
  }), t$3(current, updated) ? current : updated);
}
function updateNodes(current, update) {
  return e$1(update) ? _update(current, update) : (update = current, (existing) => _update(existing, update));
}
const RootContainerContext = createContext(null);
function useRootContainer() {
  const ctx = useContext(RootContainerContext);
  if (!ctx)
    throw new Error("useRootContainer must be used within a RootContainer");
  return ctx;
}
function useRootContainerRef() {
  return useRootContainer().ref;
}
function useRootContainerElement() {
  return useRootContainer().ref.current;
}
const ReduceGraphicsModeCtx = createContext(null);
function useIsReducedGraphics() {
  const isReduced = useContext(ReduceGraphicsModeCtx);
  return isReduced === null && console.warn("ReduceGraphicsMode is not provided"), isReduced ?? !1;
}
const [PanningAtomSafeCtx, usePanningAtom] = createSafeContext$1(
  "PanningAtomSafeCtx is not provided"
);
function RootContainer({
  id,
  className,
  reduceGraphics = !1,
  children
}) {
  const [mounted, setMounted] = useState(!1), ref = useRef(null), $isPanningRef = useRef(null);
  $isPanningRef.current || ($isPanningRef.current = atom(!1)), useIsomorphicLayoutEffect(() => {
    setMounted(!0);
  }, []), useEffect(() => $isPanningRef.current?.subscribe((isPanning) => {
    ref.current?.setAttribute("data-likec4-diagram-panning", isPanning ? "true" : "false");
  }), []);
  const ctx = useMemo(() => ({ id, ref }), [id, ref]);
  return /* @__PURE__ */ jsx(PanningAtomSafeCtx, { value: $isPanningRef.current, children: /* @__PURE__ */ jsx(ReduceGraphicsModeCtx.Provider, { value: reduceGraphics, children: /* @__PURE__ */ jsx(
    "div",
    {
      id,
      className: cx("likec4-root", className),
      ref,
      ...reduceGraphics && {
        "data-likec4-reduced-graphics": !0
      },
      children: mounted && !!ctx.ref.current && /* @__PURE__ */ jsx(RootContainerContext.Provider, { value: ctx, children })
    }
  ) }) });
}
const defaultHandlers = {
  onNavigateTo: null,
  onNodeClick: null,
  onNodeContextMenu: null,
  onCanvasContextMenu: null,
  onEdgeClick: null,
  onEdgeContextMenu: null,
  onCanvasClick: null,
  onCanvasDblClick: null,
  onLogoClick: null,
  onOpenSource: null,
  onInitialized: null,
  onLayoutTypeChange: null
}, HandlerNames = t$4(defaultHandlers), DiagramEventHandlersReactContext = createContext({
  ...t$5(HandlerNames, (name) => [name, null]),
  handlersRef: {
    current: defaultHandlers
  }
});
function DiagramEventHandlers({
  handlers,
  children
}) {
  const handlersRef = useSyncedRef(
    handlers
  ), deps = HandlerNames.map((name) => e$2(handlers[name])), value = useMemo(() => ({
    ...t$5(HandlerNames, (name) => handlersRef.current[name] ? [name, (...args) => handlersRef.current[name]?.(...args)] : [name, null]),
    handlersRef
  }), [handlersRef, ...deps]);
  return /* @__PURE__ */ jsx(DiagramEventHandlersReactContext.Provider, { value, children });
}
function useDiagramEventHandlers() {
  return useContext(DiagramEventHandlersReactContext);
}
const DefaultFeatures = {
  enableEditor: !1,
  enableReadOnly: !0,
  enableCompareWithLatest: !1,
  enableControls: !1,
  enableDynamicViewWalkthrough: !1,
  enableElementDetails: !1,
  enableFocusMode: !1,
  enableNavigateTo: !1,
  enableNotations: !1,
  enableRelationshipBrowser: !1,
  enableRelationshipDetails: !1,
  enableSearch: !1,
  enableNavigationButtons: !1,
  enableFitView: !1,
  enableVscode: !1,
  enableElementTags: !1
}, DiagramFeaturesContext = createContext(DefaultFeatures);
function DiagramFeatures({
  children,
  features,
  overrides
}) {
  const outerScope = useContext(DiagramFeaturesContext), [scope, setScope] = useState(outerScope);
  return useEffect(
    () => {
      setScope((current) => {
        const next = {
          ...outerScope,
          ...features,
          ...overrides
        };
        return shallowEqual(current, next) ? current : next;
      });
    },
    [outerScope, features, overrides]
  ), /* @__PURE__ */ jsx(DiagramFeaturesContext.Provider, { value: scope, children });
}
const overridesForOverlays = {
  enableControls: !1,
  enableReadOnly: !0,
  enableCompareWithLatest: !1
};
DiagramFeatures.Overlays = ({ children }) => /* @__PURE__ */ jsx(DiagramFeatures, { overrides: overridesForOverlays, children });
function useEnabledFeatures() {
  return useContext(DiagramFeaturesContext);
}
function IfEnabled({
  feature,
  children,
  and: and2 = !0
}) {
  return useEnabledFeatures()[`enable${feature}`] === !0 && and2 ? /* @__PURE__ */ jsx(Fragment, { children }) : null;
}
const DefaultTheme = createTheme({
  autoContrast: !0,
  primaryColor: "indigo",
  cursorType: "pointer",
  defaultRadius: "sm",
  fontFamily: "var(--likec4-app-font, var(--likec4-app-font-default))",
  headings: {
    fontWeight: "500",
    sizes: {
      h1: {
        // fontSize: '2rem',
        fontWeight: "600"
      },
      h2: {
        fontWeight: "500"
        // fontSize: '1.85rem',
      }
    }
  },
  components: {
    Portal: Portal.extend({
      defaultProps: {
        reuseTargetNode: !0
      }
    }),
    Tooltip: Tooltip$6.extend({
      defaultProps: {
        color: "dark"
      }
    })
  }
});
css({
  cursor: "pointer",
  "--mantine-cursor-pointer": "pointer",
  "& :where(.likec4-diagram, .likec4-compound-node, .likec4-element-node)": {
    cursor: "pointer"
  }
});
function EnsureMantine({ children }) {
  const mantineCtx = useContext(MantineContext);
  return useEffect(() => {
    mantineCtx || console.warn("LikeC4Diagram must be a child of MantineProvider");
  }, []), mantineCtx ? /* @__PURE__ */ jsx(Fragment, { children }) : /* @__PURE__ */ jsx(MantineProvider, { defaultColorScheme: "auto", theme: DefaultTheme, children });
}
EnsureMantine.displayName = "EnsureMantine";
const FramerMotionConfig = ({
  reducedMotion = "user",
  children
}) => {
  const nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx(LazyMotion, { features: domMax, strict: !0, children: /* @__PURE__ */ jsx(MotionConfig, { reducedMotion, ...nonce && { nonce }, children }) });
}, LikeC4ModelContext = createContext(null), CurrentViewModelContext = createContext(null);
function useLikeC4Model() {
  const model = useContext(LikeC4ModelContext);
  if (!model)
    throw new Error("LikeC4Model not found. Make sure you have LikeC4ModelProvider.");
  return model;
}
function useLikeC4Specification() {
  const model = useLikeC4Model(), [specification, setSpecification] = useState(model.$data.specification);
  return useEffect(() => {
    setSpecification((current) => deepEqual(current, model.$data.specification) ? current : model.$data.specification);
  }, [model]), specification;
}
const TagStylesContext = createContext({}), radixColors = DefaultTagColors, generateColorVars = (spec) => {
  const color = spec.color;
  if (isTagColorSpecified(spec))
    return `
      --colors-likec4-tag-bg: ${color};
      --colors-likec4-tag-bg-hover: color-mix(in oklab, ${color}, var(--colors-likec4-mix-color) 20%);
    `;
  if (!radixColors.includes(color))
    return "";
  let textcolor = "12";
  return ["mint", "grass", "lime", "yellow", "amber"].includes(color) && (textcolor = "dark-2"), `
  --colors-likec4-tag-border: var(--colors-${color}-8);
  --colors-likec4-tag-bg: var(--colors-${color}-9);
  --colors-likec4-tag-bg-hover: var(--colors-${color}-10);
  --colors-likec4-tag-text: var(--colors-${color}-${textcolor});
  `;
};
function generateStylesheet(tags, rootSelector) {
  return !tags || e$3(tags) ? "" : t$6(
    t$9(tags),
    t$8(([tag, spec]) => [
      `:is(${rootSelector} [data-likec4-tag="${tag}"]) {`,
      generateColorVars(spec),
      "}"
    ]),
    t$7(`
`)
  );
}
function TagStylesProvider({ children, rootSelector }) {
  const tags = useLikeC4Specification().tags, stylesheet = generateStylesheet(tags, rootSelector);
  return /* @__PURE__ */ jsxs(TagStylesContext.Provider, { value: tags, children: [
    stylesheet !== "" && /* @__PURE__ */ jsx(TagStylesheet, { stylesheet }),
    children
  ] });
}
const TagStylesheet = memo$1(({ stylesheet }) => {
  const nonce = useMantineStyleNonce()?.();
  return /* @__PURE__ */ jsx("style", { "data-likec4-tags": !0, type: "text/css", dangerouslySetInnerHTML: { __html: stylesheet }, nonce });
});
function useTagSpecification(tag) {
  return useContext(TagStylesContext)[tag] ?? {
    color: "tomato"
  };
}
const LikeC4EditorReactContext = createContext(null);
function LikeC4EditorProvider({ children, editor }) {
  return /* @__PURE__ */ jsx(LikeC4EditorReactContext.Provider, { value: editor, children });
}
function useOptionalLikeC4EditorPort() {
  return useContext(LikeC4EditorReactContext);
}
function useId() {
  return useId$1().replace("mantine-", "likec4-");
}
var userGeneratedStr = "css,pos,insetX,insetY,insetEnd,end,insetStart,start,flexDir,p,pl,pr,pt,pb,py,paddingY,paddingX,px,pe,paddingEnd,ps,paddingStart,ml,mr,mt,mb,m,my,marginY,mx,marginX,me,marginEnd,ms,marginStart,ringWidth,ringColor,ring,ringOffset,w,minW,maxW,h,minH,maxH,textShadowColor,bgPosition,bgPositionX,bgPositionY,bgAttachment,bgClip,bg,bgColor,bgOrigin,bgImage,bgRepeat,bgBlendMode,bgSize,bgGradient,bgLinear,bgRadial,bgConic,rounded,roundedTopLeft,roundedTopRight,roundedBottomRight,roundedBottomLeft,roundedTop,roundedRight,roundedBottom,roundedLeft,roundedStartStart,roundedStartEnd,roundedStart,roundedEndStart,roundedEndEnd,roundedEnd,borderX,borderXWidth,borderXColor,borderY,borderYWidth,borderYColor,borderStart,borderStartWidth,borderStartColor,borderEnd,borderEndWidth,borderEndColor,shadow,shadowColor,x,y,z,scrollMarginY,scrollMarginX,scrollPaddingY,scrollPaddingX,aspectRatio,boxDecorationBreak,zIndex,boxSizing,objectPosition,objectFit,overscrollBehavior,overscrollBehaviorX,overscrollBehaviorY,position,top,left,inset,insetInline,insetBlock,insetBlockEnd,insetBlockStart,insetInlineEnd,insetInlineStart,right,bottom,float,visibility,display,hideFrom,hideBelow,flexBasis,flex,flexDirection,flexGrow,flexShrink,gridTemplateColumns,gridTemplateRows,gridColumn,gridRow,gridColumnStart,gridColumnEnd,gridAutoFlow,gridAutoColumns,gridAutoRows,gap,gridGap,gridRowGap,gridColumnGap,rowGap,columnGap,justifyContent,alignContent,alignItems,alignSelf,padding,paddingLeft,paddingRight,paddingTop,paddingBottom,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingInline,paddingInlineEnd,paddingInlineStart,marginLeft,marginRight,marginTop,marginBottom,margin,marginBlock,marginBlockEnd,marginBlockStart,marginInline,marginInlineEnd,marginInlineStart,spaceX,spaceY,outlineWidth,outlineColor,outline,outlineOffset,focusRing,focusVisibleRing,focusRingColor,focusRingOffset,focusRingWidth,focusRingStyle,divideX,divideY,divideColor,divideStyle,width,inlineSize,minWidth,minInlineSize,maxWidth,maxInlineSize,height,blockSize,minHeight,minBlockSize,maxHeight,maxBlockSize,boxSize,color,fontFamily,fontSize,fontSizeAdjust,fontPalette,fontKerning,fontFeatureSettings,fontWeight,fontSmoothing,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariationSettings,fontVariantNumeric,letterSpacing,lineHeight,textAlign,textDecoration,textDecorationColor,textEmphasisColor,textDecorationStyle,textDecorationThickness,textUnderlineOffset,textTransform,textIndent,textShadow,WebkitTextFillColor,textOverflow,verticalAlign,wordBreak,textWrap,truncate,lineClamp,listStyleType,listStylePosition,listStyleImage,listStyle,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundAttachment,backgroundClip,background,backgroundColor,backgroundOrigin,backgroundImage,backgroundRepeat,backgroundBlendMode,backgroundSize,backgroundGradient,backgroundLinear,backgroundRadial,backgroundConic,textGradient,gradientFromPosition,gradientToPosition,gradientFrom,gradientTo,gradientVia,gradientViaPosition,borderRadius,borderTopLeftRadius,borderTopRightRadius,borderBottomRightRadius,borderBottomLeftRadius,borderTopRadius,borderRightRadius,borderBottomRadius,borderLeftRadius,borderStartStartRadius,borderStartEndRadius,borderStartRadius,borderEndStartRadius,borderEndEndRadius,borderEndRadius,border,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,borderBlockStartWidth,borderBlockEndWidth,borderColor,borderInline,borderInlineWidth,borderInlineColor,borderBlock,borderBlockWidth,borderBlockColor,borderLeft,borderLeftColor,borderInlineStart,borderInlineStartWidth,borderInlineStartColor,borderRight,borderRightColor,borderInlineEnd,borderInlineEndWidth,borderInlineEndColor,borderTop,borderTopColor,borderBottom,borderBottomColor,borderBlockEnd,borderBlockEndColor,borderBlockStart,borderBlockStartColor,opacity,boxShadow,boxShadowColor,mixBlendMode,filter,brightness,contrast,grayscale,hueRotate,invert,saturate,sepia,dropShadow,blur,backdropFilter,backdropBlur,backdropBrightness,backdropContrast,backdropGrayscale,backdropHueRotate,backdropInvert,backdropOpacity,backdropSaturate,backdropSepia,borderCollapse,borderSpacing,borderSpacingX,borderSpacingY,tableLayout,transitionTimingFunction,transitionDelay,transitionDuration,transitionProperty,transition,animation,animationName,animationTimingFunction,animationDuration,animationDelay,animationPlayState,animationComposition,animationFillMode,animationDirection,animationIterationCount,animationRange,animationState,animationRangeStart,animationRangeEnd,animationTimeline,transformOrigin,transformBox,transformStyle,transform,rotate,rotateX,rotateY,rotateZ,scale,scaleX,scaleY,translate,translateX,translateY,translateZ,accentColor,caretColor,scrollBehavior,scrollbar,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollMargin,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollMarginBottom,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollPaddingBottom,scrollSnapAlign,scrollSnapStop,scrollSnapType,scrollSnapStrictness,scrollSnapMargin,scrollSnapMarginTop,scrollSnapMarginBottom,scrollSnapMarginLeft,scrollSnapMarginRight,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,touchAction,userSelect,overflow,overflowWrap,overflowX,overflowY,overflowAnchor,overflowBlock,overflowInline,overflowClipBox,overflowClipMargin,overscrollBehaviorBlock,overscrollBehaviorInline,fill,stroke,strokeWidth,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,srOnly,debug,appearance,backfaceVisibility,clipPath,hyphens,mask,maskImage,maskSize,textSizeAdjust,container,containerName,containerType,cursor,colorPalette,_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,_noscript,_invertedColors,_shapeSizeXs,_shapeSizeSm,_shapeSizeMd,_shapeSizeLg,_shapeSizeXl,_shapeRectangle,_shapePerson,_shapeBrowser,_shapeMobile,_shapeCylinder,_shapeStorage,_shapeQueue,_shapeBucket,_shapeDocument,_notDisabled,_reduceGraphics,_reduceGraphicsOnPan,_noReduceGraphics,_whenPanning,_smallZoom,_compoundTransparent,_edgeActive,_whenHovered,_whenSelectable,_whenSelected,_whenDimmed,_whenFocused,_p3,_srgb,_rec2020,xs,xsOnly,xsDown,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,xsToSm,xsToMd,xsToLg,xsToXl,smToMd,smToLg,smToXl,mdToLg,mdToXl,lgToXl,@/xs,@/sm,@/md,@/lg,@likec4-root/xs,@likec4-root/sm,@likec4-root/md,@likec4-root/lg,@likec4-dialog/xs,@likec4-dialog/sm,@likec4-dialog/md,@likec4-dialog/lg,textStyle,layerStyle,animationStyle", userGenerated = userGeneratedStr.split(","), cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,WebkitUserSelect,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,anchorName,anchorScope,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimeline,animationTimingFunction,appearance,aspectRatio,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBlockStyle,borderBlockWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineColor,borderInlineEnd,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderInlineStyle,borderInlineWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,clipRule,color,colorInterpolationFilters,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,cx,cy,d,direction,display,dominantBaseline,emptyCells,fieldSizing,fill,fillOpacity,fillRule,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,floodColor,floodOpacity,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontVariationSettings,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,interpolateSize,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lightingColor,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,marker,markerEnd,markerMid,markerStart,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,positionAnchor,positionArea,positionTry,positionTryFallbacks,positionTryOrder,positionVisibility,printColorAdjust,quotes,r,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,rx,ry,scale,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginBottom,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockEnd,scrollPaddingBlockStart,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,scrollbarColor,scrollbarGutter,scrollbarWidth,shapeImageThreshold,shapeMargin,shapeOutside,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,tabSize,tableLayout,textAlign,textAlignLast,textAnchor,textBox,textBoxEdge,textBoxTrim,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textSpacingTrim,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,textWrapMode,textWrapStyle,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,vectorEffect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,x,y,zIndex,zoom,alignmentBaseline,baselineShift,colorInterpolation,colorRendering,glyphOrientationVertical", allCssProperties = cssPropertiesStr.split(",").concat(userGenerated), properties = new Map(allCssProperties.map((prop) => [prop, !0])), cssPropertySelectorRegex = /&|@/, isCssProperty = /* @__PURE__ */ memo((prop) => properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop));
const defaultShouldForwardProp = (prop, variantKeys) => !variantKeys.includes(prop) && !isCssProperty(prop), composeShouldForwardProps = (tag, shouldForwardProp2) => tag.__shouldForwardProps__ && shouldForwardProp2 ? (propName) => tag.__shouldForwardProps__(propName) && shouldForwardProp2(propName) : shouldForwardProp2, composeCvaFn = (cvaA, cvaB) => {
  if (cvaA && !cvaB) return cvaA;
  if (!cvaA && cvaB) return cvaB;
  if (cvaA.__cva__ && cvaB.__cva__ || cvaA.__recipe__ && cvaB.__recipe__) return cvaA.merge(cvaB);
  const error = new TypeError("Cannot merge cva with recipe. Please use either cva or recipe.");
  throw TypeError.captureStackTrace?.(error), error;
}, getDisplayName = (Component) => typeof Component == "string" ? Component : Component?.displayName || Component?.name || "Component";
function styledFn(Dynamic, configOrCva = {}, options = {}) {
  const cvaFn = configOrCva.__cva__ || configOrCva.__recipe__ ? configOrCva : cva(configOrCva), forwardFn = options.shouldForwardProp || defaultShouldForwardProp, shouldForwardProp2 = (prop) => options.forwardProps?.includes(prop) ? !0 : forwardFn(prop, cvaFn.variantKeys), defaultProps = Object.assign(
    options.dataAttr && configOrCva.__name__ ? { "data-recipe": configOrCva.__name__ } : {},
    options.defaultProps
  ), __cvaFn__ = composeCvaFn(Dynamic.__cva__, cvaFn), __shouldForwardProps__ = composeShouldForwardProps(Dynamic, shouldForwardProp2), __base__ = Dynamic.__base__ || Dynamic, StyledComponent = /* @__PURE__ */ forwardRef(function(props, ref) {
    const { as: Element = __base__, unstyled, children, ...restProps } = props, combinedProps = useMemo(() => Object.assign({}, defaultProps, restProps), [restProps]), [htmlProps2, forwardedProps, variantProps, styleProps, elementProps] = useMemo(() => splitProps(combinedProps, normalizeHTMLProps.keys, __shouldForwardProps__, __cvaFn__.variantKeys, isCssProperty), [combinedProps]);
    function recipeClass() {
      const { css: cssStyles, ...propStyles } = styleProps, compoundVariantStyles = __cvaFn__.__getCompoundVariantCss__?.(variantProps);
      return cx(__cvaFn__(variantProps, !1), css(compoundVariantStyles, propStyles, cssStyles), combinedProps.className);
    }
    function cvaClass() {
      const { css: cssStyles, ...propStyles } = styleProps, cvaStyles = __cvaFn__.raw(variantProps);
      return cx(css(cvaStyles, propStyles, cssStyles), combinedProps.className);
    }
    const classes2 = () => {
      if (unstyled) {
        const { css: cssStyles, ...propStyles } = styleProps;
        return cx(css(propStyles, cssStyles), combinedProps.className);
      }
      return configOrCva.__recipe__ ? recipeClass() : cvaClass();
    };
    return createElement(Element, {
      ref,
      ...forwardedProps,
      ...elementProps,
      ...normalizeHTMLProps(htmlProps2),
      className: classes2()
    }, children ?? combinedProps.children);
  }), name = getDisplayName(__base__);
  return StyledComponent.displayName = `styled.${name}`, StyledComponent.__cva__ = __cvaFn__, StyledComponent.__base__ = __base__, StyledComponent.__shouldForwardProps__ = shouldForwardProp2, StyledComponent;
}
function createJsxFactory() {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(styledFn, {
    apply(_, __, args) {
      return styledFn(...args);
    },
    get(_, el) {
      return cache.has(el) || cache.set(el, styledFn(el)), cache.get(el);
    }
  });
}
const styled = /* @__PURE__ */ createJsxFactory();
function createSafeContext(contextName) {
  const Context = createContext(void 0);
  return [Context, (componentName, slot) => {
    const context2 = useContext(Context);
    if (context2 === void 0) {
      const componentInfo = componentName ? `Component "${componentName}"` : "A component", slotInfo = slot ? ` (slot: "${slot}")` : "";
      throw new Error(
        `${componentInfo}${slotInfo} cannot access ${contextName} because it's missing its Provider.`
      );
    }
    return context2;
  }];
}
function createStyleContext(recipe) {
  const isConfigRecipe = "__recipe__" in recipe, recipeName = isConfigRecipe && recipe.__name__ ? recipe.__name__ : void 0, contextName = recipeName ? `createStyleContext("${recipeName}")` : "createStyleContext", [StyleContext, useStyleContext] = createSafeContext(contextName), svaFn = isConfigRecipe ? recipe : sva(recipe.config), getResolvedProps = (props, slotStyles) => {
    const { unstyled, ...restProps } = props;
    return unstyled ? restProps : isConfigRecipe ? { ...restProps, className: cx(slotStyles, restProps.className) } : { ...slotStyles, ...restProps };
  };
  return {
    withRootProvider: (Component, options) => {
      const WithRootProvider = (props) => {
        const [variantProps, otherProps] = svaFn.splitVariantProps(props), slotStyles = isConfigRecipe ? svaFn(variantProps) : svaFn.raw(variantProps);
        slotStyles._classNameMap = svaFn.classNameMap;
        const mergedProps = options?.defaultProps ? { ...options.defaultProps, ...otherProps } : otherProps;
        return createElement(StyleContext.Provider, {
          value: slotStyles,
          children: createElement(Component, mergedProps)
        });
      }, componentName = getDisplayName(Component);
      return WithRootProvider.displayName = `withRootProvider(${componentName})`, WithRootProvider;
    },
    withProvider: (Component, slot, options) => {
      const StyledComponent = styled(Component, {}, options), WithProvider = forwardRef((props, ref) => {
        const [variantProps, restProps] = svaFn.splitVariantProps(props), slotStyles = isConfigRecipe ? svaFn(variantProps) : svaFn.raw(variantProps);
        slotStyles._classNameMap = svaFn.classNameMap;
        const propsWithClass = { ...restProps, className: restProps.className ?? options?.defaultProps?.className }, resolvedProps = getResolvedProps(propsWithClass, slotStyles[slot]);
        return createElement(StyleContext.Provider, {
          value: slotStyles,
          children: createElement(StyledComponent, {
            ...resolvedProps,
            className: cx(resolvedProps.className, slotStyles._classNameMap[slot]),
            ref
          })
        });
      }), componentName = getDisplayName(Component);
      return WithProvider.displayName = `withProvider(${componentName})`, WithProvider;
    },
    withContext: (Component, slot, options) => {
      const StyledComponent = styled(Component, {}, options), componentName = getDisplayName(Component), WithContext = forwardRef((props, ref) => {
        const slotStyles = useStyleContext(componentName, slot), propsWithClass = { ...props, className: props.className ?? options?.defaultProps?.className }, resolvedProps = getResolvedProps(propsWithClass, slotStyles[slot]);
        return createElement(StyledComponent, {
          ...resolvedProps,
          className: cx(resolvedProps.className, slotStyles._classNameMap[slot]),
          ref
        });
      });
      return WithContext.displayName = `withContext(${componentName})`, WithContext;
    }
  };
}
const boxConfig = {
  transform(props) {
    return props;
  }
}, getBoxStyle = (styles = {}) => {
  const _styles = getPatternStyles(boxConfig, styles);
  return boxConfig.transform(_styles, patternFns);
}, Box = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, []), styleProps = getBoxStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), vstackConfig = {
  transform(props) {
    const { justify, gap, ...rest } = props;
    return {
      display: "flex",
      alignItems: "center",
      justifyContent: justify,
      gap,
      flexDirection: "column",
      ...rest
    };
  },
  defaultValues: { alignItems: "stretch", gap: "sm" }
}, getVstackStyle = (styles = {}) => {
  const _styles = getPatternStyles(vstackConfig, styles);
  return vstackConfig.transform(_styles, patternFns);
}, vstack = (styles) => css(getVstackStyle(styles));
vstack.raw = getVstackStyle;
const VStack = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, ["justify", "gap"]), styleProps = getVstackStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), hstackConfig = {
  transform(props) {
    const { justify, gap, ...rest } = props;
    return {
      display: "flex",
      alignItems: "center",
      justifyContent: justify,
      gap,
      flexDirection: "row",
      ...rest
    };
  },
  defaultValues: { gap: "sm" }
}, getHstackStyle = (styles = {}) => {
  const _styles = getPatternStyles(hstackConfig, styles);
  return hstackConfig.transform(_styles, patternFns);
}, hstack = (styles) => css(getHstackStyle(styles));
hstack.raw = getHstackStyle;
const HStack = /* @__PURE__ */ forwardRef(function(props, ref) {
  const [patternProps, restProps] = splitProps(props, ["justify", "gap"]), styleProps = getHstackStyle(patternProps), mergedProps = { ref, ...styleProps, ...restProps };
  return createElement(styled.div, mergedProps);
}), containerConfig = {
  transform(props) {
    return {
      position: "relative",
      maxWidth: "8xl",
      mx: "auto",
      px: { base: "4", md: "6", lg: "8" },
      ...props
    };
  }
}, getContainerStyle = (styles = {}) => {
  const _styles = getPatternStyles(containerConfig, styles);
  return containerConfig.transform(_styles, patternFns);
}, container$3 = (styles) => css(getContainerStyle(styles));
container$3.raw = getContainerStyle;
const bleedConfig = {
  transform(props, { map, isCssUnit: isCssUnit2, isCssVar: isCssVar2 }) {
    const { inline, block, ...rest } = props, valueFn = (v) => isCssUnit2(v) || isCssVar2(v) ? v : `token(spacing.${v}, ${v})`;
    return {
      "--bleed-x": map(inline, valueFn),
      "--bleed-y": map(block, valueFn),
      marginInline: "calc(var(--bleed-x, 0) * -1)",
      marginBlock: "calc(var(--bleed-y, 0) * -1)",
      ...rest
    };
  },
  defaultValues: { inline: "0", block: "0" }
}, getBleedStyle = (styles = {}) => {
  const _styles = getPatternStyles(bleedConfig, styles);
  return bleedConfig.transform(_styles, patternFns);
}, bleed = (styles) => css(getBleedStyle(styles));
bleed.raw = getBleedStyle;
function ErrorFallback({ error, resetErrorBoundary }) {
  const errorString = error instanceof Error ? error.message : "Unknown error", dialogRef = useRef(null);
  return useEffect(() => {
    dialogRef.current?.showModal();
  }, []), /* @__PURE__ */ jsx(
    "dialog",
    {
      ref: dialogRef,
      className: css({
        margin: "0",
        padding: "0",
        position: "fixed",
        top: "10",
        left: "10",
        width: "[calc(100vw - ({spacing.10} * 2))]",
        height: "max-content",
        maxHeight: "[calc(100vh - ({spacing.10} * 3))]",
        background: "likec4.overlay.body",
        rounded: "sm",
        borderWidth: 3,
        borderColor: "likec4.overlay.border",
        shadow: "xl",
        outline: "none",
        _backdrop: {
          cursor: "zoom-out",
          backdropFilter: "blur(18px)",
          bg: "[color-mix(in oklab, {colors.likec4.overlay.backdrop} 60%, transparent)]"
        }
      }),
      onClick: (e2) => {
        if (e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG") {
          dialogRef.current?.close();
          return;
        }
      },
      onClose: (e2) => {
        e2.stopPropagation(), resetErrorBoundary();
      },
      children: /* @__PURE__ */ jsxs(HStack, { p: "xl", gap: "lg", alignItems: "flex-start", flexWrap: "nowrap", children: [
        /* @__PURE__ */ jsx(ThemeIcon, { size: "md", radius: "xl", color: "red", children: /* @__PURE__ */ jsx(IconX, { style: { width: 20, height: 20 } }) }),
        /* @__PURE__ */ jsxs(VStack, { flex: "1", children: [
          /* @__PURE__ */ jsx(Text, { fz: "md", children: "Oops, something went wrong" }),
          /* @__PURE__ */ jsx(ScrollAreaAutosize, { maw: "100%", mah: 400, type: "auto", children: /* @__PURE__ */ jsx(Text, { fz: "md", c: "red", style: { whiteSpace: "pre-wrap", userSelect: "all" }, children: errorString }) }),
          /* @__PURE__ */ jsxs(HStack, { gap: "md", mt: "md", children: [
            /* @__PURE__ */ jsx(Button, { size: "sm", variant: "default", onClick: () => resetErrorBoundary(), children: "Reset" }),
            /* @__PURE__ */ jsx(Text, { fz: "sm", c: "dimmed", children: "See console for more details and report the issue if it persists." })
          ] })
        ] })
      ] })
    }
  );
}
function ErrorBoundary(props) {
  return /* @__PURE__ */ jsx(
    ErrorBoundary$1,
    {
      FallbackComponent: ErrorFallback,
      onError: (err, info) => {
        console.error(err, info);
      },
      ...props
    }
  );
}
const DiagramActorSafeContext = createContext(null);
DiagramActorSafeContext.displayName = "DiagramActorSafeContext";
const DiagramApiSafeContext = createContext(null);
DiagramApiSafeContext.displayName = "DiagramApiSafeContext";
const DiagramActorContextProvider = DiagramActorSafeContext.Provider, DiagramApiContextProvider = DiagramApiSafeContext.Provider;
function useDiagramActorRef() {
  const ctx = useContext(DiagramActorSafeContext);
  if (ctx === null)
    throw new Error("DiagramActorRef is not provided");
  return ctx;
}
function useDiagram() {
  const ctx = useContext(DiagramApiSafeContext);
  if (ctx === null)
    throw new Error("DiagramApi is not provided");
  return ctx;
}
function useDiagramActorSnapshot(selector3, compare2 = shallowEqual) {
  const actorRef = useDiagramActorRef();
  return useSelector(actorRef, selector3, compare2);
}
function useDiagramContext(selector3, compare2 = shallowEqual, deps) {
  const actorRef = useDiagramActorRef(), selectorRef = useCallbackRef(selector3), select2 = useCallback((s) => selectorRef(s.context), deps ?? []);
  return useSelector(actorRef, select2, compare2);
}
function useOnDiagramEvent(event, callback, options) {
  const actorRef = useDiagramActorRef(), callbackRef = useCallbackRef(callback), wasCalled = useRef(!1), once = options?.once ?? !1;
  useEffect(() => {
    if (once && wasCalled.current)
      return;
    let subscription = actorRef.on(event, (payload) => {
      callbackRef(payload), wasCalled.current = !0, once && (subscription?.unsubscribe(), subscription = null);
    });
    return () => {
      subscription?.unsubscribe();
    };
  }, [actorRef, event, once]);
}
const select$1 = (s) => s.children.overlays;
function useOverlaysActorRef() {
  return useDiagramActorSnapshot(select$1, Object.is);
}
const select = (s) => s.children.search ?? null;
function useSearchActorRef() {
  return useDiagramActorSnapshot(select, Object.is);
}
const selectViewId = (s) => s.context.view.id;
function useCurrentViewId() {
  const actorRef = useDiagramActorRef();
  return useSelector(actorRef, selectViewId);
}
const selectView = (s) => s.context.view;
function useCurrentView() {
  const actorRef = useDiagramActorRef();
  return useSelector(actorRef, selectView, shallowEqual);
}
function useOptionalCurrentViewModel() {
  return useContext(CurrentViewModelContext);
}
function useCurrentViewModel() {
  const vm = useContext(CurrentViewModelContext);
  if (!vm)
    throw new Error("No LikeC4ViewModel in context found");
  return vm;
}
function useMantinePortalProps() {
  const target = useRootContainerElement();
  return useMemo(() => target ? { portalProps: { target }, withinPortal: !0 } : { withinPortal: !1 }, [target]);
}
const _actorLogic$1 = setup({
  delays: {
    "open timeout": 500,
    "close timeout": 350
  },
  actions: {
    "update activatedBy": assign({
      activatedBy: ({ context: context2, event }) => {
        switch (!0) {
          case event.type.includes("click"):
            return "click";
          case event.type.includes("mouseEnter"):
            return "hover";
          default:
            return context2.activatedBy;
        }
      }
    }),
    "keep dropdown open": assign({
      activatedBy: "click"
    }),
    "update selected folder": assign(({ event }) => event.type === "breadcrumbs.click.root" ? { selectedFolder: "" } : (assertEvent(event, ["breadcrumbs.click.folder", "select.folder"]), { selectedFolder: event.folderPath })),
    "reset selected folder": assign({
      selectedFolder: ({ context: context2 }) => context2.viewModel?.folder.path ?? ""
    }),
    "update inputs": assign(({ context: context2, event }) => {
      assertEvent(event, "update.inputs");
      const viewChanged = event.inputs.viewModel?.id !== context2.viewModel?.id;
      let selectedFolder = context2.selectedFolder;
      return event.inputs.viewModel?.folder.path.startsWith(selectedFolder) || (selectedFolder = event.inputs.viewModel?.folder.path ?? ""), {
        view: event.inputs.view,
        viewModel: event.inputs.viewModel,
        selectedFolder,
        // allow dropdown to close on mouse leave if view changed
        activatedBy: viewChanged ? "hover" : context2.activatedBy
      };
    }),
    "reset search query": assign({
      searchQuery: ""
    }),
    "update search query": assign(({ event }) => (assertEvent(event, "searchQuery.change"), { searchQuery: event.value ?? "" })),
    "emit navigateTo": emit(({ event }) => (assertEvent(event, "select.view"), {
      type: "navigateTo",
      viewId: event.viewId
    }))
  },
  guards: {
    "was opened on hover": ({ context: context2 }) => context2.activatedBy === "hover",
    "has search query": ({ context: context2 }) => !e$3(context2.searchQuery),
    "search query is empty": ({ context: context2 }) => e$3(context2.searchQuery)
  }
}).createMachine({
  id: "breadcrumbs",
  context: ({ input: input2 }) => ({
    ...input2,
    breadcrumbs: [],
    activatedBy: "hover",
    selectedFolder: "",
    searchQuery: "",
    folderColumns: []
  }),
  initial: "idle",
  entry: [
    "update activatedBy",
    "reset selected folder"
  ],
  on: {
    "update.inputs": {
      actions: "update inputs"
    },
    "searchQuery.change": {
      actions: [
        "update search query",
        raise({ type: "searchQuery.changed" })
      ]
    }
  },
  states: {
    idle: {
      id: "idle",
      on: {
        "breadcrumbs.mouseEnter.*": {
          target: "pending",
          actions: "update activatedBy"
        },
        "breadcrumbs.click.*": {
          target: "active",
          actions: "update activatedBy"
        }
      }
    },
    // Breadcrumbs are hovered, but dropdown is not opened yet
    pending: {
      on: {
        "breadcrumbs.mouseEnter.*": {
          actions: "update activatedBy"
        },
        "breadcrumbs.mouseLeave.*": {
          target: "idle"
        },
        "breadcrumbs.click.*": {
          target: "active",
          actions: "update activatedBy"
        }
      },
      after: {
        "open timeout": {
          target: "active"
        }
      }
    },
    active: {
      tags: ["active"],
      initial: "decide",
      on: {
        "dropdown.dismiss": {
          target: "#idle"
        },
        "breadcrumbs.mouseLeave": {
          guard: "was opened on hover",
          target: ".closing"
        },
        "dropdown.mouseLeave": {
          guard: "was opened on hover",
          target: ".closing"
        },
        "searchQuery.changed": {
          target: ".decide"
        }
      },
      states: {
        // Decide next state based on the search query
        decide: {
          always: [
            {
              guard: "has search query",
              target: "search"
            },
            {
              target: "opened"
            }
          ]
        },
        opened: {
          on: {
            "searchQuery.changed": {
              guard: "has search query",
              actions: "keep dropdown open",
              target: "search"
            },
            "breadcrumbs.click.viewtitle": {
              actions: "reset selected folder"
            },
            "breadcrumbs.click.*": {
              actions: "update selected folder"
            },
            "select.folder": {
              actions: [
                "keep dropdown open",
                "update selected folder"
              ]
            },
            "select.view": {
              actions: [
                "emit navigateTo"
              ]
            }
          }
        },
        search: {
          on: {
            "breadcrumbs.click.viewtitle": {
              actions: [
                "reset search query",
                "reset selected folder"
              ],
              target: "opened"
            },
            "breadcrumbs.click.*": {
              actions: [
                "reset search query",
                "update selected folder"
              ],
              target: "opened"
            },
            "select.view": {
              actions: [
                "emit navigateTo"
              ]
            }
          }
        },
        closing: {
          on: {
            "breadcrumbs.mouseEnter.*": {
              target: "decide"
            },
            "dropdown.mouseEnter": {
              target: "decide"
            }
          },
          after: {
            "close timeout": {
              target: "#idle"
            }
          }
        }
      }
    }
  }
}), navigationPanelActorLogic = _actorLogic$1;
function pickViewBounds(view, dynamicVariant) {
  if (view._type === "dynamic")
    try {
      if (dynamicVariant ??= view.variant, dynamicVariant === "sequence")
        return view.sequenceLayout.bounds;
    } catch {
    }
  return view.bounds;
}
function calcEdgeBounds({ points, controlPoints, labelBBox }) {
  let minX = 1 / 0, minY = 1 / 0, maxX = -1 / 0, maxY = -1 / 0;
  if (controlPoints)
    for (const p of controlPoints)
      minX = Math.min(minX, p.x), minY = Math.min(minY, p.y), maxX = Math.max(maxX, p.x), maxY = Math.max(maxY, p.y);
  else
    for (const [x, y] of points)
      minX = Math.min(minX, x), minY = Math.min(minY, y), maxX = Math.max(maxX, x), maxY = Math.max(maxY, y);
  return labelBBox && (minX = Math.min(minX, labelBBox.x), minY = Math.min(minY, labelBBox.y), maxX = Math.max(maxX, labelBBox.x + labelBBox.width), maxY = Math.max(maxY, labelBBox.y + labelBBox.height)), {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function calcViewBounds({ nodes, edges }) {
  return BBox$1.expand(
    BBox$1.merge(
      ...nodes,
      ...edges.map(calcEdgeBounds)
    ),
    10
  );
}
function createViewChange(parentContext) {
  const {
    view: {
      drifts: _1,
      // Ignore drifts from view
      _layout: _2,
      // Ignore layout type from view
      ...view
    },
    xynodes,
    xystore
  } = parentContext, { nodeLookup, edgeLookup } = xystore.getState(), movedNodes = /* @__PURE__ */ new Set(), nodes = t$a(view.nodes, (node2) => {
    const internal = nodeLookup.get(node2.id);
    if (!internal)
      return console.error(`Internal node not found for ${node2.id}`), node2;
    const xynodedata = xynodes.find((n2) => n2.id === node2.id)?.data ?? internal.data, position = internal.internals.positionAbsolute, { width, height } = getNodeDimensions(internal);
    return (!isSamePoint(position, node2) || node2.width !== width || node2.height !== height) && movedNodes.add(node2.id), {
      ...node2,
      shape: xynodedata.shape,
      color: xynodedata.color,
      style: {
        ...xynodedata.style
      },
      x: Math.floor(position.x),
      y: Math.floor(position.y),
      width: Math.ceil(width),
      height: Math.ceil(height)
    };
  }), edges = t$a(view.edges, (edge) => {
    const xyedge = edgeLookup.get(edge.id);
    if (!xyedge)
      return console.error(`Internal edge not found for ${edge.id}`), edge;
    const data = xyedge.data;
    let controlPoints = data.controlPoints ?? [];
    const sourceOrTargetMoved = movedNodes.has(xyedge.source) || movedNodes.has(xyedge.target);
    controlPoints.length === 0 && sourceOrTargetMoved && (controlPoints = bezierControlPoints(data.points));
    const _updated = {
      ...n$1(edge, ["controlPoints", "labelBBox"]),
      points: data.points
    };
    return data.labelBBox && (_updated.labelBBox = data.labelBBox), t$1(controlPoints, 1) && (_updated.controlPoints = controlPoints), _updated;
  });
  return {
    op: "save-view-snapshot",
    layout: {
      ...view,
      _layout: "manual",
      bounds: calcViewBounds({ nodes, edges }),
      nodes,
      edges
    }
  };
}
const diagramActorRef$1 = function(system) {
  return system.get("diagram");
}, getDiagramContext = function(system) {
  return system.get("diagram").getSnapshot().context;
}, raiseSync = () => machine$4.raise({ type: "sync" }, { delay: 200, id: "sync" }), cancelSync = () => machine$4.cancel("sync"), reschedule = (delay2 = 50) => machine$4.raise(({ event }) => event, { delay: delay2 }), isLayoutChange = (change) => change.op === "reset-manual-layout" || change.op === "save-view-snapshot", withoutSnapshotChanges = n$2(e$4(isLayoutChange)), saveStateBeforeEdit = () => machine$4.assign(({ system }) => {
  const parentContext = getDiagramContext(system);
  return {
    beforeEditing: {
      xynodes: parentContext.xynodes.map(
        ({ measured, ...n2 }) => ({
          ...n$1(n2, ["selected", "dragging", "resizing"]),
          data: n$1(n2.data, ["dimmed", "hovered"]),
          measured,
          initialWidth: measured?.width ?? n2.width ?? n2.initialWidth,
          initialHeight: measured?.height ?? n2.height ?? n2.initialHeight
        })
      ),
      xyedges: parentContext.xyedges.map(
        (e2) => ({
          ...n$1(e2, ["selected"]),
          data: n$1(e2.data, ["active", "dimmed", "hovered"])
        })
      ),
      change: createViewChange(parentContext),
      view: parentContext.view,
      synched: !1
    }
  };
}), startEditing$1 = () => machine$4.enqueueActions(({ enqueue, event }) => {
  enqueue(saveStateBeforeEdit()), event.type === "edit.start" && enqueue.assign({
    editing: event.subject
  });
}), stopHotkey = () => machine$4.stopChild("hotkey"), ensureHotKey = () => machine$4.enqueueActions(({ check, enqueue, self }) => {
  const hasUndo = check("can undo"), hotkey = self.getSnapshot().children.hotkey;
  if (!hasUndo && hotkey) {
    enqueue.stopChild(hotkey);
    return;
  }
  hasUndo && !hotkey && enqueue.spawnChild("hotkey", {
    id: "hotkey"
  });
}), pushHistory = () => machine$4.assign(({ context: context2 }) => {
  const snapshot = context2.beforeEditing;
  return snapshot ? {
    beforeEditing: null,
    editing: null,
    history: [
      ...context2.history,
      snapshot
    ]
  } : {
    editing: null
  };
}), stopEditing$1 = () => machine$4.enqueueActions(({ event, enqueue }) => {
  if (event.type === "edit.finish" && event.wasChanged) {
    enqueue(pushHistory()), enqueue(raiseSync());
    return;
  }
  enqueue.assign({
    beforeEditing: null,
    editing: null
  });
}), markHistoryAsSynched = () => machine$4.assign(({ context: context2 }) => ({
  beforeEditing: context2.beforeEditing && context2.beforeEditing.synched === !1 ? {
    ...context2.beforeEditing,
    synched: !0
  } : context2.beforeEditing,
  history: context2.history.map((i) => ({
    ...i,
    synched: !0
  }))
})), popHistory = () => machine$4.assign(({ context: context2 }) => context2.history.length <= 1 ? {
  history: []
} : {
  history: context2.history.slice(0, context2.history.length - 1)
}), undo = () => machine$4.enqueueActions(({ context: context2, enqueue, system }) => {
  const lastHistoryItem = t$b(context2.history);
  if (!lastHistoryItem)
    return;
  enqueue(cancelSync()), enqueue(popHistory()), enqueue(ensureHotKey());
  const diagramActor = diagramActorRef$1(system);
  enqueue.sendTo(diagramActor, {
    type: "update.view",
    view: lastHistoryItem.view,
    xyedges: lastHistoryItem.xyedges,
    xynodes: lastHistoryItem.xynodes,
    source: "editor"
  }), enqueue.assign({
    pendingChanges: []
  }), lastHistoryItem.synched ? enqueue.raise({ type: "change", change: lastHistoryItem.change }, { delay: 50 }) : enqueue(raiseSync());
}), addSnapshotToPendingChanges = () => machine$4.assign(({ context: context2, system }) => {
  const parentContext = getDiagramContext(system), change = createViewChange(parentContext);
  return {
    pendingChanges: [
      // Remove all save-view-snapshot and reset-manual-layout changes
      ...withoutSnapshotChanges(context2.pendingChanges),
      change
    ]
  };
}), hotkeyActorLogic$1 = fromCallback(({ sendBack }) => {
  const ctrlZHandler = getHotkeyHandler([
    ["mod + z", (event) => {
      event.stopPropagation(), sendBack({ type: "undo" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", ctrlZHandler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", ctrlZHandler, { capture: !0 });
  };
}), applyLatest = fromPromise(
  () => {
    throw new Error("Not implemented");
  }
), executeChange = fromPromise(
  () => {
    throw new Error("Not implemented");
  }
), diagramActorRef = function(params) {
  return params.system.get("diagram");
}, machine$4 = setup({
  delays: {
    "350ms": 350,
    waitBeforeSync: 2e3
  },
  actors: {
    applyLatest,
    executeChange,
    hotkey: hotkeyActorLogic$1
  },
  guards: {
    "has pending": ({ context: context2 }) => context2.pendingChanges.length > 0,
    "can undo": ({ context: context2 }) => context2.history.length > 0
  }
}), to = {
  idle: { target: "#idle" },
  editing: { target: "#editing" },
  afterEdit: { target: "#afterEdit" },
  pending: { target: "#pending" },
  applyLatestToManual: { target: "#applyLatestToManual" },
  executeChanges: { target: "#executeChanges" }
}, idle$1 = machine$4.createStateConfig({
  id: "idle",
  on: {
    sync: {
      ...to.pending
    },
    "edit.start": {
      ...to.editing
    }
  }
}), editing = machine$4.createStateConfig({
  id: "editing",
  tags: "pending",
  entry: [
    startEditing$1(),
    cancelSync()
  ],
  on: {
    change: {
      actions: stopEditing$1(),
      ...to.executeChanges
    },
    "edit.finish": {
      actions: stopEditing$1(),
      ...to.afterEdit
    },
    undo: {
      actions: stopEditing$1(),
      ...to.idle
    }
  }
}), pending = machine$4.createStateConfig({
  id: "pending",
  tags: ["pending"],
  entry: ensureHotKey(),
  on: {
    sync: {
      reenter: !0,
      ...to.pending
    },
    "edit.start": {
      // this allows to return back from editing in afterEdit state
      actions: [
        addSnapshotToPendingChanges()
      ],
      ...to.editing
    }
  },
  after: {
    waitBeforeSync: {
      actions: [
        addSnapshotToPendingChanges()
      ],
      ...to.executeChanges
    }
  }
}), afterEdit = machine$4.createStateConfig({
  id: "afterEdit",
  always: [
    { guard: "has pending", ...to.pending },
    { ...to.idle }
  ]
}), applyLatestToManual = machine$4.createStateConfig({
  id: "applyLatestToManual",
  entry: [
    cancelSync(),
    saveStateBeforeEdit()
  ],
  initial: "call",
  on: {
    // catch all events
    "*": {
      actions: [
        log(({ event }) => `applyLatestToManual received unexpected event: ${event.type}`),
        reschedule(350)
      ]
    }
  },
  states: {
    // Fetch latest and manual layouts
    // Apply changes, send update to diagram
    call: {
      invoke: {
        src: "applyLatest",
        input: ({ context: context2 }) => {
          const current = context2.beforeEditing?.change.layout;
          return {
            current: current && current._layout === "manual" ? current : void 0,
            viewId: context2.viewId
          };
        },
        onDone: {
          actions: sendTo(
            diagramActorRef,
            ({ event }) => ({
              type: "update.view",
              view: event.output.updated
            }),
            { delay: 10 }
          ),
          target: "wait"
        },
        onError: {
          actions: [
            assign({
              beforeEditing: null,
              pendingChanges: []
            }),
            ({ event }) => {
              console.error(event.error);
            }
          ],
          ...to.idle
        }
      }
    },
    // Now we wait 350ms, take new snapshot and send save-view-snapshot
    wait: {
      entry: pushHistory(),
      after: {
        "350ms": {
          actions: [
            addSnapshotToPendingChanges(),
            ensureHotKey()
          ],
          ...to.executeChanges
        }
      }
    }
  }
}), executeChanges = machine$4.createStateConfig({
  id: "executeChanges",
  entry: [
    assign(({ event, context: context2 }) => {
      if (event.type === "change") {
        if (isLayoutChange(event.change))
          return {
            pendingChanges: [
              ...withoutSnapshotChanges(context2.pendingChanges),
              event.change
            ]
          };
        if (!context2.pendingChanges.includes(event.change))
          return {
            pendingChanges: [
              ...context2.pendingChanges,
              event.change
            ]
          };
      }
      return {};
    }),
    cancelSync()
  ],
  invoke: {
    src: "executeChange",
    input: ({ context: context2 }) => ({
      changes: context2.pendingChanges,
      viewId: context2.viewId
    }),
    onDone: {
      actions: enqueueActions(({ context: context2, enqueue }) => {
        const snapshot = r(context2.pendingChanges, (c) => c.op === "save-view-snapshot");
        snapshot && enqueue.sendTo(
          diagramActorRef,
          {
            type: "update.view-bounds",
            bounds: snapshot.layout.bounds
          }
        ), enqueue.assign({
          pendingChanges: []
        });
      }),
      ...to.idle
    },
    onError: {
      actions: ({ event }) => {
        console.error(event.error);
      },
      ...to.afterEdit
    }
  },
  on: {
    "*": {
      actions: reschedule()
    }
  }
}), _editorActorLogic = machine$4.createMachine({
  id: "editor",
  context: ({ input: input2 }) => ({
    viewId: input2.viewId,
    beforeEditing: null,
    editing: null,
    pendingChanges: [],
    history: []
  }),
  initial: "idle",
  // TODO: listen to diagram actor, if switches to "sequence" dynamic view, cancel editing
  // entry: ({ self, system }) => {
  //   // let previous = ''
  //   // const a = (self._parent as DiagramMachineRef).subscribe({
  //   //   next({ context }) {
  //   //     const current = context.view._type === 'dynamic' ? context.dynamicViewVariant
  //   //   },
  //   // })
  //   const s = self.subscribe({
  //     complete: () => {
  //       console.log('editor actor completed')
  //       s.unsubscribe()
  //     },
  //   })
  // },
  states: {
    idle: idle$1,
    editing,
    pending,
    afterEdit,
    applyLatestToManual,
    executeChanges
  },
  on: {
    cancel: {
      actions: [
        cancelSync(),
        assign({
          editing: null,
          beforeEditing: null,
          pendingChanges: []
        })
      ],
      ...to.idle
    },
    synced: {
      actions: markHistoryAsSynched()
    },
    undo: {
      guard: "can undo",
      actions: undo(),
      ...to.idle
    },
    change: {
      ...to.executeChanges
    },
    applyLatestToManual: {
      ...to.applyLatestToManual
    },
    reset: {
      actions: [
        cancelSync(),
        assign({
          history: [],
          editing: null,
          beforeEditing: null,
          pendingChanges: []
        }),
        stopHotkey()
      ],
      ...to.idle
    }
  }
}), editorActorLogic = _editorActorLogic, findNodeByModelFqn = (xynodes, elementFqn) => {
  const node2 = xynodes.find((n2) => "modelFqn" in n2.data && n2.data.modelFqn === elementFqn);
  return node2 || null;
};
function typedSystem(system) {
  return {
    get overlaysActorRef() {
      return system.get("overlays") ?? null;
    },
    get diagramActorRef() {
      return nonNullable(system.get("diagram"), "Diagram actor not found");
    },
    get searchActorRef() {
      return system.get("search") ?? null;
    },
    get editorActorRef() {
      return system.get("editor") ?? null;
    }
  };
}
typedSystem.editorActor = ({ system }) => system.get("editor");
typedSystem.overlaysActor = ({ system }) => system.get("overlays");
typedSystem.diagramActor = ({ system }) => system.get("diagram");
typedSystem.searchActor = ({ system }) => system.get("search");
function findDiagramNode(ctx, xynodeId) {
  return ctx.view.nodes.find((n2) => n2.id === xynodeId) ?? null;
}
function findDiagramEdge(ctx, xyedgeId) {
  return ctx.view.edges.find((e2) => e2.id === xyedgeId) ?? null;
}
function focusedBounds(params) {
  const knownAbsolutes = /* @__PURE__ */ new Map(), b = params.context.xynodes.reduce((acc, node2) => {
    let position = node2.position;
    if (node2.parentId) {
      const parent = knownAbsolutes.get(node2.parentId) ?? { x: 0, y: 0 };
      position = {
        x: position.x + parent.x,
        y: position.y + parent.y
      };
    }
    if (knownAbsolutes.set(node2.id, position), node2.hidden || node2.data.dimmed)
      return acc;
    const width = node2.measured?.width ?? node2.width ?? node2.initialWidth, height = node2.measured?.height ?? node2.height ?? node2.initialHeight;
    return acc.minX = Math.min(acc.minX, position.x), acc.minY = Math.min(acc.minY, position.y), acc.maxX = Math.max(acc.maxX, position.x + width), acc.maxY = Math.max(acc.maxY, position.y + height), acc;
  }, {
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  });
  return b.minX === 1 / 0 ? {
    bounds: params.context.view.bounds
  } : {
    duration: 350,
    bounds: {
      x: b.minX - 10,
      y: b.minY - 10,
      width: b.maxX - b.minX + 20,
      height: b.maxY - b.minY + 20
    }
  };
}
const MARGIN = 32;
function activeSequenceBounds(params) {
  const activeWalkthrough = nonNullable(params.context.activeWalkthrough), stepEdge = nonNullable(params.context.xyedges.find((e2) => e2.id === activeWalkthrough.stepId)), xystate = params.context.xystore.getState(), sourceNode = nonNullable(xystate.nodeLookup.get(stepEdge.source)), targetNode = nonNullable(xystate.nodeLookup.get(stepEdge.target)), actorsBounds = getNodesBounds([sourceNode, targetNode], xystate);
  let stepBounds;
  if (activeWalkthrough.parallelPrefix) {
    const parallelArea = params.context.xynodes.find(
      (n2) => n2.type === "seq-parallel" && n2.data.parallelPrefix === activeWalkthrough.parallelPrefix
    );
    parallelArea && (stepBounds = {
      x: parallelArea.position.x,
      y: parallelArea.position.y,
      ...getNodeDimensions(parallelArea)
    });
  }
  return stepBounds ??= getEdgeBounds(stepEdge, xystate), stepBounds ? stepBounds = BBox$1.merge(stepBounds, actorsBounds) : stepBounds = actorsBounds, {
    duration: 350,
    bounds: BBox$1.expand(
      stepBounds,
      MARGIN
    )
  };
}
function getEdgeBounds(edge, store) {
  const sourceNode = store.nodeLookup.get(edge.source), targetNode = store.nodeLookup.get(edge.target);
  if (!sourceNode || !targetNode)
    return null;
  const edgePosition = getEdgePosition({
    id: edge.id,
    sourceNode,
    targetNode,
    sourceHandle: edge.sourceHandle || null,
    targetHandle: edge.targetHandle || null,
    connectionMode: store.connectionMode
  });
  return edgePosition ? BBox$1.fromPoints([
    [edgePosition.sourceX, edgePosition.sourceY],
    [edgePosition.targetX, edgePosition.targetY]
  ]) : null;
}
function nodeRef(node2) {
  switch (node2.type) {
    case "element":
    case "compound-element":
    case "seq-actor":
      return node2.data.modelFqn;
    case "deployment":
    case "compound-deployment":
      return node2.data.modelFqn ?? node2.data.deploymentFqn;
    case "seq-parallel":
    case "view-group":
      return null;
    default:
      nonexhaustive$1(node2);
  }
}
function findCorrespondingNode(context2, event) {
  const fromNodeId = context2.lastOnNavigate?.fromNode, fromNode = fromNodeId && context2.xynodes.find((n2) => n2.id === fromNodeId), fromRef = fromNode && nodeRef(fromNode), toNode = fromRef && event.xynodes.find((n2) => nodeRef(n2) === fromRef);
  return { fromNode, toNode };
}
function calcViewportForBounds(context2, bounds) {
  let {
    width,
    height,
    transform
  } = context2.xystore.getState();
  const maxZoom = Math.max(transform[2], 1);
  return getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
}
const ViewPadding$1 = {
  top: "40px",
  bottom: "22px",
  left: "22px",
  right: "22px"
}, Sizes$1 = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 140,
    height: 10,
    minlen: 1,
    weight: 1
  },
  emptyNodeOffset: 120,
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph$1() {
  const g = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g.setGraph({
    ...Sizes$1.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes$1.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const PortSuffix$1 = "-port";
function createNodes$1(column, elements, g) {
  const graphNodes = new DefaultMap((key2) => ({
    id: `${column}-${key2}`,
    portId: `${column}-${key2}`
  })), tree = treeFromElements(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id = `${column}-${fqn2}`, portId = isCompound ? `${id}${PortSuffix$1}` : id;
    graphNodes.set(fqn2, {
      id,
      portId
    }), g.setNode(id, {
      column,
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    }), isCompound && (g.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth - Sizes$1.dagre.ranksep,
      height: Sizes$1.compound.labelHeight
    }), g.setParent(portId, id));
    const parent = tree.parent(element);
    parent && g.setParent(id, `${column}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id) => {
      const element = tree.byId(id), graph = graphNodes.get(element.id);
      return {
        element,
        graph
      };
    },
    graphNodes
  };
}
function applyDagreLayout$1(g) {
  return dagre.layout(g, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g.node(nodeId), { x, y, width, height } = node2;
    return {
      position: {
        x: x - Math.round(width / 2),
        y: y - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
var LayoutRelationshipsViewResult;
((LayoutRelationshipsViewResult2) => {
  LayoutRelationshipsViewResult2.Empty = "@empty";
})(LayoutRelationshipsViewResult || (LayoutRelationshipsViewResult = {}));
function layoutRelationshipsView(data, scope) {
  const g = createGraph$1(), incomers = createNodes$1("incomers", data.incomers, g), subjects = createNodes$1("subjects", data.subjects, g), outgoers = createNodes$1("outgoers", data.outgoers, g), edges = [];
  t$6(
    t$e(
      t$6(
        toArray(data.incoming),
        t$a((r2) => ({
          id: r2.source.id,
          sourceFqn: r2.source.id,
          targetFqn: r2.target.id,
          source: incomers.byId(r2.source.id).graph,
          target: subjects.byId(r2.target.id).graph,
          relation: r2
        }))
      ),
      t$6(
        toArray(data.outgoing),
        t$a((r2) => ({
          id: r2.target.id,
          sourceFqn: r2.source.id,
          targetFqn: r2.target.id,
          source: subjects.byId(r2.source.id).graph,
          target: outgoers.byId(r2.target.id).graph,
          relation: r2
        }))
      )
    ),
    t$a((r2) => ({
      ...r2,
      expr: `${r2.source.id}->${r2.target.id}`
    })),
    // Group if same source and target
    t$d(e$5("expr")),
    t$c((grouped) => {
      const source = grouped[0].source, target = grouped[0].target, name = grouped[0].expr;
      g.node(source.id).outPorts.push(target.id), g.node(target.id).inPorts.push(source.id), g.setEdge(source.portId, target.portId, {
        ...Sizes$1.edgeLabel
      }, name), edges.push({
        name,
        sourceFqn: grouped[0].sourceFqn,
        targetFqn: grouped[0].targetFqn,
        source: source.id,
        sourceHandle: source.id + "_out" + (g.node(source.id).outPorts.length - 1),
        target: target.id,
        targetHandle: target.id + "_in" + (g.node(target.id).inPorts.length - 1),
        relations: t$a(grouped, e$5("relation"))
      });
    })
  );
  for (const subjectNode of subjects.graphNodes.values()) {
    const nodeId = subjectNode.id, node2 = g.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount2 = Math.max(g.inEdges(nodeId)?.length ?? 0, g.outEdges(nodeId)?.length ?? 0);
    edgeCount2 > 2 && (node2.height = node2.height + (edgeCount2 - 3) * 14);
  }
  const nodeIds = [
    ...incomers.graphNodes.values(),
    ...subjects.graphNodes.values(),
    ...outgoers.graphNodes.values()
  ];
  if (incomers.graphNodes.size == 0) {
    const id = "incomers-empty";
    g.setNode(id, {
      column: "incomers",
      element: null,
      isCompound: !1,
      portId: id,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    });
    for (const subjectNode of subjects.graphNodes.values())
      g.setEdge(id, subjectNode.portId);
    nodeIds.push({
      id,
      portId: id
    });
  }
  if (outgoers.graphNodes.size == 0) {
    const id = "outgoers-empty";
    g.setNode(id, {
      column: "outgoers",
      element: null,
      isCompound: !1,
      portId: id,
      inPorts: [],
      outPorts: [],
      width: Sizes$1.nodeWidth,
      height: Sizes$1.nodeHeight
    });
    for (const subjectNode of subjects.graphNodes.values())
      g.setEdge(subjectNode.portId, id);
    nodeIds.push({
      id,
      portId: id
    });
  }
  const edgeCount = g.edgeCount();
  if (edgeCount > 10)
    for (const edge of g.edges())
      g.setEdge(edge, {
        ...Sizes$1.edgeLabel,
        width: edgeCount > 25 ? 800 : 400
      });
  const dagreBounds = applyDagreLayout$1(g), _calculatedNodeBounds = t$6(
    nodeIds,
    // Compound nodes have different portId
    n$2((n2) => n2.id === n2.portId),
    t$5((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= t$6(
      g.children(nodeId) ?? [],
      n$2((id) => !id.endsWith(PortSuffix$1)),
      t$a((id) => nodeBounds(id)),
      t$h((bounds) => {
        invariant(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      t$g((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes$1.compound.paddingTop, maxY = maxY + Sizes$1.compound.paddingBottom, {
          position: {
            x,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children = g.children(nodeId) ?? [];
    return children.length === 0 ? 0 : 1 + Math.max(...children.map(nodeDepth));
  }
  const sortedPorts = (nodeId, type, ports) => t$6(
    ports,
    t$a((port, index2) => ({
      port: nodeId + "_" + type + index2,
      topY: nodeBounds(port).position.y
    })),
    t$i(e$5("topY")),
    t$a(e$5("port"))
  );
  let minX = 0, minY = 0;
  const [subject] = [...subjects.root];
  invariant(subject, "Subjects should not be empty");
  let subjectBounds = nodeBounds(subjects.graphNodes.get(subject.id).id);
  const nodes = nodeIds.map(({ id }) => {
    const { element, inPorts, outPorts, column } = g.node(id);
    let { position, width, height } = nodeBounds(id);
    if (!element) {
      if (height = Math.min(subjectBounds.height, 300), position.y = subjectBounds.position.y + subjectBounds.height / 2 - height / 2, column === "incomers")
        width = subjectBounds.position.x - Sizes$1.emptyNodeOffset - position.x;
      else {
        const rightX = position.x + width;
        position.x = subjectBounds.position.x + subjectBounds.width + Sizes$1.emptyNodeOffset, width = rightX - position.x;
      }
      return {
        id,
        parent: null,
        x: position.x,
        y: position.y,
        title: "empty node",
        description: null,
        technology: null,
        tags: [],
        links: [],
        color: "muted",
        shape: "rectangle",
        style: {
          border: "dashed",
          opacity: 50
        },
        kind: LayoutRelationshipsViewResult.Empty,
        level: 0,
        labelBBox: {
          x: position.x,
          y: position.y,
          width,
          height
        },
        children: [],
        width,
        height,
        column,
        ports: {
          in: [],
          out: []
        },
        existsInCurrentView: !1
      };
    }
    const parentId = g.parent(id), children = (g.children(id) ?? []).filter((c) => !c.endsWith(PortSuffix$1));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = scope ? ifind(element.scopedViews(), (v) => v.id !== scope.id)?.id ?? null : null, inheritFromNode = scope?.findNodeWithElement(element.id), scopedAncestor = scope && !inheritFromNode ? ifind(element.ancestors(), (a) => !!scope.findNodeWithElement(a.id))?.id : null, inheritFromNodeOrAncestor = inheritFromNode ?? (scopedAncestor && scope?.findNodeWithElement(scopedAncestor));
    return {
      id,
      parent: parentId ?? null,
      x: position.x,
      y: position.y,
      title: element.title,
      description: preferSummary(element.$element) ?? null,
      technology: element.technology,
      tags: [...element.tags],
      links: null,
      color: inheritFromNodeOrAncestor?.color ?? element.color,
      shape: inheritFromNode?.shape ?? element.shape,
      icon: inheritFromNode?.icon ?? element.icon ?? "none",
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: n$1({
        ...(inheritFromNode ?? inheritFromNodeOrAncestor)?.style,
        ...element.$element.style
      }, ["color", "shape", "icon"]),
      navigateTo,
      ...children.length > 0 && { depth: nodeDepth(id) },
      children,
      width,
      height,
      column,
      ports: {
        in: sortedPorts(id, "in", inPorts),
        out: sortedPorts(id, "out", outPorts)
      },
      existsInCurrentView: !!inheritFromNode
    };
  });
  return {
    subjectExistsInScope: !scope || scope.includesElement(subject.id),
    bounds: {
      x: Math.min(minX, 0),
      y: Math.min(minY, 0),
      width: g.graph().width ?? 100,
      height: g.graph().height ?? 100
    },
    nodes,
    edges: g.edges().reduce((acc, e2) => {
      const edge = g.edge(e2), ename = e2.name;
      if (!ename)
        return acc;
      const {
        name,
        source,
        sourceFqn,
        target,
        targetFqn,
        relations,
        sourceHandle,
        targetHandle
      } = nonNullable(r(edges, (e22) => e22.name === ename)), onlyRelation = t$f(relations), label2 = onlyRelation?.title ?? "untitled", isMultiple = relations.length > 1, navigateTo = t$f(n$3(relations.flatMap((r2) => r2.navigateTo?.id ? r2.navigateTo.id : [])));
      return acc.push(exact({
        id: name,
        sourceFqn,
        source,
        sourceHandle,
        targetFqn,
        target,
        targetHandle,
        label: isMultiple ? `${relations.length} relationships` : label2,
        navigateTo,
        color: onlyRelation?.color ?? "gray",
        existsInCurrentView: !scope || relations.every((r2) => scope.includesRelation(r2.id)),
        points: edge.points.map((p) => [p.x, p.y]),
        line: onlyRelation?.line ?? "dashed",
        head: onlyRelation?.head,
        tail: onlyRelation?.tail,
        relations: relations.map((r2) => r2.id),
        parent: null
      })), acc;
    }, [])
  };
}
function useRelationshipsView(subject, viewId, scope) {
  const model = useLikeC4Model();
  return useMemo(() => {
    const view = viewId ? model.findView(viewId) : null, data = layoutRelationshipsView(
      computeRelationshipsView(subject, model, viewId, scope),
      scope === "view" ? view : null
    );
    return view && (scope === "global" || !data.subjectExistsInScope) && (data.edges = data.edges.map((edge) => (edge.existsInCurrentView = edge.relations.every((r2) => view.includesRelation(r2)), edge))), Object.assign(data, { subject });
  }, [model, subject, viewId, scope, computeRelationshipsView]);
}
function viewToNodesEdge(view) {
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  )), nodeById = (id) => nonNullable$1(nodeLookup.get(id), `Node not found: ${id}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = t$1(node2.children, 1) || node2.kind == GroupElementKind;
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.x,
      y: node2.y
    };
    parent && (position.x -= parent.x, position.y -= parent.y);
    const id = node2.id, base = {
      id,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      ...parent && {
        parentId: parent.id
      }
    }, fqn2 = node2.modelRef ?? null, navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case node2.kind === LayoutRelationshipsViewResult.Empty: {
        xynodes.push(
          {
            ...base,
            type: "empty",
            data: {
              column: node2.column
            }
          }
        );
        break;
      }
      case (isCompound && !!fqn2): {
        xynodes.push(
          {
            ...base,
            type: "compound",
            data: {
              id,
              column: node2.column,
              title: node2.title,
              color: node2.color,
              shape: node2.shape,
              style: node2.style,
              depth: node2.depth ?? 0,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              existsInCurrentView: node2.existsInCurrentView,
              fqn: fqn2,
              ...navigateTo
            }
          }
        );
        break;
      }
      default:
        invariant$1(fqn2, "Element should have either modelRef or deploymentRef"), xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              id,
              column: node2.column,
              fqn: fqn2,
              title: node2.title,
              technology: node2.technology,
              description: node2.description,
              height: node2.height,
              width: node2.width,
              color: node2.color,
              shape: node2.shape,
              icon: node2.icon ?? "none",
              ports: node2.ports,
              style: node2.style,
              existsInCurrentView: node2.existsInCurrentView,
              tags: node2.tags,
              ...navigateTo
            }
          }
        );
    }
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id = edge.id;
    if (!t$1(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    if (!t$1(edge.relations, 1)) {
      console.error("edge should have at least 1 relation", edge);
      continue;
    }
    xyedges.push({
      id,
      type: "relationship",
      source,
      target,
      sourceHandle: edge.sourceHandle,
      targetHandle: edge.targetHandle,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      // deletable: false,
      data: {
        sourceFqn: edge.sourceFqn,
        targetFqn: edge.targetFqn,
        relations: edge.relations,
        color: edge.color ?? "gray",
        label: edge.label,
        navigateTo: edge.navigateTo ?? null,
        line: edge.line ?? "dashed",
        existsInCurrentView: edge.existsInCurrentView
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes,
    xyedges
  };
}
const findRootSubject = (nodes) => nodes.find(
  (n2) => n2.data.column === "subjects" && e$6(n2.parentId)
), layouter = fromPromise(async ({ input: input2, self, signal }) => {
  const {
    subjectId,
    navigateFromNode,
    xyflow: xyflow2,
    xystore,
    update
  } = input2;
  let {
    nodes: currentNodes,
    width,
    height
  } = xystore.getState();
  const next = viewToNodesEdge(update), updateXYData = () => {
    const { nodes, edges } = xystore.getState();
    return {
      xynodes: updateNodes(nodes, next.xynodes),
      xyedges: updateEdges(edges, next.xyedges)
    };
  }, parent = nonNullable(self._parent);
  let zoom = xyflow2.getZoom();
  const maxZoom = Math.max(zoom, 1), nextviewport = getViewportForBounds(update.bounds, width, height, MinZoom, maxZoom, ViewPadding$1), nextSubjectNode = next.xynodes.find(
    (n2) => n2.type !== "empty" && n2.data.column === "subjects" && n2.data.fqn === subjectId
  ) ?? findRootSubject(next.xynodes), currentSubjectNode = findRootSubject(currentNodes), existingNode = navigateFromNode ? currentNodes.find((n2) => n2.id === navigateFromNode) : currentNodes.find((n2) => n2.type !== "empty" && n2.data.column !== "subjects" && n2.data.fqn === subjectId);
  if (!nextSubjectNode || !existingNode || nextSubjectNode.type === "empty" || !currentSubjectNode || nextSubjectNode.data.fqn === currentSubjectNode.data.fqn)
    return await xyflow2.setViewport(nextviewport), updateXYData();
  const nextSubjectCenter = {
    x: nextSubjectNode.position.x + (nextSubjectNode.initialWidth ?? 0) / 2,
    y: nextSubjectNode.position.y + (nextSubjectNode.initialHeight ?? 0) / 2
  }, currentSubjectInternalNode = xyflow2.getInternalNode(currentSubjectNode.id), currentSubjectCenter = getNodeCenter(currentSubjectInternalNode), nested = /* @__PURE__ */ new Set();
  if (currentNodes.forEach((n2) => {
    if (n2.id !== existingNode.id) {
      if (n2.data.column === "subjects") {
        nested.add(n2.id);
        return;
      }
      n2.parentId && (n2.parentId === existingNode.id || nested.has(n2.parentId)) && nested.add(n2.id);
    }
  }), currentNodes = updateNodes(
    currentNodes,
    currentNodes.flatMap((n2) => nested.has(n2.id) ? [] : n2.id !== existingNode.id ? {
      ...n2,
      data: {
        ...n2.data,
        dimmed: n2.data.column === "subjects" ? "immediate" : !0
      }
    } : {
      ...n$1(n2, ["parentId"]),
      position: {
        x: currentSubjectCenter.x - n2.initialWidth / 2,
        y: currentSubjectCenter.y - n2.initialHeight / 2
      },
      zIndex: ZIndexes.Max,
      hidden: !1,
      data: {
        ...n2.data,
        dimmed: !1
      }
    })
  ), parent.send({
    type: "update.xydata",
    xynodes: currentNodes,
    xyedges: []
  }), await delay(120), next.xynodes = next.xynodes.map(Base.setDimmed(!1)), signal.aborted)
    return updateXYData();
  const duration = 300;
  return xyflow2.setCenter(currentSubjectCenter.x, currentSubjectCenter.y, { zoom, duration, interpolate: "smooth" }), await delay(duration), await xyflow2.setCenter(nextSubjectCenter.x, nextSubjectCenter.y, { zoom }), updateXYData();
}), machine$3 = setup({
  actors: {
    layouter
  },
  guards: {
    hasViewId: ({ context: context2 }) => context2.viewId !== null,
    isReady: ({ context: context2 }) => context2.xyflow !== null && context2.xystore !== null && context2.layouted !== null,
    anotherSubject: ({ context: context2, event }) => event.type === "update.view" ? context2.layouted?.subject !== event.layouted.subject : !1
  }
}), xyflowInit = () => machine$3.assign(({ event }) => (assertEvent(event, "xyflow.init"), {
  xyflow: event.instance,
  xystore: event.store
})), updateView$2 = () => machine$3.assign(({ event }) => (assertEvent(event, "update.view"), {
  layouted: event.layouted,
  ...viewToNodesEdge(event.layouted)
})), xyflowUpdateNodeInternals = () => machine$3.createAction(({ context: context2 }) => {
  invariant(context2.xystore, "xystore is not initialized");
  const { domNode, updateNodeInternals } = context2.xystore.getState(), nodeIds = new Set(context2.xyedges.flatMap((e2) => [e2.source, e2.target]));
  if (nodeIds.size === 0 || !domNode)
    return;
  const updates = /* @__PURE__ */ new Map(), domNodes = domNode.querySelectorAll(".react-flow__node");
  for (const nodeElement of domNodes) {
    const nodeId = nodeElement.getAttribute("data-id");
    nodeId && nodeIds.has(nodeId) && updates.set(nodeId, { id: nodeId, nodeElement, force: !0 });
  }
  updateNodeInternals(updates, { triggerFitView: !1 });
}), xyflowFitDiagram = (params) => machine$3.createAction(({ context: context2, event }) => {
  params ??= event.type === "fitDiagram" ? event : {};
  let { duration, bounds } = params ?? {};
  duration ??= 450;
  const { xyflow: xyflow2, xystore } = context2;
  invariant(xyflow2, "xyflow is not initialized"), invariant(xystore, "xystore is not initialized"), bounds ??= context2.layouted?.bounds;
  const maxZoom = Math.max(xyflow2.getZoom(), 1);
  if (bounds) {
    const { width, height } = xystore.getState(), viewport = getViewportForBounds(bounds, width, height, MinZoom, maxZoom, ViewPadding$1);
    xyflow2.setViewport(viewport, duration > 0 ? { duration, interpolate: "smooth" } : void 0).catch(
      console.error
    );
  } else
    xyflow2.fitView({
      minZoom: MinZoom,
      maxZoom,
      padding: ViewPadding$1,
      ...duration > 0 && { duration, interpolate: "smooth" }
    }).catch(console.error);
}), xyflowApplyNodeChanges$1 = () => machine$3.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyNodeChanges"), {
  xynodes: applyNodeChanges(event.changes, context2.xynodes)
})), xyflowApplyEdgeChanges$1 = () => machine$3.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyEdgeChanges"), {
  xyedges: applyEdgeChanges(event.changes, context2.xyedges)
})), openRelationshipSource = () => machine$3.enqueueActions(({ system, event }) => {
  if (event.type !== "xyflow.edgeClick")
    return;
  const diagramActor = typedSystem(system).diagramActorRef, relations = event.edge.data.relations;
  t$1(relations, 1) && diagramActor.send({ type: "open.source", relation: relations[0] });
}), dispose$1 = () => machine$3.assign({
  xyflow: null,
  layouted: null,
  xystore: null,
  xyedges: [],
  xynodes: []
}), _relationshipsBrowserLogic = machine$3.createMachine({
  id: "relationships-browser",
  context: ({ input: input2 }) => ({
    subject: input2.subject,
    viewId: input2.viewId,
    scope: input2.viewId ? input2.scope : "global",
    closeable: input2.closeable ?? !0,
    enableSelectSubject: input2.enableSelectSubject ?? !0,
    enableChangeScope: input2.enableChangeScope ?? !0,
    xyflow: null,
    xystore: null,
    layouted: null,
    navigateFromNode: null,
    xynodes: [],
    xyedges: []
  }),
  initial: "initializing",
  on: {
    "xyflow.applyNodeChanges": {
      actions: xyflowApplyNodeChanges$1()
    },
    "xyflow.applyEdgeChanges": {
      actions: xyflowApplyEdgeChanges$1()
    }
  },
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: xyflowInit(),
          target: "isReady"
        },
        "update.view": {
          actions: updateView$2(),
          target: "isReady"
        },
        stop: "closed",
        close: "closed"
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          xyflowFitDiagram({ duration: 0 }),
          raise({ type: "xyflow.updateNodeInternals" }, { delay: 150 })
        ],
        target: "active"
      }, {
        target: "initializing"
      }]
    },
    active: {
      initial: "idle",
      tags: ["active"],
      on: {
        "xyflow.nodeClick": {
          actions: enqueueActions(({ event, enqueue }) => {
            if ("fqn" in event.node.data) {
              const fqn2 = event.node.data.fqn;
              enqueue.raise({
                type: "navigate.to",
                subject: fqn2,
                fromNode: event.node.id
              });
            }
          })
        },
        "xyflow.edgeClick": [
          {
            guard: "hasViewId",
            actions: enqueueActions(({ event, context: context2, system, enqueue }) => {
              event.edge.selected || event.edge.data.relations.length > 1 ? enqueue.sendTo(typedSystem(system).overlaysActorRef, {
                type: "open.relationshipDetails",
                viewId: context2.viewId,
                source: event.edge.data.sourceFqn,
                target: event.edge.data.targetFqn
              }) : enqueue(openRelationshipSource());
            })
          },
          {
            actions: openRelationshipSource()
          }
        ],
        "navigate.to": {
          actions: [
            assign({
              subject: ({ event }) => event.subject,
              viewId: ({ event, context: context2 }) => event.viewId ?? context2.viewId ?? null,
              navigateFromNode: ({ event }) => event.fromNode ?? null
            })
          ]
        },
        "xyflow.paneDblClick": {
          actions: xyflowFitDiagram()
        },
        "update.view": {
          actions: updateView$2(),
          target: ".layouting"
        },
        "change.scope": {
          actions: assign({
            scope: ({ event }) => event.scope
          })
        },
        "xyflow.updateNodeInternals": {
          actions: xyflowUpdateNodeInternals()
        },
        fitDiagram: {
          actions: xyflowFitDiagram()
        },
        "xyflow.resized": {
          actions: [
            cancel("fitDiagram"),
            raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 300 })
          ]
        },
        "xyflow.init": {
          actions: xyflowInit()
        },
        "xyflow.unmount": {
          target: "initializing"
        },
        close: "closed"
      },
      states: {
        idle: {
          on: {
            "xyflow.edgeMouseEnter": {
              actions: [
                assign({
                  xyedges: ({ context: context2, event }) => {
                    const hasDimmed = context2.xyedges.some((edge) => edge.data.dimmed !== !1 || edge.selected);
                    return context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setData(edge, {
                      hovered: !0,
                      dimmed: !1
                    }) : hasDimmed && !edge.selected ? Base.setDimmed(edge, "immediate") : edge);
                  }
                }),
                cancel("undim.edges"),
                cancel("dim.nonhovered.edges"),
                raise({ type: "dim.nonhovered.edges" }, { id: "dim.nonhovered.edges", delay: 200 })
              ]
            },
            "xyflow.edgeMouseLeave": {
              actions: [
                assign({
                  xyedges: ({ context: context2, event }) => context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setHovered(edge, !1) : edge)
                }),
                cancel("dim.nonhovered.edges"),
                raise({ type: "undim.edges" }, { id: "undim.edges", delay: 400 })
              ]
            },
            "dim.nonhovered.edges": {
              actions: assign({
                xyedges: ({ context: context2 }) => context2.xyedges.map(
                  (edge) => edge.data.hovered ? edge : Base.setDimmed(edge, edge.data.dimmed === "immediate" ? "immediate" : !0)
                )
              })
            },
            "undim.edges": {
              actions: assign({
                xyedges: ({ context: context2 }) => context2.xyedges.map(Base.setDimmed(!1))
              })
            },
            "xyflow.selectionChange": {
              actions: enqueueActions(({ event, context: context2, enqueue }) => {
                event.edges.length === 0 && context2.xyedges.some((e2) => e2.data.dimmed) && !context2.xyedges.some((e2) => e2.data.hovered) && enqueue.raise({ type: "undim.edges" });
              })
            }
          }
        },
        layouting: {
          invoke: {
            id: "layouter",
            src: "layouter",
            input: ({ context: context2 }) => ({
              subjectId: context2.subject,
              navigateFromNode: context2.navigateFromNode,
              xyflow: nonNullable(context2.xyflow),
              xystore: nonNullable(context2.xystore),
              update: nonNullable(context2.layouted)
            }),
            onDone: {
              target: "idle",
              actions: enqueueActions(({ enqueue, event }) => {
                enqueue.assign({
                  xynodes: event.output.xynodes,
                  xyedges: event.output.xyedges,
                  navigateFromNode: null
                }), enqueue.raise({ type: "fitDiagram", duration: 200 }, { id: "fitDiagram", delay: 50 });
                for (let i = 1; i < 8; i++)
                  enqueue.raise({ type: "xyflow.updateNodeInternals" }, { delay: 120 + i * 75 });
              })
            }
          },
          on: {
            "update.xydata": {
              actions: assign({
                xynodes: ({ event }) => event.xynodes,
                xyedges: ({ event }) => event.xyedges
              })
            },
            "xyflow.applyEdgeChanges": {
              // actions: log('layouting: ignore xyflow.applyEdgeChanges'),
            },
            "xyflow.applyNodeChanges": {
              // actions: log('layouting: ignore xyflow.applyNodeChanges'),
            }
          }
        }
      }
    },
    closed: {
      id: "closed",
      type: "final",
      entry: dispose$1()
    }
  },
  exit: dispose$1()
}), relationshipsBrowserLogic = _relationshipsBrowserLogic, _elementDetailsLogic = setup({
  actors: {
    relationshipsBrowserLogic
  }
}).createMachine({
  id: "element-details",
  context: ({ input: input2 }) => ({
    ...input2,
    initiatedFrom: {
      node: input2.initiatedFrom?.node ?? null,
      clientRect: input2.initiatedFrom?.clientRect ?? null
    }
  }),
  initial: "active",
  states: {
    active: {
      entry: spawnChild("relationshipsBrowserLogic", {
        id: ({ self }) => `${self.id}-relationships`,
        input: ({ context: context2 }) => ({
          subject: context2.subject,
          viewId: context2.currentView.id,
          scope: "view",
          enableSelectSubject: !1,
          enableChangeScope: !0,
          closeable: !1
        })
      }),
      exit: [
        sendTo(({ self }) => `${self.id}-relationships`, { type: "close" }),
        stopChild(({ self }) => `${self.id}-relationships`)
      ],
      on: {
        "change.subject": {
          actions: assign({
            subject: ({ event }) => event.subject
          })
        },
        close: "closed"
      }
    },
    closed: {
      id: "closed",
      type: "final"
    }
  }
}), elementDetailsLogic = _elementDetailsLogic;
function layoutResultToXYFlow(layout) {
  const xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(layout.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  )), nodeById = (id) => nonNullable$1(nodeLookup.get(id), `Node not found: ${id}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = t$1(node2.children, 1);
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.x,
      y: node2.y
    };
    parent && (position.x -= parent.x, position.y -= parent.y);
    const id = node2.id, base = {
      id,
      draggable: !1,
      deletable: !1,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      ...parent && {
        parentId: parent.id
      }
    }, fqn2 = node2.modelRef, navigateTo = { navigateTo: node2.navigateTo ?? null };
    !0 === isCompound ? xynodes.push(
      {
        ...base,
        type: "compound",
        data: {
          id,
          column: node2.column,
          title: node2.title,
          color: node2.color,
          style: node2.style,
          depth: node2.depth ?? 0,
          icon: node2.icon ?? "none",
          ports: node2.ports,
          fqn: fqn2,
          ...navigateTo
        }
      }
    ) : xynodes.push(
      {
        ...base,
        type: "element",
        data: {
          id,
          column: node2.column,
          fqn: fqn2,
          title: node2.title,
          technology: node2.technology,
          description: node2.description ?? null,
          height: node2.height,
          width: node2.width,
          color: node2.color,
          shape: node2.shape,
          icon: node2.icon ?? "none",
          ports: node2.ports,
          style: node2.style,
          tags: node2.tags,
          ...navigateTo
        }
      }
    );
  }
  for (const {
    source,
    target,
    relationId,
    label: label2,
    technology,
    description: description2,
    navigateTo = null,
    color = "gray",
    line = "dashed",
    ...edge
  } of layout.edges) {
    const id = edge.id;
    xyedges.push({
      id,
      type: "relationship",
      source,
      target,
      sourceHandle: edge.sourceHandle,
      targetHandle: edge.targetHandle,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        relationId,
        label: label2,
        color,
        navigateTo,
        line,
        description: description2 ?? null,
        ...technology && { technology }
      }
    });
  }
  return {
    xynodes,
    xyedges,
    bounds: layout.bounds
  };
}
function inputToSubject(input2) {
  return "edgeId" in input2 ? (invariant$1(e$7(input2.edgeId), "edgeId is required"), {
    edgeId: input2.edgeId
  }) : {
    source: input2.source,
    target: input2.target
  };
}
const ViewPadding = {
  x: "22px",
  y: "22px"
}, _relationshipDetailsLogic = setup({
  actions: {
    "xyflow:fitDiagram": ({ context: context2 }, params) => {
      let { duration, bounds } = params ?? {};
      duration ??= 450;
      const { xyflow: xyflow2, xystore } = context2;
      invariant$1(xyflow2, "xyflow is not initialized"), invariant$1(xystore, "xystore is not initialized"), bounds ??= context2.bounds;
      const maxZoom = Math.max(xyflow2.getZoom(), 1);
      if (bounds) {
        const { width, height } = xystore.getState(), viewport = getViewportForBounds(bounds, width, height, MinZoom, maxZoom, ViewPadding);
        xyflow2.setViewport(viewport, duration > 0 ? { duration } : void 0).catch(console.error);
      } else
        xyflow2.fitView({
          minZoom: MinZoom,
          maxZoom,
          padding: ViewPadding,
          ...duration > 0 && { duration, interpolate: "smooth" }
        }).catch(console.error);
    },
    "xyflow:updateNodeInternals": ({ context: context2 }) => {
      invariant$1(context2.xystore, "xystore is not initialized");
      const { domNode, updateNodeInternals } = context2.xystore.getState(), nodeIds = new Set(context2.xyedges.flatMap((e2) => [e2.source, e2.target]));
      if (nodeIds.size === 0 || !domNode)
        return;
      const updates = /* @__PURE__ */ new Map();
      for (const updateId of nodeIds) {
        const nodeElement = domNode.querySelector(`.react-flow__node[data-id="${updateId}"]`);
        nodeElement && updates.set(updateId, { id: updateId, nodeElement, force: !0 });
      }
      updateNodeInternals(updates, { triggerFitView: !1 });
    },
    updateXYFlow: assign(({ context: context2, event }) => {
      assertEvent(event, "xyflow.init");
      let initialized = context2.initialized;
      return initialized.xyflow || (initialized = {
        ...initialized,
        xyflow: !0
      }), {
        initialized,
        xyflow: event.instance,
        xystore: event.store
      };
    }),
    updateLayoutData: assign(({ context: context2, event }) => {
      assertEvent(event, "update.layoutData");
      const { xynodes, xyedges, bounds } = layoutResultToXYFlow(event.data);
      let initialized = context2.initialized;
      return initialized.xydata || (initialized = {
        ...initialized,
        xydata: !0
      }), {
        initialized,
        xynodes: updateNodes(context2.xynodes, xynodes),
        xyedges: updateEdges(context2.xyedges, xyedges),
        bounds: shallowEqual(context2.bounds, bounds) ? context2.bounds : bounds
      };
    }),
    "open relationship source": enqueueActions(({ system, event }) => {
      if (event.type !== "xyflow.edgeClick")
        return;
      const diagramActor = typedSystem(system).diagramActorRef, relationId = event.edge.data.relationId;
      relationId && diagramActor.send({ type: "open.source", relation: relationId });
    })
  },
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow,
    "enable: navigate.to": () => !0
  }
}).createMachine({
  initial: "initializing",
  context: ({ input: input2 }) => ({
    subject: inputToSubject(input2),
    viewId: input2.viewId,
    bounds: {
      x: 0,
      y: 0,
      width: 200,
      height: 200
    },
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    xyflow: null,
    xystore: null,
    xynodes: [],
    xyedges: []
  }),
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: "updateXYFlow",
          target: "isReady"
        },
        "update.layoutData": {
          actions: "updateLayoutData",
          target: "isReady"
        },
        close: {
          target: "closed"
        }
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: [
          { type: "xyflow:fitDiagram", params: { duration: 0 } },
          raise({ type: "xyflow.updateNodeInternals" }, { delay: 50 })
        ],
        target: "ready"
      }, {
        target: "initializing"
      }]
    },
    ready: {
      on: {
        "xyflow.edgeMouseEnter": {
          actions: [
            assign({
              xyedges: ({ context: context2, event }) => {
                const hasDimmed = context2.xyedges.some(
                  (edge) => edge.data.dimmed === !0 || edge.data.dimmed === "immediate"
                );
                return context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setData(edge, {
                  hovered: !0,
                  dimmed: !1
                }) : hasDimmed && !edge.selected ? Base.setDimmed(edge, "immediate") : edge);
              }
            }),
            cancel("undim.edges"),
            cancel("dim.nonhovered.edges"),
            raise({ type: "dim.nonhovered.edges" }, { id: "dim.nonhovered.edges", delay: 100 })
          ]
        },
        "xyflow.edgeMouseLeave": {
          actions: [
            assign({
              xyedges: ({ context: context2, event }) => context2.xyedges.map((edge) => edge.id === event.edge.id ? Base.setHovered(edge, !1) : edge)
            }),
            cancel("dim.nonhovered.edges"),
            raise({ type: "undim.edges" }, { id: "undim.edges", delay: 400 })
          ]
        },
        "dim.nonhovered.edges": {
          actions: assign({
            xyedges: ({ context: context2 }) => context2.xyedges.map((edge) => Base.setDimmed(edge, edge.data.hovered !== !0))
          })
        },
        "undim.edges": {
          actions: assign({
            xyedges: ({ context: context2 }) => context2.xyedges.some((edge) => edge.selected === !0) ? context2.xyedges.map(
              (edge) => Base.setDimmed(edge, edge.selected !== !0 ? edge.data.dimmed || "immediate" : !1)
            ) : context2.xyedges.map(Base.setDimmed(!1))
          })
        },
        "xyflow.selectionChange": {
          actions: enqueueActions(({ event, context: context2, enqueue }) => {
            event.edges.length === 0 && context2.xyedges.some((e2) => e2.data.dimmed) && !context2.xyedges.some((e2) => e2.data.hovered) && enqueue.raise({ type: "undim.edges" });
          })
        },
        "update.layoutData": {
          actions: [
            "updateLayoutData",
            cancel("fitDiagram"),
            raise({ type: "fitDiagram", duration: 0 }, { id: "fitDiagram", delay: 50 }),
            raise({ type: "xyflow.updateNodeInternals" }, { delay: 75 })
          ]
        },
        "xyflow.init": {
          actions: "updateXYFlow"
        },
        "xyflow.applyNodeChanges": {
          actions: assign({
            xynodes: ({ context: context2, event }) => applyNodeChanges(event.changes, context2.xynodes)
          })
        },
        "xyflow.applyEdgeChanges": {
          actions: assign({
            xyedges: ({ context: context2, event }) => applyEdgeChanges(event.changes, context2.xyedges)
          })
        },
        "xyflow.paneDblClick": {
          actions: "xyflow:fitDiagram"
        },
        "xyflow.edgeClick": {
          actions: "open relationship source"
        },
        "navigate.to": {
          actions: assign({
            subject: ({ event }) => inputToSubject(event.params),
            viewId: ({ context: context2, event }) => event.params.viewId ?? context2.viewId
          })
        },
        close: {
          target: "closed"
        }
      },
      exit: assign({
        xyedges: [],
        xynodes: [],
        initialized: {
          xydata: !1,
          xyflow: !1
        },
        xyflow: null,
        xystore: null
      })
    },
    closed: {
      type: "final"
    }
  },
  on: {
    fitDiagram: {
      actions: {
        type: "xyflow:fitDiagram",
        params: e$5("event")
      }
    },
    "xyflow.resized": {
      actions: [
        cancel("fitDiagram"),
        raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 200 })
      ]
    },
    "xyflow.updateNodeInternals": {
      actions: "xyflow:updateNodeInternals"
    }
  }
}), relationshipDetailsLogic = _relationshipDetailsLogic, hotkeyLogic = fromCallback(({ sendBack }) => {
  const handler = getHotkeyHandler([
    ["Escape", (event) => {
      event.stopPropagation(), sendBack({ type: "close" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", handler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", handler, { capture: !0 });
  };
}), machine$2 = setup({
  actors: {
    relationshipDetails: relationshipDetailsLogic,
    elementDetails: elementDetailsLogic,
    relationshipsBrowser: relationshipsBrowserLogic,
    hotkey: hotkeyLogic
  },
  guards: {
    "has overlays?": ({ context: context2 }) => context2.overlays.length > 0,
    "close specific overlay?": ({ context: context2, event }) => (assertEvent(event, "close"), e$7(event.actorId) && context2.overlays.some((o) => o.id === event.actorId)),
    "last: is relationshipDetails?": ({ context: context2 }) => t$b(context2.overlays)?.type === "relationshipDetails",
    "last: is relationshipsBrowser?": ({ context: context2 }) => t$b(context2.overlays)?.type === "relationshipsBrowser"
  }
}), closeLastOverlay = () => machine$2.enqueueActions(({ context: context2, enqueue }) => {
  if (context2.overlays.length === 0)
    return;
  const lastOverlay = t$b(context2.overlays)?.id;
  lastOverlay && (enqueue.sendTo(lastOverlay, { type: "close" }), enqueue.stopChild(lastOverlay), enqueue.assign({
    overlays: context2.overlays.filter((o) => o.id !== lastOverlay)
  }));
}), closeSpecificOverlay = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  assertEvent(event, "close");
  const actorId = event.actorId;
  if (!e$7(actorId))
    return;
  const toClose = context2.overlays.find((o) => o.id === actorId)?.id;
  toClose && (enqueue.sendTo(toClose, { type: "close" }), enqueue.stopChild(toClose), enqueue.assign({
    overlays: context2.overlays.filter((o) => o.id !== toClose)
  }));
}), closeAllOverlays$1 = () => machine$2.enqueueActions(({ context: context2, enqueue }) => {
  for (const { id } of t$j(context2.overlays))
    enqueue.sendTo(id, { type: "close" }), enqueue.stopChild(id);
  enqueue.assign({ overlays: [] });
}), openElementDetails$1 = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  if (assertEvent(event, "open.elementDetails"), context2.overlays.some((o) => o.type === "elementDetails" && o.subject === event.subject))
    return;
  const id = `elementDetails-${context2.seq}`;
  enqueue.spawnChild("elementDetails", {
    id,
    input: event,
    syncSnapshot: !0
  }), enqueue.assign({
    seq: context2.seq + 1,
    overlays: [
      ...context2.overlays,
      {
        id,
        type: "elementDetails",
        subject: event.subject
      }
    ]
  });
}), openRelationshipDetails = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  assertEvent(event, "open.relationshipDetails");
  const currentOverlay = t$b(context2.overlays);
  if (currentOverlay?.type === "relationshipDetails") {
    enqueue.sendTo(currentOverlay.id, {
      ...event,
      type: "navigate.to"
    });
    return;
  }
  const id = `relationshipDetails-${context2.seq}`;
  enqueue.spawnChild("relationshipDetails", {
    id,
    input: event,
    syncSnapshot: !0
  }), enqueue.assign({
    seq: context2.seq + 1,
    overlays: [
      ...context2.overlays,
      {
        id,
        type: "relationshipDetails"
      }
    ]
  });
}), openRelationshipsBrowser = () => machine$2.enqueueActions(({ context: context2, enqueue, event }) => {
  assertEvent(event, "open.relationshipsBrowser");
  const currentOverlay = t$b(context2.overlays);
  if (currentOverlay?.type === "relationshipsBrowser") {
    enqueue.sendTo(currentOverlay.id, {
      type: "navigate.to",
      subject: event.subject,
      viewId: event.viewId
    });
    return;
  }
  const id = `relationshipsBrowser-${context2.seq}`;
  enqueue.spawnChild("relationshipsBrowser", {
    id,
    input: event,
    syncSnapshot: !0
  }), enqueue.assign({
    seq: context2.seq + 1,
    overlays: [
      ...context2.overlays,
      {
        id,
        type: "relationshipsBrowser",
        subject: event.subject
      }
    ]
  });
}), openOverlay$1 = () => machine$2.enqueueActions(({ enqueue, event }) => {
  switch (assertEvent(event, [
    "open.elementDetails",
    "open.relationshipDetails",
    "open.relationshipsBrowser"
  ]), event.type) {
    case "open.elementDetails":
      enqueue(openElementDetails$1());
      break;
    case "open.relationshipDetails":
      enqueue(openRelationshipDetails());
      break;
    case "open.relationshipsBrowser":
      enqueue(openRelationshipsBrowser());
      break;
  }
}), listenToEsc = () => machine$2.spawnChild("hotkey", {
  id: "hotkey"
}), stopListeningToEsc = () => machine$2.stopChild("hotkey"), checkState = () => machine$2.enqueueActions(({ enqueue, context: context2 }) => {
  context2.overlays.length === 0 && enqueue.raise({ type: "close" });
}), _overlaysActorLogic = machine$2.createMachine({
  id: "overlays",
  context: () => ({
    seq: 1,
    overlays: []
  }),
  initial: "idle",
  states: {
    idle: {
      on: {
        "open.*": {
          actions: openOverlay$1(),
          target: "active"
        }
      }
    },
    active: {
      entry: [
        listenToEsc()
      ],
      exit: [
        stopListeningToEsc()
      ],
      on: {
        "open.*": {
          actions: openOverlay$1()
        },
        close: [
          {
            guard: not("has overlays?"),
            target: "idle"
          },
          {
            guard: "close specific overlay?",
            actions: [
              closeSpecificOverlay(),
              checkState()
            ]
          },
          {
            actions: [
              closeLastOverlay(),
              checkState()
            ]
          }
        ],
        "close.all": {
          actions: [
            closeAllOverlays$1()
          ],
          target: "idle"
        }
      }
    },
    final: {
      entry: [
        closeAllOverlays$1(),
        stopListeningToEsc()
      ],
      type: "final"
    }
  }
}), overlaysActorLogic = _overlaysActorLogic, _searchActorLogic = setup({
  actions: {
    "change searchValue": assign({
      searchValue: ({ event, context: context2 }) => (assertEvent(event, ["change.search", "open"]), event.search ?? context2.searchValue)
    }),
    "reset pickViewFor": assign({
      pickViewFor: () => null
    })
  }
}).createMachine({
  id: "search",
  context: {
    openedWithSearch: null,
    searchValue: "",
    pickViewFor: null
  },
  initial: "inactive",
  on: {
    close: {
      target: ".inactive",
      actions: "reset pickViewFor"
    }
  },
  states: {
    inactive: {
      on: {
        open: {
          target: "opened",
          actions: [
            assign({
              openedWithSearch: ({ event }) => event.search ?? null,
              searchValue: ({ event, context: context2 }) => event.search ?? context2.searchValue
            })
          ]
        }
      }
    },
    opened: {
      on: {
        open: {
          actions: "change searchValue"
        },
        "change.search": {
          actions: "change searchValue"
        },
        "pickview.open": {
          target: "pickView",
          actions: assign({
            pickViewFor: ({ event }) => event.elementFqn
          })
        }
      }
    },
    pickView: {
      on: {
        "pickview.close": {
          target: "opened",
          actions: "reset pickViewFor"
        }
      }
    }
  }
}), searchActorLogic = _searchActorLogic, hotkeyActorLogic = fromCallback(({ sendBack }) => {
  const escHandler = getHotkeyHandler([
    ["Escape", (event) => {
      event.stopPropagation(), sendBack({ type: "key.esc" });
    }, {
      preventDefault: !0
    }]
  ]), arrowshandler = getHotkeyHandler([
    ["ArrowLeft", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.left" });
    }, {
      preventDefault: !0
    }],
    ["ArrowUp", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.up" });
    }, {
      preventDefault: !0
    }],
    ["ArrowRight", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.right" });
    }, {
      preventDefault: !0
    }],
    ["ArrowDown", (event) => {
      event.stopPropagation(), sendBack({ type: "key.arrow.down" });
    }, {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", escHandler), document.body.addEventListener("keydown", arrowshandler, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", escHandler), document.body.removeEventListener("keydown", arrowshandler, { capture: !0 });
  };
}), mediaPrintActorLogic = fromCallback(({ sendBack }) => {
  const beforePrint = () => {
    sendBack({ type: "media.print.on" });
  }, afterPrint = () => {
    sendBack({ type: "media.print.off" });
  };
  return window.addEventListener("beforeprint", beforePrint), window.addEventListener("afterprint", afterPrint), () => {
    window.removeEventListener("beforeprint", beforePrint), window.removeEventListener("afterprint", afterPrint);
  };
}), deriveToggledFeatures = (context2) => {
  let toggledFeatures = context2.toggledFeatures;
  const hasActiveWalkthrough = e$8(context2.activeWalkthrough), enableCompareWithLatest = context2.features.enableCompareWithLatest && (toggledFeatures.enableCompareWithLatest ?? !1) && e$8(context2.view._layout) && !hasActiveWalkthrough, enableReadOnly = context2.features.enableReadOnly || (toggledFeatures.enableReadOnly ?? !1) || hasActiveWalkthrough || context2.dynamicViewVariant === "sequence" && context2.view._type === "dynamic" || enableCompareWithLatest && context2.view._layout === "auto";
  return {
    enableCompareWithLatest,
    enableReadOnly
  };
}, isReadOnly = (context2) => deriveToggledFeatures(context2).enableReadOnly, machine$1 = setup({
  actors: {
    hotkeyActorLogic,
    overlaysActorLogic,
    searchActorLogic,
    mediaPrintActorLogic,
    editorActor: editorActorLogic
  },
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow,
    "enabled: Editor": ({ context: context2 }) => context2.features.enableEditor,
    "enabled: FitView": ({ context: context2 }) => context2.features.enableFitView,
    "enabled: FocusMode": ({ context: context2 }) => context2.features.enableFocusMode && isReadOnly(context2),
    "enabled: Readonly": ({ context: context2 }) => isReadOnly(context2),
    "enabled: RelationshipDetails": ({ context: context2 }) => context2.features.enableRelationshipDetails,
    "enabled: Search": ({ context: context2 }) => context2.features.enableSearch,
    "enabled: ElementDetails": ({ context: context2 }) => context2.features.enableElementDetails,
    "enabled: OpenSource": ({ context: context2 }) => context2.features.enableVscode,
    "enabled: DynamicViewWalkthrough": ({ context: context2 }) => context2.features.enableDynamicViewWalkthrough,
    "focus.node: autoUnfocus": ({ event }) => (assertEvent(event, "focus.node"), event.autoUnfocus === !0),
    "enabled: Overlays": ({ context: context2 }) => context2.features.enableElementDetails || context2.features.enableRelationshipBrowser || context2.features.enableRelationshipDetails,
    "not readonly": ({ context: context2 }) => !isReadOnly(context2),
    "is dynamic view": ({ context: context2 }) => context2.view._type === "dynamic",
    "is same view": ({ context: context2, event }) => {
      if (assertEvent(event, ["update.view", "navigate.to"]), event.type === "update.view")
        return context2.view.id === event.view.id;
      if (event.type === "navigate.to")
        return context2.view.id === event.viewId;
      nonexhaustive(event.type);
    },
    "is another view": ({ context: context2, event }) => {
      if (assertEvent(event, ["update.view", "navigate.to"]), event.type === "update.view")
        return context2.view.id !== event.view.id;
      if (event.type === "navigate.to")
        return context2.view.id !== event.viewId;
      nonexhaustive(event.type);
    },
    "click: node has modelFqn": ({ event }) => (assertEvent(event, "xyflow.nodeClick"), "modelFqn" in event.node.data),
    "click: selected node": ({ event }) => (assertEvent(event, "xyflow.nodeClick"), event.node.selected === !0),
    "click: same node": ({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), context2.lastClickedNode?.id === event.node.id),
    "click: focused node": ({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), context2.focusedNode === event.node.id),
    "click: node has connections": ({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), context2.xyedges.some((e2) => e2.source === event.node.id || e2.target === event.node.id)),
    "click: selected edge": ({ event }) => (assertEvent(event, ["xyflow.edgeClick", "xyflow.edgeDoubleClick"]), event.edge.selected === !0 || event.edge.data.active === !0)
  }
}), targetState = {
  idle: "#idle",
  focused: "#focused",
  walkthrough: "#walkthrough",
  printing: "#printing",
  navigating: "#navigating"
}, selectCompareLayoutState = ({ context: context2 }) => {
  const drifts = context2.view.drifts ?? null;
  if (!context2.features.enableCompareWithLatest || !drifts || drifts.length === 0)
    return {
      hasEditor: !1,
      isEnabled: !1,
      isEditable: !1,
      isActive: !1,
      drifts: [],
      canApplyLatest: !1,
      layout: context2.view._layout ?? "auto"
    };
  const {
    enableCompareWithLatest,
    enableReadOnly
  } = deriveToggledFeatures(context2);
  return {
    hasEditor: context2.features.enableEditor,
    isEnabled: !0,
    isEditable: !enableReadOnly,
    isActive: enableCompareWithLatest === !0,
    drifts,
    canApplyLatest: !drifts.includes("type-changed"),
    layout: context2.view._layout ?? "auto"
  };
};
function useDiagramCompareLayout() {
  const actorRef = useDiagramActorRef(), state = useSelector(actorRef, selectCompareLayoutState, shallowEqual), switchLayout = useCallbackRef((layoutType) => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    actorRef.send({ type: "emit.onLayoutTypeChange", layoutType });
  }), toggleCompare = useCallbackRef((force) => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    const nextIsActive = force ? force === "on" : !state.isActive;
    state.isActive && !nextIsActive && state.layout === "auto" && switchLayout("manual"), actorRef.send({
      type: "toggle.feature",
      feature: "CompareWithLatest",
      forceValue: nextIsActive
    });
  }), resetManualLayout = useCallbackRef(() => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    actorRef.send({ type: "layout.resetManualLayout" });
  }), applyLatestToManual2 = useCallbackRef(() => {
    if (!state.isEnabled) {
      console.warn("Compare with latest feature is not enabled");
      return;
    }
    nonNullable$1(actorRef.system?.get("editor"), "editor actor not found").send({ type: "applyLatestToManual" }), state.isActive && actorRef.send({
      type: "toggle.feature",
      feature: "CompareWithLatest",
      forceValue: !1
    });
  });
  return [state, { toggleCompare, switchLayout, resetManualLayout, applyLatestToManual: applyLatestToManual2 }];
}
const createRecipe = (name, defaultVariants, compoundVariants) => {
  const getVariantProps2 = (variants) => ({
    [name]: "__ignore__",
    ...defaultVariants,
    ...compact(variants)
  });
  return {
    recipeFn: (variants, withCompoundVariants = !0) => {
      const recipeCss = createCss({
        conditions: {
          shift: sortConditions,
          finalize: finalizeConditions,
          breakpoints: { keys: ["base", "xs", "sm", "md", "lg", "xl"] }
        },
        utility: {
          toHash: (path, hashFn) => hashFn(path.join(":")),
          transform: (prop, value) => (assertCompoundVariant(name, compoundVariants, variants, prop), value === "__ignore__" ? { className: name } : (value = withoutSpace(value), { className: `${name}--${prop}_${value}` }))
        }
      }), recipeStyles = getVariantProps2(variants);
      if (withCompoundVariants) {
        const compoundVariantStyles = getCompoundVariantCss(compoundVariants, recipeStyles);
        return cx(recipeCss(recipeStyles), css(compoundVariantStyles));
      }
      return recipeCss(recipeStyles);
    },
    getVariantProps: getVariantProps2,
    __getCompoundVariantCss__: (variants) => getCompoundVariantCss(compoundVariants, getVariantProps2(variants))
  };
}, mergeRecipes = (recipeA, recipeB) => {
  if (recipeA && !recipeB) return recipeA;
  if (!recipeA && recipeB) return recipeB;
  const recipeFn = (...args) => cx(recipeA(...args), recipeB(...args)), variantKeys = uniq(recipeA.variantKeys, recipeB.variantKeys), variantMap = variantKeys.reduce((acc, key2) => (acc[key2] = uniq(recipeA.variantMap[key2], recipeB.variantMap[key2]), acc), {});
  return Object.assign(recipeFn, {
    __recipe__: !0,
    __name__: `${recipeA.__name__} ${recipeB.__name__}`,
    raw: (props) => props,
    variantKeys,
    variantMap,
    splitVariantProps(props) {
      return splitProps(props, variantKeys);
    }
  });
}, actionBtnFn = /* @__PURE__ */ createRecipe("action-btn", {
  size: "md",
  radius: "md",
  variant: "filled"
}, []), actionBtnVariantMap = {
  variant: [
    "transparent",
    "filled"
  ],
  size: [
    "sm",
    "md"
  ],
  radius: [
    "sm",
    "md"
  ]
}, actionBtnVariantKeys = Object.keys(actionBtnVariantMap), actionBtn = /* @__PURE__ */ Object.assign(memo(actionBtnFn.recipeFn), {
  __recipe__: !0,
  __name__: "actionBtn",
  __getCompoundVariantCss__: actionBtnFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: actionBtnVariantKeys,
  variantMap: actionBtnVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, actionBtnVariantKeys);
  },
  getVariantProps: actionBtnFn.getVariantProps
}), compoundNodeFn = /* @__PURE__ */ createRecipe("likec4-compound-node", {}, []), compoundNodeVariantMap = {
  isTransparent: [
    "false",
    "true"
  ],
  inverseColor: [
    "true",
    "false"
  ],
  borderStyle: [
    "solid",
    "dashed",
    "dotted",
    "none"
  ]
}, compoundNodeVariantKeys = Object.keys(compoundNodeVariantMap), compoundNode = /* @__PURE__ */ Object.assign(memo(compoundNodeFn.recipeFn), {
  __recipe__: !0,
  __name__: "compoundNode",
  __getCompoundVariantCss__: compoundNodeFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: compoundNodeVariantKeys,
  variantMap: compoundNodeVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, compoundNodeVariantKeys);
  },
  getVariantProps: compoundNodeFn.getVariantProps
}), edgeActionBtnFn = /* @__PURE__ */ createRecipe("likec4-edge-action-btn", {}, []), edgeActionBtnVariantMap = {}, edgeActionBtnVariantKeys = Object.keys(edgeActionBtnVariantMap), edgeActionBtn = /* @__PURE__ */ Object.assign(memo(edgeActionBtnFn.recipeFn), {
  __recipe__: !0,
  __name__: "edgeActionBtn",
  __getCompoundVariantCss__: edgeActionBtnFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: edgeActionBtnVariantKeys,
  variantMap: edgeActionBtnVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, edgeActionBtnVariantKeys);
  },
  getVariantProps: edgeActionBtnFn.getVariantProps
}), edgeLabelFn = /* @__PURE__ */ createRecipe("likec4-edge-label", {
  pointerEvents: "all",
  isStepEdge: !1,
  cursor: "default"
}, []), edgeLabelVariantMap = {
  pointerEvents: [
    "none",
    "all"
  ],
  cursor: [
    "pointer",
    "default"
  ],
  isStepEdge: [
    "false",
    "true"
  ]
}, edgeLabelVariantKeys = Object.keys(edgeLabelVariantMap), edgeLabel$1 = /* @__PURE__ */ Object.assign(memo(edgeLabelFn.recipeFn), {
  __recipe__: !0,
  __name__: "edgeLabel",
  __getCompoundVariantCss__: edgeLabelFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: edgeLabelVariantKeys,
  variantMap: edgeLabelVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, edgeLabelVariantKeys);
  },
  getVariantProps: edgeLabelFn.getVariantProps
}), edgePathDefaultVariants = {}, edgePathCompoundVariants = [], edgePathSlotNames = [
  [
    "path",
    "likec4-edge__path"
  ],
  [
    "pathBg",
    "likec4-edge__pathBg"
  ],
  [
    "markersCtx",
    "likec4-edge__markersCtx"
  ],
  [
    "middlePoint",
    "likec4-edge__middlePoint"
  ]
], edgePathSlotFns = /* @__PURE__ */ edgePathSlotNames.map(([slotName, slotKey]) => [slotName, createRecipe(slotKey, edgePathDefaultVariants, getSlotCompoundVariant(edgePathCompoundVariants, slotName))]), edgePathFn = memo((props = {}) => Object.fromEntries(edgePathSlotFns.map(([slotName, slotFn]) => [slotName, slotFn.recipeFn(props)]))), edgePathVariantKeys = [], getVariantProps$2 = (variants) => ({ ...edgePathDefaultVariants, ...compact(variants) }), edgePath = /* @__PURE__ */ Object.assign(edgePathFn, {
  __recipe__: !1,
  __name__: "edgePath",
  raw: (props) => props,
  classNameMap: {},
  variantKeys: edgePathVariantKeys,
  variantMap: {},
  splitVariantProps(props) {
    return splitProps(props, edgePathVariantKeys);
  },
  getVariantProps: getVariantProps$2
}), elementNodeFn = /* @__PURE__ */ createRecipe("likec4-element-node", {}, []), elementNodeVariantMap = {}, elementNodeVariantKeys = Object.keys(elementNodeVariantMap), elementNode = /* @__PURE__ */ Object.assign(memo(elementNodeFn.recipeFn), {
  __recipe__: !0,
  __name__: "elementNode",
  __getCompoundVariantCss__: elementNodeFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: elementNodeVariantKeys,
  variantMap: elementNodeVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, elementNodeVariantKeys);
  },
  getVariantProps: elementNodeFn.getVariantProps
}), elementNodeDataFn = /* @__PURE__ */ createRecipe("likec4-element-node-data", {}, []), elementNodeDataVariantMap = {}, elementNodeDataVariantKeys = Object.keys(elementNodeDataVariantMap), elementNodeData = /* @__PURE__ */ Object.assign(memo(elementNodeDataFn.recipeFn), {
  __recipe__: !0,
  __name__: "elementNodeData",
  __getCompoundVariantCss__: elementNodeDataFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: elementNodeDataVariantKeys,
  variantMap: elementNodeDataVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, elementNodeDataVariantKeys);
  },
  getVariantProps: elementNodeDataFn.getVariantProps
}), elementShapeRecipeFn = /* @__PURE__ */ createRecipe("likec4-element-shape", {
  withBorder: !1
}, [
  {
    shapetype: "html",
    withBorder: !0,
    css: {
      "&": {
        borderStyle: "solid",
        borderWidth: "3px",
        borderColor: "var(--likec4-palette-stroke)",
        "--likec4-outline-size": "6px"
      },
      "& .likec4-shape-outline": {
        borderRadius: "10px"
      }
    }
  }
]), elementShapeRecipeVariantMap = {
  shapetype: [
    "html",
    "svg"
  ],
  withBorder: [
    "true",
    "false"
  ]
}, elementShapeRecipeVariantKeys = Object.keys(elementShapeRecipeVariantMap), elementShapeRecipe = /* @__PURE__ */ Object.assign(memo(elementShapeRecipeFn.recipeFn), {
  __recipe__: !0,
  __name__: "elementShapeRecipe",
  __getCompoundVariantCss__: elementShapeRecipeFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: elementShapeRecipeVariantKeys,
  variantMap: elementShapeRecipeVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, elementShapeRecipeVariantKeys);
  },
  getVariantProps: elementShapeRecipeFn.getVariantProps
}), likec4tagFn = /* @__PURE__ */ createRecipe("likec4-tag", {
  autoTextColor: !1
}, []), likec4tagVariantMap = {
  autoTextColor: [
    "false",
    "true"
  ]
}, likec4tagVariantKeys = Object.keys(likec4tagVariantMap), likec4tag = /* @__PURE__ */ Object.assign(memo(likec4tagFn.recipeFn), {
  __recipe__: !0,
  __name__: "likec4tag",
  __getCompoundVariantCss__: likec4tagFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: likec4tagVariantKeys,
  variantMap: likec4tagVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, likec4tagVariantKeys);
  },
  getVariantProps: likec4tagFn.getVariantProps
}), markdownBlockFn = /* @__PURE__ */ createRecipe("likec4-markdown-block", {
  uselikec4palette: !1,
  value: "markdown"
}, []), markdownBlockVariantMap = {
  uselikec4palette: [
    "true",
    "false"
  ],
  value: [
    "markdown",
    "plaintext"
  ]
}, markdownBlockVariantKeys = Object.keys(markdownBlockVariantMap), markdownBlock = /* @__PURE__ */ Object.assign(memo(markdownBlockFn.recipeFn), {
  __recipe__: !0,
  __name__: "markdownBlock",
  __getCompoundVariantCss__: markdownBlockFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: markdownBlockVariantKeys,
  variantMap: markdownBlockVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, markdownBlockVariantKeys);
  },
  getVariantProps: markdownBlockFn.getVariantProps
}), navigationPanelActionIconFn = /* @__PURE__ */ createRecipe("likec4-navigation-panel-icon", {
  variant: "default",
  type: "default"
}, [
  {
    type: "warning",
    variant: "filled",
    css: {
      backgroundColor: {
        base: "likec4.panel.action.warning.bg",
        _hover: "likec4.panel.action.warning.bg.hover"
      }
    }
  }
]), navigationPanelActionIconVariantMap = {
  variant: [
    "default",
    "filled"
  ],
  type: [
    "default",
    "warning"
  ]
}, navigationPanelActionIconVariantKeys = Object.keys(navigationPanelActionIconVariantMap), navigationPanelActionIcon = /* @__PURE__ */ Object.assign(memo(navigationPanelActionIconFn.recipeFn), {
  __recipe__: !0,
  __name__: "navigationPanelActionIcon",
  __getCompoundVariantCss__: navigationPanelActionIconFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: navigationPanelActionIconVariantKeys,
  variantMap: navigationPanelActionIconVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, navigationPanelActionIconVariantKeys);
  },
  getVariantProps: navigationPanelActionIconFn.getVariantProps
}), overlayFn = /* @__PURE__ */ createRecipe("likec4-overlay", {
  fullscreen: !1,
  withBackdrop: !0
}, []), overlayVariantMap = {
  fullscreen: [
    "false",
    "true"
  ],
  withBackdrop: [
    "false",
    "true"
  ]
}, overlayVariantKeys = Object.keys(overlayVariantMap), overlay = /* @__PURE__ */ Object.assign(memo(overlayFn.recipeFn), {
  __recipe__: !0,
  __name__: "overlay",
  __getCompoundVariantCss__: overlayFn.__getCompoundVariantCss__,
  raw: (props) => props,
  variantKeys: overlayVariantKeys,
  variantMap: overlayVariantMap,
  merge(recipe) {
    return mergeRecipes(this, recipe);
  },
  splitVariantProps(props) {
    return splitProps(props, overlayVariantKeys);
  },
  getVariantProps: overlayFn.getVariantProps
}), navigationLinkDefaultVariants = {
  truncateLabel: !1
}, navigationLinkCompoundVariants = [], navigationLinkSlotNames = [
  [
    "root",
    "likec4-navlink__root"
  ],
  [
    "body",
    "likec4-navlink__body"
  ],
  [
    "section",
    "likec4-navlink__section"
  ],
  [
    "label",
    "likec4-navlink__label"
  ],
  [
    "description",
    "likec4-navlink__description"
  ]
], navigationLinkSlotFns = /* @__PURE__ */ navigationLinkSlotNames.map(([slotName, slotKey]) => [slotName, createRecipe(slotKey, navigationLinkDefaultVariants, getSlotCompoundVariant(navigationLinkCompoundVariants, slotName))]), navigationLinkFn = memo((props = {}) => Object.fromEntries(navigationLinkSlotFns.map(([slotName, slotFn]) => [slotName, slotFn.recipeFn(props)]))), navigationLinkVariantKeys = [
  "truncateLabel"
], getVariantProps$1 = (variants) => ({ ...navigationLinkDefaultVariants, ...compact(variants) }), navigationLink = /* @__PURE__ */ Object.assign(navigationLinkFn, {
  __recipe__: !1,
  __name__: "navigationLink",
  raw: (props) => props,
  classNameMap: {},
  variantKeys: navigationLinkVariantKeys,
  variantMap: {
    truncateLabel: [
      "true",
      "false"
    ]
  },
  splitVariantProps(props) {
    return splitProps(props, navigationLinkVariantKeys);
  },
  getVariantProps: getVariantProps$1
}), navigationPanelDefaultVariants = {
  size: "md"
}, navigationPanelCompoundVariants = [], navigationPanelSlotNames = [
  [
    "root",
    "likec4-navigation-panel__root"
  ],
  [
    "body",
    "likec4-navigation-panel__body"
  ],
  [
    "logo",
    "likec4-navigation-panel__logo"
  ],
  [
    "label",
    "likec4-navigation-panel__label"
  ],
  [
    "dropdown",
    "likec4-navigation-panel__dropdown"
  ]
], navigationPanelSlotFns = /* @__PURE__ */ navigationPanelSlotNames.map(([slotName, slotKey]) => [slotName, createRecipe(slotKey, navigationPanelDefaultVariants, getSlotCompoundVariant(navigationPanelCompoundVariants, slotName))]), navigationPanelFn = memo((props = {}) => Object.fromEntries(navigationPanelSlotFns.map(([slotName, slotFn]) => [slotName, slotFn.recipeFn(props)]))), navigationPanelVariantKeys = [
  "size"
], getVariantProps = (variants) => ({ ...navigationPanelDefaultVariants, ...compact(variants) }), navigationPanel = /* @__PURE__ */ Object.assign(navigationPanelFn, {
  __recipe__: !1,
  __name__: "navigationPanel",
  raw: (props) => props,
  classNameMap: {},
  variantKeys: navigationPanelVariantKeys,
  variantMap: {
    size: [
      "md",
      "lg"
    ]
  },
  splitVariantProps(props) {
    return splitProps(props, navigationPanelVariantKeys);
  },
  getVariantProps
}), Tooltip$5 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
}), BreadcrumbsSeparator = () => /* @__PURE__ */ jsx(
  ThemeIcon,
  {
    component: MotionDiv,
    variant: "transparent",
    size: 16,
    className: css({
      display: {
        base: "none",
        "@/md": "flex"
      },
      color: {
        base: "mantine.colors.gray[5]",
        _dark: "mantine.colors.dark[3]"
      }
    }),
    children: /* @__PURE__ */ jsx(IconChevronRight, {})
  }
);
Breadcrumbs.withProps({
  separator: /* @__PURE__ */ jsx(BreadcrumbsSeparator, {}),
  separatorMargin: 4
});
const PanelActionIcon = forwardRef(({
  variant = "default",
  className,
  disabled = !1,
  type,
  ...others
}, ref) => /* @__PURE__ */ jsx(
  ActionIcon,
  {
    size: "md",
    variant: "transparent",
    radius: "sm",
    component: MotionButton,
    ...!disabled && {
      whileHover: {
        scale: 1.085
      },
      whileTap: {
        scale: 1,
        translateY: 1
      }
    },
    disabled,
    ...others,
    className: cx(
      className,
      navigationPanelActionIcon({ variant, type })
    ),
    ref
  }
));
function CompareActionsMenu({
  disabled = !1,
  onApplyLatestToManual,
  onResetManualLayout
}) {
  return /* @__PURE__ */ jsxs(
    Menu,
    {
      withinPortal: !1,
      floatingStrategy: "absolute",
      shadow: "lg",
      position: "bottom-start",
      offset: { mainAxis: 4 },
      disabled,
      children: [
        /* @__PURE__ */ jsx(Menu.Target, { children: /* @__PURE__ */ jsxs(
          UnstyledButton,
          {
            disabled,
            className: cx(
              "mantine-active",
              hstack({
                gap: "2",
                py: "1.5",
                px: "2",
                lineHeight: "1",
                textStyle: "xs",
                fontWeight: "medium",
                layerStyle: "likec4.panel.action",
                userSelect: "none"
              })
            ),
            children: [
              /* @__PURE__ */ jsx(Box, { children: "Actions" }),
              /* @__PURE__ */ jsx(IconChevronDown, { size: 12, stroke: 2, opacity: 0.7 })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxs(Menu.Dropdown, { children: [
          /* @__PURE__ */ jsxs(
            Menu.Item,
            {
              disabled: !onApplyLatestToManual,
              onClick: onApplyLatestToManual,
              rightSection: onApplyLatestToManual && /* @__PURE__ */ jsx(
                Tooltip$6,
                {
                  onClick: stopPropagation,
                  position: "right-start",
                  label: /* @__PURE__ */ jsxs(Fragment, { children: [
                    "Applies changes from the latest auto-layouted",
                    /* @__PURE__ */ jsx("br", {}),
                    "to saved snapshot, preserving (as possible)",
                    /* @__PURE__ */ jsx("br", {}),
                    "manual adjustments.",
                    /* @__PURE__ */ jsx("br", {}),
                    /* @__PURE__ */ jsx("br", {}),
                    "You can undo this action."
                  ] }),
                  children: /* @__PURE__ */ jsx(IconInfoCircle, { size: 14, stroke: 1.7, opacity: 0.5 })
                }
              ),
              children: [
                "Sync with latest",
                !onApplyLatestToManual && /* @__PURE__ */ jsx(Box, { textStyle: "xs", children: "view type is changed" })
              ]
            }
          ),
          /* @__PURE__ */ jsx(Menu.Item, { onClick: onResetManualLayout, children: "Remove manual layout" })
        ] })
      ]
    }
  );
}
function LayoutTypeSwitcher({
  value,
  onChange
}) {
  const data = useMemo(() => [
    { value: "manual", label: "Saved manual" },
    { value: "auto", label: "Latest auto" }
  ], []);
  return /* @__PURE__ */ jsx(MotionDiv, { layout: "position", children: /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      color: value === "manual" ? "orange" : "green",
      value,
      component: MotionDiv,
      onChange: (layout) => {
        invariant$1(layout === "manual" || layout === "auto", "Invalid layout type"), onChange(layout);
      },
      classNames: {
        label: css({
          fontSize: "xxs",
          fontWeight: "medium"
        })
      },
      data
    }
  ) });
}
const Divider$1 = Divider$2.withProps({
  mx: 2,
  size: "xs",
  orientation: "vertical"
});
function ComparePanelControls() {
  const [ctx, { toggleCompare, switchLayout, resetManualLayout, applyLatestToManual: applyLatestToManual2 }] = useDiagramCompareLayout();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        css: {
          textStyle: "xs",
          color: "likec4.panel.text",
          userSelect: "none"
        },
        children: "Compare"
      }
    ),
    /* @__PURE__ */ jsx(
      LayoutTypeSwitcher,
      {
        value: ctx.layout,
        onChange: switchLayout
      }
    ),
    ctx.hasEditor && /* @__PURE__ */ jsxs(HStack, { gap: "1", children: [
      /* @__PURE__ */ jsx(Divider$1, {}),
      /* @__PURE__ */ jsx(
        CompareActionsMenu,
        {
          disabled: ctx.layout === "auto",
          onResetManualLayout: resetManualLayout,
          onApplyLatestToManual: ctx.canApplyLatest ? applyLatestToManual2 : void 0
        }
      ),
      /* @__PURE__ */ jsx(Divider$1, {})
    ] }),
    /* @__PURE__ */ jsx(
      PanelActionIcon,
      {
        size: "sm",
        onClick: (e2) => {
          e2.stopPropagation(), toggleCompare();
        },
        children: /* @__PURE__ */ jsx(IconX, {})
      }
    )
  ] });
}
const ComparePanel = memo$1(() => {
  const { enableCompareWithLatest } = useEnabledFeatures();
  return /* @__PURE__ */ jsx(AnimatePresence, { children: enableCompareWithLatest && /* @__PURE__ */ jsx(
    MotionDiv,
    {
      layout: "position",
      className: hstack({
        gap: "2",
        layerStyle: "likec4.panel",
        position: "relative",
        px: "2",
        py: "1",
        pl: "3",
        pointerEvents: "all"
      }),
      initial: {
        opacity: 0,
        translateX: -20
      },
      animate: {
        opacity: 1,
        translateX: 0
      },
      exit: {
        opacity: 0,
        translateX: -20
      },
      children: /* @__PURE__ */ jsx(ComparePanelControls, {})
    }
  ) });
});
ComparePanel.displayName = "ComparePanel";
const Tooltip$4 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  position: "right"
}), CenterCamera = () => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip$4, { label: "Center camera", children: /* @__PURE__ */ jsx(PanelActionIcon, { onClick: () => diagram.fitDiagram(), children: /* @__PURE__ */ jsx(IconFocusCentered, {}) }) });
};
css({
  gap: "xxs",
  _empty: {
    display: "none"
  }
});
css({
  top: "md",
  left: "md",
  margin: "0",
  pointerEvents: "none",
  "& :where(button, .action-icon, [role='dialog'])": {
    pointerEvents: "all"
  },
  "& .action-icon": {
    "--ai-size": "2rem"
  },
  "& .tabler-icon": {
    width: "65%",
    height: "65%"
  },
  _reduceGraphics: {
    "& .action-icon": {
      "--ai-radius": "0px"
    }
  }
});
css({
  shadow: {
    base: "md",
    _whenPanning: "none"
  }
});
css({
  "& .tabler-icon": {
    width: "65%",
    height: "65%"
  }
});
const autolayoutButton = css({
  flex: "1 1 40%",
  textAlign: "center",
  fontWeight: 500,
  padding: "[4px 6px]",
  fontSize: "11px",
  zIndex: 1
}), autolayoutIndicator = css({
  background: "mantine.colors.gray[2]",
  borderRadius: "sm",
  border: "1px solid",
  borderColor: "mantine.colors.gray[4]",
  _dark: {
    background: "mantine.colors.dark[5]",
    borderColor: "mantine.colors.dark[4]"
  }
}), spacingSliderBody = css({
  position: "relative",
  borderRadius: "sm",
  background: "mantine.colors.gray[3]",
  boxShadow: "inset 1px 1px 3px 0px #00000024",
  _dark: {
    background: "mantine.colors.dark[7]"
  }
}), spacingSliderThumb = css({
  position: "absolute",
  width: 8,
  height: 8,
  border: "2px solid",
  borderColor: "mantine.colors.gray[5]",
  borderRadius: 3,
  transform: "translate(-50%, -50%)"
}), selector$7 = (state) => ({
  viewId: state.view.id,
  isManualLayout: state.view._layout === "manual",
  autoLayout: state.view.autoLayout
}), ChangeAutoLayoutButton = () => {
  const diagram = useDiagram(), [rootRef, setRootRef] = useState(null), [controlsRefs, setControlsRefs] = useState({}), {
    autoLayout,
    viewId,
    isManualLayout
  } = useDiagramContext(selector$7), { ref, hovered: isSpacingHovered } = useHover(), setControlRef = (name) => (node2) => {
    controlsRefs[name] = node2, setControlsRefs(controlsRefs);
  }, setAutoLayout = (direction) => (event) => {
    event.stopPropagation(), diagram.fitDiagram(), diagram.triggerChange({
      op: "change-autolayout",
      layout: {
        ...autoLayout,
        direction
      }
    });
  }, setSpacing = (nodeSep, rankSep) => {
    diagram.fitDiagram(), diagram.triggerChange({
      op: "change-autolayout",
      layout: {
        ...autoLayout,
        nodeSep,
        rankSep
      }
    });
  };
  return isManualLayout ? null : /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip$4, { label: "Change Auto Layout", children: /* @__PURE__ */ jsx(PanelActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutDashboard, {}) }) }) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { className: "likec4-top-left-panel", p: 8, pt: 6, opacity: isSpacingHovered ? 0.6 : 1, children: /* @__PURE__ */ jsxs(Box$1, { pos: "relative", ref: setRootRef, children: [
          /* @__PURE__ */ jsx(
            FloatingIndicator,
            {
              target: controlsRefs[autoLayout.direction],
              parent: rootRef,
              className: autolayoutIndicator
            }
          ),
          /* @__PURE__ */ jsx(Box$1, { mb: 10, children: /* @__PURE__ */ jsx(Text, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Auto layout:" }) }),
          /* @__PURE__ */ jsxs(Flex, { gap: 2, wrap: "wrap", justify: "stretch", maw: 160, children: [
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("TB"), onClick: setAutoLayout("TB"), children: "Top-Bottom" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("BT"), onClick: setAutoLayout("BT"), children: "Bottom-Top" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("LR"), onClick: setAutoLayout("LR"), children: "Left-Right" }),
            /* @__PURE__ */ jsx(UnstyledButton, { className: autolayoutButton, ref: setControlRef("RL"), onClick: setAutoLayout("RL"), children: "Right-Left" })
          ] }),
          /* @__PURE__ */ jsx(Box$1, { my: 10, children: /* @__PURE__ */ jsx(Text, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Spacing:" }) }),
          /* @__PURE__ */ jsx(
            SpacingSliders,
            {
              ref,
              isVertical: autoLayout.direction === "TB" || autoLayout.direction === "BT",
              nodeSep: autoLayout.nodeSep,
              rankSep: autoLayout.rankSep,
              onChange: setSpacing
            },
            viewId
          )
        ] }) })
      ]
    }
  );
}, MAX_SPACING = 400, SpacingSliders = forwardRef(({
  isVertical,
  nodeSep,
  rankSep,
  onChange
}, _ref) => {
  isVertical || ([nodeSep, rankSep] = [rankSep, nodeSep]);
  const propagateChange = useDebouncedCallback(
    ({ x, y }) => {
      isVertical || ([x, y] = [y, x]), onChange(Math.round(x * MAX_SPACING), Math.round(y * MAX_SPACING));
    },
    [onChange, isVertical],
    250,
    2e3
  ), [value, setValue] = useUncontrolled({
    defaultValue: clampUseMovePosition({
      x: (nodeSep ?? 100) / MAX_SPACING,
      y: (rankSep ?? 120) / MAX_SPACING
    }),
    onChange: propagateChange
  }), { ref } = useMove(setValue);
  let nodeSepValue = Math.round(value.x * MAX_SPACING), rankSepValue = Math.round(value.y * MAX_SPACING);
  isVertical || ([nodeSepValue, rankSepValue] = [rankSepValue, nodeSepValue]);
  const mergedRef = useMergedRef(ref, _ref);
  return /* @__PURE__ */ jsxs(Box$1, { ref: mergedRef, className: spacingSliderBody, pt: "100%", children: [
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: spacingSliderThumb,
        style: {
          left: `${value.x * 100}%`,
          top: `${value.y * 100}%`
        }
      }
    ),
    /* @__PURE__ */ jsx(Box$1, { pos: "absolute", left: 2, bottom: 2, children: /* @__PURE__ */ jsxs(Text, { component: "div", fz: 8, c: "dimmed", fw: 500, children: [
      rankSepValue,
      ", ",
      nodeSepValue
    ] }) })
  ] });
}), Action = ({
  label: label2,
  icon: icon2,
  onClick
}) => /* @__PURE__ */ jsx(Tooltip$4, { label: label2, withinPortal: !1, position: "top", children: /* @__PURE__ */ jsx(
  PanelActionIcon,
  {
    classNames: {
      root: "action-icon",
      icon: css({
        "& > svg": {
          width: "70%",
          height: "70%"
        }
      })
    },
    onClick,
    children: icon2
  }
) }), ManualLayoutToolsButton = memo$1(() => {
  const diagram = useDiagram(), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "right",
      offset: {
        mainAxis: 12
      },
      clickOutsideEvents: [
        "pointerdown"
      ],
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Tooltip$4, { label: "Manual layouting tools", children: /* @__PURE__ */ jsx(PanelActionIcon, { children: /* @__PURE__ */ jsx(IconLayoutCollage, {}) }) }) }),
        /* @__PURE__ */ jsx(
          PopoverDropdown,
          {
            className: hstack({
              gap: "0.5",
              layerStyle: "likec4.panel",
              padding: "1",
              pointerEvents: "all"
            }),
            children: /* @__PURE__ */ jsxs(TooltipGroup, { children: [
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align in columns",
                  icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Column");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align left",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignLeft, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Left");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align center",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignCenter, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Center");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align right",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignRight, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Right");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align in rows",
                  icon: /* @__PURE__ */ jsx(IconLayoutBoardSplit, { style: { transform: "rotate(90deg)" } }),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Row");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align top",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignTop, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Top");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align middle",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignMiddle, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Middle");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Align bottom",
                  icon: /* @__PURE__ */ jsx(IconLayoutAlignBottom, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.align("Bottom");
                  }
                }
              ),
              /* @__PURE__ */ jsx(
                Action,
                {
                  label: "Reset all control points",
                  icon: /* @__PURE__ */ jsx(IconRouteOff, {}),
                  onClick: (e2) => {
                    e2.stopPropagation(), diagram.resetEdgeControlPoints();
                  }
                }
              )
            ] })
          }
        )
      ]
    }
  );
});
ManualLayoutToolsButton.displayName = "ManualLayoutToolsButton";
const ToggleReadonly$1 = () => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip$4, { label: "Switch to Read-only", children: /* @__PURE__ */ jsx(PanelActionIcon, { onClick: () => diagram.toggleFeature("ReadOnly"), children: /* @__PURE__ */ jsx(IconLockOpen2, { size: 14, stroke: 2 }) }) });
};
function EditorPanel() {
  const { enableReadOnly } = useEnabledFeatures();
  return /* @__PURE__ */ jsx(AnimatePresence, { children: !enableReadOnly && /* @__PURE__ */ jsx(
    MotionDiv,
    {
      layout: "position",
      className: vstack({
        gap: "xs",
        layerStyle: "likec4.panel",
        position: "relative",
        cursor: "pointer",
        padding: "xxs",
        pointerEvents: "all"
      }),
      initial: {
        opacity: 0,
        translateX: -20
      },
      animate: {
        opacity: 1,
        translateX: 0
      },
      exit: {
        opacity: 0,
        translateX: -20
      },
      children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 600, closeDelay: 120, children: [
        /* @__PURE__ */ jsx(ChangeAutoLayoutButton, {}),
        /* @__PURE__ */ jsx(ManualLayoutToolsButton, {}),
        /* @__PURE__ */ jsx(CenterCamera, {}),
        /* @__PURE__ */ jsx(ToggleReadonly$1, {})
      ] })
    }
  ) });
}
const NavigationPanelActorSafeContext = createContext(null);
NavigationPanelActorSafeContext.displayName = "NavigationPanelActorSafeContext";
const NavigationPanelActorContextProvider = NavigationPanelActorSafeContext.Provider, useNavigationActorRef = () => {
  const ctx = useContext(NavigationPanelActorSafeContext);
  if (ctx === null)
    throw new Error("NavigationPanelActorRef is not found in the context");
  return ctx;
};
function useNavigationActorSnapshot(selector3, compare2 = shallowEqual) {
  const actorRef = useNavigationActorRef();
  return useSelector(actorRef, selector3, compare2);
}
function useNavigationActorContext(selector3, compare2 = shallowEqual) {
  return useNavigationActorSnapshot((snapshot) => selector3(snapshot.context), compare2);
}
function useNavigationActor() {
  const actorRef = useNavigationActorRef();
  return useMemo(() => ({
    actorRef,
    send: (event) => actorRef.send(event),
    selectFolder: (folderPath) => actorRef.send({ type: "select.folder", folderPath }),
    selectView: (viewId) => actorRef.send({ type: "select.view", viewId }),
    isOpened: () => actorRef.getSnapshot().hasTag("active"),
    clearSearch: () => actorRef.send({ type: "searchQuery.change", value: "" }),
    closeDropdown: () => actorRef.send({ type: "dropdown.dismiss" })
  }), [actorRef]);
}
const compoundActionBtn = cva({
  base: {
    transitionDuration: "normal"
  },
  variants: {
    delay: {
      true: {
        // Debounce CSS transition
        transitionDelay: {
          base: "0.2s",
          _hover: "0s"
        }
      }
    }
  }
});
function CompoundActionButton({
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const isHoverDebounced = useDebouncedValue(isHovered, isHovered ? 130 : 0)[0] && isHovered;
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      initial: !1,
      animate: {
        scale: isHoverDebounced ? 1.2 : 1,
        x: isHoverDebounced ? -1 : 0,
        y: isHoverDebounced ? -1 : 0
      },
      whileHover: {
        scale: 1.4,
        x: -3,
        y: -1
      },
      className: "likec4-compound-navigation compound-action",
      whileTap: { scale: 1 },
      onClick: stopPropagation,
      children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          className: cx(
            "nodrag nopan",
            compoundActionBtn({
              delay: isHovered && !isHoverDebounced
            }),
            actionBtn({ variant: "transparent" })
          ),
          onClick,
          onDoubleClick: stopPropagation,
          children: icon2 ?? /* @__PURE__ */ jsx(IconZoomScan, { stroke: 2 })
        }
      )
    }
  );
}
function CompoundDetailsButton({
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  const isHoverDebounced = useDebouncedValue(isHovered, isHovered ? 130 : 0)[0] && isHovered;
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      initial: !1,
      animate: {
        scale: isHoverDebounced ? 1.2 : 1
        // opacity: isHoverDebounced ? 1 : 0.6,
      },
      whileHover: {
        scale: 1.4
      },
      whileTap: { scale: 1 },
      className: "likec4-compound-details details-button",
      children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          className: cx(
            "nodrag nopan",
            compoundActionBtn({
              delay: isHovered && !isHoverDebounced
            }),
            actionBtn({ variant: "transparent" })
          ),
          onClick,
          onDoubleClick: stopPropagation,
          children: icon2 ?? /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
        }
      )
    }
  );
}
function CompoundNodeContainer({
  nodeProps: {
    data: {
      hovered: isHovered = !1,
      dimmed: isDimmed = !1,
      ...data
    }
  },
  className,
  children,
  style,
  ...rest
}) {
  let opacity = t(data.style.opacity ?? 100, {
    min: 0,
    max: 100
  });
  const isTransparent = opacity < 99, MIN_OPACITY = 65, borderOpacity = MIN_OPACITY + t((100 - MIN_OPACITY) * (opacity / 100), {
    min: 0,
    max: 100 - MIN_OPACITY
  }), compoundClass = compoundNode({
    isTransparent,
    inverseColor: opacity < 60,
    borderStyle: data.style.border ?? (isTransparent ? "dashed" : "none")
  }), depth = t(data.depth ?? 1, {
    min: 1,
    max: 5
  });
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      className: cx(
        compoundClass,
        className
      ),
      initial: !1,
      "data-likec4-hovered": isHovered,
      "data-likec4-color": data.color,
      "data-compound-depth": depth,
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...style,
        // @ts-expect-error
        "--_border-transparency": `${borderOpacity}%`,
        "--_compound-transparency": `${opacity}%`
      },
      ...rest,
      children
    }
  );
}
function CompoundTitle({ data }) {
  const elementIcon2 = IconRenderer({
    element: data,
    className: "likec4-compound-icon"
  });
  return /* @__PURE__ */ jsxs("div", { className: "likec4-compound-title-container", children: [
    elementIcon2,
    /* @__PURE__ */ jsx(Text, { component: "h3", className: "likec4-compound-title", truncate: "end", children: data.title })
  ] });
}
function EdgeActionButton({ icon: icon2, onClick }) {
  return /* @__PURE__ */ jsx(
    ActionIcon,
    {
      className: cx("nodrag nopan", edgeActionBtn()),
      onPointerDownCapture: stopPropagation,
      onClick,
      role: "button",
      onDoubleClick: stopPropagation,
      children: icon2 ?? /* @__PURE__ */ jsx(IconZoomScan, {})
    }
  );
}
function EdgeContainer({
  className,
  component = "g",
  selectable = !1,
  selected = !1,
  data: {
    color = "gray",
    hovered: isHovered = !1,
    active: isActive = !1,
    dimmed: isDimmed = !1,
    ...data
  },
  animated,
  children,
  style
}) {
  const props = {
    className: cx(
      className,
      "likec4-edge-container",
      selected && "selected",
      selectable && "selectable"
    ),
    "data-likec4-color": color,
    "data-edge-dir": data.dir ?? "forward",
    "data-edge-active": isActive,
    "data-edge-animated": animated || isActive,
    "data-likec4-hovered": isHovered,
    ...selected && {
      "data-likec4-selected": selected
    },
    ...isDimmed !== !1 && {
      "data-likec4-dimmed": isDimmed
    }
  };
  return component === "svg" ? /* @__PURE__ */ jsx("svg", { style, ...props, children }) : (invariant$1(component === "g", 'EdgeContainer: component must be "g" or "svg"'), /* @__PURE__ */ jsx("g", { style, ...props, children }));
}
const EdgeLabel = forwardRef(({
  edgeProps: {
    id,
    data: {
      label: label2,
      technology,
      hovered: isHovered = !1
    },
    selected = !1,
    selectable = !1
  },
  pointerEvents = "all",
  className,
  style: _style,
  // omit
  children,
  ...rest
}, ref) => {
  const stepNum = isStepEdgeId(id) ? extractStep(id) : null, hasLabel = e$8(label2) || e$8(technology);
  return /* @__PURE__ */ jsxs(
    MotionDiv,
    {
      ref,
      className: cx(
        // This class is queried by RelationshipPopover to position near the edge label
        "likec4-edge-label",
        edgeLabel$1({
          pointerEvents,
          isStepEdge: stepNum !== null,
          cursor: selectable || stepNum !== null ? "pointer" : "default"
        }),
        className
      ),
      "data-edge-id": id,
      animate: {
        scale: isHovered && !selected ? 1.06 : 1
      },
      ...rest,
      children: [
        stepNum !== null && /* @__PURE__ */ jsx(Box, { className: "likec4-edge-label__step-number", children: stepNum }),
        hasLabel && /* @__PURE__ */ jsxs(Box, { className: "likec4-edge-label__contents", children: [
          e$8(label2) && /* @__PURE__ */ jsx(
            Box,
            {
              lineClamp: 5,
              className: "likec4-edge-label__text",
              children: label2
            }
          ),
          e$8(technology) && /* @__PURE__ */ jsx(Box, { className: "likec4-edge-label__technology", children: "[ " + technology + " ]" }),
          children
        ] })
      ]
    }
  );
});
EdgeLabel.displayName = "EdgeLabel";
const toCssVarValue = (value) => {
  if (value !== void 0)
    return e$9(value) ? `${Math.round(value)}px` : value;
};
function EdgeLabelContainer({
  edgeProps: {
    id,
    selected = !1,
    data: {
      hovered: isHovered = !1,
      active: isActive = !1,
      dimmed: isDimmed = !1,
      labelBBox,
      color = "gray"
    },
    animated
  },
  labelPosition: labelXY,
  className,
  style,
  children,
  ...rest
}) {
  let zIndex = useXYStore(
    useCallback((state) => state.edgeLookup.get(id)?.zIndex ?? ZIndexes.Edge, [id])
  );
  (isHovered || isActive) && (zIndex += 100);
  let labelX = labelXY?.x ?? labelBBox?.x, labelY = labelXY?.y ?? labelBBox?.y;
  if (labelX === void 0 || labelY === void 0)
    return null;
  const translate = labelXY?.translate ?? "";
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsx(
    "div",
    {
      ...rest,
      className: cx(
        "nodrag nopan",
        "likec4-edge-label-container",
        className
      ),
      "data-likec4-hovered": isHovered,
      "data-likec4-color": color,
      "data-edge-active": isActive,
      "data-edge-animated": animated || isActive,
      ...selected !== !1 && {
        "data-likec4-selected": selected
      },
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...labelBBox && {
          maxWidth: labelBBox.width + 18
        },
        zIndex,
        ...style,
        transform: `translate(${toCssVarValue(labelX)}, ${toCssVarValue(labelY)}) ${translate}`
      },
      children
    },
    id
  ) });
}
const Open = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 14 16",
    refX: 5,
    refY: 4,
    markerWidth: "7",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M0,0 L7,4 L0,8 L4,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeDasharray: 0,
        strokeWidth: 1,
        strokeLinecap: "round"
      }
    )
  }
), Arrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        fill: "context-stroke",
        strokeWidth: 0
      }
    )
  }
), Crow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 12",
    refX: 8,
    refY: 4,
    markerWidth: "8",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 8 0 L 0 4 L 8 8 M 8 4 L 0 4",
        fill: "none",
        strokeWidth: 1
      }
    )
  }
), OArrow = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeWidth: 1.25,
        strokeLinejoin: "miter",
        strokeLinecap: "square"
      }
    )
  }
), Diamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 5,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        fill: "context-stroke",
        strokeWidth: 0,
        strokeLinecap: "round"
      }
    )
  }
), ODiamond = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 6,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...props,
    children: /* @__PURE__ */ jsx(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeWidth: 1.25,
        strokeLinecap: "round"
      }
    )
  }
), Dot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 0,
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), ODot = (props) => /* @__PURE__ */ jsx(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...props,
    children: /* @__PURE__ */ jsx(
      "circle",
      {
        strokeWidth: 1.25,
        stroke: "context-stroke",
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), EdgeMarkers = {
  Arrow,
  Crow,
  OArrow,
  Open,
  Diamond,
  ODiamond,
  Dot,
  ODot
};
function arrowTypeToMarker(arrowType) {
  if (!(!arrowType || arrowType === "none"))
    switch (arrowType) {
      case "normal":
        return "Arrow";
      case "crow":
        return "Crow";
      case "onormal":
        return "OArrow";
      case "diamond":
        return "Diamond";
      case "odiamond":
        return "ODiamond";
      case "open":
      case "vee":
        return "Open";
      case "dot":
        return "Dot";
      case "odot":
        return "ODot";
      default:
        nonexhaustive(arrowType);
    }
}
const EdgePath = forwardRef(({
  edgeProps: {
    id,
    data: {
      line,
      dir,
      tail,
      head
    },
    selectable = !0,
    style,
    interactionWidth
  },
  isDragging = !1,
  // omit
  onEdgePointerDown,
  strokeWidth,
  svgPath
}, svgPathRef) => {
  let markerStartName = arrowTypeToMarker(tail), markerEndName = arrowTypeToMarker(head ?? "normal");
  dir === "back" && ([markerStartName, markerEndName] = [markerEndName, markerStartName]);
  const MarkerStart = markerStartName ? EdgeMarkers[markerStartName] : null, MarkerEnd = markerEndName ? EdgeMarkers[markerEndName] : null, isDotted = line === "dotted", isDashed = isDotted || line === "dashed";
  let strokeDasharray;
  isDotted ? strokeDasharray = "1,8" : isDashed && (strokeDasharray = "8,10");
  const classes2 = edgePath();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    selectable && /* @__PURE__ */ jsx(
      "path",
      {
        className: cx(
          "react-flow__edge-interaction",
          css({
            fill: "none"
          })
        ),
        onPointerDown: onEdgePointerDown,
        d: svgPath,
        style: {
          strokeWidth: interactionWidth ?? 10,
          stroke: "currentcolor",
          strokeOpacity: 0,
          ...isDragging ? { display: "none" } : {}
        }
      }
    ),
    /* @__PURE__ */ jsx(
      "circle",
      {
        className: cx(
          // This class is queried by RelationshipPopover to position in the middle of the edge
          "likec4-edge-middle-point",
          classes2.middlePoint
        ),
        "data-edge-id": id,
        style: {
          offsetPath: `path("${svgPath}")`
        }
      }
    ),
    /* @__PURE__ */ jsxs("g", { className: classes2.markersCtx, onPointerDown: onEdgePointerDown, children: [
      /* @__PURE__ */ jsxs("defs", { children: [
        MarkerStart && /* @__PURE__ */ jsx(MarkerStart, { id: "start" + id }),
        MarkerEnd && /* @__PURE__ */ jsx(MarkerEnd, { id: "end" + id })
      ] }),
      /* @__PURE__ */ jsx(
        "path",
        {
          className: cx(
            "react-flow__edge-path",
            "hide-on-reduced-graphics",
            classes2.pathBg,
            isDragging && css({ display: "none" })
          ),
          d: svgPath,
          style,
          strokeLinecap: "round"
        }
      ),
      /* @__PURE__ */ jsx(
        "path",
        {
          ref: svgPathRef,
          className: cx(
            "react-flow__edge-path",
            classes2.path,
            selectable && "react-flow__edge-interaction"
          ),
          d: svgPath,
          style,
          strokeWidth,
          strokeLinecap: "round",
          strokeDasharray,
          markerStart: MarkerStart ? `url(#start${id})` : void 0,
          markerEnd: MarkerEnd ? `url(#end${id})` : void 0
        }
      )
    ] })
  ] });
});
EdgePath.displayName = "EdgePath";
const container$2 = hstack({
  position: "absolute",
  zIndex: 1,
  justifyContent: "center",
  alignItems: "center",
  _smallZoom: {
    display: "none"
  }
}), actionButtons = hstack({
  gap: "1.5",
  justifyContent: "center",
  alignItems: "center"
});
function ElementActionButtons({
  selected = !1,
  data: {
    hovered: isHovered = !1
  },
  buttons
}) {
  const id = useId$1();
  return buttons.length ? /* @__PURE__ */ jsx(
    Box,
    {
      className: container$2,
      style: {
        top: "calc(100% - 30px)",
        transform: "translateX(-50%)",
        left: "50%",
        width: "auto",
        minHeight: 30
      },
      children: /* @__PURE__ */ jsx(
        MotionDiv,
        {
          layoutRoot: !0,
          initial: !1,
          style: {
            originY: 0
          },
          animate: {
            opacity: isHovered || selected ? 1 : 0.75,
            scale: isHovered ? 1.1 : selected ? 0.9 : 0.8,
            y: isHovered || selected ? 6 : 0
          },
          layoutDependency: `${isHovered}-${selected}`,
          "data-likec4-hovered": isHovered,
          className: cx("nodrag nopan", actionButtons),
          children: buttons.map((button2, index2) => /* @__PURE__ */ jsx(
            ActionIcon,
            {
              component: MotionButton,
              className: actionBtn({}),
              initial: !1,
              whileTap: { scale: 1 },
              whileHover: {
                scale: 1.3
              },
              onClick: button2.onClick,
              onDoubleClick: stopPropagation,
              children: button2.icon || /* @__PURE__ */ jsx(IconBolt, {})
            },
            `${id}-${button2.key ?? index2}`
          ))
        }
      )
    }
  ) : null;
}
const Markdown = forwardRef(({
  value,
  textScale = 1,
  uselikec4palette = !1,
  hideIfEmpty = !1,
  emptyText = "no content",
  className,
  style,
  fontSize,
  ...props
}, ref) => {
  if (value.isEmpty && hideIfEmpty)
    return null;
  const content = value.nonEmpty ? value.isMarkdown ? { dangerouslySetInnerHTML: { __html: value.html } } : { children: /* @__PURE__ */ jsx("p", { children: value.text }) } : { children: /* @__PURE__ */ jsx(Text, { component: "span", fz: "xs", c: "dimmed", style: { userSelect: "none" }, children: emptyText }) };
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...props,
      className: cx(
        markdownBlock({
          uselikec4palette,
          value: value.isMarkdown ? "markdown" : "plaintext"
        }),
        className
      ),
      style: {
        ...style,
        ...fontSize && {
          "--text-fz": `var(--font-sizes-${fontSize}, var(--font-sizes-md))`
        },
        ...textScale !== 1 && {
          "--mantine-scale": textScale
        }
      },
      ...content
    }
  );
});
Markdown.displayName = "Markdown";
const Root$1 = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx(
  "div",
  {
    ...props,
    ref,
    className: cx(
      className,
      elementNodeData(),
      "likec4-element"
    )
  }
)), Icon = ({ data, ...props }) => /* @__PURE__ */ jsx(IconRenderer, { element: data, ...props }), Content = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsx(
  "div",
  {
    ...props,
    className: cx(
      className,
      "likec4-element-node-content"
    ),
    ref
  }
)), Title = forwardRef(({ data: { title: title2, style }, className, ...props }, ref) => {
  const { size: size2 } = ensureSizes(style), isSm = size2 === "sm" || size2 === "xs";
  return /* @__PURE__ */ jsx(
    Text,
    {
      component: "div",
      ...props,
      className: cx(
        className,
        "likec4-element-title"
      ),
      "data-likec4-node-title": "",
      lineClamp: isSm ? 2 : 3,
      ref,
      children: title2
    }
  );
}), Technology = forwardRef(({ data, children, className, ...props }, ref) => {
  const text = data?.technology ?? children;
  return e$8(text) ? /* @__PURE__ */ jsx(
    Text,
    {
      component: "div",
      ...props,
      className: cx(
        className,
        "likec4-element-technology"
      ),
      "data-likec4-node-technology": "",
      ref,
      children: text
    }
  ) : null;
}), Description = forwardRef(({ data: { description: description2, style }, className, ...props }, ref) => {
  if (!description2)
    return null;
  const desc = RichText.from(description2), { size: size2 } = ensureSizes(style);
  return /* @__PURE__ */ jsx(
    Markdown,
    {
      ...props,
      className: cx(
        className,
        "likec4-element-description",
        css({
          lineClamp: size2 === "sm" || size2 === "xs" ? 3 : 5
        })
      ),
      "data-likec4-node-description": "",
      value: desc,
      uselikec4palette: !0,
      hideIfEmpty: !0,
      style: {
        // Workaround for lineClamp not working with nested TABLE elements (if markdown has tables)
        maxHeight: desc.isMarkdown ? "8rem" : void 0
      },
      ref
    }
  );
});
function ElementData({ iconSize: iconSize2, data }) {
  return /* @__PURE__ */ jsxs(
    Root$1,
    {
      style: e$9(iconSize2) ? {
        // @ts-ignore
        "--likec4-icon-size": `${iconSize2}px`
      } : void 0,
      children: [
        /* @__PURE__ */ jsx(Icon, { data }),
        /* @__PURE__ */ jsxs(Content, { children: [
          /* @__PURE__ */ jsx(Title, { data }),
          /* @__PURE__ */ jsx(Technology, { data }),
          /* @__PURE__ */ jsx(Description, { data })
        ] })
      ]
    }
  );
}
ElementData.Root = Root$1;
ElementData.Icon = Icon;
ElementData.Content = Content;
ElementData.Title = Title;
ElementData.Technology = Technology;
ElementData.Description = Description;
const container$1 = css({
  position: "absolute",
  top: "0.5",
  right: "0.5",
  _shapeBrowser: {
    right: "[5px]"
  },
  _shapeCylinder: {
    top: "[14px]"
  },
  _shapeStorage: {
    top: "[14px]"
  },
  _shapeQueue: {
    top: "[1px]",
    right: "3"
    // 12px
  },
  _smallZoom: {
    display: "none"
  },
  _print: {
    display: "none"
  }
});
function ElementDetailsButton({
  selected = !1,
  data: {
    hovered: isHovered = !1
  },
  icon: icon2,
  onClick
}) {
  return /* @__PURE__ */ jsx(Box, { className: cx(container$1, "details-button"), children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      className: cx("nodrag nopan", actionBtn({ variant: "transparent" })),
      component: MotionButton,
      initial: !1,
      style: {
        originX: 0.45,
        originY: 0.55
      },
      animate: isHovered || selected ? {
        scale: 1.2,
        opacity: 0.8
      } : {
        scale: 1,
        opacity: 0.5
      },
      whileHover: {
        scale: 1.4,
        opacity: 1
      },
      whileTap: { scale: 1.15 },
      onClick,
      onDoubleClick: stopPropagation,
      children: icon2 ?? /* @__PURE__ */ jsx(IconId, { stroke: 1.8, style: { width: "75%" } })
    }
  ) });
}
const ElementNodeContainer = forwardRef(({
  nodeProps: {
    selected = !1,
    selectable = !1,
    data: {
      hovered: isHovered = !1,
      dimmed: isDimmed = !1,
      ...data
    }
  },
  className,
  style,
  children,
  ...rest
}, ref) => {
  let scale2 = 1;
  switch (!0) {
    case isHovered:
      scale2 = 1.05;
      break;
    case selected:
      scale2 = 1.02;
      break;
  }
  const {
    size: size2,
    padding,
    textSize
  } = ensureSizes(data.style ?? {});
  return /* @__PURE__ */ jsx(
    MotionDiv,
    {
      ref,
      className: cx(
        elementNode(),
        "group",
        className
      ),
      initial: !1,
      ...selectable && {
        animate: {
          scale: scale2
        },
        whileTap: { scale: 0.98 }
      },
      "data-likec4-hovered": isHovered,
      "data-likec4-color": data.color,
      "data-likec4-shape": data.shape,
      "data-likec4-shape-size": size2,
      "data-likec4-spacing": padding,
      "data-likec4-text-size": textSize,
      ...isDimmed !== !1 && {
        "data-likec4-dimmed": isDimmed
      },
      style: {
        ...style
      },
      ...rest,
      children
    }
  );
});
ElementNodeContainer.displayName = "ElementNodeContainer";
function cylinderSVGPath(diameter, height, tilt = 0.07) {
  const radius = Math.round(diameter / 2), rx = radius, ry = roundDpr(tilt * radius), tiltAdjustedHeight = height - 2 * ry;
  return {
    path: `  M ${diameter},${ry}
        a ${rx},${ry} 0,0,0 ${-diameter} 0
        l 0,${tiltAdjustedHeight}
        a ${rx},${ry} 0,0,0 ${diameter} 0
        l 0,${-tiltAdjustedHeight}
        z
        `.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
function docSVGPath(width, height) {
  const waveHeight = height / 8, baseY = roundDpr(height - waveHeight / 2), amplitude = roundDpr(height / 6), radius = 6;
  return {
    path: `
    M 0 ${baseY}
    V ${radius}
    Q 0 0 ${radius} 0
    H ${width - radius}
    Q ${width} 0 ${width} ${radius}
    V ${baseY}
    C ${roundDpr(width * 0.75)} ${baseY + amplitude}, ${roundDpr(width * 0.5)} ${baseY - amplitude}, 0 ${baseY}
  `.replace(/\s+/g, " ").trim()
  };
}
function bucketSVGPath(width, height) {
  const cx2 = width / 2, topRx = roundDpr(cx2), topRy = roundDpr(Math.min(height / 8, topRx * 0.08)), bottomRx = roundDpr(topRx * 0.8), bottomRy = roundDpr(topRy * 1.05), topY = topRy, bottomY = height - bottomRy, leftBottomX = cx2 - bottomRx;
  return {
    path: `
    M ${width},${topY}
    a ${topRx},${topRy} 0,0,0 ${-width} 0
    L ${leftBottomX},${bottomY}
    a ${bottomRx},${bottomRy} 0,0,0 ${bottomRx * 2} 0
    Z
  `.replace(/\s+/g, " ").trim(),
    topRx,
    topRy,
    bottomRx,
    bottomRy
  };
}
function queueSVGPath(width, height, tilt = 0.185) {
  const diameter = height, ry = Math.round(diameter / 2), rx = roundDpr(diameter / 2 * tilt), tiltAdjustedWidth = width - 2 * rx;
  return {
    path: `
    M ${rx},0
    a ${rx},${ry} 0,0,0 0 ${diameter}
    l ${tiltAdjustedWidth},0
    a ${rx},${ry} 0,0,0 0 ${-diameter}
    z`.replace(/\s+/g, " ").trim(),
    ry,
    rx
  };
}
const PersonIcon = {
  width: 115,
  height: 120,
  path: "M57.9197 0C10.9124 0 33.5766 54.75 33.5766 54.75C38.6131 62.25 45.3285 60.75 45.3285 66C45.3285 70.5 39.4526 72 33.5766 72.75C24.3431 72.75 15.9489 71.25 7.55474 84.75C2.51825 93 0 120 0 120H115C115 120 112.482 93 108.285 84.75C99.8905 70.5 91.4963 72.75 82.2628 72C76.3869 71.25 70.5109 69.75 70.5109 65.25C70.5109 60.75 77.2263 62.25 82.2628 54C82.2628 54.75 104.927 0 57.9197 0V0Z"
};
function ShapeSvg({ shape, w, h }) {
  switch (shape) {
    case "mobile":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { "data-likec4-fill": "fill", strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 17, cy: h / 2, r: 12 }),
          /* @__PURE__ */ jsx("rect", { x: 33, y: 12, width: w - 44, height: h - 24, rx: 5 })
        ] })
      ] });
    case "document": {
      const { path } = docSVGPath(w, h);
      return /* @__PURE__ */ jsx(
        "path",
        {
          d: path,
          "data-likec4-fill": "fill",
          strokeWidth: 2
        }
      );
    }
    case "browser":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsxs("g", { "data-likec4-fill": "fill", strokeWidth: 0, children: [
          /* @__PURE__ */ jsx("circle", { cx: 16, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 36, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("circle", { cx: 56, cy: 17, r: 7 }),
          /* @__PURE__ */ jsx("rect", { x: 70, y: 8, width: w - 80, height: 17, rx: 4 }),
          /* @__PURE__ */ jsx("rect", { x: 10, y: 32, width: w - 20, height: h - 42, rx: 4 })
        ] })
      ] });
    case "person":
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          "rect",
          {
            width: w,
            height: h,
            rx: 6,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ jsx(
          "svg",
          {
            x: w - PersonIcon.width - 6,
            y: h - PersonIcon.height,
            width: PersonIcon.width,
            height: PersonIcon.height,
            viewBox: `0 0 ${PersonIcon.width} ${PersonIcon.height}`,
            "data-likec4-fill": "mix-stroke",
            children: /* @__PURE__ */ jsx(
              "path",
              {
                strokeWidth: 0,
                d: PersonIcon.path
              }
            )
          }
        )
      ] });
    case "queue": {
      const { path, rx, ry } = queueSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx("ellipse", { cx: rx, cy: ry, ry: ry - 0.75, rx, "data-likec4-fill": "mix-stroke", strokeWidth: 2 })
      ] });
    }
    case "bucket": {
      const { path, topRx, topRy } = bucketSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx(
          "ellipse",
          {
            cx: w / 2,
            cy: topRy,
            rx: topRx,
            ry: topRy,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 2
          }
        )
      ] });
    }
    case "storage":
    case "cylinder": {
      const { path, rx, ry } = cylinderSVGPath(w, h);
      return /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("path", { d: path, strokeWidth: 2 }),
        /* @__PURE__ */ jsx(
          "ellipse",
          {
            cx: rx,
            cy: ry,
            ry,
            rx: rx - 0.75,
            "data-likec4-fill": "mix-stroke",
            strokeWidth: 2
          }
        )
      ] });
    }
    default:
      return nonexhaustive(shape);
  }
}
function ShapeSvgOutline({ shape, w, h }) {
  let svg;
  switch (shape) {
    case "bucket":
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: bucketSVGPath(w + 6, h + 6).path }) });
      break;
    case "queue":
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: queueSVGPath(w + 6, h + 6).path }) });
      break;
    case "document":
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: docSVGPath(w + 6, h + 6).path }) });
      break;
    case "storage":
    case "cylinder": {
      svg = /* @__PURE__ */ jsx("g", { transform: "translate(-3 -3)", children: /* @__PURE__ */ jsx("path", { d: cylinderSVGPath(w + 6, h + 6).path }) });
      break;
    }
    default: {
      svg = /* @__PURE__ */ jsx(
        "rect",
        {
          x: -3,
          y: -3,
          width: w + 6,
          height: h + 6,
          rx: 8
        }
      );
      break;
    }
  }
  return /* @__PURE__ */ jsx("g", { className: "likec4-shape-outline", children: svg });
}
function ElementShape({ data, width, height, showSeletionOutline = !0 }) {
  let w = width && width > 10 ? width : data.width, h = height && height > 10 ? height : data.height;
  const isMultiple = data.style?.multiple ?? !1, borderStyle = data.style?.border ?? "none", withBorder = borderStyle !== "none";
  if (data.shape === "rectangle")
    return /* @__PURE__ */ jsxs(
      "div",
      {
        style: {
          borderStyle
        },
        className: elementShapeRecipe({
          shapetype: "html",
          withBorder
        }),
        children: [
          isMultiple && /* @__PURE__ */ jsx("div", { className: "likec4-shape-multiple" }),
          showSeletionOutline && /* @__PURE__ */ jsx("div", { className: "likec4-shape-outline" })
        ]
      }
    );
  const className = elementShapeRecipe({
    shapetype: "svg"
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    isMultiple && /* @__PURE__ */ jsx("svg", { className, "data-likec4-shape-multiple": "true", viewBox: `0 0 ${w} ${h}`, children: /* @__PURE__ */ jsx(ShapeSvg, { shape: data.shape, w, h }) }),
    /* @__PURE__ */ jsxs("svg", { className, viewBox: `0 0 ${w} ${h}`, children: [
      showSeletionOutline && /* @__PURE__ */ jsx(ShapeSvgOutline, { shape: data.shape, w, h }),
      /* @__PURE__ */ jsx(ShapeSvg, { shape: data.shape, w, h })
    ] })
  ] });
}
const ElementTag = forwardRef(
  ({ tag, cursor, className, style, ...props }, ref) => {
    const spec = useTagSpecification(tag);
    return /* @__PURE__ */ jsxs(
      Box,
      {
        ref,
        "data-likec4-tag": tag,
        className: cx(
          likec4tag({
            autoTextColor: isTagColorSpecified(spec)
          }),
          className
        ),
        ...props,
        style: {
          cursor,
          ...style
        },
        children: [
          /* @__PURE__ */ jsx("span", { children: "#" }),
          /* @__PURE__ */ jsx("span", { children: tag })
        ]
      }
    );
  }
), propsAreEqual = (prev, next) => prev.data.width === next.data.width && deepEqual(prev.data.tags, next.data.tags) && (prev.data.hovered ?? !1) === (next.data.hovered ?? !1), ElementTags = memo$1(({ id, data: { tags, width, hovered = !1 } }) => {
  const {
    hovered: isTagsBarHovered,
    ref: tagsBarRef
  } = useHover(), {
    hovered: isTagsToolbarHovered,
    ref: tagsToolbarRef
  } = useHover(), [isVisible, setVisible] = useDebouncedState(!1, hovered ? 120 : 300);
  useEffect(() => {
    setVisible((visibleNow) => visibleNow ? hovered || isTagsBarHovered || isTagsToolbarHovered : hovered && (isTagsBarHovered || isTagsToolbarHovered));
  }, [isTagsBarHovered, isTagsToolbarHovered, hovered]);
  const zoom = useCurrentZoom(), zoomIsLargeEnough = zoom > 1.2, diagram = useDiagram(), onHover = (tag) => {
    diagram.send({ type: "tag.highlight", tag });
  }, onLeave = useCallback(() => {
    diagram.send({ type: "tag.unhighlight" });
  }, []);
  if (!tags || tags.length === 0)
    return null;
  const maxWidth = Math.max(Math.round(width * zoom) - 10, 200);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      "div",
      {
        ref: tagsBarRef,
        className: cx(
          "likec4-element-tags",
          hstack({
            pointerEvents: "all",
            gap: "1",
            alignItems: "flex-end",
            justifyItems: "stretch",
            position: "absolute",
            width: "100%",
            bottom: "0",
            left: "0",
            padding: "1",
            _shapeCylinder: {
              bottom: "[5px]"
            },
            _shapeStorage: {
              bottom: "[5px]"
            },
            _shapeQueue: {
              bottom: "0",
              paddingLeft: "[14px]"
            }
          })
        ),
        onClick: stopPropagation,
        children: tags.map((tag) => /* @__PURE__ */ jsx(
          Box,
          {
            "data-likec4-tag": tag,
            className: css({
              layerStyle: "likec4.tag",
              flex: "1",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              maxWidth: 50,
              height: 5,
              _whenHovered: {
                height: 12,
                borderRadius: 4,
                transitionDelay: ".08s"
              },
              transition: "fast"
            })
          },
          id + "#" + tag
        ))
      }
    ),
    /* @__PURE__ */ jsx(NodeToolbar, { isVisible, align: "start", position: Position.Bottom, children: /* @__PURE__ */ jsx(
      HStack,
      {
        ref: tagsToolbarRef,
        css: {
          gap: "0.5",
          alignItems: "baseline",
          flexWrap: "wrap",
          pb: "sm",
          translate: "auto",
          x: "[-8px]",
          maxWidth
        },
        children: tags.map((tag) => /* @__PURE__ */ jsx(
          ElementTag,
          {
            tag,
            cursor: "pointer",
            className: css({
              userSelect: "none",
              ...zoomIsLargeEnough && {
                fontSize: "lg",
                borderRadius: "[4px]",
                px: "1.5"
                // 6px
              }
            }),
            onClick: (e2) => {
              e2.stopPropagation(), diagram.openSearch(`#${tag}`);
            },
            onMouseEnter: () => onHover(tag),
            onMouseLeave: onLeave
          },
          tag
        ))
      }
    ) })
  ] });
}, propsAreEqual);
ElementTags.displayName = "ElementTags";
const isSame = (a, b) => Math.abs(a - b) < 2.5, edgePropsEqual = (prev, next) => prev.id === next.id && deepEqual(prev.selected ?? !1, next.selected ?? !1) && deepEqual(prev.animated ?? !1, next.animated ?? !1) && deepEqual(prev.source, next.source) && isSame(prev.sourceX, next.sourceX) && isSame(prev.sourceY, next.sourceY) && deepEqual(prev.sourceHandleId ?? null, next.sourceHandleId ?? null) && deepEqual(prev.sourcePosition, next.sourcePosition) && deepEqual(prev.target, next.target) && isSame(prev.targetY, next.targetY) && isSame(prev.targetX, next.targetX) && deepEqual(prev.targetHandleId ?? null, next.targetHandleId ?? null) && deepEqual(prev.targetPosition, next.targetPosition) && deepEqual(prev.data, next.data);
function memoEdge(Edge) {
  const Memo = memo$1(Edge, edgePropsEqual);
  return Memo.displayName = `MemoEdge(${Edge.displayName || Edge.name})`, Memo;
}
function nodePropsEqual(prev, next) {
  return prev.id === next.id && deepEqual(prev.type, next.type) && deepEqual(prev.selected ?? !1, next.selected ?? !1) && deepEqual(prev.dragging ?? !1, next.dragging ?? !1) && deepEqual(prev.width ?? 0, next.width ?? 0) && deepEqual(prev.height ?? 0, next.height ?? 0) && deepEqual(prev.zIndex ?? 0, next.zIndex ?? 0) && deepEqual(prev.data, next.data);
}
const isMemoized = /* @__PURE__ */ Symbol.for("isMemoized");
function memoNode(Node, displayName = "Node") {
  if (Node.hasOwnProperty(isMemoized))
    return Node;
  const NodeComponent = memo$1(
    Node,
    nodePropsEqual
  );
  return NodeComponent.displayName = displayName, Object.defineProperty(NodeComponent, isMemoized, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), NodeComponent;
}
const positions = [Position.Top, Position.Right, Position.Bottom, Position.Left], DefaultHandles = memo$1(() => /* @__PURE__ */ jsx(Fragment, { children: positions.map((position) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
  /* @__PURE__ */ jsx(
    Handle,
    {
      type: "source",
      position,
      className: "likec4-node-handle-center"
    }
  ),
  /* @__PURE__ */ jsx(
    Handle,
    {
      type: "target",
      position,
      className: "likec4-node-handle-center"
    }
  )
] }, position)) })), GithubIcon = forwardRef((props, ref) => /* @__PURE__ */ jsx(
  "svg",
  {
    height: "24",
    width: "24",
    fill: "currentColor",
    ...props,
    viewBox: "0 0 24 24",
    ref,
    children: /* @__PURE__ */ jsx("path", { d: "M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z" })
  }
)), GITHUB_PREFIX = "https://github.com/", Link = forwardRef(
  ({ value, className, ...props }, ref) => {
    const url = value.url.includes("://") ? value.url : new window.URL(value.url, window.location.href).toString();
    let isGithub = url.startsWith(GITHUB_PREFIX);
    return /* @__PURE__ */ jsx(
      Badge,
      {
        ref,
        variant: "default",
        radius: "sm",
        size: "sm",
        tt: "none",
        leftSection: value.title ? /* @__PURE__ */ jsx(Fragment, { children: value.title }) : null,
        rightSection: /* @__PURE__ */ jsx(CopyButton, { value: url, timeout: 1500, children: ({ copy, copied }) => /* @__PURE__ */ jsx(
          ActionIcon,
          {
            className: css({
              opacity: copied ? 1 : 0.45,
              transition: "fast",
              _hover: {
                opacity: 1
              }
            }),
            tabIndex: -1,
            size: "20",
            variant: copied ? "light" : "transparent",
            color: copied ? "teal" : "gray",
            "data-active": copied,
            onClick: (e2) => {
              e2.stopPropagation(), e2.preventDefault(), copy();
            },
            children: copied ? /* @__PURE__ */ jsx(IconCheck, {}) : /* @__PURE__ */ jsx(IconCopy, { stroke: 2.5 })
          }
        ) }),
        ...props,
        className: cx(className, "group"),
        classNames: {
          root: css({
            flexWrap: "nowrap",
            minHeight: 24,
            maxWidth: 500,
            userSelect: "all",
            pr: "0",
            backgroundColor: {
              base: "transparent",
              _hover: {
                base: "mantine.colors.gray[1]",
                _dark: "mantine.colors.dark[5]"
              }
            }
          }),
          section: css({
            '&:is([data-position="left"])': {
              color: "mantine.colors.dimmed",
              userSelect: "none",
              pointerEvents: "none",
              _groupHover: {
                color: "[var(--badge-color)]",
                opacity: 0.7
              }
            }
          })
        },
        children: /* @__PURE__ */ jsxs(
          styled.a,
          {
            href: url,
            target: "_blank",
            style: {
              color: "var(--badge-color)",
              cursor: "pointer"
            },
            css: {
              transition: "fast",
              opacity: {
                base: 0.7,
                _hover: 1
              },
              textDecoration: {
                base: "none",
                _hover: "underline"
              }
            },
            children: [
              isGithub && /* @__PURE__ */ jsx(
                GithubIcon,
                {
                  height: "12",
                  width: "12",
                  style: { verticalAlign: "middle", marginRight: "4px" }
                }
              ),
              isGithub ? url.replace(GITHUB_PREFIX, "") : url
            ]
          }
        )
      }
    );
  }
), selector$6 = ({ context: context2 }) => {
  const view = context2.view;
  return {
    id: view.id,
    title: context2.viewModel?.title ?? (view.title && extractViewTitleFromPath(view.title)) ?? "Untitled View",
    description: context2.viewModel?.description ?? RichText.from(view.description),
    tags: view.tags ?? [],
    links: view.links ?? []
  };
}, DetailsControls = (props) => {
  const [opened, setOpened] = useState(!1), data = useNavigationActorSnapshot(selector$6, deepEqual), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom-end",
      shadow: "xl",
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      offset: {
        mainAxis: 4
      },
      opened,
      onChange: setOpened,
      ...portalProps,
      ...props,
      children: [
        /* @__PURE__ */ jsx(ViewDetailsCardTrigger, { linksCount: data.links.length, onOpen: () => setOpened(!0) }),
        opened && /* @__PURE__ */ jsx(ViewDetailsCardDropdown, { data, onClose: () => setOpened(!1) })
      ]
    }
  );
}, ViewDetailsCardTrigger = ({ linksCount, onOpen }) => /* @__PURE__ */ jsx(Popover.Target, { children: /* @__PURE__ */ jsxs(
  UnstyledButton,
  {
    component: MotionButton,
    layout: "position",
    whileTap: {
      scale: 0.95,
      translateY: 1
    },
    onClick: (e2) => {
      e2.stopPropagation(), onOpen();
    },
    className: cx(
      "group",
      hstack({
        gap: "2",
        paddingInline: "2",
        paddingBlock: "1",
        rounded: "sm",
        userSelect: "none",
        cursor: "pointer",
        color: {
          base: "likec4.panel.action",
          _hover: "likec4.panel.action.hover"
        },
        backgroundColor: {
          _hover: "likec4.panel.action.bg.hover"
        },
        display: {
          base: "none",
          "@/xs": "flex"
        }
      }),
      ""
    ),
    children: [
      /* @__PURE__ */ jsx(IconId, { size: 16, stroke: 1.8 }),
      linksCount > 0 && /* @__PURE__ */ jsxs(HStack, { gap: "[1px]", children: [
        /* @__PURE__ */ jsx(IconLink, { size: 14, stroke: 2 }),
        /* @__PURE__ */ jsx(
          Box,
          {
            css: {
              fontSize: "11px",
              fontWeight: 600,
              lineHeight: 1,
              opacity: 0.8
            },
            children: linksCount
          }
        )
      ] })
    ]
  }
) }), SectionHeader$1 = styled("div", {
  base: {
    fontSize: "xs",
    color: "mantine.colors.dimmed",
    fontWeight: 500,
    userSelect: "none",
    mb: "xxs"
  }
}), ViewDetailsCardDropdown = ({
  data: {
    id,
    title: title2,
    description: description2,
    tags,
    links
  },
  onClose
}) => {
  const diagram = useDiagram();
  return useOnDiagramEvent("paneClick", onClose), useOnDiagramEvent("nodeClick", onClose), /* @__PURE__ */ jsxs(
    Popover.Dropdown,
    {
      className: cx(
        "nowheel nopan nodrag",
        vstack({
          margin: "xs",
          layerStyle: "likec4.dropdown",
          gap: "md",
          padding: "md",
          paddingBottom: "lg",
          pointerEvents: "all",
          maxWidth: "calc(100cqw - 52px)",
          minWidth: "200px",
          maxHeight: "calc(100cqh - 100px)",
          width: "max-content",
          cursor: "default",
          overflow: "auto",
          overscrollBehavior: "contain",
          "@/sm": {
            minWidth: 400,
            maxWidth: 550
          },
          "@/lg": {
            maxWidth: 700
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsxs("section", { children: [
          /* @__PURE__ */ jsx(Text, { component: "div", fw: 500, size: "xl", lh: "sm", children: title2 }),
          /* @__PURE__ */ jsxs(HStack, { alignItems: "flex-start", mt: "1", children: [
            /* @__PURE__ */ jsx(ViewBadge, { label: "id", value: id }),
            /* @__PURE__ */ jsx(HStack, { gap: "xs", flexWrap: "wrap", children: tags.map((tag) => /* @__PURE__ */ jsx(
              ElementTag,
              {
                tag,
                cursor: "pointer",
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.openSearch(`#${tag}`);
                }
              },
              tag
            )) })
          ] })
        ] }),
        links.length > 0 && /* @__PURE__ */ jsxs("section", { className: hstack({ alignItems: "baseline" }), children: [
          /* @__PURE__ */ jsx(SectionHeader$1, { children: "Links" }),
          /* @__PURE__ */ jsx(HStack, { gap: "xs", flexWrap: "wrap", children: links.map((link, i) => /* @__PURE__ */ jsx(Link, { value: link }, `${i}-${link.url}`)) })
        ] }),
        description2.isEmpty && /* @__PURE__ */ jsx(Text, { component: "div", fw: 500, size: "xs", c: "dimmed", style: { userSelect: "none" }, children: "No description" }),
        description2.nonEmpty && /* @__PURE__ */ jsxs("section", { children: [
          /* @__PURE__ */ jsx(SectionHeader$1, { children: "Description" }),
          /* @__PURE__ */ jsx(
            Markdown,
            {
              value: description2,
              fontSize: "sm",
              emptyText: "No description",
              className: css({
                userSelect: "all"
              })
            }
          )
        ] })
      ]
    }
  );
}, ViewBadge = ({
  label: label2,
  value
}) => /* @__PURE__ */ jsxs(HStack, { gap: "0.5", children: [
  /* @__PURE__ */ jsx(ViewBadgeLabel, { children: label2 }),
  /* @__PURE__ */ jsx(
    Badge,
    {
      size: "sm",
      radius: "sm",
      variant: "light",
      color: "gray",
      tt: "none",
      fw: 500,
      classNames: {
        root: css({
          width: "max-content",
          overflow: "visible",
          px: "1",
          color: {
            _dark: "mantine.colors.gray[4]",
            _light: "mantine.colors.gray[8]"
          }
        }),
        label: css({
          overflow: "visible"
        }),
        section: css({
          opacity: 0.5,
          userSelect: "none",
          marginInlineEnd: "0.5"
        })
      },
      children: value
    }
  )
] }), ViewBadgeLabel = styled("div", {
  base: {
    color: "mantine.colors.dimmed",
    fontWeight: 500,
    fontSize: "xxs",
    userSelect: "none"
  }
}), LayoutWarning = memo$1(() => {
  const [ctx, { toggleCompare }] = useDiagramCompareLayout(), portalProps = useMantinePortalProps(), { drifts, isActive, isEnabled } = ctx;
  return /* @__PURE__ */ jsx(AnimatePresence, { propagate: !0, children: isEnabled && !isActive && /* @__PURE__ */ jsxs(
    HoverCard,
    {
      position: "bottom-start",
      openDelay: 600,
      closeDelay: 200,
      floatingStrategy: "absolute",
      offset: {
        mainAxis: 4,
        crossAxis: -22
      },
      ...portalProps,
      children: [
        /* @__PURE__ */ jsx(HoverCardTarget, { children: /* @__PURE__ */ jsx(
          UnstyledButton,
          {
            component: MotionButton,
            layout: "position",
            onClick: (e2) => {
              e2.stopPropagation(), toggleCompare();
            },
            whileTap: {
              scale: 0.95,
              translateY: 1
            },
            className: cx(
              "group",
              navigationPanelActionIcon({
                variant: "filled",
                type: "warning"
              }),
              hstack({
                gap: "xxs",
                padding: "1.5",
                rounded: "sm",
                userSelect: "none",
                cursor: "pointer",
                fontSize: "xs",
                fontWeight: 600
              })
            ),
            children: isActive ? /* @__PURE__ */ jsx(Fragment, { children: "Stop Compare" }) : /* @__PURE__ */ jsx(IconAlertTriangle, { size: 18 })
          }
        ) }),
        /* @__PURE__ */ jsx(HoverCardDropdown, { p: "0", children: /* @__PURE__ */ jsxs(
          Notification,
          {
            color: "orange",
            withBorder: !1,
            withCloseButton: !1,
            title: "View is out of sync",
            children: [
              /* @__PURE__ */ jsx(Text, { mt: 2, size: "sm", lh: "xs", children: "Model has changed since this view was last updated." }),
              /* @__PURE__ */ jsxs(Text, { mt: 4, size: "sm", lh: "xs", children: [
                "Detected changes:",
                drifts.map((drift) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
                  /* @__PURE__ */ jsx("br", {}),
                  /* @__PURE__ */ jsxs("span", { children: [
                    "- ",
                    drift
                  ] })
                ] }, drift))
              ] }),
              /* @__PURE__ */ jsx(
                Button,
                {
                  mt: "xs",
                  size: "compact-sm",
                  variant: "default",
                  onClick: (e2) => {
                    e2.stopPropagation(), toggleCompare();
                  },
                  children: "Compare with current state"
                }
              )
            ]
          }
        ) })
      ]
    }
  ) });
});
LayoutWarning.displayName = "ManualLayoutWarning";
const Logo$1 = forwardRef(
  (props, ref) => /* @__PURE__ */ jsxs("svg", { ref, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 222 56", ...props, children: [
    /* @__PURE__ */ jsx(
      "path",
      {
        fill: "#5E98AF",
        d: "M33.95 33.78V0H2.37A2.37 2.37 0 0 0 0 2.35V33.9h33.95v-.12ZM38.57 33.78H55.6v-14.6c0-1.3-1.06-2.35-2.36-2.35H38.57v16.95ZM33.95 38.37H17.04v14.6c0 1.29 1.06 2.35 2.36 2.35h14.67V38.37h-.12ZM38.57 38.37v16.95h14.67c1.3 0 2.36-1.06 2.36-2.36v-14.6H38.57Z"
      }
    ),
    /* @__PURE__ */ jsx(
      "path",
      {
        className: css({
          fill: "[#FCFBF7]",
          _light: {
            fill: "[#222221]"
          }
        }),
        d: "M71.61 12.08c-.06 3.61.3 29.95.23 31.87 0 1.8 0 3.6.06 5.41 0 .3.18.58.47.58 4.1.18 8.13-.17 12.22-.11 1.34.05 2.69 0 3.97 0 1.29-.06 1.4-.59 1.35-1.63-.06-1.63-.06-3.08-.06-4.65-.06-.82-.53-1.11-1.23-1.11-2.4.06-4.8-.06-7.19.06-.4.06-.82.06-1.23.06-.7-.06-.87-.24-.93-1v-.86c-.18-4.83.17-9.83.17-14.66-.06-4.07 0-7.73-.06-11.34 0-1.57 0-3.14-.05-4.65-.06-.93 0-1.92-.24-2.85-.11-.35-.29-.81-.7-.81h-5.5c-.93 0-1.22.64-1.28 1.57v4.12ZM103.81 35c-.17-6.63-.1-13.67-.05-20.24 0-2.04-.12-4.25-.12-6.28 0-2.21-.87-2.1-2.04-2.15-1.7-.06-2.46-.06-4.15-.06-1.11-.06-1.58.23-1.58 1.34 0 5.7-.18 21.8-.12 24.13.06 2.33.3 12.91.18 15.24-.06.81 0 1.62.06 2.44.05.29.23.58.7.58 1.93-.12 3.74-.12 5.67-.17.7-.06 1.28-.24 1.58-1 .05-.4-.12-11.04-.12-13.83Zm13.92 4.47c0-2.03-.3-7.56-.23-8.72 0-.17.11-.4.17-.4.12 0 .35.11.41.17 1.87 2.44 10.64 19.36 11.7 19.42.28.06.58.06.87.06 1.99-.12 3.74 0 5.73 0 2.04 0 .7-1.98.35-2.5-.53-.76-7.48-13.14-7.9-13.9-1.16-1.98-2.16-4.13-3.32-6.05-.12-.23-.24-.58-.18-.81.12-.7.3-1.34.59-1.98a93.18 93.18 0 0 1 4.55-8.14c1.88-2.97 2.93-4.83 4.45-7.5.35-.64.58-1.34.82-2.1.05-.29-.18-.58-.53-.58-1.11-.05-5.15 0-6.43 0-.59 0-1.17.12-1.46.64-.76 1.46-8.6 15.7-9.35 16.98-.06.12-.24.18-.41.18 0 0-.12-.18-.12-.3-.06-3.25.53-13.9.4-16.04-.05-1.28-.28-1.4-1.57-1.46-1.4-.05-3.33-.05-4.73-.05-1.3 0-1.4.7-1.58 1.62-.06.18-.06 5.64-.06 8.09 0 3.54-.3 25.76.11 32.8 0 .7.18 1.1.77 1.1 1.57-.12 3.91 0 5.49 0 1.11 0 1.29-.12 1.29-1.98 0-2.5.23-4.77.23-7.85 0-.23-.06-.46-.06-.7Zm25.66-1.4h-.06c0 1.46-.05 2.97 0 4.49.06 1.86.18 3.72.3 5.58 0 .64.17.81.76.93 1.22.29 2.4.35 3.62.35 3.16-.12 6.31.11 9.47 0 1.29-.06 1.87.06 3.16-.18 1.17-.23 1.58-.87 1.58-2.61-.12-1.1-.06-1.57-.06-2.91 0-1.92-1.35-2.56-2.52-2.5-.81.06-4.73-.06-6.31-.06-2.63.06-2.22.4-2.22-2.33 0-2.2.06-5.05.06-7.32 0-1.22.11-1.63 1.28-1.63h7.31c1.17.17 1.99-.64 1.99-1.86 0-1.22.12-1.28.12-2.5l-.18-1.75c-.12-.99-.47-1.33-1.46-1.33-.64 0-1.29.05-1.93.11-2.52.18-3.68-.17-6.14 0-.82 0-.93-.11-1-.87-.23-2.27 0-4.77.24-7.04.06-.93.3-1.1 1.17-1.16l8.24-.06c1.11-.11 1.46-.06 1.4-1.16-.11-1.69.06-3.43-.11-5.12-.12-.93-.41-1.1-1.46-1.1-1.76.05-2.17.05-3.92.17-1.75.06-8.77.06-10.46.06-2.46 0-2.63-.18-2.7 2.8-.1 2.32-.05 4.7-.05 7.09 0 4.07-.23 18.66-.12 21.92Zm47.76-24.82c.06-1.92 0-3.5 0-5.35 0-2.15-3.92-1.92-5.32-1.86a18.95 18.95 0 0 0-15.08 9.77c-.82 1.57-1.4 3.2-1.81 4.88a34 34 0 0 0-.59 12.15c.41 3.78 1.4 7.56 3.74 10.59 4.04 5.3 11.46 7.15 17.83 6.16.3-.06.59-.11.82-.29.18-.11.35-.35.35-.58l.18-3.31c.06-1.05 0-1 0-2.04 0-1.4-2.93-.35-4.74-.35-1.75 0-3.62-.06-5.2-.87-2.8-1.57-4.38-4.71-5.26-7.68-1-3.2-1.23-6.63-.64-9.88.7-4.25 2.74-9.13 7.25-10.59 2.57-.87 5.31-.58 7.89-.29.35.06.58-.17.58-.46Zm26.77 15.3c.06-2.5 0-14.84 0-18.38.06-.82 0-1.63-.11-2.45-.06-.99-.24-1.28-1.29-1.33h-4.44c-.82 0-1.35.4-1.82 1.27-1.34 3.2-10.75 24.02-12.15 26.58-.53.99-1 1.63-1 2.68v4.24c0 .76-.06 1.28 1.23 1.28l11.1-.06c1.47 0 1.47.3 1.47 1.1 0 .88-.12 4.9-.12 5.3 0 .58.12 1.16 1.23 1.16h5.08c1.23 0 1.23-.7 1.23-2.03.06-1.17-.06-3.5-.06-4.66 0-.93.18-.98 1.76-.98 1.22 0 1.75-.12 1.75-.88.06-1.57 0-2.67 0-4.42 0-1.04-.93-.98-2.92-.98-.65 0-.7-.18-.7-1.05-.12-1.8-.24-4.6-.24-6.4Zm-7.25-5.94c-.05.7-.11 10.82-.11 12.27-.06.81-.24 1.05-1 1.1-1.93.06-3.85.06-5.78.06-.47 0-.65-.4-.41-.87.23-.4 4.85-11.57 6.13-14.48.18-.17.24-.35.41-.52.18-.12.41-.18.59-.23.06 0 .23.29.23.46 0 .76-.06 1.51-.06 2.21Z"
      }
    )
  ] })
), LogoIcon = forwardRef(
  (props, ref) => /* @__PURE__ */ jsx("svg", { ref, xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 56 56", ...props, children: /* @__PURE__ */ jsx(
    "path",
    {
      fill: "#5E98AF",
      d: "M33.95 33.78V0H2.37A2.37 2.37 0 0 0 0 2.35V33.9h33.95v-.12ZM38.57 33.78H55.6v-14.6c0-1.3-1.06-2.35-2.36-2.35H38.57v16.95ZM33.95 38.37H17.04v14.6c0 1.29 1.06 2.35 2.36 2.35h14.67V38.37h-.12ZM38.57 38.37v16.95h14.67c1.3 0 2.36-1.06 2.36-2.36v-14.6H38.57Z"
    }
  ) })
), LogoButton$1 = () => {
  const actor = useNavigationActor(), { onLogoClick } = useDiagramEventHandlers();
  return /* @__PURE__ */ jsx(MotionDiv, { layout: "position", children: /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      onMouseEnter: () => {
        actor.send({ type: "breadcrumbs.mouseEnter.root" });
      },
      onMouseLeave: () => {
        actor.send({ type: "breadcrumbs.mouseLeave.root" });
      },
      onClick: (e2) => {
        e2.stopPropagation(), onLogoClick && actor.isOpened() && setTimeout(() => {
          onLogoClick();
        }, 100), actor.send({ type: "breadcrumbs.click.root" });
      },
      className: cx(
        "mantine-active",
        hstack({
          padding: "0.5",
          // _active: {
          //   transform: 'translateY(1px)',
          // },
          width: {
            base: "[20px]",
            "@/md": "[64px]"
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsx(
          Logo$1,
          {
            className: css({
              display: {
                base: "none",
                "@/md": "block"
              }
            })
          }
        ),
        /* @__PURE__ */ jsx(
          LogoIcon,
          {
            className: css({
              display: {
                base: "block",
                "@/md": "none"
              }
            })
          }
        )
      ]
    }
  ) });
}, NavigationButtons = () => {
  const diagram = useDiagram(), {
    hasStepBack,
    hasStepForward
  } = useDiagramContext((s) => ({
    hasStepBack: s.navigationHistory.currentIndex > 0,
    hasStepForward: s.navigationHistory.currentIndex < s.navigationHistory.history.length - 1
  }));
  return /* @__PURE__ */ jsxs(
    MotionDiv,
    {
      layout: "position",
      className: hstack({
        gap: "0.5"
      }),
      children: [
        /* @__PURE__ */ jsx(
          PanelActionIcon,
          {
            disabled: !hasStepBack,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigate("back");
            },
            children: /* @__PURE__ */ jsx(IconArrowLeft, { size: 14 })
          }
        ),
        /* @__PURE__ */ jsx(
          PanelActionIcon,
          {
            disabled: !hasStepForward,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigate("forward");
            },
            children: /* @__PURE__ */ jsx(IconArrowRight, { size: 14 })
          }
        )
      ]
    }
  );
}, OpenSource = () => {
  const viewId = useCurrentViewId(), { enableVscode } = useEnabledFeatures(), { onOpenSource } = useDiagramEventHandlers();
  return enableVscode ? /* @__PURE__ */ jsx(Tooltip$5, { label: "Open View Source", children: /* @__PURE__ */ jsx(
    PanelActionIcon,
    {
      onClick: (e2) => {
        e2.stopPropagation(), onOpenSource?.({ view: viewId });
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { style: { width: "60%", height: "60%" } })
    }
  ) }) : null;
}, SearchControl = memo$1(() => {
  const { enableSearch, enableCompareWithLatest } = useEnabledFeatures(), diagram = useDiagram(), isMac = isMacOs();
  return /* @__PURE__ */ jsx(AnimatePresence, { children: enableSearch && !enableCompareWithLatest && /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      component: MotionButton,
      layout: "position",
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openSearch();
      },
      whileTap: {
        scale: 0.95,
        translateY: 1
      },
      className: cx(
        "group",
        hstack({
          gap: "xxs",
          paddingInline: "sm",
          paddingBlock: "xxs",
          userSelect: "none",
          layerStyle: "likec4.panel.action.filled",
          display: {
            base: "none",
            "@/md": "flex"
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsx(IconSearch, { size: 14, stroke: 2.5 }),
        /* @__PURE__ */ jsx(
          Box,
          {
            css: {
              fontSize: "11px",
              fontWeight: 600,
              lineHeight: 1,
              opacity: 0.8,
              whiteSpace: "nowrap"
            },
            children: isMac ? " + K" : "Ctrl + K"
          }
        )
      ]
    }
  ) });
});
SearchControl.displayName = "SearchControl";
const selector$5 = (ctx) => {
  const comparingLatest = deriveToggledFeatures(ctx).enableCompareWithLatest && !!ctx.view.drifts && ctx.view._layout === "auto", sequenceLayoutActive = ctx.view._type === "dynamic" && ctx.dynamicViewVariant === "sequence", noActiveWalkthrough = !e$8(ctx.activeWalkthrough);
  return {
    visible: ctx.features.enableEditor && noActiveWalkthrough,
    disabled: comparingLatest || sequenceLayoutActive,
    isReadOnly: ctx.toggledFeatures.enableReadOnly ?? !1
  };
}, ToggleReadonly = () => {
  const { visible, disabled, isReadOnly: isReadOnly2 } = useDiagramContext(selector$5), diagram = useDiagram();
  return /* @__PURE__ */ jsx(AnimatePresence, { mode: "popLayout", children: visible && /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      component: MotionButton,
      layout: "position",
      layoutDependency: isReadOnly2,
      disabled,
      onClick: (e2) => {
        e2.stopPropagation(), !disabled && diagram.toggleFeature("ReadOnly");
      },
      initial: { opacity: 0, scale: 0.6 },
      animate: { opacity: 1, scale: disabled ? 0.95 : 1 },
      exit: { opacity: 0, scale: 0.6 },
      whileTap: {
        translateY: 1
      },
      className: cx(
        "group",
        hstack({
          gap: "0.5",
          paddingInline: "xxs",
          paddingBlock: "xxs",
          userSelect: "none",
          layerStyle: "likec4.panel.action",
          backgroundColor: {
            base: "none",
            _notDisabled: {
              _hover: "likec4.panel.action.bg.hover"
            }
          }
        })
      ),
      children: [
        /* @__PURE__ */ jsx(IconLockOpen2, { size: 14, stroke: 2, style: { display: isReadOnly2 ? "none" : void 0 } }),
        /* @__PURE__ */ jsx(IconLock, { size: 14, stroke: 2, style: { display: isReadOnly2 ? void 0 : "none" } }),
        /* @__PURE__ */ jsx(
          MotionDiv,
          {
            className: css({
              fontSize: "11px",
              fontWeight: 600,
              lineHeight: 1,
              opacity: 0.8
            }),
            style: {
              display: isReadOnly2 ? "block" : "none"
            },
            children: "Edit"
          }
        )
      ]
    }
  ) });
}, breadcrumbTitle = cva({
  base: {
    fontSize: "sm",
    fontWeight: "500",
    transition: "fast",
    color: {
      base: "likec4.panel.action",
      _hover: "likec4.panel.action.hover"
    }
  },
  variants: {
    truncate: {
      true: {
        truncate: !0
      }
    },
    dimmed: {
      true: {
        color: {
          base: "likec4.panel.text.dimmed",
          _hover: "likec4.panel.action"
        }
      }
    }
  }
}), LikeC4ProjectsContext = createContext(null), emptyProjects = [];
function useLikeC4Projects() {
  const ctx = useContext(LikeC4ProjectsContext);
  return ctx ? ctx.projects : emptyProjects;
}
const emptyOnProjectChange = (id) => {
  console.warn(`Triggered callback to change project to ${id}, but no <LikeC4ProjectsProvider/> found`);
};
function useChangeLikeC4Project() {
  const ctx = useContext(LikeC4ProjectsContext);
  return ctx ? ctx.onProjectChange : emptyOnProjectChange;
}
const emptyContext = {
  projects: emptyProjects,
  onProjectChange: emptyOnProjectChange
};
function useLikeC4ProjectsContext() {
  return useContext(LikeC4ProjectsContext) ?? emptyContext;
}
function useLikeC4ProjectId() {
  const ctx = useContext(LikeC4ModelContext);
  if (!ctx)
    throw new Error("No LikeC4ModelProvider found");
  return ctx.projectId;
}
function useLikeC4Styles() {
  const $styles = useContext(LikeC4ModelContext)?.$styles ?? LikeC4Styles$1.DEFAULT, [styles, setStyles] = useState($styles);
  return useEffect(() => {
    setStyles((current) => current.equals($styles) ? current : $styles);
  }, [$styles]), styles;
}
const TriggerWalkthroughButton = forwardRef((props, ref) => /* @__PURE__ */ jsx(
  Button,
  {
    variant: "filled",
    size: "xs",
    fw: "500",
    ...props,
    ref,
    component: MotionButton,
    whileTap: {
      scale: 0.95
    },
    layout: "position",
    layoutId: "trigger-dynamic-walkthrough",
    className: css({
      flexShrink: 0
    })
  }
));
function StartWalkthroughButton() {
  const { enableReadOnly, enableCompareWithLatest } = useEnabledFeatures(), diagram = useDiagram(), actor = useNavigationActor();
  let tooltipLabel = "Start Dynamic View Walkthrough";
  switch (!0) {
    case !enableReadOnly:
      tooltipLabel = "Walkthrough not available in Edit mode";
      break;
    case enableCompareWithLatest:
      tooltipLabel = "Walkthrough not available when Compare is active";
      break;
  }
  return /* @__PURE__ */ jsx(Tooltip$5, { label: tooltipLabel, children: /* @__PURE__ */ jsx(
    TriggerWalkthroughButton,
    {
      onClick: (e2) => {
        e2.stopPropagation(), actor.closeDropdown(), diagram.startWalkthrough();
      },
      initial: { opacity: 0, scale: 0.6, translateX: -10 },
      animate: { opacity: 1, scale: 1, translateX: 0 },
      exit: { opacity: 0, translateX: -20 },
      size: "compact-xs",
      h: 26,
      disabled: !enableReadOnly || enableCompareWithLatest,
      classNames: {
        label: css({
          display: {
            base: "none",
            "@/md": "inherit"
          }
        }),
        section: css({
          marginInlineStart: {
            base: "0",
            "@/md": "2"
          }
        })
      },
      rightSection: /* @__PURE__ */ jsx(IconPlayerPlayFilled, { size: 10 }),
      children: "Start"
    }
  ) });
}
const DynamicViewModeSwitcher = forwardRef(({ value, onChange }, ref) => /* @__PURE__ */ jsx(MotionDiv, { ref, layout: "position", children: /* @__PURE__ */ jsx(
  SegmentedControl,
  {
    size: "xs",
    value,
    component: MotionDiv,
    onChange: (variant) => {
      invariant$1(variant === "diagram" || variant === "sequence", "Invalid dynamic view variant"), onChange(variant);
    },
    classNames: {
      label: css({
        fontSize: "xxs"
      })
    },
    data: [
      {
        value: "diagram",
        label: "Diagram"
      },
      {
        value: "sequence",
        label: "Sequence"
      }
    ]
  }
) }));
function DynamicViewControls() {
  const dynamicViewVariant = useDiagramContext((c) => c.dynamicViewVariant), diagram = useDiagram();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    /* @__PURE__ */ jsx(
      DynamicViewModeSwitcher,
      {
        value: dynamicViewVariant,
        onChange: (mode) => {
          diagram.switchDynamicViewVariant(mode);
        }
      }
    ),
    /* @__PURE__ */ jsx(StartWalkthroughButton, {}, "trigger-dynamic-walkthrough")
  ] });
}
const PrevNextButton = Button.withProps({
  // Button is polymorphic, but we dont want it to inherit the motion props
  component: MotionButton,
  layout: "position",
  whileTap: {
    scale: 0.95
  },
  variant: "light",
  size: "xs",
  fw: "500"
}), ParallelFrame = () => {
  const { portalProps } = useMantinePortalProps();
  return /* @__PURE__ */ jsx(Portal, { ...portalProps, children: /* @__PURE__ */ jsx(
    Box,
    {
      css: {
        position: "absolute",
        margin: "0",
        padding: "0",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        border: "2px solid",
        borderColor: "mantine.colors.orange[6]",
        pointerEvents: "none",
        md: {
          borderWidth: 4
        }
      }
    }
  ) });
};
function ActiveWalkthroughControls() {
  const diagram = useDiagram(), {
    isParallel,
    hasNext,
    hasPrevious,
    currentStep,
    totalSteps
  } = useDiagramContext((s) => {
    const currentStepIndex = s.xyedges.findIndex((e2) => e2.id === s.activeWalkthrough?.stepId);
    return {
      isParallel: e$8(s.activeWalkthrough?.parallelPrefix),
      hasNext: currentStepIndex < s.xyedges.length - 1,
      hasPrevious: currentStepIndex > 0,
      currentStep: currentStepIndex + 1,
      totalSteps: s.xyedges.length
    };
  });
  return /* @__PURE__ */ jsxs(AnimatePresence, { propagate: !0, mode: "popLayout", children: [
    /* @__PURE__ */ jsx(
      TriggerWalkthroughButton,
      {
        variant: "light",
        size: "xs",
        color: "orange",
        mr: "sm",
        onClick: (e2) => {
          e2.stopPropagation(), diagram.stopWalkthrough();
        },
        rightSection: /* @__PURE__ */ jsx(IconPlayerStopFilled, { size: 10 }),
        children: "Stop"
      },
      "stop-walkthrough"
    ),
    /* @__PURE__ */ jsx(
      PrevNextButton,
      {
        disabled: !hasPrevious,
        onClick: () => diagram.walkthroughStep("previous"),
        leftSection: /* @__PURE__ */ jsx(IconPlayerSkipBackFilled, { size: 10 }),
        children: "Previous"
      },
      "prev"
    ),
    /* @__PURE__ */ jsxs(
      Badge,
      {
        component: MotionDiv,
        layout: "position",
        size: "md",
        radius: "sm",
        variant: isParallel ? "gradient" : "transparent",
        gradient: { from: "red", to: "orange", deg: 90 },
        rightSection: /* @__PURE__ */ jsx(
          MotionDiv,
          {
            className: css({
              fontSize: "xxs",
              display: isParallel ? "block" : "none"
            }),
            children: "parallel"
          }
        ),
        className: css({
          alignItems: "baseline"
        }),
        children: [
          currentStep,
          " / ",
          totalSteps
        ]
      },
      "step-badge"
    ),
    /* @__PURE__ */ jsx(
      PrevNextButton,
      {
        disabled: !hasNext,
        onClick: () => diagram.walkthroughStep("next"),
        rightSection: /* @__PURE__ */ jsx(IconPlayerSkipForwardFilled, { size: 10 }),
        children: "Next"
      },
      "next"
    ),
    isParallel && /* @__PURE__ */ jsx(ParallelFrame, {}, "parallel-frame")
  ] });
}
const selectBreadcrumbs = ({ context: context2 }) => {
  const view = context2.view, folder = context2.viewModel?.folder;
  return {
    folders: !folder || folder.isRoot ? [] : folder.breadcrumbs.map((s) => ({
      folderPath: s.path,
      title: s.title
    })),
    viewId: view.id,
    viewTitle: context2.viewModel?.title ?? (view.title && extractViewTitleFromPath(view.title)) ?? "Untitled View",
    isDynamicView: (context2.viewModel?._type ?? view._type) === "dynamic"
  };
}, NavigationPanelControls = memo$1(() => {
  const actor = useNavigationActor(), {
    enableNavigationButtons,
    enableDynamicViewWalkthrough
  } = useEnabledFeatures(), {
    folders,
    viewTitle,
    isDynamicView
  } = useSelector(actor.actorRef, selectBreadcrumbs, deepEqual), folderBreadcrumbs = folders.flatMap(({ folderPath, title: title2 }, i) => [
    /* @__PURE__ */ jsx(
      UnstyledButton,
      {
        component: MotionButton,
        className: cx(
          breadcrumbTitle({ dimmed: !0, truncate: !0 }),
          "mantine-active",
          css({
            userSelect: "none",
            maxWidth: "200px",
            display: {
              base: "none",
              "@/md": "block"
            }
          })
        ),
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        title: title2,
        onMouseEnter: () => actor.send({ type: "breadcrumbs.mouseEnter.folder", folderPath }),
        onMouseLeave: () => actor.send({ type: "breadcrumbs.mouseLeave.folder", folderPath }),
        onClick: (e2) => {
          e2.stopPropagation(), actor.send({ type: "breadcrumbs.click.folder", folderPath });
        },
        children: title2
      },
      folderPath
    ),
    /* @__PURE__ */ jsx(BreadcrumbsSeparator, {}, `separator-${i}`)
  ]), viewBreadcrumb = /* @__PURE__ */ jsx(
    UnstyledButton,
    {
      component: MotionButton,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      className: cx(
        "mantine-active",
        breadcrumbTitle({ truncate: !0 }),
        css({
          userSelect: "none"
        })
      ),
      title: viewTitle,
      onMouseEnter: () => actor.send({ type: "breadcrumbs.mouseEnter.viewtitle" }),
      onMouseLeave: () => actor.send({ type: "breadcrumbs.mouseLeave.viewtitle" }),
      onClick: (e2) => {
        e2.stopPropagation(), actor.send({ type: "breadcrumbs.click.viewtitle" });
      },
      children: viewTitle
    },
    "view-title"
  );
  return /* @__PURE__ */ jsxs(AnimatePresence, { propagate: !0, mode: "popLayout", children: [
    /* @__PURE__ */ jsx(LogoButton$1, {}, "logo-button"),
    enableNavigationButtons && /* @__PURE__ */ jsx(NavigationButtons, {}, "nav-buttons"),
    /* @__PURE__ */ jsxs(
      MotionDiv,
      {
        layout: "position",
        className: hstack({
          gap: "1",
          flexShrink: 1,
          flexGrow: 1,
          overflow: "hidden"
        }),
        children: [
          folderBreadcrumbs,
          viewBreadcrumb
        ]
      },
      "breadcrumbs"
    ),
    /* @__PURE__ */ jsxs(
      MotionDiv,
      {
        layout: "position",
        className: hstack({
          gap: "0.5",
          flexGrow: 0,
          _empty: {
            display: "none"
          }
        }),
        children: [
          /* @__PURE__ */ jsx(DetailsControls, { onOpen: () => actor.closeDropdown() }),
          /* @__PURE__ */ jsx(OpenSource, {}),
          /* @__PURE__ */ jsx(ToggleReadonly, {})
        ]
      },
      "actions"
    ),
    enableDynamicViewWalkthrough && isDynamicView && /* @__PURE__ */ jsx(DynamicViewControls, {}, "dynamic-view-controls"),
    /* @__PURE__ */ jsx(SearchControl, {}, "search-control"),
    /* @__PURE__ */ jsx(LayoutWarning, {}, "outdated-manual-layout-warning")
  ] });
});
NavigationPanelControls.displayName = "NavigationPanelControls";
const NavigationLink = forwardRef(({ className, truncateLabel = !0, ...others }, ref) => /* @__PURE__ */ jsx(
  NavLink,
  {
    ...others,
    component: "button",
    classNames: navigationLink({
      truncateLabel
    }),
    className: cx(
      "group",
      "mantine-active",
      className
    ),
    ref
  }
));
NavigationLink.displayName = "NavigationLink";
const CompoundActions = (props) => {
  const { enableNavigateTo } = useEnabledFeatures(), diagram = useDiagram(), { navigateTo } = props.data;
  return navigateTo && enableNavigateTo ? /* @__PURE__ */ jsx(
    CompoundActionButton,
    {
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, props.id);
      },
      ...props
    }
  ) : null;
}, compareElementActionsProps = (a, b) => deepEqual(a.data.id, b.data.id) && deepEqual(a.selected ?? !1, b.selected ?? !1) && deepEqual(a.data.modelFqn ?? null, b.data.modelFqn ?? null) && deepEqual(a.data.navigateTo ?? null, b.data.navigateTo ?? null) && deepEqual(a.data.hovered ?? !1, b.data.hovered ?? !1) && (!a.extraButtons && !b.extraButtons || shallowEqual(a.extraButtons, b.extraButtons)), ElementActions$2 = memo$1(({
  extraButtons,
  ...props
}) => {
  const { enableNavigateTo, enableRelationshipBrowser } = useEnabledFeatures(), diagram = useDiagram(), { id, navigateTo, modelFqn } = props.data;
  let buttons = useMemo(() => {
    const buttons2 = [];
    return navigateTo && enableNavigateTo && buttons2.push({
      key: "navigate",
      icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, id);
      }
    }), enableRelationshipBrowser && buttons2.push({
      key: "relationships",
      icon: /* @__PURE__ */ jsx(IconTransform, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(modelFqn);
      }
    }), buttons2;
  }, [enableNavigateTo, enableRelationshipBrowser, modelFqn, navigateTo, id, diagram]);
  return extraButtons && t$1(extraButtons, 1) && (buttons = [...buttons, ...extraButtons]), /* @__PURE__ */ jsx(ElementActionButtons, { ...props, buttons });
}, compareElementActionsProps), DeploymentElementActions = ({
  extraButtons,
  ...props
}) => {
  const { enableNavigateTo, enableRelationshipBrowser } = useEnabledFeatures(), diagram = useDiagram(), { id, navigateTo, modelFqn } = props.data;
  let buttons = useMemo(() => {
    const buttons2 = [];
    return navigateTo && enableNavigateTo && buttons2.push({
      key: "navigate",
      icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo, id);
      }
    }), enableRelationshipBrowser && modelFqn && buttons2.push({
      key: "relationships",
      icon: /* @__PURE__ */ jsx(IconTransform, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(modelFqn);
      }
    }), buttons2;
  }, [enableNavigateTo, enableRelationshipBrowser, modelFqn, navigateTo, id]);
  return extraButtons && t$1(extraButtons, 1) && (buttons = [...buttons, ...extraButtons]), /* @__PURE__ */ jsx(ElementActionButtons, { ...props, buttons });
};
function NodeDrifts({
  nodeProps: { data },
  position = "bottom"
}) {
  const drifts = data.drifts;
  if (!drifts || drifts.length === 0)
    return null;
  const toolbarPosition = position === "top" ? Position.Top : Position.Bottom;
  return /* @__PURE__ */ jsx(
    Box,
    {
      className: "likec4-node-drifts",
      css: {
        display: "contents",
        "& + .likec4-element-shape": {
          outlineColor: "likec4.compare.manual.outline",
          outlineWidth: "4px",
          outlineStyle: "dashed",
          outlineOffset: "1.5"
        }
      },
      children: /* @__PURE__ */ jsx(NodeToolbar, { isVisible: data.hovered === !0, align: "start", position: toolbarPosition, children: /* @__PURE__ */ jsx(
        Notification,
        {
          color: "orange",
          withBorder: !1,
          withCloseButton: !1,
          title: "Changes:",
          children: drifts.map((drift) => /* @__PURE__ */ jsxs(Text, { mt: 2, size: "sm", lh: "xs", children: [
            "- ",
            drift
          ] }, drift))
        }
      ) })
    }
  );
}
const Tooltip$3 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4,
  withinPortal: !1
});
function BrowseRelationshipsButton({ fqn: fqn2 }) {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(Tooltip$3, { label: "Browse relationships", children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openRelationshipsBrowser(fqn2);
      },
      children: /* @__PURE__ */ jsx(
        IconTransform,
        {
          stroke: 2,
          style: {
            width: "65%",
            height: "65%"
          }
        }
      )
    }
  ) });
}
function GoToSourceButton(props) {
  const { onOpenSource } = useDiagramEventHandlers();
  return onOpenSource ? /* @__PURE__ */ jsx(Tooltip$3, { label: "Open source", children: /* @__PURE__ */ jsx(
    ActionIcon,
    {
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: (e2) => {
        e2.stopPropagation(), props.elementId ? onOpenSource?.({
          element: props.elementId
        }) : props.deploymentId && onOpenSource?.({
          deployment: props.deploymentId
        });
      },
      children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "65%" } })
    }
  ) }) : null;
}
function BorderStyleOption({
  elementBorderStyle = "none",
  onChange
}) {
  const [value, setValue] = useState(elementBorderStyle);
  return useEffect(() => {
    setValue(elementBorderStyle);
  }, [elementBorderStyle]), /* @__PURE__ */ jsx(
    SegmentedControl,
    {
      size: "xs",
      fz: 9,
      fullWidth: !0,
      withItemsBorders: !1,
      value,
      onChange: (v) => {
        const border = v;
        setValue(border), onChange({ border });
      },
      styles: {
        label: {
          paddingTop: 2,
          paddingBottom: 2
        }
      },
      data: [
        { label: "Solid", value: "solid" },
        { label: "Dashed", value: "dashed" },
        { label: "Dotted", value: "dotted" },
        { label: "None", value: "none" }
      ]
    }
  );
}
const SemanticColors = [
  "primary",
  "secondary",
  "muted"
];
function ColorButton({
  elementColor,
  elementOpacity,
  onColorPreview,
  isOpacityEditable = !1,
  onChange,
  ...props
}) {
  const { theme } = useLikeC4Styles();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      position: "top-start",
      offset: 2,
      withinPortal: !1,
      ...props,
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(Button, { variant: "subtle", color: "gray", size: "xs", px: 6, children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: theme.colors[elementColor].elements.fill,
            size: 16,
            withShadow: !0,
            style: { color: "#fff", cursor: "pointer" }
          }
        ) }) }),
        /* @__PURE__ */ jsxs(PopoverDropdown, { p: "xs", children: [
          /* @__PURE__ */ jsx(
            ColorSwatches,
            {
              theme,
              elementColor,
              onColorPreview,
              onChange: (color) => onChange({ color })
            }
          ),
          isOpacityEditable && /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(Divider$2, { label: "opacity", labelPosition: "left" }),
            /* @__PURE__ */ jsx(Space, { h: "xs" }),
            /* @__PURE__ */ jsx(
              OpacityOption,
              {
                elementOpacity,
                onOpacityChange: (opacity) => {
                  onChange({ opacity });
                }
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function ColorSwatches({
  theme,
  elementColor,
  onColorPreview,
  onChange
}) {
  const changeColor = (color) => (e2) => {
    e2.stopPropagation(), onColorPreview(null), elementColor !== color && onChange(color);
  }, otherColors = t$4(theme.colors).filter((color) => !SemanticColors.includes(color));
  return /* @__PURE__ */ jsx(Stack, { gap: 2, onMouseLeave: () => onColorPreview(null), children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 1e3, closeDelay: 300, children: [
    /* @__PURE__ */ jsx(Flex, { maw: 120, gap: "6", justify: "flex-start", align: "flex-start", direction: "row", wrap: "wrap", children: SemanticColors.map((color) => /* @__PURE__ */ jsx(
      Tooltip$6,
      {
        label: color,
        fz: "xs",
        color: "dark",
        offset: 2,
        withinPortal: !1,
        transitionProps: { duration: 140, transition: "slide-up" },
        children: /* @__PURE__ */ jsx(
          ColorSwatch,
          {
            color: theme.colors[color].elements.fill,
            size: 18,
            withShadow: !0,
            onMouseEnter: () => onColorPreview(color),
            onClick: changeColor(color),
            style: { color: "#fff", cursor: "pointer" },
            children: elementColor === color && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
          }
        )
      },
      color
    )) }),
    /* @__PURE__ */ jsx(
      Flex,
      {
        mt: "sm",
        maw: 110,
        gap: "6",
        justify: "flex-start",
        align: "flex-start",
        direction: "row",
        wrap: "wrap",
        children: otherColors.map((key2) => /* @__PURE__ */ jsx(
          Tooltip$6,
          {
            label: key2,
            fz: "xs",
            color: "dark",
            offset: 2,
            transitionProps: { duration: 140, transition: "slide-up" },
            children: /* @__PURE__ */ jsx(
              ColorSwatch,
              {
                color: theme.colors[key2].elements.fill,
                size: 18,
                onMouseEnter: () => onColorPreview(key2),
                onClick: changeColor(key2),
                style: { color: "#fff", cursor: "pointer" },
                children: elementColor === key2 && /* @__PURE__ */ jsx(CheckIcon, { style: { width: rem(10), height: rem(10) } })
              }
            )
          },
          key2
        ))
      }
    )
  ] }) });
}
function OpacityOption({
  elementOpacity = 100,
  onOpacityChange
}) {
  const [value, setValue] = useState(elementOpacity);
  return useUpdateEffect$1(() => {
    setValue(elementOpacity);
  }, [elementOpacity]), /* @__PURE__ */ jsx(
    Slider,
    {
      size: "sm",
      color: "dark",
      value,
      onChange: setValue,
      onChangeEnd: onOpacityChange
    }
  );
}
const toolbarTitle = css({
  color: "mantine.colors.dimmed",
  fontSize: "10px",
  fontWeight: 600,
  maxWidth: "220px",
  cursor: "default",
  userSelect: "all",
  textOverflow: "ellipsis",
  overflow: "hidden",
  whiteSpace: "nowrap"
}), selectSelectedNodesCount = (context2) => context2.xynodes.filter((x) => x.selected).length, useSelectedNodesCount = () => useDiagramContext(selectSelectedNodesCount);
function Toolbar({ title: title2, children, nodeProps, ...props }) {
  const selectedNodesCount = useSelectedNodesCount(), {
    selected = !1,
    dragging = !1,
    data: {
      hovered = !1
    }
  } = nodeProps, _isToolbarVisible = hovered && selectedNodesCount === 0 || selected && selectedNodesCount === 1;
  let delay2 = 150;
  _isToolbarVisible ? selected ? delay2 = 100 : delay2 = 1e3 : selectedNodesCount > 0 && (delay2 = 50);
  const [isToolbarVisible] = useDebouncedValue(_isToolbarVisible, delay2);
  return isToolbarVisible ? /* @__PURE__ */ jsx(
    NodeToolbar,
    {
      isVisible: !dragging,
      offset: 4,
      ...props,
      children: /* @__PURE__ */ jsx(
        Paper,
        {
          className: cx("nodrag", "nopan"),
          px: 5,
          pb: 8,
          pt: 4,
          radius: "sm",
          shadow: "xl",
          onDoubleClickCapture: stopPropagation,
          onPointerDown: stopPropagation,
          onClick: stopPropagation,
          onDoubleClick: stopPropagation,
          withBorder: !0,
          children: /* @__PURE__ */ jsxs(VStack, { gap: "2", children: [
            /* @__PURE__ */ jsx(Box, { px: "1", children: /* @__PURE__ */ jsx(Text, { className: toolbarTitle, children: title2 }) }),
            /* @__PURE__ */ jsx(HStack, { gap: "1", children })
          ] })
        }
      )
    }
  ) : null;
}
function useHandlers(target, props) {
  const diagram = useDiagram(), [originalColor, setOriginalColor] = useState(null), onColorPreview = useCallbackRef((color) => {
    if (color === null) {
      if (!originalColor) return;
      setOriginalColor(null), diagram.updateNodeData(props.data.id, {
        color: originalColor
      });
      return;
    }
    setOriginalColor((value) => value ?? props.data.color), diagram.updateNodeData(props.data.id, {
      color
    });
  }), onChange = useCallbackRef((change) => {
    const { shape, color, ...style } = change;
    diagram.updateNodeData(props.data.id, {
      ...shape && { shape },
      ...color && { color },
      style
    }), diagram.triggerChange({
      op: "change-element-style",
      style: change,
      targets: [target]
    });
  });
  return {
    elementColor: originalColor ?? props.data.color,
    onColorPreview,
    onChange
  };
}
function CompoundElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      style,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(modelFqn, props), opacity = style?.opacity ?? 100;
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: modelFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            isOpacityEditable: !0,
            elementOpacity: opacity,
            onChange,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style?.border ?? (opacity < 99 ? "dashed" : "none"),
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: modelFqn }),
        enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function CompoundDeploymentToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      deploymentFqn,
      style,
      modelFqn
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(deploymentFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: deploymentFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            isOpacityEditable: !0,
            elementOpacity: style?.opacity,
            onChange,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style?.border,
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { deploymentId: deploymentFqn }),
        enableRelationshipBrowser && modelFqn && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function ElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      shape,
      modelFqn,
      style
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(modelFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: modelFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          ElementShapeButton,
          {
            elementShape: shape,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style?.border ?? "none",
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { elementId: modelFqn }),
        enableRelationshipBrowser && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function DeploymentElementToolbar(props) {
  const { enableVscode, enableRelationshipBrowser } = useEnabledFeatures(), {
    data: {
      shape,
      deploymentFqn,
      modelFqn,
      style
    }
  } = props, { elementColor, onColorPreview, onChange } = useHandlers(deploymentFqn, props);
  return /* @__PURE__ */ jsxs(
    Toolbar,
    {
      nodeProps: props,
      title: deploymentFqn,
      align: "start",
      children: [
        /* @__PURE__ */ jsx(
          ColorButton,
          {
            elementColor,
            onColorPreview,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          ElementShapeButton,
          {
            elementShape: shape,
            onChange
          }
        ),
        /* @__PURE__ */ jsx(
          BorderStyleOption,
          {
            elementBorderStyle: style?.border ?? "none",
            onChange
          }
        ),
        enableVscode && /* @__PURE__ */ jsx(GoToSourceButton, { deploymentId: deploymentFqn }),
        enableRelationshipBrowser && modelFqn && /* @__PURE__ */ jsx(BrowseRelationshipsButton, { fqn: modelFqn })
      ]
    }
  );
}
function ElementShapeButton({
  elementShape,
  onChange
}) {
  return /* @__PURE__ */ jsxs(
    Menu,
    {
      openDelay: 300,
      closeDelay: 450,
      floatingStrategy: "fixed",
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      closeOnItemClick: !1,
      position: "top-start",
      offset: 2,
      styles: {
        item: {
          padding: "calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-xs)"
        }
      },
      withinPortal: !1,
      children: [
        /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
          Button,
          {
            variant: "light",
            color: "gray",
            size: "xs",
            px: 8,
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 12 }),
            children: elementShape
          }
        ) }),
        /* @__PURE__ */ jsx(
          MenuDropdown,
          {
            onDoubleClick: stopPropagation,
            onClick: stopPropagation,
            children: ElementShapes.map((shape) => /* @__PURE__ */ jsx(
              MenuItem,
              {
                fz: 12,
                fw: 500,
                value: shape,
                rightSection: elementShape === shape ? /* @__PURE__ */ jsx(IconCheck, { size: 12 }) : void 0,
                onClick: (e2) => {
                  e2.stopPropagation(), onChange({ shape });
                },
                children: shape
              },
              shape
            ))
          }
        )
      ]
    }
  );
}
function ElementDetailsButtonWithHandler$2(props) {
  const diagram = useDiagram(), fqn2 = props.data.modelFqn;
  return fqn2 ? /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(fqn2, props.id);
      }
    }
  ) : null;
}
function CompoundDetailsButtonWithHandler(props) {
  const diagram = useDiagram(), fqn2 = props.data.modelFqn;
  return fqn2 ? /* @__PURE__ */ jsx(
    CompoundDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(fqn2, props.id);
      }
    }
  ) : null;
}
function ElementNode$2(props) {
  const { enableElementTags, enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
    enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(ElementActions$2, { ...props }),
    enableElementDetails && /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$2, { ...props }),
    !enableReadOnly && /* @__PURE__ */ jsx(ElementToolbar, { ...props }),
    /* @__PURE__ */ jsx(DefaultHandles, {})
  ] });
}
function DeploymentNode(props) {
  const { enableElementTags, enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
    enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(DeploymentElementActions, { ...props }),
    enableElementDetails && /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$2, { ...props }),
    !enableReadOnly && /* @__PURE__ */ jsx(DeploymentElementToolbar, { ...props }),
    /* @__PURE__ */ jsx(DefaultHandles, {})
  ] });
}
const compoundHasDrifts = css({
  outlineColor: "likec4.compare.manual.outline",
  outlineWidth: "4px",
  outlineStyle: "dashed",
  outlineOffset: "1.5"
}), hasDrifts = (props) => props.data.drifts && props.data.drifts.length > 0;
function CompoundElementNode(props) {
  const { enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures(), showDrifts = enableCompareWithLatest && hasDrifts(props);
  return /* @__PURE__ */ jsxs(
    CompoundNodeContainer,
    {
      className: showDrifts ? compoundHasDrifts : void 0,
      nodeProps: props,
      children: [
        enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
        /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
        /* @__PURE__ */ jsx(CompoundActions, { ...props }),
        enableElementDetails && /* @__PURE__ */ jsx(CompoundDetailsButtonWithHandler, { ...props }),
        !enableReadOnly && /* @__PURE__ */ jsx(CompoundElementToolbar, { ...props }),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    }
  );
}
function CompoundDeploymentNode(props) {
  const { enableElementDetails, enableReadOnly, enableCompareWithLatest } = useEnabledFeatures(), showDrifts = enableCompareWithLatest && hasDrifts(props);
  return /* @__PURE__ */ jsxs(
    CompoundNodeContainer,
    {
      className: showDrifts ? compoundHasDrifts : void 0,
      nodeProps: props,
      children: [
        enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
        /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
        /* @__PURE__ */ jsx(CompoundActions, { ...props }),
        enableElementDetails && /* @__PURE__ */ jsx(CompoundDetailsButtonWithHandler, { ...props }),
        !enableReadOnly && /* @__PURE__ */ jsx(CompoundDeploymentToolbar, { ...props }),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    }
  );
}
function ViewGroupNode(props) {
  const { enableCompareWithLatest } = useEnabledFeatures(), showDrifts = enableCompareWithLatest && hasDrifts(props);
  return /* @__PURE__ */ jsxs(
    CompoundNodeContainer,
    {
      className: showDrifts ? compoundHasDrifts : void 0,
      nodeProps: props,
      children: [
        enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
        /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    }
  );
}
const positionMap = {
  left: Position.Left,
  right: Position.Right,
  top: Position.Top,
  bottom: Position.Bottom
}, ActorStepPort = ({
  data,
  port: p
}) => /* @__PURE__ */ jsxs(Fragment, { children: [
  /* @__PURE__ */ jsx(
    Box,
    {
      "data-likec4-color": data.color,
      className: css({
        position: "absolute",
        backgroundColor: "var(--likec4-palette-fill)",
        rounded: "xs",
        width: {
          base: "5px",
          _whenHovered: "7px",
          _whenSelected: "7px"
        },
        transition: "fast",
        translateX: "-1/2",
        translateY: "-1/2",
        translate: "auto"
      }),
      style: {
        top: p.cy,
        left: p.cx,
        height: p.height
      }
    }
  ),
  /* @__PURE__ */ jsx(
    Handle,
    {
      id: p.id,
      type: p.type,
      position: positionMap[p.position],
      style: {
        top: p.cy - 3,
        left: p.cx - 3,
        width: 6,
        height: 6,
        right: "unset",
        bottom: "unset",
        visibility: "hidden",
        transform: p.position === "left" ? "translate(-150%, 0)" : "translate(100%, 0)"
      }
    }
  )
] }), hasModelFqn$1 = (data) => e$8(data.modelFqn);
function SequenceActorNode(props) {
  const { enableElementDetails, enableCompareWithLatest } = useEnabledFeatures(), data = props.data, {
    id,
    positionAbsoluteY,
    data: {
      viewHeight,
      hovered: isHovered = !1,
      ports
    }
  } = props;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        "data-likec4-color": "gray",
        className: css({
          position: "absolute",
          rounded: "xs",
          top: "1",
          pointerEvents: "none",
          transition: "fast",
          translateX: "-1/2",
          translate: "auto"
        }),
        style: {
          backgroundColor: "var(--likec4-palette-stroke)",
          opacity: isHovered ? 0.6 : 0.4,
          left: "50%",
          width: isHovered ? 3 : 2,
          height: viewHeight - positionAbsoluteY,
          zIndex: -1,
          pointerEvents: "none"
        }
      }
    ),
    /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
      enableCompareWithLatest && /* @__PURE__ */ jsx(NodeDrifts, { nodeProps: props }),
      /* @__PURE__ */ jsx(ElementShape, { ...props }),
      /* @__PURE__ */ jsx(ElementData, { ...props }),
      hasModelFqn$1(data) && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(ElementActions$2, { ...props, data }),
        enableElementDetails && /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$2, { id, data })
      ] })
    ] }),
    ports.map((p) => /* @__PURE__ */ jsx(ActorStepPort, { port: p, data: props.data }, p.id))
  ] });
}
function SequenceParallelArea(props) {
  return /* @__PURE__ */ jsx(
    Box,
    {
      "data-likec4-color": props.data.color,
      css: {
        width: "100%",
        height: "100%",
        border: "default",
        rounded: "sm",
        borderWidth: 1,
        "--_color": {
          base: "var(--likec4-palette-stroke)",
          _dark: "[color-mix(in oklab, var(--likec4-palette-hiContrast) 40%, var(--likec4-palette-fill))]"
        },
        borderColor: "[var(--_color)/30]",
        backgroundColor: "var(--likec4-palette-fill)/15",
        pointerEvents: "none",
        paddingLeft: "2",
        paddingTop: "0.5",
        fontSize: "xs",
        fontWeight: "bold",
        letterSpacing: ".75px",
        color: "[var(--_color)/75]"
      },
      children: "PARALLEL"
    }
  );
}
const backdropBlur$1 = "--_blur", backdropOpacity$1 = "--_opacity", cssVarLevel = "--_level", Overlay = forwardRef(({
  onClose,
  className,
  classes: classes2,
  overlayLevel = 0,
  children,
  fullscreen = !1,
  withBackdrop = !0,
  backdrop,
  openDelay = 130,
  ...rest
}, ref) => {
  const [opened, setOpened] = useState(openDelay === 0), focusTrapRef = useFocusTrap(opened), dialogRef = useRef(null), isClosingRef = useRef(!1), motionNotReduced = useReducedMotionConfig() !== !0, onCloseRef = useRef(onClose);
  onCloseRef.current = onClose;
  const close = useDebouncedCallback(
    () => {
      isClosingRef.current || (isClosingRef.current = !0, onCloseRef.current());
    },
    [],
    50
  );
  useLayoutEffect(() => {
    dialogRef.current?.open || dialogRef.current?.showModal();
  }, []), useTimeoutEffect(() => {
    setOpened(!0);
  }, openDelay > 0 ? openDelay : void 0);
  const overlayRecipe = overlay({
    fullscreen,
    withBackdrop
  });
  let targetBackdropOpacity = overlayLevel > 0 ? "50%" : "60%";
  return backdrop?.opacity !== void 0 && (targetBackdropOpacity = `${backdrop.opacity * 100}%`), /* @__PURE__ */ jsx(
    m.dialog,
    {
      ref: useMergedRef(
        dialogRef,
        focusTrapRef,
        ref
      ),
      className: cx(
        classes2?.dialog,
        className,
        overlayRecipe,
        // styles.dialog,
        fullscreen && ReactRemoveScroll.classNames.fullWidth
      ),
      layout: !0,
      style: {
        // @ts-ignore
        [cssVarLevel]: overlayLevel
      },
      ...motionNotReduced ? {
        initial: {
          [backdropBlur$1]: "0px",
          [backdropOpacity$1]: "0%",
          scale: 0.85,
          // originY: 0.4,
          // translateY: -10,
          opacity: 0
        },
        animate: {
          [backdropBlur$1]: overlayLevel > 0 ? "4px" : "8px",
          [backdropOpacity$1]: targetBackdropOpacity,
          scale: 1,
          opacity: 1,
          translateY: 0
          // transition: {
          //   delay: 0.075,
          // },
        },
        exit: {
          opacity: 0,
          scale: 0.98,
          translateY: -20,
          // transition: {
          //   duration: 0.1,
          // },
          [backdropBlur$1]: "0px",
          [backdropOpacity$1]: "0%"
        }
      } : {
        initial: {
          [backdropBlur$1]: "8px",
          [backdropOpacity$1]: targetBackdropOpacity
        }
      },
      onClick: (e2) => {
        if (e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG") {
          dialogRef.current?.close();
          return;
        }
      },
      onCancel: (e2) => {
        e2.preventDefault(), e2.stopPropagation(), close();
      },
      onDoubleClick: stopPropagation,
      onPointerDown: stopPropagation,
      onClose: (e2) => {
        e2.stopPropagation(), close();
      },
      ...rest,
      children: /* @__PURE__ */ jsx(ReactRemoveScroll, { forwardProps: !0, children: /* @__PURE__ */ jsx(
        "div",
        {
          className: cx(
            classes2?.body,
            "likec4-overlay-body"
          ),
          children: opened && /* @__PURE__ */ jsx(Fragment, { children })
        }
      ) })
    }
  );
});
Overlay.displayName = "Overlay";
function PortalToContainer({ children }) {
  const ctx = useContext(RootContainerContext);
  if (!ctx)
    throw new Error("PortalToContainer must be used within RootContainer");
  return /* @__PURE__ */ jsx(Portal, { target: ctx.ref.current ?? `#${ctx.id}`, children });
}
const ProjectsMenu = memo$1((_) => {
  const { projects, onProjectChange } = useLikeC4ProjectsContext(), projectId = useLikeC4ProjectId();
  return projects.length <= 1 ? null : /* @__PURE__ */ jsxs(HStack, { gap: "0.5", alignItems: "baseline", children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        css: {
          fontWeight: "400",
          fontSize: "xxs",
          color: "likec4.panel.text.dimmed",
          userSelect: "none"
        },
        children: "Project"
      }
    ),
    /* @__PURE__ */ jsxs(
      Menu,
      {
        withinPortal: !1,
        shadow: "md",
        position: "bottom-start",
        offset: { mainAxis: 2 },
        children: [
          /* @__PURE__ */ jsx(MenuTarget, { children: /* @__PURE__ */ jsx(
            Button,
            {
              tabIndex: -1,
              autoFocus: !1,
              variant: "subtle",
              size: "compact-xs",
              color: "gray",
              classNames: {
                root: css({
                  fontWeight: "400",
                  fontSize: "xxs",
                  height: "auto",
                  lineHeight: 1.1,
                  color: {
                    _light: "mantine.colors.gray[9]"
                  }
                }),
                section: css({
                  '&:is([data-position="right"])': {
                    marginInlineStart: "1"
                  }
                })
              },
              rightSection: /* @__PURE__ */ jsx(IconChevronDown, { opacity: 0.5, size: 12, stroke: 1.5 }),
              children: projectId
            }
          ) }),
          /* @__PURE__ */ jsx(MenuDropdown, { children: projects.map(({ id, title: title2 }) => /* @__PURE__ */ jsx(
            MenuItem,
            {
              onClick: (e2) => {
                if (projectId === id) {
                  e2.stopPropagation();
                  return;
                }
                onProjectChange(id);
              },
              children: title2 ?? id
            },
            id
          )) })
        ]
      }
    )
  ] });
}), scopedKeydownHandler = createScopedKeydownHandler({
  siblingSelector: "[data-likec4-focusable]",
  parentSelector: "[data-likec4-breadcrumbs-dropdown]",
  activateOnFocus: !1,
  loop: !0,
  orientation: "vertical"
});
function hasSearchQuerySelector(s) {
  return s.context.searchQuery.trim().length >= 2;
}
const NavigationPanelDropdown = memo$1(() => {
  const actor = useNavigationActor(), hasSearchQuery = useNavigationActorSnapshot(hasSearchQuerySelector);
  useOnDiagramEvent("paneClick", () => {
    actor.closeDropdown();
  }), useOnDiagramEvent("nodeClick", () => {
    actor.closeDropdown();
  }), useOnDiagramEvent("edgeClick", () => {
    actor.closeDropdown();
  });
  const setSearchQuery = useThrottledCallback((value) => {
    actor.send({ type: "searchQuery.change", value });
  }, 250);
  return /* @__PURE__ */ jsxs(
    PopoverDropdown,
    {
      className: cx(
        "nowheel",
        vstack({
          layerStyle: "likec4.dropdown",
          gap: "xs",
          pointerEvents: "all"
        })
      ),
      "data-likec4-breadcrumbs-dropdown": !0,
      onMouseLeave: () => actor.send({ type: "dropdown.mouseLeave" }),
      onMouseEnter: () => actor.send({ type: "dropdown.mouseEnter" }),
      children: [
        /* @__PURE__ */ jsx(ProjectsMenu, {}),
        /* @__PURE__ */ jsx(HStack, { gap: "xs", children: /* @__PURE__ */ jsx(
          SearchInput,
          {
            defaultValue: actor.actorRef.getSnapshot().context.searchQuery,
            onChange: setSearchQuery
          }
        ) }),
        /* @__PURE__ */ jsx(
          ScrollAreaAutosize,
          {
            scrollbars: "x",
            type: "auto",
            offsetScrollbars: "present",
            classNames: {
              root: css({
                maxWidth: [
                  "calc(100vw - 50px)",
                  "calc(100cqw - 50px)"
                ]
              })
            },
            styles: {
              viewport: {
                overscrollBehavior: "none"
              }
            },
            children: hasSearchQuery ? /* @__PURE__ */ jsx(SearchResults, {}) : /* @__PURE__ */ jsx(FolderColumns, {})
          }
        )
      ]
    }
  );
});
NavigationPanelDropdown.displayName = "NavigationPanelDropdown";
function selectSearchQuery(s) {
  return normalizeViewPath(s.context.searchQuery);
}
const compare = compareNaturalHierarchically(VIEW_FOLDERS_SEPARATOR), SearchResults = memo$1(() => {
  const likec4model = useLikeC4Model(), actor = useNavigationActor(), searchQuery = useSelector(actor.actorRef, selectSearchQuery), deferredSearchQuery = useDeferredValue(searchQuery), isSearchByPath = deferredSearchQuery.includes(VIEW_FOLDERS_SEPARATOR), highlight = isSearchByPath ? deferredSearchQuery.split(VIEW_FOLDERS_SEPARATOR) : deferredSearchQuery, [found, setFound] = useState([]);
  return useEffect(() => {
    setFound((current) => {
      const results = t$6(
        likec4model.views(),
        ifilter((v) => isSearchByPath && v.$view.title ? normalizeViewPath(v.$view.title).toLowerCase().includes(deferredSearchQuery) : v.id.toLowerCase().includes(deferredSearchQuery) || !!v.title?.toLowerCase().includes(deferredSearchQuery)),
        ifirst(20),
        toArray(),
        t$k((a, b) => compare(a.folder.path, b.folder.path))
      );
      return shallowEqual(results, current) ? current : results;
    });
  }, [likec4model, deferredSearchQuery, isSearchByPath]), found.length === 0 ? /* @__PURE__ */ jsx("div", { children: "no results" }) : /* @__PURE__ */ jsx(
    ScrollAreaAutosize,
    {
      scrollbars: "xy",
      offsetScrollbars: !1,
      className: css({
        width: "100%",
        maxWidth: [
          "calc(100vw - 250px)",
          "calc(100cqw - 250px)"
        ],
        maxHeight: [
          "calc(100vh - 200px)",
          "calc(100cqh - 200px)"
        ]
      }),
      children: /* @__PURE__ */ jsx(VStack, { gap: "0.5", children: found.map((v) => /* @__PURE__ */ jsx(
        FoundedView,
        {
          view: v,
          highlight,
          onClick: (e2) => {
            e2.stopPropagation(), actor.selectView(v.id);
          },
          "data-likec4-focusable": !0,
          onKeyDown: scopedKeydownHandler
        },
        v.id
      )) })
    }
  );
}), foundedViewClass = hstack({
  gap: "xxs",
  rounded: "sm",
  px: "xs",
  py: "xxs",
  _hover: {
    backgroundColor: {
      base: "mantine.colors.gray[1]",
      _dark: "mantine.colors.dark[5]"
    }
  },
  _focus: {
    outline: "none",
    color: "mantine.colors.primary.lightColor!",
    backgroundColor: "mantine.colors.primary.lightHover!"
  }
}), inheritColor = css({
  _groupFocus: {
    color: "[inherit!]",
    transition: "none"
  }
});
function FoundedView({ view, highlight, ...props }) {
  const folder = view.folder, viewIcon = ViewTypeIcon[view.id === "index" ? "index" : view._type], viewLabel = /* @__PURE__ */ jsx(
    Highlight,
    {
      component: "div",
      className: cx(
        inheritColor,
        breadcrumbTitle({ truncate: !0 }),
        css({
          "& > mark": {
            backgroundColor: {
              base: "mantine.colors.yellow[2]/90",
              _dark: "mantine.colors.yellow[5]/80",
              _groupFocus: "[transparent]"
            },
            color: {
              _groupFocus: "[inherit!]"
            }
          }
        })
      ),
      maw: 350,
      highlight,
      children: view.title ?? view.id
    },
    view.id
  ), className = cx(
    props.className,
    "group",
    foundedViewClass
  );
  if (folder.isRoot)
    return /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        ...props,
        className,
        children: [
          viewIcon,
          viewLabel
        ]
      }
    );
  const breadcrumbs = folder.breadcrumbs.map((b) => /* @__PURE__ */ jsx(
    Highlight,
    {
      component: "div",
      className: cx(
        css({
          _groupHover: {
            color: "mantine.colors.dimmed"
          }
        }),
        inheritColor,
        breadcrumbTitle({ dimmed: !0, truncate: !0 })
      ),
      maw: 170,
      highlight: e(highlight) ? highlight : [],
      children: b.title
    },
    b.path
  ));
  return breadcrumbs.push(
    /* @__PURE__ */ jsxs(HStack, { gap: "[4px]", children: [
      viewIcon,
      viewLabel
    ] })
  ), /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...props,
      className,
      children: [
        folderIcon,
        /* @__PURE__ */ jsx(Breadcrumbs, { separator: /* @__PURE__ */ jsx(IconChevronRight, { size: 12, stroke: 1.5 }), separatorMargin: 3, children: breadcrumbs })
      ]
    }
  );
}
const btnRightSection = /* @__PURE__ */ jsx(IconChevronRight, { size: 12, stroke: 1.5, className: "mantine-rotate-rtl" }), folderIcon = /* @__PURE__ */ jsx(
  IconFolderFilled,
  {
    size: 16,
    className: css({
      opacity: {
        base: 0.3,
        _groupHover: 0.5,
        _groupActive: 0.5,
        _groupFocus: 0.5
      }
    })
  }
), viewTypeIconCss = css({
  opacity: {
    base: 0.3,
    _dark: 0.5,
    _groupHover: 0.8,
    _groupActive: 0.8,
    _groupFocus: 0.8
  }
}), ViewTypeIcon = {
  index: /* @__PURE__ */ jsx(IconStarFilled, { size: 16, className: viewTypeIconCss }),
  element: /* @__PURE__ */ jsx(
    IconZoomScan,
    {
      size: 18,
      stroke: 2,
      className: viewTypeIconCss
    }
  ),
  deployment: /* @__PURE__ */ jsx(IconStack2, { size: 16, stroke: 1.5, className: viewTypeIconCss }),
  dynamic: /* @__PURE__ */ jsx(IconDirectionSignFilled, { size: 18, className: viewTypeIconCss })
}, ColumnScrollArea = ScrollAreaAutosize.withProps({
  scrollbars: "y",
  className: css({
    maxHeight: [
      "calc(100vh - 160px)",
      "calc(100cqh - 160px)"
    ]
  })
});
function folderColumn(folder, context2) {
  return {
    folderPath: folder.path,
    items: [
      ...folder.folders.map((s) => ({
        type: "folder",
        folderPath: s.path,
        title: s.title,
        selected: context2.selectedFolder.startsWith(s.path)
      })),
      ...folder.views.map((s) => ({
        type: "view",
        viewType: s.id === "index" ? "index" : s._type,
        viewId: s.id,
        title: s.title ?? s.id,
        description: s.description.nonEmpty && s.description.text || null,
        selected: s.id === context2.viewModel?.id
      }))
    ]
  };
}
const selectColumns = (context2) => {
  const viewModel = context2.viewModel;
  if (!viewModel)
    return [];
  const likec4model = viewModel.$model, columns = [
    folderColumn(likec4model.rootViewFolder, context2)
  ], folder = likec4model.viewFolder(context2.selectedFolder);
  if (!folder.isRoot)
    for (const b of folder.breadcrumbs)
      columns.push(folderColumn(b, context2));
  return columns;
}, FolderColumns = memo$1(() => {
  const columns = useNavigationActorContext(selectColumns, deepEqual);
  return /* @__PURE__ */ jsx(HStack, { gap: "xs", alignItems: "stretch", children: columns.flatMap((column, i) => [
    i > 0 && /* @__PURE__ */ jsx(Divider$2, { orientation: "vertical" }, "divider" + i),
    /* @__PURE__ */ jsx(
      FolderColumn,
      {
        data: column,
        isLast: i > 0 && i == columns.length - 1
      },
      column.folderPath
    )
  ]) });
});
function FolderColumn({ data, isLast }) {
  const ref = useRef(null), actor = useNavigationActorRef(), onItemClicked = (item) => (e2) => {
    e2.stopPropagation(), item.type === "folder" ? actor.send({ type: "select.folder", folderPath: item.folderPath }) : actor.send({ type: "select.view", viewId: item.viewId });
  };
  return useMountEffect(() => {
    isLast && ref.current && ref.current.scrollIntoView({
      block: "nearest",
      inline: "nearest",
      behavior: "smooth"
    });
  }), /* @__PURE__ */ jsx(Box, { mb: "1", ref, children: /* @__PURE__ */ jsx(ColumnScrollArea, { children: /* @__PURE__ */ jsx(VStack, { gap: "0.5", children: data.items.map((item, i) => /* @__PURE__ */ jsx(
    FolderColumnItem,
    {
      columnItem: item,
      onClick: onItemClicked(item)
    },
    `${data.folderPath}/${item.type}/${i}`
  )) }) }) });
}
function FolderColumnItem({ columnItem, ...props }) {
  switch (columnItem.type) {
    case "folder":
      return /* @__PURE__ */ jsx(
        NavigationLink,
        {
          variant: "light",
          active: columnItem.selected,
          label: columnItem.title,
          leftSection: folderIcon,
          rightSection: btnRightSection,
          maw: "300px",
          miw: "200px",
          ...props
        },
        columnItem.folderPath
      );
    case "view":
      return /* @__PURE__ */ jsx(
        NavigationLink,
        {
          variant: "filled",
          active: columnItem.selected,
          label: columnItem.title,
          description: columnItem.description,
          leftSection: ViewTypeIcon[columnItem.viewType],
          maw: "300px",
          miw: "200px",
          ...props
        },
        columnItem.viewId
      );
    default:
      nonexhaustive$1(columnItem);
  }
}
function SearchInput(props) {
  const [_value, handleChange] = useUncontrolled({
    ...props,
    finalValue: ""
  });
  return /* @__PURE__ */ jsx(
    Input,
    {
      size: "xs",
      placeholder: "Search by title or id",
      variant: "unstyled",
      height: rem(26),
      value: _value,
      onKeyDown: scopedKeydownHandler,
      onChange: (e2) => handleChange(e2.currentTarget.value),
      "data-likec4-focusable": !0,
      classNames: {
        wrapper: css({
          flexGrow: 1,
          backgroundColor: {
            base: "mantine.colors.gray[1]",
            _dark: "mantine.colors.dark[5]/80",
            _hover: {
              base: "mantine.colors.gray[2]",
              _dark: "mantine.colors.dark[4]"
            },
            _focus: {
              base: "mantine.colors.gray[2]",
              _dark: "mantine.colors.dark[4]"
            }
          },
          rounded: "sm"
        }),
        input: css({
          _placeholder: {
            color: "mantine.colors.dimmed"
          },
          _focus: {
            outline: "none"
          }
        })
      },
      style: {
        "--input-fz": "var(--mantine-font-size-sm)"
      },
      leftSection: /* @__PURE__ */ jsx(IconSearch, { size: 14 }),
      rightSectionPointerEvents: "all",
      rightSectionWidth: "min-content",
      rightSection: !props.value || e$3(props.value) ? null : /* @__PURE__ */ jsx(
        Button,
        {
          variant: "subtle",
          h: "100%",
          size: "compact-xs",
          color: "gray",
          onClick: (e2) => {
            e2.stopPropagation(), handleChange("");
          },
          children: "clear"
        }
      )
    }
  );
}
const SectionHeader = styled("div", {
  base: {
    fontSize: "xs",
    color: "mantine.colors.dimmed",
    fontWeight: 500,
    userSelect: "none",
    mb: "xxs"
  }
});
function selectWalkthroughNotes(s) {
  const isActive = e$a(s.activeWalkthrough), activeStepIndex = isActive ? s.xyedges.findIndex((e2) => e2.id === s.activeWalkthrough?.stepId) : -1;
  return {
    isActive,
    isParallel: isActive && e$8(s.activeWalkthrough?.parallelPrefix),
    hasNext: isActive && activeStepIndex < s.xyedges.length - 1,
    hasPrevious: isActive && activeStepIndex > 0,
    notes: isActive ? s.xyedges[activeStepIndex]?.data?.notes ?? null : null
  };
}
const WalkthroughPanel = memo$1(() => {
  const { isActive, notes: _notes } = useDiagramContext(selectWalkthroughNotes), notes = _notes ? RichText$1.from(_notes) : RichText$1.EMPTY;
  return /* @__PURE__ */ jsx(AnimatePresence, { children: isActive && !notes.isEmpty && /* @__PURE__ */ jsx(
    m.div,
    {
      layout: "position",
      className: css({
        position: "relative"
      }),
      initial: {
        opacity: 0,
        translateX: -20
      },
      animate: {
        opacity: 1,
        translateX: 0
      },
      exit: {
        opacity: 0,
        translateX: -20
      },
      children: /* @__PURE__ */ jsxs(
        ScrollAreaAutosize,
        {
          className: vstack({
            position: "absolute",
            layerStyle: "likec4.dropdown",
            gap: "sm",
            padding: "md",
            paddingTop: "xxs",
            pointerEvents: "all",
            maxWidth: "calc(100cqw - 32px)",
            minWidth: "calc(100cqw - 50px)",
            maxHeight: "calc(100cqh - 100px)",
            width: "max-content",
            cursor: "default",
            overflow: "auto",
            overscrollBehavior: "contain",
            "@/sm": {
              minWidth: 400,
              maxWidth: 550
            },
            "@/lg": {
              maxWidth: 700
            }
          }),
          type: "scroll",
          children: [
            /* @__PURE__ */ jsx(SectionHeader, { children: "Notes" }),
            /* @__PURE__ */ jsx(
              Markdown,
              {
                value: notes,
                fontSize: "sm",
                emptyText: "No description",
                className: css({
                  userSelect: "all"
                })
              }
            )
          ]
        }
      )
    }
  ) });
}), NavigationPanel$1 = memo$1(() => {
  const diagram = useDiagram(), view = useCurrentView(), viewModel = useOptionalCurrentViewModel(), actorRef = useActorRef(
    navigationPanelActorLogic,
    {
      input: {
        view,
        viewModel
      }
    }
  );
  return useEffect(() => {
    const subscription = actorRef.on("navigateTo", (event) => {
      diagram.navigateTo(event.viewId);
    });
    return () => subscription.unsubscribe();
  }, [actorRef, diagram]), useEffect(() => {
    actorRef.send({ type: "update.inputs", inputs: { viewModel, view } });
  }, [viewModel, view]), /* @__PURE__ */ jsx(
    VStack,
    {
      css: {
        alignItems: "flex-start",
        pointerEvents: "none",
        position: "absolute",
        top: "0",
        left: "0",
        margin: "0",
        width: "100%",
        gap: "xxs",
        maxWidth: [
          "calc(100vw)",
          "calc(100cqw)"
        ],
        "@/sm": {
          margin: "xs",
          gap: "xs",
          width: "max-content",
          maxWidth: [
            "calc(100vw - 2 * {spacing.md})",
            "calc(100cqw - 2 * {spacing.md})"
          ]
        },
        _print: {
          display: "none"
        }
      },
      children: /* @__PURE__ */ jsxs(NavigationPanelActorContextProvider, { value: actorRef, children: [
        /* @__PURE__ */ jsx(NavigationPanelImpl, { actor: actorRef }),
        /* @__PURE__ */ jsx(ComparePanel, {}),
        /* @__PURE__ */ jsx(WalkthroughPanel, {}),
        /* @__PURE__ */ jsx(EditorPanel, {})
      ] })
    }
  );
});
NavigationPanel$1.displayName = "NavigationPanel";
const NavigationPanelImpl = ({ actor }) => {
  const opened = useSelector(actor, (s) => s.hasTag("active")), portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(
    Popover,
    {
      offset: {
        mainAxis: 4
      },
      opened,
      position: "bottom-start",
      trapFocus: opened,
      ...portalProps,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onDismiss: () => actor.send({ type: "dropdown.dismiss" }),
      children: [
        /* @__PURE__ */ jsx(NavigationPanelPopoverTarget, { actor }),
        opened && /* @__PURE__ */ jsx(NavigationPanelDropdown, {})
      ]
    }
  );
}, NavigationPanelPopoverTarget = ({ actor }) => {
  const isActiveWalkthrough = useDiagramContext((c) => c.activeWalkthrough !== null);
  return /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
    MotionDiv,
    {
      layout: !0,
      layoutDependency: isActiveWalkthrough,
      className: hstack({
        layerStyle: "likec4.panel",
        position: "relative",
        gap: "xs",
        cursor: "pointer",
        pointerEvents: "all",
        width: "100%"
      }),
      onMouseLeave: () => actor.send({ type: "breadcrumbs.mouseLeave" }),
      children: /* @__PURE__ */ jsx(AnimatePresence, { children: isActiveWalkthrough ? /* @__PURE__ */ jsx(ActiveWalkthroughControls, {}) : /* @__PURE__ */ jsx(NavigationPanelControls, {}) })
    }
  ) }) });
}, ElementDetailsActorContext = createContext(null);
ElementDetailsActorContext.displayName = "ElementDetailsActorContext";
const useElementDetailsActorRef = () => {
  const ctx = useContext(ElementDetailsActorContext);
  if (ctx === null)
    throw new Error("ElementDetailsActorRef is not provided");
  return ctx;
}, backdropBlur = "--_blur", backdropOpacity = "--_opacity", dialog$1 = css({
  boxSizing: "border-box",
  margin: "0",
  padding: "0",
  position: "fixed",
  inset: "0",
  width: "100vw",
  height: "100vh",
  maxWidth: "100vw",
  maxHeight: "100vh",
  background: "transparent",
  border: "transparent",
  _backdrop: {
    // WebkitBackdropFilter: `blur(${backdropBlur})`,
    backdropFilter: "auto",
    backdropBlur: `var(${backdropBlur})`,
    backgroundColor: `[rgb(36 36 36 / var(${backdropOpacity}, 5%))]`
  }
}), card$1 = css({
  position: "absolute",
  pointerEvents: "all",
  display: "flex",
  flexDirection: "column",
  padding: "4",
  gap: "lg",
  justifyContent: "stretch",
  color: "mantine.colors.text",
  boxShadow: "md",
  overflow: "hidden",
  border: "none",
  background: `[
    linear-gradient(180deg,
    color-mix(in oklab, var(--likec4-palette-fill) 60%, transparent),
    color-mix(in oklab, var(--likec4-palette-fill) 20%, transparent) 8px,
    color-mix(in oklab, var(--likec4-palette-fill) 14%, transparent) 20px,
    transparent 80px
    ),
    linear-gradient(180deg, var(--likec4-palette-fill), var(--likec4-palette-fill) 4px, transparent 4px),
    {colors.likec4.overlay.body}
  ]`,
  "& .react-flow__attribution": {
    display: "none"
  }
}), cardHeader = css({
  flex: 0,
  cursor: "move"
}), title$2 = css({
  display: "block",
  fontFamily: "likec4.element",
  fontOpticalSizing: "auto",
  fontStyle: "normal",
  fontWeight: 600,
  fontSize: "24px",
  // lineHeight: 1.15,
  lineHeight: "xs"
  // color: vars.element.hiContrast
}), iconSize$1 = "40px", elementIcon$1 = css({
  flex: `0 0 ${iconSize$1}`,
  height: iconSize$1,
  width: iconSize$1,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  alignSelf: "flex-start",
  cursor: "move",
  _dark: {
    mixBlendMode: "hard-light"
  },
  "& :where(svg, img)": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none",
    filter: `
    drop-shadow(0 0 3px rgb(0 0 0 / 10%))
    drop-shadow(0 1px 8px rgb(0 0 0 / 5%))
    drop-shadow(1px 1px 16px rgb(0 0 0 / 2%))
  `
  },
  "& img": {
    objectFit: "contain"
  }
}), viewTitleColor = "--view-title-color", iconColor = "--icon-color", viewButton$1 = css({
  // display: 'flex',
  width: "100%",
  background: "mantine.colors.body",
  borderRadius: "sm",
  padding: "[10px 8px]",
  // gap: 6,
  // alignItems: 'flex-start',
  transition: "fast",
  border: "1px dashed",
  borderColor: "mantine.colors.defaultBorder",
  [viewTitleColor]: "{colors.mantine.colors.dark[1]}",
  _hover: {
    background: "mantine.colors.defaultHover",
    [iconColor]: "{colors.mantine.colors.dark[1]}",
    [viewTitleColor]: "{colors.mantine.colors.defaultColor}"
  },
  _dark: {
    background: "mantine.colors.dark[6]"
  },
  _light: {
    [iconColor]: "{colors.mantine.colors.gray[6]}",
    [viewTitleColor]: "{colors.mantine.colors.gray[7]}",
    _hover: {
      [iconColor]: "{colors.mantine.colors.gray[7]}"
    }
  },
  "& .mantine-ThemeIcon-root": {
    transition: "fast",
    // color: fallbackVar(iconColor, 'mantine.colors.dark[2])',
    color: `[var(${iconColor}, {colors.mantine.colors.dark[2]})]`,
    "--ti-size": "22px",
    _hover: {
      color: "mantine.colors.defaultColor"
    }
  },
  "& > *": {
    transition: "all 130ms {easings.inOut}"
  },
  "&:hover > *": {
    transitionTimingFunction: "out",
    transform: "translateX(1.6px)"
  }
}), viewButtonTitle = css({
  transition: "fast",
  color: `[var(${viewTitleColor}, {colors.mantine.colors.gray[7]})]`,
  fontSize: "15px",
  fontWeight: 500,
  lineHeight: "1.4"
}), tabsRoot = css({
  flex: 1,
  display: "flex",
  flexDirection: "column",
  justifyContent: "stretch",
  overflow: "hidden",
  gap: "sm"
}), tabsList = css({
  // flex: '0',
  background: "mantine.colors.gray[1]",
  borderRadius: "sm",
  flexWrap: "nowrap",
  gap: "1.5",
  // 6px
  padding: "1",
  _dark: {
    background: "mantine.colors.dark[7]"
  }
}), tabsTab = css({
  fontSize: "xs",
  fontWeight: 500,
  flexGrow: 1,
  padding: "[6px 8px]",
  transition: "fast",
  borderRadius: "sm",
  color: "mantine.colors.gray[7]",
  _hover: {
    transitionTimingFunction: "out",
    color: "mantine.colors.defaultColor",
    background: "mantine.colors.gray[3]"
  },
  "&[data-active]": {
    transition: "none",
    background: "mantine.colors.white",
    shadow: "xs",
    color: "mantine.colors.defaultColor"
  },
  _dark: {
    color: "mantine.colors.dark[1]",
    _hover: {
      color: "mantine.colors.white",
      background: "mantine.colors.dark[6]"
    },
    "&:is([data-active])": {
      color: "mantine.colors.white",
      background: "mantine.colors.dark[5]"
    }
  }
}), tabsPanel = css({
  flex: 1,
  overflow: "hidden",
  position: "relative",
  "&:not(:has(.mantine-ScrollArea-root))": {
    paddingLeft: "1",
    paddingRight: "1"
  },
  "& .mantine-ScrollArea-root": {
    width: "100%",
    height: "100%",
    "& > div": {
      paddingLeft: "1",
      paddingRight: "1"
    }
  }
}), propertiesGrid = css({
  flex: 1,
  display: "grid",
  gridTemplateColumns: "min-content 1fr",
  gridAutoRows: "min-content max-content",
  gap: "[24px 20px]",
  alignItems: "baseline",
  justifyItems: "stretch"
}), propertyLabel = css({
  justifySelf: "end",
  textAlign: "right",
  userSelect: "none"
}), resizeHandle = css({
  position: "absolute",
  width: "14px",
  height: "14px",
  border: "3.5px solid",
  borderColor: "mantine.colors.dark[3]",
  borderTop: "none",
  borderLeft: "none",
  borderRadius: "2px",
  bottom: "0.5",
  right: "0.5",
  transition: "fast",
  cursor: "se-resize",
  _hover: {
    borderWidth: "4px",
    borderColor: "mantine.colors.dark[1]"
  }
});
function MetadataProvider({ children }) {
  return /* @__PURE__ */ jsx(Fragment, { children });
}
function TruncatedValue({ value, isExpanded }) {
  const [isTruncated, setIsTruncated] = useState(!1), textRef = useRef(null);
  return useEffect(() => {
    textRef.current && setIsTruncated(textRef.current.scrollWidth > textRef.current.clientWidth);
  }, [value]), /* @__PURE__ */ jsx(
    Tooltip$6,
    {
      label: isTruncated && !isExpanded ? value : null,
      multiline: !0,
      w: 300,
      withinPortal: !0,
      children: /* @__PURE__ */ jsx(
        Text,
        {
          ref: textRef,
          component: "div",
          className: css({
            fontSize: "sm",
            padding: "xs",
            userSelect: "all",
            color: "mantine.colors.text",
            lineHeight: 1.4,
            whiteSpace: isExpanded ? "pre-wrap" : "nowrap",
            overflow: isExpanded ? "visible" : "hidden",
            textOverflow: isExpanded ? "unset" : "ellipsis",
            wordBreak: isExpanded ? "break-word" : "normal",
            minWidth: 0,
            width: "100%"
          }),
          children: value
        }
      )
    }
  );
}
function MultiValueDisplay({
  values,
  isExpanded
}) {
  return isExpanded ? /* @__PURE__ */ jsx(Stack, { gap: "xs", children: values.map((value, index2) => /* @__PURE__ */ jsxs(Flex, { align: "center", gap: "xs", children: [
    /* @__PURE__ */ jsx(
      Text,
      {
        className: css({
          fontSize: "xs",
          color: "mantine.colors.gray[5]",
          fontWeight: 500,
          flexShrink: 0,
          _dark: {
            color: "mantine.colors.dark[3]"
          }
        }),
        children: ""
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: css({
          minHeight: "32px",
          display: "flex",
          alignItems: "center",
          flex: 1
        }),
        children: /* @__PURE__ */ jsx(TruncatedValue, { value, isExpanded: !0 })
      }
    )
  ] }, index2)) }) : /* @__PURE__ */ jsx(
    Box$1,
    {
      className: css({
        minHeight: "32px",
        display: "flex",
        alignItems: "center",
        padding: "xs",
        gap: "xs",
        flexWrap: "wrap",
        minWidth: 0,
        // Allow shrinking
        overflow: "hidden"
        // Prevent overflow
      }),
      children: values.map((value, index2) => /* @__PURE__ */ jsxs(Flex, { align: "center", gap: "xs", style: { minWidth: 0 }, children: [
        /* @__PURE__ */ jsx(
          Text,
          {
            className: css({
              fontSize: "sm",
              padding: "[4px 8px]",
              backgroundColor: "mantine.colors.white",
              color: "mantine.colors.text",
              borderRadius: "sm",
              border: "1px solid",
              borderColor: "mantine.colors.gray[3]",
              whiteSpace: "nowrap",
              overflow: "hidden",
              textOverflow: "ellipsis",
              maxWidth: "min(200px, 100%)",
              minWidth: "60px",
              flex: "0 1 auto",
              userSelect: "all",
              _dark: {
                backgroundColor: "mantine.colors.dark[9]",
                color: "mantine.colors.text",
                borderColor: "mantine.colors.dark[4]"
              }
            }),
            title: value,
            children: value
          }
        ),
        index2 < values.length - 1 && /* @__PURE__ */ jsx(
          Text,
          {
            className: css({
              fontSize: "xs",
              color: "mantine.colors.gray[5]",
              fontWeight: 500,
              flexShrink: 0,
              _dark: {
                color: "mantine.colors.dark[3]"
              }
            }),
            children: ""
          }
        )
      ] }, index2))
    }
  );
}
function MetadataValue({ label: label2, value }) {
  const elements = Array.isArray(value) ? value : typeof value == "string" && value.includes(`
`) ? value.split(`
`).map((s) => s.trim()).filter(Boolean) : [value], hasMultipleElements = elements.length > 1, [isExpanded, setIsExpanded] = useState(!1);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    hasMultipleElements ? /* @__PURE__ */ jsx(
      UnstyledButton,
      {
        onClick: () => {
          setIsExpanded(!isExpanded);
        },
        className: css({
          fontSize: "xs",
          color: "mantine.colors.dimmed",
          justifySelf: "end",
          textAlign: "right",
          userSelect: "none",
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-end",
          gap: "xs",
          padding: "[4px 8px]",
          borderRadius: "sm",
          whiteSpace: "nowrap",
          transition: "all 150ms ease",
          _hover: {
            backgroundColor: "mantine.colors.gray[1]",
            color: "mantine.colors.primary[6]",
            _dark: {
              backgroundColor: "mantine.colors.dark[7]",
              color: "mantine.colors.primary[4]"
            }
          }
        }),
        children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: "xs", children: [
          /* @__PURE__ */ jsxs(Text, { component: "span", size: "xs", fw: 700, children: [
            label2,
            ":"
          ] }),
          /* @__PURE__ */ jsx(
            Text,
            {
              component: "span",
              className: css({
                fontSize: "xs",
                fontWeight: 500,
                color: "mantine.colors.gray[6]",
                backgroundColor: "mantine.colors.gray[1]",
                padding: "[1px 4px]",
                borderRadius: "xs",
                _dark: {
                  color: "mantine.colors.dark[2]",
                  backgroundColor: "mantine.colors.dark[6]"
                }
              }),
              children: elements.length
            }
          ),
          isExpanded ? /* @__PURE__ */ jsx(IconChevronDown, { size: 12 }) : /* @__PURE__ */ jsx(IconChevronRight, { size: 12 })
        ] })
      }
    ) : /* @__PURE__ */ jsxs(
      Text,
      {
        component: "div",
        className: css({
          fontSize: "xs",
          color: "mantine.colors.dimmed",
          justifySelf: "end",
          textAlign: "right",
          userSelect: "none",
          whiteSpace: "nowrap",
          padding: "[4px 8px]",
          fontWeight: 700
        }),
        children: [
          label2,
          ":"
        ]
      }
    ),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: css({
          justifySelf: "stretch",
          alignSelf: "start"
        }),
        children: hasMultipleElements ? /* @__PURE__ */ jsx(
          MultiValueDisplay,
          {
            values: elements,
            isExpanded
          }
        ) : /* @__PURE__ */ jsx(
          Box$1,
          {
            className: css({
              minHeight: "32px",
              display: "flex",
              alignItems: "center"
            }),
            children: /* @__PURE__ */ jsx(TruncatedValue, { value: elements[0] || "", isExpanded })
          }
        )
      }
    )
  ] });
}
const treeNode$1 = css({
  "&[data-level='1']": {
    marginBottom: "sm"
  }
}), treeNodeLabel$1 = css({
  cursor: "default",
  marginTop: "0",
  marginBottom: "0"
}), label$1 = css({
  transition: "fast",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.dark[1]"
  },
  "& > *": {
    transition: "fast"
  },
  _hover: {
    transitionTimingFunction: "out",
    "& > :not([data-no-transform])": {
      transitionTimingFunction: "out",
      transform: "translateX(1px)"
    }
  }
  //   '.mantine-Button-root:hover & > :not([data-no-transform])': {
  // transitionTimingFunction: 'out',
  //   transform: 'translateX(1px)',
  //   },
}), nodeLabel = cx(label$1), instanceLabel = cx(
  label$1,
  css({
    cursor: "pointer",
    width: "100%",
    justifyContent: "stretch",
    flexWrap: "nowrap",
    height: "36px",
    paddingInlineStart: "[16px]",
    paddingInlineEnd: "2.5",
    // 10px
    borderRadius: "sm",
    alignItems: "center",
    color: "mantine.colors.gray[7]",
    _dark: {
      color: "mantine.colors.gray.lightColor"
    },
    _hover: {
      background: "mantine.colors.gray.lightHover"
    },
    "& .tabler-icon": {
      transition: "fast",
      width: "90%",
      opacity: 0.65
    }
  })
), DeploymentNodeRenderer = ({
  node: node2
}) => /* @__PURE__ */ jsxs(Group, { className: nodeLabel, gap: 6, align: "baseline", wrap: "nowrap", children: [
  /* @__PURE__ */ jsxs(Text, { component: "div", fz: 11, c: "dimmed", children: [
    node2.kind,
    ":"
  ] }),
  /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", children: node2.title })
] }), DeployedInstanceRenderer = ({
  instance
}) => {
  const diagram = useDiagram(), currentViewId = diagram.currentView.id, views = [...instance.views()];
  return /* @__PURE__ */ jsxs(Group, { className: instanceLabel, gap: 4, children: [
    /* @__PURE__ */ jsx(ThemeIcon, { color: "gray", variant: "transparent", size: "xs", flex: 0, children: /* @__PURE__ */ jsx(IconTarget, { stroke: 1.2 }) }),
    /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", flex: "1 1 100%", children: instance.title }),
    /* @__PURE__ */ jsxs(Box$1, { onClick: stopPropagation, pos: "relative", "data-no-transform": !0, flex: 0, children: [
      views.length === 0 && /* @__PURE__ */ jsx(Button, { size: "compact-xs", variant: "transparent", color: "gray", disabled: !0, children: "no views" }),
      views.length > 0 && /* @__PURE__ */ jsxs(
        Menu,
        {
          shadow: "md",
          withinPortal: !1,
          position: "bottom-start",
          offset: 0,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          closeOnEscape: !0,
          trapFocus: !0,
          children: [
            /* @__PURE__ */ jsx(Menu.Target, { children: /* @__PURE__ */ jsxs(Button, { size: "compact-xs", variant: "subtle", color: "gray", children: [
              views.length,
              " view",
              views.length > 1 ? "s" : ""
            ] }) }),
            /* @__PURE__ */ jsx(Menu.Dropdown, { children: views.map((view) => /* @__PURE__ */ jsx(
              Menu.Item,
              {
                px: "xs",
                py: 4,
                disabled: view.id === currentViewId,
                leftSection: /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", color: "gray", children: /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8, opacity: 0.65 }) }),
                styles: {
                  itemSection: {
                    marginInlineEnd: rem(8)
                  }
                },
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.navigateTo(view.id);
                },
                children: view.title
              },
              view.id
            )) })
          ]
        }
      )
    ] })
  ] });
}, setHoveredNode$3 = () => {
}, TabPanelDeployments = memo$1(({ elementFqn }) => {
  const element = useLikeC4Model().element(elementFqn), deployments = [...element.deployments()], tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode$3;
  const data = useMemo(() => {
    let roots = [], treeItems = /* @__PURE__ */ new Map();
    for (const instance of element.deployments()) {
      let instanceNode = {
        label: /* @__PURE__ */ jsx(DeployedInstanceRenderer, { instance }),
        value: instance.id,
        type: "instance",
        children: []
      };
      treeItems.set(instance.id, instanceNode);
      let ancestor = instance.parent;
      for (; ancestor; ) {
        let ancestorNode = treeItems.get(ancestor.id);
        if (ancestorNode) {
          ancestorNode.children.push(instanceNode);
          break;
        }
        ancestorNode = {
          label: /* @__PURE__ */ jsx(DeploymentNodeRenderer, { node: ancestor }),
          value: ancestor.id,
          type: "node",
          children: [instanceNode]
        }, treeItems.set(ancestor.id, ancestorNode), instanceNode = ancestorNode, ancestor = ancestor.parent;
      }
      !ancestor && !roots.includes(instanceNode) && roots.push(instanceNode);
    }
    return roots;
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), deployments.length === 0 ? /* @__PURE__ */ jsx(Alert, { variant: "light", color: "gray", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: "This element does not have any deployments" }) : (
    // <Box></Box>
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "sm",
        allowRangeSelection: !1,
        classNames: {
          node: treeNode$1,
          label: treeNodeLabel$1
        },
        styles: {
          root: {
            position: "relative",
            width: "min-content",
            minWidth: 300
          }
        },
        data,
        tree,
        renderNode: ({ node: node2, selected, elementProps, hasChildren }) => /* @__PURE__ */ jsx(
          Box$1,
          {
            ...elementProps,
            style: {
              ...!hasChildren && {
                marginBottom: rem(4)
              }
            },
            children: hasChildren ? /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: !0,
                color: "gray",
                variant: selected ? "transparent" : "subtle",
                size: "xs",
                justify: "flex-start",
                styles: {
                  root: {
                    position: "unset",
                    paddingInlineStart: rem(16)
                  }
                },
                children: node2.label
              }
            ) : node2.label
          }
        )
      }
    )
  );
}), RelationshipsBrowserActorContext = createContext(null);
function useRelationshipsBrowserActor() {
  return nonNullable$1(useContext(RelationshipsBrowserActorContext), "No RelationshipsBrowserActorContext");
}
function useRelationshipsBrowserState(selector3, compare2 = shallowEqual) {
  const actor = useRelationshipsBrowserActor();
  return useSelector(actor, selector3, compare2);
}
function useRelationshipsBrowser() {
  const actor = useRelationshipsBrowserActor();
  return useMemo(() => ({
    actor,
    get rootElementId() {
      return `relationships-browser-${actor.sessionId.replaceAll(":", "_")}`;
    },
    getState: () => actor.getSnapshot().context,
    send: actor.send,
    updateView: (layouted) => {
      actor.getSnapshot().status === "active" && actor.send({
        type: "update.view",
        layouted
      });
    },
    changeScope: (scope) => {
      actor.send({
        type: "change.scope",
        scope
      });
    },
    navigateTo: (subject, fromNode) => {
      actor.send({
        type: "navigate.to",
        subject,
        fromNode
      });
    },
    fitDiagram: () => {
      actor.send({ type: "fitDiagram" });
    },
    close: () => {
      actor._parent ? actor._parent?.send({ type: "close", actorId: actor.id }) : actor.send({ type: "close" });
    }
  }), [actor]);
}
const RelationshipEdge$3 = memoEdge((props) => {
  const browser = useRelationshipsBrowser(), { enableNavigateTo } = useEnabledFeatures(), {
    data: {
      navigateTo,
      relations,
      existsInCurrentView
    }
  } = props, [svgPath, labelX, labelY] = getBezierPath(props), diagram = useDiagram(), markOrange = relations.length > 1 || !existsInCurrentView, edgeProps = markOrange ? {
    ...props,
    data: {
      ...props.data,
      color: "amber"
    }
  } : props;
  let label2 = /* @__PURE__ */ jsx(
    EdgeLabel,
    {
      edgeProps,
      className: css({
        transition: "fast"
      }),
      children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
        EdgeActionButton,
        {
          ...props,
          onClick: (e2) => {
            e2.stopPropagation(), diagram.navigateTo(navigateTo);
          }
        }
      )
    }
  );
  return existsInCurrentView || (label2 = /* @__PURE__ */ jsx(
    Tooltip$6,
    {
      color: "orange",
      c: "black",
      label: "This relationship is not included in the current view",
      portalProps: {
        target: `#${browser.rootElementId}`
      },
      openDelay: 800,
      children: label2
    }
  )), /* @__PURE__ */ jsxs(EdgeContainer, { ...edgeProps, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps,
        svgPath,
        ...markOrange && {
          strokeWidth: 5
        }
      }
    ),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps,
        labelPosition: {
          x: labelX,
          y: labelY,
          translate: "translate(-50%, 0)"
        },
        style: {
          maxWidth: Math.min(Math.abs(props.targetX - props.sourceX - 70), 250)
        },
        children: label2
      }
    )
  ] });
}), emptyNode = css({
  width: "100%",
  height: "100%",
  border: "3px dashed",
  borderColor: "mantine.colors.defaultBorder",
  borderRadius: "md",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
function EmptyNode({
  data: {
    column
  }
}) {
  return /* @__PURE__ */ jsx(Box$1, { className: emptyNode, children: /* @__PURE__ */ jsxs(Text, { c: "dimmed", fz: "lg", fw: 500, children: [
    "No ",
    column === "incomers" ? "incoming" : "outgoing"
  ] }) });
}
const selectSubject$1 = (state) => state.context.subject, ElementActions$1 = (props) => {
  const { enableNavigateTo, enableVscode } = useEnabledFeatures(), diagram = useDiagram(), currentViewId = useCurrentViewId(), browser = useRelationshipsBrowser(), subject = useRelationshipsBrowserState(selectSubject$1), { navigateTo, fqn: fqn2 } = props.data, buttons = useMemo(() => {
    const buttons2 = [];
    return navigateTo && enableNavigateTo && currentViewId !== navigateTo && buttons2.push({
      key: "navigate",
      icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.navigateTo(navigateTo);
      }
    }), fqn2 !== subject && buttons2.push({
      key: "relationships",
      icon: /* @__PURE__ */ jsx(IconTransform, {}),
      onClick: (e2) => {
        e2.stopPropagation(), browser.navigateTo(fqn2, props.id);
      }
    }), enableVscode && buttons2.push({
      key: "goToSource",
      icon: /* @__PURE__ */ jsx(IconFileSymlink, {}),
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openSource({ element: fqn2 });
      }
    }), buttons2;
  }, [navigateTo, enableNavigateTo, currentViewId, fqn2, subject, enableVscode, diagram, browser, props.id]);
  return /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons,
      ...props
    }
  );
}, ElementDetailsButtonWithHandler$1 = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
      }
    }
  );
};
function ElementNode$1(props) {
  const { enableElementTags } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { layoutId: props.id, nodeProps: props, children: [
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler$1, { ...props }),
    /* @__PURE__ */ jsx(ElementActions$1, { ...props }),
    /* @__PURE__ */ jsx(ElementPorts$1, { ...props })
  ] }, props.id);
}
function CompoundNode$1(props) {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsxs(CompoundNodeContainer, { layoutId: props.id, nodeProps: props, children: [
    /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
    /* @__PURE__ */ jsx(
      CompoundDetailsButton,
      {
        ...props,
        onClick: (e2) => {
          e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
        }
      }
    ),
    /* @__PURE__ */ jsx(CompoundPorts$1, { ...props })
  ] }, props.id);
}
const ElementPorts$1 = ({ data: { ports, height: h } }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  ports.in.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (i + 1) * ((h - 30) / (ports.in.length + 1))}px`
      }
    },
    id
  )),
  ports.out.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (i + 1) * ((h - 30) / (ports.out.length + 1))}px`
      }
    },
    id
  ))
] }), CompoundPorts$1 = ({ data }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  data.ports.in.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    id
  )),
  data.ports.out.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    id
  ))
] }), sortByLabel = (a, b) => compareNatural(a.label, b.label);
function buildNode(element) {
  return {
    label: element.title,
    value: element.id,
    children: [...element.children()].map(buildNode).sort(sortByLabel)
  };
}
function useLikeC4ElementsTree(viewId) {
  const model = useLikeC4Model();
  return useMemo(() => viewId ? [...model.view(viewId).roots()].map(buildNode).sort(sortByLabel) : [...model.roots()].map(buildNode).sort(sortByLabel), [model, viewId ?? null]);
}
const node = css({
  margin: "0"
}), label = css({
  _hover: {
    backgroundColor: "mantine.colors.gray[0]",
    _dark: {
      backgroundColor: "mantine.colors.defaultHover",
      color: "mantine.colors.white"
    }
  }
}), scrollArea$2 = css({
  maxHeight: [
    "70vh",
    "calc(100cqh - 70px)"
  ]
}), classes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label,
  node,
  scrollArea: scrollArea$2
}, Symbol.toStringTag, { value: "Module" })), selector2$1 = (state) => {
  const subjectExistsInScope = state.context.layouted?.subjectExistsInScope ?? !1;
  return {
    subjectId: state.context.subject,
    viewId: state.context.viewId,
    scope: state.context.scope,
    subjectExistsInScope,
    enableSelectSubject: state.context.enableSelectSubject,
    enableChangeScope: state.context.enableChangeScope
  };
}, setHoveredNode$2 = () => {
}, SelectElement = memo$1(() => {
  const browser = useRelationshipsBrowser(), {
    subjectId,
    viewId,
    scope,
    subjectExistsInScope,
    enableSelectSubject,
    enableChangeScope
  } = useRelationshipsBrowserState(selector2$1), root = useRef(null), viewport = useRef(null), subject = useLikeC4Model().findElement(subjectId), data = useLikeC4ElementsTree(scope === "view" && viewId ? viewId : void 0), tree = useTree({
    multiple: !1
  });
  return tree.setHoveredNode = setHoveredNode$2, useEffect(() => {
    ancestorsFqn(subjectId).reverse().forEach((id) => {
      tree.expand(id);
    }), tree.select(subjectId);
  }, [subjectId]), /* @__PURE__ */ jsxs(Group, { ref: root, gap: "xs", pos: "relative", children: [
    enableSelectSubject && /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
      /* @__PURE__ */ jsx(
        Box$1,
        {
          fz: "xs",
          fw: "500",
          style: { whiteSpace: "nowrap", userSelect: "none" },
          children: "Relationships of"
        }
      ),
      /* @__PURE__ */ jsx(Box$1, { pos: "relative", children: /* @__PURE__ */ jsxs(
        Popover,
        {
          position: "bottom-start",
          shadow: "md",
          keepMounted: !1,
          withinPortal: !1,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          offset: 4,
          onOpen: () => {
            setTimeout(() => {
              viewport.current?.querySelector(`[data-value="${subjectId}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
            }, 100);
          },
          children: [
            /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsx(
              Button,
              {
                size: "xs",
                variant: "default",
                maw: 250,
                rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
                children: /* @__PURE__ */ jsx(Text, { fz: "xs", fw: "500", truncate: !0, children: subject?.title ?? "???" })
              }
            ) }),
            /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { scrollbars: "y", type: "never", viewportRef: viewport, className: scrollArea$2, children: /* @__PURE__ */ jsx(
              Tree,
              {
                allowRangeSelection: !1,
                selectOnClick: !1,
                tree,
                data,
                classNames: classes,
                levelOffset: 8,
                styles: {
                  root: {
                    maxWidth: 400,
                    overflow: "hidden"
                  },
                  label: {
                    paddingTop: 5,
                    paddingBottom: 6
                  }
                },
                renderNode: ({ node: node2, selected, expanded, elementProps, hasChildren }) => /* @__PURE__ */ jsxs(Group, { gap: 2, wrap: "nowrap", ...elementProps, py: "3", children: [
                  /* @__PURE__ */ jsx(
                    ActionIcon,
                    {
                      variant: "subtle",
                      size: 18,
                      c: "dimmed",
                      style: {
                        visibility: hasChildren ? "visible" : "hidden"
                      },
                      children: /* @__PURE__ */ jsx(
                        IconChevronRight,
                        {
                          stroke: 3.5,
                          style: {
                            transition: "transform 150ms ease",
                            transform: `rotate(${expanded ? "90deg" : "0"})`,
                            width: "80%"
                          }
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    Box$1,
                    {
                      flex: "1 1 100%",
                      w: "100%",
                      onClick: (e2) => {
                        e2.stopPropagation(), tree.select(node2.value), tree.expand(node2.value), browser.navigateTo(node2.value);
                      },
                      children: /* @__PURE__ */ jsx(
                        Text,
                        {
                          fz: "sm",
                          fw: selected ? "600" : "400",
                          truncate: "end",
                          children: node2.label
                        }
                      )
                    }
                  )
                ] })
              }
            ) }) })
          ]
        }
      ) })
    ] }),
    enableChangeScope && /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
      enableSelectSubject && /* @__PURE__ */ jsx(
        Box$1,
        {
          fz: "xs",
          fw: "500",
          ...!subjectExistsInScope && {
            c: "dimmed"
          },
          style: { whiteSpace: "nowrap", userSelect: "none" },
          children: "Scope"
        }
      ),
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(
        Tooltip$6,
        {
          color: "orange",
          label: /* @__PURE__ */ jsxs(Fragment, { children: [
            "This element does not exist in the current view",
            scope === "view" && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx("br", {}),
              "Scope is set to global"
            ] })
          ] }),
          position: "bottom-start",
          disabled: subjectExistsInScope,
          portalProps: {
            target: root.current
          },
          children: /* @__PURE__ */ jsx(
            SegmentedControl,
            {
              flex: "1 0 auto",
              size: "xs",
              withItemsBorders: !1,
              value: scope,
              styles: {
                label: {
                  paddingLeft: 8,
                  paddingRight: 8
                }
              },
              onChange: (value) => {
                browser.changeScope(value);
              },
              data: [
                { label: "Global", value: "global" },
                {
                  label: /* @__PURE__ */ jsx("span", { children: "Current view" }),
                  value: "view",
                  disabled: !subjectExistsInScope
                }
              ]
            }
          )
        }
      ) })
    ] })
  ] });
}), nodeTypes$2 = {
  element: ElementNode$1,
  compound: CompoundNode$1,
  empty: EmptyNode
}, edgeTypes$3 = {
  relationship: RelationshipEdge$3
};
function RelationshipsBrowser({ actorRef }) {
  const initialRef = useRef(null);
  return initialRef.current == null && (initialRef.current = {
    initialNodes: [],
    initialEdges: []
  }), /* @__PURE__ */ jsx(RelationshipsBrowserActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(ReactFlowProvider, { ...initialRef.current, children: /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(RelationshipsBrowserXYFlow, {}) }) }) }) });
}
const selector$4 = (state) => ({
  isActive: state.hasTag("active"),
  nodes: state.context.xynodes,
  edges: state.context.xyedges
}), selectorEq$1 = (a, b) => a.isActive === b.isActive && shallowEqual(a.nodes, b.nodes) && shallowEqual(a.edges, b.edges), RelationshipsBrowserXYFlow = memo$1(() => {
  const browser = useRelationshipsBrowser(), {
    isActive,
    nodes,
    edges
  } = useRelationshipsBrowserState(
    selector$4,
    selectorEq$1
  );
  return /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      id: browser.rootElementId,
      nodes,
      edges,
      className: cx(
        isActive ? "initialized" : "not-initialized",
        "relationships-browser"
      ),
      nodeTypes: nodeTypes$2,
      edgeTypes: edgeTypes$3,
      fitView: !1,
      onNodeClick: useCallbackRef((_e, node2) => {
        _e.stopPropagation(), browser.send({ type: "xyflow.nodeClick", node: node2 });
      }),
      onEdgeClick: useCallbackRef((_e, edge) => {
        _e.stopPropagation(), browser.send({ type: "xyflow.edgeClick", edge });
      }),
      onPaneClick: useCallbackRef((_e) => {
        _e.stopPropagation(), browser.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: useCallbackRef((_e) => {
        browser.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: useCallbackRef(() => {
        browser.send({ type: "xyflow.resized" });
      }),
      onNodesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        browser.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      onEdgeMouseEnter: useCallbackRef((_event, edge) => {
        edge.data.hovered || browser.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef((_event, edge) => {
        edge.data.hovered && browser.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      onSelectionChange: useCallbackRef((params) => {
        browser.send({ type: "xyflow.selectionChange", ...params });
      }),
      nodesDraggable: !1,
      nodesSelectable: !0,
      pannable: !0,
      zoomable: !0,
      children: /* @__PURE__ */ jsx(RelationshipsBrowserInner, {})
    }
  );
}), selector2 = (state) => ({
  subjectId: state.context.subject,
  viewId: state.context.viewId,
  scope: state.context.scope,
  closeable: state.context.closeable
}), RelationshipsBrowserInner = memo$1(() => {
  const browser = useRelationshipsBrowser(), {
    subjectId,
    viewId,
    scope,
    closeable
  } = useRelationshipsBrowserState(selector2), store = useStoreApi(), instance = useReactFlow();
  useEffect(() => {
    instance.viewportInitialized && browser.send({ type: "xyflow.init", instance, store });
  }, [store, instance.viewportInitialized, browser]);
  const layouted = useRelationshipsView(subjectId, viewId, scope), [historySubjectId, historyOps, { history, current }] = useStateHistory(subjectId);
  useEffect(() => {
    historySubjectId !== subjectId && historyOps.set(subjectId);
  }, [subjectId]), useEffect(() => {
    historySubjectId !== subjectId && browser.navigateTo(historySubjectId);
  }, [historySubjectId, browser]), useRafEffect(() => {
    browser.updateView(layouted);
  }, [layouted, browser]);
  const hasStepBack = current > 0, hasStepForward = current + 1 < history.length;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      TopLeftPanel$1,
      {
        hasStepBack,
        hasStepForward,
        onStepBack: () => historyOps.back(),
        onStepForward: () => historyOps.forward()
      }
    ),
    closeable && /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
      ActionIcon,
      {
        variant: "default",
        color: "gray",
        onClick: (e2) => {
          e2.stopPropagation(), browser.close();
        },
        children: /* @__PURE__ */ jsx(IconX, {})
      }
    ) })
  ] });
}), TopLeftPanel$1 = ({
  hasStepBack,
  hasStepForward,
  onStepBack,
  onStepForward
}) => /* @__PURE__ */ jsx(Panel, { position: "top-left", children: /* @__PURE__ */ jsxs(Group, { gap: 4, wrap: "nowrap", children: [
  /* @__PURE__ */ jsxs(AnimatePresence, { mode: "popLayout", children: [
    hasStepBack && /* @__PURE__ */ jsx(
      m.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), onStepBack();
            },
            children: /* @__PURE__ */ jsx(IconChevronLeft, {})
          }
        )
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      m.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), onStepForward();
            },
            children: /* @__PURE__ */ jsx(IconChevronRight, {})
          }
        )
      },
      "forward"
    )
  ] }),
  /* @__PURE__ */ jsx(SelectElement, {})
] }) }), fqn = css({
  display: "inline-block",
  fontSize: "sm",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "[3px 6px]",
  borderRadius: 3,
  background: "var(--likec4-palette-fill)/75",
  lineHeight: 1.2,
  color: "var(--likec4-palette-hiContrast)"
  // selectors: {
  //   [`${whereDark} &`]: {
  //   }
  // }
}), relationshipStat = css({
  _light: {
    background: "mantine.colors.gray[1]",
    "&[data-missing": {}
  },
  // [`&[data-zero]`]: {
  //   color: mantine.colors.dimmed
  // },
  // [`${whereLight} &[data-zero]`]: {
  //   background: mantine.colors.gray[3]
  // },
  "&[data-missing]": {
    color: "mantine.colors.orange[4]",
    background: "mantine.colors.orange[8]/15",
    borderColor: "mantine.colors.orange[5]/20",
    _light: {
      color: "mantine.colors.orange[8]"
    }
  }
}), xyflow = css({
  flex: "1 1 100%",
  position: "relative",
  width: "100%",
  height: "100%",
  background: "mantine.colors.body",
  border: "1px solid {colors.mantine.colors.defaultBorder}",
  borderRadius: "sm",
  _light: {
    borderColor: "mantine.colors.gray[3]",
    background: "mantine.colors.gray[1]"
  }
});
css({
  _before: {
    content: '"scope:"',
    position: "absolute",
    top: "0",
    left: "2",
    fontSize: "xxs",
    fontWeight: 500,
    lineHeight: "1",
    color: "mantine.colors.dimmed",
    opacity: 0.85,
    transform: "translateY(-100%) translateY(-2px)"
  },
  _light: {
    "& .mantine-SegmentedControl-root": {
      background: "mantine.colors.gray[3]"
    }
  }
});
css({
  display: "inline-block",
  fontSize: "xl",
  fontWeight: 600,
  padding: "[1px 5px]",
  minWidth: 24,
  textAlign: "center",
  borderRadius: "sm",
  background: "mantine.colors.dark[7]",
  color: "mantine.colors.defaultColor",
  "&[data-zero]": {
    color: "mantine.colors.dimmed"
  },
  "&[data-missing]": {
    color: "mantine.colors.orange[4]",
    background: "mantine.colors.orange[8]/20"
  }
  // _light: {
  //   background: 'mantine.colors.gray[4]',
  //   color: 'mantine.colors.dark[6]',
  //   [`&[data-zero]`]: {
  //     background: 'mantine.colors.gray[3]',
  //   },
  //   [`&[data-missing]`]: {
  //     color: 'mantine.colors.orange[8]',
  //   },
  // },
});
const Tooltip$2 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function TabPanelRelationships({
  node: node2,
  element
}) {
  const diagram = useDiagram(), delailsActor = useElementDetailsActorRef(), relationshipsBrowserActor = useSelector(
    delailsActor,
    useCallback((s) => s.children[`${delailsActor.id}-relationships`], [delailsActor.id])
  ), incoming = [...element.incoming()].map((r2) => r2.id), outgoing = [...element.outgoing()].map((r2) => r2.id), incomingInView = node2 ? n$3([...node2.incoming()].flatMap((e2) => e2.$edge.relations)) : [], outgoingInView = node2 ? n$3([...node2.outgoing()].flatMap((e2) => e2.$edge.relations)) : [], notIncludedRelations = [
    ...incoming,
    ...outgoing
  ].filter((r2) => !incomingInView.includes(r2) && !outgoingInView.includes(r2)).length;
  return /* @__PURE__ */ jsxs(Stack, { gap: "xs", pos: "relative", w: "100%", h: "100%", children: [
    incoming.length + outgoing.length > 0 && /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
      /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsxs(Group, { gap: 8, mb: 4, wrap: "nowrap", children: [
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "incoming",
            total: incoming.length,
            included: incomingInView.length
          }
        ),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(Text, { className: fqn, children: nameFromFqn(element.id) }),
        /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: 16 } }) }),
        /* @__PURE__ */ jsx(
          RelationshipsStat,
          {
            title: "outgoing",
            total: outgoing.length,
            included: outgoingInView.length
          }
        )
      ] }) }),
      notIncludedRelations > 0 && /* @__PURE__ */ jsx(Tooltip$2, { label: "Current view does not include some relationships", children: /* @__PURE__ */ jsxs(
        Group,
        {
          mt: "xs",
          gap: 6,
          c: "orange",
          style: { cursor: "pointer" },
          children: [
            /* @__PURE__ */ jsx(IconInfoCircle, { style: { width: 14 } }),
            /* @__PURE__ */ jsxs(Text, { fz: "sm", children: [
              notIncludedRelations,
              " relationship",
              notIncludedRelations > 1 ? "s are" : " is",
              " hidden"
            ] })
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx(Box$1, { className: xyflow, children: relationshipsBrowserActor && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(RelationshipsBrowser, { actorRef: relationshipsBrowserActor }),
      /* @__PURE__ */ jsx(Box$1, { pos: "absolute", top: 12, right: 12, children: /* @__PURE__ */ jsx(
        ActionIcon,
        {
          size: "md",
          variant: "default",
          radius: "sm",
          onClick: (e2) => {
            e2.stopPropagation();
            const {
              subject,
              scope,
              viewId
            } = relationshipsBrowserActor.getSnapshot().context;
            diagram.overlays().send({
              type: "open.relationshipsBrowser",
              subject,
              scope,
              viewId
            });
          },
          children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "70%" } })
        }
      ) })
    ] }) })
  ] });
}
function RelationshipsStat({
  title: title2,
  total,
  included
}) {
  return /* @__PURE__ */ jsx(
    Paper,
    {
      withBorder: !0,
      shadow: "none",
      className: relationshipStat,
      px: "md",
      py: "xs",
      radius: "md",
      mod: {
        zero: total === 0,
        missing: total !== included
      },
      children: /* @__PURE__ */ jsxs(Stack, { gap: 4, align: "flex-end", children: [
        /* @__PURE__ */ jsx(Text, { component: "div", c: total !== included ? "orange" : "dimmed", tt: "uppercase", fw: 600, fz: 10, lh: 1, children: title2 }),
        /* @__PURE__ */ jsx(Text, { fw: 600, fz: "xl", component: "div", lh: 1, children: total !== included ? /* @__PURE__ */ jsxs(Fragment, { children: [
          included,
          " / ",
          total
        ] }) : /* @__PURE__ */ jsx(Fragment, { children: total }) })
      ] })
    }
  );
}
const treeNodeLabel = css({
  marginTop: "sm",
  marginBottom: "sm"
}), elementLabel = css({
  display: "inline-flex",
  transition: "fast",
  border: "1px dashed",
  borderColor: "mantine.colors.defaultBorder",
  borderRadius: "sm",
  px: "md",
  py: "xs",
  alignItems: "center",
  cursor: "pointer",
  color: "mantine.colors.gray[7]",
  _dark: {
    color: "mantine.colors.dark[1]"
  },
  "& > *": {
    transition: "fast"
  },
  _hover: {
    transitionTimingFunction: "out",
    borderStyle: "solid",
    color: "mantine.colors.defaultColor",
    background: "mantine.colors.defaultHover",
    "& > *": {
      transitionTimingFunction: "out",
      transform: "translateX(1px)"
    }
  }
}), ElementLabel = ({
  element
}) => /* @__PURE__ */ jsx(Box$1, { className: elementLabel, children: /* @__PURE__ */ jsx(Text, { component: "div", fz: "sm", fw: "500", children: element.title }) }), setHoveredNode$1 = () => {
};
function TabPanelStructure({
  element
}) {
  const tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode$1;
  const data = useMemo(() => {
    let seq = 1;
    const messageNode = (label2) => ({
      label: label2,
      value: `msg${seq++}`,
      type: "message",
      children: []
    }), current = {
      label: /* @__PURE__ */ jsx(ElementLabel, { type: "current", element }),
      value: element.id,
      element,
      type: "current",
      children: [...element.children()].map((child) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "descedant", element: child }),
        value: child.id,
        element: child,
        type: "descedant",
        children: []
      }))
    };
    return current.children.length === 0 && current.children.push(
      messageNode(/* @__PURE__ */ jsx(Pill, { radius: "sm", children: "no nested" }))
    ), [
      [...element.ancestors()].reduce((acc, parent) => ({
        label: /* @__PURE__ */ jsx(ElementLabel, { type: "ancestor", element: parent }),
        value: parent.id,
        element: parent,
        type: "ancestor",
        children: [acc]
      }), current)
    ];
  }, [element]);
  return useEffect(() => {
    tree.expandAllNodes();
  }, [data]), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Alert, { variant: "light", color: "orange", title: "In development", icon: /* @__PURE__ */ jsx(IconInfoCircle, {}), children: [
      "We need your feedback. Share your thoughts and ideas -",
      " ",
      /* @__PURE__ */ jsx(
        Anchor,
        {
          fz: "sm",
          fw: 500,
          underline: "hover",
          c: "orange",
          href: "https://github.com/likec4/likec4/discussions/",
          target: "_blank",
          children: "GitHub discussions"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(
      Tree,
      {
        levelOffset: "xl",
        allowRangeSelection: !1,
        expandOnClick: !1,
        expandOnSpace: !1,
        classNames: {
          label: treeNodeLabel
        },
        data,
        tree
      }
    )
  ] });
}
const Divider = Divider$2.withProps({
  mb: 8,
  labelPosition: "left",
  variant: "dashed"
}), Tooltip$1 = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
}), SmallLabel = Text.withProps({
  component: "div",
  fz: 11,
  fw: 500,
  c: "dimmed",
  lh: 1
}), PropertyLabel = Text.withProps({
  component: "div",
  fz: "xs",
  c: "dimmed",
  className: propertyLabel
}), MIN_PADDING = 24, TABS = ["Properties", "Relationships", "Views", "Structure", "Deployments"];
function ElementDetailsCard({
  viewId,
  fromNode,
  rectFromNode,
  fqn: fqn2,
  onClose
}) {
  const [opened, setOpened] = useState(!1), windowSize = useViewportSize(), windowWidth = windowSize.width || window.innerWidth || 1200, windowHeight = windowSize.height || window.innerHeight || 800, [activeTab, setActiveTab] = useSessionStorage({
    key: "likec4:element-details:active-tab",
    defaultValue: "Properties"
  }), diagram = useDiagram(), viewModel = useCurrentViewModel(), nodeModel = fromNode ? viewModel.findNode(fromNode) : viewModel.findNodeWithElement(fqn2), elementModel = viewModel.$model.element(fqn2), [viewsOf, otherViews] = t$6(
    [...elementModel.views()],
    t$a((v) => v.$view),
    t$l((v) => v._type === "element" && v.viewOf === fqn2)
  );
  let defaultView = nodeModel?.navigateTo?.$view ?? elementModel.defaultView?.$view ?? null;
  defaultView?.id === viewId && (defaultView = null);
  const defaultLink = t$f(elementModel.links), controls = useDragControls(), isCompound = (nodeModel?.$node.children?.length ?? 0) > 0, _width = Math.min(700, windowWidth - MIN_PADDING * 2), _height = Math.min(650, windowHeight - MIN_PADDING * 2), fromPositon = rectFromNode ? {
    x: rectFromNode.x + (isCompound ? rectFromNode.width - _width / 2 : rectFromNode.width / 2),
    y: rectFromNode.y + (isCompound ? 0 : rectFromNode.height / 2)
  } : {
    x: windowWidth / 2,
    y: windowHeight / 2
  }, fromScale = rectFromNode ? Math.min(rectFromNode.width / _width, rectFromNode.height / _height, 0.9) : 1, left = Math.round(
    t(fromPositon.x - _width / 2, {
      min: MIN_PADDING,
      max: windowWidth - _width - MIN_PADDING
    })
  ), top = Math.round(
    t(fromPositon.y - (isCompound ? 0 : 60), {
      min: MIN_PADDING,
      max: windowHeight - _height - MIN_PADDING
    })
  ), originX = t((fromPositon.x - left) / _width, {
    min: 0.1,
    max: 0.9
  }), originY = t((fromPositon.y - top) / _height, {
    min: 0.1,
    max: 0.9
  }), width = useMotionValue(_width), height = useMotionValue(_height);
  useUpdateEffect(() => {
    width.set(_width), height.set(_height);
  }, [_width, _height]);
  const handleDrag = useCallback((_, info) => {
    width.set(Math.max(width.get() + info.delta.x, 320)), height.set(Math.max(height.get() + info.delta.y, 300));
  }, []), ref = useRef(null), onCloseRef = useSyncedRef(onClose), close = useDebouncedCallback(
    () => {
      onCloseRef.current();
    },
    [],
    50
  ), notation = nodeModel?.$node.notation ?? null, elementIcon2 = IconRenderer({
    element: {
      id: fqn2,
      title: elementModel.title,
      icon: nodeModel?.icon ?? elementModel.icon
    },
    className: elementIcon$1
  });
  return useTimeoutEffect(() => {
    ref.current?.open || ref.current?.showModal();
  }, 20), useTimeoutEffect(() => {
    setOpened(!0);
  }, 220), /* @__PURE__ */ jsx(
    m.dialog,
    {
      ref,
      className: cx(dialog$1, ReactRemoveScroll.classNames.fullWidth),
      layout: !0,
      initial: {
        [backdropBlur]: "0px",
        [backdropOpacity]: "5%"
      },
      animate: {
        [backdropBlur]: "3px",
        [backdropOpacity]: "60%"
      },
      exit: {
        [backdropBlur]: "0px",
        [backdropOpacity]: "0%",
        transition: {
          duration: 0.1
        }
      },
      onClick: (e2) => {
        e2.stopPropagation(), e2.target?.nodeName?.toUpperCase() === "DIALOG" && ref.current?.close();
      },
      onDoubleClick: stopPropagation,
      onPointerDown: stopPropagation,
      onClose: (e2) => {
        e2.stopPropagation(), close();
      },
      children: /* @__PURE__ */ jsx(ReactRemoveScroll, { forwardProps: !0, removeScrollBar: !1, children: /* @__PURE__ */ jsxs(
        m.div,
        {
          layout: !0,
          layoutRoot: !0,
          drag: !0,
          dragControls: controls,
          dragElastic: 0,
          dragMomentum: !1,
          dragListener: !1,
          "data-likec4-color": nodeModel?.color ?? elementModel.color,
          className: card$1,
          initial: {
            top,
            left,
            width: _width,
            height: _height,
            opacity: 0,
            originX,
            originY,
            scale: Math.max(fromScale, 0.65)
          },
          animate: {
            opacity: 1,
            scale: 1
          },
          exit: {
            opacity: 0,
            scale: 0.9,
            translateY: -10,
            transition: {
              duration: 0.1
            }
          },
          style: {
            width,
            height
          },
          children: [
            /* @__PURE__ */ jsxs("div", { className: cardHeader, onPointerDown: (e2) => controls.start(e2), children: [
              /* @__PURE__ */ jsxs(HStack, { alignItems: "start", justify: "space-between", gap: "sm", mb: "sm", flexWrap: "nowrap", children: [
                /* @__PURE__ */ jsxs(HStack, { alignItems: "start", gap: "sm", style: { cursor: "default" }, flexWrap: "nowrap", children: [
                  elementIcon2,
                  /* @__PURE__ */ jsxs("div", { children: [
                    /* @__PURE__ */ jsx(
                      Text,
                      {
                        component: "div",
                        className: title$2,
                        children: elementModel.title
                      }
                    ),
                    notation && /* @__PURE__ */ jsx(Text, { component: "div", c: "dimmed", fz: "sm", fw: 500, lh: 1.3, lineClamp: 1, children: notation })
                  ] })
                ] }),
                /* @__PURE__ */ jsx(
                  CloseButton,
                  {
                    size: "lg",
                    onClick: (e2) => {
                      e2.stopPropagation(), close();
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs(HStack, { alignItems: "baseline", gap: "sm", flexWrap: "nowrap", children: [
                /* @__PURE__ */ jsxs("div", { children: [
                  /* @__PURE__ */ jsx(SmallLabel, { children: "kind" }),
                  /* @__PURE__ */ jsx(
                    Badge,
                    {
                      radius: "sm",
                      size: "sm",
                      fw: 600,
                      color: "gray",
                      style: {
                        cursor: "pointer"
                      },
                      onClick: (e2) => {
                        e2.stopPropagation(), diagram.openSearch(`kind:${elementModel.kind}`);
                      },
                      children: elementModel.kind
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxs("div", { style: { flex: 1 }, children: [
                  /* @__PURE__ */ jsx(SmallLabel, { children: "tags" }),
                  /* @__PURE__ */ jsxs(Flex, { gap: 4, flex: 1, mt: 6, wrap: "wrap", children: [
                    elementModel.tags.map((tag) => /* @__PURE__ */ jsx(
                      ElementTag,
                      {
                        tag,
                        cursor: "pointer",
                        onClick: (e2) => {
                          e2.stopPropagation(), diagram.openSearch(`#${tag}`);
                        }
                      },
                      tag
                    )),
                    elementModel.tags.length === 0 && /* @__PURE__ */ jsx(Badge, { radius: "sm", size: "sm", fw: 600, color: "gray", children: "" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxs(
                  ActionIconGroup,
                  {
                    style: {
                      alignSelf: "flex-start"
                    },
                    children: [
                      defaultLink && /* @__PURE__ */ jsx(
                        ActionIcon,
                        {
                          component: "a",
                          href: defaultLink.url,
                          target: "_blank",
                          size: "lg",
                          variant: "default",
                          radius: "sm",
                          children: /* @__PURE__ */ jsx(IconExternalLink, { stroke: 1.6, style: { width: "65%" } })
                        }
                      ),
                      /* @__PURE__ */ jsx(IfEnabled, { feature: "Vscode", children: /* @__PURE__ */ jsx(Tooltip$1, { label: "Open source", children: /* @__PURE__ */ jsx(
                        ActionIcon,
                        {
                          size: "lg",
                          variant: "default",
                          radius: "sm",
                          onClick: (e2) => {
                            e2.stopPropagation(), diagram.openSource({
                              element: elementModel.id
                            });
                          },
                          children: /* @__PURE__ */ jsx(IconFileSymlink, { stroke: 1.8, style: { width: "62%" } })
                        }
                      ) }) }),
                      defaultView && /* @__PURE__ */ jsx(Tooltip$1, { label: "Open default view", children: /* @__PURE__ */ jsx(
                        ActionIcon,
                        {
                          size: "lg",
                          variant: "default",
                          radius: "sm",
                          onClick: (e2) => {
                            e2.stopPropagation(), diagram.navigateTo(defaultView.id, fromNode ?? void 0);
                          },
                          children: /* @__PURE__ */ jsx(IconZoomScan, { style: { width: "70%" } })
                        }
                      ) })
                    ]
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsx(MetadataProvider, { children: /* @__PURE__ */ jsxs(
              Tabs,
              {
                value: activeTab,
                onChange: (v) => setActiveTab(v),
                variant: "none",
                classNames: {
                  root: tabsRoot,
                  list: tabsList,
                  tab: tabsTab,
                  panel: tabsPanel
                },
                children: [
                  /* @__PURE__ */ jsx(TabsList, { children: TABS.map((tab) => /* @__PURE__ */ jsx(TabsTab, { value: tab, children: tab }, tab)) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Properties", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "scroll", offsetScrollbars: !0, children: /* @__PURE__ */ jsxs(Box$1, { className: propertiesGrid, pt: "xs", children: [
                    elementModel.hasSummary && /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "summary" }),
                      /* @__PURE__ */ jsx(Markdown, { value: elementModel.summary })
                    ] }),
                    /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "description" }),
                      /* @__PURE__ */ jsx(
                        Markdown,
                        {
                          value: elementModel.description,
                          emptyText: "no description"
                        }
                      )
                    ] }),
                    elementModel.technology && /* @__PURE__ */ jsx(ElementProperty, { title: "technology", children: elementModel.technology }),
                    elementModel.links.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
                      /* @__PURE__ */ jsx(PropertyLabel, { children: "links" }),
                      /* @__PURE__ */ jsx(HStack, { gap: "xs", flexWrap: "wrap", children: elementModel.links.map((link, i) => /* @__PURE__ */ jsx(Link, { value: link }, i)) })
                    ] }),
                    elementModel.$element.metadata && /* @__PURE__ */ jsx(ElementMetata, { value: elementModel.$element.metadata })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Relationships", children: /* @__PURE__ */ jsx(
                    DiagramFeatures,
                    {
                      overrides: {
                        enableRelationshipBrowser: !1,
                        enableNavigateTo: !1
                      },
                      children: opened && activeTab === "Relationships" && /* @__PURE__ */ jsx(
                        TabPanelRelationships,
                        {
                          element: elementModel,
                          node: nodeModel ?? null
                        }
                      )
                    }
                  ) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Views", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsxs(Stack, { gap: "lg", children: [
                    viewsOf.length > 0 && /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views of the element (scoped)" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "sm", children: viewsOf.map((view) => /* @__PURE__ */ jsx(
                        ViewButton$1,
                        {
                          view,
                          onNavigateTo: (to2) => diagram.navigateTo(to2, fromNode ?? void 0)
                        },
                        view.id
                      )) })
                    ] }),
                    otherViews.length > 0 && /* @__PURE__ */ jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsx(Divider, { label: "views including this element" }),
                      /* @__PURE__ */ jsx(Stack, { gap: "sm", children: otherViews.map((view) => /* @__PURE__ */ jsx(
                        ViewButton$1,
                        {
                          view,
                          onNavigateTo: (to2) => diagram.navigateTo(to2, fromNode ?? void 0)
                        },
                        view.id
                      )) })
                    ] })
                  ] }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Structure", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabPanelStructure, { element: elementModel }) }) }),
                  /* @__PURE__ */ jsx(TabsPanel, { value: "Deployments", children: /* @__PURE__ */ jsx(ScrollArea, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ jsx(TabPanelDeployments, { elementFqn: elementModel.id }) }) })
                ]
              }
            ) }),
            /* @__PURE__ */ jsx(
              m.div,
              {
                className: resizeHandle,
                drag: !0,
                dragElastic: 0,
                dragMomentum: !1,
                onDrag: handleDrag,
                dragConstraints: { top: 0, left: 0, right: 0, bottom: 0 }
              }
            )
          ]
        }
      ) })
    }
  );
}
const ViewButton$1 = ({
  view,
  onNavigateTo
}) => /* @__PURE__ */ jsx(UnstyledButton, { className: viewButton$1, onClick: (e2) => onNavigateTo(view.id, e2), children: /* @__PURE__ */ jsxs(Group, { gap: 6, align: "start", wrap: "nowrap", children: [
  /* @__PURE__ */ jsx(ThemeIcon, { size: "sm", variant: "transparent", children: view._type === "deployment" ? /* @__PURE__ */ jsx(IconStack2, { stroke: 1.8 }) : /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
  /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(Text, { component: "div", className: viewButtonTitle, lineClamp: 1, children: view.title || "untitled" }) })
] }) });
function ElementProperty({
  title: title2,
  emptyValue = "undefined",
  children,
  style,
  ...props
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { children: title2 }),
    /* @__PURE__ */ jsx(
      Text,
      {
        component: "div",
        ...e$6(children) && { c: "dimmed" },
        fz: "md",
        style: {
          whiteSpace: "preserve-breaks",
          userSelect: "all",
          ...style
        },
        ...props,
        children: children || emptyValue
      }
    )
  ] });
}
function ElementMetata({
  value: metadata
}) {
  const metadataEntries = t$9(metadata).sort(([a], [b]) => a.localeCompare(b));
  return /* @__PURE__ */ jsx(MetadataProvider, { children: /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PropertyLabel, { style: { justifySelf: "end", textAlign: "right" }, children: "metadata" }),
    /* @__PURE__ */ jsx(
      Box$1,
      {
        className: css({
          display: "grid",
          gridTemplateColumns: "min-content 1fr",
          gridAutoRows: "min-content",
          gap: "[12px 16px]",
          alignItems: "baseline",
          justifyItems: "stretch"
        }),
        children: metadataEntries.map(([key2, value]) => /* @__PURE__ */ jsx(MetadataValue, { label: key2, value }, key2))
      }
    )
  ] }) });
}
const selector$3 = (s) => ({
  viewId: s.context.currentView.id,
  fromNode: s.context.initiatedFrom.node,
  rectFromNode: s.context.initiatedFrom.clientRect,
  fqn: s.context.subject
});
function ElementDetails({
  actorRef,
  onClose
}) {
  const props = useSelector(
    actorRef,
    selector$3,
    shallowEqual
  );
  return /* @__PURE__ */ jsx(ElementDetailsActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(
    ElementDetailsCard,
    {
      onClose,
      ...props
    }
  ) });
}
const finalize = (elements, explicits) => elements.size > 2 && explicits.size !== elements.size ? new Set(sortParentsFirst([
  ...treeFromElements(elements).flatten(),
  ...explicits
])) : elements.size > 1 ? new Set(sortParentsFirst([...elements])) : elements;
function computeEdgeDetailsViewData(edges, view) {
  const sources = /* @__PURE__ */ new Set(), relationships = /* @__PURE__ */ new Set(), targets = /* @__PURE__ */ new Set(), explicit = {
    sources: /* @__PURE__ */ new Set(),
    targets: /* @__PURE__ */ new Set()
  }, addExplicit = (el, type) => {
    type === "source" ? (sources.add(el), explicit.sources.add(el)) : (targets.add(el), explicit.targets.add(el));
  };
  for (const edgeId of edges) {
    const edge = view.findEdge(edgeId), _relationships = edge ? [...edge.relationships("model")] : [];
    if (!edge || !t$1(_relationships, 1) || !edge.source.hasElement() || !edge.target.hasElement())
      continue;
    const source = edge.source.element, target = edge.target.element;
    addExplicit(source, "source"), addExplicit(target, "target");
    for (const relationship of _relationships) {
      if (relationships.add(relationship), relationship.source !== source) {
        addExplicit(relationship.source, "source");
        for (const parent of relationship.source.ancestors()) {
          if (parent === source)
            break;
          sources.add(parent);
        }
      }
      if (relationship.target !== target) {
        addExplicit(relationship.target, "target");
        for (const parent of relationship.target.ancestors()) {
          if (parent === target)
            break;
          targets.add(parent);
        }
      }
    }
  }
  return {
    sources: finalize(sources, explicit.sources),
    targets: finalize(targets, explicit.targets),
    relationships
  };
}
function computeRelationshipDetailsViewData({
  // relationships: _relationships,
  source,
  target
}) {
  const sources = /* @__PURE__ */ new Set(), relationships = /* @__PURE__ */ new Set(), targets = /* @__PURE__ */ new Set(), explicit = {
    sources: /* @__PURE__ */ new Set(),
    targets: /* @__PURE__ */ new Set()
  }, addExplicit = (el, type) => {
    type === "source" ? (sources.add(el), explicit.sources.add(el)) : (targets.add(el), explicit.targets.add(el));
  };
  source && addExplicit(source, "source"), target && addExplicit(target, "target");
  const [connection] = modelConnection.findConnection(source, target, "directed");
  if (!connection)
    return {
      sources,
      targets,
      relationships
    };
  for (const relationship of connection.relations) {
    const relationSource = relationship.source, relationTarget = relationship.target;
    if (addExplicit(relationSource, "source"), addExplicit(relationTarget, "target"), relationships.add(relationship), source !== relationSource) {
      invariant(isAncestor(source, relationSource), `${source.id} is not an ancestor of ${relationSource.id}`);
      for (const parent of relationSource.ancestors()) {
        if (parent === source)
          break;
        sources.add(parent);
      }
    }
    if (target !== relationTarget) {
      invariant(isAncestor(target, relationTarget), `${target.id} is not an ancestor of ${relationTarget.id}`);
      for (const parent of relationTarget.ancestors()) {
        if (parent === target)
          break;
        targets.add(parent);
      }
    }
  }
  return {
    sources: finalize(sources, explicit.sources),
    targets: finalize(targets, explicit.targets),
    relationships
  };
}
const RelationshipEdge$2 = memoEdge((props) => {
  const { enableNavigateTo } = useEnabledFeatures(), {
    data: { navigateTo }
  } = props, [svgPath, labelX, labelY] = getBezierPath(props), diagram = useDiagram();
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...props, children: [
    /* @__PURE__ */ jsx(EdgePath, { edgeProps: props, svgPath }),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps: props,
        labelPosition: {
          x: labelX,
          y: labelY,
          translate: "translate(-50%, 0)"
        },
        style: {
          maxWidth: Math.abs(props.targetX - props.sourceX - 100)
        },
        children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps: props, children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
          EdgeActionButton,
          {
            ...props,
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigateTo(navigateTo);
            }
          }
        ) })
      }
    )
  ] });
}), ElementActions = (props) => {
  const { enableNavigateTo, enableVscode } = useEnabledFeatures(), diagram = useDiagram(), currentViewId = useCurrentViewId(), buttons = [], { navigateTo, fqn: fqn2 } = props.data;
  return navigateTo && enableNavigateTo && currentViewId !== navigateTo && buttons.push({
    key: "navigate",
    icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.navigateTo(navigateTo);
    }
  }), fqn2 && buttons.push({
    key: "relationships",
    icon: /* @__PURE__ */ jsx(IconTransform, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openRelationshipsBrowser(fqn2);
    }
  }), fqn2 && enableVscode && buttons.push({
    key: "goToSource",
    icon: /* @__PURE__ */ jsx(IconFileSymlink, {}),
    onClick: (e2) => {
      e2.stopPropagation(), diagram.openSource({ element: fqn2 });
    }
  }), /* @__PURE__ */ jsx(
    ElementActionButtons,
    {
      buttons,
      ...props
    }
  );
}, ElementDetailsButtonWithHandler = (props) => {
  const diagram = useDiagram();
  return /* @__PURE__ */ jsx(
    ElementDetailsButton,
    {
      ...props,
      onClick: (e2) => {
        e2.stopPropagation(), diagram.openElementDetails(props.data.fqn);
      }
    }
  );
}, ElementNode = memoNode((props) => {
  const { enableElementTags } = useEnabledFeatures();
  return /* @__PURE__ */ jsxs(ElementNodeContainer, { nodeProps: props, children: [
    /* @__PURE__ */ jsx(ElementShape, { ...props }),
    /* @__PURE__ */ jsx(ElementData, { ...props }),
    enableElementTags && /* @__PURE__ */ jsx(ElementTags, { ...props }),
    /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { ...props }),
    /* @__PURE__ */ jsx(ElementActions, { ...props }),
    /* @__PURE__ */ jsx(ElementPorts, { ...props })
  ] });
}), CompoundNode = memoNode(
  (props) => /* @__PURE__ */ jsxs(CompoundNodeContainer, { nodeProps: props, children: [
    /* @__PURE__ */ jsx(ElementDetailsButtonWithHandler, { ...props }),
    /* @__PURE__ */ jsx(CompoundTitle, { ...props }),
    /* @__PURE__ */ jsx(CompoundPorts, { ...props })
  ] })
), ElementPorts = ({ data: { ports, height: h } }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  ports.in.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (i + 1) * ((h - 30) / (ports.in.length + 1))}px`
      }
    },
    id
  )),
  ports.out.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (i + 1) * ((h - 30) / (ports.out.length + 1))}px`
      }
    },
    id
  ))
] }), CompoundPorts = ({ data }) => /* @__PURE__ */ jsxs(Fragment, { children: [
  data.ports.in.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "target",
      position: Position.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    id
  )),
  data.ports.out.map((id, i) => /* @__PURE__ */ jsx(
    Handle,
    {
      id,
      type: "source",
      position: Position.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    id
  ))
] }), RelationshipDetailsActorContext = createContext(null);
function useRelationshipDetailsActor() {
  return nonNullable$1(useContext(RelationshipDetailsActorContext), "No RelationshipDetailsActorContext");
}
function useRelationshipDetailsState(selector3, compare2 = shallowEqual) {
  const select2 = useCallbackRef(selector3), actor = useRelationshipDetailsActor();
  return useSelector(actor, select2, compare2);
}
function useRelationshipDetails() {
  const actor = useRelationshipDetailsActor();
  return useMemo(() => ({
    actor,
    get rootElementId() {
      return `relationship-details-${actor.sessionId.replaceAll(":", "_")}`;
    },
    getState: () => actor.getSnapshot().context,
    send: actor.send,
    navigateTo: (...params) => {
      params.length === 1 ? actor.send({ type: "navigate.to", params: { edgeId: params[0] } }) : actor.send({ type: "navigate.to", params: { source: params[0], target: params[1] } });
    },
    fitDiagram: () => {
      actor.send({ type: "fitDiagram" });
    },
    close: () => {
      actor._parent ? actor._parent?.send({ type: "close", actorId: actor.id }) : actor.send({ type: "close" });
    }
  }), [actor]);
}
const Sizes = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 220,
    height: 14
    // minlen: 1,
  },
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function createGraph() {
  const g = new dagre.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return g.setGraph({
    ...Sizes.dagre,
    rankdir: "LR"
  }), g.setDefaultEdgeLabel(() => ({ ...Sizes.edgeLabel })), g.setDefaultNodeLabel(() => ({})), g;
}
const PortSuffix = "-port";
function createNodes(column, elements, g) {
  const graphNodes = new DefaultMap((key2) => ({
    id: `${column}-${key2}`,
    portId: `${column}-${key2}`
  })), tree = treeFromElements(elements);
  for (const element of tree.sorted) {
    const isCompound = tree.children(element).length > 0, fqn2 = element.id, id = `${column}-${fqn2}`, portId = isCompound ? `${id}${PortSuffix}` : id;
    graphNodes.set(fqn2, {
      id,
      portId
    }), g.setNode(id, {
      column,
      element,
      isCompound,
      portId,
      inPorts: [],
      outPorts: [],
      width: Sizes.nodeWidth,
      height: Sizes.nodeHeight
    }), isCompound && (g.setNode(portId, {
      element,
      portId,
      isCompound,
      inPorts: [],
      outPorts: [],
      width: Sizes.nodeWidth - Sizes.dagre.ranksep,
      height: Sizes.compound.labelHeight
    }), g.setParent(portId, id));
    const parent = tree.parent(element);
    parent && g.setParent(id, `${column}-${parent.id}`);
  }
  return {
    ...tree,
    byId: (id) => {
      const element = tree.byId(id), graph = graphNodes.get(element.id);
      return {
        element,
        graph
      };
    },
    graphNodes
  };
}
function applyDagreLayout(g) {
  return dagre.layout(g, {
    // disableOptimalOrderHeuristic: true,
  }), (nodeId) => {
    const node2 = g.node(nodeId), { x, y, width, height } = node2;
    return {
      position: {
        x: x - Math.round(width / 2),
        y: y - Math.round(height / 2)
      },
      width,
      height
    };
  };
}
function layoutRelationshipDetails(data, scope) {
  const g = createGraph(), sources = createNodes("sources", data.sources, g), targets = createNodes("targets", data.targets, g), edges = Array.from(data.relationships).map((r2) => {
    const source = sources.byId(r2.source.id).graph, target = targets.byId(r2.target.id).graph, name = r2.id;
    return g.node(source.id).outPorts.push(target.id), g.node(target.id).inPorts.push(source.id), g.setEdge(source.portId, target.portId, {
      ...Sizes.edgeLabel
    }, name), {
      name,
      source: source.id,
      sourceHandle: source.id + "_out" + (g.node(source.id).outPorts.length - 1),
      target: target.id,
      targetHandle: target.id + "_in" + (g.node(target.id).inPorts.length - 1),
      relationship: r2
    };
  }), nodeIds = [
    ...sources.graphNodes.values(),
    ...targets.graphNodes.values()
  ];
  for (const { id: nodeId } of nodeIds) {
    const node2 = g.node(nodeId);
    if (node2.isCompound)
      continue;
    const edgeCount2 = Math.max(g.inEdges(nodeId)?.length ?? 0, g.outEdges(nodeId)?.length ?? 0);
    edgeCount2 > 3 && (node2.height = node2.height + (edgeCount2 - 4) * 14);
  }
  const edgeCount = g.edgeCount();
  if (edgeCount > 5)
    for (const edge of g.edges())
      g.setEdge(edge, {
        ...Sizes.edgeLabel,
        width: edgeCount > 10 ? 800 : 400
      });
  const dagreBounds = applyDagreLayout(g), _calculatedNodeBounds = t$6(
    nodeIds,
    // Compound nodes have different portId
    n$2((n2) => n2.id === n2.portId),
    t$5((n2) => [n2.id, dagreBounds(n2.id)])
  );
  function nodeBounds(nodeId) {
    return _calculatedNodeBounds[nodeId] ??= t$6(
      g.children(nodeId) ?? [],
      n$2((id) => !id.endsWith(PortSuffix)),
      t$a((id) => nodeBounds(id)),
      t$h((bounds) => {
        invariant(bounds.length > 0, `Node ${nodeId} has no nested nodes`);
      }),
      t$g((acc, bounds) => ({
        minY: Math.min(acc.minY, bounds.position.y),
        maxY: Math.max(acc.maxY, bounds.position.y + bounds.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: minY2, maxY }) => {
        const {
          position: { x },
          width
        } = dagreBounds(nodeId);
        return minY2 = minY2 - Sizes.compound.paddingTop, maxY = maxY + Sizes.compound.paddingBottom, {
          position: {
            x,
            y: minY2
          },
          width,
          height: maxY - minY2
        };
      }
    );
  }
  function nodeLevel(nodeId) {
    const parent = g.parent(nodeId);
    return parent ? nodeLevel(parent) + 1 : 0;
  }
  function nodeDepth(nodeId) {
    const children = g.children(nodeId) ?? [];
    return children.length === 0 ? 0 : 1 + Math.max(...children.map(nodeDepth));
  }
  const sortedPorts = (nodeId, type, ports) => t$6(
    ports,
    t$a((port, index2) => ({
      port: nodeId + "_" + type + index2,
      topY: nodeBounds(port).position.y
    })),
    t$i(e$5("topY")),
    t$a(e$5("port"))
  );
  let minX = 0, minY = 0;
  const nodes = nodeIds.map(({ id }) => {
    const { element, inPorts, outPorts, column } = g.node(id);
    let { position, width, height } = nodeBounds(id);
    const parentId = g.parent(id), children = (g.children(id) ?? []).filter((c) => !c.endsWith(PortSuffix));
    minX = Math.min(minX, position.x), minY = Math.min(minY, position.y);
    const navigateTo = scope ? ifind(element.scopedViews(), (v) => v.id !== scope.id)?.id ?? null : null, inheritFromNode = scope?.findNodeWithElement(element.id), scopedAncestor = scope && !inheritFromNode ? ifind(element.ancestors(), (a) => !!scope.findNodeWithElement(a.id))?.id : null, inheritFromNodeOrAncestor = inheritFromNode ?? (scopedAncestor && scope?.findNodeWithElement(scopedAncestor));
    return exact({
      id,
      parent: parentId ?? null,
      x: position.x,
      y: position.y,
      title: element.title,
      description: preferSummary(element.$element) ?? null,
      technology: element.technology,
      tags: [...element.tags],
      links: null,
      color: inheritFromNodeOrAncestor?.color ?? element.color,
      shape: inheritFromNode?.shape ?? element.shape,
      icon: inheritFromNode?.icon ?? element.icon ?? "none",
      modelRef: element.id,
      kind: element.kind,
      level: nodeLevel(id),
      labelBBox: {
        x: position.x,
        y: position.y,
        width,
        height
      },
      style: n$1({
        ...(inheritFromNode ?? inheritFromNodeOrAncestor)?.style,
        ...element.$element.style
      }, ["shape", "color", "icon"]),
      navigateTo,
      ...children.length > 0 && { depth: nodeDepth(id) },
      children,
      width,
      height,
      column,
      ports: {
        in: sortedPorts(id, "in", inPorts),
        out: sortedPorts(id, "out", outPorts)
      }
    });
  });
  return {
    bounds: {
      x: Math.min(minX, 0),
      y: Math.min(minY, 0),
      width: g.graph().width ?? 100,
      height: g.graph().height ?? 100
    },
    nodes,
    edges: g.edges().reduce((acc, e2) => {
      const edge = g.edge(e2), ename = e2.name;
      if (!ename)
        return acc;
      const { name, source, target, relationship, sourceHandle, targetHandle } = r(edges, (e22) => e22.name === ename), label2 = relationship.title ?? "untitled", navigateTo = relationship.navigateTo?.id ?? null, description2 = preferSummary(relationship.$relationship) ?? null, technology = relationship.technology ?? null;
      return acc.push({
        id: name,
        source,
        sourceHandle,
        target,
        targetHandle,
        label: label2,
        color: relationship.color,
        description: description2,
        ...navigateTo && { navigateTo },
        ...technology && { technology },
        points: edge.points.map((p) => [p.x, p.y]),
        line: relationship.line,
        relationId: relationship.id,
        parent: null
      }), acc;
    }, [])
  };
}
const edgeEnpoint = css.raw({
  display: "inline-flex",
  alignItems: "center",
  padding: "[6px 2px 0 2px]",
  "& .mantine-Text-root": {
    color: "mantine.colors.text/90",
    fontSize: "xs",
    fontWeight: 500,
    lineHeight: "1.2"
  }
}), edgeSource = css({
  paddingLeft: "1",
  gridColumn: 1
}, edgeEnpoint), edgeArrow = css({
  gridColumn: 2
}, edgeEnpoint), edgeTarget = css({
  gridColumn: 3,
  paddingRight: "1"
}, edgeEnpoint), edgeLabelclass = "likec4-edge-label", edgeLabel = cx(
  edgeLabelclass,
  css({
    display: "grid",
    gridColumnStart: 1,
    gridColumnEnd: 4,
    borderBottom: "1px solid",
    borderBottomColor: "mantine.colors.defaultBorder",
    marginBottom: "0",
    padding: "[0 4px 5px 4px]",
    width: "100%",
    "& .mantine-Text-root": {
      fontSize: "xxs",
      fontWeight: 400,
      lineHeight: "xs",
      color: "mantine.colors.dimmed"
    }
  })
), edgeRow = css({
  display: "contents",
  [`&:last-child .${edgeLabelclass}`]: {
    borderBottom: "none",
    marginBottom: "0"
  },
  "& > *": {
    transition: "all 0.15s ease-in"
  },
  "&:is(:hover, [data-selected=true]) > *": {
    transition: "all 0.15s ease-out",
    cursor: "pointer",
    backgroundColor: "mantine.colors.defaultHover"
  }
}), edgeGrid = css({
  display: "grid",
  gridTemplateColumns: "1fr 30px 1fr",
  gridAutoRows: "min-content max-content",
  gap: "0",
  alignItems: "stretch"
});
css({
  display: "grid",
  gridTemplateColumns: "min-content 1fr",
  gridAutoRows: "min-content max-content",
  gap: "[10px 12px]",
  alignItems: "baseline",
  justifyItems: "start"
});
const scrollArea$1 = css({
  maxHeight: [
    "70vh",
    "calc(100cqh - 70px)"
  ]
}), SelectEdge = ({
  edge,
  view
}) => {
  const browser = useRelationshipDetails(), viewport = useRef(null), edgeSource$1 = view.nodes.find((n2) => n2.id === edge.source), edgeTarget$1 = view.nodes.find((n2) => n2.id === edge.target), edges = view.edges.flatMap((edge2) => {
    const source = view.nodes.find((n2) => n2.id === edge2.source), target = view.nodes.find((n2) => n2.id === edge2.target);
    return source && target ? {
      id: edge2.id,
      source,
      target,
      label: edge2.label
    } : [];
  });
  return !edgeSource$1 || !edgeTarget$1 || edges.length === 0 ? null : /* @__PURE__ */ jsxs(
    Popover,
    {
      position: "bottom-start",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          viewport.current?.querySelector(`[data-edge-id="${edge.id}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ jsx(PopoverTarget, { children: /* @__PURE__ */ jsxs(
          Button,
          {
            size: "xs",
            variant: "default",
            fw: "500",
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ jsx(IconSelector, { size: 16 }),
            children: [
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeSource,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeSource$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: edgeSource$1.title })
                }
              ),
              /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }),
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeTarget,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": edgeTarget$1.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: edgeTarget$1.title })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsx(PopoverDropdown, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { className: scrollArea$1, scrollbars: "y", type: "never", viewportRef: viewport, children: /* @__PURE__ */ jsx(Box$1, { className: edgeGrid, p: "xs", maw: 400, children: edges.map((e2) => /* @__PURE__ */ jsxs(
          "div",
          {
            className: edgeRow,
            "data-selected": e2.id === edge.id,
            onClick: (event) => {
              event.stopPropagation(), browser.navigateTo(e2.id);
            },
            children: [
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeSource,
                  mod: {
                    "edge-id": e2.id,
                    "likec4-color": e2.source.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.source.title })
                }
              ),
              /* @__PURE__ */ jsx(Box$1, { className: edgeArrow, children: /* @__PURE__ */ jsx(ThemeIcon, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ jsx(IconArrowRight, { style: { width: "80%" } }) }) }),
              /* @__PURE__ */ jsx(
                Box$1,
                {
                  className: edgeTarget,
                  mod: {
                    "likec4-color": e2.target.color
                  },
                  children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.target.title })
                }
              ),
              /* @__PURE__ */ jsx(Box$1, { className: edgeLabel, children: /* @__PURE__ */ jsx(Text, { component: "span", truncate: !0, children: e2.label || "untitled" }) })
            ]
          },
          e2.id
        )) }) }) })
      ]
    }
  );
}, nodeTypes$1 = {
  element: ElementNode,
  compound: CompoundNode
}, edgeTypes$2 = {
  relationship: RelationshipEdge$2
};
function RelationshipDetails({ actorRef }) {
  const initialRef = useRef(null);
  return initialRef.current == null && (initialRef.current = {
    defaultNodes: [],
    defaultEdges: []
  }), /* @__PURE__ */ jsx(RelationshipDetailsActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsx(ReactFlowProvider, { ...initialRef.current, children: /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    /* @__PURE__ */ jsx(RelationshipDetailsInner, {}, "xyflow"),
    /* @__PURE__ */ jsx(SyncRelationshipDetailsXYFlow, {}, "sync")
  ] }) }) }) });
}
const selectSubject = (state) => ({
  ...state.context.subject,
  viewId: state.context.viewId
}), SyncRelationshipDetailsXYFlow = memo$1(() => {
  const actor = useRelationshipDetailsActor(), subject = useSelector(actor, selectSubject, deepEqual), likec4model = useLikeC4Model(), view = likec4model.findView(subject.viewId) ?? null, data = useMemo(() => {
    let data2;
    if ("edgeId" in subject && e$8(subject.edgeId)) {
      invariant$1(view, `view ${subject.viewId} not found`);
      const edge = nonNullable$1(view.findEdge(subject.edgeId), `edge ${subject.edgeId} not found in ${subject.viewId}`);
      data2 = computeEdgeDetailsViewData([edge.id], view);
    } else if (subject.source && subject.target)
      data2 = computeRelationshipDetailsViewData({
        source: likec4model.element(subject.source),
        target: likec4model.element(subject.target)
      });
    else
      return null;
    return layoutRelationshipDetails(data2, view);
  }, [
    subject,
    view,
    likec4model
  ]), store = useStoreApi(), instance = useReactFlow();
  return useEffect(() => {
    instance.viewportInitialized && actor.send({ type: "xyflow.init", instance, store });
  }, [store, instance.viewportInitialized, actor]), useEffect(() => {
    data !== null && actor.send({ type: "update.layoutData", data });
  }, [data, actor]), null;
}), selector$2 = ({ context: context2 }) => ({
  // subject: context.subject,
  // view: state.context.view,
  initialized: context2.initialized.xydata && context2.initialized.xyflow,
  nodes: context2.xynodes,
  edges: context2.xyedges
}), RelationshipDetailsInner = memo$1(() => {
  const browser = useRelationshipDetails(), {
    initialized,
    nodes,
    edges
  } = useRelationshipDetailsState(selector$2, deepEqual);
  return /* @__PURE__ */ jsxs(
    BaseXYFlow,
    {
      id: browser.rootElementId,
      nodes,
      edges,
      className: cx(
        initialized ? "initialized" : "not-initialized",
        "likec4-relationship-details"
      ),
      nodeTypes: nodeTypes$1,
      edgeTypes: edgeTypes$2,
      onNodesChange: useCallbackRef$1((changes) => {
        browser.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef$1((changes) => {
        browser.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      fitViewPadding: 0.05,
      onNodeClick: useCallbackRef$1((e2, node2) => {
        e2.stopPropagation(), browser.send({ type: "xyflow.nodeClick", node: node2 });
      }),
      onEdgeClick: useCallbackRef$1((e2, edge) => {
        e2.stopPropagation(), browser.send({ type: "xyflow.edgeClick", edge });
      }),
      onPaneClick: useCallbackRef$1(() => {
        browser.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: useCallbackRef$1(() => {
        browser.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: useCallbackRef$1(() => {
        browser.send({ type: "xyflow.resized" });
      }),
      onEdgeMouseEnter: useCallbackRef$1((_event, edge) => {
        edge.data.hovered || browser.send({ type: "xyflow.edgeMouseEnter", edge });
      }),
      onEdgeMouseLeave: useCallbackRef$1((_event, edge) => {
        edge.data.hovered && browser.send({ type: "xyflow.edgeMouseLeave", edge });
      }),
      onSelectionChange: useCallbackRef$1((params) => {
        browser.send({ type: "xyflow.selectionChange", ...params });
      }),
      nodesDraggable: !1,
      nodesSelectable: !0,
      fitView: !1,
      pannable: !0,
      zoomable: !0,
      children: [
        /* @__PURE__ */ jsx(TopLeftPanel, {}),
        /* @__PURE__ */ jsx(Panel, { position: "top-right", children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), browser.close();
            },
            children: /* @__PURE__ */ jsx(IconX, {})
          }
        ) })
      ]
    }
  );
}), topLeftPanelselector = ({ context: context2 }) => ({
  subject: context2.subject,
  viewId: context2.viewId
}), TopLeftPanel = memo$1(() => {
  const { subject, viewId } = useRelationshipDetailsState(topLeftPanelselector, deepEqual), view = useLikeC4Model().findView(viewId);
  if (!view || !view.isDiagram())
    return null;
  const edges = [...view.edges()];
  let edge = "edgeId" in subject && e$8(subject.edgeId) ? edges.find((e2) => e2.id === subject.edgeId) : r(edges, (e2) => e2.source.element?.id === subject.source && e2.target.element?.id === subject.target) || r(edges, (e2) => (e2.source.element?.id === subject.source || isAncestor$1(e2.source.element?.id ?? "__", subject.source ?? "__")) && (e2.target.element?.id === subject.target || isAncestor$1(e2.target.element?.id ?? "__", subject.target ?? "__")));
  return edge ? /* @__PURE__ */ jsx(TopLeftPanelInner, { edge: edge.$edge, view: view.$view }) : null;
}), TopLeftPanelInner = ({ edge, view }) => {
  const browser = useRelationshipDetails(), edgeId = edge.id, [historyEdgeId, historyOps, { history, current }] = useStateHistory(edge.id);
  useEffect(() => {
    historyEdgeId !== edgeId && historyOps.set(edgeId);
  }, [edgeId]), useEffect(() => {
    historyEdgeId !== edgeId && browser.navigateTo(historyEdgeId);
  }, [historyEdgeId]);
  const hasStepBack = current > 0, hasStepForward = current + 1 < history.length;
  return /* @__PURE__ */ jsx(Panel, { position: "top-left", children: /* @__PURE__ */ jsx(Group, { gap: 4, wrap: "nowrap", children: /* @__PURE__ */ jsxs(AnimatePresence, { mode: "popLayout", children: [
    hasStepBack && /* @__PURE__ */ jsx(
      m.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.back();
            },
            children: /* @__PURE__ */ jsx(IconChevronLeft, {})
          }
        )
      },
      "back"
    ),
    hasStepForward && /* @__PURE__ */ jsx(
      m.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            variant: "default",
            color: "gray",
            onClick: (e2) => {
              e2.stopPropagation(), historyOps.forward();
            },
            children: /* @__PURE__ */ jsx(IconChevronRight, {})
          }
        )
      },
      "forward"
    ),
    /* @__PURE__ */ jsx(Group, { gap: "xs", wrap: "nowrap", ml: "sm", children: /* @__PURE__ */ jsx(SelectEdge, { edge, view }) })
  ] }) }) });
}, selectOverlays = (s) => s.context.overlays.map((overlay2) => {
  switch (overlay2.type) {
    case "relationshipsBrowser":
      return s.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s.children[overlay2.id]
      } : null;
    case "relationshipDetails":
      return s.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s.children[overlay2.id]
      } : null;
    case "elementDetails":
      return s.children[overlay2.id] ? {
        type: overlay2.type,
        actorRef: s.children[overlay2.id]
      } : null;
    default:
      nonexhaustive(overlay2);
  }
}).filter(e$b), compareSelectOverlays = (a, b) => a.length === b.length && a.every((overlay2, i) => overlay2.actorRef === b[i].actorRef);
function Overlays({ overlaysActorRef }) {
  const diagram = useDiagram(), overlays = useSelector(overlaysActorRef, selectOverlays, compareSelectOverlays), isMotionReduced = useReducedMotionConfig() ?? !1, isActiveOverlay = overlays.some((overlay2) => overlay2.type === "elementDetails");
  useEffect(() => {
    const xyflowRendererDom = diagram.getContext().xystore.getState().domNode?.querySelector(".react-flow__renderer");
    if (!xyflowRendererDom || isMotionReduced) return;
    const current = animate(xyflowRendererDom, {
      opacity: isActiveOverlay ? 0.7 : 1,
      filter: isActiveOverlay ? "grayscale(1)" : "grayscale(0)",
      transform: isActiveOverlay ? "perspective(400px) translateZ(-12px) translateY(3px)" : "translateY(0)"
    }, {
      duration: isActiveOverlay ? 0.35 : 0.17
    });
    let cleanupTm = null;
    return isActiveOverlay || (cleanupTm = setTimeout(() => {
      xyflowRendererDom.style.transform = "", xyflowRendererDom.style.filter = "", cleanupTm = null;
    }, 450)), () => {
      cleanupTm && clearTimeout(cleanupTm), current.stop();
    };
  }, [isActiveOverlay]);
  const close = (actorRef) => {
    overlaysActorRef.send({ type: "close", actorId: actorRef.id });
  }, overlaysReact = overlays.map((overlay2, index2) => {
    switch (overlay2.type) {
      case "relationshipsBrowser":
        return /* @__PURE__ */ jsx(
          Overlay,
          {
            overlayLevel: index2,
            onClose: () => close(overlay2.actorRef),
            children: /* @__PURE__ */ jsx(RelationshipsBrowser, { actorRef: overlay2.actorRef })
          },
          overlay2.actorRef.sessionId
        );
      case "relationshipDetails":
        return /* @__PURE__ */ jsx(
          Overlay,
          {
            overlayLevel: index2,
            onClose: () => close(overlay2.actorRef),
            children: /* @__PURE__ */ jsx(RelationshipDetails, { actorRef: overlay2.actorRef })
          },
          overlay2.actorRef.sessionId
        );
      case "elementDetails":
        return /* @__PURE__ */ jsx(
          ElementDetails,
          {
            actorRef: overlay2.actorRef,
            onClose: () => close(overlay2.actorRef)
          },
          overlay2.actorRef.sessionId
        );
      default:
        nonexhaustive(overlay2);
    }
  });
  return /* @__PURE__ */ jsx(DiagramFeatures.Overlays, { children: /* @__PURE__ */ jsx(ErrorBoundary, { onReset: () => overlaysActorRef.send({ type: "close.all" }), children: /* @__PURE__ */ jsx(LayoutGroup, { children: /* @__PURE__ */ jsx(AnimatePresence, { mode: "popLayout", children: overlaysReact }) }) }) });
}
const [SearchActorContext, useSearchActor] = createSafeContext$1("SearchActorContext"), selectSearchValue = (s) => s.context.searchValue;
function useSearch() {
  const searchActorRef = useSearchActor(), searchValue = useSelector(searchActorRef, selectSearchValue), updateSearch = useCallback((search) => {
    searchActorRef.send({ type: "change.search", search });
  }, [searchActorRef]);
  return [searchValue, updateSearch];
}
const selectNormalizedSearchValue = (s) => {
  const v = s.context.searchValue.trim().toLowerCase();
  return v.length > 1 ? v : "";
};
function useNormalizedSearch() {
  const searchActorRef = useSearchActor();
  return useDeferredValue(useSelector(searchActorRef, selectNormalizedSearchValue));
}
function useUpdateSearch() {
  const searchActorRef = useSearchActor();
  return useCallback((search) => {
    searchActorRef.send({ type: "change.search", search });
  }, [searchActorRef]);
}
const selectPickViewFor = (s) => s.context.pickViewFor;
function usePickViewFor() {
  const searchActorRef = useSearchActor();
  return useSelector(searchActorRef, selectPickViewFor);
}
const buttonFocused = css.raw({
  outline: "none",
  background: "mantine.colors.primary[8]",
  borderColor: "mantine.colors.primary[9]"
}), _treenodefocus = ".mantine-Tree-node:focus > .mantine-Tree-label &", button = css.raw({
  display: "flex",
  width: "100%",
  background: "mantine.colors.body",
  rounded: "sm",
  padding: "[12px 8px 12px 14px]",
  minHeight: "60px",
  gap: "2",
  // alignItems: 'flex-start',
  // transition: `all 50ms ${easings.inOut}`,
  border: "1px solid",
  borderColor: "mantine.colors.defaultBorder",
  // [titleColor]: '{colors.mantine.colors.dark[1]}',
  // [iconColor]: '{colors.mantine.colors.dimmed}',
  // [descriptionColor]: '{colors.mantine.colors.dimmed}',
  _hover: {
    ...buttonFocused,
    borderColor: "mantine.colors.primary[9]",
    background: "mantine.colors.primary[8]/60"
  },
  _focus: buttonFocused,
  [_treenodefocus]: buttonFocused,
  _dark: {
    borderColor: "transparent",
    background: "mantine.colors.dark[6]/80"
    // background: 'mantine.colors.dark[6]',
  },
  _light: {
    background: "mantine.colors.white/80",
    // [iconColor]: '{colors.mantine.colors.gray[6]}',
    // [titleColor]: '{colors.mantine.colors.gray[7]}',
    _hover: {
      borderColor: "mantine.colors.primary[6]",
      backgroundColor: "mantine.colors.primary[5]"
      // [iconColor]: '{colors.mantine.colors.primary[3])',
      // [titleColor]: '{colors.mantine.colors.primary[0])',
      // [descriptionColor]: '{colors.mantine.colors.primary[1]}',
    }
  }
}), focusable = "likec4-focusable", iconSize = {
  ref: "var(--likec4-icon-size, 24px)"
}, icon$1 = css.raw({
  color: {
    base: "mantine.colors.dimmed",
    _light: "mantine.colors.gray[5]",
    _groupHover: "mantine.colors.primary[0]",
    _groupFocus: "mantine.colors.primary[0]"
  },
  [_treenodefocus]: {
    color: "mantine.colors.primary[0]"
  },
  flex: `0 0 ${iconSize.ref}`,
  height: iconSize.ref,
  width: iconSize.ref,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  alignSelf: "flex-start",
  "--ti-size": iconSize.ref,
  "& svg, & img": {
    width: "100%",
    height: "auto",
    maxHeight: "100%",
    pointerEvents: "none"
  },
  "& img": {
    objectFit: "contain"
  },
  "&.likec4-shape-icon svg": {
    // color: `[var(${iconColor})]`,
    strokeWidth: 1.5
  }
  // [iconSize]: '24px',
  // [whenContainerIsNarrow]: {
  //   [iconSize]: '18px',
  // },
}), title$1 = css.raw({
  fontSize: "16px",
  fontWeight: 500,
  lineHeight: "1.1",
  ":where([data-disabled]) &": {
    opacity: 0.4
  },
  color: {
    base: "mantine.colors.dark[1]",
    _light: "mantine.colors.gray[7]",
    _groupHover: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.white"
    },
    _groupFocus: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.white"
    }
  },
  [_treenodefocus]: {
    color: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.white"
    }
  }
}), descriptionColor = css.raw({
  color: {
    base: "mantine.colors.dimmed",
    _groupHover: {
      base: "mantine.colors.primary[1]",
      _light: "mantine.colors.primary[0]"
    },
    _groupFocus: "mantine.colors.primary[0]"
  },
  [_treenodefocus]: {
    color: "mantine.colors.primary[0]"
  }
}), description = css.raw(descriptionColor, {
  marginTop: "1",
  fontSize: "12px",
  lineHeight: "1.4",
  ":where([data-disabled]) &": {
    opacity: 0.85
  }
}), emptyBoX = css({
  width: "100%",
  height: "100%",
  border: "2px dashed",
  borderColor: "mantine.colors.defaultBorder",
  rounded: "md",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  fontSize: "md",
  color: "mantine.colors.dimmed",
  padding: "md",
  paddingBlock: "xl"
}), buttonsva = sva({
  slots: ["root", "icon", "title", "description", "descriptionColor"],
  className: "search-button",
  base: {
    root: button,
    icon: icon$1,
    title: title$1,
    description,
    descriptionColor
  }
}), whenContainerIsNarrow = "@container likec4-tree (max-width: 450px)", treeNode = css({
  outline: "none",
  marginBottom: "2"
}), treeRoot = css(
  container$3.raw({
    containerName: "likec4-tree"
  }),
  {
    containerType: "inline-size",
    height: "100%"
  }
), treeLabel = css({
  display: "flex",
  alignItems: "baseline",
  outline: "none !important",
  gap: "1"
}), treeSubtree = css({
  marginTop: "2"
}), elementExpandIcon = css({
  color: "mantine.colors.dimmed"
}), elementTitleAndId = css({
  [whenContainerIsNarrow]: {
    flexDirection: "column-reverse",
    alignItems: "flex-start",
    gap: "0.5"
  }
}), elementId = css({
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "10px",
  lineHeight: "1.3",
  display: "block",
  fontWeight: 500,
  whiteSpace: "nowrap",
  padding: "[1px 5px]",
  borderRadius: "4px",
  background: "mantine.colors.dark[9]/30",
  _light: {
    background: "mantine.colors.gray[3]/20"
  }
}), elementIcon = css({
  "--likec4-icon-size": "24px",
  [whenContainerIsNarrow]: {
    "--likec4-icon-size": "18px"
  }
}), elementViewsCount = css({
  flex: 0,
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "10px",
  fontWeight: 500,
  whiteSpace: "nowrap",
  lineHeight: "1.1",
  [whenContainerIsNarrow]: {
    display: "none"
  }
});
function stopAndPrevent$1(e2) {
  e2.stopPropagation(), e2.preventDefault();
}
function centerY(element) {
  const rect = element.getBoundingClientRect();
  return rect.y + Math.floor(rect.height / 2);
}
function moveFocusToSearchInput(from) {
  if (!from) {
    console.error("moveFocusToSearchInput: from is null or undefined");
    return;
  }
  const root = from.getRootNode();
  if (!e$2(root.querySelector)) {
    console.error("moveFocusToSearchInput: root.querySelector is not a function");
    return;
  }
  let input2 = root.querySelector("[data-likec4-search-input]");
  if (input2) {
    const length = input2.value.length;
    input2.focus(), input2.setSelectionRange(length, length);
  }
}
function focusToFirstFoundElement(from) {
  if (!from) {
    console.error("focusToFirstFoundElement: from is null or undefined");
    return;
  }
  const root = from.getRootNode();
  if (!e$2(root.querySelector)) {
    console.error("focusToFirstFoundElement: root.querySelector is not a function");
    return;
  }
  root.querySelector(`[data-likec4-search] .${focusable}`)?.focus();
}
function queryAllFocusable(from, where, selector3 = `.${focusable}`) {
  if (!from)
    return console.error("queryAllFocusable: from is null or undefined"), [];
  const root = from.getRootNode();
  return e$2(root.querySelectorAll) ? [...root.querySelectorAll(`[data-likec4-search-${where}] ${selector3}`)] : (console.error("queryAllFocusable: root.querySelectorAll is not a function"), []);
}
function whenSearchAnimationEnds(callback) {
  setTimeout(callback, 300);
}
const _viewBtn = "likec4-view-btn", viewButton = cx(
  css({
    flexWrap: "nowrap",
    display: "flex",
    // '& .mantine-ThemeIcon-root': {
    //   color: `[var(${iconColor}, {colors.mantine.colors.dark[2]})]`,
    //   '--ti-size': '24px',
    // },
    "&[data-disabled] .mantine-ThemeIcon-root": {
      opacity: 0.45
    }
  }),
  _viewBtn
);
css({
  marginTop: "1",
  // transition: transitions.fast,
  // color: `[var(${descriptionColor}, {colors.mantine.colors.dimmed})]`,
  fontSize: "13px",
  lineHeight: "1.4",
  ":where(.likec4-view-btn[data-disabled]) &": {
    opacity: 0.85
  }
});
const NothingFound = () => /* @__PURE__ */ jsx(Box, { className: emptyBoX, children: "Nothing found" }), ViewsColumn = memo$1(() => {
  const ref = useRef(null);
  let views = [...useLikeC4Model().views()], search = useNormalizedSearch();
  return search && (search.startsWith("kind:") ? views = [] : views = views.filter((view) => search.startsWith("#") ? view.tags.some((tag) => tag.toLocaleLowerCase().includes(search.slice(1))) : `${view.id} ${view.title} ${view.description.text}`.toLocaleLowerCase().includes(search))), /* @__PURE__ */ jsxs(
    Stack,
    {
      ref,
      renderRoot: (props) => /* @__PURE__ */ jsx(MotionDiv, { layout: !0, ...props }),
      gap: 8,
      "data-likec4-search-views": !0,
      onKeyDown: (e2) => {
        if (e2.key === "ArrowLeft" || e2.key === "ArrowRight") {
          const maxY = e2.target.getBoundingClientRect().y, elementButtons = queryAllFocusable(ref.current, "elements", ".likec4-element-button");
          let elementButton = elementButtons.length > 1 ? elementButtons.find((el, i, all) => centerY(el) > maxY || i === all.length - 1) : null;
          elementButton ??= n$4(elementButtons), elementButton && (e2.stopPropagation(), elementButton.focus());
          return;
        }
      },
      children: [
        views.length === 0 && /* @__PURE__ */ jsx(NothingFound, {}),
        views.length > 0 && /* @__PURE__ */ jsx(VisuallyHidden, { children: /* @__PURE__ */ jsx(
          UnstyledButton,
          {
            "data-likec4-view": !0,
            tabIndex: -1,
            onFocus: (e2) => {
              e2.stopPropagation(), moveFocusToSearchInput(ref.current);
            }
          }
        ) }),
        views.map((view, i) => /* @__PURE__ */ jsx(MotionDiv, { layoutId: `@view${view.id}`, children: /* @__PURE__ */ jsx(
          ViewButton,
          {
            view,
            search,
            tabIndex: i === 0 ? 0 : -1
          }
        ) }, view.id))
      ]
    }
  );
}), btn$1 = buttonsva();
function ViewButton({ className, view, loop = !1, search, focusOnElement, ...props }) {
  const searchActorRef = useSearchActor(), diagram = useDiagram(), nextViewId = view.id, currentViewId = useCurrentViewId(), isCurrentView = nextViewId === currentViewId, navigate = () => {
    searchActorRef.send({ type: "close" }), whenSearchAnimationEnds(() => {
      if (isCurrentView && focusOnElement) {
        diagram.focusOnElement(focusOnElement);
        return;
      }
      diagram.navigateTo(nextViewId, void 0, focusOnElement);
    });
  };
  return /* @__PURE__ */ jsxs(
    UnstyledButton,
    {
      ...props,
      className: cx(btn$1.root, "group", focusable, viewButton, className),
      "data-likec4-view": view.id,
      ...isCurrentView && !focusOnElement && { "data-disabled": !0 },
      onClick: (e2) => {
        e2.stopPropagation(), navigate();
      },
      onKeyDown: createScopedKeydownHandler({
        siblingSelector: "[data-likec4-view]",
        parentSelector: "[data-likec4-search-views]",
        activateOnFocus: !1,
        loop,
        orientation: "vertical",
        onKeyDown: (e2) => {
          e2.nativeEvent.code === "Space" && (e2.stopPropagation(), navigate());
        }
      }),
      children: [
        /* @__PURE__ */ jsx(ThemeIcon, { variant: "transparent", className: btn$1.icon, children: view.isDeploymentView() ? /* @__PURE__ */ jsx(IconStack2, { stroke: 1.8 }) : /* @__PURE__ */ jsx(IconZoomScan, { stroke: 1.8 }) }),
        /* @__PURE__ */ jsxs(Box, { style: { flexGrow: 1 }, children: [
          /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", children: [
            /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: search, className: btn$1.title, children: view.title || "untitled" }),
            isCurrentView && /* @__PURE__ */ jsx(Badge, { size: "xs", fz: 9, radius: "sm", children: "current" })
          ] }),
          /* @__PURE__ */ jsx(
            Highlight,
            {
              highlight: view.description.nonEmpty ? search : "",
              component: "div",
              className: btn$1.description,
              lineClamp: 1,
              children: view.description.text || "No description"
            }
          )
        ] })
      ]
    }
  );
}
const btn = buttonsva(), ElementsColumn = memo$1(() => {
  const model = useLikeC4Model(), search = useNormalizedSearch(), data = useMemo(() => {
    const searchTerms = search.split(".");
    let elements;
    e$3(searchTerms) || searchTerms[0] === "kind:" ? elements = model.elements() : elements = ifilter(model.elements(), (element) => search.startsWith("kind:") ? element.kind.toLocaleLowerCase().startsWith(search.slice(5)) : search.startsWith("#") ? element.tags.some((tag) => tag.toLocaleLowerCase().includes(search.slice(1))) : (element.title + " " + element.id + " " + element.summary.text).toLocaleLowerCase().includes(search));
    const byid = {}, { all, roots } = t$6(
      [...elements],
      sortParentsFirst,
      t$g((acc, element) => {
        const treeItem = {
          label: element.title,
          value: element.id,
          element,
          searchTerms,
          children: []
        };
        byid[treeItem.value] = treeItem;
        const parent = acc.all.findLast((root) => isAncestor(root.value, treeItem.value));
        return parent ? (parent.children.push(treeItem), parent.children.length > 1 && parent.children.sort(sortByLabel)) : acc.roots.push(treeItem), acc.all.push(treeItem), acc;
      }, {
        all: [],
        roots: []
      })
    );
    return {
      all,
      byid,
      roots: roots.sort(sortByLabel)
    };
  }, [model, search]), handleClick2 = useHandleElementSelection();
  return data.all.length === 0 ? /* @__PURE__ */ jsx(NothingFound, {}) : /* @__PURE__ */ jsx(ElementsTree, { data, handleClick: handleClick2 });
}), setHoveredNode = () => {
};
function ElementsTree({
  data: {
    all,
    byid,
    roots
  },
  handleClick: handleClick2
}) {
  const tree = useTree({
    multiple: !1
  });
  tree.setHoveredNode = setHoveredNode, useEffect(() => {
    tree.collapseAllNodes();
    for (const nd of all)
      nd.children.length > 0 && tree.expand(nd.value);
  }, [all]);
  const onKeyDownCapture = useCallbackRef((e2) => {
    const target = e2.target, id = target.getAttribute("data-value"), node2 = !!id && byid[id];
    if (node2) {
      if (e2.key === "ArrowUp") {
        id === roots[0]?.value && (stopAndPrevent$1(e2), moveFocusToSearchInput(target));
        return;
      }
      if (e2.key === "ArrowRight") {
        if (node2.children.length > 0 && tree.expandedState[id] === !1)
          return;
        const maxY = (e2.target.querySelector(".mantine-Tree-label") ?? target).getBoundingClientRect().y, viewButtons = queryAllFocusable(target, "views");
        let view = viewButtons.length > 1 ? viewButtons.find((el, i, all2) => centerY(el) > maxY || i === all2.length - 1) : null;
        view ??= n$4(viewButtons), view && (stopAndPrevent$1(e2), view.focus());
        return;
      }
      if (e2.key === " " || e2.key === "Enter") {
        stopAndPrevent$1(e2), handleClick2(node2.element);
        return;
      }
    }
  });
  return /* @__PURE__ */ jsx(
    Tree,
    {
      "data-likec4-search-elements": !0,
      allowRangeSelection: !1,
      clearSelectionOnOutsideClick: !0,
      selectOnClick: !1,
      tree,
      data: roots,
      levelOffset: "lg",
      classNames: {
        root: treeRoot,
        node: cx(focusable, treeNode),
        label: treeLabel,
        subtree: treeSubtree
      },
      onKeyDownCapture,
      renderNode: ElementTreeNode
    }
  );
}
function ElementTreeNode({ node: node2, elementProps, hasChildren, expanded }) {
  const { element, searchTerms } = node2, elementIcon$12 = IconOrShapeRenderer({
    element: {
      id: element.id,
      title: element.title,
      shape: element.shape,
      icon: element.icon
    },
    className: cx(btn.icon, elementIcon)
  }), views = [...element.views()], handleClick2 = useHandleElementSelection(), key2 = `@tree.${node2.value}`;
  return /* @__PURE__ */ jsxs(MotionDiv, { layoutId: key2, ...elementProps, children: [
    /* @__PURE__ */ jsx(
      ActionIcon,
      {
        variant: "transparent",
        size: 16,
        tabIndex: -1,
        className: cx(elementExpandIcon),
        style: {
          visibility: hasChildren ? "visible" : "hidden"
        },
        children: /* @__PURE__ */ jsx(
          IconChevronRight,
          {
            stroke: 3.5,
            style: {
              transition: "transform 150ms ease",
              transform: `rotate(${expanded ? "90deg" : "0"})`,
              width: "100%"
            }
          }
        )
      }
    ),
    /* @__PURE__ */ jsxs(
      UnstyledButton,
      {
        component: MotionButton,
        layout: !0,
        tabIndex: -1,
        "data-value": element.id,
        className: cx(btn.root, "group", "likec4-element-button"),
        ...views.length > 0 && {
          onClick: (e2) => {
            (!hasChildren || expanded) && (e2.stopPropagation(), handleClick2(element));
          }
        },
        children: [
          elementIcon$12,
          /* @__PURE__ */ jsxs(Box$1, { style: { flexGrow: 1 }, children: [
            /* @__PURE__ */ jsxs(Group, { gap: "xs", wrap: "nowrap", align: "center", className: elementTitleAndId, children: [
              /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: searchTerms, className: btn.title, children: node2.label }),
              /* @__PURE__ */ jsx(Tooltip$6, { label: element.id, withinPortal: !1, fz: "xs", disabled: !element.id.includes("."), children: /* @__PURE__ */ jsx(
                Highlight,
                {
                  component: "div",
                  highlight: searchTerms,
                  className: cx(elementId, btn.descriptionColor),
                  children: nameFromFqn$1(element.id)
                }
              ) })
            ] }),
            /* @__PURE__ */ jsx(Highlight, { component: "div", highlight: searchTerms, className: btn.description, lineClamp: 1, children: element.summary.text || "No description" })
          ] }),
          /* @__PURE__ */ jsx(Text, { component: "div", className: cx(elementViewsCount, btn.descriptionColor), fz: "xs", children: views.length === 0 ? "No views" : /* @__PURE__ */ jsxs(Fragment, { children: [
            views.length,
            " view",
            views.length > 1 ? "s" : ""
          ] }) })
        ]
      }
    )
  ] });
}
function useHandleElementSelection() {
  const diagram = useDiagram(), searchActorRef = useSearchActor();
  return useCallbackRef((element) => {
    const views = [...element.views()];
    if (views.length === 0)
      return;
    const elementFqn = element.id, onlyOneViewId = t$f(views)?.id;
    if (!onlyOneViewId) {
      searchActorRef.send({ type: "pickview.open", elementFqn });
      return;
    }
    const isSameView = onlyOneViewId === diagram.currentView.id;
    searchActorRef.send({ type: "close" }), whenSearchAnimationEnds(() => {
      if (isSameView) {
        diagram.focusOnElement(elementFqn);
        return;
      }
      diagram.navigateTo(onlyOneViewId, void 0, elementFqn);
    });
  });
}
const input = css({
  border: "transparent",
  background: {
    base: "transparent",
    _focusWithin: {
      base: "mantine.colors.gray[4]/55 !important",
      _dark: "mantine.colors.dark[5]/55 !important"
    },
    _groupHover: {
      base: "mantine.colors.gray[3]/35",
      _dark: "mantine.colors.dark[5]/35"
    }
  }
}), pickviewBackdrop = css({
  position: "absolute",
  inset: "0",
  width: "100%",
  height: "100%",
  backgroundColor: "[rgb(34 34 34 / 0.7)]",
  zIndex: 902,
  backdropFilter: "auto",
  backdropBlur: "10px",
  _light: {
    backgroundColor: "[rgb(255 255 255 / 0.6)]"
  }
}), pickview = css({
  position: "absolute",
  top: "[2rem]",
  left: "[50%]",
  width: "100%",
  maxWidth: "600px",
  minWidth: "200px",
  transform: "translateX(-50%)",
  zIndex: 903
}), pickviewGroup = css({
  marginTop: "2",
  "& + &": {
    marginTop: "[32px]"
  }
});
css({
  height: [
    "100%",
    "100cqh"
  ],
  "& .mantine-ScrollArea-viewport": {
    minHeight: "100%",
    "& > div": {
      minHeight: "100%",
      height: "100%"
    }
  }
});
function PickView({ elementFqn }) {
  const searchActorRef = useSearchActor(), element = useLikeC4Model().element(elementFqn), scoped = [], others = [];
  for (const view of element.views())
    view.viewOf === element ? scoped.push(view) : others.push(view);
  const closePickView = () => {
    searchActorRef.send({ type: "pickview.close" });
  };
  return useWindowEvent(
    "keydown",
    (event) => {
      try {
        event.key === "Escape" && (event.stopPropagation(), event.preventDefault(), closePickView());
      } catch (e2) {
        console.warn(e2);
      }
    },
    {
      capture: !0
    }
  ), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      MotionDiv,
      {
        className: pickviewBackdrop,
        onClick: (e2) => {
          e2.stopPropagation(), closePickView();
        }
      },
      "pickview-backdrop"
    ),
    /* @__PURE__ */ jsx(FocusTrap, { children: /* @__PURE__ */ jsxs(
      MotionDiv,
      {
        initial: {
          opacity: 0,
          scale: 0.95,
          originY: 0,
          translateX: "-50%",
          translateY: -20
        },
        animate: {
          opacity: 1,
          scale: 1,
          translateY: 0
        },
        exit: {
          opacity: 0,
          scale: 0.98,
          translateY: -20,
          transition: {
            duration: 0.1
          }
        },
        className: pickview,
        "data-likec4-search-views": !0,
        children: [
          /* @__PURE__ */ jsxs(Group, { px: "sm", py: "md", justify: "space-between", children: [
            /* @__PURE__ */ jsx(Title$1, { order: 2, lh: 1, children: "Select view" }),
            /* @__PURE__ */ jsx(
              ActionIcon,
              {
                size: "md",
                variant: "default",
                onClick: (e2) => {
                  e2.stopPropagation(), closePickView();
                },
                children: /* @__PURE__ */ jsx(IconX, {})
              }
            )
          ] }),
          /* @__PURE__ */ jsxs(ScrollAreaAutosize, { mah: "calc(100vh - 110px)", type: "never", children: [
            scoped.length > 0 && /* @__PURE__ */ jsxs(Stack, { gap: "sm", px: "sm", className: pickviewGroup, children: [
              /* @__PURE__ */ jsx(Title$1, { order: 6, c: "dimmed", children: "scoped views of the element" }),
              scoped.map((view, i) => /* @__PURE__ */ jsx(
                ViewButton,
                {
                  view,
                  search: "",
                  loop: !0,
                  focusOnElement: elementFqn,
                  mod: {
                    autofocus: i === 0
                  }
                },
                view.id
              ))
            ] }),
            others.length > 0 && /* @__PURE__ */ jsxs(Stack, { gap: "sm", px: "sm", className: pickviewGroup, children: [
              /* @__PURE__ */ jsx(Title$1, { order: 6, c: "dimmed", children: "views including this element" }),
              others.map((view, i) => /* @__PURE__ */ jsx(
                ViewButton,
                {
                  view,
                  search: "",
                  loop: !0,
                  focusOnElement: elementFqn,
                  mod: {
                    autofocus: i === 0 && scoped.length === 0
                  }
                },
                view.id
              ))
            ] })
          ] })
        ]
      },
      "pickview"
    ) })
  ] });
}
function SearchByTags() {
  const ref = useRef(null);
  let tags = useLikeC4Model().tagsSortedByUsage, setSearch = useUpdateSearch(), search = useNormalizedSearch(), countBefore = tags.length, isFiltered = !1;
  if (search.startsWith("#")) {
    const searchTag = search.slice(1);
    tags = tags.filter(({ tag }) => tag.toLocaleLowerCase().includes(searchTag)), isFiltered = tags.length !== countBefore;
  }
  return tags.length === 0 ? null : (tags = tags.slice(0, 15), /* @__PURE__ */ jsxs(
    HStack,
    {
      ref,
      css: {
        gap: "md",
        paddingLeft: "[48px]",
        flexWrap: "nowrap"
      },
      children: [
        /* @__PURE__ */ jsx(
          HStack,
          {
            css: {
              gap: "1.5",
              // 6px
              flexWrap: "wrap",
              opacity: isFiltered ? 1 : 0.3,
              grayscale: isFiltered ? 0 : 0.9,
              filter: "auto",
              transition: "fast",
              _groupHover: {
                opacity: 1,
                grayscale: 0
              },
              _groupFocusWithin: {
                opacity: 1,
                grayscale: 0
              }
            },
            children: tags.map(({ tag }) => /* @__PURE__ */ jsx(
              ElementTag,
              {
                tag,
                className: css({
                  userSelect: "none",
                  cursor: "pointer"
                }),
                onClick: (e2) => {
                  e2.stopPropagation(), setSearch(`#${tag}`), setTimeout(() => {
                    focusToFirstFoundElement(ref.current);
                  }, 350);
                }
              },
              tag
            ))
          }
        ),
        isFiltered && /* @__PURE__ */ jsx(
          Button,
          {
            size: "compact-xs",
            variant: "light",
            onClick: (e2) => {
              e2.stopPropagation(), setSearch(""), moveFocusToSearchInput(ref.current);
            },
            rightSection: /* @__PURE__ */ jsx(IconX, { size: 14 }),
            children: "Clear"
          }
        )
      ]
    }
  ));
}
function startingWithKind(search) {
  return search.match(/^(k|ki|kin|kind|kind:)$/) != null;
}
const SEARCH_PREFIXES = ["#", "kind:"], LikeC4SearchInput = memo$1(() => {
  const searchActorRef = useSearchActor(), likec4model = useLikeC4Model(), inputRef = useRef(null), { ref, focused: focused2 } = useFocusWithin(), [search, setSearch] = useSearch(), combobox = useCombobox({
    scrollBehavior: "smooth",
    loop: !1
  });
  useWindowEvent(
    "keydown",
    (event) => {
      try {
        !focused2 && (event.key === "Backspace" || event.key.startsWith("Arrow") || event.key.match(/^\p{L}$/u)) && moveFocusToSearchInput(inputRef.current);
      } catch (e2) {
        console.warn(e2);
      }
    }
  );
  let options = [], isExactMatch = !1;
  switch (!0) {
    // case search === '' && isEmptyForSomeTime === '': {
    //   options = SEARCH_PREFIXES.map((prefix) => (
    //     <ComboboxOption value={prefix} key={prefix}>
    //       <Text component="span" opacity={.5} mr={4} fz={'sm'}>Search by</Text>
    //       {prefix}
    //     </ComboboxOption>
    //   ))
    //   break
    // }
    case search.startsWith("#"): {
      const searchTag = search.toLocaleLowerCase().slice(1), alloptions = likec4model.tags.filter((tag) => tag.toLocaleLowerCase().includes(searchTag));
      alloptions.length === 0 ? (isExactMatch = !1, options = [
        /* @__PURE__ */ jsx(ComboboxEmpty, { children: "No tags found" }, "empty-tags")
      ]) : (isExactMatch = likec4model.tags.some((tag) => tag.toLocaleLowerCase() === searchTag), options = alloptions.map((tag) => /* @__PURE__ */ jsxs(ComboboxOption, { value: `#${tag}`, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "#" }),
        tag
      ] }, tag)));
      break;
    }
    case search.startsWith("kind:"):
    case startingWithKind(search): {
      const term = search.length > 5 ? search.slice(5).toLocaleLowerCase() : "";
      let alloptions = t$4(likec4model.specification.elements);
      term && (alloptions = alloptions.filter((kind) => kind.toLocaleLowerCase().includes(term))), alloptions.length === 0 ? (isExactMatch = !1, options = [
        /* @__PURE__ */ jsx(ComboboxEmpty, { children: "No kinds found" }, "empty-kinds")
      ]) : (isExactMatch = alloptions.some((kind) => kind.toLocaleLowerCase() === term), options = alloptions.map((kind) => /* @__PURE__ */ jsxs(ComboboxOption, { value: `kind:${kind}`, children: [
        /* @__PURE__ */ jsx(Text, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "kind:" }),
        kind
      ] }, kind)));
      break;
    }
  }
  return /* @__PURE__ */ jsxs(
    Combobox,
    {
      onOptionSubmit: (optionValue) => {
        setSearch(optionValue), combobox.resetSelectedOption(), SEARCH_PREFIXES.includes(optionValue) || (combobox.closeDropdown(), setTimeout(() => {
          focusToFirstFoundElement(inputRef.current);
        }, 350));
      },
      width: "max-content",
      position: "bottom-start",
      shadow: "md",
      offset: {
        mainAxis: 4,
        crossAxis: 50
      },
      store: combobox,
      withinPortal: !1,
      children: [
        /* @__PURE__ */ jsx(ComboboxTarget, { children: /* @__PURE__ */ jsx(
          Input,
          {
            ref: useMergedRef(inputRef, ref),
            placeholder: "Search by title, description or start with # or kind:",
            autoFocus: !0,
            "data-autofocus": !0,
            "data-likec4-search-input": !0,
            tabIndex: 0,
            classNames: {
              input
            },
            size: "lg",
            value: search,
            leftSection: /* @__PURE__ */ jsx(IconSearch, { style: { width: rem(20) }, stroke: 2 }),
            rightSection: /* @__PURE__ */ jsx(
              Input.ClearButton,
              {
                onClick: (e2) => {
                  e2.stopPropagation();
                  const openedWithSearch = searchActorRef.getSnapshot().context.openedWithSearch;
                  search === "" || search === openedWithSearch ? searchActorRef.send({ type: "close" }) : setSearch("");
                }
              }
            ),
            rightSectionPointerEvents: "auto",
            onChange: (event) => {
              setSearch(event.currentTarget.value), combobox.openDropdown(), combobox.updateSelectedOptionIndex();
            },
            onClick: () => combobox.openDropdown(),
            onFocus: () => combobox.openDropdown(),
            onBlur: () => combobox.closeDropdown(),
            onKeyDownCapture: (e2) => {
              if (e2.key === "Tab") {
                switch (!0) {
                  case combobox.getSelectedOptionIndex() >= 0:
                    return combobox.clickSelectedOption(), stopAndPrevent$1(e2);
                  case options.length === 1:
                    return combobox.selectFirstOption() && combobox.clickSelectedOption(), stopAndPrevent$1(e2);
                  case startingWithKind(search):
                    return setSearch("kind:"), stopAndPrevent$1(e2);
                }
                return;
              }
              if (e2.key === "Backspace" && combobox.dropdownOpened) {
                if (search === "kind:")
                  return setSearch(""), combobox.resetSelectedOption(), stopAndPrevent$1(e2);
                if (search.startsWith("kind:") && isExactMatch)
                  return setSearch("kind:"), combobox.resetSelectedOption(), stopAndPrevent$1(e2);
                if (search.startsWith("#") && isExactMatch)
                  return setSearch("#"), combobox.resetSelectedOption(), stopAndPrevent$1(e2);
              }
              if (e2.key === "Escape" && combobox.dropdownOpened && options.length > 0) {
                stopAndPrevent$1(e2), combobox.closeDropdown();
                return;
              }
              if (e2.key === "ArrowUp" && combobox.dropdownOpened && search === "" && combobox.getSelectedOptionIndex() === 0) {
                combobox.closeDropdown(), stopAndPrevent$1(e2);
                return;
              }
              if (e2.key === "ArrowDown" && (!combobox.dropdownOpened || options.length === 0 || isExactMatch || // reached the last option and the search is empty
              search === "" && combobox.getSelectedOptionIndex() === options.length - 1)) {
                combobox.closeDropdown(), stopAndPrevent$1(e2), focusToFirstFoundElement(inputRef.current);
                return;
              }
            }
          }
        ) }),
        /* @__PURE__ */ jsx(ComboboxDropdown, { hidden: options.length === 0, style: { minWidth: 300 }, children: /* @__PURE__ */ jsx(ComboboxOptions, { children: /* @__PURE__ */ jsx(ScrollAreaAutosize, { mah: "min(322px, calc(100cqh - 50px))", type: "scroll", children: options }) }) })
      ]
    }
  );
}), dialog = css({
  backgroundColor: "[rgb(34 34 34 / var(--_opacity, 95%))]",
  _light: {
    backgroundColor: "[rgb(250 250 250 / var(--_opacity, 95%))]"
  },
  backdropFilter: "auto",
  backdropBlur: "var(--_blur, 10px)"
  //   base: `[rgb(34 34 34 / var(${backdropOpacity}))]`,
  //   _light: `[rgb(255 255 255/ var(${backdropOpacity}))]`,
  // },
}), body = css({
  // containerName: 'likec4-search',
  // containerType: 'size',
  // position: 'fixed',
  // zIndex: 901,
  // top: '0',
  // left: '0',
  width: "100%",
  height: "100%",
  maxHeight: "100vh",
  overflow: "hidden",
  display: "flex",
  flexDirection: "column",
  justifyContent: "stretch",
  gap: "sm",
  paddingTop: "[20px]",
  paddingLeft: "md",
  paddingRight: "md",
  paddingBottom: "sm",
  background: "[transparent]"
  // backgroundColor: {
  //   _dark: `[rgb(34 34 34 / 0.95)]`,
  //   _light: `[rgb(255 255 255/ 0.95)]`,
  // },
}), selectIsOpened = (s) => !s.matches("inactive");
function Search({ searchActorRef }) {
  const isOpened = useSelector(searchActorRef, selectIsOpened), openSearch = () => {
    searchActorRef.send({ type: "open" });
  }, close = useCallbackRef(() => {
    searchActorRef.send({ type: "close" });
  });
  return useHotkeys([
    ["mod+k", openSearch, {
      preventDefault: !0
    }],
    ["mod+f", openSearch, {
      preventDefault: !0
    }]
  ]), /* @__PURE__ */ jsx(SearchActorContext, { value: searchActorRef, children: /* @__PURE__ */ jsx(DiagramFeatures.Overlays, { children: /* @__PURE__ */ jsx(ErrorBoundary$1, { FallbackComponent: ErrorFallback, onReset: close, children: /* @__PURE__ */ jsx(AnimatePresence, { children: isOpened && /* @__PURE__ */ jsx(
    Overlay,
    {
      fullscreen: !0,
      withBackdrop: !1,
      backdrop: {
        opacity: 0.9
      },
      classes: {
        dialog,
        body
      },
      openDelay: 0,
      onClose: close,
      "data-likec4-search": "true",
      children: /* @__PURE__ */ jsx(SearchOverlay, { searchActorRef })
    }
  ) }) }) }) });
}
const scrollArea = css({
  height: [
    "100%",
    "100cqh"
  ],
  "& .mantine-ScrollArea-viewport": {
    minHeight: "100%",
    "& > div": {
      minHeight: "100%",
      height: "100%"
    }
  }
}), SearchOverlay = ({ searchActorRef }) => {
  const ref = useRef(null), pickViewFor = usePickViewFor();
  return useTimeoutEffect(() => {
    e$8(searchActorRef.getSnapshot().context.openedWithSearch) && focusToFirstFoundElement(ref.current);
  }, 150), /* @__PURE__ */ jsxs(Box, { ref, display: "contents", children: [
    /* @__PURE__ */ jsx(
      Group,
      {
        className: "group",
        wrap: "nowrap",
        onClick: (e2) => {
          e2.stopPropagation(), moveFocusToSearchInput(ref.current);
        },
        children: /* @__PURE__ */ jsxs(VStack, { flex: 1, px: "sm", children: [
          /* @__PURE__ */ jsx(LikeC4SearchInput, {}),
          /* @__PURE__ */ jsx(SearchByTags, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxs(Grid, { children: [
      /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(Title$1, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Elements" }) }),
      /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(Title$1, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Views" }) })
    ] }),
    /* @__PURE__ */ jsxs(
      Grid,
      {
        className: css({
          containerName: "likec4-search-elements",
          containerType: "size",
          overflow: "hidden",
          flexGrow: 1
        }),
        children: [
          /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(
            ScrollArea,
            {
              type: "scroll",
              className: scrollArea,
              pr: "xs",
              scrollbars: "y",
              children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-elements", children: /* @__PURE__ */ jsx(ElementsColumn, {}) }) })
            }
          ) }),
          /* @__PURE__ */ jsx(GridCol, { span: 6, children: /* @__PURE__ */ jsx(
            ScrollArea,
            {
              type: "scroll",
              className: scrollArea,
              pr: "xs",
              scrollbars: "y",
              children: /* @__PURE__ */ jsx(AnimatePresence, { children: /* @__PURE__ */ jsx(LayoutGroup, { id: "likec4-search-views", children: /* @__PURE__ */ jsx(ViewsColumn, {}) }) })
            }
          ) })
        ]
      }
    ),
    pickViewFor && /* @__PURE__ */ jsx(PickView, { elementFqn: pickViewFor })
  ] });
}, _actorLogic = setup({
  delays: {
    "open timeout": ({ context: context2 }) => context2.openTimeout,
    "close timeout": 600,
    "long idle": 1500
  },
  actions: {
    "update edgeId": assign(({ context: context2, event }) => (assertEvent(event, ["xyedge.select", "xyedge.mouseEnter"]), {
      edgeId: event.edgeId,
      edgeSelected: context2.edgeSelected || event.type === "xyedge.select"
    })),
    "increase open timeout": assign(() => ({
      openTimeout: 800
    })),
    "decrease open timeout": assign(() => ({
      openTimeout: 300
    })),
    "reset edgeId": assign({
      edgeId: null,
      edgeSelected: !1
    })
  },
  guards: {
    "edge was selected": ({ context: context2 }) => context2.edgeSelected,
    "edge was hovered": ({ context: context2 }) => !context2.edgeSelected
  }
}).createMachine({
  id: "breadcrumbs",
  context: () => ({
    edgeId: null,
    edgeSelected: !1,
    openTimeout: 800
  }),
  initial: "idle",
  on: {
    close: {
      target: "#idle",
      actions: [
        "reset edgeId",
        "increase open timeout"
      ]
    }
  },
  states: {
    idle: {
      id: "idle",
      on: {
        "xyedge.mouseEnter": {
          target: "opening",
          actions: "update edgeId"
        },
        "xyedge.select": {
          target: "active",
          actions: "update edgeId"
        }
      },
      after: {
        "long idle": {
          actions: "increase open timeout"
        }
      }
    },
    opening: {
      on: {
        "xyedge.mouseLeave": {
          target: "idle"
        },
        "xyedge.select": {
          target: "active",
          actions: "update edgeId"
        }
      },
      after: {
        "open timeout": {
          actions: "decrease open timeout",
          target: "active"
        }
      }
    },
    active: {
      tags: ["opened"],
      initial: "opened",
      exit: "reset edgeId",
      on: {
        "xyedge.unselect": {
          target: "idle",
          actions: "increase open timeout"
        },
        "xyedge.select": {
          actions: "update edgeId"
        }
      },
      states: {
        opened: {
          on: {
            "dropdown.mouseEnter": {
              target: "hovered"
            },
            "xyedge.mouseLeave": {
              guard: "edge was hovered",
              target: "closing"
            }
          }
        },
        hovered: {
          on: {
            "dropdown.mouseLeave": [
              {
                guard: "edge was selected",
                target: "opened"
              },
              {
                target: "closing"
              }
            ]
          }
        },
        closing: {
          on: {
            "xyedge.mouseEnter": {
              guard: "edge was hovered",
              target: "opened",
              actions: "update edgeId"
            },
            "xyedge.select": {
              target: "opened",
              actions: "update edgeId"
            },
            "dropdown.mouseEnter": {
              target: "hovered"
            }
          },
          after: {
            "close timeout": {
              target: "#idle"
            }
          }
        }
      }
    }
  }
}), RelationshipPopoverActorLogic = _actorLogic, endpoint = css({
  display: "block",
  fontSize: "xxs",
  fontWeight: 500,
  whiteSpace: "nowrap",
  paddingX: "1",
  paddingY: "0.5",
  borderRadius: "[2px]",
  background: {
    _light: "var(--likec4-palette-fill)/90",
    _dark: "var(--likec4-palette-fill)/60"
  },
  lineHeight: "1",
  color: {
    _light: "var(--likec4-palette-hiContrast)",
    _dark: "var(--likec4-palette-loContrast)"
  }
}), title = css({
  whiteSpaceCollapse: "preserve-breaks",
  fontSize: "sm",
  lineHeight: "sm",
  userSelect: "all"
});
function selectDiagramContext(c) {
  let selected = null;
  for (const edge of c.xyedges)
    if (edge.selected) {
      if (selected) {
        selected = null;
        break;
      }
      selected = edge.data.id;
    }
  return {
    viewId: c.view.id,
    selected
  };
}
const RelationshipPopover = memo$1(() => {
  const likec4model = useLikeC4Model(), actorRef = useActorRef(RelationshipPopoverActorLogic), diagram = useDiagram(), { viewId, selected } = useDiagramContext(selectDiagramContext), openedEdgeId = useSelector(actorRef, (s) => s.hasTag("opened") ? s.context.edgeId : null);
  useOnDiagramEvent("navigateTo", () => {
    actorRef.send({ type: "close" });
  }), useOnDiagramEvent("edgeMouseEnter", ({ edge }) => {
    actorRef.send({ type: "xyedge.mouseEnter", edgeId: edge.data.id });
  }), useOnDiagramEvent("edgeMouseLeave", () => {
    actorRef.send({ type: "xyedge.mouseLeave" });
  }), useOnDiagramEvent("walkthroughStarted", () => {
    actorRef.send({ type: "close" });
  }), useEffect(() => {
    selected ? actorRef.send({ type: "xyedge.select", edgeId: selected }) : actorRef.send({ type: "xyedge.unselect" });
  }, [selected]);
  const onMouseEnter = useCallback((event) => {
    if (!openedEdgeId)
      return;
    actorRef.send({ type: "dropdown.mouseEnter" });
    const edge = diagram.findEdge(openedEdgeId);
    edge && !edge.data.hovered && diagram.send({ type: "xyflow.edgeMouseEnter", edge, event });
  }, [actorRef, diagram, openedEdgeId]), onMouseLeave = useCallback((event) => {
    if (!openedEdgeId)
      return;
    actorRef.send({ type: "dropdown.mouseLeave" });
    const edge = diagram.findEdge(openedEdgeId);
    edge?.data.hovered && diagram.send({ type: "xyflow.edgeMouseLeave", edge, event });
  }, [actorRef, diagram, openedEdgeId]), { diagramEdge, sourceNode, targetNode } = useDiagramContext(
    (ctx) => {
      const diagramEdge2 = openedEdgeId ? findDiagramEdge(ctx, openedEdgeId) : null, sourceNode2 = diagramEdge2 ? findDiagramNode(ctx, diagramEdge2.source) : null, targetNode2 = diagramEdge2 ? findDiagramNode(ctx, diagramEdge2.target) : null;
      return {
        diagramEdge: diagramEdge2,
        sourceNode: sourceNode2,
        targetNode: targetNode2
      };
    },
    shallowEqual,
    [openedEdgeId]
  );
  if (!diagramEdge || !sourceNode || !targetNode || e$3(diagramEdge.relations))
    return null;
  const [direct, nested] = t$6(
    diagramEdge.relations,
    t$a((id) => {
      try {
        return likec4model.relationship(id);
      } catch (e2) {
        return console.error(
          `View is cached and likec4model missing relationship ${id} from ${sourceNode.id} -> ${targetNode.id}`,
          e2
        ), null;
      }
    }),
    n$2(e$8),
    t$l((r2) => r2.source.id === sourceNode.id && r2.target.id === targetNode.id)
  );
  return direct.length === 0 && nested.length === 0 ? (console.warn("No relationships found  diagram edge", {
    diagramEdge,
    sourceNode,
    targetNode
  }), null) : /* @__PURE__ */ jsx(PortalToContainer, { children: /* @__PURE__ */ jsx(
    RelationshipPopoverInternal,
    {
      viewId,
      direct,
      nested,
      diagramEdge,
      sourceNode,
      targetNode,
      onMouseEnter,
      onMouseLeave
    }
  ) });
}), getEdgeLabelElement = (edgeId, container2) => container2?.querySelector(`.likec4-edge-label[data-edge-id="${edgeId}"]`) ?? container2?.querySelector(`.likec4-edge-middle-point[data-edge-id="${edgeId}"]`) ?? null, POPOVER_PADDING = 8, RelationshipPopoverInternal = ({
  viewId,
  diagramEdge,
  direct,
  nested,
  sourceNode,
  targetNode,
  onMouseEnter,
  onMouseLeave
}) => {
  const ref = useRef(null), { enableNavigateTo, enableVscode, enableCompareWithLatest } = useEnabledFeatures(), { onOpenSource } = useDiagramEventHandlers(), containerRef = useRootContainerRef(), [referenceEl, setReferenceEl] = useState(null);
  useLayoutEffect(() => {
    setReferenceEl(getEdgeLabelElement(diagramEdge.id, containerRef.current));
  }, [diagramEdge]), useEffect(() => {
    const reference = referenceEl, popper = ref.current;
    if (!reference || !popper)
      return;
    let wasCanceled = !1;
    const cleanup = autoUpdate(reference, popper, () => {
      computePosition(reference, popper, {
        placement: "bottom-start",
        middleware: [
          offset(4),
          autoPlacement({
            crossAxis: !0,
            // padding: POPOVER_PADDING,
            allowedPlacements: [
              "bottom-start",
              "bottom-end",
              "left-start",
              "top-start",
              "top-end",
              "right-start",
              "right-end",
              "left-end"
            ]
          }),
          size({
            apply({ availableHeight, availableWidth, elements }) {
              wasCanceled || Object.assign(elements.floating.style, {
                maxWidth: `${t(roundDpr(availableWidth), { min: 220, max: 400 })}px`,
                maxHeight: `${t(roundDpr(availableHeight), { min: 100, max: 500 })}px`
              });
            }
          }),
          hide({
            padding: POPOVER_PADDING * 2
          })
        ]
      }).then(({ x, y, middlewareData }) => {
        wasCanceled || (popper.style.transform = `translate(${roundDpr(x)}px, ${roundDpr(y)}px)`, popper.style.visibility = middlewareData.hide?.referenceHidden ? "hidden" : "visible");
      });
    }, {
      ancestorResize: !1,
      animationFrame: !0
    });
    return () => {
      wasCanceled = !0, cleanup();
    };
  }, [referenceEl]);
  const diagram = useDiagram(), renderRelationship = useCallback(
    (relationship, index2) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
      index2 > 0 && /* @__PURE__ */ jsx(Divider$2, {}),
      /* @__PURE__ */ jsx(
        Relationship,
        {
          viewId,
          relationship,
          sourceNode,
          targetNode,
          onNavigateTo: enableNavigateTo ? (viewId2) => {
            diagram.navigateTo(viewId2);
          } : void 0,
          ...onOpenSource && enableVscode && {
            onOpenSource: () => onOpenSource({ relation: relationship.id })
          }
        }
      )
    ] }, relationship.id),
    [viewId, sourceNode, targetNode, diagram, enableNavigateTo, onOpenSource, enableVscode]
  );
  return /* @__PURE__ */ jsx(
    ScrollAreaAutosize,
    {
      ref,
      onMouseEnter,
      onMouseLeave,
      type: "auto",
      scrollbars: "y",
      scrollbarSize: 6,
      styles: {
        viewport: {
          overscrollBehavior: "contain",
          minWidth: 200,
          minHeight: 40
        }
      },
      className: cx(
        css({
          layerStyle: "likec4.dropdown",
          p: "0",
          pointerEvents: {
            base: "all",
            _whenPanning: "none"
          },
          position: "absolute",
          top: "0",
          left: "0",
          width: "max-content",
          cursor: "default"
        })
      ),
      children: /* @__PURE__ */ jsxs(
        VStack,
        {
          css: {
            gap: "3",
            padding: "4",
            paddingTop: "2"
          },
          children: [
            enableCompareWithLatest && /* @__PURE__ */ jsx(EdgeDrifts$1, { diagramEdge }),
            /* @__PURE__ */ jsx(
              Button,
              {
                variant: "default",
                color: "gray",
                size: "compact-xs",
                style: {
                  alignSelf: "flex-start",
                  fontWeight: 500,
                  "--button-fz": "var(--font-sizes-xxs)"
                },
                onClick: (e2) => {
                  e2.stopPropagation(), diagram.openRelationshipDetails(diagramEdge.id);
                },
                children: "browse relationships"
              }
            ),
            direct.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(Label$1, { children: "DIRECT RELATIONSHIPS" }),
              direct.map(renderRelationship)
            ] }),
            nested.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(
                Label$1,
                {
                  css: {
                    mt: direct.length > 0 ? "2" : "0"
                  },
                  children: "RESOLVED FROM NESTED"
                }
              ),
              nested.map(renderRelationship)
            ] })
          ]
        }
      )
    }
  );
}, EdgeDrifts$1 = ({ diagramEdge }) => {
  const drifts = diagramEdge.drifts;
  return !drifts || drifts.length === 0 ? null : /* @__PURE__ */ jsx(
    Notification,
    {
      color: "orange",
      withBorder: !1,
      withCloseButton: !1,
      title: "Changes:",
      children: drifts.map((drift) => /* @__PURE__ */ jsxs(Text, { mt: 2, size: "sm", lh: "xs", children: [
        "- ",
        drift
      ] }, drift))
    }
  );
}, Relationship = forwardRef(({
  viewId,
  relationship: r2,
  sourceNode,
  targetNode,
  onNavigateTo,
  onOpenSource
}, ref) => {
  const sourceId = getEndpointId(r2, "source", sourceNode), targetId = getEndpointId(r2, "target", targetNode), navigateTo = onNavigateTo && r2.navigateTo?.id !== viewId ? r2.navigateTo?.id : void 0, links = r2.links, metadataEntries = r2.hasMetadata() ? t$9(r2.getMetadata()).sort(([a], [b]) => a.localeCompare(b)) : null, metadataTooltipLabel = metadataEntries && /* @__PURE__ */ jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "6px" }, children: [
    /* @__PURE__ */ jsx(
      "div",
      {
        style: {
          fontWeight: 600,
          fontSize: "10px",
          color: "#868e96",
          marginBottom: "2px",
          letterSpacing: "0.5px",
          textTransform: "uppercase"
        },
        children: "Metadata"
      }
    ),
    /* @__PURE__ */ jsx(
      "div",
      {
        style: {
          borderTop: "1px solid rgba(0, 0, 0, 0.1)",
          paddingTop: "6px",
          display: "flex",
          flexDirection: "column",
          gap: "6px"
        },
        children: metadataEntries.map(([key2, value]) => {
          const displayValue = Array.isArray(value) ? value.join(", ") : value;
          return /* @__PURE__ */ jsxs("div", { style: { display: "flex", gap: "12px", fontSize: "12px", lineHeight: "1.4" }, children: [
            /* @__PURE__ */ jsxs(
              "span",
              {
                style: {
                  fontWeight: 600,
                  minWidth: "110px",
                  color: "#495057"
                },
                children: [
                  key2,
                  ":"
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              "span",
              {
                style: {
                  color: "#212529",
                  wordBreak: "break-word",
                  flex: 1
                },
                children: displayValue
              }
            )
          ] }, key2);
        })
      }
    )
  ] });
  return /* @__PURE__ */ jsxs(
    VStack,
    {
      ref,
      className: bleed({
        block: "2",
        inline: "2",
        paddingY: "2.5",
        paddingX: "2",
        gap: "1",
        rounded: "sm",
        backgroundColor: {
          _hover: {
            base: "mantine.colors.gray[1]",
            _dark: "mantine.colors.dark[5]/70"
          }
        }
      }),
      children: [
        /* @__PURE__ */ jsx(HStack, { gap: "0.5", children: /* @__PURE__ */ jsxs(TooltipGroup, { openDelay: 200, children: [
          /* @__PURE__ */ jsx(Tooltip, { label: sourceId.full, offset: 2, position: "top-start", children: /* @__PURE__ */ jsx(Text, { component: "div", "data-likec4-color": sourceNode.color, className: endpoint, children: sourceId.short }) }),
          /* @__PURE__ */ jsx(IconArrowRight, { stroke: 2.5, size: "11px", opacity: 0.65 }),
          /* @__PURE__ */ jsx(Tooltip, { label: targetId.full, offset: 2, position: "top-start", children: /* @__PURE__ */ jsx(Text, { component: "div", "data-likec4-color": targetNode.color, className: endpoint, children: targetId.short }) }),
          navigateTo && /* @__PURE__ */ jsx(Tooltip, { label: "Open dynamic view", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              size: "sm",
              radius: "sm",
              variant: "default",
              onClick: (event) => {
                event.stopPropagation(), onNavigateTo?.(navigateTo);
              },
              style: {
                alignSelf: "flex-end"
              },
              role: "button",
              children: /* @__PURE__ */ jsx(IconZoomScan, { size: "80%", stroke: 2 })
            }
          ) }),
          onOpenSource && /* @__PURE__ */ jsx(Tooltip, { label: "Open source", children: /* @__PURE__ */ jsx(
            ActionIcon,
            {
              size: "sm",
              radius: "sm",
              variant: "default",
              onClick: (event) => {
                event.stopPropagation(), onOpenSource();
              },
              role: "button",
              children: /* @__PURE__ */ jsx(IconFileSymlink, { size: "80%", stroke: 2 })
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsxs(HStack, { gap: "xs", alignItems: "center", children: [
          /* @__PURE__ */ jsx(Box, { className: title, children: r2.title || "untitled" }),
          metadataTooltipLabel && /* @__PURE__ */ jsx(
            Tooltip,
            {
              label: metadataTooltipLabel,
              w: 350,
              position: "right",
              offset: 10,
              openDelay: 300,
              withArrow: !0,
              bg: "white",
              c: "dark",
              withinPortal: !0,
              styles: {
                tooltip: {
                  boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                  border: "1px solid #dee2e6"
                }
              },
              children: /* @__PURE__ */ jsx(Box, { display: "inline-flex", children: /* @__PURE__ */ jsx(
                IconInfoCircle,
                {
                  size: 14,
                  opacity: 0.5,
                  style: { flexShrink: 0, cursor: "help" }
                }
              ) })
            }
          )
        ] }),
        r2.kind && /* @__PURE__ */ jsxs(HStack, { gap: "2", children: [
          /* @__PURE__ */ jsx(Label$1, { children: "kind" }),
          /* @__PURE__ */ jsx(Text, { size: "xs", className: css({ userSelect: "all" }), children: r2.kind })
        ] }),
        r2.technology && /* @__PURE__ */ jsxs(HStack, { gap: "2", children: [
          /* @__PURE__ */ jsx(Label$1, { children: "technology" }),
          /* @__PURE__ */ jsx(Text, { size: "xs", className: css({ userSelect: "all" }), children: r2.technology })
        ] }),
        r2.summary.nonEmpty && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Label$1, { children: "description" }),
          /* @__PURE__ */ jsx(
            Box,
            {
              css: {
                paddingLeft: "2.5",
                py: "1.5",
                borderLeft: "2px dotted",
                borderLeftColor: {
                  base: "mantine.colors.gray[3]",
                  _dark: "mantine.colors.dark[4]"
                }
              },
              children: /* @__PURE__ */ jsx(Markdown, { value: r2.summary, fontSize: "sm", textScale: 0.875 })
            }
          )
        ] }),
        links.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Label$1, { children: "links" }),
          /* @__PURE__ */ jsx(HStack, { gap: "1", flexWrap: "wrap", children: links.map((link) => /* @__PURE__ */ jsx(Link, { size: "sm", value: link }, link.url)) })
        ] })
      ]
    }
  );
}), Label$1 = styled("div", {
  base: {
    display: "block",
    fontSize: "xxs",
    fontWeight: 500,
    userSelect: "none",
    lineHeight: "sm",
    color: "mantine.colors.dimmed"
  }
}), Tooltip = Tooltip$6.withProps({
  color: "dark",
  fz: "xs",
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function getEndpointId(r2, endpoint2, diagramNode) {
  const diagramNodeId = r2.isDeploymentRelation() ? diagramNode.id : diagramNode.modelRef || "", full = r2[endpoint2].id, short = nameFromFqn(diagramNodeId) + full.slice(diagramNodeId.length);
  return { full, short };
}
const LayoutDriftFrame = memo$1(() => {
  const [{ layout, isActive }, { toggleCompare }] = useDiagramCompareLayout(), bgColor = layout === "manual" ? "var(--mantine-color-orange-6)" : "var(--mantine-color-green-6)";
  return /* @__PURE__ */ jsx(
    Box,
    {
      className: hstack({
        position: "absolute",
        top: "0",
        left: "0",
        width: "full",
        height: "full",
        border: "default",
        borderWidth: 4,
        pointerEvents: "none",
        alignItems: "flex-start",
        justifyContent: "center"
      }),
      style: {
        zIndex: "9999",
        display: isActive ? void 0 : "none",
        borderColor: bgColor
      },
      children: /* @__PURE__ */ jsx(
        Btn,
        {
          style: {
            backgroundColor: bgColor
          },
          onClick: (e2) => {
            e2.stopPropagation(), toggleCompare();
          },
          children: "Close compare"
        }
      )
    }
  );
}), Btn = UnstyledButton.withProps({
  className: css({
    fontSize: "xs",
    fontWeight: "medium",
    py: "1.5",
    lineHeight: "1",
    borderBottomLeftRadius: "sm",
    borderBottomRightRadius: "sm",
    transform: "translateY(-4px)",
    px: "4",
    color: "mantine.colors.gray[9]",
    pointerEvents: "all",
    _active: {
      transform: "translateY(-3px)"
    }
  })
}), container = css({
  position: "absolute",
  bottom: "0",
  right: "0",
  padding: "2",
  margin: "0",
  width: "min-content",
  height: "min-content",
  _print: {
    display: "none"
  }
}), icon = css({
  "--ai-radius": "0px",
  _noReduceGraphics: {
    "--ai-radius": "{radii.md}"
  }
}), card = css({
  cursor: "default",
  userSelect: "none",
  minWidth: 200,
  maxWidth: "calc(100vw - 20px)",
  backgroundColor: "mantine.colors.body/80",
  // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  sm: {
    minWidth: 300,
    maxWidth: "65vw"
  },
  md: {
    maxWidth: "40vw"
  },
  _dark: {
    backgroundColor: "mantine.colors.dark[6]/80"
  }
}), tabPanel = css({
  padding: "xxs"
}), elementNotation = css({
  backgroundColor: "transparent",
  transition: "all 100ms ease-in",
  // WebkitBackdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // backdropFilter: fallbackVar(vars.safariAnimationHook, 'blur(8px)'),
  // vars: {
  //   // [stokeFillMix]: `color-mix(in oklab, ${vars.element.stroke} 90%, ${vars.element.fill})`
  // },
  _hover: {
    transition: "all 120ms ease-out",
    // backgroundColor:
    backgroundColor: "mantine.colors.primary[2]/50"
  },
  _dark: {
    _hover: {
      backgroundColor: "mantine.colors.dark[3]/40"
    }
  }
});
css({
  fill: "var(--likec4-palette-fill)",
  stroke: "var(--likec4-palette-stroke)",
  strokeWidth: 1,
  overflow: "visible",
  width: "100%",
  height: "auto",
  filter: `
    drop-shadow(0 2px 3px rgb(0 0 0 / 22%))
    drop-shadow(0 1px 8px rgb(0 0 0 / 10%))
  `
});
const shapeBadge = css({
  fontWeight: 500,
  letterSpacing: "0.2px",
  paddingTop: "0",
  paddingBottom: "0",
  textTransform: "lowercase",
  transition: "all 150ms ease-in-out",
  cursor: "pointer",
  "--badge-radius": "2px",
  "--badge-fz": "9.5px",
  "--badge-padding-x": "3px",
  "--badge-height": "13.5px",
  "--badge-lh": "1",
  "--badge-bg": "var(--likec4-palette-fill)",
  "--badge-color": "var(--likec4-palette-hiContrast)"
}), ElementNotation = ({ value }) => {
  const {
    title: title2,
    color = "primary",
    shape = "rectangle"
  } = value, [onlyKind, setOnlyKind] = useState(null), diagram = useDiagram(), w = 300, h = 200;
  return /* @__PURE__ */ jsx(
    Card,
    {
      shadow: "none",
      px: "xs",
      py: "sm",
      className: cx(
        elementNotation
      ),
      "data-likec4-color": color,
      onMouseEnter: () => {
        setOnlyKind(null), diagram.highlightNotation(value);
      },
      onMouseLeave: () => {
        setOnlyKind(null), diagram.unhighlightNotation();
      },
      children: /* @__PURE__ */ jsxs(
        Group,
        {
          gap: "sm",
          align: "stretch",
          wrap: "nowrap",
          children: [
            /* @__PURE__ */ jsx(
              Box$1,
              {
                flex: "0 0 70px",
                style: {
                  position: "relative",
                  width: 70,
                  height: n$5(70 * (h / w), 0)
                },
                children: /* @__PURE__ */ jsx(
                  ElementShape,
                  {
                    data: {
                      shape,
                      width: w,
                      height: h
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxs(Stack, { gap: 4, flex: 1, children: [
              /* @__PURE__ */ jsx(Group, { gap: 4, flex: "0 0 auto", children: value.kinds.map((kind) => /* @__PURE__ */ jsx(
                Badge,
                {
                  className: cx(
                    shapeBadge
                  ),
                  onMouseEnter: () => {
                    setOnlyKind(kind), diagram.highlightNotation(value, kind);
                  },
                  onMouseLeave: () => {
                    setOnlyKind(null), diagram.highlightNotation(value);
                  },
                  opacity: e$b(onlyKind) && onlyKind !== kind ? 0.25 : 1,
                  children: kind
                },
                kind
              )) }),
              /* @__PURE__ */ jsx(
                Text,
                {
                  component: "div",
                  fz: "sm",
                  fw: 500,
                  lh: "1.25",
                  style: {
                    textWrap: "pretty"
                  },
                  children: title2
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, selector$1 = (s) => ({
  id: s.view.id,
  notations: s.view.notation?.nodes ?? []
}), NotationPanel = memo$1(() => {
  const height = useXYStore((s) => s.height), {
    id,
    notations
  } = useDiagramContext(selector$1), [isCollapsed, setCollapsed] = useLocalStorage({
    key: "notation-webview-collapsed",
    defaultValue: !0
  }), hasNotations = notations.length > 0, portalProps = useMantinePortalProps();
  return /* @__PURE__ */ jsxs(AnimatePresence, { children: [
    !hasNotations && /* @__PURE__ */ jsx(
      m.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: container,
        children: /* @__PURE__ */ jsx(Tooltip$6, { label: "View has no notations", color: "orange", ...portalProps, children: /* @__PURE__ */ jsx(
          ThemeIcon,
          {
            size: "lg",
            variant: "light",
            color: "orange",
            radius: "md",
            children: /* @__PURE__ */ jsx(IconAlertTriangle, {})
          }
        ) })
      },
      "empty"
    ),
    hasNotations && isCollapsed && /* @__PURE__ */ jsx(
      m.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: container,
        children: /* @__PURE__ */ jsx(Tooltip$6, { label: "Show notation", color: "dark", fz: "xs", ...portalProps, children: /* @__PURE__ */ jsx(
          ActionIcon,
          {
            size: "lg",
            variant: "default",
            color: "gray",
            className: icon,
            onClick: () => setCollapsed(!1),
            children: /* @__PURE__ */ jsx(IconHelpCircle, { stroke: 1.5 })
          }
        ) })
      },
      "collapsed"
    ),
    hasNotations && !isCollapsed && /* @__PURE__ */ jsx(
      m.div,
      {
        initial: {
          opacity: 0.75,
          // translateX: '50%',
          scale: 0.2
        },
        animate: { opacity: 1, scale: 1 },
        exit: {
          opacity: 0,
          scale: 0.25
        },
        className: cx("react-flow__panel", container),
        style: {
          transformOrigin: "bottom right"
        },
        children: /* @__PURE__ */ jsx(
          Paper,
          {
            radius: "sm",
            withBorder: !0,
            shadow: "lg",
            className: card,
            children: /* @__PURE__ */ jsxs(Tabs, { defaultValue: "first", radius: "xs", children: [
              /* @__PURE__ */ jsxs(TabsList, { children: [
                /* @__PURE__ */ jsx(
                  ActionIcon,
                  {
                    size: "md",
                    variant: "subtle",
                    color: "gray",
                    ml: 2,
                    style: {
                      alignSelf: "center"
                    },
                    onClick: () => setCollapsed(!0),
                    children: /* @__PURE__ */ jsx(IconArrowDownRight, { stroke: 2 })
                  }
                ),
                /* @__PURE__ */ jsx(TabsTab, { value: "first", fz: "xs", children: "Elements" }),
                /* @__PURE__ */ jsx(TabsTab, { value: "second", fz: "xs", disabled: !0, children: "Relationships" })
              ] }),
              /* @__PURE__ */ jsx(TabsPanel, { value: "first", className: tabPanel, hidden: isCollapsed, children: /* @__PURE__ */ jsx(
                ScrollAreaAutosize,
                {
                  viewportProps: {
                    style: {
                      maxHeight: `min(40vh, ${Math.max(height - 60, 50)}px)`
                    }
                  },
                  children: /* @__PURE__ */ jsx(Stack, { gap: 0, children: notations.map((n2, i) => /* @__PURE__ */ jsx(ElementNotation, { value: n2 }, i)) })
                }
              ) })
            ] })
          }
        )
      },
      id
    )
  ] });
}), LikeC4DiagramUI = memo$1(() => {
  const {
    enableControls,
    enableNotations,
    enableSearch,
    enableRelationshipDetails,
    enableReadOnly,
    enableCompareWithLatest
  } = useEnabledFeatures(), rerender = useRerender(), overlaysActorRef = useOverlaysActorRef(), searchActorRef = useSearchActorRef(), handleReset = useCallback(() => {
    console.warn("DiagramUI: resetting error boundary and rerendering..."), rerender();
  }, []);
  return /* @__PURE__ */ jsxs(ErrorBoundary, { onReset: handleReset, children: [
    enableControls && /* @__PURE__ */ jsx(NavigationPanel$1, {}),
    overlaysActorRef && /* @__PURE__ */ jsx(Overlays, { overlaysActorRef }),
    enableNotations && /* @__PURE__ */ jsx(NotationPanel, {}),
    enableSearch && searchActorRef && /* @__PURE__ */ jsx(Search, { searchActorRef }),
    enableRelationshipDetails && enableReadOnly && /* @__PURE__ */ jsx(RelationshipPopover, {}),
    enableCompareWithLatest && /* @__PURE__ */ jsx(LayoutDriftFrame, {})
  ] });
});
LikeC4DiagramUI.displayName = "DiagramUI";
function EdgeDrifts({
  edgeProps: { data },
  svgPath
}) {
  const drifts = data.drifts;
  return !drifts || drifts.length === 0 ? null : /* @__PURE__ */ jsx(
    "path",
    {
      className: cx(
        "react-flow__edge-path",
        css({
          pointerEvents: "none",
          stroke: "likec4.compare.manual.outline",
          fill: "none",
          strokeWidth: {
            base: "8px",
            _whenHovered: "12px"
          },
          strokeOpacity: 0.5
        })
      ),
      d: svgPath,
      strokeLinecap: "round"
    }
  );
}
const controlPointsContainer = css({
  overflow: "visible",
  position: "absolute",
  pointerEvents: "none",
  top: "0",
  left: "0",
  mixBlendMode: {
    _dark: "screen",
    _light: "multiply"
  }
}), controlPoint = css({
  fill: "[var(--xy-edge-stroke)]",
  stroke: "transparent",
  fillOpacity: 0.5,
  strokeWidth: 10,
  r: 4,
  cursor: "grab",
  pointerEvents: "all",
  visibility: "hidden",
  transitionDuration: "120ms",
  transitionProperty: "visibility, fill, fill-opacity, r",
  transitionTimingFunction: "inOut",
  transitionDelay: "20ms",
  ":where([data-likec4-selected='true'], [data-likec4-hovered='true']) &": {
    visibility: "visible",
    fillOpacity: 1,
    transitionTimingFunction: "out",
    transitionDelay: "0ms"
  },
  ":where([data-likec4-selected='true']) &": {
    r: 6
  },
  ":is([data-likec4-hovered='true']) &": {
    r: 8
  },
  _hover: {
    fill: "mantine.colors.primary.filledHover",
    r: 10,
    transitionDuration: "100ms"
  },
  _groupActive: {
    cursor: "grabbing"
  }
});
function useControlPoints({
  sourceX,
  sourceY,
  targetX,
  targetY,
  data
}) {
  const [controlPoints, setControlPoints] = useState(
    () => data.controlPoints ?? bezierControlPoints(data.points)
  );
  useUpdateEffect(() => {
    const next = data.controlPoints ?? bezierControlPoints(data.points);
    setControlPoints((prev) => deepEqual(prev, next) ? prev : next);
  }, [
    data.controlPoints?.map((p) => `${Math.round(p.x)},${Math.round(p.y)}`).join("|") ?? "",
    data.points.map((p) => `${Math.round(p[0])},${Math.round(p[1])}`).join("|")
  ]);
  const insertControlPoint = useCallbackRef(({ x, y }) => {
    const sourceV = vector(sourceX, sourceY), targetV = vector(targetX, targetY), points = [
      data.dir === "back" ? targetV : sourceV,
      ...controlPoints.map(vector) || [],
      data.dir === "back" ? sourceV : targetV
    ], newPointV = vector(x, y).round();
    let insertionIndex = 0, minDistance = 1 / 0;
    for (let i = 0; i < points.length - 1; i++) {
      const a = points[i], b = points[i + 1], fromCurrentToNext = b.subtract(a), fromCurrentToNew = newPointV.subtract(a), fromNextToNew = newPointV.subtract(b);
      if (fromCurrentToNext.dot(fromCurrentToNew) * fromCurrentToNext.dot(fromNextToNew) < 0) {
        const distanceToEdge = Math.abs(fromCurrentToNext.cross(fromCurrentToNew)) / fromCurrentToNext.length();
        distanceToEdge < minDistance && (minDistance = distanceToEdge, insertionIndex = i);
      }
    }
    const newControlPoints = controlPoints.slice();
    return newControlPoints.splice(insertionIndex, 0, { x: newPointV.x, y: newPointV.y }), setControlPoints(newControlPoints), newControlPoints;
  });
  return {
    controlPoints,
    setControlPoints,
    insertControlPoint
  };
}
const curve = d3line().curve(curveCatmullRomOpen.alpha(0.7)).x((d) => Math.round(d.x)).y((d) => Math.round(d.y)), isSameRects = (a, b) => isEqualRects(a.sourceNode, b.sourceNode) && isEqualRects(a.targetNode, b.targetNode);
function useRelationshipEdgePath({
  props: {
    sourceX,
    sourceY,
    source,
    target,
    targetX,
    targetY,
    data
  },
  controlPoints,
  isControlPointDragging
}) {
  const {
    sourceNode,
    targetNode
  } = useXYStore(
    useCallback(({ nodeLookup }) => {
      const sourceNode2 = nonNullable$1(nodeLookup.get(source), `source node ${source} not found`), targetNode2 = nonNullable$1(nodeLookup.get(target), `target node ${target} not found`);
      return {
        sourceNode: nodeToRect(sourceNode2),
        targetNode: nodeToRect(targetNode2)
      };
    }, [source, target]),
    isSameRects
  );
  if (e$8(data.controlPoints) || isControlPointDragging) {
    const sourceCenterPos = { x: sourceX, y: sourceY }, targetCenterPos = { x: targetX, y: targetY }, nodeMargin = 6, points = data.dir === "back" ? [
      targetCenterPos,
      getNodeIntersectionFromCenterToPoint(targetNode, n$4(controlPoints) ?? sourceCenterPos, nodeMargin),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(sourceNode, t$b(controlPoints) ?? targetCenterPos, nodeMargin),
      sourceCenterPos
    ] : [
      sourceCenterPos,
      getNodeIntersectionFromCenterToPoint(sourceNode, n$4(controlPoints) ?? targetCenterPos, nodeMargin),
      ...controlPoints,
      getNodeIntersectionFromCenterToPoint(targetNode, t$b(controlPoints) ?? sourceCenterPos, nodeMargin),
      targetCenterPos
    ];
    return nonNullable$1(curve(points));
  }
  return bezierPath(data.points);
}
const getEdgeCenter = (path) => {
  const dompoint = path.getPointAtLength(path.getTotalLength() * 0.5);
  return {
    x: Math.round(dompoint.x),
    y: Math.round(dompoint.y)
  };
}, RelationshipEdge$1 = memoEdge((props) => {
  const [isControlPointDragging, setIsControlPointDragging] = useState(!1), isControlPointDraggingRef = useRef(isControlPointDragging);
  isControlPointDraggingRef.current = isControlPointDragging;
  const xyflow2 = useXYFlow(), diagram = useDiagram(), {
    enableNavigateTo,
    enableReadOnly,
    enableCompareWithLatest
  } = useEnabledFeatures(), enabledEditing = !enableReadOnly, {
    id,
    selected = !1,
    data: {
      labelBBox,
      labelXY,
      ...data
    }
  } = props, navigateTo = enableNavigateTo && !isControlPointDragging ? data.navigateTo : void 0, {
    controlPoints,
    setControlPoints,
    insertControlPoint
  } = useControlPoints(props);
  let edgePath2 = useRelationshipEdgePath({
    props,
    controlPoints,
    isControlPointDragging
  }), labelX = labelBBox?.x ?? 0, labelY = labelBBox?.y ?? 0;
  const [labelPos, setLabelPos] = useState({
    x: labelXY?.x ?? labelX,
    y: labelXY?.y ?? labelY
  });
  useUpdateEffect(() => {
    if (isControlPointDraggingRef.current)
      return;
    const next = {
      x: labelX,
      y: labelY
    };
    setLabelPos((current) => isSamePoint(current, next) ? current : next);
  }, [labelX, labelY]);
  const svgPathRef = useRef(null);
  useEffect(() => {
    const path = svgPathRef.current;
    if (!path || !isControlPointDragging) return;
    const next = getEdgeCenter(path);
    setLabelPos((current) => isSamePoint(current, next) ? current : next);
  }, [edgePath2, isControlPointDragging]);
  const updateEdgeData2 = useCallbackRef((controlPoints2) => {
    const point = svgPathRef.current ? getEdgeCenter(svgPathRef.current) : null;
    labelBBox && point ? diagram.updateEdgeData(id, {
      controlPoints: controlPoints2,
      labelBBox: {
        ...labelBBox,
        ...point
      }
    }) : diagram.updateEdgeData(id, { controlPoints: controlPoints2 }), diagram.stopEditing(!0), setIsControlPointDragging(!1);
  }), onControlPointerStartMove = useCallbackRef(() => {
    diagram.startEditing("edge"), setIsControlPointDragging(!0);
  }), onControlPointerCancelMove = useCallbackRef(() => {
    diagram.stopEditing(), setIsControlPointDragging(!1);
  }), onControlPointerFinishMove = useCallbackRef((points) => {
    setControlPoints(points), requestAnimationFrame(() => {
      updateEdgeData2(points);
    });
  }), onControlPointerDelete = useCallbackRef((points) => {
    diagram.startEditing("edge"), setIsControlPointDragging(!0), setControlPoints(points), requestAnimationFrame(() => {
      updateEdgeData2(points);
    });
  }), onEdgePointerDown = useCallbackRef((e2) => {
    if (e2.pointerType !== "mouse" || e2.button !== 2 && !selected)
      return;
    e2.stopPropagation(), e2.preventDefault(), diagram.startEditing("edge");
    const newControlPoints = insertControlPoint(
      xyflow2.screenToFlowPosition(
        {
          x: e2.clientX,
          y: e2.clientY
        },
        { snapToGrid: !1 }
      )
    );
    diagram.updateEdgeData(id, { controlPoints: newControlPoints }), diagram.stopEditing(!0);
  });
  return isControlPointDragging && !props.data.hovered && (props = {
    ...props,
    data: {
      ...props.data,
      hovered: !0
    }
  }), /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      EdgeContainer,
      {
        ...props,
        className: css({
          "& .react-flow__edge-interaction": {
            cursor: enabledEditing && selected ? "copy" : void 0
          }
        }),
        children: [
          /* @__PURE__ */ jsx(
            EdgePath,
            {
              edgeProps: props,
              svgPath: edgePath2,
              ref: svgPathRef,
              isDragging: isControlPointDragging,
              ...enabledEditing && {
                onEdgePointerDown
              }
            }
          ),
          enableCompareWithLatest && /* @__PURE__ */ jsx(
            EdgeDrifts,
            {
              edgeProps: props,
              svgPath: edgePath2
            }
          ),
          labelBBox && /* @__PURE__ */ jsx(
            EdgeLabelContainer,
            {
              edgeProps: props,
              labelPosition: isControlPointDragging ? labelPos : { x: labelX, y: labelY },
              children: /* @__PURE__ */ jsx(
                EdgeLabel,
                {
                  pointerEvents: enabledEditing ? "none" : "all",
                  edgeProps: props,
                  children: navigateTo && /* @__PURE__ */ jsx(
                    EdgeActionButton,
                    {
                      onClick: (e2) => {
                        e2.stopPropagation(), diagram.navigateTo(navigateTo);
                      }
                    }
                  )
                }
              )
            }
          )
        ]
      }
    ),
    enabledEditing && controlPoints.length > 0 && /* @__PURE__ */ jsx(
      ControlPoints,
      {
        isControlPointDragging,
        edgeProps: props,
        controlPoints,
        onMove: setControlPoints,
        onStartMove: onControlPointerStartMove,
        onCancelMove: onControlPointerCancelMove,
        onFinishMove: onControlPointerFinishMove,
        onDelete: onControlPointerDelete,
        zIndex: 9999
      }
    )
  ] });
});
RelationshipEdge$1.displayName = "RelationshipEdge";
function ControlPoints({
  isControlPointDragging,
  edgeProps,
  controlPoints,
  onMove,
  onStartMove,
  onCancelMove,
  onFinishMove,
  onDelete,
  zIndex
}) {
  const xyflowStore = useXYStoreApi(), xyflow2 = useXYFlow(), edgeId = edgeProps.data.id, onLmbControlPointerDown = (index2, e2, domNode) => {
    let hasMoved = !1, pointer = { x: e2.clientX, y: e2.clientY }, animationFrameId = null, cp = controlPoints;
    const onPointerMove = (e22) => {
      const clientPoint = {
        x: e22.clientX,
        y: e22.clientY
      };
      isSamePoint(pointer, clientPoint) || (hasMoved || (hasMoved = !0, onStartMove()), pointer = clientPoint, animationFrameId ??= requestAnimationFrame(() => {
        animationFrameId = null, cp = cp.slice();
        const { x, y } = xyflow2.screenToFlowPosition(pointer, { snapToGrid: !1 });
        cp[index2] = {
          x: Math.round(x),
          y: Math.round(y)
        }, onMove(cp);
      })), e22.stopPropagation();
    }, onPointerUp = (e22) => {
      e22.stopPropagation(), domNode.removeEventListener("pointermove", onPointerMove, {
        capture: !0
      }), domNode.removeEventListener("click", stopAndPrevent, {
        capture: !0
      }), hasMoved ? onFinishMove(cp) : onCancelMove();
    };
    domNode.addEventListener("pointermove", onPointerMove, {
      capture: !0
    }), domNode.addEventListener("pointerup", onPointerUp, {
      once: !0,
      capture: !0
    }), domNode.addEventListener("click", stopAndPrevent, {
      capture: !0,
      once: !0
    });
  }, onRmbControlPointerDown = (index2, e2) => {
    if (controlPoints.length <= 1)
      return;
    e2.stopPropagation(), e2.preventDefault();
    const newControlPoints = controlPoints.slice();
    newControlPoints.splice(index2, 1), setTimeout(() => {
      onDelete(newControlPoints);
    }, 10);
  }, onControlPointerDown = useCallbackRef((e2) => {
    const { domNode, addSelectedEdges, edges, unselectNodesAndEdges } = xyflowStore.getState();
    if (!domNode || e2.pointerType !== "mouse")
      return;
    const index2 = parseFloat(e2.currentTarget.getAttribute("data-control-point-index") || "");
    if (isNaN(index2))
      throw new Error("data-control-point-index is not a number");
    switch (e2.button) {
      case 0: {
        e2.stopPropagation(), unselectNodesAndEdges({
          edges: edges.filter((ed) => ed.selected && ed.id !== edgeId)
        }), addSelectedEdges([edgeId]), onLmbControlPointerDown(index2, e2, domNode);
        break;
      }
      case 2:
        onRmbControlPointerDown(index2, e2);
        break;
    }
  }), onControlPointerDblClick = useCallbackRef((e2) => {
    const { domNode } = xyflowStore.getState();
    if (!domNode || e2.pointerType !== "mouse")
      return;
    const index2 = parseFloat(e2.currentTarget.getAttribute("data-control-point-index") || "");
    if (isNaN(index2))
      throw new Error("data-control-point-index is not a number");
    onRmbControlPointerDown(index2, e2);
  });
  return /* @__PURE__ */ jsx(EdgeLabelRenderer, { children: /* @__PURE__ */ jsx(
    EdgeContainer,
    {
      component: "svg",
      className: controlPointsContainer,
      ...edgeProps,
      style: {
        ...edgeProps.style,
        zIndex
      },
      children: /* @__PURE__ */ jsx(
        "g",
        {
          "data-active": isControlPointDragging ? !0 : void 0,
          className: "group",
          onContextMenu: stopAndPrevent,
          children: controlPoints.map((p, i) => /* @__PURE__ */ jsx(
            "circle",
            {
              "data-control-point-index": i,
              onPointerDownCapture: onControlPointerDown,
              onDoubleClick: onControlPointerDblClick,
              className: cx("nodrag nopan", controlPoint),
              cx: p.x,
              cy: p.y
            },
            "controlPoints" + edgeId + "#" + i
          ))
        }
      )
    }
  ) });
}
const stopAndPrevent = (e2) => {
  e2.stopPropagation(), e2.preventDefault();
}, LABEL_OFFSET = 16;
function SequenceStepEdge(props) {
  const { enableNavigateTo, enableCompareWithLatest } = useEnabledFeatures(), diagram = useDiagram(), { navigateTo } = props.data, isSelfLoop = props.source === props.target, isBack = props.sourceX > props.targetX, [path] = getSmoothStepPath({
    sourceX: props.sourceX,
    sourceY: props.sourceY,
    sourcePosition: props.sourcePosition,
    targetX: props.targetX,
    targetY: props.targetY,
    targetPosition: props.targetPosition,
    ...isSelfLoop && {
      offset: 30,
      borderRadius: 16
    }
  });
  let labelX = props.sourceX;
  switch (!0) {
    case isSelfLoop:
      labelX = props.sourceX + 24 + LABEL_OFFSET;
      break;
    case isBack:
      labelX = props.sourceX - LABEL_OFFSET;
      break;
    default:
      labelX = props.sourceX + LABEL_OFFSET;
      break;
  }
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...props, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps: props,
        svgPath: path
      }
    ),
    enableCompareWithLatest && /* @__PURE__ */ jsx(EdgeDrifts, { edgeProps: props, svgPath: path }),
    /* @__PURE__ */ jsx(
      EdgeLabelContainer,
      {
        edgeProps: props,
        labelPosition: {
          x: labelX,
          y: props.sourceY + (isSelfLoop ? 0 : LABEL_OFFSET),
          translate: isBack ? "translate(-100%, 0)" : void 0
        },
        children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps: props, children: enableNavigateTo && navigateTo && /* @__PURE__ */ jsx(
          EdgeActionButton,
          {
            onClick: (e2) => {
              e2.stopPropagation(), diagram.navigateTo(navigateTo);
            }
          }
        ) })
      }
    )
  ] });
}
const BuiltinNodes = {
  ElementNode: ElementNode$2,
  DeploymentNode,
  CompoundElementNode,
  CompoundDeploymentNode,
  ViewGroupNode,
  SequenceActorNode,
  SequenceParallelArea
}, BuiltinEdges = {
  RelationshipEdge: RelationshipEdge$1,
  SequenceStepEdge
};
class Rect {
  static LeftPadding = 42;
  static RightPadding = 42;
  static TopPadding = 60;
  static BottomPadding = 42;
  id;
  minX = 1 / 0;
  minY = 1 / 0;
  maxX = -1 / 0;
  maxY = -1 / 0;
  initialX;
  initialY;
  get positionAbsolute() {
    return {
      x: this.minX,
      y: this.minY
    };
  }
  get initialPositionAbsolute() {
    return {
      x: this.initialX,
      y: this.initialY
    };
  }
  set positionAbsolute(pos) {
    const x = Math.round(pos.x), y = Math.round(pos.y);
    this.maxX += x - this.minX, this.maxY += y - this.minY, this.minX = x, this.minY = y;
  }
  get dimensions() {
    return {
      width: Math.round(this.maxX - this.minX),
      height: Math.round(this.maxY - this.minY)
    };
  }
  get diff() {
    return {
      x: Math.round(this.positionAbsolute.x - this.initialX),
      y: Math.round(this.positionAbsolute.y - this.initialY)
    };
  }
  get isMoved() {
    return this.diff.x !== 0 || this.diff.y !== 0;
  }
  // Position relative to parent
  get position() {
    const positionAbsolute = this.positionAbsolute;
    if (!this.parent)
      return positionAbsolute;
    const parentPosition = this.parent.positionAbsolute;
    return {
      x: positionAbsolute.x - parentPosition.x,
      y: positionAbsolute.y - parentPosition.y
    };
  }
  constructor(xynode, parent = null) {
    this.id = xynode.id, this.positionAbsolute = parent ? {
      x: xynode.position.x + parent.minX,
      y: xynode.position.y + parent.minY
    } : xynode.position;
    const { width, height } = getNodeDimensions(xynode);
    this.maxX = this.minX + Math.ceil(width), this.maxY = this.minY + Math.ceil(height), this.initialX = this.positionAbsolute.x, this.initialY = this.positionAbsolute.y, parent && parent.children.push(this);
  }
}
class CompoundRect extends Rect {
  constructor(xynode, parent = null) {
    super(xynode, parent), this.parent = parent;
  }
  children = [];
}
class Leaf extends Rect {
  constructor(xynode, parent = null) {
    super(xynode, parent), this.parent = parent;
  }
}
function makeEdgeModifier(edge, anchor) {
  const controlPoints = edge.data.controlPoints ?? null;
  return (edgeLookup) => {
    const current = nonNullable$1(edgeLookup.get(edge.id), `Edge ${edge.id} not found`), { x: dx, y: dy } = anchor.diff;
    return dx === 0 && dy === 0 ? {
      id: edge.id,
      type: "replace",
      item: produce(current, (draft) => {
        draft.data.points = edge.data.points, draft.data.controlPoints = controlPoints, draft.data.labelBBox = edge.data.labelBBox;
      })
    } : {
      id: edge.id,
      type: "replace",
      item: produce(current, (draft) => {
        draft.data.points = t$a(edge.data.points, (pt) => [pt[0] + dx, pt[1] + dy]), controlPoints && (draft.data.controlPoints = controlPoints.map((pt) => ({
          x: pt.x + dx,
          y: pt.y + dy
        }))), edge.data.labelBBox && (draft.data.labelBBox = {
          x: edge.data.labelBBox.x + dx,
          y: edge.data.labelBBox.y + dy,
          width: edge.data.labelBBox.width,
          height: edge.data.labelBBox.height
        });
      })
    };
  };
}
function makeRelativeEdgeModifier(edge, movingRect, anchorNode, staticNode) {
  const controlPoints = edge.data.controlPoints ?? bezierControlPoints(edge.data.points), anchorV = vector(BBox.center(anchorNode)), staticV = vector(BBox.center(staticNode)), staticToAnchor = anchorV.subtract(staticV), staticToAnchorLength = staticToAnchor.length();
  return (edgeLookup) => {
    const current = nonNullable$1(edgeLookup.get(edge.id), `Edge ${edge.id} not found`), { x: dx, y: dy } = movingRect.diff;
    if (dx === 0 && dy === 0)
      return {
        id: edge.id,
        type: "replace",
        item: produce(current, (draft) => {
          draft.data.points = edge.data.points, draft.data.controlPoints = edge.data.controlPoints, draft.data.labelBBox = edge.data.labelBBox;
        })
      };
    const d = vector(dx, dy), relativePoint = (pt) => {
      const p = vector(pt), projLength = p.subtract(staticV).dot(staticToAnchor), coeff = t(projLength / staticToAnchorLength ** 2, {
        min: -1,
        max: 1
      });
      return p.add(d.multiply(coeff)).round().toObject();
    };
    return {
      id: edge.id,
      type: "replace",
      item: produce(current, (draft) => {
        if (draft.data.controlPoints = controlPoints.map(relativePoint), edge.data.labelBBox) {
          draft.data.labelBBox ??= edge.data.labelBBox;
          const { x, y } = relativePoint(edge.data.labelBBox);
          draft.data.labelBBox.x = x, draft.data.labelBBox.y = y;
        }
      })
    };
  };
}
function createLayoutConstraints(xyflowApi, editingNodeIds) {
  const { parentLookup, nodeLookup, edges } = xyflowApi.getState(), rects = /* @__PURE__ */ new Map(), ancestorsOf = new DefaultMap$1((nodeId) => {
    let parent = nodeLookup.get(nodeId)?.parentId;
    return parent ? [parent, ...ancestorsOf.get(parent)] : [];
  }), nestedOf = new DefaultMap$1((nodeId) => {
    const children = parentLookup.get(nodeId);
    if (!children || children.size === 0)
      return /* @__PURE__ */ new Set();
    const nested = /* @__PURE__ */ new Set();
    for (const child of children.values()) {
      nested.add(child.id);
      for (const desc of nestedOf.get(child.id))
        nested.add(desc);
    }
    return nested;
  });
  if (t$1(editingNodeIds, 2)) {
    const leafsOnly = t$6(
      editingNodeIds,
      t$8((id) => [...nestedOf.get(id)]),
      n$3(),
      (exclude) => r$1(editingNodeIds, exclude)
    );
    invariant(t$1(leafsOnly, 1), "All editing nodes are nested within each other"), editingNodeIds = leafsOnly;
  }
  const ancestorsOfDraggingNodes = new Set(
    editingNodeIds.flatMap((i) => ancestorsOf.get(i))
  ), traverse = [...nodeLookup.values()].flatMap(
    (x) => x.parentId ? [] : { xynode: x, parent: null }
  );
  for (; traverse.length > 0; ) {
    const { xynode, parent } = traverse.shift();
    if (!editingNodeIds.includes(xynode.id) && ancestorsOfDraggingNodes.has(xynode.id)) {
      const rect = new CompoundRect(xynode, parent);
      rects.set(xynode.id, rect), parentLookup.get(xynode.id)?.forEach((child) => {
        traverse.push({
          xynode: child,
          parent: rect
        });
      });
      continue;
    }
    rects.set(xynode.id, new Leaf(xynode, parent));
  }
  const rectsToUpdate = [...rects.values()], edgeModifiers = /* @__PURE__ */ new Map(), findMovingAncestor = (nodeId) => rects.get(nodeId) ?? ancestorsOf.get(nodeId).map((id) => rects.get(id)).find((s) => !!s) ?? null, movingNodes = new Set(editingNodeIds.flatMap((id) => [id, ...nestedOf.get(id)]));
  for (const edge of edges) {
    const isSourceMoving = movingNodes.has(edge.source), isTargetMoving = movingNodes.has(edge.target);
    if (isSourceMoving && isTargetMoving) {
      let r2 = rects.get(edge.source) ?? rects.get(edge.target) ?? findMovingAncestor(edge.source) ?? findMovingAncestor(edge.target);
      r2 && edgeModifiers.set(edge, makeEdgeModifier(edge, r2));
      continue;
    }
    if (isSourceMoving !== isTargetMoving) {
      const movingRect = findMovingAncestor(isSourceMoving ? edge.source : edge.target);
      if (!movingRect)
        continue;
      const [sourceNode, targetNode] = t$6(
        [edge.source, edge.target],
        t$a((id) => nonNullable$1(nodeLookup.get(id), `Node ${id} not found`)),
        t$a(nodeToRect)
      ), [anchorNode, staticNode] = isSourceMoving ? [sourceNode, targetNode] : [targetNode, sourceNode];
      edgeModifiers.set(
        edge,
        makeRelativeEdgeModifier(
          edge,
          movingRect,
          anchorNode,
          staticNode
        )
      );
      continue;
    }
  }
  function applyConstraints(targets) {
    for (const r2 of targets) {
      if (!(r2 instanceof CompoundRect))
        continue;
      applyConstraints(r2.children);
      const childrenBB = {
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      };
      for (const child of r2.children)
        childrenBB.minX = Math.min(childrenBB.minX, child.minX), childrenBB.minY = Math.min(childrenBB.minY, child.minY), childrenBB.maxX = Math.max(childrenBB.maxX, child.maxX), childrenBB.maxY = Math.max(childrenBB.maxY, child.maxY);
      r2.minX = childrenBB.minX - Rect.LeftPadding, r2.minY = childrenBB.minY - Rect.TopPadding, r2.maxX = childrenBB.maxX + Rect.RightPadding, r2.maxY = childrenBB.maxY + Rect.BottomPadding;
    }
  }
  const _edgeModifiers = [...edgeModifiers.values()];
  function updateXYFlow() {
    applyConstraints(rectsToUpdate);
    const nodeUpdates = rectsToUpdate.reduce((acc, r2) => (acc.push({
      id: r2.id,
      type: "position",
      dragging: !1,
      position: r2.position,
      positionAbsolute: r2.positionAbsolute
    }), r2 instanceof CompoundRect && acc.push({
      id: r2.id,
      type: "dimensions",
      setAttributes: !0,
      dimensions: r2.dimensions
    }), acc), []), { edgeLookup, triggerNodeChanges, triggerEdgeChanges } = xyflowApi.getState();
    triggerNodeChanges(nodeUpdates);
    const changes = _edgeModifiers.map((fm) => fm(edgeLookup));
    changes.length > 0 && triggerEdgeChanges(changes);
  }
  let animationFrameId = null;
  function onMove() {
    rectsToUpdate.length !== 0 && (animationFrameId ??= requestAnimationFrame(() => {
      animationFrameId = null;
      for (const id of editingNodeIds) {
        const rect = rects.get(id);
        if (!rect) {
          console.warn(`Rect not found for id ${id}`);
          continue;
        }
        const node2 = nodeLookup.get(id);
        if (!node2) {
          console.warn(`Node not found for id ${id}`);
          continue;
        }
        rect.positionAbsolute = node2.internals.positionAbsolute;
      }
      updateXYFlow();
    }));
  }
  return {
    rects,
    onMove,
    updateXYFlow
  };
}
function useLayoutConstraints() {
  const xystore = useXYStoreApi(), diagram = useDiagram(), solverRef = useRef(void 0);
  return useMemo(() => ({
    onNodeDragStart: (_event, xynode) => {
      diagram.startEditing("node");
      const { nodeLookup } = xystore.getState(), draggingNodes = t$6(
        Array.from(nodeLookup.values()),
        n$2((n2) => n2.dragging === !0 || n2.id === xynode.id || n2.selected === !0),
        t$a((n2) => n2.id)
      );
      t$1(draggingNodes, 1) && (solverRef.current = createLayoutConstraints(xystore, draggingNodes));
    },
    onNodeDrag: (_event) => {
      solverRef.current?.onMove();
    },
    onNodeDragStop: (_event) => {
      const moved = solverRef.current ? isome(solverRef.current.rects.values(), (r2) => r2.isMoved) : !1;
      diagram.stopEditing(moved), solverRef.current = void 0;
    }
  }), [xystore, diagram]);
}
const edgeTypes$1 = {
  relationship: BuiltinEdges.RelationshipEdge,
  "seq-step": BuiltinEdges.SequenceStepEdge
}, builtinNodes = {
  element: memoNode(BuiltinNodes.ElementNode),
  deployment: memoNode(BuiltinNodes.DeploymentNode),
  "compound-element": memoNode(BuiltinNodes.CompoundElementNode),
  "compound-deployment": memoNode(BuiltinNodes.CompoundDeploymentNode),
  "view-group": memoNode(BuiltinNodes.ViewGroupNode),
  "seq-actor": memoNode(BuiltinNodes.SequenceActorNode),
  "seq-parallel": memoNode(BuiltinNodes.SequenceParallelArea)
};
function prepareNodeTypes(nodeTypes2) {
  return !nodeTypes2 || e$3(nodeTypes2) ? builtinNodes : {
    element: nodeTypes2.element ?? builtinNodes.element,
    deployment: nodeTypes2.deployment ?? builtinNodes.deployment,
    "compound-element": nodeTypes2.compoundElement ?? builtinNodes["compound-element"],
    "compound-deployment": nodeTypes2.compoundDeployment ?? builtinNodes["compound-deployment"],
    "view-group": nodeTypes2.viewGroup ?? builtinNodes["view-group"],
    "seq-actor": nodeTypes2.seqActor ?? builtinNodes["seq-actor"],
    "seq-parallel": nodeTypes2.seqParallel ?? builtinNodes["seq-parallel"]
  };
}
const selectXYProps = ({ context: ctx, children }) => {
  const { enableReadOnly } = deriveToggledFeatures(ctx), isNotEditingEdge = enableReadOnly || children.editor?.getSnapshot().context.editing !== "edge";
  return {
    enableReadOnly,
    initialized: ctx.initialized.xydata && ctx.initialized.xyflow,
    nodes: ctx.xynodes,
    edges: ctx.xyedges,
    pannable: ctx.pannable,
    zoomable: ctx.zoomable,
    nodesDraggable: !enableReadOnly && ctx.nodesDraggable,
    nodesSelectable: ctx.nodesSelectable && isNotEditingEdge,
    fitViewPadding: ctx.fitViewPadding,
    enableFitView: ctx.features.enableFitView,
    ...!ctx.features.enableFitView && {
      viewport: {
        x: -ctx.view.bounds.x,
        y: -ctx.view.bounds.y,
        zoom: 1
      }
    }
  };
}, equalsXYProps = (a, b) => a.enableReadOnly === b.enableReadOnly && a.initialized === b.initialized && a.pannable === b.pannable && a.zoomable === b.zoomable && a.nodesDraggable === b.nodesDraggable && a.nodesSelectable === b.nodesSelectable && a.enableFitView === b.enableFitView && shallowEqual(a.fitViewPadding, b.fitViewPadding) && shallowEqual(a.nodes, b.nodes) && shallowEqual(a.edges, b.edges) && shallowEqual(a.viewport ?? null, b.viewport ?? null);
function LikeC4DiagramXYFlow({
  background = "dots",
  reactFlowProps = {},
  children,
  renderNodes
}) {
  const diagram = useDiagram();
  let {
    enableReadOnly,
    initialized,
    nodes,
    edges,
    enableFitView,
    nodesDraggable,
    nodesSelectable,
    ...props
  } = useDiagramActorSnapshot(selectXYProps, equalsXYProps);
  const {
    onNodeContextMenu,
    onCanvasContextMenu,
    onEdgeContextMenu,
    onNodeClick,
    onEdgeClick,
    onCanvasClick,
    onCanvasDblClick
  } = useDiagramEventHandlers(), isReducedGraphics = useIsReducedGraphics(), layoutConstraints = useLayoutConstraints(), $isPanning = usePanningAtom(), isPanning = useTimeout(() => {
    $isPanning.set(!0);
  }, isReducedGraphics ? 120 : 400), notPanning = useDebouncedCallback$1(() => {
    isPanning.clear(), $isPanning.set(!1);
  }, isReducedGraphics ? 350 : 200), onMove = useCallbackRef((event) => {
    event && ($isPanning.get() || isPanning.start(), notPanning());
  }), onMoveEnd = useCallbackRef((event, viewport) => {
    isPanning.clear(), diagram.send({
      type: "xyflow.viewportMoved",
      viewport,
      manually: !!event
    });
  }), onViewportResize = useCallbackRef(() => {
    diagram.send({ type: "xyflow.resized" });
  }), nodeTypes2 = useCustomCompareMemo(
    () => prepareNodeTypes(renderNodes),
    [renderNodes],
    depsShallowEqual
  );
  return useUpdateEffect(() => {
    console.warn("renderNodes changed - this might degrade performance");
  }, [nodeTypes2]), /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      nodes,
      edges,
      className: cx(initialized ? "initialized" : "not-initialized"),
      nodeTypes: nodeTypes2,
      edgeTypes: edgeTypes$1,
      onNodesChange: useCallbackRef((changes) => {
        diagram.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        diagram.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      background: initialized ? background : "transparent",
      fitView: !1,
      onNodeClick: useCallbackRef((e2, node2) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.nodeClick", node: node2 }), onNodeClick?.(diagram.findDiagramNode(node2.id), e2);
      }),
      onEdgeClick: useCallbackRef((e2, edge) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.edgeClick", edge }), onEdgeClick?.(diagram.findDiagramEdge(edge.id), e2);
      }),
      onEdgeDoubleClick: useCallbackRef((e2, edge) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.edgeDoubleClick", edge });
      }),
      onPaneClick: useCallbackRef((e2) => {
        e2.stopPropagation(), diagram.send({ type: "xyflow.paneClick" }), onCanvasClick?.(e2);
      }),
      onDoubleClick: useCallbackRef((e2) => {
        e2.stopPropagation(), e2.preventDefault(), diagram.send({ type: "xyflow.paneDblClick" }), onCanvasDblClick?.(e2);
      }),
      onNodeMouseEnter: useCallbackRef((event, node2) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.nodeMouseEnter", node: node2 });
      }),
      onNodeMouseLeave: useCallbackRef((event, node2) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.nodeMouseLeave", node: node2 });
      }),
      onEdgeMouseEnter: useCallbackRef((event, edge) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.edgeMouseEnter", edge, event });
      }),
      onEdgeMouseLeave: useCallbackRef((event, edge) => {
        event.stopPropagation(), diagram.send({ type: "xyflow.edgeMouseLeave", edge, event });
      }),
      onMove,
      onMoveEnd,
      onInit: useCallbackRef((instance) => {
        diagram.send({ type: "xyflow.init", instance });
      }),
      onNodeContextMenu: useCallbackRef((event, node2) => {
        const diagramNode = nonNullable$1(
          diagram.findDiagramNode(node2.id),
          `diagramNode ${node2.id} not found`
        );
        onNodeContextMenu?.(diagramNode, event);
      }),
      onEdgeContextMenu: useCallbackRef((event, edge) => {
        const diagramEdge = nonNullable$1(
          diagram.findDiagramEdge(edge.id),
          `diagramEdge ${edge.id} not found`
        );
        onEdgeContextMenu?.(diagramEdge, event);
      }),
      ...onCanvasContextMenu && {
        onPaneContextMenu: onCanvasContextMenu
      },
      ...enableFitView && {
        onViewportResize
      },
      nodesDraggable,
      nodesSelectable,
      elevateEdgesOnSelect: !enableReadOnly,
      zIndexMode: "manual",
      ...nodesDraggable && layoutConstraints,
      ...props,
      ...reactFlowProps,
      children
    }
  );
}
function applyChangesToManualLayout(manualView, latestView) {
  try {
    return setAutoFreeze(!1), _applyChangesToManualLayout(manualView, latestView);
  } finally {
    setAutoFreeze(!0);
  }
}
const isRootNode = (node2) => e$6(node2.parent);
function _applyChangesToManualLayout(manualView, latestView) {
  invariant$1(manualView.id === latestView.id, "View IDs do not match"), invariant$1(manualView._type === latestView._type, "View types do not match"), invariant$1(manualView._layout === "manual" && latestView._layout === "auto", "Views must be manual and auto");
  const compounds = /* @__PURE__ */ new Set(), newnodes = /* @__PURE__ */ new Set(), isNotCompound = (node2) => !compounds.has(typeof node2 == "string" ? node2 : node2.id), isBetweenNewLeafNodes = (edge) => newnodes.has(edge.source) && newnodes.has(edge.target) && isNotCompound(edge.source) && isNotCompound(edge.target), nodesMap = new Map(
    latestView.nodes.map((latest) => {
      latest.children && latest.children.length > 0 && compounds.add(latest.id);
      const manual = manualView.nodes.find((n2) => n2.id === latest.id);
      return manual ? [latest.id, applyFromManualNode({ latest, manual })] : (newnodes.add(latest.id), [latest.id, removeDrift(latest)]);
    })
  );
  if (newnodes.size === nodesMap.size)
    return produce(latestView, (draft) => {
      draft._layout = "manual", draft.nodes = castDraft([...nodesMap.values()]), draft.edges = castDraft(latestView.edges.map(removeDrift)), delete draft.drifts;
    });
  compounds.size > 0 && expandCompoundNodes(nodesMap);
  const nodes = [...nodesMap.values()], edges = latestView.edges.map((latest) => {
    const dir = latest.dir ?? "forward", hasSameEndpoints = (candidate) => candidate.source === latest.source && candidate.target === latest.target && (candidate.dir === dir || !candidate.dir && !latest.dir);
    let manual = manualView.edges.find((e2) => e2.id === latest.id && hasSameEndpoints(e2));
    if (manual || (manual = manualView.edges.find((e2) => hasSameEndpoints(e2))), manual)
      return applyFromManualEdge({
        latest,
        manual
      });
    if (isBetweenNewLeafNodes(latest))
      return removeDrift(latest);
    const sourceNode = nodesMap.get(latest.source), targetNode = nodesMap.get(latest.target);
    return makeAsStraightLine(latest, sourceNode, targetNode);
  }), bounds = BBox$2.merge(...nodes.filter(isRootNode));
  return produce(latestView, (draft) => {
    draft._layout = "manual", draft.nodes = castDraft(nodes), draft.edges = castDraft(edges), draft.bounds = bounds, delete draft.drifts;
  });
}
const COMPOUND_PADDING = {
  Left: 42,
  Right: 42,
  Top: 60,
  Bottom: 42
};
function expandCompoundNodes(nodes) {
  function expand(nodeId) {
    const node2 = nonNullable$1(nodes.get(nodeId), `Node ${nodeId} not found`);
    if (node2.children.length === 0)
      return node2;
    const childBBoxes = [];
    for (const childId of node2.children)
      childBBoxes.push(
        expand(childId)
      );
    const childrenBBox = BBox$2.merge(...childBBoxes);
    return node2.x = childrenBBox.x - COMPOUND_PADDING.Left, node2.y = childrenBBox.y - COMPOUND_PADDING.Top, node2.width = childrenBBox.width + COMPOUND_PADDING.Left + COMPOUND_PADDING.Right, node2.height = childrenBBox.height + COMPOUND_PADDING.Top + COMPOUND_PADDING.Bottom, node2;
  }
  for (const node2 of nodes.values())
    !isRootNode(node2) || node2.children.length === 0 || expand(node2.id);
}
function applyFromManualNode({ latest, manual }) {
  return invariant$1(manual.id === latest.id, "Node IDs do not match"), produce(latest, (next) => {
    next.x = manual.x, next.y = manual.y, next.drifts = null;
  });
}
function applyFromManualEdge(edges) {
  const { manual, latest } = edges;
  return produce(latest, (draft) => {
    manual.controlPoints ? draft.controlPoints = manual.controlPoints : delete draft.controlPoints, draft.points = castDraft(manual.points), manual.labelBBox && (draft.labelBBox = latest.labelBBox ?? manual.labelBBox, draft.labelBBox.x = manual.labelBBox.x, draft.labelBBox.y = manual.labelBBox.y), draft.drifts = null;
  });
}
function removeDrift(object) {
  if ("drifts" in object && object.drifts !== null) {
    const result = { ...object };
    return result.drifts = null, result;
  }
  return object;
}
function makeAsStraightLine(edge, sourceNode, targetNode) {
  const controlPoints = edgeControlPoints(sourceNode, targetNode), labelPos = controlPoints[0];
  return produce(edge, (draft) => {
    draft.controlPoints = controlPoints, edge.labelBBox && (draft.labelBBox.x = labelPos.x, draft.labelBBox.y = labelPos.y), delete draft.drifts;
  });
}
function getBorderPointOnVector$1(node2, nodeCenter, v) {
  const xScale = node2.width / 2 / v.x, yScale = node2.height / 2 / v.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v).multiply(scale2).add(nodeCenter);
}
function edgeControlPoints(source, target) {
  const sourceCenter = vector(BBox$2.center(source)), targetCenter = vector(BBox$2.center(target));
  if (source === target) {
    const centerOfTopBoundary = vector(0, source.height || 0).multiply(-0.5).add(sourceCenter);
    return [
      centerOfTopBoundary.add(vector(-80 / 2.5, -80)).round().toObject(),
      centerOfTopBoundary.add(vector(80 / 2.5, -80)).round().toObject()
    ];
  }
  const sourceToTargetVector = targetCenter.subtract(sourceCenter), sourceBorderPoint = getBorderPointOnVector$1(source, sourceCenter, sourceToTargetVector), sourceToTarget = getBorderPointOnVector$1(target, targetCenter, sourceToTargetVector.multiply(-1)).subtract(sourceBorderPoint);
  return [
    sourceBorderPoint.add(sourceToTarget.multiply(0.4)).round().toObject(),
    sourceBorderPoint.add(sourceToTarget.multiply(0.6)).round().toObject()
  ];
}
function useEditorActorLogic(viewId) {
  const port = useOptionalLikeC4EditorPort(), applyLatest2 = useCallbackRef(
    async ({ input: { viewId: viewId2, current } }) => {
      if (!port)
        return console.error("No editor port available for applying latest to manual layout"), Promise.reject(new Error("No editor port"));
      const [manual, latest] = await Promise.all([
        current ?? Promise.resolve().then(() => port.fetchView(viewId2, "manual")),
        Promise.resolve().then(() => port.fetchView(viewId2, "auto"))
      ]).catch((err) => (console.error("Failed to fetch views for applying latest to manual layout", err), Promise.reject(err)));
      return {
        updated: applyChangesToManualLayout(manual, latest)
      };
    }
  ), executeChange2 = useCallbackRef(
    async ({ input: input2 }) => {
      if (!port)
        return console.error("No editor port available for executing change"), Promise.reject(new Error("No editor port"));
      for (const change of input2.changes)
        await Promise.resolve().then(() => port.handleChange(viewId, change)).catch((err) => (console.error("Failed to execute change", {
          change,
          err
        }), Promise.reject(err)));
      return {};
    }
  );
  return editorActorLogic.provide({
    actors: {
      applyLatest: fromPromise(applyLatest2),
      executeChange: fromPromise(executeChange2)
    }
  });
}
function makeDiagramApi(actorRef) {
  return {
    ref: actorRef,
    get actor() {
      return actorRef.current;
    },
    overlays() {
      return nonNullable(actorRef.current.getSnapshot().children.overlays, "Overlays actor not found");
    },
    send: (event) => actorRef.current.send(event),
    navigateTo: (viewId, fromNode, focusOnElement) => {
      actorRef.current.send({
        type: "navigate.to",
        viewId,
        ...fromNode && { fromNode },
        ...focusOnElement && { focusOnElement }
      });
    },
    navigate: (direction) => {
      actorRef.current.send({ type: `navigate.${direction}` });
    },
    fitDiagram: (duration = 350) => {
      actorRef.current.send({ type: "xyflow.fitDiagram", duration });
    },
    openRelationshipsBrowser: (fqn2) => {
      actorRef.current.send({ type: "open.relationshipsBrowser", fqn: fqn2 });
    },
    openSource: (params) => {
      actorRef.current.send({ type: "open.source", ...params });
    },
    openElementDetails: (fqn2, fromNode) => {
      actorRef.current.send({ type: "open.elementDetails", fqn: fqn2, fromNode });
    },
    openRelationshipDetails: (...params) => {
      params.length === 1 ? actorRef.current.send({ type: "open.relationshipDetails", params: { edgeId: params[0] } }) : actorRef.current.send({ type: "open.relationshipDetails", params: { source: params[0], target: params[1] } });
    },
    updateNodeData: (nodeId, data) => {
      actorRef.current.send({ type: "update.nodeData", nodeId, data });
    },
    updateEdgeData: (edgeId, data) => {
      actorRef.current.send({ type: "update.edgeData", edgeId, data });
    },
    startEditing: (subject) => {
      const editorActor = typedSystem(actorRef.current.system).editorActorRef;
      invariant(editorActor, "No editor actor found in diagram actor system"), editorActor.send({ type: "edit.start", subject });
    },
    stopEditing: (wasChanged = !1) => {
      const editorActor = typedSystem(actorRef.current.system).editorActorRef;
      invariant(editorActor, "No editor actor found in diagram actor system"), editorActor.send({ type: "edit.finish", wasChanged });
    },
    undoEditing: () => {
      const editorActor = typedSystem(actorRef.current.system).editorActorRef;
      invariant(editorActor, "No editor actor found in diagram actor system");
      const hasUndo = editorActor.getSnapshot().context.history.length > 0;
      return hasUndo && editorActor.send({ type: "undo" }), hasUndo;
    },
    align: (mode) => {
      actorRef.current.send({ type: "layout.align", mode });
    },
    resetEdgeControlPoints: () => {
      actorRef.current.send({ type: "layout.resetEdgeControlPoints" });
    },
    focusNode: (nodeId) => {
      actorRef.current.send({ type: "focus.node", nodeId });
    },
    focusOnElement: (elementFqn) => {
      const context2 = actorRef.current.getSnapshot().context, node2 = findNodeByModelFqn(context2.xynodes, elementFqn);
      node2 && actorRef.current.send({ type: "focus.node", nodeId: node2.id, autoUnfocus: !0 });
    },
    /**
     * @warning Do not use in render phase
     */
    get currentView() {
      return actorRef.current.getSnapshot().context.view;
    },
    /**
     * @warning Do not use in render phase
     */
    getContext: () => actorRef.current.getSnapshot().context,
    /**
     * @warning Do not use in render phase
     */
    findDiagramNode: (xynodeId) => findDiagramNode(actorRef.current.getSnapshot().context, xynodeId),
    findEdge: (xyedgeId) => actorRef.current.getSnapshot().context.xyedges.find((e2) => e2.data.id === xyedgeId) ?? null,
    /**
     * @warning Do not use in render phase
     */
    findDiagramEdge: (xyedgeId) => findDiagramEdge(actorRef.current.getSnapshot().context, xyedgeId),
    startWalkthrough: () => {
      actorRef.current.send({ type: "walkthrough.start" });
    },
    walkthroughStep: (direction = "next") => {
      actorRef.current.send({ type: "walkthrough.step", direction });
    },
    stopWalkthrough: () => {
      actorRef.current.send({ type: "walkthrough.end" });
    },
    toggleFeature: (feature, forceValue) => {
      actorRef.current.send({ type: "toggle.feature", feature, ...forceValue !== void 0 && { forceValue } });
    },
    highlightNotation: (notation, kind) => {
      actorRef.current.send({ type: "notations.highlight", notation, ...kind && { kind } });
    },
    unhighlightNotation: () => {
      actorRef.current.send({ type: "notations.unhighlight" });
    },
    openSearch: (searchValue) => {
      actorRef.current.send({ type: "open.search", ...searchValue && { search: searchValue } });
    },
    triggerChange: (change) => {
      actorRef.current.send({ type: "trigger.change", change });
    },
    switchDynamicViewVariant: (variant) => {
      actorRef.current.send({ type: "switch.dynamicViewVariant", variant });
    }
  };
}
function mergeXYNodesEdges(context2, event) {
  const nextView = event.view, isSameView = context2.view.id === nextView.id;
  if (nextView._type === "dynamic" && nextView.variant === "sequence")
    return {
      xynodes: event.xynodes,
      xyedges: event.xyedges,
      view: nextView
    };
  const xynodes = updateNodes(context2.xynodes, event.xynodes), xyedges = isSameView ? updateEdges(context2.xyedges, event.xyedges) : event.xyedges;
  return {
    xynodes,
    xyedges,
    view: nextView
  };
}
function focusNodesEdges(context2) {
  const { xynodes: _xynodes, xyedges: _xyedges, focusedNode } = context2;
  if (!focusedNode)
    return null;
  const focused2 = /* @__PURE__ */ new Set([focusedNode]), xyedges = _xyedges.map((edge) => edge.source === focusedNode || edge.target === focusedNode ? (focused2.add(edge.source), focused2.add(edge.target), Base.setData(edge, {
    dimmed: !1,
    active: !0
  })) : Base.setData(edge, {
    dimmed: !0,
    active: !1
  }));
  return {
    xynodes: _xynodes.map((n2) => Base.setDimmed(n2, !focused2.has(n2.id))),
    xyedges
  };
}
function updateNodeData({ context: context2, event }) {
  return assertEvent(event, "update.nodeData"), { xynodes: context2.xynodes.map((node2) => {
    if (node2.id !== event.nodeId)
      return node2;
    const data = n$6(node2.data, event.data);
    return deepEqual(data, node2.data) ? node2 : {
      ...node2,
      data
    };
  }) };
}
function updateEdgeData({ context: context2, event }) {
  return assertEvent(event, "update.edgeData"), { xyedges: context2.xyedges.map((edge) => {
    if (edge.id !== event.edgeId)
      return edge;
    const data = n$6(edge.data, event.data);
    return deepEqual(data, edge.data) ? edge : {
      ...edge,
      data
    };
  }) };
}
function getBorderPointOnVector(node2, nodeCenter, v) {
  const dimensions = getNodeDimensions(node2), xScale = dimensions.width / 2 / v.x, yScale = dimensions.height / 2 / v.y, scale2 = Math.min(Math.abs(xScale), Math.abs(yScale));
  return vector(v).multiply(scale2).add(nodeCenter);
}
function resetEdgeControlPoints(nodeLookup, edge) {
  const source = nonNullable$1(nodeLookup.get(edge.source), `Source node ${edge.source} not found`), target = nonNullable$1(nodeLookup.get(edge.target), `Target node ${edge.target} not found`), sourceCenter = vector(getNodeCenter(source)), targetCenter = vector(getNodeCenter(target));
  if (source === target) {
    const centerOfTopBoundary = vector(0, source.height || 0).multiply(-0.5).add(sourceCenter);
    return [
      centerOfTopBoundary.add(vector(-80 / 2.5, -80)).round().toObject(),
      centerOfTopBoundary.add(vector(80 / 2.5, -80)).round().toObject()
    ];
  }
  const sourceToTargetVector = targetCenter.subtract(sourceCenter), sourceBorderPoint = getBorderPointOnVector(source, sourceCenter, sourceToTargetVector), sourceToTarget = getBorderPointOnVector(target, targetCenter, sourceToTargetVector.multiply(-1)).subtract(sourceBorderPoint);
  return [
    sourceBorderPoint.add(sourceToTarget.multiply(0.4)).round().toObject(),
    sourceBorderPoint.add(sourceToTarget.multiply(0.6)).round().toObject()
  ];
}
function diagramToXY(opts) {
  const {
    view
  } = opts, xynodes = [], xyedges = [], nodeLookup = /* @__PURE__ */ new Map(), queue = Queue.from(view.nodes.reduce(
    (acc, node2) => (nodeLookup.set(node2.id, node2), node2.parent || acc.push({ node: node2, parent: null }), acc),
    []
  ));
  let visiblePredicate = (_nodeOrEdge) => !0;
  if (opts.where)
    try {
      const filterablePredicate = whereOperatorAsPredicate(opts.where);
      visiblePredicate = (i) => filterablePredicate({
        ...t$m(i, ["tags", "kind"]),
        ..."source" in i ? { source: nodeById(i.source) } : i,
        ..."target" in i ? { target: nodeById(i.target) } : i
      });
    } catch (e2) {
      console.error("Error in where filter:", e2);
    }
  const ns = "", nodeById = (id) => nonNullable$1(nodeLookup.get(id), `Node not found: ${id}`);
  let next;
  for (; next = queue.dequeue(); ) {
    const { node: node2, parent } = next, isCompound = t$1(node2.children, 1) || node2.kind == GroupElementKind;
    if (isCompound)
      for (const child of node2.children)
        queue.enqueue({ node: nodeById(child), parent: node2 });
    const position = {
      x: node2.x,
      y: node2.y
    };
    parent && (position.x -= parent.x, position.y -= parent.y);
    const base = {
      id: ns + node2.id,
      deletable: !1,
      position,
      zIndex: isCompound ? ZIndexes.Compound : ZIndexes.Element,
      style: {
        width: node2.width,
        height: node2.height
      },
      initialWidth: node2.width,
      initialHeight: node2.height,
      hidden: node2.kind !== GroupElementKind && !visiblePredicate(node2),
      ...parent && {
        parentId: ns + parent.id
      }
    }, compoundData = {
      viewId: view.id,
      id: node2.id,
      title: node2.title,
      color: node2.color,
      shape: node2.shape,
      style: node2.style,
      depth: node2.depth ?? 0,
      icon: node2.icon ?? "none",
      tags: node2.tags ?? null,
      x: node2.x,
      y: node2.y,
      drifts: node2.drifts ?? null
    }, leafNodeData = {
      viewId: view.id,
      id: node2.id,
      title: node2.title,
      technology: node2.technology ?? null,
      description: node2.description ?? null,
      height: node2.height,
      width: node2.width,
      level: node2.level,
      color: node2.color,
      shape: node2.shape,
      style: node2.style,
      icon: node2.icon ?? null,
      tags: node2.tags,
      x: node2.x,
      y: node2.y,
      isMultiple: node2.style?.multiple ?? !1,
      drifts: node2.drifts ?? null
    };
    if (node2.kind === GroupElementKind) {
      xynodes.push({
        ...base,
        type: "view-group",
        data: {
          isViewGroup: !0,
          ...compoundData
        },
        dragHandle: ".likec4-compound-title-container"
      });
      continue;
    }
    const modelFqn = node2.modelRef ?? null, deploymentFqn = node2.deploymentRef ?? null;
    if (!modelFqn && !deploymentFqn)
      throw console.error("Invalid node", node2), new Error("Element should have either modelRef or deploymentRef");
    const navigateTo = { navigateTo: node2.navigateTo ?? null };
    switch (!0) {
      case (isCompound && !!deploymentFqn): {
        xynodes.push(
          {
            ...base,
            type: "compound-deployment",
            data: {
              ...compoundData,
              ...navigateTo,
              deploymentFqn,
              modelFqn
            }
          }
        );
        break;
      }
      case isCompound: {
        invariant$1(!!modelFqn, "ModelRef expected"), xynodes.push(
          {
            ...base,
            type: "compound-element",
            data: {
              ...compoundData,
              ...navigateTo,
              modelFqn
            }
          }
        );
        break;
      }
      case !!deploymentFqn: {
        xynodes.push(
          {
            ...base,
            type: "deployment",
            data: {
              ...leafNodeData,
              ...navigateTo,
              deploymentFqn,
              modelFqn
            }
          }
        );
        break;
      }
      default:
        invariant$1(!!modelFqn, "ModelRef expected"), xynodes.push(
          {
            ...base,
            type: "element",
            data: {
              ...leafNodeData,
              ...navigateTo,
              modelFqn
            }
          }
        );
    }
  }
  for (const edge of view.edges) {
    const source = edge.source, target = edge.target, id = ns + edge.id;
    if (!t$1(edge.points, 2)) {
      console.error("edge should have at least 2 points", edge);
      continue;
    }
    xyedges.push({
      id,
      type: "relationship",
      source: ns + source,
      target: ns + target,
      zIndex: ZIndexes.Edge,
      hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        id: edge.id,
        label: edge.label,
        technology: edge.technology,
        notes: edge.notes ?? null,
        navigateTo: edge.navigateTo,
        controlPoints: edge.controlPoints ?? null,
        labelBBox: edge.labelBBox ?? null,
        labelXY: null,
        points: edge.points,
        color: edge.color ?? "gray",
        line: edge.line ?? "dashed",
        dir: edge.dir ?? "forward",
        head: edge.head ?? "normal",
        tail: edge.tail ?? "none",
        astPath: edge.astPath,
        drifts: edge.drifts ?? null
      },
      interactionWidth: 20
    });
  }
  return {
    bounds: view.bounds,
    xynodes,
    xyedges
  };
}
const SeqZIndex = {
  parallel: 1,
  actor: 10
}, SeqParallelAreaColor = {
  default: "gray",
  active: "amber"
};
function sequenceLayoutToXY(view) {
  const { actors, steps, compounds, parallelAreas, bounds } = view.sequenceLayout, xynodes = [], xyedges = [], getNode = (id) => nonNullable$1(view.nodes.find((n2) => n2.id === id));
  for (const compound of compounds)
    xynodes.push(toCompoundArea(compound, getNode(compound.origin), view));
  for (const parallelArea of parallelAreas)
    xynodes.push(toSeqParallelArea(parallelArea, view));
  for (const actor of actors)
    xynodes.push(toSeqActorNode(actor, getNode(actor.id), bounds, view));
  for (const step of steps) {
    const edge = view.edges.find((e2) => e2.id === step.id);
    if (!edge)
      throw new Error(`Edge ${step.id} not found`);
    xyedges.push(toSeqStepEdge(step, edge));
  }
  return {
    bounds,
    xynodes,
    xyedges
  };
}
function toCompoundArea({ id, x, y, width, height, depth }, node2, view) {
  return {
    id,
    type: "view-group",
    data: {
      id: node2.id,
      title: node2.title,
      color: node2.color ?? "gray",
      shape: node2.shape,
      style: node2.style,
      tags: node2.tags,
      x,
      y,
      viewId: view.id,
      depth,
      isViewGroup: !0,
      drifts: node2.drifts ?? null
    },
    // zIndex: SeqZIndex.compound,
    position: {
      x,
      y
    },
    draggable: !1,
    selectable: !1,
    focusable: !1,
    style: {
      pointerEvents: "none"
    },
    width,
    initialWidth: width,
    height,
    initialHeight: height
  };
}
function toSeqParallelArea({ parallelPrefix, x, y, width, height }, view) {
  return {
    id: `seq-parallel-${parallelPrefix}`,
    type: "seq-parallel",
    data: {
      id: `seq-parallel-${parallelPrefix}`,
      title: "PARALLEL",
      technology: null,
      color: SeqParallelAreaColor.default,
      shape: "rectangle",
      style: {},
      tags: [],
      x,
      y,
      level: 0,
      icon: null,
      width,
      height,
      description: null,
      viewId: view.id,
      parallelPrefix,
      drifts: null
    },
    zIndex: SeqZIndex.parallel,
    position: {
      x,
      y
    },
    draggable: !1,
    deletable: !1,
    selectable: !1,
    focusable: !1,
    style: {
      pointerEvents: "none"
    },
    width,
    initialWidth: width,
    height,
    initialHeight: height
  };
}
function toSeqActorNode({ id, x, y, width, height, ports }, actor, bounds, view) {
  return {
    id,
    type: "seq-actor",
    data: {
      id: actor.id,
      x,
      y,
      level: 0,
      icon: actor.icon ?? null,
      isMultiple: actor.style.multiple ?? !1,
      title: actor.title,
      width,
      height,
      color: actor.color,
      navigateTo: actor.navigateTo ?? null,
      shape: actor.shape,
      style: actor.style,
      tags: actor.tags,
      modelFqn: actor.modelRef ?? null,
      technology: actor.technology ?? null,
      description: actor.description ?? null,
      viewHeight: bounds.height,
      viewId: view.id,
      ports,
      drifts: actor.drifts ?? null
    },
    deletable: !1,
    selectable: !0,
    zIndex: SeqZIndex.actor,
    position: { x, y },
    width,
    initialWidth: width,
    height,
    initialHeight: height
  };
}
function toSeqStepEdge({ id, labelBBox, sourceHandle, targetHandle }, edge) {
  return {
    id,
    type: "seq-step",
    data: {
      id,
      label: edge.label,
      technology: edge.technology,
      notes: edge.notes ?? null,
      navigateTo: edge.navigateTo,
      controlPoints: null,
      labelBBox: {
        x: 0,
        y: 0,
        width: labelBBox?.width ?? edge.labelBBox?.width ?? 32,
        height: labelBBox?.height ?? edge.labelBBox?.height ?? 32
      },
      labelXY: null,
      points: edge.points,
      color: edge.color,
      line: edge.line,
      dir: "forward",
      head: edge.head ?? "normal",
      tail: edge.tail ?? "none",
      astPath: edge.astPath,
      drifts: edge.drifts ?? null
    },
    selectable: !0,
    focusable: !1,
    zIndex: 20,
    interactionWidth: 40,
    source: edge.source,
    sourceHandle,
    target: edge.target,
    targetHandle
  };
}
function convertToXYFlow({ dynamicViewVariant, ...params }) {
  const view = params.view, isDynamic = view._type === "dynamic", { bounds, xynodes, xyedges } = isDynamic && dynamicViewVariant === "sequence" ? sequenceLayoutToXY(view) : diagramToXY(params);
  return isDynamic && view.variant !== dynamicViewVariant ? {
    view: {
      ...view,
      bounds,
      variant: dynamicViewVariant
    },
    xynodes,
    xyedges
  } : {
    view: bounds === view.bounds ? view : {
      ...view,
      bounds
    },
    xynodes,
    xyedges
  };
}
class Aligner {
}
class LinearAligner extends Aligner {
  constructor(getEdgePosition2, computePosition2, propertyToEdit) {
    super(), this.getEdgePosition = getEdgePosition2, this.computePosition = computePosition2, this.propertyToEdit = propertyToEdit;
  }
  alignTo;
  computeLayout(nodes) {
    this.alignTo = this.getEdgePosition(nodes);
  }
  applyPosition(node2) {
    return {
      [this.propertyToEdit]: this.computePosition(this.alignTo, node2)
    };
  }
}
class GridAligner extends Aligner {
  layout = /* @__PURE__ */ new Map();
  axisPreset;
  get primaryAxisCoord() {
    return this.axisPreset.primaryAxisCoord;
  }
  get secondaryAxisCoord() {
    return this.axisPreset.secondaryAxisCoord;
  }
  get primaryAxisDimension() {
    return this.axisPreset.primaryAxisDimension;
  }
  get secondaryAxisDimension() {
    return this.axisPreset.secondaryAxisDimension;
  }
  constructor(alignmentMode) {
    super(), this.axisPreset = alignmentMode === "Column" ? {
      primaryAxisDimension: "width",
      secondaryAxisDimension: "height",
      primaryAxisCoord: "x",
      secondaryAxisCoord: "y"
    } : {
      primaryAxisDimension: "height",
      secondaryAxisDimension: "width",
      primaryAxisCoord: "y",
      secondaryAxisCoord: "x"
    };
  }
  applyPosition(node2) {
    return this.layout?.get(node2.id) ?? {};
  }
  computeLayout(nodes) {
    const sortedNodeRects = t$6(
      nodes,
      t$i((r2) => r2[this.primaryAxisCoord])
    ), layoutRect = this.getLayoutRect(sortedNodeRects), layers = this.getLayers(sortedNodeRects);
    this.layout = this.buildLayout(layers, layoutRect, sortedNodeRects);
  }
  getLayoutRect(nodeRects) {
    const x = Math.min(...nodeRects.map((n2) => n2.x)), y = Math.min(...nodeRects.map((n2) => n2.y)), right = Math.max(...nodeRects.map((n2) => n2.x + n2.width)), bottom = Math.max(...nodeRects.map((n2) => n2.y + n2.height));
    return {
      x,
      y,
      width: right - x,
      height: bottom - y
    };
  }
  getLayers(sortedNodeRects) {
    const layers = [];
    let layerEnd = 0, layer = null;
    for (let node2 of sortedNodeRects)
      if (layer && node2[this.primaryAxisCoord] < layerEnd)
        layer.nodes.push(node2), layer.primaryAxisSize = Math.max(layer.primaryAxisSize, node2[this.primaryAxisDimension]), layer.occupiedSpace += node2[this.secondaryAxisDimension], layerEnd = Math.max(
          node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension],
          layerEnd
        );
      else {
        layer = {
          primaryAxisSize: node2[this.primaryAxisDimension],
          nodes: [node2],
          occupiedSpace: node2[this.secondaryAxisDimension],
          layout: null
        }, layers.push(layer), layerEnd = node2[this.primaryAxisCoord] + node2[this.primaryAxisDimension];
        continue;
      }
    return layers.forEach((l) => l.nodes.sort((a, b) => a[this.secondaryAxisCoord] - b[this.secondaryAxisCoord])), layers;
  }
  buildLayout(layers, layoutRect, nodeRects) {
    const nodeMap = new Map(nodeRects.map((n2) => [n2.id, n2])), layout = [], occupiedSpace = layers.reduce((a, b) => a + b.primaryAxisSize, 0), rowMargin = layers.length > 1 ? (layoutRect[this.primaryAxisDimension] - occupiedSpace) / (layers.length - 1) : 0, baseLayerIndex = layers.reduce(
      (widestLayerIndex, layer, i) => layers[widestLayerIndex].occupiedSpace < layer.occupiedSpace ? i : widestLayerIndex,
      0
    ), baseLayer = layers[baseLayerIndex], baseLayerPosition = layers.slice(0, baseLayerIndex).reduce(
      (a, layer) => a + layer.primaryAxisSize + rowMargin,
      layoutRect[this.primaryAxisCoord]
    ), baseLayerLayout = this.buildLayerLayout(
      baseLayer,
      layoutRect,
      baseLayerPosition,
      nodeMap,
      null
    );
    baseLayer.layout = baseLayerLayout, layout.push(...baseLayerLayout.nodePositions);
    let placeNextLayerAt = baseLayerPosition + baseLayer.primaryAxisSize + rowMargin, refLayer = baseLayer;
    for (let i = baseLayerIndex + 1; i < layers.length; i++) {
      const layer = layers[i];
      layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer, placeNextLayerAt += layer.primaryAxisSize + rowMargin;
    }
    placeNextLayerAt = baseLayerPosition, refLayer = baseLayer;
    for (let i = baseLayerIndex - 1; i >= 0; i--) {
      const layer = layers[i];
      placeNextLayerAt -= layer.primaryAxisSize + rowMargin, layer.layout = this.buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer), layout.push(...layer.layout.nodePositions), refLayer = layer.layout.refLayer ?? layer;
    }
    return new Map(layout);
  }
  buildLayerLayout(layer, layoutRect, placeNextLayerAt, nodeMap, refLayer) {
    let bestLayerLayout = this.scoreLayout(
      this.spaceAround(layer, layoutRect, placeNextLayerAt),
      nodeMap
    );
    if (layer.nodes.length != 1) {
      const currentlayerLayout = this.scoreLayout(
        this.spaceBetween(layer, layoutRect, placeNextLayerAt),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length - 1 >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInGaps(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    if (refLayer && refLayer.nodes.length >= layer.nodes.length) {
      const currentlayerLayout = this.scoreLayout(
        this.placeInCells(layer, placeNextLayerAt, refLayer),
        nodeMap
      );
      bestLayerLayout = currentlayerLayout[0] < bestLayerLayout[0] ? currentlayerLayout : bestLayerLayout;
    }
    return bestLayerLayout[1];
  }
  spaceBetween(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length - 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord];
    const result = /* @__PURE__ */ new Map();
    for (let node2 of layer.nodes)
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  spaceAround(layer, layoutRect, placeNextLayerAt) {
    const margin = (layoutRect[this.secondaryAxisDimension] - layer.occupiedSpace) / (layer.nodes.length + 1);
    let placeNextNodeAt = layoutRect[this.secondaryAxisCoord] + margin;
    const result = /* @__PURE__ */ new Map();
    for (let node2 of t$i(layer.nodes, (n2) => n2[this.secondaryAxisCoord]))
      result.set(node2.id, {
        [this.secondaryAxisCoord]: placeNextNodeAt,
        [this.primaryAxisCoord]: placeNextLayerAt
      }), placeNextNodeAt += node2[this.secondaryAxisDimension] + margin;
    return { nodePositions: result, refLayer: null };
  }
  placeInGaps(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getGapsPositions(refLayer);
    let optionIndex = 0;
    for (let i = 0, node2 = nodes[i]; i < nodes.length; i++, node2 = nodes[i]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  placeInCells(layer, placeNextLayerAt, refLayer) {
    const result = /* @__PURE__ */ new Map(), nodes = layer.nodes, placementOptions = this.getNodePositions(refLayer);
    let optionIndex = 0;
    for (let i = 0, node2 = nodes[i]; i < nodes.length; i++, node2 = nodes[i]) {
      const nodeCenter = node2[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2;
      let bestOffset = 1 / 0;
      for (; optionIndex - i <= placementOptions.length - nodes.length; ) {
        const offset2 = placementOptions[optionIndex] - nodeCenter;
        if (Math.abs(offset2) < Math.abs(bestOffset))
          bestOffset = offset2, optionIndex++;
        else
          break;
      }
      result.set(node2.id, {
        [this.secondaryAxisCoord]: node2[this.secondaryAxisCoord] + bestOffset,
        [this.primaryAxisCoord]: placeNextLayerAt
      });
    }
    return { nodePositions: result, refLayer };
  }
  scoreLayout(layout, originalRects) {
    return [
      t$6(
        Array.from(layout.nodePositions),
        t$a(([id, position]) => {
          const originalRect = originalRects.get(id);
          return invariant$1(originalRect, `Could not find original rect for node ${id}`), [t$m(originalRect, ["x", "y"]), position];
        }),
        t$a(
          ([original, suggested]) => Math.abs(original[this.secondaryAxisCoord] - suggested[this.secondaryAxisCoord])
        ),
        t$g((a, b) => a + b, 0)
      ),
      layout
    ];
  }
  getGapsPositions(layer) {
    const result = [], { layout, nodes } = layer;
    invariant$1(layout, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i = 1; i < nodes.length; i++) {
      const previousNode = nodes[i - 1], currentNode = nodes[i], previousNodePosition = layout.nodePositions.get(previousNode.id), currentNodePosition = layout.nodePositions.get(currentNode.id);
      result.push(
        (currentNodePosition[this.secondaryAxisCoord] + previousNodePosition[this.secondaryAxisCoord] + previousNode[this.secondaryAxisDimension]) / 2
      );
    }
    return result;
  }
  getNodePositions(layer) {
    const result = [], { layout, nodes } = layer;
    invariant$1(layout, "Layout of the layer must be computed before calling getGapsPositions");
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i], nodePosition = layout.nodePositions.get(node2.id);
      result.push(
        nodePosition[this.secondaryAxisCoord] + node2[this.secondaryAxisDimension] / 2
      );
    }
    return result;
  }
}
function getLinearAligner(mode) {
  switch (mode) {
    case "Left":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x)),
        (alignTo, _) => Math.floor(alignTo),
        "x"
      );
    case "Top":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y)),
        (alignTo, _) => Math.floor(alignTo),
        "y"
      );
    case "Right":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.x + n2.width)),
        (alignTo, node2) => Math.floor(alignTo - node2.width),
        "x"
      );
    case "Bottom":
      return new LinearAligner(
        (nodes) => Math.max(...nodes.map((n2) => n2.y + n2.height)),
        (alignTo, node2) => Math.floor(alignTo - node2.height),
        "y"
      );
    case "Center":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.x + n2.width / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.width / 2),
        "x"
      );
    case "Middle":
      return new LinearAligner(
        (nodes) => Math.min(...nodes.map((n2) => n2.y + n2.height / 2)),
        (alignTo, node2) => Math.floor(alignTo - node2.height / 2),
        "y"
      );
  }
}
function toNodeRect(node2) {
  const { width, height } = getNodeDimensions(node2);
  return {
    ...node2.internals.positionAbsolute,
    id: node2.id,
    width,
    height
  };
}
function getAligner(mode) {
  switch (mode) {
    case "Left":
    case "Right":
    case "Top":
    case "Bottom":
    case "Center":
    case "Middle":
      return getLinearAligner(mode);
    case "Column":
    case "Row":
      return new GridAligner(mode);
    default:
      nonexhaustive(mode);
  }
}
const setViewport = (params) => machine$1.createAction(({ context: context2, event }) => {
  let viewport, duration;
  params ? (viewport = params.viewport, duration = params.duration) : (assertEvent(event, "xyflow.setViewport"), viewport = event.viewport, duration = event.duration), duration = duration ?? 400;
  const { panZoom } = nonNullable$1(context2.xystore).getState(), animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport({
    x: Math.round(viewport.x),
    y: Math.round(viewport.y),
    zoom: viewport.zoom
  }, animationProps).catch((err) => {
    console.error("Error during fitDiagram panZoom setViewport", { err });
  });
}), fitDiagram$1 = (params) => machine$1.enqueueActions(({ context: context2, event, enqueue }) => {
  let bounds = context2.view.bounds, duration;
  params ? (bounds = params.bounds ?? context2.view.bounds, duration = params.duration) : event.type === "xyflow.fitDiagram" && (bounds = event.bounds ?? context2.view.bounds, duration = event.duration, enqueue.assign({
    viewportChangedManually: !1
  })), duration ??= 450;
  const { width, height, panZoom, transform } = nonNullable$1(context2.xystore).getState(), maxZoom = Math.max(1, transform[2]), viewport = getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
  viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y);
  const animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport(viewport, animationProps).catch((err) => {
    console.error("Error during fitDiagram panZoom setViewport", { err });
  });
}), fitFocusedBounds = () => machine$1.createAction(({ context: context2 }) => {
  const isActiveSequenceWalkthrough = !!context2.activeWalkthrough && context2.dynamicViewVariant === "sequence", { bounds, duration = 450 } = isActiveSequenceWalkthrough ? activeSequenceBounds({ context: context2 }) : focusedBounds({ context: context2 }), { width, height, panZoom, transform } = nonNullable$1(context2.xystore).getState(), maxZoom = Math.max(1, transform[2]), viewport = getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
  viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y);
  const animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport(viewport, animationProps).catch((err) => {
    console.error("Error during fitFocusedBounds panZoom setViewport", { err });
  });
}), DEFAULT_DELAY = 30, raiseSetViewport = (params) => {
  const { delay: delay2 = DEFAULT_DELAY, ...rest } = params ?? {};
  return machine$1.raise(
    {
      type: "xyflow.setViewport",
      ...rest
    },
    {
      id: "fitDiagram",
      delay: delay2
    }
  );
}, cancelFitDiagram$1 = () => machine$1.cancel("fitDiagram"), raiseFitDiagram$1 = (params) => {
  const { delay: delay2 = DEFAULT_DELAY, ...rest } = params ?? {};
  return machine$1.raise(
    {
      type: "xyflow.fitDiagram",
      ...rest
    },
    {
      id: "fitDiagram",
      delay: delay2
    }
  );
}, raiseUpdateView = (view) => machine$1.raise(({ context: context2 }) => ({
  type: "update.view",
  view: context2.view
}), { delay: DEFAULT_DELAY }), assignViewportBefore = (viewport) => machine$1.assign(({ context: context2 }) => ({
  // We can assign
  viewportBefore: {
    wasChangedManually: context2.viewportChangedManually,
    value: { ...context2.viewport }
  }
})), returnViewportBefore = (params) => machine$1.enqueueActions(({ enqueue, context: { viewportBefore } }) => {
  enqueue(cancelFitDiagram$1()), viewportBefore ? (enqueue.assign({
    viewportChangedManually: viewportBefore.wasChangedManually,
    viewportBefore: null
  }), params && params.delay === 0 ? enqueue(setViewport({ viewport: viewportBefore.value, ...params })) : enqueue(raiseSetViewport({ viewport: viewportBefore.value, ...params }))) : params && params.delay === 0 ? enqueue(fitDiagram$1({ ...params })) : enqueue(raiseFitDiagram$1({ ...params }));
}), disableCompareWithLatest = () => machine$1.assign(({ context: context2 }) => ({
  toggledFeatures: {
    ...context2.toggledFeatures,
    enableCompareWithLatest: !1
  },
  viewportOnAutoLayout: null,
  viewportOnManualLayout: null
})), onEdgeDoubleClick = () => machine$1.assign(({ context: context2, event }) => {
  if (assertEvent(event, "xyflow.edgeDoubleClick"), !event.edge.data.controlPoints)
    return {};
  const { nodeLookup } = context2.xystore.getState();
  return {
    xyedges: context2.xyedges.map((e2) => {
      if (e2.id === event.edge.id) {
        const controlPoints = resetEdgeControlPoints(nodeLookup, e2), pt = controlPoints[0];
        return {
          ...e2,
          data: {
            ...e2.data,
            controlPoints,
            labelBBox: e2.data.labelBBox ? { ...e2.data.labelBBox, ...pt } : null,
            labelXY: null
          }
        };
      }
      return e2;
    })
  };
}), assignLastClickedNode = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "xyflow.nodeClick");
  const { lastClickedNode } = context2;
  return !lastClickedNode || lastClickedNode.id !== event.node.id ? {
    lastClickedNode: {
      id: event.node.id,
      clicks: 1,
      timestamp: Date.now()
    }
  } : {
    lastClickedNode: {
      id: lastClickedNode.id,
      clicks: lastClickedNode.clicks + 1,
      timestamp: Date.now()
    }
  };
}), assignFocusedNode = () => machine$1.assign(({ event }) => {
  let focusedNode, autoUnfocusTimer = !1;
  switch (event.type) {
    case "xyflow.nodeClick":
      focusedNode = event.node.data.id;
      break;
    case "focus.node":
      focusedNode = event.nodeId, autoUnfocusTimer = event.autoUnfocus === !0;
      break;
    default:
      throw new Error(`Unexpected event type: ${event.type} in action 'assign: focusedNode'`);
  }
  return {
    focusedNode,
    autoUnfocusTimer
  };
}), resetLastClickedNode = () => machine$1.assign(() => ({
  lastClickedNode: null
})), updateFeatures = () => machine$1.assign(({ event }) => (assertEvent(event, "update.features"), {
  features: { ...event.features }
})), updateInputs = () => machine$1.assign(({ event }) => (assertEvent(event, "update.inputs"), { ...event.inputs })), assignXYDataFromView = (view) => machine$1.assign(({ context: context2, event }) => {
  let xydata;
  assertEvent(event, "update.view"), xydata = "xynodes" in event ? event : convertToXYFlow({
    dynamicViewVariant: context2.dynamicViewVariant,
    view: event.view,
    where: context2.where
  });
  const update = mergeXYNodesEdges(context2, xydata);
  let { lastClickedNode, focusedNode, activeWalkthrough } = context2;
  if (lastClickedNode || focusedNode || activeWalkthrough) {
    const nodeIds = new Set(update.xynodes.map((n2) => n2.id));
    lastClickedNode && !nodeIds.has(lastClickedNode.id) && (lastClickedNode = null), focusedNode && !nodeIds.has(focusedNode) && (focusedNode = null);
    const stepId = activeWalkthrough?.stepId;
    return stepId && !update.xyedges.some((e2) => e2.id === stepId) && (activeWalkthrough = null), {
      ...update,
      lastClickedNode,
      focusedNode,
      activeWalkthrough
    };
  }
  return update;
}), focusOnNodesAndEdges = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  const next = focusNodesEdges(context2);
  next ? enqueue.assign(next) : enqueue.raise({ type: "key.esc" });
}), undimEverything = () => machine$1.assign(({ context: context2 }) => ({
  xynodes: context2.xynodes.map(Base.setDimmed(!1)),
  xyedges: context2.xyedges.map(Base.setData({
    dimmed: !1,
    active: !1
  }))
})), assignDynamicViewVariant = () => machine$1.assign(({ event }) => (assertEvent(event, "switch.dynamicViewVariant"), {
  dynamicViewVariant: event.variant
})), onNodeMouseEnter = (params) => machine$1.assign(({ context: context2, event }) => {
  let node2 = params?.node;
  return node2 || (assertEvent(event, "xyflow.nodeMouseEnter"), node2 = event.node), {
    xynodes: context2.xynodes.map((n2) => n2.id === node2.id ? Base.setHovered(n2, !0) : n2)
  };
}), onNodeMouseLeave = (params) => machine$1.assign(({ context: context2, event }) => {
  let node2 = params?.node;
  return node2 || (assertEvent(event, "xyflow.nodeMouseLeave"), node2 = event.node), {
    xynodes: context2.xynodes.map((n2) => n2.id === node2.id ? Base.setHovered(n2, !1) : n2)
  };
}), emitPaneClick = () => machine$1.emit(() => ({
  type: "paneClick"
})), emitOpenSource = (params) => machine$1.emit(({ event }) => params ? {
  type: "openSource",
  params
} : (assertEvent(event, "open.source"), {
  type: "openSource",
  params: event
})), emitInitialized = () => machine$1.emit(({ context: context2 }) => (invariant$1(context2.xyflow, "XYFlow instance not found"), {
  type: "initialized",
  instance: context2.xyflow
})), emitNodeClick = () => machine$1.emit(({ context: context2, event }) => (assertEvent(event, "xyflow.nodeClick"), {
  type: "nodeClick",
  node: nonNullable$1(findDiagramNode(context2, event.node.id), `Node ${event.node.id} not found in diagram`),
  xynode: event.node
})), emitNavigateTo = (params) => machine$1.emit(({ context: context2 }) => ({
  type: "navigateTo",
  viewId: params?.viewId ?? nonNullable$1(context2.lastOnNavigate, "Invalid state, lastOnNavigate is null").toView
})), emitEdgeClick = () => machine$1.emit(({ context: context2, event }) => (assertEvent(event, "xyflow.edgeClick"), {
  type: "edgeClick",
  edge: nonNullable$1(findDiagramEdge(context2, event.edge.id), `Edge ${event.edge.id} not found in diagram`),
  xyedge: event.edge
})), triggerChange = (viewChange) => machine$1.enqueueActions(({ event, enqueue }) => {
  let change = viewChange;
  change || (assertEvent(event, "trigger.change"), change = event.change), enqueue.assign({
    viewportChangedManually: !0
  }), enqueue.sendTo(
    typedSystem.editorActor,
    {
      type: "change",
      change
    }
  );
}), emitOnLayoutTypeChange = () => machine$1.enqueueActions(({ event, system, context: context2, enqueue }) => {
  if (!context2.features.enableCompareWithLatest) {
    console.warn("Layout type cannot be changed while CompareWithLatest feature is disabled");
    return;
  }
  const currentLayoutType = context2.view._layout;
  let nextLayoutType = currentLayoutType === "auto" ? "manual" : "auto";
  if (event.type === "emit.onLayoutTypeChange" && (nextLayoutType = event.layoutType), currentLayoutType === nextLayoutType) {
    console.warn("Ignoring layout type change event, layout type is already", currentLayoutType);
    return;
  }
  if (context2.toggledFeatures.enableCompareWithLatest === !0) {
    currentLayoutType === "manual" && nextLayoutType === "auto" && typedSystem(system).editorActorRef?.send({
      type: "cancel"
    });
    const currentViewport = context2.viewport;
    currentLayoutType === "auto" && enqueue.assign({
      viewportOnAutoLayout: currentViewport
    }), currentLayoutType === "manual" && enqueue.assign({
      viewportOnManualLayout: currentViewport
    });
  }
  enqueue.emit({
    type: "onLayoutTypeChange",
    layoutType: nextLayoutType
  });
}), layoutAlign = (params) => machine$1.createAction(({ context: context2, event }) => {
  let mode;
  assertEvent(event, "layout.align"), mode = event.mode;
  const xystore = nonNullable$1(context2.xystore, "xystore is not initialized"), { nodeLookup, parentLookup } = xystore.getState(), nodesToAlign = [...new Set(nodeLookup.values().filter((n2) => n2.selected).map((n2) => n2.id)).difference(new Set(parentLookup.keys()))];
  if (!t$1(nodesToAlign, 2)) {
    console.warn("At least 2 nodes must be selected to align");
    return;
  }
  const constraints = createLayoutConstraints(xystore, nodesToAlign), aligner = getAligner(mode), nodes = nodesToAlign.map((id) => ({
    node: nonNullable$1(nodeLookup.get(id)),
    rect: nonNullable$1(constraints.rects.get(id))
  }));
  aligner.computeLayout(nodes.map(({ node: node2 }) => toNodeRect(node2)));
  for (const { rect, node: node2 } of nodes)
    rect.positionAbsolute = {
      ...rect.positionAbsolute,
      ...aligner.applyPosition(toNodeRect(node2))
    };
  constraints.updateXYFlow();
}), resetEdgesControlPoints = () => machine$1.assign(({ context: context2 }) => {
  const { nodeLookup } = context2.xystore.getState();
  return {
    xyedges: context2.xyedges.map((edge) => {
      if (!edge.data.controlPoints)
        return edge;
      const controlPoints = resetEdgeControlPoints(nodeLookup, edge), pt = controlPoints[0];
      return {
        ...edge,
        data: {
          ...edge.data,
          controlPoints,
          labelBBox: edge.data.labelBBox ? { ...edge.data.labelBBox, x: pt.x, y: pt.y } : null,
          labelXY: edge.data.labelXY ? pt : null
        }
      };
    })
  };
}), notationsHighlight = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "notations.highlight");
  const { notation, kind } = event, targetKinds = kind ? [kind] : notation.kinds, shouldHighlight = (node2) => node2.notation === notation.title && node2.shape === notation.shape && node2.color === notation.color && targetKinds.includes(node2.kind), xynodes = context2.xynodes.map((n2) => {
    const node2 = findDiagramNode(context2, n2.id), highlighted = node2 && shouldHighlight(node2);
    return Base.setDimmed(n2, highlighted ? !1 : "immediate");
  }), xyedges = context2.xyedges.map((edge) => Base.setDimmed(edge, !0));
  return { xynodes, xyedges };
}), tagHighlight = () => machine$1.assign(({ context: context2, event }) => (assertEvent(event, "tag.highlight"), {
  xynodes: context2.xynodes.map((n2) => n2.data.tags?.includes(event.tag) ? Base.setDimmed(n2, !1) : Base.setDimmed(n2, !0))
})), assignToggledFeatures = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "toggle.feature");
  const currentValue = context2.toggledFeatures[`enable${event.feature}`] ?? context2.features[`enable${event.feature}`], nextValue = event.forceValue ?? !currentValue;
  return {
    toggledFeatures: {
      ...context2.toggledFeatures,
      [`enable${event.feature}`]: nextValue
    }
  };
}), closeSearch = () => machine$1.sendTo(
  typedSystem.searchActor,
  {
    type: "close"
  }
), closeAllOverlays = () => machine$1.sendTo(
  typedSystem.overlaysActor,
  {
    type: "close.all"
  }
), stopEditorActor = () => machine$1.enqueueActions(({ enqueue, system }) => {
  const actor = typedSystem(system).editorActorRef;
  actor && enqueue.stopChild(actor);
}), ensureEditorActor = () => machine$1.enqueueActions(({ enqueue, context: context2, system, check }) => {
  const hasEditor = check("enabled: Editor"), editor = typedSystem(system).editorActorRef;
  if (!hasEditor && editor) {
    enqueue.stopChild(editor);
    return;
  }
  hasEditor && !editor && enqueue.spawnChild("editorActor", {
    id: "editor",
    systemId: "editor",
    input: {
      viewId: context2.view.id
    },
    syncSnapshot: !0
  });
}), startEditing = (subject = "node") => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "edit.start",
    subject
  }
), sendSynced = () => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "synced"
  }
), stopEditing = (wasChanged = !0) => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "edit.finish",
    wasChanged
  }
), cancelEditing = () => machine$1.sendTo(
  typedSystem.editorActor,
  {
    type: "cancel"
  }
), hasModelFqn = (node2) => "modelFqn" in node2.data && e$8(node2.data.modelFqn), openElementDetails = (params) => machine$1.enqueueActions(({ context: context2, event, enqueue }) => {
  let initiatedFrom = null, fromNodeId, subject;
  switch (!0) {
    case event.type === "xyflow.nodeClick": {
      if (!hasModelFqn(event.node)) {
        console.warn("No modelFqn in clicked node data");
        return;
      }
      subject = event.node.data.modelFqn, fromNodeId = event.node.data.id;
      break;
    }
    case event.type === "open.elementDetails": {
      subject = event.fqn, fromNodeId = event.fromNode;
      break;
    }
    default: {
      if (!context2.lastClickedNode) {
        console.warn("No last clicked node");
        return;
      }
      fromNodeId = context2.lastClickedNode.id;
      const node2 = context2.xynodes.find((n2) => n2.id === fromNodeId);
      if (!node2 || !hasModelFqn(node2)) {
        console.warn("No modelFqn in last clicked node");
        return;
      }
      subject = node2.data.modelFqn;
      break;
    }
  }
  const internalNode = fromNodeId ? context2.xystore.getState().nodeLookup.get(fromNodeId) : null;
  if (fromNodeId && internalNode) {
    const nodeRect = nodeToRect$1(internalNode), zoom = context2.xyflow.getZoom(), clientRect = {
      ...context2.xyflow.flowToScreenPosition(nodeRect),
      width: nodeRect.width * zoom,
      height: nodeRect.height * zoom
    };
    initiatedFrom = {
      node: fromNodeId,
      clientRect
    };
  }
  enqueue.sendTo(
    typedSystem.overlaysActor,
    {
      type: "open.elementDetails",
      subject,
      currentView: context2.view,
      ...initiatedFrom && { initiatedFrom }
    }
  );
}), openOverlay = () => machine$1.enqueueActions(({ context: context2, event, enqueue, check }) => {
  if (assertEvent(event, ["open.relationshipsBrowser", "open.relationshipDetails", "open.elementDetails"]), !check("enabled: Overlays")) {
    console.warn("Overlays feature is disabled");
    return;
  }
  switch (event.type) {
    case "open.elementDetails": {
      check("enabled: ElementDetails") ? enqueue(openElementDetails()) : console.warn("ElementDetails feature is disabled");
      break;
    }
    case "open.relationshipsBrowser": {
      enqueue.sendTo(
        typedSystem.overlaysActor,
        {
          type: "open.relationshipsBrowser",
          subject: event.fqn,
          viewId: context2.view.id,
          scope: "view",
          closeable: !0,
          enableChangeScope: !0,
          enableSelectSubject: !0
        }
      );
      break;
    }
    case "open.relationshipDetails": {
      enqueue.sendTo(
        typedSystem.overlaysActor,
        {
          type: "open.relationshipDetails",
          viewId: context2.view.id,
          ...event.params
        }
      );
      break;
    }
    default:
      nonexhaustive(event);
  }
}), openSourceOfFocusedOrLastClickedNode = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  const nodeId = context2.focusedNode ?? context2.lastClickedNode?.id;
  if (!nodeId || !context2.features.enableVscode) return;
  const diagramNode = findDiagramNode(context2, nodeId);
  diagramNode && (diagramNode.deploymentRef ? enqueue.raise({ type: "open.source", deployment: diagramNode.deploymentRef }) : diagramNode.modelRef && enqueue.raise({ type: "open.source", element: diagramNode.modelRef }));
}), ensureOverlaysActor = () => machine$1.enqueueActions(({ enqueue, check, system }) => {
  const enableOverlays = check("enabled: Overlays"), hasRunning = typedSystem(system).overlaysActorRef;
  if (enableOverlays && !hasRunning) {
    enqueue.spawnChild("overlaysActorLogic", { id: "overlays", systemId: "overlays" });
    return;
  }
  !enableOverlays && hasRunning && (enqueue.sendTo(hasRunning, {
    type: "close.all"
  }), enqueue.stopChild("overlays"));
}), ensureSearchActor = () => machine$1.enqueueActions(({ enqueue, context: { features: { enableSearch } }, system }) => {
  const hasRunning = typedSystem(system).searchActorRef;
  if (enableSearch && !hasRunning) {
    enqueue.spawnChild("searchActorLogic", { id: "search", systemId: "search" });
    return;
  }
  !enableSearch && hasRunning && (enqueue.sendTo(hasRunning, {
    type: "close"
  }), enqueue.stopChild("search"));
}), onEdgeMouseEnter = () => machine$1.enqueueActions(({ enqueue, context: context2, event }) => {
  assertEvent(event, "xyflow.edgeMouseEnter");
  let edge = event.edge;
  enqueue.assign({
    xyedges: context2.xyedges.map((e2) => e2.id === event.edge.id ? (edge = Base.setHovered(e2, !0), edge) : e2)
  }), enqueue.emit({
    type: "edgeMouseEnter",
    edge,
    event: event.event
  });
}), onEdgeMouseLeave = () => machine$1.enqueueActions(({ enqueue, context: context2, event }) => {
  assertEvent(event, "xyflow.edgeMouseLeave");
  let edge = event.edge;
  enqueue.assign({
    xyedges: context2.xyedges.map((e2) => e2.id === event.edge.id ? (edge = Base.setHovered(e2, !1), edge) : e2)
  }), enqueue.emit({
    type: "edgeMouseLeave",
    edge,
    event: event.event
  });
}), startHotKeyActor = () => machine$1.spawnChild("hotkeyActorLogic", { id: "hotkey" }), stopHotKeyActor = () => machine$1.stopChild("hotkey"), AUTO_UNFOCUS_DELAY = 3e3, startAutoUnfocusTimer = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  context2.autoUnfocusTimer && AUTO_UNFOCUS_DELAY > 0 && enqueue.raise({ type: "focus.autoUnfocus" }, { delay: AUTO_UNFOCUS_DELAY, id: "autoUnfocusTimer" });
}), cancelAutoUnfocusTimer = () => machine$1.cancel("autoUnfocusTimer"), handleNavigate = () => machine$1.enqueueActions(({ enqueue, context: context2, event }) => {
  assertEvent(event, ["navigate.to", "navigate.back", "navigate.forward"]);
  const {
    view,
    focusedNode,
    activeWalkthrough,
    dynamicViewVariant,
    viewport,
    viewportChangedManually,
    viewportBefore,
    navigationHistory: {
      currentIndex,
      history: _history
    }
  } = context2;
  let history = [..._history];
  if (currentIndex < _history.length) {
    const updatedEntry = produce(_history[currentIndex], (draft) => {
      draft.viewport = { ...viewport }, draft.viewportChangedManually = viewportChangedManually, draft.focusedNode = focusedNode, view._type === "dynamic" ? (draft.activeWalkthrough = activeWalkthrough?.stepId ?? null, draft.dynamicViewVariant = dynamicViewVariant) : (draft.activeWalkthrough = null, draft.dynamicViewVariant = null), viewportBefore ? draft.viewportBefore = viewportBefore : delete draft.viewportBefore;
    });
    history = [..._history], history[currentIndex] = updatedEntry;
  }
  switch (event.type) {
    case "navigate.to": {
      enqueue.assign({
        navigationHistory: {
          currentIndex,
          history
        },
        lastOnNavigate: {
          fromView: context2.view.id,
          toView: event.viewId,
          fromNode: event.fromNode ?? null,
          focusOnElement: event.focusOnElement ?? null
        }
      }), enqueue(emitNavigateTo());
      break;
    }
    case "navigate.back": {
      invariant$1(currentIndex > 0, "Cannot navigate back");
      const stepBack = history[currentIndex - 1];
      enqueue.assign({
        navigationHistory: {
          currentIndex: currentIndex - 1,
          history
        },
        lastOnNavigate: null
      }), enqueue(emitNavigateTo({ viewId: stepBack.viewId }));
      break;
    }
    case "navigate.forward": {
      invariant$1(currentIndex < history.length - 1, "Cannot navigate forward");
      const stepForward = history[currentIndex + 1];
      enqueue.assign({
        navigationHistory: {
          currentIndex: currentIndex + 1,
          history
        },
        lastOnNavigate: null
      }), enqueue(emitNavigateTo({ viewId: stepForward.viewId }));
      break;
    }
    default:
      nonexhaustive(event);
  }
}), updateView$1 = () => machine$1.enqueueActions(
  ({ enqueue, event, context: context2 }) => {
    if (event.type !== "update.view") {
      console.warn(`Ignoring unexpected event type: ${event.type} in action 'update.view'`);
      return;
    }
    const nextView = event.view;
    if (nextView.id !== context2.view.id) {
      console.warn("updateView called for another view - ignoring", { event });
      return;
    }
    if (enqueue(assignXYDataFromView()), event.source === "editor")
      return;
    enqueue(sendSynced());
    let recenter = !context2.viewportChangedManually && !context2.focusedNode && !context2.activeWalkthrough;
    if (context2.toggledFeatures.enableCompareWithLatest === !0 && context2.view._layout !== nextView._layout) {
      if (nextView._layout === "auto" && context2.viewportOnAutoLayout) {
        enqueue(
          setViewport({
            viewport: context2.viewportOnAutoLayout,
            duration: 0
          })
        );
        return;
      }
      if (nextView._layout === "manual" && context2.viewportOnManualLayout) {
        enqueue(
          setViewport({
            viewport: context2.viewportOnManualLayout,
            duration: 0
          })
        );
        return;
      }
    }
    recenter = recenter || nextView._type === "dynamic" && context2.view._type === "dynamic" && nextView.variant !== context2.view.variant, recenter = recenter || context2.toggledFeatures.enableCompareWithLatest === !0 && !!nextView._layout && context2.view._layout !== nextView._layout, recenter && (enqueue(cancelFitDiagram$1()), enqueue(raiseFitDiagram$1({
      bounds: event.view.bounds
    })));
  }
), initializing = machine$1.createStateConfig({
  on: {
    "xyflow.init": {
      actions: assign(({ context: context2, event }) => ({
        initialized: {
          ...context2.initialized,
          xyflow: !0
        },
        xyflow: event.instance
      })),
      target: "isReady"
    },
    "update.view": {
      actions: [
        assignXYDataFromView(),
        assign(({ context: context2 }) => ({
          initialized: {
            ...context2.initialized,
            xydata: !0
          }
        }))
      ],
      target: "isReady"
    }
  }
}), isReady = machine$1.createStateConfig({
  always: [{
    guard: "isReady",
    actions: [
      fitDiagram$1({ duration: 0 }),
      assign(({ context: context2 }) => ({
        navigationHistory: {
          currentIndex: 0,
          history: [{
            viewId: context2.view.id,
            viewport: { ...context2.xyflow.getViewport() },
            viewportChangedManually: !1
          }]
        }
      })),
      emitInitialized()
    ],
    target: "ready"
  }, {
    target: "initializing"
  }]
}), handleBrowserForwardBackward = () => machine$1.assign(({ context: context2, event }) => {
  assertEvent(event, "update.view");
  let {
    lastOnNavigate,
    navigationHistory: {
      currentIndex,
      history
    }
  } = context2;
  const stepCurrent = history[currentIndex];
  if (!stepCurrent || stepCurrent.viewId === event.view.id || lastOnNavigate)
    return {};
  const stepBack = currentIndex > 0 ? nonNullable(history[currentIndex - 1]) : null;
  if (stepBack && stepBack.viewId === event.view.id)
    return {
      navigationHistory: {
        currentIndex: currentIndex - 1,
        history
      },
      lastOnNavigate: null
    };
  const stepForward = currentIndex < history.length - 1 ? nonNullable(history[currentIndex + 1]) : null;
  if (stepForward && stepForward.viewId === event.view.id)
    return {
      navigationHistory: {
        currentIndex: currentIndex + 1,
        history
      },
      lastOnNavigate: null
    };
  if (event.view._type === "element" && event.view.viewOf) {
    const toRef = event.view.viewOf, existingNode = context2.xynodes.find((n2) => nodeRef(n2) === toRef);
    if (existingNode)
      return {
        lastOnNavigate: {
          fromView: context2.view.id,
          toView: event.view.id,
          fromNode: existingNode.id
        }
      };
  }
  return {};
}), navigating = machine$1.createStateConfig({
  id: targetState.navigating.slice(1),
  always: {
    target: targetState.idle,
    actions: [
      cancelFitDiagram$1(),
      handleBrowserForwardBackward(),
      disableCompareWithLatest(),
      enqueueActions(({ enqueue, context: context2, event }) => {
        assertEvent(event, "update.view");
        const {
          xyflow: xyflow2,
          xystore,
          navigationHistory: {
            currentIndex,
            history
          }
        } = context2, eventWithXYData = "xynodes" in event ? event : {
          ...event,
          ...convertToXYFlow({
            dynamicViewVariant: context2.dynamicViewVariant,
            view: event.view,
            where: context2.where
          })
        };
        invariant(xyflow2, "xyflow is not initialized");
        const calcZoomTowardsNextViewport = (nextViewport2) => {
          const zoom = xyflow2.getZoom(), coef = nextViewport2.zoom < zoom ? 0.8 : 0.4;
          return zoom + (nextViewport2.zoom - zoom) * coef;
        }, fromHistory = history[currentIndex];
        if (fromHistory && fromHistory.viewId === event.view.id) {
          enqueue.assign({
            ...mergeXYNodesEdges(context2, eventWithXYData),
            dynamicViewVariant: fromHistory.dynamicViewVariant ?? context2.dynamicViewVariant,
            viewportChangedManually: fromHistory.viewportChangedManually
          });
          const wasFocused = fromHistory.focusedNode, wasActiveWalkthrough = fromHistory.activeWalkthrough, viewportBefore = fromHistory.viewportBefore;
          viewportBefore && (wasFocused || wasActiveWalkthrough) && enqueue.assign({
            viewport: viewportBefore.value,
            viewportChangedManually: viewportBefore.wasChangedManually,
            viewportBefore: null
          });
          const center = BBox$1.center(event.view.bounds), zoom = calcZoomTowardsNextViewport(fromHistory.viewport);
          if (xyflow2.setCenter(
            center.x,
            center.y,
            { zoom, duration: 0 }
          ), wasFocused) {
            enqueue.raise({
              type: "focus.node",
              nodeId: wasFocused
            }, { delay: 50 });
            return;
          }
          if (wasActiveWalkthrough) {
            enqueue.raise({
              type: "walkthrough.start",
              stepId: wasActiveWalkthrough
            }, { delay: 50 });
            return;
          }
          enqueue(raiseSetViewport({
            delay: 80,
            viewport: fromHistory.viewport
          }));
          return;
        }
        const nextViewport = calcViewportForBounds(
          context2,
          event.view.bounds
        ), { fromNode, toNode } = findCorrespondingNode(context2, eventWithXYData);
        if (fromNode && toNode) {
          const elFrom = xyflow2.getInternalNode(fromNode.id), fromPoint = xyflow2.flowToScreenPosition({
            x: elFrom.internals.positionAbsolute.x,
            y: elFrom.internals.positionAbsolute.y
          }), toPoint = xyflow2.flowToScreenPosition({
            x: toNode.data.x,
            y: toNode.data.y
          });
          xystore.getState().panBy({
            x: Math.round(fromPoint.x - toPoint.x),
            y: Math.round(fromPoint.y - toPoint.y)
          });
        } else {
          const zoom = calcZoomTowardsNextViewport(nextViewport), center = BBox$1.center(event.view.bounds);
          xyflow2.setCenter(
            center.x,
            center.y,
            { zoom, duration: 0 }
          );
        }
        const updatedHistory = currentIndex < history.length - 1 ? history.slice(0, currentIndex + 1) : [...history];
        updatedHistory.push({
          viewId: event.view.id,
          viewport: { ...nextViewport },
          viewportChangedManually: !1
        });
        const focusOnElement = context2.lastOnNavigate?.focusOnElement, nodeToFocus = e$8(focusOnElement) ? findNodeByModelFqn(eventWithXYData.xynodes, focusOnElement) : null;
        enqueue.assign({
          ...mergeXYNodesEdges(context2, eventWithXYData),
          viewportChangedManually: !1,
          lastOnNavigate: null,
          navigationHistory: {
            currentIndex: updatedHistory.length - 1,
            history: updatedHistory
          }
        }), nodeToFocus ? enqueue.raise({
          type: "focus.node",
          nodeId: nodeToFocus.id,
          autoUnfocus: !0
        }, { delay: 150 }) : enqueue(raiseFitDiagram$1({
          delay: 100
        }));
      })
    ]
  }
}), focused = machine$1.createStateConfig({
  id: targetState.focused.slice(1),
  entry: [
    cancelFitDiagram$1(),
    focusOnNodesAndEdges(),
    assignViewportBefore(),
    openSourceOfFocusedOrLastClickedNode(),
    startHotKeyActor(),
    fitFocusedBounds(),
    startAutoUnfocusTimer()
  ],
  exit: [
    stopHotKeyActor(),
    undimEverything(),
    returnViewportBefore(),
    cancelAutoUnfocusTimer(),
    assign({
      focusedNode: null,
      autoUnfocusTimer: !1
    })
  ],
  on: {
    "focus.autoUnfocus": {
      target: targetState.idle
    },
    "xyflow.nodeClick": [
      {
        guard: and([
          "enabled: ElementDetails",
          "click: focused node",
          "click: node has modelFqn"
        ]),
        actions: [
          assignLastClickedNode(),
          openElementDetails(),
          emitNodeClick()
        ]
      },
      {
        guard: "click: focused node",
        actions: [
          assignLastClickedNode(),
          emitNodeClick()
        ],
        target: targetState.idle
      },
      {
        actions: [
          assignLastClickedNode(),
          raise(({ event }) => ({
            type: "focus.node",
            nodeId: event.node.id
          })),
          emitNodeClick()
        ]
      }
    ],
    "focus.node": {
      actions: [
        assignFocusedNode(),
        focusOnNodesAndEdges(),
        openSourceOfFocusedOrLastClickedNode(),
        fitFocusedBounds()
      ]
    },
    "key.esc": {
      target: targetState.idle
    },
    "xyflow.paneClick": {
      actions: [
        resetLastClickedNode(),
        emitPaneClick()
      ],
      target: targetState.idle
    },
    "notations.unhighlight": {
      actions: focusOnNodesAndEdges()
    },
    "tag.unhighlight": {
      actions: focusOnNodesAndEdges()
    },
    "update.view": {
      guard: "is same view",
      actions: [
        updateView$1(),
        focusOnNodesAndEdges()
      ]
    }
  }
}), idle = machine$1.createStateConfig({
  id: targetState.idle.slice(1),
  on: {
    "xyflow.nodeClick": [
      {
        guard: and([
          "enabled: Readonly",
          "enabled: FocusMode",
          "click: node has connections",
          or([
            "click: same node",
            "click: selected node"
          ])
        ]),
        actions: [
          assignLastClickedNode(),
          assignFocusedNode(),
          emitNodeClick()
        ],
        target: targetState.focused
      },
      {
        guard: and([
          "enabled: Readonly",
          "enabled: ElementDetails",
          "click: node has modelFqn",
          or([
            "click: same node",
            "click: selected node"
          ])
        ]),
        actions: [
          assignLastClickedNode(),
          openSourceOfFocusedOrLastClickedNode(),
          openElementDetails(),
          emitNodeClick()
        ]
      },
      {
        actions: [
          assignLastClickedNode(),
          openSourceOfFocusedOrLastClickedNode(),
          emitNodeClick()
        ]
      }
    ],
    "xyflow.paneClick": {
      actions: [
        resetLastClickedNode(),
        emitPaneClick()
      ]
    },
    "xyflow.paneDblClick": {
      actions: [
        resetLastClickedNode(),
        enqueueActions(({ context: context2, enqueue, check }) => {
          check("enabled: FitView") && enqueue(fitDiagram$1()), enqueue(
            emitOpenSource({ view: context2.view.id })
          );
        })
      ]
    },
    "focus.node": [
      // Focus was initialed by the user searching (autoUnfocus=true) - always allowed
      {
        guard: "focus.node: autoUnfocus",
        actions: assignFocusedNode(),
        target: targetState.focused
      },
      // Regular focus - requires FocusMode to be enabled
      {
        guard: "enabled: FocusMode",
        actions: assignFocusedNode(),
        target: targetState.focused
      }
    ],
    "xyflow.edgeClick": {
      guard: and([
        "enabled: Readonly",
        "is dynamic view",
        "enabled: DynamicViewWalkthrough",
        "click: selected edge"
      ]),
      actions: [
        resetLastClickedNode(),
        raise(({ event }) => ({
          type: "walkthrough.start",
          stepId: event.edge.id
        })),
        emitEdgeClick()
      ]
    }
  }
}), printing = machine$1.createStateConfig({
  id: targetState.printing.slice(1),
  entry: [
    cancelFitDiagram$1(),
    assignViewportBefore(),
    enqueueActions(({ enqueue, context: context2 }) => {
      const bounds = context2.view.bounds, OFFSET = 16;
      enqueue(
        setViewport({
          viewport: {
            x: bounds.x + OFFSET,
            y: bounds.y + OFFSET,
            zoom: 1
          },
          duration: 0
        })
      );
    })
  ],
  exit: [
    returnViewportBefore({ delay: 0, duration: 0 })
  ],
  on: {
    "media.print.off": {
      target: targetState.idle
    },
    "*": {
      actions: [
        log(({ event }) => `Printing state - ignoring event: ${event.type}`)
      ]
    }
  }
}), updateActiveWalkthroughState = () => machine$1.enqueueActions(({ context: context2, enqueue }) => {
  const { activeWalkthrough } = context2;
  if (!activeWalkthrough) {
    console.warn("Active walkthrough is null"), enqueue.raise({ type: "walkthrough.end" });
    return;
  }
  const { stepId, parallelPrefix } = activeWalkthrough, step = context2.xyedges.find((x) => x.id === stepId);
  if (!step) {
    console.warn("Invalid walkthrough stepId:", stepId), enqueue.raise({ type: "walkthrough.end" });
    return;
  }
  enqueue.assign({
    xyedges: context2.xyedges.map((edge) => {
      const active = stepId === edge.id || !!parallelPrefix && edge.id.startsWith(parallelPrefix);
      return Base.setData(edge, {
        active,
        dimmed: stepId !== edge.id
      });
    }),
    xynodes: context2.xynodes.map((node2) => {
      const dimmed = step.source !== node2.id && step.target !== node2.id;
      return node2.type === "seq-parallel" ? Base.setData(node2, {
        color: parallelPrefix === node2.data.parallelPrefix ? SeqParallelAreaColor.active : SeqParallelAreaColor.default,
        dimmed
      }) : Base.setDimmed(node2, dimmed);
    })
  });
}), emitWalkthroughStarted = () => machine$1.emit(({ context: context2 }) => {
  const edge = context2.xyedges.find((x) => x.id === context2.activeWalkthrough?.stepId);
  return invariant$1(edge, "Invalid walkthrough state"), {
    type: "walkthroughStarted",
    edge
  };
}), emitWalkthroughStopped = () => machine$1.emit(() => ({
  type: "walkthroughStopped"
})), emitWalkthroughStep = () => machine$1.emit(({ context: context2 }) => {
  const edge = context2.xyedges.find((x) => x.id === context2.activeWalkthrough?.stepId);
  return invariant$1(edge, "Invalid walkthrough state"), {
    type: "walkthroughStep",
    edge
  };
}), walkthrough = machine$1.createStateConfig({
  id: targetState.walkthrough.slice(1),
  entry: [
    startHotKeyActor(),
    cancelEditing(),
    cancelFitDiagram$1(),
    assignViewportBefore(),
    assign({
      activeWalkthrough: ({ context: context2, event }) => {
        assertEvent(event, "walkthrough.start");
        const stepId = event.stepId ?? n$4(context2.xyedges).id;
        return {
          stepId,
          parallelPrefix: getParallelStepsPrefix(stepId)
        };
      }
    }),
    updateActiveWalkthroughState(),
    fitFocusedBounds(),
    emitWalkthroughStarted()
  ],
  exit: [
    stopHotKeyActor(),
    enqueueActions(({ enqueue, context: context2 }) => {
      enqueue.assign({
        activeWalkthrough: null
      }), context2.dynamicViewVariant === "sequence" && context2.activeWalkthrough?.parallelPrefix && enqueue.assign({
        xynodes: context2.xynodes.map((n2) => n2.type === "seq-parallel" ? Base.setData(n2, {
          color: SeqParallelAreaColor.default
        }) : n2)
      });
    }),
    undimEverything(),
    returnViewportBefore(),
    emitWalkthroughStopped()
  ],
  on: {
    "key.esc": {
      target: targetState.idle
    },
    "key.arrow.left": {
      actions: raise({ type: "walkthrough.step", direction: "previous" })
    },
    "key.arrow.up": {
      actions: raise({ type: "walkthrough.step", direction: "previous" })
    },
    "key.arrow.right": {
      actions: raise({ type: "walkthrough.step", direction: "next" })
    },
    "key.arrow.down": {
      actions: raise({ type: "walkthrough.step", direction: "next" })
    },
    "walkthrough.step": {
      actions: [
        assign(({ context: context2, event }) => {
          const { stepId } = context2.activeWalkthrough, stepIndex = context2.xyedges.findIndex((e2) => e2.id === stepId), nextStepIndex = t(event.direction === "next" ? stepIndex + 1 : stepIndex - 1, {
            min: 0,
            max: context2.xyedges.length - 1
          });
          if (nextStepIndex === stepIndex)
            return {};
          const nextStepId = context2.xyedges[nextStepIndex].id;
          return {
            activeWalkthrough: {
              stepId: nextStepId,
              parallelPrefix: getParallelStepsPrefix(nextStepId)
            }
          };
        }),
        updateActiveWalkthroughState(),
        fitFocusedBounds(),
        emitWalkthroughStep()
      ]
    },
    "xyflow.edgeClick": {
      actions: [
        assign(({ event, context: context2 }) => !isStepEdgeId(event.edge.id) || event.edge.id === context2.activeWalkthrough?.stepId ? {} : {
          activeWalkthrough: {
            stepId: event.edge.id,
            parallelPrefix: getParallelStepsPrefix(event.edge.id)
          }
        }),
        updateActiveWalkthroughState(),
        fitFocusedBounds(),
        emitEdgeClick(),
        emitWalkthroughStep()
      ]
    },
    "notations.unhighlight": {
      actions: updateActiveWalkthroughState()
    },
    "tag.unhighlight": {
      actions: updateActiveWalkthroughState()
    },
    "update.view": {
      guard: "is same view",
      actions: [
        updateView$1(),
        updateActiveWalkthroughState()
      ]
    },
    "walkthrough.end": {
      target: targetState.idle
    },
    "xyflow.paneDblClick": {
      target: targetState.idle
    }
  }
}), ready = machine$1.createStateConfig({
  initial: "idle",
  entry: [
    spawnChild("mediaPrintActorLogic", { id: "mediaPrint" }),
    ensureEditorActor(),
    ensureOverlaysActor(),
    ensureSearchActor()
  ],
  exit: [
    cancelFitDiagram$1(),
    stopChild("mediaPrint"),
    closeAllOverlays(),
    closeSearch(),
    stopEditorActor()
  ],
  states: {
    idle,
    focused,
    walkthrough,
    printing
  },
  on: {
    "navigate.*": {
      actions: handleNavigate()
    },
    "layout.align": {
      guard: "not readonly",
      actions: [
        startEditing("node"),
        layoutAlign(),
        stopEditing(!0)
      ]
    },
    "layout.resetEdgeControlPoints": {
      guard: "not readonly",
      actions: [
        startEditing("edge"),
        resetEdgesControlPoints(),
        stopEditing(!0)
      ]
    },
    "layout.resetManualLayout": {
      guard: "not readonly",
      actions: [
        cancelEditing(),
        disableCompareWithLatest(),
        triggerChange({
          op: "reset-manual-layout"
        })
      ]
    },
    "xyflow.resized": {
      guard: ({ context: context2 }) => context2.features.enableFitView && !context2.viewportChangedManually,
      actions: [
        cancelFitDiagram$1(),
        raiseFitDiagram$1({ delay: 200 })
      ]
    },
    "open.elementDetails": {
      actions: openOverlay()
    },
    "open.relationshipsBrowser": {
      actions: openOverlay()
    },
    "open.relationshipDetails": {
      actions: openOverlay()
    },
    "open.source": {
      guard: "enabled: OpenSource",
      actions: emitOpenSource()
    },
    "walkthrough.start": {
      guard: "is dynamic view",
      target: targetState.walkthrough
    },
    "toggle.feature": {
      actions: [
        assignToggledFeatures(),
        ensureEditorActor()
      ]
    },
    "update.features": {
      actions: [
        updateFeatures(),
        ensureOverlaysActor(),
        ensureSearchActor(),
        ensureEditorActor()
      ]
    },
    "xyflow.nodeMouseEnter": {
      actions: onNodeMouseEnter()
    },
    "xyflow.nodeMouseLeave": {
      actions: onNodeMouseLeave()
    },
    "xyflow.edgeMouseEnter": {
      actions: onEdgeMouseEnter()
    },
    "xyflow.edgeMouseLeave": {
      actions: onEdgeMouseLeave()
    },
    "xyflow.edgeDoubleClick": {
      guard: and([
        "not readonly",
        ({ event }) => !!event.edge.data.controlPoints && event.edge.data.controlPoints.length > 0
      ]),
      actions: [
        startEditing("edge"),
        onEdgeDoubleClick(),
        stopEditing(!0)
      ]
    },
    "notations.highlight": {
      actions: notationsHighlight()
    },
    "notations.unhighlight": {
      actions: undimEverything()
    },
    "tag.highlight": {
      actions: tagHighlight()
    },
    "tag.unhighlight": {
      actions: undimEverything()
    },
    "open.search": {
      guard: "enabled: Search",
      actions: sendTo(({ system }) => typedSystem(system).searchActorRef, ({ event }) => ({
        type: "open",
        search: event.search
      }))
    },
    "xyflow.paneClick": {
      actions: [
        resetLastClickedNode(),
        emitPaneClick()
      ]
    },
    "xyflow.nodeClick": {
      actions: [
        assignLastClickedNode(),
        emitNodeClick()
      ]
    },
    "xyflow.edgeClick": {
      actions: [
        resetLastClickedNode(),
        emitEdgeClick()
      ]
    },
    "xyflow.fitDiagram": {
      guard: "enabled: FitView",
      actions: fitDiagram$1()
    },
    "xyflow.setViewport": {
      actions: setViewport()
    },
    "update.view": [
      // Redirect to navigating state if received another view
      {
        guard: "is another view",
        target: targetState.navigating
      },
      // Otherwise, just update the view in place
      {
        actions: updateView$1()
      }
    ],
    "media.print.on": {
      target: targetState.printing
    }
  }
}), key$1 = "likec4:diagram:toggledFeatures", DiagramToggledFeaturesPersistence = {
  read() {
    try {
      let fromStorage = sessionStorage.getItem(key$1);
      return fromStorage ? JSON.parse(fromStorage) : null;
    } catch (e2) {
      return console.error(`Error reading fromStorage ${key$1}:`, e2), null;
    }
  },
  write(toggledFeatures) {
    return sessionStorage.setItem(key$1, JSON.stringify(t$2(toggledFeatures, e$c))), toggledFeatures;
  }
}, _diagramMachine = machine$1.createMachine({
  initial: "initializing",
  context: ({ input: input2 }) => ({
    ...input2,
    xyedges: [],
    xynodes: [],
    features: { ...DefaultFeatures },
    toggledFeatures: DiagramToggledFeaturesPersistence.read() ?? {
      enableReadOnly: !0,
      enableCompareWithLatest: !1
    },
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    viewportChangedManually: !1,
    lastOnNavigate: null,
    lastClickedNode: null,
    focusedNode: null,
    autoUnfocusTimer: !1,
    activeElementDetails: null,
    viewportBefore: null,
    viewportOnManualLayout: null,
    viewportOnAutoLayout: null,
    navigationHistory: {
      currentIndex: 0,
      history: []
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    xyflow: null,
    dynamicViewVariant: input2.dynamicViewVariant ?? (input2.view._type === "dynamic" ? input2.view.variant : "diagram") ?? "diagram",
    activeWalkthrough: null
  }),
  states: {
    initializing,
    isReady,
    ready,
    navigating,
    final: {
      type: "final",
      entry: [
        stopEditorActor(),
        cancelFitDiagram$1(),
        stopChild("hotkey"),
        stopChild("overlays"),
        stopChild("search"),
        stopChild("mediaPrint"),
        assign({
          xyflow: null,
          xystore: null,
          xyedges: [],
          xynodes: [],
          initialized: {
            xydata: !1,
            xyflow: !1
          }
        })
      ]
    }
  },
  on: {
    "update.nodeData": {
      actions: assign(updateNodeData)
    },
    "update.edgeData": {
      actions: assign(updateEdgeData)
    },
    "switch.dynamicViewVariant": {
      guard: ({ context: context2, event }) => context2.dynamicViewVariant !== event.variant,
      actions: [
        assignDynamicViewVariant(),
        raiseUpdateView()
      ]
    },
    "update.inputs": {
      actions: updateInputs()
    },
    "update.view-bounds": {
      actions: assign(({ context: context2, event }) => ({
        view: {
          ...context2.view,
          bounds: event.bounds
        }
      }))
    },
    "update.features": {
      actions: updateFeatures()
    },
    "trigger.change": {
      actions: triggerChange()
    },
    "emit.onLayoutTypeChange": {
      actions: emitOnLayoutTypeChange()
    },
    "xyflow.applyNodeChanges": {
      actions: assign({
        xynodes: ({ context: context2, event }) => applyNodeChanges(event.changes, context2.xynodes)
      })
    },
    "xyflow.applyEdgeChanges": {
      actions: assign({
        xyedges: ({ context: context2, event }) => applyEdgeChanges(event.changes, context2.xyedges)
      })
    },
    "xyflow.viewportMoved": {
      actions: assign(({ event, context: context2 }) => ({
        viewportChangedManually: context2.viewportChangedManually || event.manually,
        viewport: event.viewport
      }))
    },
    destroy: {
      target: ".final"
    }
  }
}), diagramMachine = _diagramMachine;
function DiagramActorProvider({
  view,
  zoomable,
  pannable,
  nodesDraggable,
  nodesSelectable,
  fitViewPadding,
  where,
  children,
  dynamicViewVariant: _defaultVariant
}) {
  const xystore = useStoreApi(), editorActor = useEditorActorLogic(view.id), actor = useActorRef(
    diagramMachine.provide({
      actors: {
        editorActor
      }
    }),
    {
      id: "diagram",
      systemId: "diagram",
      // ...inspector,
      input: {
        xystore,
        view,
        zoomable,
        pannable,
        fitViewPadding,
        nodesDraggable,
        nodesSelectable,
        where,
        dynamicViewVariant: _defaultVariant
      }
    }
  ), actorRef = useRef(actor);
  actorRef.current !== actor && (console.warn("DiagramMachine actor instance changed", {
    context: {
      previous: actorRef.current.getSnapshot().context,
      current: actor.getSnapshot().context
    }
  }), actorRef.current = actor);
  const [api, setApi] = useState(() => makeDiagramApi(actorRef));
  useEffect(() => {
    setApi((api2) => api2.ref === actorRef ? api2 : (console.warn(
      "DiagramMachine actorRef changed, creating new DiagramApi instance, this should not happen during the lifetime of the actor"
    ), makeDiagramApi(actorRef)));
  }, [actorRef]);
  const features = useEnabledFeatures();
  return useEffect(
    () => actor.send({ type: "update.features", features }),
    [features, actor]
  ), useEffect(
    () => actor.send({
      type: "update.inputs",
      inputs: { zoomable, where, pannable, fitViewPadding, nodesDraggable, nodesSelectable }
    }),
    [zoomable, where, pannable, fitViewPadding, actor, nodesDraggable, nodesSelectable]
  ), useUpdateEffect(() => {
    _defaultVariant && actor.send({ type: "switch.dynamicViewVariant", variant: _defaultVariant });
  }, [_defaultVariant, actor]), useRafEffect(
    () => actor.send({ type: "update.view", view, source: "external" }),
    [actor, view]
  ), /* @__PURE__ */ jsx(DiagramActorContextProvider, { value: actor, children: /* @__PURE__ */ jsxs(DiagramApiContextProvider, { value: api, children: [
    /* @__PURE__ */ jsx(ErrorBoundary, { children: /* @__PURE__ */ jsx(CurrentViewModelProvider, { actorRef: actor, children }) }),
    /* @__PURE__ */ jsx(DiagramActorEventListener, {})
  ] }) });
}
const selectFromActor = ({ context: context2 }) => {
  let toggledFeatures = context2.toggledFeatures;
  const hasDrifts2 = context2.view.drifts != null && context2.view.drifts.length > 0, enableCompareWithLatest = context2.features.enableCompareWithLatest && (toggledFeatures.enableCompareWithLatest ?? !1) && e$6(context2.activeWalkthrough) && hasDrifts2, enableReadOnly = context2.features.enableReadOnly || toggledFeatures.enableReadOnly || !!context2.activeWalkthrough || context2.dynamicViewVariant === "sequence" && context2.view._type === "dynamic" || enableCompareWithLatest && context2.view._layout === "auto";
  return (toggledFeatures.enableReadOnly !== enableReadOnly || toggledFeatures.enableCompareWithLatest !== enableCompareWithLatest) && (toggledFeatures = {
    ...toggledFeatures,
    enableCompareWithLatest,
    enableReadOnly
  }), {
    toggledFeatures,
    viewId: context2.view.id
  };
}, compareSelected = (a, b) => a.viewId === b.viewId && shallowEqual(a.toggledFeatures, b.toggledFeatures);
function CurrentViewModelProvider({ children, actorRef }) {
  const { viewId, toggledFeatures } = useSelector(
    actorRef,
    selectFromActor,
    compareSelected
  ), viewmodel = useLikeC4Model().findView(viewId);
  return /* @__PURE__ */ jsx(CurrentViewModelContext.Provider, { value: viewmodel, children: /* @__PURE__ */ jsx(DiagramFeatures, { overrides: toggledFeatures, children }) });
}
const DiagramActorEventListener = memo$1(() => {
  const diagram = useDiagram(), {
    onNavigateTo,
    onOpenSource,
    // onChange,
    onLayoutTypeChange,
    handlersRef
  } = useDiagramEventHandlers();
  useOnDiagramEvent("openSource", ({ params }) => onOpenSource?.(params)), useOnDiagramEvent("navigateTo", ({ viewId }) => onNavigateTo?.(viewId)), useOnDiagramEvent("onLayoutTypeChange", ({ layoutType }) => {
    onLayoutTypeChange?.(layoutType);
  }), useOnDiagramEvent(
    "initialized",
    ({ instance: xyflow2 }) => {
      try {
        handlersRef.current.onInitialized?.({ diagram, xyflow: xyflow2 });
      } catch (error) {
        console.error(error);
      }
    },
    { once: !0 }
  );
  const toggledFeatures = useDiagramContext(
    (ctx) => ctx.toggledFeatures,
    shallowEqual
  );
  return useUpdateEffect(() => {
    DiagramToggledFeaturesPersistence.write(t$n(toggledFeatures, e$6));
  }, [toggledFeatures]), null;
}), scheme = (scheme2) => `[data-mantine-color-scheme="${scheme2}"]`, whenDark = scheme("dark"), MAX_DEPTH = 5, generateCompoundColors = (rootSelector, name, colors, depth) => {
  const compoundDarkColor = (color) => toHex(
    scale(color, {
      l: -22 - 5 * depth,
      s: -10 - 6 * depth
    })
  ), compoundLightColor = (color) => toHex(
    scale(color, {
      l: -20 - 3 * depth,
      s: -3 - 6 * depth
    })
  ), selector3 = `:where(${rootSelector} [data-likec4-color="${name}"][data-compound-depth="${depth}"])`;
  return `
${selector3} {
  --likec4-palette-fill: ${compoundLightColor(colors.elements.fill)};
  --likec4-palette-stroke: ${compoundLightColor(colors.elements.stroke)};
}
${whenDark} ${selector3} {
  --likec4-palette-fill: ${compoundDarkColor(colors.elements.fill)};
  --likec4-palette-stroke: ${compoundDarkColor(colors.elements.stroke)};
}
  `.trim();
};
function toStyle(rootSelector, name, colors) {
  const { elements, relationships } = colors, selector3 = `:where(${rootSelector} [data-likec4-color=${name}])`;
  return [
    `
${selector3} {
  --likec4-palette-fill: ${elements.fill};
  --likec4-palette-stroke: ${elements.stroke};
  --likec4-palette-hiContrast: ${elements.hiContrast};
  --likec4-palette-loContrast: ${elements.loContrast};
  --likec4-palette-relation-stroke: ${relationships.line};
  --likec4-palette-relation-label: ${relationships.label};
  --likec4-palette-relation-label-bg: ${relationships.labelBg};
  --likec4-palette-relation-stroke-selected: ${toRgba(mix(relationships.line, "black", 85))};
}
${whenDark} ${selector3} {
  --likec4-palette-relation-stroke-selected: ${toRgba(mix(relationships.line, "white", 70))};
}

  `.trim(),
    ...t$o(1, MAX_DEPTH + 1).map((depth) => generateCompoundColors(rootSelector, name, colors, depth))
  ].join(`
`);
}
function generateBuiltInColorStyles(rootSelector, theme) {
  return t$6(
    theme.colors,
    t$9(),
    t$a(([color, values]) => toStyle(rootSelector, color, values)),
    t$7(`
`)
  );
}
const LikeC4Styles = memo$1(({ id }) => {
  const rootSelector = `#${id}`, nonce = useMantineStyleNonce()?.(), { theme } = useLikeC4Styles(), colorsStyles = generateBuiltInColorStyles(rootSelector, theme);
  return /* @__PURE__ */ jsx(
    "style",
    {
      type: "text/css",
      "data-likec4-colors": id,
      dangerouslySetInnerHTML: { __html: colorsStyles },
      nonce
    }
  );
});
function LikeC4Diagram({
  onCanvasClick,
  onCanvasContextMenu,
  onCanvasDblClick,
  onEdgeClick,
  onEdgeContextMenu,
  onNavigateTo,
  onNodeClick,
  onNodeContextMenu,
  onOpenSource,
  onLogoClick,
  onLayoutTypeChange,
  onInitialized,
  view,
  className,
  controls = !0,
  fitView = !0,
  fitViewPadding: _fitViewPadding = controls ? FitViewPaddings.withControls : FitViewPaddings.default,
  pannable = !0,
  zoomable = !0,
  background = "dots",
  enableElementTags = !1,
  enableFocusMode = !1,
  enableElementDetails = !1,
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = !1,
  enableCompareWithLatest = !!onLayoutTypeChange,
  nodesSelectable,
  enableNotations = !1,
  showNavigationButtons = !!onNavigateTo,
  enableDynamicViewWalkthrough = !1,
  dynamicViewVariant,
  enableSearch = !1,
  initialWidth,
  initialHeight,
  reduceGraphics = "auto",
  renderIcon,
  where,
  reactFlowProps,
  renderNodes,
  children
}) {
  const id = useId(), initialRef = useRef(null), hasEditor = !!useOptionalLikeC4EditorPort(), readonly = !hasEditor;
  nodesSelectable ??= hasEditor || enableFocusMode || !!onNavigateTo || !!onNodeClick;
  const bounds = pickViewBounds(view, dynamicViewVariant), fitViewPadding = useNormalizedViewPadding(_fitViewPadding);
  initialRef.current == null && (initialRef.current = {
    defaultEdges: [],
    defaultNodes: [],
    initialWidth: initialWidth ?? bounds.width,
    initialHeight: initialHeight ?? bounds.height,
    initialFitViewOptions: {
      maxZoom: MaxZoom,
      minZoom: MinZoom,
      padding: fitViewPadding
    },
    initialMaxZoom: MaxZoom,
    initialMinZoom: MinZoom
  });
  const isReducedGraphicsMode = reduceGraphics === "auto" ? pannable && (bounds.width ?? 1) * (bounds.height ?? 1) > 6e6 && view.nodes.some((n2) => n2.children?.length > 0) : reduceGraphics;
  return /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsx(
    FramerMotionConfig,
    {
      ...isReducedGraphicsMode && { reducedMotion: "always" },
      children: /* @__PURE__ */ jsx(IconRendererProvider, { value: renderIcon ?? null, children: /* @__PURE__ */ jsx(
        DiagramFeatures,
        {
          features: {
            enableFitView: fitView,
            enableEditor: hasEditor,
            enableReadOnly: readonly,
            enableFocusMode,
            enableNavigateTo: !!onNavigateTo,
            enableElementDetails,
            enableRelationshipDetails,
            enableRelationshipBrowser,
            enableSearch,
            enableNavigationButtons: showNavigationButtons && !!onNavigateTo,
            enableDynamicViewWalkthrough: view._type === "dynamic" && enableDynamicViewWalkthrough,
            enableNotations,
            enableVscode: !!onOpenSource,
            enableControls: controls,
            enableElementTags,
            enableCompareWithLatest: enableCompareWithLatest && !!onLayoutTypeChange
          },
          children: /* @__PURE__ */ jsxs(
            DiagramEventHandlers,
            {
              handlers: {
                onCanvasClick,
                onCanvasContextMenu,
                onCanvasDblClick,
                onEdgeClick,
                onEdgeContextMenu,
                onNavigateTo,
                onNodeClick,
                onNodeContextMenu,
                onOpenSource,
                onLogoClick,
                onInitialized,
                onLayoutTypeChange
              },
              children: [
                /* @__PURE__ */ jsx(LikeC4Styles, { id }),
                /* @__PURE__ */ jsx(TagStylesProvider, { rootSelector: `#${id}`, children: /* @__PURE__ */ jsx(RootContainer, { id, className, reduceGraphics: isReducedGraphicsMode, children: /* @__PURE__ */ jsx(
                  ReactFlowProvider,
                  {
                    fitView,
                    ...initialRef.current,
                    children: /* @__PURE__ */ jsxs(
                      DiagramActorProvider,
                      {
                        view,
                        zoomable,
                        pannable,
                        fitViewPadding,
                        nodesDraggable: hasEditor,
                        nodesSelectable,
                        where: where ?? null,
                        dynamicViewVariant,
                        children: [
                          /* @__PURE__ */ jsx(
                            LikeC4DiagramXYFlow,
                            {
                              background,
                              reactFlowProps,
                              renderNodes,
                              children
                            }
                          ),
                          /* @__PURE__ */ jsx(LikeC4DiagramUI, {})
                        ]
                      }
                    )
                  }
                ) }) })
              ]
            }
          )
        }
      ) })
    }
  ) });
}
const toLiteralPaddingWithUnit = (value) => typeof value == "number" ? `${value}px` : value;
function useNormalizedViewPadding(raw) {
  return useCustomCompareMemo(
    () => {
      if (e$d(raw))
        return t$p(raw, toLiteralPaddingWithUnit);
      const v = toLiteralPaddingWithUnit(raw);
      return {
        x: v,
        y: v
      };
    },
    [raw],
    deepEqual
  );
}
function LikeC4ModelProvider({
  children,
  likec4model
}) {
  return /* @__PURE__ */ jsx(LikeC4ModelContext.Provider, { value: likec4model, children });
}
function LikeC4ProjectsProvider({
  children,
  projects,
  onProjectChange: _onProjectChange
}) {
  useContext(LikeC4ProjectsContext) && console.warn("LikeC4ProjectsProvider should not be nested inside another one");
  const onProjectChange = useCallbackRef(_onProjectChange), [value, setValue] = useState(() => ({ projects, onProjectChange }));
  return useEffect(() => {
    setValue((current) => deepEqual(current.projects, projects) ? current : { projects, onProjectChange });
  }, [projects]), /* @__PURE__ */ jsx(LikeC4ProjectsContext.Provider, { value, children });
}
function StaticLikeC4Diagram({
  view,
  fitView = !0,
  fitViewPadding = "8px",
  enableRelationshipDetails = !1,
  enableRelationshipBrowser = enableRelationshipDetails,
  background = "transparent",
  className,
  ...rest
}) {
  return /* @__PURE__ */ jsx(
    LikeC4Diagram,
    {
      view,
      className: cx(className, "likec4-static-view"),
      fitView,
      fitViewPadding,
      pannable: !1,
      zoomable: !1,
      controls: !1,
      background,
      enableNotations: !1,
      enableElementDetails: !1,
      enableRelationshipDetails,
      enableRelationshipBrowser,
      enableDynamicViewWalkthrough: !1,
      showNavigationButtons: !1,
      enableCompareWithLatest: !1,
      enableFocusMode: !1,
      enableSearch: !1,
      nodesSelectable: !1,
      enableElementTags: !1,
      ...rest
    }
  );
}
function layoutedProjectsViewToXYFlow(view) {
  return {
    xynodes: t$a(view.nodes, projectNodeToXY),
    xyedges: t$a(view.edges, projectEdgeToXY)
  };
}
function projectNodeToXY({ id, x, y, width, height, ...node2 }) {
  return {
    id,
    position: { x, y },
    type: "project",
    initialWidth: width,
    initialHeight: height,
    draggable: !1,
    deletable: !1,
    zIndex: ZIndexes.Element,
    style: {
      width,
      height
    },
    data: {
      id,
      width,
      height,
      ...node2
    }
  };
}
function projectEdgeToXY({ id, source, target, ...edge }) {
  return {
    id,
    source,
    target,
    type: "relationship",
    zIndex: ZIndexes.Edge,
    deletable: !1,
    data: {
      id,
      technology: null,
      labelBBox: null,
      ...edge
    }
  };
}
const key = "likec4:projects-overview:lastViewport", ProjectsOverviewViewportPersistence = {
  read() {
    try {
      let fromStorage = sessionStorage.getItem(key);
      return fromStorage ? JSON.parse(fromStorage) : null;
    } catch (e2) {
      return console.error(`Error reading fromStorage ${key}:`, e2), null;
    }
  },
  write(viewport) {
    if (!viewport) {
      sessionStorage.removeItem(key);
      return;
    }
    sessionStorage.setItem(key, JSON.stringify(viewport));
  }
}, machine = setup({
  guards: {
    isReady: ({ context: context2 }) => context2.initialized.xydata && context2.initialized.xyflow && !!context2.xystore && !!context2.xyflow,
    "click: selected node": ({ event }) => (assertEvent(event, ["xyflow.click.node"]), event.node.selected === !0)
  }
}), updateView = () => machine.assign(({ event }) => {
  assertEvent(event, "update.view");
  const { xynodes, xyedges } = layoutedProjectsViewToXYFlow(event.view);
  return {
    view: event.view,
    xynodes,
    xyedges
  };
}), xyflowApplyNodeChanges = () => machine.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyNodeChanges"), {
  xynodes: applyNodeChanges(event.changes, context2.xynodes)
})), xyflowApplyEdgeChanges = () => machine.assign(({ context: context2, event }) => (assertEvent(event, "xyflow.applyEdgeChanges"), {
  xyedges: applyEdgeChanges(event.changes, context2.xyedges)
})), onMouseEnterOrLeave = () => machine.assign(({ context: context2, event }) => {
  assertEvent(event, [
    "xyflow.mouse.enter.edge",
    "xyflow.mouse.leave.edge",
    "xyflow.mouse.enter.node",
    "xyflow.mouse.leave.node"
  ]);
  const isEnter = event.type.startsWith("xyflow.mouse.enter");
  switch (event.type) {
    case "xyflow.mouse.enter.edge":
    case "xyflow.mouse.leave.edge": {
      const edgeId = event.edge.id;
      return {
        xyedges: context2.xyedges.map((e2) => e2.id === edgeId ? Base.setHovered(e2, isEnter) : e2)
      };
    }
    case "xyflow.mouse.enter.node":
    case "xyflow.mouse.leave.node": {
      const nodeId = event.node.id;
      return {
        xynodes: context2.xynodes.map((n2) => n2.id === nodeId ? Base.setHovered(n2, isEnter) : n2)
      };
    }
    default:
      nonexhaustive(event);
  }
}), saveViewport = () => machine.createAction(({ context: context2 }) => {
  const xyflow2 = context2.xyflow;
  xyflow2 && ProjectsOverviewViewportPersistence.write(xyflow2.getViewport());
}), handleClick = () => machine.enqueueActions(({ event, enqueue }) => {
  if (event.type === "xyflow.click.double") {
    enqueue(cancelFitDiagram()), enqueue(raiseFitDiagram());
    return;
  }
  if (event.type === "xyflow.click.pane") {
    enqueue(cancelFitDiagram());
    return;
  }
  console.warn("Unknown event", event);
}), cancelFitDiagram = () => machine.cancel("fitDiagram"), raiseFitDiagram = (params) => {
  const { delay: delay2 = 30, ...rest } = {};
  return machine.raise(
    {
      type: "xyflow.fitDiagram",
      ...rest
    },
    {
      id: "fitDiagram",
      delay: delay2
    }
  );
}, fitDiagram = (params) => machine.enqueueActions(({ context: context2, event, enqueue }) => {
  enqueue(cancelFitDiagram());
  let bounds = context2.view.bounds, duration;
  params ? (bounds = params.bounds ?? context2.view.bounds, duration = params.duration) : event.type === "xyflow.fitDiagram" && (bounds = event.bounds ?? context2.view.bounds, duration = event.duration), duration ??= 450;
  const { width, height, panZoom, transform } = nonNullable$1(context2.xystore).getState(), maxZoom = Math.max(1, transform[2]), viewport = getViewportForBounds(
    bounds,
    width,
    height,
    MinZoom,
    maxZoom,
    context2.fitViewPadding
  );
  viewport.x = Math.round(viewport.x), viewport.y = Math.round(viewport.y);
  const animationProps = duration > 0 ? { duration, interpolate: "smooth" } : void 0;
  panZoom?.setViewport(viewport, animationProps).catch((err) => {
    console.error("Error during fitDiagram panZoom setViewport", { err });
  }), ProjectsOverviewViewportPersistence.write(null);
}), restoreViewport = () => machine.enqueueActions(({ context: context2, enqueue }) => {
  const viewport = ProjectsOverviewViewportPersistence.read();
  if (viewport) {
    nonNullable$1(context2.xyflow).setViewport(viewport, {
      duration: 0
    });
    return;
  }
  enqueue(fitDiagram({ duration: 0 }));
}), dispose = () => machine.assign({
  xyflow: null,
  xystore: null,
  initialized: {
    xyflow: !1,
    xydata: !1
  },
  xyedges: [],
  xynodes: []
}), assignNavigateTo = () => machine.assign(({ event, context: context2 }) => {
  let navigateTo;
  switch (event.type) {
    case "xyflow.click.node": {
      navigateTo = event.node;
      break;
    }
    case "navigate.to": {
      navigateTo = nonNullable$1(context2.xynodes.find((n2) => n2.id === event.fromNode), `Node ${event.fromNode} not found`);
      break;
    }
    default:
      return console.warn(`Unexpected event ${event.type} in assignNavigateTo`), {};
  }
  return {
    navigateTo
  };
}), _projectOverviewLogic = machine.createMachine({
  id: "projects-overview",
  context: ({ input: input2 }) => ({
    ...input2,
    initialized: {
      xydata: !1,
      xyflow: !1
    },
    xyflow: null,
    xystore: null,
    xynodes: [],
    xyedges: []
  }),
  initial: "init",
  on: {
    close: {
      target: ".closed"
    }
  },
  states: {
    init: {
      on: {
        "update.view": {
          actions: [
            updateView(),
            assign(({ context: context2 }) => ({
              initialized: {
                ...context2.initialized,
                xydata: !0
              }
            }))
          ],
          target: "isReady"
        },
        "xyflow.init": {
          actions: [
            assign(({ context: context2, event }) => ({
              initialized: {
                ...context2.initialized,
                xyflow: !0
              },
              xyflow: event.xyflow,
              xystore: event.xystore
            }))
          ],
          target: "isReady"
        }
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        target: "active"
      }, {
        target: "init"
      }]
    },
    active: {
      tags: "active",
      entry: [
        restoreViewport()
      ],
      on: {
        "navigate.to": {
          actions: assignNavigateTo(),
          target: "navigate"
        },
        "xyflow.applyNodeChanges": {
          actions: xyflowApplyNodeChanges()
        },
        "xyflow.applyEdgeChanges": {
          actions: xyflowApplyEdgeChanges()
        },
        "xyflow.mouse.*": {
          actions: onMouseEnterOrLeave()
        },
        "xyflow.click.node": [
          {
            guard: "click: selected node",
            actions: assignNavigateTo(),
            target: "navigate"
          }
        ],
        "xyflow.click.*": {
          actions: handleClick()
        },
        "xyflow.fitDiagram": {
          actions: fitDiagram()
        },
        "update.view": {
          actions: updateView()
        }
      }
    },
    navigate: {
      tags: "active",
      entry: [
        cancelFitDiagram(),
        saveViewport(),
        assign({
          xyedges: []
        }),
        ({ context: { navigateTo, xyflow: xyflow2, xystore }, self }) => {
          invariant$1(xyflow2 && navigateTo, "Invalid state, xyflow is undefined");
          const { width, domNode } = nonNullable$1(xystore).getState(), nextZoom = t(
            Math.min(
              width * 2 / 3 / navigateTo.data.width
              // (height - 200) / (navigateTo.data.height),
            ),
            { min: MinZoom, max: 2.5 }
          ), next = {
            x: Math.round(
              -nextZoom * navigateTo.position.x + (width - nextZoom * navigateTo.data.width) / 2
            ),
            y: Math.round(-nextZoom * navigateTo.position.y) + 50
          }, current = xyflow2.getViewport(), otherNodes = domNode.querySelectorAll(
            `.react-flow__node-project:not([data-id="${navigateTo.id}"]) > *`
          ), otherNodesAnimation = animate(otherNodes, {
            opacity: 0,
            scale: 0.9
          }, {
            visualDuration: 0.25,
            delay: stagger(0.08, { from: "center" })
          }), v = motionValue(1), transform = mapValue(
            v,
            [1, 0],
            [
              `translate(${current.x}px, ${current.y}px) scale(${current.zoom})`,
              `translate(${next.x}px, ${next.y}px) scale(${nextZoom})`
            ]
          ), cancelViewportAnimation = styleEffect(
            domNode.querySelector(".xyflow__viewport"),
            { transform }
          ), cancelOpacityAnimation = styleEffect(
            domNode.querySelector(`.react-flow__node-project:is([data-id="${navigateTo.id}"]) > *`),
            { opacity: v }
          ), targetAnimation = animate(
            v,
            0,
            {
              delay: otherNodes.length > 3 ? 0.25 : 0,
              type: "spring",
              stiffness: 350,
              damping: 40,
              mass: 1.5,
              visualDuration: 0.55
            }
          );
          Promise.race([
            targetAnimation.finished,
            sleep(750)
          ]).then(() => {
            cancelViewportAnimation(), cancelOpacityAnimation(), targetAnimation.stop(), otherNodesAnimation.stop(), self.send({
              type: "emit.navigate.to",
              projectId: navigateTo.data.projectId
            });
          });
        }
      ],
      on: {
        "emit.navigate.to": {
          actions: emit(({ event }) => ({
            ...event,
            type: "navigate.to"
          }))
        }
      }
    },
    closed: {
      id: "closed",
      type: "final",
      entry: dispose()
    }
  }
}), projectOverviewLogic = _projectOverviewLogic;
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const ProjectsOverviewActorContext = createContext(null);
function useProjectsOverviewActor() {
  return nonNullable$1(useContext(ProjectsOverviewActorContext), "No ProjectsOverviewActorContext");
}
const { withProvider, withContext } = createStyleContext(navigationPanel), shouldForwardProp = (prop, variantKeys) => isValidMotionProp(prop) || !variantKeys.includes(prop) && !isCssProperty(prop), LogoButton = forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxs(
  "button",
  {
    ...props,
    ref,
    className: cx(
      "mantine-active",
      className
    ),
    children: [
      /* @__PURE__ */ jsx("div", {}),
      /* @__PURE__ */ jsx(
        Logo$1,
        {
          className: css({
            display: {
              base: "none",
              "@/md": "block"
            }
          })
        }
      ),
      /* @__PURE__ */ jsx(
        Logo$1,
        {
          className: css({
            display: {
              base: "block",
              "@/md": "none"
            }
          })
        }
      )
    ]
  }
)), Root = withProvider(MotionDiv, "root", {
  shouldForwardProp
}), Body = withContext(MotionDiv, "body", {
  shouldForwardProp
}), Logo = withContext(LogoButton, "logo"), Label = withContext(MotionDiv, "label", {
  shouldForwardProp
});
withContext(MotionDiv, "dropdown", {
  shouldForwardProp
});
const NavigationPanel = {
  Root,
  Body,
  Logo,
  Label
}, ProjectsOverviewPanel = () => /* @__PURE__ */ jsx(NavigationPanel.Root, { size: "lg", children: /* @__PURE__ */ jsxs(NavigationPanel.Body, { children: [
  /* @__PURE__ */ jsx(NavigationPanel.Logo, {}),
  /* @__PURE__ */ jsx(NavigationPanel.Label, { children: "Projects Overview" })
] }) }), RelationshipEdge = memoEdge((edgeProps) => {
  const path = bezierPath(edgeProps.data.points);
  return /* @__PURE__ */ jsxs(EdgeContainer, { ...edgeProps, children: [
    /* @__PURE__ */ jsx(
      EdgePath,
      {
        edgeProps,
        svgPath: path
      }
    ),
    /* @__PURE__ */ jsx(EdgeLabelContainer, { edgeProps, children: /* @__PURE__ */ jsx(EdgeLabel, { edgeProps }) })
  ] });
});
function ProjectNode(props) {
  const actor = useProjectsOverviewActor(), navigateTo = useCallbackRef$1((e2) => {
    e2.stopPropagation(), actor.send({ type: "navigate.to", fromNode: props.data.id, projectId: props.data.projectId });
  });
  return /* @__PURE__ */ jsxs(
    ElementNodeContainer,
    {
      layout: !0,
      nodeProps: props,
      children: [
        /* @__PURE__ */ jsx(ElementShape, { ...props }),
        /* @__PURE__ */ jsx(ElementData, { ...props }),
        /* @__PURE__ */ jsx(
          ElementActionButtons,
          {
            ...props,
            buttons: [
              {
                key: "navigate",
                icon: /* @__PURE__ */ jsx(IconZoomScan, {}),
                onClick: navigateTo
              }
            ]
          }
        ),
        /* @__PURE__ */ jsx(DefaultHandles, {})
      ]
    },
    props.id
  );
}
function useProjectsOverviewState(selector3, compare2 = shallowEqual) {
  const actor = useProjectsOverviewActor();
  return useSelector(actor, selector3, compare2);
}
function useProjectsOverviewXYStoreApi() {
  return useStoreApi();
}
const nodeTypes = {
  project: ProjectNode
}, edgeTypes = {
  relationship: RelationshipEdge
}, selector = (state) => ({
  isActive: state.hasTag("active"),
  nodes: state.context.xynodes,
  edges: state.context.xyedges
}), selectorEq = (a, b) => a.isActive === b.isActive && shallowEqual(a.nodes, b.nodes) && shallowEqual(a.edges, b.edges), ProjectsOverviewXY = memo$1(({
  background = "dots",
  ...props
}) => {
  const actorRef = useProjectsOverviewActor(), {
    isActive,
    nodes,
    edges
  } = useProjectsOverviewState(
    selector,
    selectorEq
  ), xystore = useProjectsOverviewXYStoreApi();
  return /* @__PURE__ */ jsx(
    BaseXYFlow,
    {
      nodes,
      edges,
      className: cx(
        isActive ? "initialized" : "not-initialized",
        "projects-overview"
      ),
      nodeTypes,
      edgeTypes,
      fitView: !1,
      onNodeClick: useCallbackRef((_e, node2) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.node", node: node2 });
      }),
      onEdgeClick: useCallbackRef((_e, edge) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.edge", edge });
      }),
      onPaneClick: useCallbackRef((_e) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.pane" });
      }),
      onDoubleClick: useCallbackRef((_e) => {
        _e.stopPropagation(), actorRef.send({ type: "xyflow.click.double" });
      }),
      onNodesChange: useCallbackRef((changes) => {
        actorRef.send({ type: "xyflow.applyNodeChanges", changes });
      }),
      onEdgesChange: useCallbackRef((changes) => {
        actorRef.send({ type: "xyflow.applyEdgeChanges", changes });
      }),
      onEdgeMouseEnter: useCallbackRef((event, edge) => {
        actorRef.send({ type: "xyflow.mouse.enter.edge", edge, event });
      }),
      onEdgeMouseLeave: useCallbackRef((event, edge) => {
        actorRef.send({ type: "xyflow.mouse.leave.edge", edge, event });
      }),
      onNodeMouseEnter: useCallbackRef((event, node2) => {
        actorRef.send({ type: "xyflow.mouse.enter.node", node: node2 });
      }),
      onNodeMouseLeave: useCallbackRef((event, node2) => {
        actorRef.send({ type: "xyflow.mouse.leave.node", node: node2 });
      }),
      onInit: useCallbackRef((xyflow2) => {
        actorRef.send({ type: "xyflow.init", xyflow: xyflow2, xystore });
      }),
      nodesDraggable: !1,
      nodesSelectable: !0,
      pannable: !0,
      zoomable: !0,
      background,
      ...props
    }
  );
});
ProjectsOverviewXY.displayName = "ProjectsOverviewXY";
function ProjectsOverview({
  view,
  onNavigateToProject,
  fitViewPadding = {
    top: "50px",
    bottom: "32px",
    left: "32px",
    right: "32px"
  },
  ...props
}) {
  const actorRef = useActorRef(
    projectOverviewLogic,
    {
      input: { view, fitViewPadding }
    }
  );
  useEffect(() => {
    actorRef.send({ type: "update.view", view });
  }, [actorRef, view]);
  const onNavigateToProjectRef = useSyncedRef(onNavigateToProject);
  useEffect(() => {
    const subs = [
      actorRef.on("navigate.to", ({ projectId }) => {
        onNavigateToProjectRef.current?.(projectId);
      })
    ];
    return () => {
      subs.forEach((sub) => sub.unsubscribe());
    };
  }, [actorRef]);
  const bounds = view.bounds, initialRef = useRef({
    initialNodes: [],
    initialEdges: [],
    initialWidth: bounds.width,
    initialHeight: bounds.height,
    fitView: !1
  });
  return /* @__PURE__ */ jsx(ProjectsOverviewActorContext.Provider, { value: actorRef, children: /* @__PURE__ */ jsxs(ReactFlowProvider, { ...initialRef.current, children: [
    /* @__PURE__ */ jsx(LayoutGroup, { id: actorRef.sessionId, inherit: !1, children: /* @__PURE__ */ jsx(ProjectsOverviewXY, { ...props }) }),
    /* @__PURE__ */ jsx(ProjectsOverviewPanel, {})
  ] }) });
}
function LikeC4ProjectsOverview({
  view,
  className,
  onNavigateToProject,
  ...props
}) {
  const onChangeLikeC4Project = useChangeLikeC4Project(), id = useId();
  return onNavigateToProject ??= onChangeLikeC4Project, /* @__PURE__ */ jsx(EnsureMantine, { children: /* @__PURE__ */ jsxs(FramerMotionConfig, { children: [
    /* @__PURE__ */ jsx(LikeC4Styles, { id }),
    /* @__PURE__ */ jsx(RootContainer, { id, className, children: /* @__PURE__ */ jsx(
      ProjectsOverview,
      {
        view,
        onNavigateToProject,
        ...props
      }
    ) })
  ] }) });
}
export {
  Box as B,
  IconRendererProvider as I,
  LikeC4ProjectsProvider as L,
  Markdown as M,
  StaticLikeC4Diagram as S,
  LikeC4ModelProvider as a,
  useLikeC4Model as b,
  css as c,
  IconStarFilled as d,
  IconStack2 as e,
  IconLayoutDashboard as f,
  IconFileCode as g,
  IconFolderOpen as h,
  IconFolderFilled as i,
  IconArrowLeft as j,
  IconMoonStars as k,
  IconSun as l,
  useLikeC4Projects as m,
  IconChevronDown as n,
  IconAlertTriangle as o,
  IconCheck as p,
  IconCopy as q,
  IconExternalLink as r,
  IconShare as s,
  pickViewBounds as t,
  useUpdateEffect as u,
  LikeC4Diagram as v,
  useDiagramContext as w,
  LikeC4EditorProvider as x,
  useChangeLikeC4Project as y,
  LikeC4ProjectsOverview as z
};
